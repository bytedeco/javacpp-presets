// Targeted by JavaCPP version 1.4.2-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.cuda.*;
import static org.bytedeco.javacpp.nvinfer.*;

public class nvparsers extends org.bytedeco.javacpp.presets.nvparsers {
    static { Loader.load(); }

// Parsed from NvCaffeParser.h

/*
 * Copyright 1993-2016 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO LICENSEE:
 *
 * This source code and/or documentation ("Licensed Deliverables") are
 * subject to NVIDIA intellectual property rights under U.S. and
 * international Copyright laws.
 *
 * These Licensed Deliverables contained herein is PROPRIETARY and
 * CONFIDENTIAL to NVIDIA and is being provided under the terms and
 * conditions of a form of NVIDIA software license agreement by and
 * between NVIDIA and Licensee ("License Agreement") or electronically
 * accepted by Licensee.  Notwithstanding any terms or conditions to
 * the contrary in the License Agreement, reproduction or disclosure
 * of the Licensed Deliverables to any third party without the express
 * written consent of NVIDIA is prohibited.
 *
 * NOTWITHSTANDING ANY TERMS OR CONDITIONS TO THE CONTRARY IN THE
 * LICENSE AGREEMENT, NVIDIA MAKES NO REPRESENTATION ABOUT THE
 * SUITABILITY OF THESE LICENSED DELIVERABLES FOR ANY PURPOSE.  IT IS
 * PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.
 * NVIDIA DISCLAIMS ALL WARRANTIES WITH REGARD TO THESE LICENSED
 * DELIVERABLES, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY,
 * NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * NOTWITHSTANDING ANY TERMS OR CONDITIONS TO THE CONTRARY IN THE
 * LICENSE AGREEMENT, IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY
 * SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, OR ANY
 * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THESE LICENSED DELIVERABLES.
 *
 * U.S. Government End Users.  These Licensed Deliverables are a
 * "commercial item" as that term is defined at 48 C.F.R. 2.101 (OCT
 * 1995), consisting of "commercial computer software" and "commercial
 * computer software documentation" as such terms are used in 48
 * C.F.R. 12.212 (SEPT 1995) and is provided to the U.S. Government
 * only as a commercial end item.  Consistent with 48 C.F.R.12.212 and
 * 48 C.F.R. 227.7202-1 through 227.7202-4 (JUNE 1995), all
 * U.S. Government End Users acquire the Licensed Deliverables with
 * only those rights set forth herein.
 *
 * Any use of the Licensed Deliverables in individual and commercial
 * software must include, in the user documentation and internal
 * comments to the code, the above Disclaimer and U.S. Government End
 * Users Notice.
 */

// #ifndef NV_CAFFE_PARSER_H
// #define NV_CAFFE_PARSER_H

// #include "NvInfer.h"
    @Namespace("ditcaffe") @Opaque public static class NetParameter extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public NetParameter() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public NetParameter(Pointer p) { super(p); }
    }


// owned by the parser: goes away when the parser does
@Namespace("nvcaffeparser1") public static class IBlobNameToTensor extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IBlobNameToTensor(Pointer p) { super(p); }

    public native ITensor find(String name);
    public native ITensor find(@Cast("const char*") BytePointer name);
}

@Namespace("nvcaffeparser1") public static class IBinaryProtoBlob extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IBinaryProtoBlob(Pointer p) { super(p); }

    public native @Const Pointer getData();
    public native @ByVal DimsNCHW getDimensions();
    public native DataType getDataType();
    public native void destroy();
}

@Namespace("nvcaffeparser1") public static class IPluginFactory extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IPluginFactory(Pointer p) { super(p); }

    public native @Cast("bool") boolean isPlugin(String layerName);
    public native @Cast("bool") boolean isPlugin(@Cast("const char*") BytePointer layerName);
    public native IPlugin createPlugin(String layerName, @Const Weights weights, int nbWeights);
    public native IPlugin createPlugin(@Cast("const char*") BytePointer layerName, @Const Weights weights, int nbWeights);
}

@Namespace("nvcaffeparser1") public static class IPluginFactoryExt extends IPluginFactory {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IPluginFactoryExt(Pointer p) { super(p); }

    public native int getVersion();
    public native @Cast("bool") boolean isPluginExt(String layerName);
    public native @Cast("bool") boolean isPluginExt(@Cast("const char*") BytePointer layerName);
}

@Namespace("nvcaffeparser1") public static class ICaffeParser extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ICaffeParser(Pointer p) { super(p); }

    public native @Const IBlobNameToTensor parse(String deploy,
                                                  String model,
                                                  @ByRef INetworkDefinition network,
                                                  DataType weightType);
    public native @Const IBlobNameToTensor parse(@Cast("const char*") BytePointer deploy,
                                                  @Cast("const char*") BytePointer model,
                                                  @ByRef INetworkDefinition network,
                                                  @Cast("nvinfer1::DataType") int weightType);

    public native void setProtobufBufferSize(@Cast("size_t") long size);
    public native void setPluginFactory(IPluginFactory factory);
    public native IBinaryProtoBlob parseBinaryProto(String fileName);
    public native IBinaryProtoBlob parseBinaryProto(@Cast("const char*") BytePointer fileName);
    public native void destroy();
    public native void setPluginFactoryExt(IPluginFactoryExt factory);
}

@Namespace("nvcaffeparser1") public static native ICaffeParser createCaffeParser();
@Namespace("nvcaffeparser1") public static native void shutdownProtobufLibrary();


// #endif


// Parsed from NvUffParser.h

/*
 * Copyright 1993-2017 NVIDIA Corporation.  All rights reserved.
 *
 * NOTICE TO LICENSEE:
 *
 * This source code and/or documentation ("Licensed Deliverables") are
 * subject to NVIDIA intellectual property rights under U.S. and
 * international Copyright laws.
 *
 * These Licensed Deliverables contained herein is PROPRIETARY and
 * CONFIDENTIAL to NVIDIA and is being provided under the terms and
 * conditions of a form of NVIDIA software license agreement by and
 * between NVIDIA and Licensee ("License Agreement") or electronically
 * accepted by Licensee.  Notwithstanding any terms or conditions to
 * the contrary in the License Agreement, reproduction or disclosure
 * of the Licensed Deliverables to any third party without the express
 * written consent of NVIDIA is prohibited.
 *
 * NOTWITHSTANDING ANY TERMS OR CONDITIONS TO THE CONTRARY IN THE
 * LICENSE AGREEMENT, NVIDIA MAKES NO REPRESENTATION ABOUT THE
 * SUITABILITY OF THESE LICENSED DELIVERABLES FOR ANY PURPOSE.  IT IS
 * PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.
 * NVIDIA DISCLAIMS ALL WARRANTIES WITH REGARD TO THESE LICENSED
 * DELIVERABLES, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY,
 * NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE.
 * NOTWITHSTANDING ANY TERMS OR CONDITIONS TO THE CONTRARY IN THE
 * LICENSE AGREEMENT, IN NO EVENT SHALL NVIDIA BE LIABLE FOR ANY
 * SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, OR ANY
 * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
 * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THESE LICENSED DELIVERABLES.
 *
 * U.S. Government End Users.  These Licensed Deliverables are a
 * "commercial item" as that term is defined at 48 C.F.R. 2.101 (OCT
 * 1995), consisting of "commercial computer software" and "commercial
 * computer software documentation" as such terms are used in 48
 * C.F.R. 12.212 (SEPT 1995) and is provided to the U.S. Government
 * only as a commercial end item.  Consistent with 48 C.F.R.12.212 and
 * 48 C.F.R. 227.7202-1 through 227.7202-4 (JUNE 1995), all
 * U.S. Government End Users acquire the Licensed Deliverables with
 * only those rights set forth herein.
 *
 * Any use of the Licensed Deliverables in individual and commercial
 * software must include, in the user documentation and internal
 * comments to the code, the above Disclaimer and U.S. Government End
 * Users Notice.
 */

// #ifndef NV_UFF_PARSER_H
// #define NV_UFF_PARSER_H

// #include "NvInfer.h"

//Current supported Universal Framework Format (UFF) version for the parser.
public static final int UFF_REQUIRED_VERSION_MAJOR = 0;
public static final int UFF_REQUIRED_VERSION_MINOR = 3;
public static final int UFF_REQUIRED_VERSION_PATCH = 0;

/**
* \enum UffInputOrder
* \brief The different possible supported input order
*/
@Namespace("nvuffparser") public enum UffInputOrder {
    /** NCHW order */
    kNCHW(0),
    /** NHWC order */
    kNHWC(1),
    /** NC order */
    kNC(2);

    public final int value;
    private UffInputOrder(int v) { this.value = v; }
    private UffInputOrder(UffInputOrder e) { this.value = e.value; }
    public UffInputOrder intern() { for (UffInputOrder e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/**
* \enum FieldType
* \brief The possible field types for custom layer
*/

@Namespace("nvuffparser") public enum FieldType {
    /** FP32 field type */
    kFLOAT(0),
    /** INT32 field type */
    kINT32(1),
    /** char field type. String for length>1 */
    kCHAR(2),
    /** nvinfer1::Dims field type */
    kDIMS(4),
    /** nvinfer1::DataType field type */
    kDATATYPE(5),
    kUNKNOWN(6);

    public final int value;
    private FieldType(int v) { this.value = v; }
    private FieldType(FieldType e) { this.value = e.value; }
    public FieldType intern() { for (FieldType e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/**
 * \class FieldMap
 *
 * \brief an array of field params used as a layer parameter for plugin layers
 *
 * The node fields are passed by the parser to the API through the plugin
 * constructor. The implementation of the plugin should parse the contents of
 * the fieldMap as part of the plugin constructor
 */
@Namespace("nvuffparser") @NoOffset public static class FieldMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FieldMap(Pointer p) { super(p); }

    @MemberGetter public native String name();
    @MemberGetter public native @Const Pointer data();
    public native FieldType type(); public native FieldMap type(FieldType type);
    public native int length(); public native FieldMap length(int length);

    public FieldMap(String name, @Const Pointer data, FieldType type, int length/*=1*/) { super((Pointer)null); allocate(name, data, type, length); }
    private native void allocate(String name, @Const Pointer data, FieldType type, int length/*=1*/);
    public FieldMap(String name, @Const Pointer data, FieldType type) { super((Pointer)null); allocate(name, data, type); }
    private native void allocate(String name, @Const Pointer data, FieldType type);
    public FieldMap(@Cast("const char*") BytePointer name, @Const Pointer data, @Cast("nvuffparser::FieldType") int type, int length/*=1*/) { super((Pointer)null); allocate(name, data, type, length); }
    private native void allocate(@Cast("const char*") BytePointer name, @Const Pointer data, @Cast("nvuffparser::FieldType") int type, int length/*=1*/);
    public FieldMap(@Cast("const char*") BytePointer name, @Const Pointer data, @Cast("nvuffparser::FieldType") int type) { super((Pointer)null); allocate(name, data, type); }
    private native void allocate(@Cast("const char*") BytePointer name, @Const Pointer data, @Cast("nvuffparser::FieldType") int type);
}

@Namespace("nvuffparser") public static class FieldCollection extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public FieldCollection() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public FieldCollection(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FieldCollection(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public FieldCollection position(long position) {
        return (FieldCollection)super.position(position);
    }

    public native int nbFields(); public native FieldCollection nbFields(int nbFields);
    @MemberGetter public native @Const FieldMap fields();
}


@Name("nvuffparser::IPluginFactory") public static class IUffPluginFactory extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IUffPluginFactory(Pointer p) { super(p); }

    public native @Cast("bool") boolean isPlugin(String layerName);
    public native @Cast("bool") boolean isPlugin(@Cast("const char*") BytePointer layerName);
    public native IPlugin createPlugin(String layerName, @Const Weights weights, int nbWeights,
                                                @Const @ByVal FieldCollection fc);
    public native IPlugin createPlugin(@Cast("const char*") BytePointer layerName, @Const Weights weights, int nbWeights,
                                                @Const @ByVal FieldCollection fc);

}


@Namespace("nvuffparser") public static class IUffParser extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IUffParser(Pointer p) { super(p); }


    /** \brief register an input name of a UFF network with the associated Dimensions
    *
    * @param inputName: input name
    * @param inputDims: input Dimensions, always provide your dimensions in CHW even if your network
    *                   input was in HWC in yout original framework.
    * @param inputOrder: input order on which the framework input was originally
    */
    public native @Cast("bool") boolean registerInput(String inputName, @ByVal DimsCHW inputDims,
                                   UffInputOrder inputOrder/*=nvuffparser::UffInputOrder::kNCHW*/);
    public native @Cast("bool") boolean registerInput(String inputName, @ByVal DimsCHW inputDims);
    public native @Cast("bool") boolean registerInput(@Cast("const char*") BytePointer inputName, @ByVal DimsCHW inputDims,
                                   @Cast("nvuffparser::UffInputOrder") int inputOrder/*=nvuffparser::UffInputOrder::kNCHW*/);
    public native @Cast("bool") boolean registerInput(@Cast("const char*") BytePointer inputName, @ByVal DimsCHW inputDims);

    /** \brief register an output name of a UFF network
    *
    * @param outputName output name
    */
    public native @Cast("bool") boolean registerOutput(String outputName);
    public native @Cast("bool") boolean registerOutput(@Cast("const char*") BytePointer outputName);

    /** \brief parse a UFF file
    *
    * @param file: file name of the UFF file
    * @param network: network in which the UFFParser will fill the layers
    * @param weightsType: the type on which the weights will transformed in
    */
    public native @Cast("bool") boolean parse(String file,
                           @ByRef INetworkDefinition network,
                           DataType weightsType/*=nvinfer1::DataType::kFLOAT*/);
    public native @Cast("bool") boolean parse(String file,
                           @ByRef INetworkDefinition network);
    public native @Cast("bool") boolean parse(@Cast("const char*") BytePointer file,
                           @ByRef INetworkDefinition network,
                           @Cast("nvinfer1::DataType") int weightsType/*=nvinfer1::DataType::kFLOAT*/);
    public native @Cast("bool") boolean parse(@Cast("const char*") BytePointer file,
                           @ByRef INetworkDefinition network);

    /** \brief parse a UFF buffer, useful if the file already live in memory
    *
    * @param buffer: buffer of the UFF file
    * @param size: size of buffer of the UFF file
    * @param network: network in which the UFFParser will fill the layers
    * @param weightsType: the type on which the weights will transformed in
    */
    public native @Cast("bool") boolean parseBuffer(String buffer, @Cast("std::size_t") long size,
                                 @ByRef INetworkDefinition network,
                                 DataType weightsType/*=nvinfer1::DataType::kFLOAT*/);
    public native @Cast("bool") boolean parseBuffer(String buffer, @Cast("std::size_t") long size,
                                 @ByRef INetworkDefinition network);
    public native @Cast("bool") boolean parseBuffer(@Cast("const char*") BytePointer buffer, @Cast("std::size_t") long size,
                                 @ByRef INetworkDefinition network,
                                 @Cast("nvinfer1::DataType") int weightsType/*=nvinfer1::DataType::kFLOAT*/);
    public native @Cast("bool") boolean parseBuffer(@Cast("const char*") BytePointer buffer, @Cast("std::size_t") long size,
                                 @ByRef INetworkDefinition network);

    public native void destroy();

    /** \brief Return Version Major of the UFF
     */
    public native int getUffRequiredVersionMajor();

    /** \brief Return Version Minor of the UFF
     */
    public native int getUffRequiredVersionMinor();

    /** \brief Return Patch Version of the UFF
     */
    public native int getUffRequiredVersionPatch();

    public native void setPluginFactory(IUffPluginFactory factory);
}


@Namespace("nvuffparser") public static native IUffParser createUffParser();



// #endif /* !NV_UFF_PARSER_H */


}
