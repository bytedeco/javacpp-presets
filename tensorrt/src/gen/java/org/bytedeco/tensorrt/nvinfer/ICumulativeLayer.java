// Targeted by JavaCPP version 1.5.13-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.tensorrt.nvinfer;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.cuda.cudart.*;
import static org.bytedeco.cuda.global.cudart.*;
import org.bytedeco.cuda.cublas.*;
import static org.bytedeco.cuda.global.cublas.*;
import org.bytedeco.cuda.cudnn.*;
import static org.bytedeco.cuda.global.cudnn.*;
import org.bytedeco.cuda.nvrtc.*;
import static org.bytedeco.cuda.global.nvrtc.*;

import static org.bytedeco.tensorrt.global.nvinfer.*;
 // namespace impl

/**
 *  \class ICumulativeLayer
 * 
 *  \brief Layer that represents a cumulative operation across a tensor.
 * 
 *  It computes successive reductions across an axis of a tensor. The output
 *  always has the same shape as the input.
 * 
 *  If the reduction operation is summation, then this is also known as
 *  prefix-sum or cumulative sum.
 * 
 *  The operation has forward vs. reverse variants, and inclusive vs. exclusive variants.
 * 
 *  For example, let the input be a vector x of length n and the output be vector y.
 *  Then y[j] = sum(x[...]) where ... denotes a sequence of indices from this table:
 * 
 *            | forward   | reverse
 *  ----------|-----------| ---------
 *  inclusive | 0..j      |   j..n-1
 *  exclusive | 0..j-1    | j+1..n-1
 * 
 *  For multidimensional tensors, the reductions apply across a specified axis. For
 *  example, given a 2D input, a forward inclusive cumulative operation across axis 0 generates
 *  cumulative sums within each column.
 * 
 *  \warning Do not inherit from this class, as doing so will break forward-compatibility of the API and ABI.
 *  */
@Namespace("nvinfer1") @NoOffset @Properties(inherit = org.bytedeco.tensorrt.presets.nvinfer.class)
public class ICumulativeLayer extends ILayer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ICumulativeLayer(Pointer p) { super(p); }

    /**
     *  \brief Set the cumulative operation for the layer.
     * 
     *  @param op The reduction operation to be performed
     * 
     *  @return Whether \p op is valid and the operation successfully set
     * 
     *  @see getOperation(), CumulativeOperation
     *  */
    
    
    //!
    //!
    //!
    //!
    public native @Cast("bool") @NoException(true) boolean setOperation(CumulativeOperation op);
    public native @Cast("bool") @NoException(true) boolean setOperation(@Cast("nvinfer1::CumulativeOperation") int op);

    /**
     *  \brief Get the cumulative operation for the layer.
     * 
     *  @return The reduction operation to be performed
     * 
     *  @see setOperation(), CumulativeOperation
     *  */
    
    
    //!
    //!
    //!
    //!
    public native @NoException(true) CumulativeOperation getOperation();

    /**
     *  \brief Set whether it is an exclusive accumulation or inclusive accumulation.
     * 
     *  @param exclusive Whether the operation will exclude the element at the current index
     * 
     *  @see getExclusive
     *  */
    
    
    //!
    //!
    //!
    //!
    public native @NoException(true) void setExclusive(@Cast("bool") boolean exclusive);

    /**
     *  \brief Get whether it is exclusive accumulation or inclusive accumulation.
     * 
     *  @return Whether the operation will exclude the element at the current index
     * 
     *  @see setExclusive
     *  */
    
    
    //!
    //!
    //!
    //!
    public native @Cast("bool") @NoException(true) boolean getExclusive();

    /**
     *  \brief Specify whether the cumulative operation should be applied backward.
     * 
     *  @param reverse Whether the cumulative will run in the reverse direction from the last element
     * 
     *  @see getReverse
     *  */
    
    
    //!
    //!
    //!
    //!
    public native @NoException(true) void setReverse(@Cast("bool") boolean reverse);

    /**
     *  \brief Get the boolean that specifies whether the cumulative operation should be applied backward.
     * 
     *  @return Whether the cumulative will run in the reverse direction from the last element
     * 
     *  @see setReverse
     *  */
    public native @Cast("bool") @NoException(true) boolean getReverse();
}
