// Targeted by JavaCPP version 1.5.13-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.tensorrt.nvinfer;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.cuda.cudart.*;
import static org.bytedeco.cuda.global.cudart.*;
import org.bytedeco.cuda.cublas.*;
import static org.bytedeco.cuda.global.cublas.*;
import org.bytedeco.cuda.cudnn.*;
import static org.bytedeco.cuda.global.cudnn.*;
import org.bytedeco.cuda.nvrtc.*;
import static org.bytedeco.cuda.global.nvrtc.*;

import static org.bytedeco.tensorrt.global.nvinfer.*;


@Namespace("nvinfer1::v_1_0") @NoOffset @Properties(inherit = org.bytedeco.tensorrt.presets.nvinfer.class)
public class IPluginV3OneBuild extends IPluginCapability {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IPluginV3OneBuild(Pointer p) { super(p); }

    /**
     *  \brief The default maximum number of format combinations that will be timed by TensorRT during the build phase
     * 
     *  @see getFormatCombinationLimit
     *  */
    
    
    //!
    //!
    @MemberGetter public static native int kDEFAULT_FORMAT_COMBINATION_LIMIT();
    public static final int kDEFAULT_FORMAT_COMBINATION_LIMIT = kDEFAULT_FORMAT_COMBINATION_LIMIT();

    /**
     *  \brief Return version information associated with this interface. Applications must not override this method.
     *  */
    
    
    //!
    //!
    //!
    //!
    //!
    //!
    public native @ByVal @NoException(true) InterfaceInfo getInterfaceInfo();

    /**
     *  \brief Configure the plugin.
     * 
     *  configurePlugin() can be called multiple times in the build phase during creation of an engine by IBuilder.
     * 
     *  configurePlugin() is called when a plugin is being prepared for profiling but not for any
     *  specific input size. This provides an opportunity for the plugin to make algorithmic choices on the basis of
     *  input and output formats, along with the bound of possible dimensions. The min, opt and max value of the
     *  DynamicPluginTensorDesc correspond to the kMIN, kOPT and kMAX value of the current profile that the plugin is
     *  being profiled for, with the desc.dims field corresponding to the dimensions of plugin specified at network
     *  creation. Wildcard dimensions may exist during this phase in the desc.dims field.
     * 
     *  @param in The input tensors attributes that are used for configuration.
     *  @param nbInputs Number of input tensors.
     *  @param out The output tensors attributes that are used for configuration.
     *  @param nbOutputs Number of output tensors.
     * 
     *  @return 0 for success, else non-zero (which will cause engine termination, if invoked by TensorRT).
     *  */
    
    
    //!
    //!
    //!
    //!
    //!
    //!
    public native @NoException(true) int configurePlugin(@Const DynamicPluginTensorDesc in, int nbInputs,
            @Const DynamicPluginTensorDesc out, int nbOutputs);

    /**
     *  \brief Provide the data types of the plugin outputs if the input tensors have the data types provided.
     * 
     *  @param outputTypes Pre-allocated array to which the output data types should be written.
     *  @param nbOutputs The number of output tensors. This matches the value returned from getNbOutputs().
     *  @param inputTypes The input data types.
     *  @param nbInputs The number of input tensors.
     * 
     *  @return 0 for success, else non-zero (which will cause engine termination). The returned code will be reported
     *  through the error recorder.
     * 
     *  \note Provide {@code DataType::kFLOAT}s if the layer has no inputs. The data type for any size tensor outputs must be
     *  {@code DataType::kINT32}. The returned data types must each have a format that is supported by the plugin.
     * 
     *  \warning DataType:kBOOL and DataType::kUINT8 are not supported.
     *  */
    
    
    //!
    //!
    //!
    //!
    //!
    //!
    public native @NoException(true) int getOutputDataTypes(
            @Cast("nvinfer1::DataType*") IntPointer outputTypes, int nbOutputs, @Cast("nvinfer1::DataType*") IntPointer inputTypes, int nbInputs);
    public native @NoException(true) int getOutputDataTypes(
            @Cast("nvinfer1::DataType*") IntBuffer outputTypes, int nbOutputs, @Cast("nvinfer1::DataType*") IntBuffer inputTypes, int nbInputs);
    public native @NoException(true) int getOutputDataTypes(
            @Cast("nvinfer1::DataType*") int[] outputTypes, int nbOutputs, @Cast("nvinfer1::DataType*") int[] inputTypes, int nbInputs);

    /**
     *  \brief Provide expressions for computing dimensions of the output tensors from dimensions of the input tensors.
     * 
     *  @param inputs Expressions for dimensions of the input tensors
     *  @param nbInputs The number of input tensors
     *  @param shapeInputs Expressions for values of the shape tensor inputs
     *  @param nbShapeInputs The number of shape tensor inputs
     *  @param outputs Pre-allocated array to which the output dimensions must be written
     *  @param nbOutputs Number of outputs.
     *  @param exprBuilder Object for generating new dimension expressions
     * 
     *  \note Any size tensor outputs must be declared to be 0D.
     * 
     *  \note The declaration of shapeInputs as DimsExprs is slightly abusive, because the "dimensions"
     *        are actually the values of the shape tensor. For example, if the input shape tensor
     *        is a 2x3 matrix, the DimsExprs will have six "dimensions": the three values from the first
     *        row of the matrix followed by the three values from the second row of the matrix.
     * 
     *  @return 0 for success, else non-zero (which will cause engine termination). Returned code will be reported
     *  through the error recorder.
     *  */
    
    
    //!
    //!
    //!
    //!
    //!
    //!
    //!
    //!
    //!
    //!
    //!
    //!
    //!
    public native @NoException(true) int getOutputShapes(@Const DimsExprs inputs, int nbInputs, @Const DimsExprs shapeInputs,
            int nbShapeInputs, DimsExprs outputs, int nbOutputs, @ByRef IExprBuilder exprBuilder);

    /**
     *  \brief Return true if plugin supports the format and datatype for the input/output indexed by pos.
     * 
     *  For this method inputs are numbered 0.. (nbInputs - 1) and outputs are numbered nbInputs.. (nbInputs + nbOutputs
     *  - 1). Using this numbering, pos is an index into InOut, where 0 <= pos < nbInputs + nbOutputs - 1.
     * 
     *  TensorRT invokes this method to ask if the input/output indexed by pos supports the format/datatype specified
     *  by inOut[pos].format and inOut[pos].type.  The override should return true if that format/datatype at inOut[pos]
     *  are supported by the plugin.  If support is conditional on other input/output formats/datatypes, the plugin can
     *  make its result conditional on the formats/datatypes in inOut[0.. pos - 1], which will be set to values
     *  that the plugin supports.  The override should not inspect inOut[pos1.. nbInputs + nbOutputs - 1],
     *  which will have invalid values.  In other words, the decision for pos must be based on inOut[0..pos] only.
     * 
     *  Some examples:
     * 
     *  * A definition for a plugin that supports only FP16 NCHW:
     * 
     *          return inOut.format[pos] == TensorFormat::kLINEAR && inOut.type[pos] == DataType::kHALF;
     * 
     *  * A definition for a plugin that supports only FP16 NCHW for its two inputs,
     *    and FP32 NCHW for its single output:
     * 
     *          return inOut.format[pos] == TensorFormat::kLINEAR && (inOut.type[pos] == pos < 2 ?  DataType::kHALF :
     *          DataType::kFLOAT);
     * 
     *  * A definition for a "polymorphic" plugin with two inputs and one output that supports
     *    any format or type, but the inputs and output must have the same format and type:
     * 
     *          return pos == 0 || (inOut.format[pos] == inOut.format[0] && inOut.type[pos] == inOut.type[0]);
     * 
     *  \warning TensorRT will stop querying once it finds getFormatCombinationLimit() of combinations.
     * 
     *  @see getFormatCombinationLimit
     *  */
    
    
    //!
    //!
    //!
    public native @Cast("bool") @NoException(true) boolean supportsFormatCombination(
            int pos, @Const DynamicPluginTensorDesc inOut, int nbInputs, int nbOutputs);

    /**
     *  \brief Get the number of outputs from the plugin.
     * 
     *  @return The number of outputs, which must be a positive integer.
     *  */
    
    
    //!
    //!
    //!
    //!
    public native @NoException(true) int getNbOutputs();

    /**
     *  \brief Find the workspace size required by the layer.
     * 
     *  This function is called after the plugin is configured, and possibly during execution.
     *  The result should be a sufficient workspace size to deal with inputs and outputs of the given size
     *  or any smaller problem.
     * 
     *  @return The workspace size.
     *  */
    
    
    //!
    //!
    //!
    //!
    //!
    //!
    //!
    //!
    //!
    public native @Cast("size_t") @NoException(true) long getWorkspaceSize(@Const DynamicPluginTensorDesc inputs, int nbInputs,
            @Const DynamicPluginTensorDesc outputs, int nbOutputs);

    /**
     *  \brief Query for any custom tactics that the plugin intends to use
     * 
     *  This method queries for the set of tactics T(f) supported by the plugin for the format combination f indicated
     *  by the immediately preceding call to configurePlugin(). It is guaranteed to be called after configurePlugin().
     * 
     *  For each format combination provided through configurePlugin(), up to a maximum of getFormatCombinationLimit(),
     *  the plugin will be timed for each tactic advertised through this method for that format combination. i.e. The
     *  plugin will be timed {@code N = \sum_{i=0}^{i<getFormatCombinationLimit()} (T(f[i]))} times. If {@code N = 1}, the
     *  plugin may not be timed. In pseudocode, the timing protocol appears as the following:
     * 
     *  counter = 0
     *  for each supported format combination
     *      ++counter
     *      if counter > getFormatCombinationLimit()
     *          goto done
     *      configurePlugin(...)
     *      for each tactic in getValidTactics(...)
     *          time tactic
     *  done:
     * 
     * 
     *  @param tactics Pre-allocated buffer to which the tactic values should be written
     *  @param nbTactics The number of tactics advertised through getNbTactics()
     * 
     *  \note The provided tactic values must be unique and non-zero. The tactic value 0 is reserved for the default
     *  tactic attached to each format combination.
     * 
     *  @return 0 for success, else non-zero (which will cause engine termination). The returned code will be reported
     *  through the error recorder.
     *  */
    
    
    //!
    //!
    public native @NoException(true) int getValidTactics(IntPointer tactics, int nbTactics);
    public native @NoException(true) int getValidTactics(IntBuffer tactics, int nbTactics);
    public native @NoException(true) int getValidTactics(int[] tactics, int nbTactics);

    /**
     *  \brief Query for the number of custom tactics the plugin intends to use
     *  */
    
    
    //!
    //!
    //!
    //!
    public native @NoException(true) int getNbTactics();

    /**
     *  \brief Called to query the suffix to use for the timing cache ID. May be called anytime after plugin creation.
     * 
     *  @return Suffix to use for timing cache ID, considering only the creation state of the plugin.
     *          Returning nullptr will disable timing caching for the plugin altogether.
     * 
     *  \note If timing caching is enabled for the plugin (by returning non-null), the I/O shape and format information
     *  will be automatically considered to form the prefix of the timing cache ID. Therefore, only other factors
     *  determining the creation state of the plugin, such as its attribute values, should be considered to compose the
     *  return value.
     *  */
    
    
    //!
    //!
    public native @NoException(true) String getTimingCacheID();

    /**
     *  \brief Return the maximum number of format combinations that will be timed by TensorRT during the build phase
     *  */
    
    
    //!
    //!
    //!
    public native @NoException(true) int getFormatCombinationLimit();

    /**
     *  \brief Query for a string representing the configuration of the plugin. May be called anytime after
     *  plugin creation.
     * 
     *  @return A string representing the plugin's creation state, especially with regard to its attribute values.
     *  */
    public native @NoException(true) String getMetadataString();
}
