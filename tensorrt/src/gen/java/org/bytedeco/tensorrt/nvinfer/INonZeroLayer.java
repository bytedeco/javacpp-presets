// Targeted by JavaCPP version 1.5.13-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.tensorrt.nvinfer;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.cuda.cudart.*;
import static org.bytedeco.cuda.global.cudart.*;
import org.bytedeco.cuda.cublas.*;
import static org.bytedeco.cuda.global.cublas.*;
import org.bytedeco.cuda.cudnn.*;
import static org.bytedeco.cuda.global.cudnn.*;
import org.bytedeco.cuda.nvrtc.*;
import static org.bytedeco.cuda.global.nvrtc.*;

import static org.bytedeco.tensorrt.global.nvinfer.*;


/** \class INonZero
 * 
 *  \brief A NonZero layer in a network.
 * 
 *  This layer gets the positions of elements that are non-zero in the input.
 *  For boolean input, "non-zero" means "true". Semantics are similar to ONNX NonZero.
 * 
 *  The input may have type kFLOAT, kHALF, kINT32, or kBOOL.
 * 
 *  The output is a matrix of type kINT32 or kINT64.
 *  For an input with dimensions [L1, L2, ..., Lm], the output has dimensions [m,n],
 *  where n is the number of non-zero elements. I.e., each column denotes a m-D position.
 * 
 *  The columns are lexically ordered.
 *  E.g., a column with [3,2,4,7] precedes a column with [3,2,5,6].
 * 
 *  Tip: "compress" can be implemented with INonZero+IShuffle+Gather.
 *  For example, to compress a tensor x over axis k using mask vector v,
 *  use nonzero(v) to compute the subscripts, shuffle with reshape dimensions = [-1]
 *  to make the subscripts 1D, and then gather with the subscripts.
 *  */
@Namespace("nvinfer1") @NoOffset @Properties(inherit = org.bytedeco.tensorrt.presets.nvinfer.class)
public class INonZeroLayer extends ILayer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public INonZeroLayer(Pointer p) { super(p); }

    /**
     *  \brief Set the indices type for the layer.
     * 
     *  @param type The DataType of the indices tensor.
     * 
     *  @return true if set successfully, false otherwise.
     * 
     *  Set the indices (the first output) type of the NonZero layer. Valid values are DataType::kINT32 and
     *  DataType::kINT64, otherwise an error occurs and the type is not updated.
     *  */
    
    
    //!
    //!
    //!
    public native @Cast("bool") @NoException(true) boolean setIndicesType(DataType type);
    public native @Cast("bool") @NoException(true) boolean setIndicesType(@Cast("nvinfer1::DataType") int type);

    /**
     *  \brief Return the NonZero layer indices type.
     * 
     *  @return indices type set during layer creation or by setIndicesType().
     *  The return value is the indices type of the NonZero layer.
     *  The default value is DataType::kINT32.
     *  */
    public native @NoException(true) DataType getIndicesType();
}
