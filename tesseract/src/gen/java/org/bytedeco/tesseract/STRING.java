// Targeted by JavaCPP version 1.5-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.tesseract;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import org.bytedeco.leptonica.*;
import static org.bytedeco.leptonica.global.lept.*;

import static org.bytedeco.tesseract.global.tesseract.*;


@NoOffset @Properties(inherit = org.bytedeco.tesseract.presets.tesseract.class)
public class STRING extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public STRING(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public STRING(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public STRING position(long position) {
        return (STRING)super.position(position);
    }

    public STRING() { super((Pointer)null); allocate(); }
    private native void allocate();
    public STRING(@Const @ByRef STRING string) { super((Pointer)null); allocate(string); }
    private native void allocate(@Const @ByRef STRING string);
    public STRING(@Cast("const char*") BytePointer string) { super((Pointer)null); allocate(string); }
    private native void allocate(@Cast("const char*") BytePointer string);
    public STRING(String string) { super((Pointer)null); allocate(string); }
    private native void allocate(String string);
    public STRING(@Cast("const char*") BytePointer data, int length) { super((Pointer)null); allocate(data, length); }
    private native void allocate(@Cast("const char*") BytePointer data, int length);
    public STRING(String data, int length) { super((Pointer)null); allocate(data, length); }
    private native void allocate(String data, int length);

    // Writes to the given file. Returns false in case of error.
    public native @Cast("bool") boolean Serialize(@Cast("FILE*") Pointer fp);
    // Reads from the given file. Returns false in case of error.
    // If swap is true, assumes a big/little-endian swap is needed.
    public native @Cast("bool") boolean DeSerialize(@Cast("bool") boolean swap, @Cast("FILE*") Pointer fp);
    // Writes to the given file. Returns false in case of error.
    public native @Cast("bool") boolean Serialize(TFile fp);
    // Reads from the given file. Returns false in case of error.
    // If swap is true, assumes a big/little-endian swap is needed.
    public native @Cast("bool") boolean DeSerialize(TFile fp);
    // As DeSerialize, but only seeks past the data - hence a static method.
    public static native @Cast("bool") boolean SkipDeSerialize(TFile fp);

    public native @Cast("bool") boolean contains(byte c);
    public native int length();
    public native int size();
    // Workaround to avoid g++ -Wsign-compare warnings.
    public native @Cast("uint32_t") int unsigned_size();
    public native @Cast("const char*") BytePointer string();
    public native @Cast("const char*") BytePointer c_str();

    public native @Cast("char*") BytePointer strdup();

// #if STRING_IS_PROTECTED
// #else
    public native @Cast("char*") @ByRef @Name("operator []") BytePointer get(int index);
// #endif
    public native void split(byte c, StringGenericVector splited);
    public native void truncate_at(int index);

    public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef STRING string);
    public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef STRING string);
    public native @Cast("bool") @Name("operator !=") boolean notEquals(@Cast("const char*") BytePointer string);
    public native @Cast("bool") @Name("operator !=") boolean notEquals(String string);

    public native @ByRef @Name("operator =") STRING put(@Cast("const char*") BytePointer string);
    public native @ByRef @Name("operator =") STRING put(String string);
    public native @ByRef @Name("operator =") STRING put(@Const @ByRef STRING string);

    public native @ByVal @Name("operator +") STRING add(@Const @ByRef STRING string);
    public native @ByVal @Name("operator +") STRING add(byte ch);

    public native @ByRef @Name("operator +=") STRING addPut(@Cast("const char*") BytePointer string);
    public native @ByRef @Name("operator +=") STRING addPut(String string);
    public native @ByRef @Name("operator +=") STRING addPut(@Const @ByRef STRING string);
    public native @ByRef @Name("operator +=") STRING addPut(byte ch);

    // Assignment for strings which are not null-terminated.
    public native void assign(@Cast("const char*") BytePointer cstr, int len);
    public native void assign(String cstr, int len);

    // Appends the given string and int (as a %d) to this.
    // += cannot be used for ints as there as a char += operator that would
    // be ambiguous, and ints usually need a string before or between them
    // anyway.
    public native void add_str_int(@Cast("const char*") BytePointer str, int number);
    public native void add_str_int(String str, int number);
    // Appends the given string and double (as a %.8g) to this.
    public native void add_str_double(@Cast("const char*") BytePointer str, double number);
    public native void add_str_double(String str, double number);

    // ensure capacity but keep pointer encapsulated
    public native void ensure(int min_capacity);
}
