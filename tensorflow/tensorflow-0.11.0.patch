diff --git a/util/python/python_config.sh b/util/python/python_config.sh
index c326033..4161d24 100755
--- a/util/python/python_config.sh
+++ b/util/python/python_config.sh
@@ -46,16 +46,14 @@ function main {
 }
 
 function python_path {
-  python - <<END
+  "$PYTHON_BIN_PATH" - <<END
 from __future__ import print_function
 import site
 import os
-
 try:
   input = raw_input
 except NameError:
   pass
-
 python_paths = []
 if os.getenv('PYTHONPATH') is not None:
   python_paths = os.getenv('PYTHONPATH').split(':')
@@ -65,25 +63,22 @@ except AttributeError:
  from distutils.sysconfig import get_python_lib
  library_paths = [get_python_lib()]
 all_paths = set(python_paths + library_paths)
-
 paths = []
 for path in all_paths:
   if os.path.isdir(path):
     paths.append(path)
-
 if len(paths) == 1:
   print(paths[0])
 else:
-  ret_paths = " ".join(paths)
+  ret_paths = ",".join(paths)
   print(ret_paths)
 END
 }
 
 function default_python_path {
-  PYTHON_ARG="$1" python - <<END
+  PYTHON_ARG="$1" "$PYTHON_BIN_PATH" - <<END
 from __future__ import print_function
 import os
-
 default = os.getenv('PYTHON_ARG')
 default = str(default)
 print(default)
@@ -108,32 +103,47 @@ function setup_python {
     exit 1
   fi
 
-  local python_include=$("${PYTHON_BIN_PATH}" -c 'from __future__ import print_function; from distutils import sysconfig; print(sysconfig.get_python_inc());')
+  local python_include="$("${PYTHON_BIN_PATH}" -c 'from __future__ import print_function; from distutils import sysconfig; print(sysconfig.get_python_inc());')"
   if [ "$python_include" == "" ]; then
     echo -e "\n\nERROR: Problem getting python include path.  Is distutils installed?"
     exit 1
   fi
 
-  local python_lib_path=$(python_path)
-  echo "Found possible Python library paths:"
-  for x in $python_lib_path; do
-    echo "  $x"
-  done
-  set -- $python_lib_path
-  echo "Please input the desired Python library path to use.  Default is ["$1"]"
-  read b || true
-  if [ "$b" == "" ]; then
-   python_lib="$(default_python_path $python_lib_path)"
-   echo $python_lib
-  else
-    if test -d $b -a -x $b; then
-      python_lib=$b
+  if [ -z "$PYTHON_LIB_PATH" ]; then
+    local python_lib_path
+    # Split python_path into an array of paths, this allows path containing spaces
+    IFS=','
+    python_lib_path=($(python_path))
+    unset IFS
+
+    if [ 1 = "$USE_DEFAULT_PYTHON_LIB_PATH" ]; then
+      PYTHON_LIB_PATH="$(default_python_path "${python_lib_path[0]}")"
+      echo "Using python library path: $PYTHON_LIB_PATH"
+
     else
-      echo -e "\n\nERROR: The path you have entered does not exist."
-      exit 1
+      echo "Found possible Python library paths:"
+      for x in "${python_lib_path[@]}"; do
+        echo "  $x"
+      done
+      set -- "${python_lib_path[@]}"
+      echo "Please input the desired Python library path to use.  Default is ["$1"]"
+      read b || true
+      if [ "$b" == "" ]; then
+        PYTHON_LIB_PATH="$(default_python_path "${python_lib_path[0]}")"
+        echo "Using python library path: $PYTHON_LIB_PATH"
+      else
+        PYTHON_LIB_PATH="$b"
+      fi
     fi
   fi
 
+  if test -d "$PYTHON_LIB_PATH" -a -x "$PYTHON_LIB_PATH"; then
+    python_lib="$PYTHON_LIB_PATH"
+  else
+    echo -e "\n\nERROR: Invalid python library path: ${PYTHON_LIB_PATH}."
+    exit 1
+  fi
+
   local numpy_include=$("${PYTHON_BIN_PATH}" -c 'from __future__ import print_function; import numpy; print(numpy.get_include());')
   if [ "$numpy_include" == "" ]; then
     echo -e "\n\nERROR: Problem getting numpy include path.  Is numpy installed?"
@@ -142,24 +152,34 @@ function setup_python {
 
   for x in $EXPECTED_PATHS; do
     if [ -e "$x" ]; then
-      # This makes ./configure slow on Windows, but it works.
       rm -rf "$x"
     fi
   done
 
-# ln -sf is acutally implemented as copying in msys since creating symbolic links is privileged on Windows
-# So we need -rf to remove them above.
-  ln -sf "${python_include}" util/python/python_include
-  ln -sf "${python_lib}" util/python/python_lib
-  ln -sf "${numpy_include}" third_party/py/numpy/numpy_include
+# ln -sf is actually implemented as copying in msys since creating symbolic
+# links is privileged on Windows. But copying is too slow, so invoke mklink
+# to create junctions on Windows.
+  if is_windows; then
+    cmd /c "mklink /J util\\python\\python_include \"${python_include}\""
+    cmd /c "mklink /J util\\python\\python_lib \"${python_lib}\""
+    cmd /c "mklink /J third_party\\py\\numpy\\numpy_include \"${numpy_include}\""
+  else
+    ln -sf "${python_include}" util/python/python_include
+    ln -sf "${python_lib}" util/python/python_lib
+    ln -sf "${numpy_include}" third_party/py/numpy/numpy_include
+  fi
+  # Convert python path to Windows style before writing into bazel.rc
+  if is_windows; then
+    PYTHON_BIN_PATH="$(cygpath -m "$PYTHON_BIN_PATH")"
+  fi
 
   # Write tools/bazel.rc
   echo "# Autogenerated by configure: DO NOT EDIT" > tools/bazel.rc
   sed -e "s/\$PYTHON_MAJOR_VERSION/$python_major_version/g" \
-      -e "s[\$PYTHON_BINARY[$PYTHON_BIN_PATH[g" \
+      -e "s[\$PYTHON_BINARY[\"$PYTHON_BIN_PATH\"[g" \
       tools/bazel.rc.template >> tools/bazel.rc
   # Write tools/python_bin_path.sh
-  echo "export PYTHON_BIN_PATH=$PYTHON_BIN_PATH" > tools/python_bin_path.sh
+  echo "export PYTHON_BIN_PATH=\"$PYTHON_BIN_PATH\"" > tools/python_bin_path.sh
 }
 
 PLATFORM="$(uname -s | tr 'A-Z' 'a-z')"
@@ -183,7 +203,13 @@ function check_python {
       echo -e "\n\nERROR: '${x}' is not a symbolic link.  Internal error.\n\n" 1>&2
       exit 1
     fi
-    true_path=$(readlink "${x}")
+    if is_windows; then
+      # In msys, readlink <path> doesn't work, because no symbolic link on
+      # Windows. readlink -f <path> returns the real path of a junction.
+      true_path=$(readlink -f "${x}")
+    else
+      true_path=$(readlink "${x}")
+    fi
     if [ ! -d "${true_path}" ]; then
       echo -e "\n\nERROR: '${x}' does not refer to an existing directory: ${true_path}.  Do you need to rerun configure?\n\n" 1>&2
       exit 1
@@ -191,4 +217,4 @@ function check_python {
   done
 }
 
-main "$@"
+main "$@"
\ No newline at end of file
