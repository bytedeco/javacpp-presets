// Targeted by JavaCPP version 1.5.2-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.tensorflow;

import org.bytedeco.tensorflow.Allocator;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.tensorflow.global.tensorflow.*;


@Namespace("tensorflow") @NoOffset @Properties(inherit = org.bytedeco.tensorflow.presets.tensorflow.class)
public class EagerContext extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public EagerContext(Pointer p) { super(p); }

  // TODO: remove this constructor once we migrate all callers to the next one.
  public EagerContext(@Const @ByRef SessionOptions opts,
                 @Cast("tensorflow::ContextDevicePlacementPolicy") int default_policy, @Cast("bool") boolean async,
                 @MoveUniquePtr DeviceMgr device_mgr,
                 Rendezvous rendezvous) { super((Pointer)null); allocate(opts, default_policy, async, device_mgr, rendezvous); }
  private native void allocate(@Const @ByRef SessionOptions opts,
                 @Cast("tensorflow::ContextDevicePlacementPolicy") int default_policy, @Cast("bool") boolean async,
                 @MoveUniquePtr DeviceMgr device_mgr,
                 Rendezvous rendezvous);

  public EagerContext(
        @Const @ByRef SessionOptions opts, @Cast("tensorflow::ContextDevicePlacementPolicy") int default_policy,
        @Cast("bool") boolean async, @Const DeviceMgr device_mgr, @Cast("bool") boolean device_mgr_owned,
        Rendezvous rendezvous, @Const CustomKernelCreator custom_kernel_creator,
        DistributedFunctionLibraryRuntime cluster_flr/*=nullptr*/,
        @ByVal(nullValue = "std::function<tensorflow::Rendezvous*(const int64)>(nullptr)") RendezvousCreator rendezvous_creator) { super((Pointer)null); allocate(opts, default_policy, async, device_mgr, device_mgr_owned, rendezvous, custom_kernel_creator, cluster_flr, rendezvous_creator); }
  private native void allocate(
        @Const @ByRef SessionOptions opts, @Cast("tensorflow::ContextDevicePlacementPolicy") int default_policy,
        @Cast("bool") boolean async, @Const DeviceMgr device_mgr, @Cast("bool") boolean device_mgr_owned,
        Rendezvous rendezvous, @Const CustomKernelCreator custom_kernel_creator,
        DistributedFunctionLibraryRuntime cluster_flr/*=nullptr*/,
        @ByVal(nullValue = "std::function<tensorflow::Rendezvous*(const int64)>(nullptr)") RendezvousCreator rendezvous_creator);
  public EagerContext(
        @Const @ByRef SessionOptions opts, @Cast("tensorflow::ContextDevicePlacementPolicy") int default_policy,
        @Cast("bool") boolean async, @Const DeviceMgr device_mgr, @Cast("bool") boolean device_mgr_owned,
        Rendezvous rendezvous, @Const CustomKernelCreator custom_kernel_creator) { super((Pointer)null); allocate(opts, default_policy, async, device_mgr, device_mgr_owned, rendezvous, custom_kernel_creator); }
  private native void allocate(
        @Const @ByRef SessionOptions opts, @Cast("tensorflow::ContextDevicePlacementPolicy") int default_policy,
        @Cast("bool") boolean async, @Const DeviceMgr device_mgr, @Cast("bool") boolean device_mgr_owned,
        Rendezvous rendezvous, @Const CustomKernelCreator custom_kernel_creator);

  // Returns the function library runtime for the given device.
  public native FunctionLibraryRuntime func_lib(@Const Device d);

  public native ProcessFunctionLibraryRuntime pflr();

  // True if running in asynchronous mode.
  public native @Cast("bool") boolean Async();

  public native EagerExecutor Executor();

  public native @Cast("std::function<void(std::function<void()>)>*") Pointer runner();

  // Sets whether this thread should run in synchronous or asynchronous mode.
  public native @ByVal Status SetAsyncForThread(@Cast("bool") boolean async);

  // TODO(apassos) make this return a constant reference
  public native DeviceMap device_map();

  // TODO(apassos) make this return a constant reference
  public native DeviceVector devices();
  public native @StdVector DeviceType prioritized_device_type_list();

  // Clears the kernel caches.
  public native void ClearCaches();

  // Sets the device placement policy for the current thread.
  public native void SetThreadLocalDevicePlacementPolicy(@Cast("tensorflow::ContextDevicePlacementPolicy") int policy);

  // Returns the device placement policy for the current thread.
  public native @Cast("tensorflow::ContextDevicePlacementPolicy") int GetDevicePlacementPolicy();

  public native @ByVal Status AsyncWait();

  public native @ByVal Status GetStatus();

  public native void ClearAsyncError();

  public native @Cast("bool") boolean FindFunctionByName(@StdString BytePointer name);
  public native @Cast("bool") boolean FindFunctionByName(@StdString String name);

  public native @ByVal Status FindFunctionOpData(@StdString BytePointer name,
                              @Cast("const tensorflow::OpRegistrationData**") PointerPointer op_data);
  public native @ByVal Status FindFunctionOpData(@StdString BytePointer name,
                              @Const @ByPtrPtr OpRegistrationData op_data);
  public native @ByVal Status FindFunctionOpData(@StdString String name,
                              @Const @ByPtrPtr OpRegistrationData op_data);

  public native @Const FunctionDef FindFunctionDef(@StdString BytePointer name);
  public native @Const FunctionDef FindFunctionDef(@StdString String name);

  public native @ByVal Status FindDeviceByName(@StdString BytePointer name, @Cast("tensorflow::Device**") PointerPointer result);
  public native @ByVal Status FindDeviceByName(@StdString BytePointer name, @ByPtrPtr Device result);
  public native @ByVal Status FindDeviceByName(@StdString String name, @ByPtrPtr Device result);

  public native Device HostCPU();

  public native GraphCollector GetGraphCollector();

  public native @Cast("tensorflow::uint64") long NextId();

  public native void ExecutorAdd(EagerNode node);

  public native @ByVal Status AddFunctionDef(@Const @ByRef FunctionDef fdef);

  public native @ByVal Status RemoveFunction(@StdString BytePointer func);
  public native @ByVal Status RemoveFunction(@StdString String func);

  public native KernelAndDevice GetCachedKernel(@ByVal Fprint128 cache_key);

  public native void AddKernelToCache(@ByVal Fprint128 cache_key, KernelAndDevice kernel);

  public native @Cast("bool") boolean LogDevicePlacement();
  public native @Cast("bool") boolean LogMemory();

  public native Rendezvous GetRendezvous();
  public native Rendezvous CreateRendezvous(@Cast("const tensorflow::int64") long step_id);

  public native CollectiveExecutorMgrInterface collective_executor_mgr();
  public native @MoveUniquePtr CollectiveExecutor.Handle GetCollectiveExecutorHandle();

  public native @Const DeviceMgr local_device_mgr();
  public native @Const DeviceMgr remote_device_mgr();

  // TODO(apassos) remove the need for this
  public native void ReleaseDeviceMgr();

  // TODO(apassos) clean up RunMetadata storage.
  public native @Cast("tensorflow::mutex*") Pointer MetadataMu();
  public native @Cast("bool") boolean ShouldStoreStepStats();
  public native void SetShouldStoreStepStats(@Cast("bool") boolean value);
  public native @Cast("bool") boolean ShouldStoreGraphs();
  public native void SetShouldStoreGraphs(@Cast("bool") boolean value);
  public native RunMetadata RunMetadataProto();
  public native void ClearRunMetadata();

  public native @ByVal Status RegisterRunMetadataListener(RunMetadataListener listener);
  public native void ClearRunMetadataListener();

  public native void StartStep();
  public native void EndStep();
  public native ScopedStepContainer StepContainer();

  public native FunctionLibraryDefinition FuncLibDef();

// #if !defined(IS_MOBILE_PLATFORM)
  public native @ByVal Status GetClientAndContextID(Device device, @Cast("tensorflow::eager::EagerClient**") PointerPointer client,
                                 @Cast("tensorflow::uint64*") LongPointer context_id);
  public native @ByVal Status GetClientAndContextID(Device device, @ByPtrPtr EagerClient client,
                                 @Cast("tensorflow::uint64*") LongPointer context_id);
  public native @ByVal Status GetClientAndContextID(Device device, @ByPtrPtr EagerClient client,
                                 @Cast("tensorflow::uint64*") LongBuffer context_id);
  public native @ByVal Status GetClientAndContextID(Device device, @ByPtrPtr EagerClient client,
                                 @Cast("tensorflow::uint64*") long... context_id);

  // TODO(nareshmodi): Encapsulate remote state into a separate
  // class/struct.
  //
  // Enables the eager context to communicate with remote devices.
  //
  // - server: A ServerInterface that exports the tensorflow.WorkerService.
  // Note that this class expects the server to already have been started.
  // - remote_eager_workers: A cache from which we can get "EagerClient"s to
  // communicate with remote eager services.
  // - remote_device_mgr: A DeviceMgr* which contains all remote devices
  // (should contain no local devices).
  // - remote_contexts: A map containing task name to remote context ID.
  public native @ByVal Status InitializeRemote(
        @MoveUniquePtr ServerInterface server, WorkerEnv worker_env,
        @SharedPtr WorkerSession worker_session,
        @MoveUniquePtr EagerClientCache remote_eager_workers,
        @MoveUniquePtr DeviceMgr remote_device_manager,
        @Const @ByRef RemoteContexts remote_contexts, Rendezvous r,
        DeviceMgr local_device_mgr, int keep_alive_secs,
        DistributedFunctionLibraryRuntime cluster_flr);

  public native @Cast("bool") boolean HasActiveRemoteContext(@Cast("tensorflow::uint64") long context_id);

  public native @ByVal Status StoreCollectiveOpsServer(
        @MoveUniquePtr ServerInterface server, DeviceMgr device_mgr,
        CollectiveExecutorMgrInterface rpc_collective_executor_mgr);
// #endif  // IS_MOBILE_PLATFORM

  // If true, then tensors should be shipped across processes via the
  // EagerService.SendTensor RPC. If false, _Send/_Recv ops should be used
  // instead (which in-turn use WorkerService.RecvTensor RPCs).
  public native @Cast("bool") boolean UseSendTensorRPC();
  public native @Cast("bool") boolean PinSmallOpsToCPU();

  public native Env TFEnv();

  // All child threads will be reset() when destructing EagerContext.
  public native void AddChildThread(@MoveUniquePtr Thread thread);
}
