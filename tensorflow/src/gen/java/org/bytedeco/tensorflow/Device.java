// Targeted by JavaCPP version 1.5-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.tensorflow;

import org.bytedeco.tensorflow.Allocator;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.tensorflow.global.tensorflow.*;


@Namespace("tensorflow") @NoOffset @Properties(inherit = org.bytedeco.tensorflow.presets.tensorflow.class)
public class Device extends DeviceBase {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Device(Pointer p) { super(p); }

  // Callback type that takes a Status and returns void.

  // Full name of this device (see top comment).
  public native @StdString BytePointer name();

  // Parsed name of this device
  public native @Const @ByRef DeviceNameUtils.ParsedName parsed_name();

  // Describes what kind of device this is.  This is intended to be
  // human-readable and not computer-parsed, except that two devices
  // with the same device_type() are expected to perform similarly
  // (both from a computation and communication perspective).
  public native @StdString BytePointer device_type();

  // Returns an aggregation of device attributes.
  public native @Const @ByRef DeviceAttributes attributes();

  // Performs the actual compute function.
  //
  // Subclasses may override this function if they wish to perform
  // some initialization before each compute.
  public native void Compute(OpKernel op_kernel, OpKernelContext context);

  // Asynchronous kernel's compute.
  public native void ComputeAsync(AsyncOpKernel op_kernel, OpKernelContext context,
                              @ByVal @Cast("tensorflow::AsyncOpKernel::DoneCallback*") Fn done);

  // Takes ownership of the references in tensors. If necessary, a
  // device may override this method to keep a reference to the
  // accessed tensors until the async computation has completed.
  public native void ConsumeListOfAccessedTensors(
        DeviceContext context, @Cast("const tensorflow::TensorReferenceVector*") @ByRef AllocatorAttributesVector tensors);

  // If true, and tracing is enabled, the `tracing::ScopedAnnotation()` tracing
  // mechanism will be used instead of `tracing::ScopedActivity()`. Some devices
  // may override this method to use annotations, which enable child activities
  // (such as GPU kernel launches) to be related to the OpKernel invocation.
  public native @Cast("bool") boolean TraceUsingAnnotations();

  // Blocks until all operations queued on the device at the time of
  // the call have completed.  Returns any error pending on the device
  // at completion.
  public native @ByVal Status Sync();

  // Calls the given callback when all operations queued on the device at the
  // time of the call have completed. The callback is passed any error pending
  // on the device at completion.
  // TODO(b/112409994): Consolidate these two APIs, removing the synchronous
  // version.
  public native void Sync(@Cast("const tensorflow::Device::DoneCallback*") @ByRef Pointer done);

  // Override this to return true for devices that require a Sync() call before
  // session completion.
  public native @Cast("bool") boolean RequiresSyncOnCompletion();

  // Optionally modify the device's GraphDef before execution.
  //
  // This method should be considered experimental and is supplied to enable
  // prototyping of TensorFlow device implementations that need to modify
  // the GraphDef before execution.
  //
  // 'graph' supplies the partition of the graph assigned to this
  // device.
  public native @ByVal Status MaybeRewriteGraph(@UniquePtr Graph arg0);

  // Fill in the context map for the graph. Default behavior is to do
  // nothing.
  //
  // The caller takes ownership over the DeviceContext objects given
  // by the device.
  public native @ByVal Status FillContextMap(@Const Graph graph,
                                  @Cast("tensorflow::DeviceContextMap*") DeviceContextVector device_context_map);

  // Returns the op segment of this device.  The caller can reuse op
  // kernels registered for the same session running on this device.
  public native OpSegment op_segment();

  // Returns the resource manager associated w/ this device.
  public native ResourceMgr resource_manager();

  // Returns the device manager that owns this device, or nullptr if this Device
  // is not owned by a device manager.
  public native DeviceMgr device_mgr();

  // Summarizes the status of this Device, for debugging.
  public native @StdString BytePointer DebugString();

  // Assembles the parameter components into a complete DeviceAttributes value.
  public static native @ByVal DeviceAttributes BuildDeviceAttributes(
        @StdString BytePointer name, @ByVal DeviceType device, @Cast("tensorflow::Bytes") long memory_limit,
        @Const @ByRef DeviceLocality locality, @StdString BytePointer physical_device_desc);
  public static native @ByVal DeviceAttributes BuildDeviceAttributes(
        @StdString String name, @ByVal DeviceType device, @Cast("tensorflow::Bytes") long memory_limit,
        @Const @ByRef DeviceLocality locality, @StdString String physical_device_desc);

  public static native @ByVal DeviceAttributes BuildDeviceAttributes(
        @StdString BytePointer name, @ByVal DeviceType device, @Cast("tensorflow::Bytes") long memory_limit,
        @Const @ByRef DeviceLocality locality);
  public static native @ByVal DeviceAttributes BuildDeviceAttributes(
        @StdString String name, @ByVal DeviceType device, @Cast("tensorflow::Bytes") long memory_limit,
        @Const @ByRef DeviceLocality locality);

  // Clears the resource manager associated with this device.
  public native void ClearResourceMgr();
}
