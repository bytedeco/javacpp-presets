// Targeted by JavaCPP version 1.5.13-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.numpy;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;
import org.bytedeco.cpython.*;
import static org.bytedeco.cpython.global.python.*;

import static org.bytedeco.numpy.global.numpy.*;


/**
 * Query an ArrayMethod for the initial value for use in reduction.
 *
 * @param context The arraymethod context, mainly to access the descriptors.
 * @param reduction_is_empty Whether the reduction is empty. When it is, the
 *     value returned may differ.  In this case it is a "default" value that
 *     may differ from the "identity" value normally used.  For example:
 *     - {@code 0.0} is the default for {@code sum([])}.  But {@code -0.0} is the correct
 *       identity otherwise as it preserves the sign for {@code sum([-0.0])}.
 *     - We use no identity for object, but return the default of {@code 0} and {@code 1}
 *       for the empty {@code sum([], dtype=object)} and {@code prod([], dtype=object)}.
 *       This allows {@code np.sum(np.array(["a", "b"], dtype=object))} to work.
 *     - {@code -inf} or {@code INT_MIN} for {@code max} is an identity, but at least {@code INT_MIN}
 *       not a good *default* when there are no items.
 * @param initial Pointer to initial data to be filled (if possible)
 *
 * @return -1, 0, or 1 indicating error, no initial value, and initial being
 *     successfully filled.  Errors must not be given where 0 is correct, NumPy
 *     may call this even when not strictly necessary.
 */
@Properties(inherit = org.bytedeco.numpy.presets.numpy.class)
public class PyArrayMethod_GetReductionInitial extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    PyArrayMethod_GetReductionInitial(Pointer p) { super(p); }
    protected PyArrayMethod_GetReductionInitial() { allocate(); }
    private native void allocate();
    public native int call(
        PyArrayMethod_Context context, @Cast("npy_bool") byte reduction_is_empty,
        Pointer initial);
}
