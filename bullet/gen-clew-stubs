#!/usr/bin/env hy

;;
;; Copyright (C) 2022 Andrey Krainyak
;;
;; Licensed either under the Apache License, Version 2.0, or (at your option)
;; under the terms of the GNU General Public License as published by
;; the Free Software Foundation (subject to the "Classpath" exception),
;; either version 2, or any later version (collectively, the "License");
;; you may not use this file except in compliance with the License.
;; You may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;     http://www.gnu.org/licenses/
;;     http://www.gnu.org/software/classpath/license.html
;;
;; or as provided in the LICENSE.txt file that accompanied this code.
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;;



;; Usage:

;; Install dependencies: pip install --pre hy hyrule
;; Invoke the script from terminal - it will spit out the stubs into stdout.
;; Copy the output into clew_stubs.h inside bullet/src/main/resources.

(import glob [glob])
(import pathlib [Path])
(import re)
(require hyrule [-> ->>]
         hyrule.anaphoric *
         hyrule.destructure [let+])

(setv SCRIPT-PATH (Path __file__))
(setv BULLET-DIR (. SCRIPT-PATH parent))
(setv CLEW-H-PATH (get (glob f"{BULLET-DIR}/**/clew.h" :recursive True) 0))

(defn read-header []
  (with [f (open CLEW-H-PATH "r")]
    (f.read)))

(defn extract-func-names [header-text]
  (->> header-text
       (re.findall "#define *(\w+) *CLEW_GET_FUN.*\n")))

(defn parse-params [text]
  (->> text
       (re.sub "[\n\t]" " ")
       (re.sub " +" " ")))

(defn parse-typedef [text]
  (let [groups (re.search (+ "(?s)CL_API_ENTRY *"
                             "(?P<rettype>\w+).*"
                             "(?P<pfn>PFN\w+)\)"
                             "\((?P<params>.*)\)") text)]
    (, (.group groups "pfn")
       {"params" (parse-params (.group groups "params"))
        "ret-type" (.group groups "rettype")})))

(defn extract-typedefs [header-text]
  (->> header-text
       (re.findall "(?s)typedef CL_API_ENTRY.*?;")
       (map parse-typedef)
       dict))

(defn gen-fun-decl [name typedefs]
  (let+ [pfn (+ "PFN" (.upper name))
         {ret "ret-type" ps "params"} (get typedefs pfn)]
    f"{ret} {name}({ps});"))

(let [header-text (read-header)
      typedefs (extract-typedefs header-text)]
  (->> header-text
       extract-func-names
       sorted
       (map #%(gen-fun-decl %1 typedefs))
       (.join "\n")
       print))
