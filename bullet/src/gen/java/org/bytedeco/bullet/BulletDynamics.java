// Targeted by JavaCPP version 1.5.7: DO NOT EDIT THIS FILE

package org.bytedeco.bullet;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.bullet.LinearMath.*;
import static org.bytedeco.bullet.BulletCollision.*;

public class BulletDynamics extends org.bytedeco.bullet.presets.BulletDynamics {
    static { Loader.load(); }

// Parsed from LinearMath/btAlignedObjectArray.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_OBJECT_ARRAY__
// #define BT_OBJECT_ARRAY__

// #include "btScalar.h"  // has definitions like SIMD_FORCE_INLINE
// #include "btAlignedAllocator.h"

/**If the platform doesn't support placement new, you can disable BT_USE_PLACEMENT_NEW
 * then the btAlignedObjectArray doesn't support objects with virtual methods, and non-trivial constructors/destructors
 * You can enable BT_USE_MEMCPY, then swapping elements in the array will use memcpy instead of operator=
 * see discussion here: https://bulletphysics.orgphpBB2/viewtopic.php?t=1231 and
 * http://www.continuousphysics.com/Bullet/phpBB2/viewtopic.php?t=1240 */

public static final int BT_USE_PLACEMENT_NEW = 1;
//#define BT_USE_MEMCPY 1 //disable, because it is cumbersome to find out for each platform where memcpy is defined. It can be in <memory.h> or <string.h> or otherwise...
// #define BT_ALLOW_ARRAY_COPY_OPERATOR  // enabling this can accidently perform deep copies of data if you are not careful

// #ifdef BT_USE_MEMCPY
// #include <memory.h>
// #include <string.h>
// #endif  //BT_USE_MEMCPY

// #ifdef BT_USE_PLACEMENT_NEW
// #include <new>  //for placement new
// #endif          //BT_USE_PLACEMENT_NEW

/**The btAlignedObjectArray template class uses a subset of the stl::vector interface for its methods
 * It is developed to replace stl::vector to avoid portability issues, including STL alignment issues to add SIMD/SSE data */
@Name("btAlignedObjectArray<btRigidBody*>") @NoOffset public static class btAlignedObjectArray_btRigidBodyPointer extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btAlignedObjectArray_btRigidBodyPointer(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btAlignedObjectArray_btRigidBodyPointer(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btAlignedObjectArray_btRigidBodyPointer position(long position) {
        return (btAlignedObjectArray_btRigidBodyPointer)super.position(position);
    }
    @Override public btAlignedObjectArray_btRigidBodyPointer getPointer(long i) {
        return new btAlignedObjectArray_btRigidBodyPointer((Pointer)this).offsetAddress(i);
    }

	public native @ByRef @Name("operator =") btAlignedObjectArray_btRigidBodyPointer put(@Const @ByRef btAlignedObjectArray_btRigidBodyPointer other);
	public btAlignedObjectArray_btRigidBodyPointer() { super((Pointer)null); allocate(); }
	private native void allocate();

	/**Generally it is best to avoid using the copy constructor of an btAlignedObjectArray, and use a (const) reference to the array instead. */
	public btAlignedObjectArray_btRigidBodyPointer(@Const @ByRef btAlignedObjectArray_btRigidBodyPointer otherArray) { super((Pointer)null); allocate(otherArray); }
	private native void allocate(@Const @ByRef btAlignedObjectArray_btRigidBodyPointer otherArray);

	/** return the number of elements in the array */
	public native int size();

	public native @ByPtrRef btRigidBody at(int n);

	public native @ByPtrRef @Name("operator []") btRigidBody get(int n);

	/**clear the array, deallocated memory. Generally it is better to use array.resize(0), to reduce performance overhead of run-time memory (de)allocations. */
	public native void clear();

	public native void pop_back();

	/**resize changes the number of elements in the array. If the new size is larger, the new elements will be constructed using the optional second argument.
	 * when the new number of elements is smaller, the destructor will be called, but memory will not be freed, to reduce performance overhead of run-time memory (de)allocations. */
	public native void resizeNoInitialize(int newsize);

	public native void resize(int newsize, @ByPtrRef btRigidBody fillData/*=btRigidBody*()*/);
	public native void resize(int newsize);
	public native @ByPtrRef btRigidBody expandNonInitializing();

	public native @ByPtrRef btRigidBody expand(@ByPtrRef btRigidBody fillValue/*=btRigidBody*()*/);
	public native @ByPtrRef btRigidBody expand();

	public native void push_back(@ByPtrRef btRigidBody _Val);

	/** return the pre-allocated (reserved) elements, this is at least as large as the total number of elements,see size() and reserve() */
	public native @Name("capacity") int _capacity();

	public native void reserve(int _Count);

	/**heap sort from http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Sort/Heap/ */ /*downHeap*/

	public native void swap(int index0, int index1);

	/**non-recursive binary search, assumes sorted array */
	public native int findBinarySearch(@ByPtrRef btRigidBody key);

	public native int findLinearSearch(@ByPtrRef btRigidBody key);

	// If the key is not in the array, return -1 instead of 0,
	// since 0 also means the first element in the array.
	public native int findLinearSearch2(@ByPtrRef btRigidBody key);

	public native void removeAtIndex(int index);
	public native void remove(@ByPtrRef btRigidBody key);

	//PCK: whole function
	public native void initializeFromBuffer(Pointer buffer, int size, int _capacity);

	public native void copyFromArray(@Const @ByRef btAlignedObjectArray_btRigidBodyPointer otherArray);
}

// #endif  //BT_OBJECT_ARRAY__


// Parsed from BulletDynamics/Dynamics/btRigidBody.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_RIGIDBODY_H
// #define BT_RIGIDBODY_H

// #include "LinearMath/btAlignedObjectArray.h"
// #include "LinearMath/btTransform.h"
// #include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
// #include "BulletCollision/CollisionDispatch/btCollisionObject.h"
@Opaque public static class btTypedConstraint extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public btTypedConstraint() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btTypedConstraint(Pointer p) { super(p); }
}

public static native @Cast("btScalar") float gDeactivationTime(); public static native void gDeactivationTime(float setter);
public static native @Cast("bool") boolean gDisableDeactivation(); public static native void gDisableDeactivation(boolean setter);

// #ifdef BT_USE_DOUBLE_PRECISION
// #else
// #define btRigidBodyData btRigidBodyFloatData
public static final String btRigidBodyDataName = "btRigidBodyFloatData";
// #endif  //BT_USE_DOUBLE_PRECISION

/** enum btRigidBodyFlags */
public static final int
	BT_DISABLE_WORLD_GRAVITY = 1,
	/**BT_ENABLE_GYROPSCOPIC_FORCE flags is enabled by default in Bullet 2.83 and onwards.
	 * and it BT_ENABLE_GYROPSCOPIC_FORCE becomes equivalent to BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY
	 * See Demos/GyroscopicDemo and computeGyroscopicImpulseImplicit */
	BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT = 2,
	BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD = 4,
	BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY = 8,
	BT_ENABLE_GYROPSCOPIC_FORCE = BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY;

/**The btRigidBody is the main class for rigid body objects. It is derived from btCollisionObject, so it keeps a pointer to a btCollisionShape.
 * It is recommended for performance and memory use to share btCollisionShape objects whenever possible.
 * There are 3 types of rigid bodies:
 * - A) Dynamic rigid bodies, with positive mass. Motion is controlled by rigid body dynamics.
 * - B) Fixed objects with zero mass. They are not moving (basically collision objects)
 * - C) Kinematic objects, which are objects without mass, but the user can move them. There is one-way interaction, and Bullet calculates a velocity based on the timestep and previous and current world transform.
 * Bullet automatically deactivates dynamic rigid bodies, when the velocity is below a threshold for a given time.
 * Deactivated (sleeping) rigid bodies don't take any processing time, except a minor broadphase collision detection impact (to allow active objects to activate/wake up sleeping objects) */
@NoOffset public static class btRigidBody extends btCollisionObject {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btRigidBody(Pointer p) { super(p); }

	/**The btRigidBodyConstructionInfo structure provides information to create a rigid body. Setting mass to zero creates a fixed (non-dynamic) rigid body.
	 * For dynamic objects, you can use the collision shape to approximate the local inertia tensor, otherwise use the zero vector (default argument)
	 * You can use the motion state to synchronize the world transform between physics and graphics objects.
	 * And if the motion state is provided, the rigid body will initialize its initial world transform from the motion state,
	 * m_startWorldTransform is only used when you don't provide a motion state. */
	@NoOffset public static class btRigidBodyConstructionInfo extends Pointer {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public btRigidBodyConstructionInfo(Pointer p) { super(p); }
	
		public native @Cast("btScalar") float m_mass(); public native btRigidBodyConstructionInfo m_mass(float setter);

		/**When a motionState is provided, the rigid body will initialize its world transform from the motion state
		 * In this case, m_startWorldTransform is ignored. */
		public native btMotionState m_motionState(); public native btRigidBodyConstructionInfo m_motionState(btMotionState setter);
		public native @ByRef btTransform m_startWorldTransform(); public native btRigidBodyConstructionInfo m_startWorldTransform(btTransform setter);

		public native btCollisionShape m_collisionShape(); public native btRigidBodyConstructionInfo m_collisionShape(btCollisionShape setter);
		public native @ByRef btVector3 m_localInertia(); public native btRigidBodyConstructionInfo m_localInertia(btVector3 setter);
		public native @Cast("btScalar") float m_linearDamping(); public native btRigidBodyConstructionInfo m_linearDamping(float setter);
		public native @Cast("btScalar") float m_angularDamping(); public native btRigidBodyConstructionInfo m_angularDamping(float setter);

		/**best simulation results when friction is non-zero */
		public native @Cast("btScalar") float m_friction(); public native btRigidBodyConstructionInfo m_friction(float setter);
		/**the m_rollingFriction prevents rounded shapes, such as spheres, cylinders and capsules from rolling forever.
		 * See Bullet/Demos/RollingFrictionDemo for usage */
		public native @Cast("btScalar") float m_rollingFriction(); public native btRigidBodyConstructionInfo m_rollingFriction(float setter);
		public native @Cast("btScalar") float m_spinningFriction(); public native btRigidBodyConstructionInfo m_spinningFriction(float setter);  //torsional friction around contact normal

		/**best simulation results using zero restitution. */
		public native @Cast("btScalar") float m_restitution(); public native btRigidBodyConstructionInfo m_restitution(float setter);

		public native @Cast("btScalar") float m_linearSleepingThreshold(); public native btRigidBodyConstructionInfo m_linearSleepingThreshold(float setter);
		public native @Cast("btScalar") float m_angularSleepingThreshold(); public native btRigidBodyConstructionInfo m_angularSleepingThreshold(float setter);

		//Additional damping can help avoiding lowpass jitter motion, help stability for ragdolls etc.
		//Such damping is undesirable, so once the overall simulation quality of the rigid body dynamics system has improved, this should become obsolete
		public native @Cast("bool") boolean m_additionalDamping(); public native btRigidBodyConstructionInfo m_additionalDamping(boolean setter);
		public native @Cast("btScalar") float m_additionalDampingFactor(); public native btRigidBodyConstructionInfo m_additionalDampingFactor(float setter);
		public native @Cast("btScalar") float m_additionalLinearDampingThresholdSqr(); public native btRigidBodyConstructionInfo m_additionalLinearDampingThresholdSqr(float setter);
		public native @Cast("btScalar") float m_additionalAngularDampingThresholdSqr(); public native btRigidBodyConstructionInfo m_additionalAngularDampingThresholdSqr(float setter);
		public native @Cast("btScalar") float m_additionalAngularDampingFactor(); public native btRigidBodyConstructionInfo m_additionalAngularDampingFactor(float setter);

		public btRigidBodyConstructionInfo(@Cast("btScalar") float mass, btMotionState motionState, btCollisionShape collisionShape, @Const @ByRef(nullValue = "btVector3(0, 0, 0)") btVector3 localInertia) { super((Pointer)null); allocate(mass, motionState, collisionShape, localInertia); }
		private native void allocate(@Cast("btScalar") float mass, btMotionState motionState, btCollisionShape collisionShape, @Const @ByRef(nullValue = "btVector3(0, 0, 0)") btVector3 localInertia);
		public btRigidBodyConstructionInfo(@Cast("btScalar") float mass, btMotionState motionState, btCollisionShape collisionShape) { super((Pointer)null); allocate(mass, motionState, collisionShape); }
		private native void allocate(@Cast("btScalar") float mass, btMotionState motionState, btCollisionShape collisionShape);
	}

	/**btRigidBody constructor using construction info */
	public btRigidBody(@Const @ByRef btRigidBodyConstructionInfo constructionInfo) { super((Pointer)null); allocate(constructionInfo); }
	private native void allocate(@Const @ByRef btRigidBodyConstructionInfo constructionInfo);

	/**btRigidBody constructor for backwards compatibility.
	 * To specify friction (etc) during rigid body construction, please use the other constructor (using btRigidBodyConstructionInfo) */
	public btRigidBody(@Cast("btScalar") float mass, btMotionState motionState, btCollisionShape collisionShape, @Const @ByRef(nullValue = "btVector3(0, 0, 0)") btVector3 localInertia) { super((Pointer)null); allocate(mass, motionState, collisionShape, localInertia); }
	private native void allocate(@Cast("btScalar") float mass, btMotionState motionState, btCollisionShape collisionShape, @Const @ByRef(nullValue = "btVector3(0, 0, 0)") btVector3 localInertia);
	public btRigidBody(@Cast("btScalar") float mass, btMotionState motionState, btCollisionShape collisionShape) { super((Pointer)null); allocate(mass, motionState, collisionShape); }
	private native void allocate(@Cast("btScalar") float mass, btMotionState motionState, btCollisionShape collisionShape);
	public native void proceedToTransform(@Const @ByRef btTransform newTrans);

	/**to keep collision detection and dynamics separate we don't store a rigidbody pointer
	 * but a rigidbody is derived from btCollisionObject, so we can safely perform an upcast */
	public static native @Const btRigidBody upcast(@Const btCollisionObject colObj);

	/** continuous collision detection needs prediction */
	public native void predictIntegratedTransform(@Cast("btScalar") float step, @ByRef btTransform predictedTransform);

	public native void saveKinematicState(@Cast("btScalar") float step);

	public native void applyGravity();
    
    public native void clearGravity();

	public native void setGravity(@Const @ByRef btVector3 acceleration);

	public native @Const @ByRef btVector3 getGravity();

	public native void setDamping(@Cast("btScalar") float lin_damping, @Cast("btScalar") float ang_damping);

	public native @Cast("btScalar") float getLinearDamping();

	public native @Cast("btScalar") float getAngularDamping();

	public native @Cast("btScalar") float getLinearSleepingThreshold();

	public native @Cast("btScalar") float getAngularSleepingThreshold();

	public native void applyDamping(@Cast("btScalar") float timeStep);

	public native btCollisionShape getCollisionShape();

	public native void setMassProps(@Cast("btScalar") float mass, @Const @ByRef btVector3 inertia);

	public native @Const @ByRef btVector3 getLinearFactor();
	public native void setLinearFactor(@Const @ByRef btVector3 linearFactor);
	public native @Cast("btScalar") float getInvMass();
	public native @Cast("btScalar") float getMass();
	public native @Const @ByRef btMatrix3x3 getInvInertiaTensorWorld();

	public native void integrateVelocities(@Cast("btScalar") float step);

	public native void setCenterOfMassTransform(@Const @ByRef btTransform xform);

	public native void applyCentralForce(@Const @ByRef btVector3 force);

	public native @Const @ByRef btVector3 getTotalForce();

	public native @Const @ByRef btVector3 getTotalTorque();

	public native @Const @ByRef btVector3 getInvInertiaDiagLocal();

	public native void setInvInertiaDiagLocal(@Const @ByRef btVector3 diagInvInertia);

	public native void setSleepingThresholds(@Cast("btScalar") float linear, @Cast("btScalar") float angular);

	public native void applyTorque(@Const @ByRef btVector3 torque);

	public native void applyForce(@Const @ByRef btVector3 force, @Const @ByRef btVector3 rel_pos);

	public native void applyCentralImpulse(@Const @ByRef btVector3 impulse);

	public native void applyTorqueImpulse(@Const @ByRef btVector3 torque);

	public native void applyImpulse(@Const @ByRef btVector3 impulse, @Const @ByRef btVector3 rel_pos);
    
    public native void applyPushImpulse(@Const @ByRef btVector3 impulse, @Const @ByRef btVector3 rel_pos);
    
    public native @ByVal btVector3 getPushVelocity();
    
    public native @ByVal btVector3 getTurnVelocity();
    
    public native void setPushVelocity(@Const @ByRef btVector3 v);

//     #if defined(BT_CLAMP_VELOCITY_TO) && BT_CLAMP_VELOCITY_TO > 0
//     #endif

    public native void setTurnVelocity(@Const @ByRef btVector3 v);
    
    public native void applyCentralPushImpulse(@Const @ByRef btVector3 impulse);
    
    public native void applyTorqueTurnImpulse(@Const @ByRef btVector3 torque);

	public native void clearForces();

	public native void updateInertiaTensor();

	public native @Const @ByRef btVector3 getCenterOfMassPosition();
	public native @ByVal btQuaternion getOrientation();

	public native @Const @ByRef btTransform getCenterOfMassTransform();
	public native @Const @ByRef btVector3 getLinearVelocity();
	public native @Const @ByRef btVector3 getAngularVelocity();

	public native void setLinearVelocity(@Const @ByRef btVector3 lin_vel);

	public native void setAngularVelocity(@Const @ByRef btVector3 ang_vel);

	public native @ByVal btVector3 getVelocityInLocalPoint(@Const @ByRef btVector3 rel_pos);
    
    public native @ByVal btVector3 getPushVelocityInLocalPoint(@Const @ByRef btVector3 rel_pos);

	public native void translate(@Const @ByRef btVector3 v);

	public native void getAabb(@ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native @Cast("btScalar") float computeImpulseDenominator(@Const @ByRef btVector3 pos, @Const @ByRef btVector3 normal);

	public native @Cast("btScalar") float computeAngularImpulseDenominator(@Const @ByRef btVector3 axis);

	public native void updateDeactivation(@Cast("btScalar") float timeStep);

	public native @Cast("bool") boolean wantsSleeping();
	public native btBroadphaseProxy getBroadphaseProxy();
	public native void setNewBroadphaseProxy(btBroadphaseProxy broadphaseProxy);

	//btMotionState allows to automatic synchronize the world transform for active objects
	public native btMotionState getMotionState();
	public native void setMotionState(btMotionState motionState);

	//for experimental overriding of friction/contact solver func
	public native int m_contactSolverType(); public native btRigidBody m_contactSolverType(int setter);
	public native int m_frictionSolverType(); public native btRigidBody m_frictionSolverType(int setter);

	public native void setAngularFactor(@Const @ByRef btVector3 angFac);

	public native void setAngularFactor(@Cast("btScalar") float angFac);
	public native @Const @ByRef btVector3 getAngularFactor();

	//is this rigidbody added to a btCollisionWorld/btDynamicsWorld/btBroadphase?
	public native @Cast("bool") boolean isInWorld();

	public native void addConstraintRef(btTypedConstraint c);
	public native void removeConstraintRef(btTypedConstraint c);

	public native btTypedConstraint getConstraintRef(int index);

	public native int getNumConstraintRefs();

	public native void setFlags(int flags);

	public native int getFlags();

	/**perform implicit force computation in world space */
	public native @ByVal btVector3 computeGyroscopicImpulseImplicit_World(@Cast("btScalar") float dt);

	/**perform implicit force computation in body space (inertial frame) */
	public native @ByVal btVector3 computeGyroscopicImpulseImplicit_Body(@Cast("btScalar") float step);

	/**explicit version is best avoided, it gains energy */
	public native @ByVal btVector3 computeGyroscopicForceExplicit(@Cast("btScalar") float maxGyroscopicForce);
	public native @ByVal btVector3 getLocalInertia();

	///////////////////////////////////////////////

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);

	public native void serializeSingleObject(btSerializer serializer);
}

//@todo add m_optionalMotionState and m_constraintRefs to btRigidBodyData
/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btRigidBodyFloatData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btRigidBodyFloatData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btRigidBodyFloatData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btRigidBodyFloatData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btRigidBodyFloatData position(long position) {
        return (btRigidBodyFloatData)super.position(position);
    }
    @Override public btRigidBodyFloatData getPointer(long i) {
        return new btRigidBodyFloatData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btCollisionObjectFloatData m_collisionObjectData(); public native btRigidBodyFloatData m_collisionObjectData(btCollisionObjectFloatData setter);
	public native @ByRef btMatrix3x3FloatData m_invInertiaTensorWorld(); public native btRigidBodyFloatData m_invInertiaTensorWorld(btMatrix3x3FloatData setter);
	public native @ByRef btVector3FloatData m_linearVelocity(); public native btRigidBodyFloatData m_linearVelocity(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_angularVelocity(); public native btRigidBodyFloatData m_angularVelocity(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_angularFactor(); public native btRigidBodyFloatData m_angularFactor(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_linearFactor(); public native btRigidBodyFloatData m_linearFactor(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_gravity(); public native btRigidBodyFloatData m_gravity(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_gravity_acceleration(); public native btRigidBodyFloatData m_gravity_acceleration(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_invInertiaLocal(); public native btRigidBodyFloatData m_invInertiaLocal(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_totalForce(); public native btRigidBodyFloatData m_totalForce(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_totalTorque(); public native btRigidBodyFloatData m_totalTorque(btVector3FloatData setter);
	public native float m_inverseMass(); public native btRigidBodyFloatData m_inverseMass(float setter);
	public native float m_linearDamping(); public native btRigidBodyFloatData m_linearDamping(float setter);
	public native float m_angularDamping(); public native btRigidBodyFloatData m_angularDamping(float setter);
	public native float m_additionalDampingFactor(); public native btRigidBodyFloatData m_additionalDampingFactor(float setter);
	public native float m_additionalLinearDampingThresholdSqr(); public native btRigidBodyFloatData m_additionalLinearDampingThresholdSqr(float setter);
	public native float m_additionalAngularDampingThresholdSqr(); public native btRigidBodyFloatData m_additionalAngularDampingThresholdSqr(float setter);
	public native float m_additionalAngularDampingFactor(); public native btRigidBodyFloatData m_additionalAngularDampingFactor(float setter);
	public native float m_linearSleepingThreshold(); public native btRigidBodyFloatData m_linearSleepingThreshold(float setter);
	public native float m_angularSleepingThreshold(); public native btRigidBodyFloatData m_angularSleepingThreshold(float setter);
	public native int m_additionalDamping(); public native btRigidBodyFloatData m_additionalDamping(int setter);
}

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btRigidBodyDoubleData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btRigidBodyDoubleData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btRigidBodyDoubleData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btRigidBodyDoubleData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btRigidBodyDoubleData position(long position) {
        return (btRigidBodyDoubleData)super.position(position);
    }
    @Override public btRigidBodyDoubleData getPointer(long i) {
        return new btRigidBodyDoubleData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btCollisionObjectDoubleData m_collisionObjectData(); public native btRigidBodyDoubleData m_collisionObjectData(btCollisionObjectDoubleData setter);
	public native @ByRef btMatrix3x3DoubleData m_invInertiaTensorWorld(); public native btRigidBodyDoubleData m_invInertiaTensorWorld(btMatrix3x3DoubleData setter);
	public native @ByRef btVector3DoubleData m_linearVelocity(); public native btRigidBodyDoubleData m_linearVelocity(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_angularVelocity(); public native btRigidBodyDoubleData m_angularVelocity(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_angularFactor(); public native btRigidBodyDoubleData m_angularFactor(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_linearFactor(); public native btRigidBodyDoubleData m_linearFactor(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_gravity(); public native btRigidBodyDoubleData m_gravity(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_gravity_acceleration(); public native btRigidBodyDoubleData m_gravity_acceleration(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_invInertiaLocal(); public native btRigidBodyDoubleData m_invInertiaLocal(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_totalForce(); public native btRigidBodyDoubleData m_totalForce(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_totalTorque(); public native btRigidBodyDoubleData m_totalTorque(btVector3DoubleData setter);
	public native double m_inverseMass(); public native btRigidBodyDoubleData m_inverseMass(double setter);
	public native double m_linearDamping(); public native btRigidBodyDoubleData m_linearDamping(double setter);
	public native double m_angularDamping(); public native btRigidBodyDoubleData m_angularDamping(double setter);
	public native double m_additionalDampingFactor(); public native btRigidBodyDoubleData m_additionalDampingFactor(double setter);
	public native double m_additionalLinearDampingThresholdSqr(); public native btRigidBodyDoubleData m_additionalLinearDampingThresholdSqr(double setter);
	public native double m_additionalAngularDampingThresholdSqr(); public native btRigidBodyDoubleData m_additionalAngularDampingThresholdSqr(double setter);
	public native double m_additionalAngularDampingFactor(); public native btRigidBodyDoubleData m_additionalAngularDampingFactor(double setter);
	public native double m_linearSleepingThreshold(); public native btRigidBodyDoubleData m_linearSleepingThreshold(double setter);
	public native double m_angularSleepingThreshold(); public native btRigidBodyDoubleData m_angularSleepingThreshold(double setter);
	public native int m_additionalDamping(); public native btRigidBodyDoubleData m_additionalDamping(int setter);
	public native @Cast("char") byte m_padding(int i); public native btRigidBodyDoubleData m_padding(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_padding();
}

// #endif  //BT_RIGIDBODY_H


// Parsed from BulletDynamics/Dynamics/btDynamicsWorld.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_DYNAMICS_WORLD_H
// #define BT_DYNAMICS_WORLD_H

// #include "BulletCollision/CollisionDispatch/btCollisionWorld.h"
// #include "BulletDynamics/ConstraintSolver/btContactSolverInfo.h"
@Opaque public static class btActionInterface extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public btActionInterface() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btActionInterface(Pointer p) { super(p); }
}

/** Type for the callback for each tick */
public static class btInternalTickCallback extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    btInternalTickCallback(Pointer p) { super(p); }
    protected btInternalTickCallback() { allocate(); }
    private native void allocate();
    public native void call(btDynamicsWorld world, @Cast("btScalar") float timeStep);
}

/** enum btDynamicsWorldType */
public static final int
	BT_SIMPLE_DYNAMICS_WORLD = 1,
	BT_DISCRETE_DYNAMICS_WORLD = 2,
	BT_CONTINUOUS_DYNAMICS_WORLD = 3,
	BT_SOFT_RIGID_DYNAMICS_WORLD = 4,
	BT_GPU_DYNAMICS_WORLD = 5,
	BT_SOFT_MULTIBODY_DYNAMICS_WORLD = 6,
    BT_DEFORMABLE_MULTIBODY_DYNAMICS_WORLD = 7;

/**The btDynamicsWorld is the interface class for several dynamics implementation, basic, discrete, parallel, and continuous etc. */
@NoOffset public static class btDynamicsWorld extends btCollisionWorld {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btDynamicsWorld(Pointer p) { super(p); }


	/**stepSimulation proceeds the simulation over 'timeStep', units in preferably in seconds.
	 * By default, Bullet will subdivide the timestep in constant substeps of each 'fixedTimeStep'.
	 * in order to keep the simulation real-time, the maximum number of substeps can be clamped to 'maxSubSteps'.
	 * You can disable subdividing the timestep/substepping by passing maxSubSteps=0 as second argument to stepSimulation, but in that case you have to keep the timeStep constant. */
	public native int stepSimulation(@Cast("btScalar") float timeStep, int maxSubSteps/*=1*/, @Cast("btScalar") float fixedTimeStep/*=btScalar(1.) / btScalar(60.)*/);
	public native int stepSimulation(@Cast("btScalar") float timeStep);

	public native void debugDrawWorld();

	public native void addConstraint(btTypedConstraint constraint, @Cast("bool") boolean disableCollisionsBetweenLinkedBodies/*=false*/);
	public native void addConstraint(btTypedConstraint constraint);

	public native void removeConstraint(btTypedConstraint constraint);

	public native void addAction(btActionInterface action);

	public native void removeAction(btActionInterface action);

	//once a rigidbody is added to the dynamics world, it will get this gravity assigned
	//existing rigidbodies in the world get gravity assigned too, during this method
	public native void setGravity(@Const @ByRef btVector3 gravity);
	public native @ByVal btVector3 getGravity();

	public native void synchronizeMotionStates();

	public native void addRigidBody(btRigidBody body);

	public native void addRigidBody(btRigidBody body, int group, int mask);

	public native void removeRigidBody(btRigidBody body);

	public native void setConstraintSolver(btConstraintSolver solver);

	public native btConstraintSolver getConstraintSolver();

	public native int getNumConstraints();

	public native btTypedConstraint getConstraint(int index);

	public native @Cast("btDynamicsWorldType") int getWorldType();

	public native void clearForces();

	/** Set the callback for when an internal tick (simulation substep) happens, optional user info */
	public native void setInternalTickCallback(btInternalTickCallback cb, Pointer worldUserInfo/*=0*/, @Cast("bool") boolean isPreTick/*=false*/);
	public native void setInternalTickCallback(btInternalTickCallback cb);

	public native void setWorldUserInfo(Pointer worldUserInfo);

	public native Pointer getWorldUserInfo();

	public native @ByRef btContactSolverInfo getSolverInfo();

	/**obsolete, use addAction instead. */
	public native void addVehicle(btActionInterface vehicle);
	/**obsolete, use removeAction instead */
	public native void removeVehicle(btActionInterface vehicle);
	/**obsolete, use addAction instead. */
	public native void addCharacter(btActionInterface character);
	/**obsolete, use removeAction instead */
	public native void removeCharacter(btActionInterface character);
}

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btDynamicsWorldDoubleData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btDynamicsWorldDoubleData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btDynamicsWorldDoubleData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btDynamicsWorldDoubleData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btDynamicsWorldDoubleData position(long position) {
        return (btDynamicsWorldDoubleData)super.position(position);
    }
    @Override public btDynamicsWorldDoubleData getPointer(long i) {
        return new btDynamicsWorldDoubleData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btContactSolverInfoDoubleData m_solverInfo(); public native btDynamicsWorldDoubleData m_solverInfo(btContactSolverInfoDoubleData setter);
	public native @ByRef btVector3DoubleData m_gravity(); public native btDynamicsWorldDoubleData m_gravity(btVector3DoubleData setter);
}

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btDynamicsWorldFloatData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btDynamicsWorldFloatData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btDynamicsWorldFloatData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btDynamicsWorldFloatData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btDynamicsWorldFloatData position(long position) {
        return (btDynamicsWorldFloatData)super.position(position);
    }
    @Override public btDynamicsWorldFloatData getPointer(long i) {
        return new btDynamicsWorldFloatData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btContactSolverInfoFloatData m_solverInfo(); public native btDynamicsWorldFloatData m_solverInfo(btContactSolverInfoFloatData setter);
	public native @ByRef btVector3FloatData m_gravity(); public native btDynamicsWorldFloatData m_gravity(btVector3FloatData setter);
}

// #endif  //BT_DYNAMICS_WORLD_H


// Parsed from BulletDynamics/ConstraintSolver/btContactSolverInfo.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_CONTACT_SOLVER_INFO
// #define BT_CONTACT_SOLVER_INFO

// #include "LinearMath/btScalar.h"

/** enum btSolverMode */
public static final int
	SOLVER_RANDMIZE_ORDER = 1,
	SOLVER_FRICTION_SEPARATE = 2,
	SOLVER_USE_WARMSTARTING = 4,
	SOLVER_USE_2_FRICTION_DIRECTIONS = 16,
	SOLVER_ENABLE_FRICTION_DIRECTION_CACHING = 32,
	SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION = 64,
	SOLVER_CACHE_FRIENDLY = 128,
	SOLVER_SIMD = 256,
	SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS = 512,
	SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS = 1024,
	SOLVER_DISABLE_IMPLICIT_CONE_FRICTION = 2048,
	SOLVER_USE_ARTICULATED_WARMSTARTING = 4096;

public static class btContactSolverInfoData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btContactSolverInfoData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btContactSolverInfoData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btContactSolverInfoData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btContactSolverInfoData position(long position) {
        return (btContactSolverInfoData)super.position(position);
    }
    @Override public btContactSolverInfoData getPointer(long i) {
        return new btContactSolverInfoData((Pointer)this).offsetAddress(i);
    }

	public native @Cast("btScalar") float m_tau(); public native btContactSolverInfoData m_tau(float setter);
	public native @Cast("btScalar") float m_damping(); public native btContactSolverInfoData m_damping(float setter);  //global non-contact constraint damping, can be locally overridden by constraints during 'getInfo2'.
	public native @Cast("btScalar") float m_friction(); public native btContactSolverInfoData m_friction(float setter);
	public native @Cast("btScalar") float m_timeStep(); public native btContactSolverInfoData m_timeStep(float setter);
	public native @Cast("btScalar") float m_restitution(); public native btContactSolverInfoData m_restitution(float setter);
	public native int m_numIterations(); public native btContactSolverInfoData m_numIterations(int setter);
	public native @Cast("btScalar") float m_maxErrorReduction(); public native btContactSolverInfoData m_maxErrorReduction(float setter);
	public native @Cast("btScalar") float m_sor(); public native btContactSolverInfoData m_sor(float setter);          //successive over-relaxation term
	public native @Cast("btScalar") float m_erp(); public native btContactSolverInfoData m_erp(float setter);          //error reduction for non-contact constraints
	public native @Cast("btScalar") float m_erp2(); public native btContactSolverInfoData m_erp2(float setter);         //error reduction for contact constraints
	public native @Cast("btScalar") float m_deformable_erp(); public native btContactSolverInfoData m_deformable_erp(float setter);          //error reduction for deformable constraints
	public native @Cast("btScalar") float m_deformable_cfm(); public native btContactSolverInfoData m_deformable_cfm(float setter);          //constraint force mixing for deformable constraints
	public native @Cast("btScalar") float m_deformable_maxErrorReduction(); public native btContactSolverInfoData m_deformable_maxErrorReduction(float setter); // maxErrorReduction for deformable contact
	public native @Cast("btScalar") float m_globalCfm(); public native btContactSolverInfoData m_globalCfm(float setter);    //constraint force mixing for contacts and non-contacts
	public native @Cast("btScalar") float m_frictionERP(); public native btContactSolverInfoData m_frictionERP(float setter);  //error reduction for friction constraints
	public native @Cast("btScalar") float m_frictionCFM(); public native btContactSolverInfoData m_frictionCFM(float setter);  //constraint force mixing for friction constraints

	public native int m_splitImpulse(); public native btContactSolverInfoData m_splitImpulse(int setter);
	public native @Cast("btScalar") float m_splitImpulsePenetrationThreshold(); public native btContactSolverInfoData m_splitImpulsePenetrationThreshold(float setter);
	public native @Cast("btScalar") float m_splitImpulseTurnErp(); public native btContactSolverInfoData m_splitImpulseTurnErp(float setter);
	public native @Cast("btScalar") float m_linearSlop(); public native btContactSolverInfoData m_linearSlop(float setter);
	public native @Cast("btScalar") float m_warmstartingFactor(); public native btContactSolverInfoData m_warmstartingFactor(float setter);
	public native @Cast("btScalar") float m_articulatedWarmstartingFactor(); public native btContactSolverInfoData m_articulatedWarmstartingFactor(float setter);
	public native int m_solverMode(); public native btContactSolverInfoData m_solverMode(int setter);
	public native int m_restingContactRestitutionThreshold(); public native btContactSolverInfoData m_restingContactRestitutionThreshold(int setter);
	public native int m_minimumSolverBatchSize(); public native btContactSolverInfoData m_minimumSolverBatchSize(int setter);
	public native @Cast("btScalar") float m_maxGyroscopicForce(); public native btContactSolverInfoData m_maxGyroscopicForce(float setter);
	public native @Cast("btScalar") float m_singleAxisRollingFrictionThreshold(); public native btContactSolverInfoData m_singleAxisRollingFrictionThreshold(float setter);
	public native @Cast("btScalar") float m_leastSquaresResidualThreshold(); public native btContactSolverInfoData m_leastSquaresResidualThreshold(float setter);
	public native @Cast("btScalar") float m_restitutionVelocityThreshold(); public native btContactSolverInfoData m_restitutionVelocityThreshold(float setter);
	public native @Cast("bool") boolean m_jointFeedbackInWorldSpace(); public native btContactSolverInfoData m_jointFeedbackInWorldSpace(boolean setter);
	public native @Cast("bool") boolean m_jointFeedbackInJointFrame(); public native btContactSolverInfoData m_jointFeedbackInJointFrame(boolean setter);
	public native int m_reportSolverAnalytics(); public native btContactSolverInfoData m_reportSolverAnalytics(int setter);
	public native int m_numNonContactInnerIterations(); public native btContactSolverInfoData m_numNonContactInnerIterations(int setter);
}

public static class btContactSolverInfo extends btContactSolverInfoData {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btContactSolverInfo(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btContactSolverInfo(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btContactSolverInfo position(long position) {
        return (btContactSolverInfo)super.position(position);
    }
    @Override public btContactSolverInfo getPointer(long i) {
        return new btContactSolverInfo((Pointer)this).offsetAddress(i);
    }

	public btContactSolverInfo() { super((Pointer)null); allocate(); }
	private native void allocate();
}

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btContactSolverInfoDoubleData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btContactSolverInfoDoubleData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btContactSolverInfoDoubleData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btContactSolverInfoDoubleData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btContactSolverInfoDoubleData position(long position) {
        return (btContactSolverInfoDoubleData)super.position(position);
    }
    @Override public btContactSolverInfoDoubleData getPointer(long i) {
        return new btContactSolverInfoDoubleData((Pointer)this).offsetAddress(i);
    }

	public native double m_tau(); public native btContactSolverInfoDoubleData m_tau(double setter);
	public native double m_damping(); public native btContactSolverInfoDoubleData m_damping(double setter);  //global non-contact constraint damping, can be locally overridden by constraints during 'getInfo2'.
	public native double m_friction(); public native btContactSolverInfoDoubleData m_friction(double setter);
	public native double m_timeStep(); public native btContactSolverInfoDoubleData m_timeStep(double setter);
	public native double m_restitution(); public native btContactSolverInfoDoubleData m_restitution(double setter);
	public native double m_maxErrorReduction(); public native btContactSolverInfoDoubleData m_maxErrorReduction(double setter);
	public native double m_sor(); public native btContactSolverInfoDoubleData m_sor(double setter);
	public native double m_erp(); public native btContactSolverInfoDoubleData m_erp(double setter);        //used as Baumgarte factor
	public native double m_erp2(); public native btContactSolverInfoDoubleData m_erp2(double setter);       //used in Split Impulse
	public native double m_globalCfm(); public native btContactSolverInfoDoubleData m_globalCfm(double setter);  //constraint force mixing
	public native double m_splitImpulsePenetrationThreshold(); public native btContactSolverInfoDoubleData m_splitImpulsePenetrationThreshold(double setter);
	public native double m_splitImpulseTurnErp(); public native btContactSolverInfoDoubleData m_splitImpulseTurnErp(double setter);
	public native double m_linearSlop(); public native btContactSolverInfoDoubleData m_linearSlop(double setter);
	public native double m_warmstartingFactor(); public native btContactSolverInfoDoubleData m_warmstartingFactor(double setter);
	public native double m_articulatedWarmstartingFactor(); public native btContactSolverInfoDoubleData m_articulatedWarmstartingFactor(double setter);
	public native double m_maxGyroscopicForce(); public native btContactSolverInfoDoubleData m_maxGyroscopicForce(double setter);  /**it is only used for 'explicit' version of gyroscopic force */
	public native double m_singleAxisRollingFrictionThreshold(); public native btContactSolverInfoDoubleData m_singleAxisRollingFrictionThreshold(double setter);

	public native int m_numIterations(); public native btContactSolverInfoDoubleData m_numIterations(int setter);
	public native int m_solverMode(); public native btContactSolverInfoDoubleData m_solverMode(int setter);
	public native int m_restingContactRestitutionThreshold(); public native btContactSolverInfoDoubleData m_restingContactRestitutionThreshold(int setter);
	public native int m_minimumSolverBatchSize(); public native btContactSolverInfoDoubleData m_minimumSolverBatchSize(int setter);
	public native int m_splitImpulse(); public native btContactSolverInfoDoubleData m_splitImpulse(int setter);
	public native @Cast("char") byte m_padding(int i); public native btContactSolverInfoDoubleData m_padding(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_padding();
}
/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btContactSolverInfoFloatData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btContactSolverInfoFloatData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btContactSolverInfoFloatData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btContactSolverInfoFloatData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btContactSolverInfoFloatData position(long position) {
        return (btContactSolverInfoFloatData)super.position(position);
    }
    @Override public btContactSolverInfoFloatData getPointer(long i) {
        return new btContactSolverInfoFloatData((Pointer)this).offsetAddress(i);
    }

	public native float m_tau(); public native btContactSolverInfoFloatData m_tau(float setter);
	public native float m_damping(); public native btContactSolverInfoFloatData m_damping(float setter);  //global non-contact constraint damping, can be locally overridden by constraints during 'getInfo2'.
	public native float m_friction(); public native btContactSolverInfoFloatData m_friction(float setter);
	public native float m_timeStep(); public native btContactSolverInfoFloatData m_timeStep(float setter);

	public native float m_restitution(); public native btContactSolverInfoFloatData m_restitution(float setter);
	public native float m_maxErrorReduction(); public native btContactSolverInfoFloatData m_maxErrorReduction(float setter);
	public native float m_sor(); public native btContactSolverInfoFloatData m_sor(float setter);
	public native float m_erp(); public native btContactSolverInfoFloatData m_erp(float setter);  //used as Baumgarte factor

	public native float m_erp2(); public native btContactSolverInfoFloatData m_erp2(float setter);       //used in Split Impulse
	public native float m_globalCfm(); public native btContactSolverInfoFloatData m_globalCfm(float setter);  //constraint force mixing
	public native float m_splitImpulsePenetrationThreshold(); public native btContactSolverInfoFloatData m_splitImpulsePenetrationThreshold(float setter);
	public native float m_splitImpulseTurnErp(); public native btContactSolverInfoFloatData m_splitImpulseTurnErp(float setter);

	public native float m_linearSlop(); public native btContactSolverInfoFloatData m_linearSlop(float setter);
	public native float m_warmstartingFactor(); public native btContactSolverInfoFloatData m_warmstartingFactor(float setter);
	public native float m_articulatedWarmstartingFactor(); public native btContactSolverInfoFloatData m_articulatedWarmstartingFactor(float setter);
	public native float m_maxGyroscopicForce(); public native btContactSolverInfoFloatData m_maxGyroscopicForce(float setter);

	public native float m_singleAxisRollingFrictionThreshold(); public native btContactSolverInfoFloatData m_singleAxisRollingFrictionThreshold(float setter);
	public native int m_numIterations(); public native btContactSolverInfoFloatData m_numIterations(int setter);
	public native int m_solverMode(); public native btContactSolverInfoFloatData m_solverMode(int setter);
	public native int m_restingContactRestitutionThreshold(); public native btContactSolverInfoFloatData m_restingContactRestitutionThreshold(int setter);

	public native int m_minimumSolverBatchSize(); public native btContactSolverInfoFloatData m_minimumSolverBatchSize(int setter);
	public native int m_splitImpulse(); public native btContactSolverInfoFloatData m_splitImpulse(int setter);
	
}

// #endif  //BT_CONTACT_SOLVER_INFO


// Parsed from BulletDynamics/Dynamics/btDiscreteDynamicsWorld.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_DISCRETE_DYNAMICS_WORLD_H
// #define BT_DISCRETE_DYNAMICS_WORLD_H

// #include "btDynamicsWorld.h"
@Opaque public static class btSimulationIslandManager extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public btSimulationIslandManager() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btSimulationIslandManager(Pointer p) { super(p); }
}
@Opaque public static class btPersistentManifold extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public btPersistentManifold() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btPersistentManifold(Pointer p) { super(p); }
}

@Opaque public static class InplaceSolverIslandCallback extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public InplaceSolverIslandCallback() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public InplaceSolverIslandCallback(Pointer p) { super(p); }
}

// #include "LinearMath/btAlignedObjectArray.h"
// #include "LinearMath/btThreads.h"

/**btDiscreteDynamicsWorld provides discrete rigid body simulation
 * those classes replace the obsolete CcdPhysicsEnvironment/CcdPhysicsController */
@NoOffset public static class btDiscreteDynamicsWorld extends btDynamicsWorld {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btDiscreteDynamicsWorld(Pointer p) { super(p); }


	/**this btDiscreteDynamicsWorld constructor gets created objects from the user, and will not delete those */
	public btDiscreteDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration) { super((Pointer)null); allocate(dispatcher, pairCache, constraintSolver, collisionConfiguration); }
	private native void allocate(btDispatcher dispatcher, btBroadphaseInterface pairCache, btConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration);

	/**if maxSubSteps > 0, it will interpolate motion between fixedTimeStep's */
	public native int stepSimulation(@Cast("btScalar") float timeStep, int maxSubSteps/*=1*/, @Cast("btScalar") float fixedTimeStep/*=btScalar(1.) / btScalar(60.)*/);
	public native int stepSimulation(@Cast("btScalar") float timeStep);

    public native void solveConstraints(@ByRef btContactSolverInfo solverInfo);
    
	public native void synchronizeMotionStates();

	/**this can be useful to synchronize a single rigid body -> graphics object */
	public native void synchronizeSingleMotionState(btRigidBody body);

	public native void addConstraint(btTypedConstraint constraint, @Cast("bool") boolean disableCollisionsBetweenLinkedBodies/*=false*/);
	public native void addConstraint(btTypedConstraint constraint);

	public native void removeConstraint(btTypedConstraint constraint);

	public native void addAction(btActionInterface arg0);

	public native void removeAction(btActionInterface arg0);

	public native btSimulationIslandManager getSimulationIslandManager();

	public native btCollisionWorld getCollisionWorld();

	public native void setGravity(@Const @ByRef btVector3 gravity);

	public native @ByVal btVector3 getGravity();

	public native void addCollisionObject(btCollisionObject collisionObject, int collisionFilterGroup/*=btBroadphaseProxy::StaticFilter*/, int collisionFilterMask/*=btBroadphaseProxy::AllFilter ^ btBroadphaseProxy::StaticFilter*/);
	public native void addCollisionObject(btCollisionObject collisionObject);

	public native void addRigidBody(btRigidBody body);

	public native void addRigidBody(btRigidBody body, int group, int mask);

	public native void removeRigidBody(btRigidBody body);

	/**removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btCollisionWorld::removeCollisionObject */
	public native void removeCollisionObject(btCollisionObject collisionObject);

	public native void debugDrawConstraint(btTypedConstraint constraint);

	public native void debugDrawWorld();

	public native void setConstraintSolver(btConstraintSolver solver);

	public native btConstraintSolver getConstraintSolver();

	public native int getNumConstraints();

	public native btTypedConstraint getConstraint(int index);

	public native @Cast("btDynamicsWorldType") int getWorldType();

	/**the forces on each rigidbody is accumulating together with gravity. clear this after each timestep. */
	public native void clearForces();

	/**apply gravity, call this once per timestep */
	public native void applyGravity();

	public native void setNumTasks(int numTasks);

	/**obsolete, use updateActions instead */
	public native void updateVehicles(@Cast("btScalar") float timeStep);

	/**obsolete, use addAction instead */
	public native void addVehicle(btActionInterface vehicle);
	/**obsolete, use removeAction instead */
	public native void removeVehicle(btActionInterface vehicle);
	/**obsolete, use addAction instead */
	public native void addCharacter(btActionInterface character);
	/**obsolete, use removeAction instead */
	public native void removeCharacter(btActionInterface character);

	public native void setSynchronizeAllMotionStates(@Cast("bool") boolean synchronizeAll);
	public native @Cast("bool") boolean getSynchronizeAllMotionStates();

	public native void setApplySpeculativeContactRestitution(@Cast("bool") boolean enable);

	public native @Cast("bool") boolean getApplySpeculativeContactRestitution();

	/**Preliminary serialization test for Bullet 2.76. Loading those files requires a separate parser (see Bullet/Demos/SerializeDemo) */
	public native void serialize(btSerializer serializer);

	/**Interpolate motion state between previous and current transform, instead of current and next transform.
	 * This can relieve discontinuities in the rendering, due to penetrations */
	public native void setLatencyMotionStateInterpolation(@Cast("bool") boolean latencyInterpolation);
	public native @Cast("bool") boolean getLatencyMotionStateInterpolation();
    
    public native @ByRef btAlignedObjectArray_btRigidBodyPointer getNonStaticRigidBodies();
}

// #endif  //BT_DISCRETE_DYNAMICS_WORLD_H


// Parsed from BulletDynamics/Dynamics/btSimpleDynamicsWorld.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_SIMPLE_DYNAMICS_WORLD_H
// #define BT_SIMPLE_DYNAMICS_WORLD_H

// #include "btDynamicsWorld.h"

/**The btSimpleDynamicsWorld serves as unit-test and to verify more complicated and optimized dynamics worlds.
 * Please use btDiscreteDynamicsWorld instead */
@NoOffset public static class btSimpleDynamicsWorld extends btDynamicsWorld {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btSimpleDynamicsWorld(Pointer p) { super(p); }

	/**this btSimpleDynamicsWorld constructor creates dispatcher, broadphase pairCache and constraintSolver */
	public btSimpleDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration) { super((Pointer)null); allocate(dispatcher, pairCache, constraintSolver, collisionConfiguration); }
	private native void allocate(btDispatcher dispatcher, btBroadphaseInterface pairCache, btConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration);

	/**maxSubSteps/fixedTimeStep for interpolation is currently ignored for btSimpleDynamicsWorld, use btDiscreteDynamicsWorld instead */
	public native int stepSimulation(@Cast("btScalar") float timeStep, int maxSubSteps/*=1*/, @Cast("btScalar") float fixedTimeStep/*=btScalar(1.) / btScalar(60.)*/);
	public native int stepSimulation(@Cast("btScalar") float timeStep);

	public native void setGravity(@Const @ByRef btVector3 gravity);

	public native @ByVal btVector3 getGravity();

	public native void addRigidBody(btRigidBody body);

	public native void addRigidBody(btRigidBody body, int group, int mask);

	public native void removeRigidBody(btRigidBody body);

	public native void debugDrawWorld();

	public native void addAction(btActionInterface action);

	public native void removeAction(btActionInterface action);

	/**removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btCollisionWorld::removeCollisionObject */
	public native void removeCollisionObject(btCollisionObject collisionObject);

	public native void updateAabbs();

	public native void synchronizeMotionStates();

	public native void setConstraintSolver(btConstraintSolver solver);

	public native btConstraintSolver getConstraintSolver();

	public native @Cast("btDynamicsWorldType") int getWorldType();

	public native void clearForces();
}

// #endif  //BT_SIMPLE_DYNAMICS_WORLD_H


// Parsed from BulletDynamics/ConstraintSolver/btPoint2PointConstraint.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_POINT2POINTCONSTRAINT_H
// #define BT_POINT2POINTCONSTRAINT_H

// #include "LinearMath/btVector3.h"
// #include "btJacobianEntry.h"
// #include "btTypedConstraint.h"

// #ifdef BT_USE_DOUBLE_PRECISION
// #else
// #define btPoint2PointConstraintData2 btPoint2PointConstraintFloatData
public static final String btPoint2PointConstraintDataName = "btPoint2PointConstraintFloatData";
// #endif  //BT_USE_DOUBLE_PRECISION

@NoOffset public static class btConstraintSetting extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConstraintSetting(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btConstraintSetting(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btConstraintSetting position(long position) {
        return (btConstraintSetting)super.position(position);
    }
    @Override public btConstraintSetting getPointer(long i) {
        return new btConstraintSetting((Pointer)this).offsetAddress(i);
    }

	public btConstraintSetting() { super((Pointer)null); allocate(); }
	private native void allocate();
	public native @Cast("btScalar") float m_tau(); public native btConstraintSetting m_tau(float setter);
	public native @Cast("btScalar") float m_damping(); public native btConstraintSetting m_damping(float setter);
	public native @Cast("btScalar") float m_impulseClamp(); public native btConstraintSetting m_impulseClamp(float setter);
}

/** enum btPoint2PointFlags */
public static final int
	BT_P2P_FLAGS_ERP = 1,
	BT_P2P_FLAGS_CFM = 2;

/** point to point constraint between two rigidbodies each with a pivotpoint that descibes the 'ballsocket' location in local space */
@NoOffset public static class btPoint2PointConstraint extends btTypedConstraint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btPoint2PointConstraint(Pointer p) { super(p); }


	/**for backwards compatibility during the transition to 'getInfo/getInfo2' */
	public native @Cast("bool") boolean m_useSolveConstraintObsolete(); public native btPoint2PointConstraint m_useSolveConstraintObsolete(boolean setter);

	public native @ByRef btConstraintSetting m_setting(); public native btPoint2PointConstraint m_setting(btConstraintSetting setter);

	public btPoint2PointConstraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 pivotInB) { super((Pointer)null); allocate(rbA, rbB, pivotInA, pivotInB); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 pivotInB);

	public btPoint2PointConstraint(@ByRef btRigidBody rbA, @Const @ByRef btVector3 pivotInA) { super((Pointer)null); allocate(rbA, pivotInA); }
	private native void allocate(@ByRef btRigidBody rbA, @Const @ByRef btVector3 pivotInA);

	public native void buildJacobian();

	public native void updateRHS(@Cast("btScalar") float timeStep);

	public native void setPivotA(@Const @ByRef btVector3 pivotA);

	public native void setPivotB(@Const @ByRef btVector3 pivotB);

	public native @Const @ByRef btVector3 getPivotInA();

	public native @Const @ByRef btVector3 getPivotInB();

	/**override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
	 * If no axis is provided, it uses the default axis for this constraint. */
	public native void setParam(int num, @Cast("btScalar") float value, int axis/*=-1*/);
	public native void setParam(int num, @Cast("btScalar") float value);
	/**return the local value of parameter */
	public native @Cast("btScalar") float getParam(int num, int axis/*=-1*/);
	public native @Cast("btScalar") float getParam(int num);

	public native int getFlags();

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);
}

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btPoint2PointConstraintFloatData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btPoint2PointConstraintFloatData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btPoint2PointConstraintFloatData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btPoint2PointConstraintFloatData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btPoint2PointConstraintFloatData position(long position) {
        return (btPoint2PointConstraintFloatData)super.position(position);
    }
    @Override public btPoint2PointConstraintFloatData getPointer(long i) {
        return new btPoint2PointConstraintFloatData((Pointer)this).offsetAddress(i);
    }

	
	public native @ByRef btVector3FloatData m_pivotInA(); public native btPoint2PointConstraintFloatData m_pivotInA(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_pivotInB(); public native btPoint2PointConstraintFloatData m_pivotInB(btVector3FloatData setter);
}

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btPoint2PointConstraintDoubleData2 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btPoint2PointConstraintDoubleData2() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btPoint2PointConstraintDoubleData2(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btPoint2PointConstraintDoubleData2(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btPoint2PointConstraintDoubleData2 position(long position) {
        return (btPoint2PointConstraintDoubleData2)super.position(position);
    }
    @Override public btPoint2PointConstraintDoubleData2 getPointer(long i) {
        return new btPoint2PointConstraintDoubleData2((Pointer)this).offsetAddress(i);
    }

	
	public native @ByRef btVector3DoubleData m_pivotInA(); public native btPoint2PointConstraintDoubleData2 m_pivotInA(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_pivotInB(); public native btPoint2PointConstraintDoubleData2 m_pivotInB(btVector3DoubleData setter);
}

// #ifdef BT_BACKWARDS_COMPATIBLE_SERIALIZATION
/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
 * this structure is not used, except for loading pre-2.82 .bullet files
 * do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btPoint2PointConstraintDoubleData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btPoint2PointConstraintDoubleData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btPoint2PointConstraintDoubleData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btPoint2PointConstraintDoubleData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btPoint2PointConstraintDoubleData position(long position) {
        return (btPoint2PointConstraintDoubleData)super.position(position);
    }
    @Override public btPoint2PointConstraintDoubleData getPointer(long i) {
        return new btPoint2PointConstraintDoubleData((Pointer)this).offsetAddress(i);
    }

	
	public native @ByRef btVector3DoubleData m_pivotInA(); public native btPoint2PointConstraintDoubleData m_pivotInA(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_pivotInB(); public native btPoint2PointConstraintDoubleData m_pivotInB(btVector3DoubleData setter);
}
// #endif  //BT_BACKWARDS_COMPATIBLE_SERIALIZATION



/**fills the dataBuffer and returns the struct name (and 0 on failure) */


// #endif  //BT_POINT2POINTCONSTRAINT_H


// Parsed from BulletDynamics/ConstraintSolver/btHingeConstraint.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/* Hinge Constraint by Dirk Gregorius. Limits added by Marcus Hennix at Starbreeze Studios */

// #ifndef BT_HINGECONSTRAINT_H
// #define BT_HINGECONSTRAINT_H

public static final int _BT_USE_CENTER_LIMIT_ = 1;

// #include "LinearMath/btVector3.h"
// #include "btJacobianEntry.h"
// #include "btTypedConstraint.h"

// #ifdef BT_USE_DOUBLE_PRECISION
// #else
// #define btHingeConstraintData btHingeConstraintFloatData
public static final String btHingeConstraintDataName = "btHingeConstraintFloatData";
// #endif  //BT_USE_DOUBLE_PRECISION

/** enum btHingeFlags */
public static final int
	BT_HINGE_FLAGS_CFM_STOP = 1,
	BT_HINGE_FLAGS_ERP_STOP = 2,
	BT_HINGE_FLAGS_CFM_NORM = 4,
	BT_HINGE_FLAGS_ERP_NORM = 8;

/** hinge constraint between two rigidbodies each with a pivotpoint that descibes the axis location in local space
 *  axis defines the orientation of the hinge axis */
@NoOffset public static class btHingeConstraint extends btTypedConstraint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btHingeConstraint(Pointer p) { super(p); }


	public btHingeConstraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 pivotInB, @Const @ByRef btVector3 axisInA, @Const @ByRef btVector3 axisInB, @Cast("bool") boolean useReferenceFrameA/*=false*/) { super((Pointer)null); allocate(rbA, rbB, pivotInA, pivotInB, axisInA, axisInB, useReferenceFrameA); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 pivotInB, @Const @ByRef btVector3 axisInA, @Const @ByRef btVector3 axisInB, @Cast("bool") boolean useReferenceFrameA/*=false*/);
	public btHingeConstraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 pivotInB, @Const @ByRef btVector3 axisInA, @Const @ByRef btVector3 axisInB) { super((Pointer)null); allocate(rbA, rbB, pivotInA, pivotInB, axisInA, axisInB); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 pivotInB, @Const @ByRef btVector3 axisInA, @Const @ByRef btVector3 axisInB);

	public btHingeConstraint(@ByRef btRigidBody rbA, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 axisInA, @Cast("bool") boolean useReferenceFrameA/*=false*/) { super((Pointer)null); allocate(rbA, pivotInA, axisInA, useReferenceFrameA); }
	private native void allocate(@ByRef btRigidBody rbA, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 axisInA, @Cast("bool") boolean useReferenceFrameA/*=false*/);
	public btHingeConstraint(@ByRef btRigidBody rbA, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 axisInA) { super((Pointer)null); allocate(rbA, pivotInA, axisInA); }
	private native void allocate(@ByRef btRigidBody rbA, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 axisInA);

	public btHingeConstraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform rbAFrame, @Const @ByRef btTransform rbBFrame, @Cast("bool") boolean useReferenceFrameA/*=false*/) { super((Pointer)null); allocate(rbA, rbB, rbAFrame, rbBFrame, useReferenceFrameA); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform rbAFrame, @Const @ByRef btTransform rbBFrame, @Cast("bool") boolean useReferenceFrameA/*=false*/);
	public btHingeConstraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform rbAFrame, @Const @ByRef btTransform rbBFrame) { super((Pointer)null); allocate(rbA, rbB, rbAFrame, rbBFrame); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform rbAFrame, @Const @ByRef btTransform rbBFrame);

	public btHingeConstraint(@ByRef btRigidBody rbA, @Const @ByRef btTransform rbAFrame, @Cast("bool") boolean useReferenceFrameA/*=false*/) { super((Pointer)null); allocate(rbA, rbAFrame, useReferenceFrameA); }
	private native void allocate(@ByRef btRigidBody rbA, @Const @ByRef btTransform rbAFrame, @Cast("bool") boolean useReferenceFrameA/*=false*/);
	public btHingeConstraint(@ByRef btRigidBody rbA, @Const @ByRef btTransform rbAFrame) { super((Pointer)null); allocate(rbA, rbAFrame); }
	private native void allocate(@ByRef btRigidBody rbA, @Const @ByRef btTransform rbAFrame);

	public native void buildJacobian();

	public native void updateRHS(@Cast("btScalar") float timeStep);

	public native @ByRef btRigidBody getRigidBodyA();

	public native @ByRef btRigidBody getRigidBodyB();

	public native @ByRef btTransform getFrameOffsetA();

	public native @ByRef btTransform getFrameOffsetB();

	public native void setFrames(@Const @ByRef btTransform frameA, @Const @ByRef btTransform frameB);

	public native void setAngularOnly(@Cast("bool") boolean angularOnly);

	public native void enableAngularMotor(@Cast("bool") boolean enableMotor, @Cast("btScalar") float targetVelocity, @Cast("btScalar") float maxMotorImpulse);

	// extra motor API, including ability to set a target rotation (as opposed to angular velocity)
	// note: setMotorTarget sets angular velocity under the hood, so you must call it every tick to
	//       maintain a given angular target.
	public native void enableMotor(@Cast("bool") boolean enableMotor);
	public native void setMaxMotorImpulse(@Cast("btScalar") float maxMotorImpulse);
	public native void setMotorTargetVelocity(@Cast("btScalar") float motorTargetVelocity);
	public native void setMotorTarget(@Const @ByRef btQuaternion qAinB, @Cast("btScalar") float dt);  // qAinB is rotation of body A wrt body B.
	public native void setMotorTarget(@Cast("btScalar") float targetAngle, @Cast("btScalar") float dt);

	public native void setLimit(@Cast("btScalar") float low, @Cast("btScalar") float high, @Cast("btScalar") float _softness/*=0.9f*/, @Cast("btScalar") float _biasFactor/*=0.3f*/, @Cast("btScalar") float _relaxationFactor/*=1.0f*/);
	public native void setLimit(@Cast("btScalar") float low, @Cast("btScalar") float high);

	public native @Cast("btScalar") float getLimitSoftness();

	public native @Cast("btScalar") float getLimitBiasFactor();

	public native @Cast("btScalar") float getLimitRelaxationFactor();

	public native void setAxis(@ByRef btVector3 axisInA);

	public native @Cast("bool") boolean hasLimit();

	public native @Cast("btScalar") float getLowerLimit();

	public native @Cast("btScalar") float getUpperLimit();

	/**The getHingeAngle gives the hinge angle in range [-PI,PI] */
	public native @Cast("btScalar") float getHingeAngle();

	public native @Cast("btScalar") float getHingeAngle(@Const @ByRef btTransform transA, @Const @ByRef btTransform transB);

	public native void testLimit(@Const @ByRef btTransform transA, @Const @ByRef btTransform transB);

	public native @ByRef btTransform getAFrame();
	public native @ByRef btTransform getBFrame();

	public native int getSolveLimit();

	public native @Cast("btScalar") float getLimitSign();

	public native @Cast("bool") boolean getAngularOnly();
	public native @Cast("bool") boolean getEnableAngularMotor();
	public native @Cast("btScalar") float getMotorTargetVelocity();
	public native @Cast("btScalar") float getMaxMotorImpulse();
	// access for UseFrameOffset
	public native @Cast("bool") boolean getUseFrameOffset();
	public native void setUseFrameOffset(@Cast("bool") boolean frameOffsetOnOff);
	// access for UseReferenceFrameA
	public native @Cast("bool") boolean getUseReferenceFrameA();
	public native void setUseReferenceFrameA(@Cast("bool") boolean useReferenceFrameA);

	/**override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
	 * If no axis is provided, it uses the default axis for this constraint. */
	public native void setParam(int num, @Cast("btScalar") float value, int axis/*=-1*/);
	public native void setParam(int num, @Cast("btScalar") float value);
	/**return the local value of parameter */
	public native @Cast("btScalar") float getParam(int num, int axis/*=-1*/);
	public native @Cast("btScalar") float getParam(int num);

	public native int getFlags();

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);
}

//only for backward compatibility
// #ifdef BT_BACKWARDS_COMPATIBLE_SERIALIZATION
/**this structure is not used, except for loading pre-2.82 .bullet files */
public static class btHingeConstraintDoubleData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btHingeConstraintDoubleData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btHingeConstraintDoubleData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btHingeConstraintDoubleData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btHingeConstraintDoubleData position(long position) {
        return (btHingeConstraintDoubleData)super.position(position);
    }
    @Override public btHingeConstraintDoubleData getPointer(long i) {
        return new btHingeConstraintDoubleData((Pointer)this).offsetAddress(i);
    }

	
	public native @ByRef btTransformDoubleData m_rbAFrame(); public native btHingeConstraintDoubleData m_rbAFrame(btTransformDoubleData setter);  // constraint axii. Assumes z is hinge axis.
	public native @ByRef btTransformDoubleData m_rbBFrame(); public native btHingeConstraintDoubleData m_rbBFrame(btTransformDoubleData setter);
	public native int m_useReferenceFrameA(); public native btHingeConstraintDoubleData m_useReferenceFrameA(int setter);
	public native int m_angularOnly(); public native btHingeConstraintDoubleData m_angularOnly(int setter);
	public native int m_enableAngularMotor(); public native btHingeConstraintDoubleData m_enableAngularMotor(int setter);
	public native float m_motorTargetVelocity(); public native btHingeConstraintDoubleData m_motorTargetVelocity(float setter);
	public native float m_maxMotorImpulse(); public native btHingeConstraintDoubleData m_maxMotorImpulse(float setter);

	public native float m_lowerLimit(); public native btHingeConstraintDoubleData m_lowerLimit(float setter);
	public native float m_upperLimit(); public native btHingeConstraintDoubleData m_upperLimit(float setter);
	public native float m_limitSoftness(); public native btHingeConstraintDoubleData m_limitSoftness(float setter);
	public native float m_biasFactor(); public native btHingeConstraintDoubleData m_biasFactor(float setter);
	public native float m_relaxationFactor(); public native btHingeConstraintDoubleData m_relaxationFactor(float setter);
}
// #endif  //BT_BACKWARDS_COMPATIBLE_SERIALIZATION

/**The getAccumulatedHingeAngle returns the accumulated hinge angle, taking rotation across the -PI/PI boundary into account */
@NoOffset public static class btHingeAccumulatedAngleConstraint extends btHingeConstraint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btHingeAccumulatedAngleConstraint(Pointer p) { super(p); }


	public btHingeAccumulatedAngleConstraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 pivotInB, @Const @ByRef btVector3 axisInA, @Const @ByRef btVector3 axisInB, @Cast("bool") boolean useReferenceFrameA/*=false*/) { super((Pointer)null); allocate(rbA, rbB, pivotInA, pivotInB, axisInA, axisInB, useReferenceFrameA); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 pivotInB, @Const @ByRef btVector3 axisInA, @Const @ByRef btVector3 axisInB, @Cast("bool") boolean useReferenceFrameA/*=false*/);
	public btHingeAccumulatedAngleConstraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 pivotInB, @Const @ByRef btVector3 axisInA, @Const @ByRef btVector3 axisInB) { super((Pointer)null); allocate(rbA, rbB, pivotInA, pivotInB, axisInA, axisInB); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 pivotInB, @Const @ByRef btVector3 axisInA, @Const @ByRef btVector3 axisInB);

	public btHingeAccumulatedAngleConstraint(@ByRef btRigidBody rbA, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 axisInA, @Cast("bool") boolean useReferenceFrameA/*=false*/) { super((Pointer)null); allocate(rbA, pivotInA, axisInA, useReferenceFrameA); }
	private native void allocate(@ByRef btRigidBody rbA, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 axisInA, @Cast("bool") boolean useReferenceFrameA/*=false*/);
	public btHingeAccumulatedAngleConstraint(@ByRef btRigidBody rbA, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 axisInA) { super((Pointer)null); allocate(rbA, pivotInA, axisInA); }
	private native void allocate(@ByRef btRigidBody rbA, @Const @ByRef btVector3 pivotInA, @Const @ByRef btVector3 axisInA);

	public btHingeAccumulatedAngleConstraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform rbAFrame, @Const @ByRef btTransform rbBFrame, @Cast("bool") boolean useReferenceFrameA/*=false*/) { super((Pointer)null); allocate(rbA, rbB, rbAFrame, rbBFrame, useReferenceFrameA); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform rbAFrame, @Const @ByRef btTransform rbBFrame, @Cast("bool") boolean useReferenceFrameA/*=false*/);
	public btHingeAccumulatedAngleConstraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform rbAFrame, @Const @ByRef btTransform rbBFrame) { super((Pointer)null); allocate(rbA, rbB, rbAFrame, rbBFrame); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform rbAFrame, @Const @ByRef btTransform rbBFrame);

	public btHingeAccumulatedAngleConstraint(@ByRef btRigidBody rbA, @Const @ByRef btTransform rbAFrame, @Cast("bool") boolean useReferenceFrameA/*=false*/) { super((Pointer)null); allocate(rbA, rbAFrame, useReferenceFrameA); }
	private native void allocate(@ByRef btRigidBody rbA, @Const @ByRef btTransform rbAFrame, @Cast("bool") boolean useReferenceFrameA/*=false*/);
	public btHingeAccumulatedAngleConstraint(@ByRef btRigidBody rbA, @Const @ByRef btTransform rbAFrame) { super((Pointer)null); allocate(rbA, rbAFrame); }
	private native void allocate(@ByRef btRigidBody rbA, @Const @ByRef btTransform rbAFrame);
	public native @Cast("btScalar") float getAccumulatedHingeAngle();
	public native void setAccumulatedHingeAngle(@Cast("btScalar") float accAngle);
}

public static class btHingeConstraintFloatData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btHingeConstraintFloatData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btHingeConstraintFloatData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btHingeConstraintFloatData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btHingeConstraintFloatData position(long position) {
        return (btHingeConstraintFloatData)super.position(position);
    }
    @Override public btHingeConstraintFloatData getPointer(long i) {
        return new btHingeConstraintFloatData((Pointer)this).offsetAddress(i);
    }

	
	public native @ByRef btTransformFloatData m_rbAFrame(); public native btHingeConstraintFloatData m_rbAFrame(btTransformFloatData setter);  // constraint axii. Assumes z is hinge axis.
	public native @ByRef btTransformFloatData m_rbBFrame(); public native btHingeConstraintFloatData m_rbBFrame(btTransformFloatData setter);
	public native int m_useReferenceFrameA(); public native btHingeConstraintFloatData m_useReferenceFrameA(int setter);
	public native int m_angularOnly(); public native btHingeConstraintFloatData m_angularOnly(int setter);

	public native int m_enableAngularMotor(); public native btHingeConstraintFloatData m_enableAngularMotor(int setter);
	public native float m_motorTargetVelocity(); public native btHingeConstraintFloatData m_motorTargetVelocity(float setter);
	public native float m_maxMotorImpulse(); public native btHingeConstraintFloatData m_maxMotorImpulse(float setter);

	public native float m_lowerLimit(); public native btHingeConstraintFloatData m_lowerLimit(float setter);
	public native float m_upperLimit(); public native btHingeConstraintFloatData m_upperLimit(float setter);
	public native float m_limitSoftness(); public native btHingeConstraintFloatData m_limitSoftness(float setter);
	public native float m_biasFactor(); public native btHingeConstraintFloatData m_biasFactor(float setter);
	public native float m_relaxationFactor(); public native btHingeConstraintFloatData m_relaxationFactor(float setter);
}

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btHingeConstraintDoubleData2 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btHingeConstraintDoubleData2() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btHingeConstraintDoubleData2(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btHingeConstraintDoubleData2(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btHingeConstraintDoubleData2 position(long position) {
        return (btHingeConstraintDoubleData2)super.position(position);
    }
    @Override public btHingeConstraintDoubleData2 getPointer(long i) {
        return new btHingeConstraintDoubleData2((Pointer)this).offsetAddress(i);
    }

	
	public native @ByRef btTransformDoubleData m_rbAFrame(); public native btHingeConstraintDoubleData2 m_rbAFrame(btTransformDoubleData setter);  // constraint axii. Assumes z is hinge axis.
	public native @ByRef btTransformDoubleData m_rbBFrame(); public native btHingeConstraintDoubleData2 m_rbBFrame(btTransformDoubleData setter);
	public native int m_useReferenceFrameA(); public native btHingeConstraintDoubleData2 m_useReferenceFrameA(int setter);
	public native int m_angularOnly(); public native btHingeConstraintDoubleData2 m_angularOnly(int setter);
	public native int m_enableAngularMotor(); public native btHingeConstraintDoubleData2 m_enableAngularMotor(int setter);
	public native double m_motorTargetVelocity(); public native btHingeConstraintDoubleData2 m_motorTargetVelocity(double setter);
	public native double m_maxMotorImpulse(); public native btHingeConstraintDoubleData2 m_maxMotorImpulse(double setter);

	public native double m_lowerLimit(); public native btHingeConstraintDoubleData2 m_lowerLimit(double setter);
	public native double m_upperLimit(); public native btHingeConstraintDoubleData2 m_upperLimit(double setter);
	public native double m_limitSoftness(); public native btHingeConstraintDoubleData2 m_limitSoftness(double setter);
	public native double m_biasFactor(); public native btHingeConstraintDoubleData2 m_biasFactor(double setter);
	public native double m_relaxationFactor(); public native btHingeConstraintDoubleData2 m_relaxationFactor(double setter);
	public native @Cast("char") byte m_padding1(int i); public native btHingeConstraintDoubleData2 m_padding1(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_padding1();
}



/**fills the dataBuffer and returns the struct name (and 0 on failure) */


// #endif  //BT_HINGECONSTRAINT_H


// Parsed from BulletDynamics/ConstraintSolver/btConeTwistConstraint.h

/*
Bullet Continuous Collision Detection and Physics Library
btConeTwistConstraint is Copyright (c) 2007 Starbreeze Studios

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

Written by: Marcus Hennix
*/

/*
Overview:

btConeTwistConstraint can be used to simulate ragdoll joints (upper arm, leg etc).
It is a fixed translation, 3 degree-of-freedom (DOF) rotational "joint".
It divides the 3 rotational DOFs into swing (movement within a cone) and twist.
Swing is divided into swing1 and swing2 which can have different limits, giving an elliptical shape.
(Note: the cone's base isn't flat, so this ellipse is "embedded" on the surface of a sphere.)

In the contraint's frame of reference:
twist is along the x-axis,
and swing 1 and 2 are along the z and y axes respectively.
*/

// #ifndef BT_CONETWISTCONSTRAINT_H
// #define BT_CONETWISTCONSTRAINT_H

// #include "LinearMath/btVector3.h"
// #include "btJacobianEntry.h"
// #include "btTypedConstraint.h"

// #ifdef BT_USE_DOUBLE_PRECISION
// #else
// #define btConeTwistConstraintData2 btConeTwistConstraintData
public static final String btConeTwistConstraintDataName = "btConeTwistConstraintData";
// #endif  //BT_USE_DOUBLE_PRECISION

/** enum btConeTwistFlags */
public static final int
	BT_CONETWIST_FLAGS_LIN_CFM = 1,
	BT_CONETWIST_FLAGS_LIN_ERP = 2,
	BT_CONETWIST_FLAGS_ANG_CFM = 4;

/**btConeTwistConstraint can be used to simulate ragdoll joints (upper arm, leg etc) */
@NoOffset public static class btConeTwistConstraint extends btTypedConstraint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConeTwistConstraint(Pointer p) { super(p); }


	public btConeTwistConstraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform rbAFrame, @Const @ByRef btTransform rbBFrame) { super((Pointer)null); allocate(rbA, rbB, rbAFrame, rbBFrame); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform rbAFrame, @Const @ByRef btTransform rbBFrame);

	public btConeTwistConstraint(@ByRef btRigidBody rbA, @Const @ByRef btTransform rbAFrame) { super((Pointer)null); allocate(rbA, rbAFrame); }
	private native void allocate(@ByRef btRigidBody rbA, @Const @ByRef btTransform rbAFrame);

	public native void buildJacobian();

	

	public native void updateRHS(@Cast("btScalar") float timeStep);

	public native @Const @ByRef btRigidBody getRigidBodyA();
	public native @Const @ByRef btRigidBody getRigidBodyB();

	public native void setAngularOnly(@Cast("bool") boolean angularOnly);

	public native @Cast("bool") boolean getAngularOnly();

	public native void setLimit(int limitIndex, @Cast("btScalar") float limitValue);

	public native @Cast("btScalar") float getLimit(int limitIndex);

	// setLimit(), a few notes:
	// _softness:
	//		0->1, recommend ~0.8->1.
	//		describes % of limits where movement is free.
	//		beyond this softness %, the limit is gradually enforced until the "hard" (1.0) limit is reached.
	// _biasFactor:
	//		0->1?, recommend 0.3 +/-0.3 or so.
	//		strength with which constraint resists zeroth order (angular, not angular velocity) limit violation.
	// __relaxationFactor:
	//		0->1, recommend to stay near 1.
	//		the lower the value, the less the constraint will fight velocities which violate the angular limits.
	public native void setLimit(@Cast("btScalar") float _swingSpan1, @Cast("btScalar") float _swingSpan2, @Cast("btScalar") float _twistSpan, @Cast("btScalar") float _softness/*=1.f*/, @Cast("btScalar") float _biasFactor/*=0.3f*/, @Cast("btScalar") float _relaxationFactor/*=1.0f*/);
	public native void setLimit(@Cast("btScalar") float _swingSpan1, @Cast("btScalar") float _swingSpan2, @Cast("btScalar") float _twistSpan);

	public native @Const @ByRef btTransform getAFrame();
	public native @Const @ByRef btTransform getBFrame();

	public native int getSolveTwistLimit();

	public native int getSolveSwingLimit();

	public native @Cast("btScalar") float getTwistLimitSign();

	public native void calcAngleInfo();
	public native void calcAngleInfo2(@Const @ByRef btTransform transA, @Const @ByRef btTransform transB, @Const @ByRef btMatrix3x3 invInertiaWorldA, @Const @ByRef btMatrix3x3 invInertiaWorldB);

	public native @Cast("btScalar") float getSwingSpan1();
	public native @Cast("btScalar") float getSwingSpan2();
	public native @Cast("btScalar") float getTwistSpan();
	public native @Cast("btScalar") float getLimitSoftness();
	public native @Cast("btScalar") float getBiasFactor();
	public native @Cast("btScalar") float getRelaxationFactor();
	public native @Cast("btScalar") float getTwistAngle();
	public native @Cast("bool") boolean isPastSwingLimit();

	public native @Cast("btScalar") float getDamping();
	public native void setDamping(@Cast("btScalar") float damping);

	public native void enableMotor(@Cast("bool") boolean b);
	public native @Cast("bool") boolean isMotorEnabled();
	public native @Cast("btScalar") float getMaxMotorImpulse();
	public native @Cast("bool") boolean isMaxMotorImpulseNormalized();
	public native void setMaxMotorImpulse(@Cast("btScalar") float maxMotorImpulse);
	public native void setMaxMotorImpulseNormalized(@Cast("btScalar") float maxMotorImpulse);

	public native @Cast("btScalar") float getFixThresh();
	public native void setFixThresh(@Cast("btScalar") float fixThresh);

	// setMotorTarget:
	// q: the desired rotation of bodyA wrt bodyB.
	// note: if q violates the joint limits, the internal target is clamped to avoid conflicting impulses (very bad for stability)
	// note: don't forget to enableMotor()
	public native void setMotorTarget(@Const @ByRef btQuaternion q);
	public native @Const @ByRef btQuaternion getMotorTarget();

	// same as above, but q is the desired rotation of frameA wrt frameB in constraint space
	public native void setMotorTargetInConstraintSpace(@Const @ByRef btQuaternion q);

	public native @ByVal btVector3 GetPointForAngle(@Cast("btScalar") float fAngleInRadians, @Cast("btScalar") float fLength);

	/**override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
	 * If no axis is provided, it uses the default axis for this constraint. */
	public native void setParam(int num, @Cast("btScalar") float value, int axis/*=-1*/);
	public native void setParam(int num, @Cast("btScalar") float value);

	public native void setFrames(@Const @ByRef btTransform frameA, @Const @ByRef btTransform frameB);

	public native @Const @ByRef btTransform getFrameOffsetA();

	public native @Const @ByRef btTransform getFrameOffsetB();

	/**return the local value of parameter */
	public native @Cast("btScalar") float getParam(int num, int axis/*=-1*/);
	public native @Cast("btScalar") float getParam(int num);

	public native int getFlags();

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);
}

public static class btConeTwistConstraintDoubleData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btConeTwistConstraintDoubleData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btConeTwistConstraintDoubleData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConeTwistConstraintDoubleData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btConeTwistConstraintDoubleData position(long position) {
        return (btConeTwistConstraintDoubleData)super.position(position);
    }
    @Override public btConeTwistConstraintDoubleData getPointer(long i) {
        return new btConeTwistConstraintDoubleData((Pointer)this).offsetAddress(i);
    }

	
	public native @ByRef btTransformDoubleData m_rbAFrame(); public native btConeTwistConstraintDoubleData m_rbAFrame(btTransformDoubleData setter);
	public native @ByRef btTransformDoubleData m_rbBFrame(); public native btConeTwistConstraintDoubleData m_rbBFrame(btTransformDoubleData setter);

	//limits
	public native double m_swingSpan1(); public native btConeTwistConstraintDoubleData m_swingSpan1(double setter);
	public native double m_swingSpan2(); public native btConeTwistConstraintDoubleData m_swingSpan2(double setter);
	public native double m_twistSpan(); public native btConeTwistConstraintDoubleData m_twistSpan(double setter);
	public native double m_limitSoftness(); public native btConeTwistConstraintDoubleData m_limitSoftness(double setter);
	public native double m_biasFactor(); public native btConeTwistConstraintDoubleData m_biasFactor(double setter);
	public native double m_relaxationFactor(); public native btConeTwistConstraintDoubleData m_relaxationFactor(double setter);

	public native double m_damping(); public native btConeTwistConstraintDoubleData m_damping(double setter);
}

// #ifdef BT_BACKWARDS_COMPATIBLE_SERIALIZATION
/**this structure is not used, except for loading pre-2.82 .bullet files */
public static class btConeTwistConstraintData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btConeTwistConstraintData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btConeTwistConstraintData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConeTwistConstraintData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btConeTwistConstraintData position(long position) {
        return (btConeTwistConstraintData)super.position(position);
    }
    @Override public btConeTwistConstraintData getPointer(long i) {
        return new btConeTwistConstraintData((Pointer)this).offsetAddress(i);
    }

	
	public native @ByRef btTransformFloatData m_rbAFrame(); public native btConeTwistConstraintData m_rbAFrame(btTransformFloatData setter);
	public native @ByRef btTransformFloatData m_rbBFrame(); public native btConeTwistConstraintData m_rbBFrame(btTransformFloatData setter);

	//limits
	public native float m_swingSpan1(); public native btConeTwistConstraintData m_swingSpan1(float setter);
	public native float m_swingSpan2(); public native btConeTwistConstraintData m_swingSpan2(float setter);
	public native float m_twistSpan(); public native btConeTwistConstraintData m_twistSpan(float setter);
	public native float m_limitSoftness(); public native btConeTwistConstraintData m_limitSoftness(float setter);
	public native float m_biasFactor(); public native btConeTwistConstraintData m_biasFactor(float setter);
	public native float m_relaxationFactor(); public native btConeTwistConstraintData m_relaxationFactor(float setter);

	public native float m_damping(); public native btConeTwistConstraintData m_damping(float setter);

	public native @Cast("char") byte m_pad(int i); public native btConeTwistConstraintData m_pad(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_pad();
}
// #endif  //BT_BACKWARDS_COMPATIBLE_SERIALIZATION
//



/**fills the dataBuffer and returns the struct name (and 0 on failure) */


// #endif  //BT_CONETWISTCONSTRAINT_H


// Parsed from BulletDynamics/ConstraintSolver/btGeneric6DofConstraint.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/** 2009 March: btGeneric6DofConstraint refactored by Roman Ponomarev
/** Added support for generic constraint solver through getInfo1/getInfo2 methods */

/*
2007-09-09
btGeneric6DofConstraint Refactored by Francisco Le?n
email: projectileman@yahoo.com
http://gimpact.sf.net
*/

// #ifndef BT_GENERIC_6DOF_CONSTRAINT_H
// #define BT_GENERIC_6DOF_CONSTRAINT_H

// #include "LinearMath/btVector3.h"
// #include "btJacobianEntry.h"
// #include "btTypedConstraint.h"

// #ifdef BT_USE_DOUBLE_PRECISION
// #else
// #define btGeneric6DofConstraintData2 btGeneric6DofConstraintData
public static final String btGeneric6DofConstraintDataName = "btGeneric6DofConstraintData";
// #endif  //BT_USE_DOUBLE_PRECISION

/** Rotation Limit structure for generic joints */
@NoOffset public static class btRotationalLimitMotor extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btRotationalLimitMotor(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btRotationalLimitMotor(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btRotationalLimitMotor position(long position) {
        return (btRotationalLimitMotor)super.position(position);
    }
    @Override public btRotationalLimitMotor getPointer(long i) {
        return new btRotationalLimitMotor((Pointer)this).offsetAddress(i);
    }

	/** limit_parameters
	 * \{ */
	/** joint limit */
	public native @Cast("btScalar") float m_loLimit(); public native btRotationalLimitMotor m_loLimit(float setter);
	/** joint limit */
	public native @Cast("btScalar") float m_hiLimit(); public native btRotationalLimitMotor m_hiLimit(float setter);
	/** target motor velocity */
	public native @Cast("btScalar") float m_targetVelocity(); public native btRotationalLimitMotor m_targetVelocity(float setter);
	/** max force on motor */
	public native @Cast("btScalar") float m_maxMotorForce(); public native btRotationalLimitMotor m_maxMotorForce(float setter);
	/** max force on limit */
	public native @Cast("btScalar") float m_maxLimitForce(); public native btRotationalLimitMotor m_maxLimitForce(float setter);
	/** Damping. */
	public native @Cast("btScalar") float m_damping(); public native btRotationalLimitMotor m_damping(float setter);
	public native @Cast("btScalar") float m_limitSoftness(); public native btRotationalLimitMotor m_limitSoftness(float setter);   /** Relaxation factor */
	/** Constraint force mixing factor */
	public native @Cast("btScalar") float m_normalCFM(); public native btRotationalLimitMotor m_normalCFM(float setter);
	/** Error tolerance factor when joint is at limit */
	public native @Cast("btScalar") float m_stopERP(); public native btRotationalLimitMotor m_stopERP(float setter);
	/** Constraint force mixing factor when joint is at limit */
	public native @Cast("btScalar") float m_stopCFM(); public native btRotationalLimitMotor m_stopCFM(float setter);
	/** restitution factor */
	public native @Cast("btScalar") float m_bounce(); public native btRotationalLimitMotor m_bounce(float setter);
	public native @Cast("bool") boolean m_enableMotor(); public native btRotationalLimitMotor m_enableMotor(boolean setter);

	/**\}
	 <p>
	 *  temp_variables
	 * \{ */
	public native @Cast("btScalar") float m_currentLimitError(); public native btRotationalLimitMotor m_currentLimitError(float setter);  /**  How much is violated this limit */
	public native @Cast("btScalar") float m_currentPosition(); public native btRotationalLimitMotor m_currentPosition(float setter);    /**  current value of angle */
	/** 0=free, 1=at lo limit, 2=at hi limit */
	public native int m_currentLimit(); public native btRotationalLimitMotor m_currentLimit(int setter);
	public native @Cast("btScalar") float m_accumulatedImpulse(); public native btRotationalLimitMotor m_accumulatedImpulse(float setter);
	/**\} */

	public btRotationalLimitMotor() { super((Pointer)null); allocate(); }
	private native void allocate();

	public btRotationalLimitMotor(@Const @ByRef btRotationalLimitMotor limot) { super((Pointer)null); allocate(limot); }
	private native void allocate(@Const @ByRef btRotationalLimitMotor limot);

	/** Is limited */
	public native @Cast("bool") boolean isLimited();

	/** Need apply correction */
	public native @Cast("bool") boolean needApplyTorques();

	/** calculates  error
	/**
	calculates m_currentLimit and m_currentLimitError.
	*/
	public native int testLimitValue(@Cast("btScalar") float test_value);

	/** apply the correction impulses for two bodies */
	public native @Cast("btScalar") float solveAngularLimits(@Cast("btScalar") float timeStep, @ByRef btVector3 axis, @Cast("btScalar") float jacDiagABInv, btRigidBody body0, btRigidBody body1);
}

@NoOffset public static class btTranslationalLimitMotor extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btTranslationalLimitMotor(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btTranslationalLimitMotor(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btTranslationalLimitMotor position(long position) {
        return (btTranslationalLimitMotor)super.position(position);
    }
    @Override public btTranslationalLimitMotor getPointer(long i) {
        return new btTranslationalLimitMotor((Pointer)this).offsetAddress(i);
    }

	/** the constraint lower limits */
	public native @ByRef btVector3 m_lowerLimit(); public native btTranslationalLimitMotor m_lowerLimit(btVector3 setter);
	/** the constraint upper limits */
	public native @ByRef btVector3 m_upperLimit(); public native btTranslationalLimitMotor m_upperLimit(btVector3 setter);
	public native @ByRef btVector3 m_accumulatedImpulse(); public native btTranslationalLimitMotor m_accumulatedImpulse(btVector3 setter);
	/** Linear_Limit_parameters
	 * \{ */
	/** Softness for linear limit */
	public native @Cast("btScalar") float m_limitSoftness(); public native btTranslationalLimitMotor m_limitSoftness(float setter);
	/** Damping for linear limit */
	public native @Cast("btScalar") float m_damping(); public native btTranslationalLimitMotor m_damping(float setter);
	public native @Cast("btScalar") float m_restitution(); public native btTranslationalLimitMotor m_restitution(float setter);    /** Bounce parameter for linear limit */
	/** Constraint force mixing factor */
	public native @ByRef btVector3 m_normalCFM(); public native btTranslationalLimitMotor m_normalCFM(btVector3 setter);
	/** Error tolerance factor when joint is at limit */
	public native @ByRef btVector3 m_stopERP(); public native btTranslationalLimitMotor m_stopERP(btVector3 setter);
	/** Constraint force mixing factor when joint is at limit */
	public native @ByRef btVector3 m_stopCFM(); public native btTranslationalLimitMotor m_stopCFM(btVector3 setter);
							   /**\} */
	public native @Cast("bool") boolean m_enableMotor(int i); public native btTranslationalLimitMotor m_enableMotor(int i, boolean setter);
	@MemberGetter public native @Cast("bool*") BoolPointer m_enableMotor();
	/** target motor velocity */
	public native @ByRef btVector3 m_targetVelocity(); public native btTranslationalLimitMotor m_targetVelocity(btVector3 setter);
	/** max force on motor */
	public native @ByRef btVector3 m_maxMotorForce(); public native btTranslationalLimitMotor m_maxMotorForce(btVector3 setter);
	public native @ByRef btVector3 m_currentLimitError(); public native btTranslationalLimitMotor m_currentLimitError(btVector3 setter);  /**  How much is violated this limit */
	public native @ByRef btVector3 m_currentLinearDiff(); public native btTranslationalLimitMotor m_currentLinearDiff(btVector3 setter);  /**  Current relative offset of constraint frames */
	/** 0=free, 1=at lower limit, 2=at upper limit */
	public native int m_currentLimit(int i); public native btTranslationalLimitMotor m_currentLimit(int i, int setter);
	@MemberGetter public native IntPointer m_currentLimit();

	public btTranslationalLimitMotor() { super((Pointer)null); allocate(); }
	private native void allocate();

	public btTranslationalLimitMotor(@Const @ByRef btTranslationalLimitMotor other) { super((Pointer)null); allocate(other); }
	private native void allocate(@Const @ByRef btTranslationalLimitMotor other);

	/** Test limit
	/**
    - free means upper < lower,
    - locked means upper == lower
    - limited means upper > lower
    - limitIndex: first 3 are linear, next 3 are angular
    */
	public native @Cast("bool") boolean isLimited(int limitIndex);
	public native @Cast("bool") boolean needApplyForce(int limitIndex);
	public native int testLimitValue(int limitIndex, @Cast("btScalar") float test_value);

	public native @Cast("btScalar") float solveLinearAxis(
			@Cast("btScalar") float timeStep,
			@Cast("btScalar") float jacDiagABInv,
			@ByRef btRigidBody body1, @Const @ByRef btVector3 pointInA,
			@ByRef btRigidBody body2, @Const @ByRef btVector3 pointInB,
			int limit_index,
			@Const @ByRef btVector3 axis_normal_on_a,
			@Const @ByRef btVector3 anchorPos);
}

/** enum bt6DofFlags */
public static final int
	BT_6DOF_FLAGS_CFM_NORM = 1,
	BT_6DOF_FLAGS_CFM_STOP = 2,
	BT_6DOF_FLAGS_ERP_STOP = 4;
public static final int BT_6DOF_FLAGS_AXIS_SHIFT = 3;  // bits per axis

/** btGeneric6DofConstraint between two rigidbodies each with a pivotpoint that descibes the axis location in local space
/**
btGeneric6DofConstraint can leave any of the 6 degree of freedom 'free' or 'locked'.
currently this limit supports rotational motors<br>
<ul>
<li> For Linear limits, use btGeneric6DofConstraint.setLinearUpperLimit, btGeneric6DofConstraint.setLinearLowerLimit. You can set the parameters with the btTranslationalLimitMotor structure accsesible through the btGeneric6DofConstraint.getTranslationalLimitMotor method.
At this moment translational motors are not supported. May be in the future. </li>
<p>
<li> For Angular limits, use the btRotationalLimitMotor structure for configuring the limit.
This is accessible through btGeneric6DofConstraint.getLimitMotor method,
This brings support for limit parameters and motors. </li>
<p>
<li> Angulars limits have these possible ranges:
<table border=1 >
<tr>
	<td><b>AXIS</b></td>
	<td><b>MIN ANGLE</b></td>
	<td><b>MAX ANGLE</b></td>
</tr><tr>
	<td>X</td>
	<td>-PI</td>
	<td>PI</td>
</tr><tr>
	<td>Y</td>
	<td>-PI/2</td>
	<td>PI/2</td>
</tr><tr>
	<td>Z</td>
	<td>-PI</td>
	<td>PI</td>
</tr>
</table>
</li>
</ul>
<p>
*/
@NoOffset public static class btGeneric6DofConstraint extends btTypedConstraint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btGeneric6DofConstraint(Pointer p) { super(p); }


	/**for backwards compatibility during the transition to 'getInfo/getInfo2' */
	public native @Cast("bool") boolean m_useSolveConstraintObsolete(); public native btGeneric6DofConstraint m_useSolveConstraintObsolete(boolean setter);

	public btGeneric6DofConstraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform frameInA, @Const @ByRef btTransform frameInB, @Cast("bool") boolean useLinearReferenceFrameA) { super((Pointer)null); allocate(rbA, rbB, frameInA, frameInB, useLinearReferenceFrameA); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform frameInA, @Const @ByRef btTransform frameInB, @Cast("bool") boolean useLinearReferenceFrameA);
	public btGeneric6DofConstraint(@ByRef btRigidBody rbB, @Const @ByRef btTransform frameInB, @Cast("bool") boolean useLinearReferenceFrameB) { super((Pointer)null); allocate(rbB, frameInB, useLinearReferenceFrameB); }
	private native void allocate(@ByRef btRigidBody rbB, @Const @ByRef btTransform frameInB, @Cast("bool") boolean useLinearReferenceFrameB);

	/** Calcs global transform of the offsets
	/**
	Calcs the global transform for the joint offset for body A an B, and also calcs the agle differences between the bodies.
	@see btGeneric6DofConstraint.getCalculatedTransformA , btGeneric6DofConstraint.getCalculatedTransformB, btGeneric6DofConstraint.calculateAngleInfo
	*/
	public native void calculateTransforms(@Const @ByRef btTransform transA, @Const @ByRef btTransform transB);

	public native void calculateTransforms();

	/** Gets the global transform of the offset for body A
	/**
    @see btGeneric6DofConstraint.getFrameOffsetA, btGeneric6DofConstraint.getFrameOffsetB, btGeneric6DofConstraint.calculateAngleInfo.
    */
	public native @Const @ByRef btTransform getCalculatedTransformA();

	/** Gets the global transform of the offset for body B
	/**
    @see btGeneric6DofConstraint.getFrameOffsetA, btGeneric6DofConstraint.getFrameOffsetB, btGeneric6DofConstraint.calculateAngleInfo.
    */
	public native @Const @ByRef btTransform getCalculatedTransformB();

	public native @ByRef btTransform getFrameOffsetA();

	public native @ByRef btTransform getFrameOffsetB();

	/** performs Jacobian calculation, and also calculates angle differences and axis */
	public native void buildJacobian();

	public native void updateRHS(@Cast("btScalar") float timeStep);

	/** Get the rotation axis in global coordinates
	/**
	\pre btGeneric6DofConstraint.buildJacobian must be called previously.
	*/
	public native @ByVal btVector3 getAxis(int axis_index);

	/** Get the relative Euler angle
	/**
	\pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
	*/
	public native @Cast("btScalar") float getAngle(int axis_index);

	/** Get the relative position of the constraint pivot
	/**
	\pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
	*/
	public native @Cast("btScalar") float getRelativePivotPosition(int axis_index);

	public native void setFrames(@Const @ByRef btTransform frameA, @Const @ByRef btTransform frameB);

	/** Test angular limit.
	/**
	Calculates angular correction and returns true if limit needs to be corrected.
	\pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
	*/
	public native @Cast("bool") boolean testAngularLimitMotor(int axis_index);

	public native void setLinearLowerLimit(@Const @ByRef btVector3 linearLower);

	public native void getLinearLowerLimit(@ByRef btVector3 linearLower);

	public native void setLinearUpperLimit(@Const @ByRef btVector3 linearUpper);

	public native void getLinearUpperLimit(@ByRef btVector3 linearUpper);

	public native void setAngularLowerLimit(@Const @ByRef btVector3 angularLower);

	public native void getAngularLowerLimit(@ByRef btVector3 angularLower);

	public native void setAngularUpperLimit(@Const @ByRef btVector3 angularUpper);

	public native void getAngularUpperLimit(@ByRef btVector3 angularUpper);

	/** Retrieves the angular limit informacion */
	public native btRotationalLimitMotor getRotationalLimitMotor(int index);

	/** Retrieves the  limit informacion */
	public native btTranslationalLimitMotor getTranslationalLimitMotor();

	//first 3 are linear, next 3 are angular
	public native void setLimit(int axis, @Cast("btScalar") float lo, @Cast("btScalar") float hi);

	/** Test limit
	/**
    - free means upper < lower,
    - locked means upper == lower
    - limited means upper > lower
    - limitIndex: first 3 are linear, next 3 are angular
    */
	public native @Cast("bool") boolean isLimited(int limitIndex);

	public native void calcAnchorPos();  // overridable

	// access for UseFrameOffset
	public native @Cast("bool") boolean getUseFrameOffset();
	public native void setUseFrameOffset(@Cast("bool") boolean frameOffsetOnOff);

	public native @Cast("bool") boolean getUseLinearReferenceFrameA();
	public native void setUseLinearReferenceFrameA(@Cast("bool") boolean linearReferenceFrameA);

	/**override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
	 * If no axis is provided, it uses the default axis for this constraint. */
	public native void setParam(int num, @Cast("btScalar") float value, int axis/*=-1*/);
	public native void setParam(int num, @Cast("btScalar") float value);
	/**return the local value of parameter */
	public native @Cast("btScalar") float getParam(int num, int axis/*=-1*/);
	public native @Cast("btScalar") float getParam(int num);

	public native void setAxis(@Const @ByRef btVector3 axis1, @Const @ByRef btVector3 axis2);

	public native int getFlags();

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);
}

public static class btGeneric6DofConstraintData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btGeneric6DofConstraintData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btGeneric6DofConstraintData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btGeneric6DofConstraintData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btGeneric6DofConstraintData position(long position) {
        return (btGeneric6DofConstraintData)super.position(position);
    }
    @Override public btGeneric6DofConstraintData getPointer(long i) {
        return new btGeneric6DofConstraintData((Pointer)this).offsetAddress(i);
    }

	
	public native @ByRef btTransformFloatData m_rbAFrame(); public native btGeneric6DofConstraintData m_rbAFrame(btTransformFloatData setter);  // constraint axii. Assumes z is hinge axis.
	public native @ByRef btTransformFloatData m_rbBFrame(); public native btGeneric6DofConstraintData m_rbBFrame(btTransformFloatData setter);

	public native @ByRef btVector3FloatData m_linearUpperLimit(); public native btGeneric6DofConstraintData m_linearUpperLimit(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_linearLowerLimit(); public native btGeneric6DofConstraintData m_linearLowerLimit(btVector3FloatData setter);

	public native @ByRef btVector3FloatData m_angularUpperLimit(); public native btGeneric6DofConstraintData m_angularUpperLimit(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_angularLowerLimit(); public native btGeneric6DofConstraintData m_angularLowerLimit(btVector3FloatData setter);

	public native int m_useLinearReferenceFrameA(); public native btGeneric6DofConstraintData m_useLinearReferenceFrameA(int setter);
	public native int m_useOffsetForConstraintFrame(); public native btGeneric6DofConstraintData m_useOffsetForConstraintFrame(int setter);
}

public static class btGeneric6DofConstraintDoubleData2 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btGeneric6DofConstraintDoubleData2() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btGeneric6DofConstraintDoubleData2(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btGeneric6DofConstraintDoubleData2(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btGeneric6DofConstraintDoubleData2 position(long position) {
        return (btGeneric6DofConstraintDoubleData2)super.position(position);
    }
    @Override public btGeneric6DofConstraintDoubleData2 getPointer(long i) {
        return new btGeneric6DofConstraintDoubleData2((Pointer)this).offsetAddress(i);
    }

	
	public native @ByRef btTransformDoubleData m_rbAFrame(); public native btGeneric6DofConstraintDoubleData2 m_rbAFrame(btTransformDoubleData setter);  // constraint axii. Assumes z is hinge axis.
	public native @ByRef btTransformDoubleData m_rbBFrame(); public native btGeneric6DofConstraintDoubleData2 m_rbBFrame(btTransformDoubleData setter);

	public native @ByRef btVector3DoubleData m_linearUpperLimit(); public native btGeneric6DofConstraintDoubleData2 m_linearUpperLimit(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_linearLowerLimit(); public native btGeneric6DofConstraintDoubleData2 m_linearLowerLimit(btVector3DoubleData setter);

	public native @ByRef btVector3DoubleData m_angularUpperLimit(); public native btGeneric6DofConstraintDoubleData2 m_angularUpperLimit(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_angularLowerLimit(); public native btGeneric6DofConstraintDoubleData2 m_angularLowerLimit(btVector3DoubleData setter);

	public native int m_useLinearReferenceFrameA(); public native btGeneric6DofConstraintDoubleData2 m_useLinearReferenceFrameA(int setter);
	public native int m_useOffsetForConstraintFrame(); public native btGeneric6DofConstraintDoubleData2 m_useOffsetForConstraintFrame(int setter);
}



/**fills the dataBuffer and returns the struct name (and 0 on failure) */


// #endif  //BT_GENERIC_6DOF_CONSTRAINT_H


// Parsed from BulletDynamics/ConstraintSolver/btSliderConstraint.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/*
Added by Roman Ponomarev (rponom@gmail.com)
April 04, 2008

TODO:
 - add clamping od accumulated impulse to improve stability
 - add conversion for ODE constraint solver
*/

// #ifndef BT_SLIDER_CONSTRAINT_H
// #define BT_SLIDER_CONSTRAINT_H

// #include "LinearMath/btScalar.h"  //for BT_USE_DOUBLE_PRECISION

// #ifdef BT_USE_DOUBLE_PRECISION
// #else
// #define btSliderConstraintData2 btSliderConstraintData
public static final String btSliderConstraintDataName = "btSliderConstraintData";
// #endif  //BT_USE_DOUBLE_PRECISION

// #include "LinearMath/btVector3.h"
// #include "btJacobianEntry.h"
// #include "btTypedConstraint.h"

public static native @MemberGetter double SLIDER_CONSTRAINT_DEF_SOFTNESS();
public static final double SLIDER_CONSTRAINT_DEF_SOFTNESS = SLIDER_CONSTRAINT_DEF_SOFTNESS();
public static native @MemberGetter double SLIDER_CONSTRAINT_DEF_DAMPING();
public static final double SLIDER_CONSTRAINT_DEF_DAMPING = SLIDER_CONSTRAINT_DEF_DAMPING();
public static native @MemberGetter double SLIDER_CONSTRAINT_DEF_RESTITUTION();
public static final double SLIDER_CONSTRAINT_DEF_RESTITUTION = SLIDER_CONSTRAINT_DEF_RESTITUTION();
public static native @MemberGetter double SLIDER_CONSTRAINT_DEF_CFM();
public static final double SLIDER_CONSTRAINT_DEF_CFM = SLIDER_CONSTRAINT_DEF_CFM();

/** enum btSliderFlags */
public static final int
	BT_SLIDER_FLAGS_CFM_DIRLIN = (1 << 0),
	BT_SLIDER_FLAGS_ERP_DIRLIN = (1 << 1),
	BT_SLIDER_FLAGS_CFM_DIRANG = (1 << 2),
	BT_SLIDER_FLAGS_ERP_DIRANG = (1 << 3),
	BT_SLIDER_FLAGS_CFM_ORTLIN = (1 << 4),
	BT_SLIDER_FLAGS_ERP_ORTLIN = (1 << 5),
	BT_SLIDER_FLAGS_CFM_ORTANG = (1 << 6),
	BT_SLIDER_FLAGS_ERP_ORTANG = (1 << 7),
	BT_SLIDER_FLAGS_CFM_LIMLIN = (1 << 8),
	BT_SLIDER_FLAGS_ERP_LIMLIN = (1 << 9),
	BT_SLIDER_FLAGS_CFM_LIMANG = (1 << 10),
	BT_SLIDER_FLAGS_ERP_LIMANG = (1 << 11);

@NoOffset public static class btSliderConstraint extends btTypedConstraint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btSliderConstraint(Pointer p) { super(p); }


	// constructors
	public btSliderConstraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform frameInA, @Const @ByRef btTransform frameInB, @Cast("bool") boolean useLinearReferenceFrameA) { super((Pointer)null); allocate(rbA, rbB, frameInA, frameInB, useLinearReferenceFrameA); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform frameInA, @Const @ByRef btTransform frameInB, @Cast("bool") boolean useLinearReferenceFrameA);
	public btSliderConstraint(@ByRef btRigidBody rbB, @Const @ByRef btTransform frameInB, @Cast("bool") boolean useLinearReferenceFrameA) { super((Pointer)null); allocate(rbB, frameInB, useLinearReferenceFrameA); }
	private native void allocate(@ByRef btRigidBody rbB, @Const @ByRef btTransform frameInB, @Cast("bool") boolean useLinearReferenceFrameA);

	// overrides

	// access
	public native @Const @ByRef btRigidBody getRigidBodyA();
	public native @Const @ByRef btRigidBody getRigidBodyB();
	public native @Const @ByRef btTransform getCalculatedTransformA();
	public native @Const @ByRef btTransform getCalculatedTransformB();
	public native @ByRef btTransform getFrameOffsetA();
	public native @ByRef btTransform getFrameOffsetB();
	public native @Cast("btScalar") float getLowerLinLimit();
	public native void setLowerLinLimit(@Cast("btScalar") float lowerLimit);
	public native @Cast("btScalar") float getUpperLinLimit();
	public native void setUpperLinLimit(@Cast("btScalar") float upperLimit);
	public native @Cast("btScalar") float getLowerAngLimit();
	public native void setLowerAngLimit(@Cast("btScalar") float lowerLimit);
	public native @Cast("btScalar") float getUpperAngLimit();
	public native void setUpperAngLimit(@Cast("btScalar") float upperLimit);
	public native @Cast("bool") boolean getUseLinearReferenceFrameA();
	public native @Cast("btScalar") float getSoftnessDirLin();
	public native @Cast("btScalar") float getRestitutionDirLin();
	public native @Cast("btScalar") float getDampingDirLin();
	public native @Cast("btScalar") float getSoftnessDirAng();
	public native @Cast("btScalar") float getRestitutionDirAng();
	public native @Cast("btScalar") float getDampingDirAng();
	public native @Cast("btScalar") float getSoftnessLimLin();
	public native @Cast("btScalar") float getRestitutionLimLin();
	public native @Cast("btScalar") float getDampingLimLin();
	public native @Cast("btScalar") float getSoftnessLimAng();
	public native @Cast("btScalar") float getRestitutionLimAng();
	public native @Cast("btScalar") float getDampingLimAng();
	public native @Cast("btScalar") float getSoftnessOrthoLin();
	public native @Cast("btScalar") float getRestitutionOrthoLin();
	public native @Cast("btScalar") float getDampingOrthoLin();
	public native @Cast("btScalar") float getSoftnessOrthoAng();
	public native @Cast("btScalar") float getRestitutionOrthoAng();
	public native @Cast("btScalar") float getDampingOrthoAng();
	public native void setSoftnessDirLin(@Cast("btScalar") float softnessDirLin);
	public native void setRestitutionDirLin(@Cast("btScalar") float restitutionDirLin);
	public native void setDampingDirLin(@Cast("btScalar") float dampingDirLin);
	public native void setSoftnessDirAng(@Cast("btScalar") float softnessDirAng);
	public native void setRestitutionDirAng(@Cast("btScalar") float restitutionDirAng);
	public native void setDampingDirAng(@Cast("btScalar") float dampingDirAng);
	public native void setSoftnessLimLin(@Cast("btScalar") float softnessLimLin);
	public native void setRestitutionLimLin(@Cast("btScalar") float restitutionLimLin);
	public native void setDampingLimLin(@Cast("btScalar") float dampingLimLin);
	public native void setSoftnessLimAng(@Cast("btScalar") float softnessLimAng);
	public native void setRestitutionLimAng(@Cast("btScalar") float restitutionLimAng);
	public native void setDampingLimAng(@Cast("btScalar") float dampingLimAng);
	public native void setSoftnessOrthoLin(@Cast("btScalar") float softnessOrthoLin);
	public native void setRestitutionOrthoLin(@Cast("btScalar") float restitutionOrthoLin);
	public native void setDampingOrthoLin(@Cast("btScalar") float dampingOrthoLin);
	public native void setSoftnessOrthoAng(@Cast("btScalar") float softnessOrthoAng);
	public native void setRestitutionOrthoAng(@Cast("btScalar") float restitutionOrthoAng);
	public native void setDampingOrthoAng(@Cast("btScalar") float dampingOrthoAng);
	public native void setPoweredLinMotor(@Cast("bool") boolean onOff);
	public native @Cast("bool") boolean getPoweredLinMotor();
	public native void setTargetLinMotorVelocity(@Cast("btScalar") float targetLinMotorVelocity);
	public native @Cast("btScalar") float getTargetLinMotorVelocity();
	public native void setMaxLinMotorForce(@Cast("btScalar") float maxLinMotorForce);
	public native @Cast("btScalar") float getMaxLinMotorForce();
	public native void setPoweredAngMotor(@Cast("bool") boolean onOff);
	public native @Cast("bool") boolean getPoweredAngMotor();
	public native void setTargetAngMotorVelocity(@Cast("btScalar") float targetAngMotorVelocity);
	public native @Cast("btScalar") float getTargetAngMotorVelocity();
	public native void setMaxAngMotorForce(@Cast("btScalar") float maxAngMotorForce);
	public native @Cast("btScalar") float getMaxAngMotorForce();

	public native @Cast("btScalar") float getLinearPos();
	public native @Cast("btScalar") float getAngularPos();

	// access for ODE solver
	public native @Cast("bool") boolean getSolveLinLimit();
	public native @Cast("btScalar") float getLinDepth();
	public native @Cast("bool") boolean getSolveAngLimit();
	public native @Cast("btScalar") float getAngDepth();
	// shared code used by ODE solver
	public native void calculateTransforms(@Const @ByRef btTransform transA, @Const @ByRef btTransform transB);
	public native void testLinLimits();
	public native void testAngLimits();
	// access for PE Solver
	public native @ByVal btVector3 getAncorInA();
	public native @ByVal btVector3 getAncorInB();
	// access for UseFrameOffset
	public native @Cast("bool") boolean getUseFrameOffset();
	public native void setUseFrameOffset(@Cast("bool") boolean frameOffsetOnOff);

	public native void setFrames(@Const @ByRef btTransform frameA, @Const @ByRef btTransform frameB);

	/**override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
	 * If no axis is provided, it uses the default axis for this constraint. */
	public native void setParam(int num, @Cast("btScalar") float value, int axis/*=-1*/);
	public native void setParam(int num, @Cast("btScalar") float value);
	/**return the local value of parameter */
	public native @Cast("btScalar") float getParam(int num, int axis/*=-1*/);
	public native @Cast("btScalar") float getParam(int num);

	public native int getFlags();

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);
}

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */

public static class btSliderConstraintData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btSliderConstraintData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btSliderConstraintData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btSliderConstraintData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btSliderConstraintData position(long position) {
        return (btSliderConstraintData)super.position(position);
    }
    @Override public btSliderConstraintData getPointer(long i) {
        return new btSliderConstraintData((Pointer)this).offsetAddress(i);
    }

	
	public native @ByRef btTransformFloatData m_rbAFrame(); public native btSliderConstraintData m_rbAFrame(btTransformFloatData setter);  // constraint axii. Assumes z is hinge axis.
	public native @ByRef btTransformFloatData m_rbBFrame(); public native btSliderConstraintData m_rbBFrame(btTransformFloatData setter);

	public native float m_linearUpperLimit(); public native btSliderConstraintData m_linearUpperLimit(float setter);
	public native float m_linearLowerLimit(); public native btSliderConstraintData m_linearLowerLimit(float setter);

	public native float m_angularUpperLimit(); public native btSliderConstraintData m_angularUpperLimit(float setter);
	public native float m_angularLowerLimit(); public native btSliderConstraintData m_angularLowerLimit(float setter);

	public native int m_useLinearReferenceFrameA(); public native btSliderConstraintData m_useLinearReferenceFrameA(int setter);
	public native int m_useOffsetForConstraintFrame(); public native btSliderConstraintData m_useOffsetForConstraintFrame(int setter);
}

public static class btSliderConstraintDoubleData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btSliderConstraintDoubleData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btSliderConstraintDoubleData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btSliderConstraintDoubleData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btSliderConstraintDoubleData position(long position) {
        return (btSliderConstraintDoubleData)super.position(position);
    }
    @Override public btSliderConstraintDoubleData getPointer(long i) {
        return new btSliderConstraintDoubleData((Pointer)this).offsetAddress(i);
    }

	
	public native @ByRef btTransformDoubleData m_rbAFrame(); public native btSliderConstraintDoubleData m_rbAFrame(btTransformDoubleData setter);  // constraint axii. Assumes z is hinge axis.
	public native @ByRef btTransformDoubleData m_rbBFrame(); public native btSliderConstraintDoubleData m_rbBFrame(btTransformDoubleData setter);

	public native double m_linearUpperLimit(); public native btSliderConstraintDoubleData m_linearUpperLimit(double setter);
	public native double m_linearLowerLimit(); public native btSliderConstraintDoubleData m_linearLowerLimit(double setter);

	public native double m_angularUpperLimit(); public native btSliderConstraintDoubleData m_angularUpperLimit(double setter);
	public native double m_angularLowerLimit(); public native btSliderConstraintDoubleData m_angularLowerLimit(double setter);

	public native int m_useLinearReferenceFrameA(); public native btSliderConstraintDoubleData m_useLinearReferenceFrameA(int setter);
	public native int m_useOffsetForConstraintFrame(); public native btSliderConstraintDoubleData m_useOffsetForConstraintFrame(int setter);
}



/**fills the dataBuffer and returns the struct name (and 0 on failure) */


// #endif  //BT_SLIDER_CONSTRAINT_H


// Parsed from BulletDynamics/ConstraintSolver/btGeneric6DofSpringConstraint.h

/*
Bullet Continuous Collision Detection and Physics Library, http://bulletphysics.org
Copyright (C) 2006, 2007 Sony Computer Entertainment Inc. 

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_GENERIC_6DOF_SPRING_CONSTRAINT_H
// #define BT_GENERIC_6DOF_SPRING_CONSTRAINT_H

// #include "LinearMath/btVector3.h"
// #include "btTypedConstraint.h"
// #include "btGeneric6DofConstraint.h"

// #ifdef BT_USE_DOUBLE_PRECISION
// #else
// #define btGeneric6DofSpringConstraintData2 btGeneric6DofSpringConstraintData
public static final String btGeneric6DofSpringConstraintDataName = "btGeneric6DofSpringConstraintData";
// #endif  //BT_USE_DOUBLE_PRECISION

/** Generic 6 DOF constraint that allows to set spring motors to any translational and rotational DOF
 <p>
 *  DOF index used in enableSpring() and setStiffness() means:
 *  0 : translation X
 *  1 : translation Y
 *  2 : translation Z
 *  3 : rotation X (3rd Euler rotational around new position of X axis, range [-PI+epsilon, PI-epsilon] )
 *  4 : rotation Y (2nd Euler rotational around new position of Y axis, range [-PI/2+epsilon, PI/2-epsilon] )
 *  5 : rotation Z (1st Euler rotational around Z axis, range [-PI+epsilon, PI-epsilon] ) */

@NoOffset public static class btGeneric6DofSpringConstraint extends btGeneric6DofConstraint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btGeneric6DofSpringConstraint(Pointer p) { super(p); }


	public btGeneric6DofSpringConstraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform frameInA, @Const @ByRef btTransform frameInB, @Cast("bool") boolean useLinearReferenceFrameA) { super((Pointer)null); allocate(rbA, rbB, frameInA, frameInB, useLinearReferenceFrameA); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform frameInA, @Const @ByRef btTransform frameInB, @Cast("bool") boolean useLinearReferenceFrameA);
	public btGeneric6DofSpringConstraint(@ByRef btRigidBody rbB, @Const @ByRef btTransform frameInB, @Cast("bool") boolean useLinearReferenceFrameB) { super((Pointer)null); allocate(rbB, frameInB, useLinearReferenceFrameB); }
	private native void allocate(@ByRef btRigidBody rbB, @Const @ByRef btTransform frameInB, @Cast("bool") boolean useLinearReferenceFrameB);
	public native void enableSpring(int index, @Cast("bool") boolean onOff);
	public native void setStiffness(int index, @Cast("btScalar") float stiffness);
	public native void setDamping(int index, @Cast("btScalar") float damping);
	public native void setEquilibriumPoint();           // set the current constraint position/orientation as an equilibrium point for all DOF
	public native void setEquilibriumPoint(int index);  // set the current constraint position/orientation as an equilibrium point for given DOF
	public native void setEquilibriumPoint(int index, @Cast("btScalar") float val);

	public native @Cast("bool") boolean isSpringEnabled(int index);

	public native @Cast("btScalar") float getStiffness(int index);

	public native @Cast("btScalar") float getDamping(int index);

	public native @Cast("btScalar") float getEquilibriumPoint(int index);

	public native void setAxis(@Const @ByRef btVector3 axis1, @Const @ByRef btVector3 axis2);

	public native int calculateSerializeBufferSize();
	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);
}

public static class btGeneric6DofSpringConstraintData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btGeneric6DofSpringConstraintData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btGeneric6DofSpringConstraintData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btGeneric6DofSpringConstraintData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btGeneric6DofSpringConstraintData position(long position) {
        return (btGeneric6DofSpringConstraintData)super.position(position);
    }
    @Override public btGeneric6DofSpringConstraintData getPointer(long i) {
        return new btGeneric6DofSpringConstraintData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btGeneric6DofConstraintData m_6dofData(); public native btGeneric6DofSpringConstraintData m_6dofData(btGeneric6DofConstraintData setter);

	public native int m_springEnabled(int i); public native btGeneric6DofSpringConstraintData m_springEnabled(int i, int setter);
	@MemberGetter public native IntPointer m_springEnabled();
	public native float m_equilibriumPoint(int i); public native btGeneric6DofSpringConstraintData m_equilibriumPoint(int i, float setter);
	@MemberGetter public native FloatPointer m_equilibriumPoint();
	public native float m_springStiffness(int i); public native btGeneric6DofSpringConstraintData m_springStiffness(int i, float setter);
	@MemberGetter public native FloatPointer m_springStiffness();
	public native float m_springDamping(int i); public native btGeneric6DofSpringConstraintData m_springDamping(int i, float setter);
	@MemberGetter public native FloatPointer m_springDamping();
}

public static class btGeneric6DofSpringConstraintDoubleData2 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btGeneric6DofSpringConstraintDoubleData2() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btGeneric6DofSpringConstraintDoubleData2(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btGeneric6DofSpringConstraintDoubleData2(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btGeneric6DofSpringConstraintDoubleData2 position(long position) {
        return (btGeneric6DofSpringConstraintDoubleData2)super.position(position);
    }
    @Override public btGeneric6DofSpringConstraintDoubleData2 getPointer(long i) {
        return new btGeneric6DofSpringConstraintDoubleData2((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btGeneric6DofConstraintDoubleData2 m_6dofData(); public native btGeneric6DofSpringConstraintDoubleData2 m_6dofData(btGeneric6DofConstraintDoubleData2 setter);

	public native int m_springEnabled(int i); public native btGeneric6DofSpringConstraintDoubleData2 m_springEnabled(int i, int setter);
	@MemberGetter public native IntPointer m_springEnabled();
	public native double m_equilibriumPoint(int i); public native btGeneric6DofSpringConstraintDoubleData2 m_equilibriumPoint(int i, double setter);
	@MemberGetter public native DoublePointer m_equilibriumPoint();
	public native double m_springStiffness(int i); public native btGeneric6DofSpringConstraintDoubleData2 m_springStiffness(int i, double setter);
	@MemberGetter public native DoublePointer m_springStiffness();
	public native double m_springDamping(int i); public native btGeneric6DofSpringConstraintDoubleData2 m_springDamping(int i, double setter);
	@MemberGetter public native DoublePointer m_springDamping();
}



/**fills the dataBuffer and returns the struct name (and 0 on failure) */


// #endif  // BT_GENERIC_6DOF_SPRING_CONSTRAINT_H


// Parsed from BulletDynamics/ConstraintSolver/btGeneric6DofSpring2Constraint.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/*
2014 May: btGeneric6DofSpring2Constraint is created from the original (2.82.2712) btGeneric6DofConstraint by Gabor Puhr and Tamas Umenhoffer
Pros:
- Much more accurate and stable in a lot of situation. (Especially when a sleeping chain of RBs connected with 6dof2 is pulled)
- Stable and accurate spring with minimal energy loss that works with all of the solvers. (latter is not true for the original 6dof spring)
- Servo motor functionality
- Much more accurate bouncing. 0 really means zero bouncing (not true for the original 6odf) and there is only a minimal energy loss when the value is 1 (because of the solvers' precision)
- Rotation order for the Euler system can be set. (One axis' freedom is still limited to pi/2)

Cons:
- It is slower than the original 6dof. There is no exact ratio, but half speed is a good estimation.
- At bouncing the correct velocity is calculated, but not the correct position. (it is because of the solver can correct position or velocity, but not both.)
*/

/** 2009 March: btGeneric6DofConstraint refactored by Roman Ponomarev
/** Added support for generic constraint solver through getInfo1/getInfo2 methods */

/*
2007-09-09
btGeneric6DofConstraint Refactored by Francisco Le?n
email: projectileman@yahoo.com
http://gimpact.sf.net
*/

// #ifndef BT_GENERIC_6DOF_CONSTRAINT2_H
// #define BT_GENERIC_6DOF_CONSTRAINT2_H

// #include "LinearMath/btVector3.h"
// #include "btJacobianEntry.h"
// #include "btTypedConstraint.h"

// #ifdef BT_USE_DOUBLE_PRECISION
// #else
// #define btGeneric6DofSpring2ConstraintData2 btGeneric6DofSpring2ConstraintData
public static final String btGeneric6DofSpring2ConstraintDataName = "btGeneric6DofSpring2ConstraintData";
// #endif  //BT_USE_DOUBLE_PRECISION

/** enum RotateOrder */
public static final int
	RO_XYZ = 0,
	RO_XZY = 1,
	RO_YXZ = 2,
	RO_YZX = 3,
	RO_ZXY = 4,
	RO_ZYX = 5;

@NoOffset public static class btRotationalLimitMotor2 extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btRotationalLimitMotor2(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btRotationalLimitMotor2(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btRotationalLimitMotor2 position(long position) {
        return (btRotationalLimitMotor2)super.position(position);
    }
    @Override public btRotationalLimitMotor2 getPointer(long i) {
        return new btRotationalLimitMotor2((Pointer)this).offsetAddress(i);
    }

	// upper < lower means free
	// upper == lower means locked
	// upper > lower means limited
	public native @Cast("btScalar") float m_loLimit(); public native btRotationalLimitMotor2 m_loLimit(float setter);
	public native @Cast("btScalar") float m_hiLimit(); public native btRotationalLimitMotor2 m_hiLimit(float setter);
	public native @Cast("btScalar") float m_bounce(); public native btRotationalLimitMotor2 m_bounce(float setter);
	public native @Cast("btScalar") float m_stopERP(); public native btRotationalLimitMotor2 m_stopERP(float setter);
	public native @Cast("btScalar") float m_stopCFM(); public native btRotationalLimitMotor2 m_stopCFM(float setter);
	public native @Cast("btScalar") float m_motorERP(); public native btRotationalLimitMotor2 m_motorERP(float setter);
	public native @Cast("btScalar") float m_motorCFM(); public native btRotationalLimitMotor2 m_motorCFM(float setter);
	public native @Cast("bool") boolean m_enableMotor(); public native btRotationalLimitMotor2 m_enableMotor(boolean setter);
	public native @Cast("btScalar") float m_targetVelocity(); public native btRotationalLimitMotor2 m_targetVelocity(float setter);
	public native @Cast("btScalar") float m_maxMotorForce(); public native btRotationalLimitMotor2 m_maxMotorForce(float setter);
	public native @Cast("bool") boolean m_servoMotor(); public native btRotationalLimitMotor2 m_servoMotor(boolean setter);
	public native @Cast("btScalar") float m_servoTarget(); public native btRotationalLimitMotor2 m_servoTarget(float setter);
	public native @Cast("bool") boolean m_enableSpring(); public native btRotationalLimitMotor2 m_enableSpring(boolean setter);
	public native @Cast("btScalar") float m_springStiffness(); public native btRotationalLimitMotor2 m_springStiffness(float setter);
	public native @Cast("bool") boolean m_springStiffnessLimited(); public native btRotationalLimitMotor2 m_springStiffnessLimited(boolean setter);
	public native @Cast("btScalar") float m_springDamping(); public native btRotationalLimitMotor2 m_springDamping(float setter);
	public native @Cast("bool") boolean m_springDampingLimited(); public native btRotationalLimitMotor2 m_springDampingLimited(boolean setter);
	public native @Cast("btScalar") float m_equilibriumPoint(); public native btRotationalLimitMotor2 m_equilibriumPoint(float setter);

	public native @Cast("btScalar") float m_currentLimitError(); public native btRotationalLimitMotor2 m_currentLimitError(float setter);
	public native @Cast("btScalar") float m_currentLimitErrorHi(); public native btRotationalLimitMotor2 m_currentLimitErrorHi(float setter);
	public native @Cast("btScalar") float m_currentPosition(); public native btRotationalLimitMotor2 m_currentPosition(float setter);
	public native int m_currentLimit(); public native btRotationalLimitMotor2 m_currentLimit(int setter);

	public btRotationalLimitMotor2() { super((Pointer)null); allocate(); }
	private native void allocate();

	public btRotationalLimitMotor2(@Const @ByRef btRotationalLimitMotor2 limot) { super((Pointer)null); allocate(limot); }
	private native void allocate(@Const @ByRef btRotationalLimitMotor2 limot);

	public native @Cast("bool") boolean isLimited();

	public native void testLimitValue(@Cast("btScalar") float test_value);
}

@NoOffset public static class btTranslationalLimitMotor2 extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btTranslationalLimitMotor2(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btTranslationalLimitMotor2(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btTranslationalLimitMotor2 position(long position) {
        return (btTranslationalLimitMotor2)super.position(position);
    }
    @Override public btTranslationalLimitMotor2 getPointer(long i) {
        return new btTranslationalLimitMotor2((Pointer)this).offsetAddress(i);
    }

	// upper < lower means free
	// upper == lower means locked
	// upper > lower means limited
	public native @ByRef btVector3 m_lowerLimit(); public native btTranslationalLimitMotor2 m_lowerLimit(btVector3 setter);
	public native @ByRef btVector3 m_upperLimit(); public native btTranslationalLimitMotor2 m_upperLimit(btVector3 setter);
	public native @ByRef btVector3 m_bounce(); public native btTranslationalLimitMotor2 m_bounce(btVector3 setter);
	public native @ByRef btVector3 m_stopERP(); public native btTranslationalLimitMotor2 m_stopERP(btVector3 setter);
	public native @ByRef btVector3 m_stopCFM(); public native btTranslationalLimitMotor2 m_stopCFM(btVector3 setter);
	public native @ByRef btVector3 m_motorERP(); public native btTranslationalLimitMotor2 m_motorERP(btVector3 setter);
	public native @ByRef btVector3 m_motorCFM(); public native btTranslationalLimitMotor2 m_motorCFM(btVector3 setter);
	public native @Cast("bool") boolean m_enableMotor(int i); public native btTranslationalLimitMotor2 m_enableMotor(int i, boolean setter);
	@MemberGetter public native @Cast("bool*") BoolPointer m_enableMotor();
	public native @Cast("bool") boolean m_servoMotor(int i); public native btTranslationalLimitMotor2 m_servoMotor(int i, boolean setter);
	@MemberGetter public native @Cast("bool*") BoolPointer m_servoMotor();
	public native @Cast("bool") boolean m_enableSpring(int i); public native btTranslationalLimitMotor2 m_enableSpring(int i, boolean setter);
	@MemberGetter public native @Cast("bool*") BoolPointer m_enableSpring();
	public native @ByRef btVector3 m_servoTarget(); public native btTranslationalLimitMotor2 m_servoTarget(btVector3 setter);
	public native @ByRef btVector3 m_springStiffness(); public native btTranslationalLimitMotor2 m_springStiffness(btVector3 setter);
	public native @Cast("bool") boolean m_springStiffnessLimited(int i); public native btTranslationalLimitMotor2 m_springStiffnessLimited(int i, boolean setter);
	@MemberGetter public native @Cast("bool*") BoolPointer m_springStiffnessLimited();
	public native @ByRef btVector3 m_springDamping(); public native btTranslationalLimitMotor2 m_springDamping(btVector3 setter);
	public native @Cast("bool") boolean m_springDampingLimited(int i); public native btTranslationalLimitMotor2 m_springDampingLimited(int i, boolean setter);
	@MemberGetter public native @Cast("bool*") BoolPointer m_springDampingLimited();
	public native @ByRef btVector3 m_equilibriumPoint(); public native btTranslationalLimitMotor2 m_equilibriumPoint(btVector3 setter);
	public native @ByRef btVector3 m_targetVelocity(); public native btTranslationalLimitMotor2 m_targetVelocity(btVector3 setter);
	public native @ByRef btVector3 m_maxMotorForce(); public native btTranslationalLimitMotor2 m_maxMotorForce(btVector3 setter);

	public native @ByRef btVector3 m_currentLimitError(); public native btTranslationalLimitMotor2 m_currentLimitError(btVector3 setter);
	public native @ByRef btVector3 m_currentLimitErrorHi(); public native btTranslationalLimitMotor2 m_currentLimitErrorHi(btVector3 setter);
	public native @ByRef btVector3 m_currentLinearDiff(); public native btTranslationalLimitMotor2 m_currentLinearDiff(btVector3 setter);
	public native int m_currentLimit(int i); public native btTranslationalLimitMotor2 m_currentLimit(int i, int setter);
	@MemberGetter public native IntPointer m_currentLimit();

	public btTranslationalLimitMotor2() { super((Pointer)null); allocate(); }
	private native void allocate();

	public btTranslationalLimitMotor2(@Const @ByRef btTranslationalLimitMotor2 other) { super((Pointer)null); allocate(other); }
	private native void allocate(@Const @ByRef btTranslationalLimitMotor2 other);

	public native @Cast("bool") boolean isLimited(int limitIndex);

	public native void testLimitValue(int limitIndex, @Cast("btScalar") float test_value);
}

/** enum bt6DofFlags2 */
public static final int
	BT_6DOF_FLAGS_CFM_STOP2 = 1,
	BT_6DOF_FLAGS_ERP_STOP2 = 2,
	BT_6DOF_FLAGS_CFM_MOTO2 = 4,
	BT_6DOF_FLAGS_ERP_MOTO2 = 8,
	BT_6DOF_FLAGS_USE_INFINITE_ERROR = (1<<16);
public static final int BT_6DOF_FLAGS_AXIS_SHIFT2 = 4;  // bits per axis

@NoOffset public static class btGeneric6DofSpring2Constraint extends btTypedConstraint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btGeneric6DofSpring2Constraint(Pointer p) { super(p); }


	public btGeneric6DofSpring2Constraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform frameInA, @Const @ByRef btTransform frameInB, @Cast("RotateOrder") int rotOrder/*=RO_XYZ*/) { super((Pointer)null); allocate(rbA, rbB, frameInA, frameInB, rotOrder); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform frameInA, @Const @ByRef btTransform frameInB, @Cast("RotateOrder") int rotOrder/*=RO_XYZ*/);
	public btGeneric6DofSpring2Constraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform frameInA, @Const @ByRef btTransform frameInB) { super((Pointer)null); allocate(rbA, rbB, frameInA, frameInB); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform frameInA, @Const @ByRef btTransform frameInB);
	public btGeneric6DofSpring2Constraint(@ByRef btRigidBody rbB, @Const @ByRef btTransform frameInB, @Cast("RotateOrder") int rotOrder/*=RO_XYZ*/) { super((Pointer)null); allocate(rbB, frameInB, rotOrder); }
	private native void allocate(@ByRef btRigidBody rbB, @Const @ByRef btTransform frameInB, @Cast("RotateOrder") int rotOrder/*=RO_XYZ*/);
	public btGeneric6DofSpring2Constraint(@ByRef btRigidBody rbB, @Const @ByRef btTransform frameInB) { super((Pointer)null); allocate(rbB, frameInB); }
	private native void allocate(@ByRef btRigidBody rbB, @Const @ByRef btTransform frameInB);

	public native void buildJacobian();
	public native int calculateSerializeBufferSize();
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);

	public native btRotationalLimitMotor2 getRotationalLimitMotor(int index);
	public native btTranslationalLimitMotor2 getTranslationalLimitMotor();

	// Calculates the global transform for the joint offset for body A an B, and also calculates the angle differences between the bodies.
	public native void calculateTransforms(@Const @ByRef btTransform transA, @Const @ByRef btTransform transB);
	public native void calculateTransforms();

	// Gets the global transform of the offset for body A
	public native @Const @ByRef btTransform getCalculatedTransformA();
	// Gets the global transform of the offset for body B
	public native @Const @ByRef btTransform getCalculatedTransformB();

	public native @ByRef btTransform getFrameOffsetA();
	public native @ByRef btTransform getFrameOffsetB();

	// Get the rotation axis in global coordinates ( btGeneric6DofSpring2Constraint::calculateTransforms() must be called previously )
	public native @ByVal btVector3 getAxis(int axis_index);

	// Get the relative Euler angle ( btGeneric6DofSpring2Constraint::calculateTransforms() must be called previously )
	public native @Cast("btScalar") float getAngle(int axis_index);

	// Get the relative position of the constraint pivot ( btGeneric6DofSpring2Constraint::calculateTransforms() must be called previously )
	public native @Cast("btScalar") float getRelativePivotPosition(int axis_index);

	public native void setFrames(@Const @ByRef btTransform frameA, @Const @ByRef btTransform frameB);

	public native void setLinearLowerLimit(@Const @ByRef btVector3 linearLower);
	public native void getLinearLowerLimit(@ByRef btVector3 linearLower);
	public native void setLinearUpperLimit(@Const @ByRef btVector3 linearUpper);
	public native void getLinearUpperLimit(@ByRef btVector3 linearUpper);

	public native void setAngularLowerLimit(@Const @ByRef btVector3 angularLower);

	public native void setAngularLowerLimitReversed(@Const @ByRef btVector3 angularLower);

	public native void getAngularLowerLimit(@ByRef btVector3 angularLower);

	public native void getAngularLowerLimitReversed(@ByRef btVector3 angularLower);

	public native void setAngularUpperLimit(@Const @ByRef btVector3 angularUpper);

	public native void setAngularUpperLimitReversed(@Const @ByRef btVector3 angularUpper);

	public native void getAngularUpperLimit(@ByRef btVector3 angularUpper);

	public native void getAngularUpperLimitReversed(@ByRef btVector3 angularUpper);

	//first 3 are linear, next 3 are angular

	public native void setLimit(int axis, @Cast("btScalar") float lo, @Cast("btScalar") float hi);

	public native void setLimitReversed(int axis, @Cast("btScalar") float lo, @Cast("btScalar") float hi);

	public native @Cast("bool") boolean isLimited(int limitIndex);

	public native void setRotationOrder(@Cast("RotateOrder") int order);
	public native @Cast("RotateOrder") int getRotationOrder();

	public native void setAxis(@Const @ByRef btVector3 axis1, @Const @ByRef btVector3 axis2);

	public native void setBounce(int index, @Cast("btScalar") float bounce);

	public native void enableMotor(int index, @Cast("bool") boolean onOff);
	public native void setServo(int index, @Cast("bool") boolean onOff);  // set the type of the motor (servo or not) (the motor has to be turned on for servo also)
	public native void setTargetVelocity(int index, @Cast("btScalar") float velocity);
	public native void setServoTarget(int index, @Cast("btScalar") float target);
	public native void setMaxMotorForce(int index, @Cast("btScalar") float force);

	public native void enableSpring(int index, @Cast("bool") boolean onOff);
	public native void setStiffness(int index, @Cast("btScalar") float stiffness, @Cast("bool") boolean limitIfNeeded/*=true*/);
	public native void setStiffness(int index, @Cast("btScalar") float stiffness);  // if limitIfNeeded is true the system will automatically limit the stiffness in necessary situations where otherwise the spring would move unrealistically too widely
	public native void setDamping(int index, @Cast("btScalar") float damping, @Cast("bool") boolean limitIfNeeded/*=true*/);
	public native void setDamping(int index, @Cast("btScalar") float damping);      // if limitIfNeeded is true the system will automatically limit the damping in necessary situations where otherwise the spring would blow up
	public native void setEquilibriumPoint();                                                   // set the current constraint position/orientation as an equilibrium point for all DOF
	public native void setEquilibriumPoint(int index);                                          // set the current constraint position/orientation as an equilibrium point for given DOF
	public native void setEquilibriumPoint(int index, @Cast("btScalar") float val);

	//override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
	//If no axis is provided, it uses the default axis for this constraint.
	public native void setParam(int num, @Cast("btScalar") float value, int axis/*=-1*/);
	public native void setParam(int num, @Cast("btScalar") float value);
	public native @Cast("btScalar") float getParam(int num, int axis/*=-1*/);
	public native @Cast("btScalar") float getParam(int num);

	public static native @Cast("btScalar") float btGetMatrixElem(@Const @ByRef btMatrix3x3 mat, int index);
	public static native @Cast("bool") boolean matrixToEulerXYZ(@Const @ByRef btMatrix3x3 mat, @ByRef btVector3 xyz);
	public static native @Cast("bool") boolean matrixToEulerXZY(@Const @ByRef btMatrix3x3 mat, @ByRef btVector3 xyz);
	public static native @Cast("bool") boolean matrixToEulerYXZ(@Const @ByRef btMatrix3x3 mat, @ByRef btVector3 xyz);
	public static native @Cast("bool") boolean matrixToEulerYZX(@Const @ByRef btMatrix3x3 mat, @ByRef btVector3 xyz);
	public static native @Cast("bool") boolean matrixToEulerZXY(@Const @ByRef btMatrix3x3 mat, @ByRef btVector3 xyz);
	public static native @Cast("bool") boolean matrixToEulerZYX(@Const @ByRef btMatrix3x3 mat, @ByRef btVector3 xyz);
}

public static class btGeneric6DofSpring2ConstraintData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btGeneric6DofSpring2ConstraintData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btGeneric6DofSpring2ConstraintData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btGeneric6DofSpring2ConstraintData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btGeneric6DofSpring2ConstraintData position(long position) {
        return (btGeneric6DofSpring2ConstraintData)super.position(position);
    }
    @Override public btGeneric6DofSpring2ConstraintData getPointer(long i) {
        return new btGeneric6DofSpring2ConstraintData((Pointer)this).offsetAddress(i);
    }

	
	public native @ByRef btTransformFloatData m_rbAFrame(); public native btGeneric6DofSpring2ConstraintData m_rbAFrame(btTransformFloatData setter);
	public native @ByRef btTransformFloatData m_rbBFrame(); public native btGeneric6DofSpring2ConstraintData m_rbBFrame(btTransformFloatData setter);

	public native @ByRef btVector3FloatData m_linearUpperLimit(); public native btGeneric6DofSpring2ConstraintData m_linearUpperLimit(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_linearLowerLimit(); public native btGeneric6DofSpring2ConstraintData m_linearLowerLimit(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_linearBounce(); public native btGeneric6DofSpring2ConstraintData m_linearBounce(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_linearStopERP(); public native btGeneric6DofSpring2ConstraintData m_linearStopERP(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_linearStopCFM(); public native btGeneric6DofSpring2ConstraintData m_linearStopCFM(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_linearMotorERP(); public native btGeneric6DofSpring2ConstraintData m_linearMotorERP(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_linearMotorCFM(); public native btGeneric6DofSpring2ConstraintData m_linearMotorCFM(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_linearTargetVelocity(); public native btGeneric6DofSpring2ConstraintData m_linearTargetVelocity(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_linearMaxMotorForce(); public native btGeneric6DofSpring2ConstraintData m_linearMaxMotorForce(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_linearServoTarget(); public native btGeneric6DofSpring2ConstraintData m_linearServoTarget(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_linearSpringStiffness(); public native btGeneric6DofSpring2ConstraintData m_linearSpringStiffness(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_linearSpringDamping(); public native btGeneric6DofSpring2ConstraintData m_linearSpringDamping(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_linearEquilibriumPoint(); public native btGeneric6DofSpring2ConstraintData m_linearEquilibriumPoint(btVector3FloatData setter);
	public native @Cast("char") byte m_linearEnableMotor(int i); public native btGeneric6DofSpring2ConstraintData m_linearEnableMotor(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_linearEnableMotor();
	public native @Cast("char") byte m_linearServoMotor(int i); public native btGeneric6DofSpring2ConstraintData m_linearServoMotor(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_linearServoMotor();
	public native @Cast("char") byte m_linearEnableSpring(int i); public native btGeneric6DofSpring2ConstraintData m_linearEnableSpring(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_linearEnableSpring();
	public native @Cast("char") byte m_linearSpringStiffnessLimited(int i); public native btGeneric6DofSpring2ConstraintData m_linearSpringStiffnessLimited(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_linearSpringStiffnessLimited();
	public native @Cast("char") byte m_linearSpringDampingLimited(int i); public native btGeneric6DofSpring2ConstraintData m_linearSpringDampingLimited(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_linearSpringDampingLimited();
	public native @Cast("char") byte m_padding1(int i); public native btGeneric6DofSpring2ConstraintData m_padding1(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_padding1();

	public native @ByRef btVector3FloatData m_angularUpperLimit(); public native btGeneric6DofSpring2ConstraintData m_angularUpperLimit(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_angularLowerLimit(); public native btGeneric6DofSpring2ConstraintData m_angularLowerLimit(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_angularBounce(); public native btGeneric6DofSpring2ConstraintData m_angularBounce(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_angularStopERP(); public native btGeneric6DofSpring2ConstraintData m_angularStopERP(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_angularStopCFM(); public native btGeneric6DofSpring2ConstraintData m_angularStopCFM(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_angularMotorERP(); public native btGeneric6DofSpring2ConstraintData m_angularMotorERP(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_angularMotorCFM(); public native btGeneric6DofSpring2ConstraintData m_angularMotorCFM(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_angularTargetVelocity(); public native btGeneric6DofSpring2ConstraintData m_angularTargetVelocity(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_angularMaxMotorForce(); public native btGeneric6DofSpring2ConstraintData m_angularMaxMotorForce(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_angularServoTarget(); public native btGeneric6DofSpring2ConstraintData m_angularServoTarget(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_angularSpringStiffness(); public native btGeneric6DofSpring2ConstraintData m_angularSpringStiffness(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_angularSpringDamping(); public native btGeneric6DofSpring2ConstraintData m_angularSpringDamping(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_angularEquilibriumPoint(); public native btGeneric6DofSpring2ConstraintData m_angularEquilibriumPoint(btVector3FloatData setter);
	public native @Cast("char") byte m_angularEnableMotor(int i); public native btGeneric6DofSpring2ConstraintData m_angularEnableMotor(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_angularEnableMotor();
	public native @Cast("char") byte m_angularServoMotor(int i); public native btGeneric6DofSpring2ConstraintData m_angularServoMotor(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_angularServoMotor();
	public native @Cast("char") byte m_angularEnableSpring(int i); public native btGeneric6DofSpring2ConstraintData m_angularEnableSpring(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_angularEnableSpring();
	public native @Cast("char") byte m_angularSpringStiffnessLimited(int i); public native btGeneric6DofSpring2ConstraintData m_angularSpringStiffnessLimited(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_angularSpringStiffnessLimited();
	public native @Cast("char") byte m_angularSpringDampingLimited(int i); public native btGeneric6DofSpring2ConstraintData m_angularSpringDampingLimited(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_angularSpringDampingLimited();

	public native int m_rotateOrder(); public native btGeneric6DofSpring2ConstraintData m_rotateOrder(int setter);
}

public static class btGeneric6DofSpring2ConstraintDoubleData2 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btGeneric6DofSpring2ConstraintDoubleData2() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btGeneric6DofSpring2ConstraintDoubleData2(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btGeneric6DofSpring2ConstraintDoubleData2(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btGeneric6DofSpring2ConstraintDoubleData2 position(long position) {
        return (btGeneric6DofSpring2ConstraintDoubleData2)super.position(position);
    }
    @Override public btGeneric6DofSpring2ConstraintDoubleData2 getPointer(long i) {
        return new btGeneric6DofSpring2ConstraintDoubleData2((Pointer)this).offsetAddress(i);
    }

	
	public native @ByRef btTransformDoubleData m_rbAFrame(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_rbAFrame(btTransformDoubleData setter);
	public native @ByRef btTransformDoubleData m_rbBFrame(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_rbBFrame(btTransformDoubleData setter);

	public native @ByRef btVector3DoubleData m_linearUpperLimit(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearUpperLimit(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_linearLowerLimit(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearLowerLimit(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_linearBounce(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearBounce(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_linearStopERP(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearStopERP(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_linearStopCFM(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearStopCFM(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_linearMotorERP(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearMotorERP(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_linearMotorCFM(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearMotorCFM(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_linearTargetVelocity(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearTargetVelocity(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_linearMaxMotorForce(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearMaxMotorForce(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_linearServoTarget(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearServoTarget(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_linearSpringStiffness(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearSpringStiffness(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_linearSpringDamping(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearSpringDamping(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_linearEquilibriumPoint(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearEquilibriumPoint(btVector3DoubleData setter);
	public native @Cast("char") byte m_linearEnableMotor(int i); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearEnableMotor(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_linearEnableMotor();
	public native @Cast("char") byte m_linearServoMotor(int i); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearServoMotor(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_linearServoMotor();
	public native @Cast("char") byte m_linearEnableSpring(int i); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearEnableSpring(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_linearEnableSpring();
	public native @Cast("char") byte m_linearSpringStiffnessLimited(int i); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearSpringStiffnessLimited(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_linearSpringStiffnessLimited();
	public native @Cast("char") byte m_linearSpringDampingLimited(int i); public native btGeneric6DofSpring2ConstraintDoubleData2 m_linearSpringDampingLimited(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_linearSpringDampingLimited();
	public native @Cast("char") byte m_padding1(int i); public native btGeneric6DofSpring2ConstraintDoubleData2 m_padding1(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_padding1();

	public native @ByRef btVector3DoubleData m_angularUpperLimit(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularUpperLimit(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_angularLowerLimit(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularLowerLimit(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_angularBounce(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularBounce(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_angularStopERP(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularStopERP(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_angularStopCFM(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularStopCFM(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_angularMotorERP(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularMotorERP(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_angularMotorCFM(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularMotorCFM(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_angularTargetVelocity(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularTargetVelocity(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_angularMaxMotorForce(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularMaxMotorForce(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_angularServoTarget(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularServoTarget(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_angularSpringStiffness(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularSpringStiffness(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_angularSpringDamping(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularSpringDamping(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_angularEquilibriumPoint(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularEquilibriumPoint(btVector3DoubleData setter);
	public native @Cast("char") byte m_angularEnableMotor(int i); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularEnableMotor(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_angularEnableMotor();
	public native @Cast("char") byte m_angularServoMotor(int i); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularServoMotor(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_angularServoMotor();
	public native @Cast("char") byte m_angularEnableSpring(int i); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularEnableSpring(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_angularEnableSpring();
	public native @Cast("char") byte m_angularSpringStiffnessLimited(int i); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularSpringStiffnessLimited(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_angularSpringStiffnessLimited();
	public native @Cast("char") byte m_angularSpringDampingLimited(int i); public native btGeneric6DofSpring2ConstraintDoubleData2 m_angularSpringDampingLimited(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_angularSpringDampingLimited();

	public native int m_rotateOrder(); public native btGeneric6DofSpring2ConstraintDoubleData2 m_rotateOrder(int setter);
}





// #endif  //BT_GENERIC_6DOF_CONSTRAINT_H


// Parsed from BulletDynamics/ConstraintSolver/btUniversalConstraint.h

/*
Bullet Continuous Collision Detection and Physics Library, http://bulletphysics.org
Copyright (C) 2006, 2007 Sony Computer Entertainment Inc. 

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_UNIVERSAL_CONSTRAINT_H
// #define BT_UNIVERSAL_CONSTRAINT_H

// #include "LinearMath/btVector3.h"
// #include "btTypedConstraint.h"
// #include "btGeneric6DofConstraint.h"

/** Constraint similar to ODE Universal Joint
 *  has 2 rotatioonal degrees of freedom, similar to Euler rotations around Z (axis 1)
 *  and Y (axis 2)
 *  Description from ODE manual :
 *  "Given axis 1 on body 1, and axis 2 on body 2 that is perpendicular to axis 1, it keeps them perpendicular.
 *  In other words, rotation of the two bodies about the direction perpendicular to the two axes will be equal." */

@NoOffset public static class btUniversalConstraint extends btGeneric6DofConstraint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btUniversalConstraint(Pointer p) { super(p); }


	// constructor
	// anchor, axis1 and axis2 are in world coordinate system
	// axis1 must be orthogonal to axis2
	public btUniversalConstraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btVector3 anchor, @Const @ByRef btVector3 axis1, @Const @ByRef btVector3 axis2) { super((Pointer)null); allocate(rbA, rbB, anchor, axis1, axis2); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btVector3 anchor, @Const @ByRef btVector3 axis1, @Const @ByRef btVector3 axis2);
	// access
	public native @Const @ByRef btVector3 getAnchor();
	public native @Const @ByRef btVector3 getAnchor2();
	public native @Const @ByRef btVector3 getAxis1();
	public native @Const @ByRef btVector3 getAxis2();
	public native @Cast("btScalar") float getAngle1();
	public native @Cast("btScalar") float getAngle2();
	// limits
	public native void setUpperLimit(@Cast("btScalar") float ang1max, @Cast("btScalar") float ang2max);
	public native void setLowerLimit(@Cast("btScalar") float ang1min, @Cast("btScalar") float ang2min);

	public native void setAxis(@Const @ByRef btVector3 axis1, @Const @ByRef btVector3 axis2);
}

// #endif  // BT_UNIVERSAL_CONSTRAINT_H


// Parsed from BulletDynamics/ConstraintSolver/btHinge2Constraint.h

/*
Bullet Continuous Collision Detection and Physics Library, http://bulletphysics.org
Copyright (C) 2006, 2007 Sony Computer Entertainment Inc. 

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_HINGE2_CONSTRAINT_H
// #define BT_HINGE2_CONSTRAINT_H

// #include "LinearMath/btVector3.h"
// #include "btTypedConstraint.h"
// #include "btGeneric6DofSpring2Constraint.h"

// Constraint similar to ODE Hinge2 Joint
// has 3 degrees of frredom:
// 2 rotational degrees of freedom, similar to Euler rotations around Z (axis 1) and X (axis 2)
// 1 translational (along axis Z) with suspension spring

@NoOffset public static class btHinge2Constraint extends btGeneric6DofSpring2Constraint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btHinge2Constraint(Pointer p) { super(p); }


	// constructor
	// anchor, axis1 and axis2 are in world coordinate system
	// axis1 must be orthogonal to axis2
	public btHinge2Constraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @ByRef btVector3 anchor, @ByRef btVector3 axis1, @ByRef btVector3 axis2) { super((Pointer)null); allocate(rbA, rbB, anchor, axis1, axis2); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @ByRef btVector3 anchor, @ByRef btVector3 axis1, @ByRef btVector3 axis2);
	// access
	public native @Const @ByRef btVector3 getAnchor();
	public native @Const @ByRef btVector3 getAnchor2();
	public native @Const @ByRef btVector3 getAxis1();
	public native @Const @ByRef btVector3 getAxis2();
	public native @Cast("btScalar") float getAngle1();
	public native @Cast("btScalar") float getAngle2();
	// limits
	public native void setUpperLimit(@Cast("btScalar") float ang1max);
	public native void setLowerLimit(@Cast("btScalar") float ang1min);
}

// #endif  // BT_HINGE2_CONSTRAINT_H


// Parsed from BulletDynamics/ConstraintSolver/btGearConstraint.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2012 Advanced Micro Devices, Inc.  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_GEAR_CONSTRAINT_H
// #define BT_GEAR_CONSTRAINT_H

// #include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"

// #ifdef BT_USE_DOUBLE_PRECISION
// #else
// #define btGearConstraintData btGearConstraintFloatData
public static final String btGearConstraintDataName = "btGearConstraintFloatData";
// #endif  //BT_USE_DOUBLE_PRECISION

/**The btGeatConstraint will couple the angular velocity for two bodies around given local axis and ratio.
 * See Bullet/Demos/ConstraintDemo for an example use. */
@NoOffset public static class btGearConstraint extends btTypedConstraint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btGearConstraint(Pointer p) { super(p); }

	public btGearConstraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btVector3 axisInA, @Const @ByRef btVector3 axisInB, @Cast("btScalar") float ratio/*=1.f*/) { super((Pointer)null); allocate(rbA, rbB, axisInA, axisInB, ratio); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btVector3 axisInA, @Const @ByRef btVector3 axisInB, @Cast("btScalar") float ratio/*=1.f*/);
	public btGearConstraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btVector3 axisInA, @Const @ByRef btVector3 axisInB) { super((Pointer)null); allocate(rbA, rbB, axisInA, axisInB); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btVector3 axisInA, @Const @ByRef btVector3 axisInB);

	/**internal method used by the constraint solver, don't use them directly */

	/**internal method used by the constraint solver, don't use them directly */

	public native void setAxisA(@ByRef btVector3 axisA);
	public native void setAxisB(@ByRef btVector3 axisB);
	public native void setRatio(@Cast("btScalar") float ratio);
	public native @Const @ByRef btVector3 getAxisA();
	public native @Const @ByRef btVector3 getAxisB();
	public native @Cast("btScalar") float getRatio();

	public native void setParam(int num, @Cast("btScalar") float value, int axis/*=-1*/);
	public native void setParam(int num, @Cast("btScalar") float value);

	/**return the local value of parameter */
	public native @Cast("btScalar") float getParam(int num, int axis/*=-1*/);
	public native @Cast("btScalar") float getParam(int num);

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);
}

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btGearConstraintFloatData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btGearConstraintFloatData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btGearConstraintFloatData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btGearConstraintFloatData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btGearConstraintFloatData position(long position) {
        return (btGearConstraintFloatData)super.position(position);
    }
    @Override public btGearConstraintFloatData getPointer(long i) {
        return new btGearConstraintFloatData((Pointer)this).offsetAddress(i);
    }

	

	public native @ByRef btVector3FloatData m_axisInA(); public native btGearConstraintFloatData m_axisInA(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_axisInB(); public native btGearConstraintFloatData m_axisInB(btVector3FloatData setter);

	public native float m_ratio(); public native btGearConstraintFloatData m_ratio(float setter);
	public native @Cast("char") byte m_padding(int i); public native btGearConstraintFloatData m_padding(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_padding();
}

public static class btGearConstraintDoubleData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btGearConstraintDoubleData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btGearConstraintDoubleData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btGearConstraintDoubleData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btGearConstraintDoubleData position(long position) {
        return (btGearConstraintDoubleData)super.position(position);
    }
    @Override public btGearConstraintDoubleData getPointer(long i) {
        return new btGearConstraintDoubleData((Pointer)this).offsetAddress(i);
    }

	

	public native @ByRef btVector3DoubleData m_axisInA(); public native btGearConstraintDoubleData m_axisInA(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_axisInB(); public native btGearConstraintDoubleData m_axisInB(btVector3DoubleData setter);

	public native double m_ratio(); public native btGearConstraintDoubleData m_ratio(double setter);
}



/**fills the dataBuffer and returns the struct name (and 0 on failure) */


// #endif  //BT_GEAR_CONSTRAINT_H


// Parsed from BulletDynamics/ConstraintSolver/btFixedConstraint.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2013 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_FIXED_CONSTRAINT_H
// #define BT_FIXED_CONSTRAINT_H

// #include "btGeneric6DofSpring2Constraint.h"

public static class btFixedConstraint extends btGeneric6DofSpring2Constraint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btFixedConstraint(Pointer p) { super(p); }

	public btFixedConstraint(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform frameInA, @Const @ByRef btTransform frameInB) { super((Pointer)null); allocate(rbA, rbB, frameInA, frameInB); }
	private native void allocate(@ByRef btRigidBody rbA, @ByRef btRigidBody rbB, @Const @ByRef btTransform frameInA, @Const @ByRef btTransform frameInB);
}

// #endif  //BT_FIXED_CONSTRAINT_H


// Parsed from BulletDynamics/ConstraintSolver/btConstraintSolver.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_CONSTRAINT_SOLVER_H
// #define BT_CONSTRAINT_SOLVER_H

// #include "LinearMath/btScalar.h"
@Opaque public static class btStackAlloc extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public btStackAlloc() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btStackAlloc(Pointer p) { super(p); }
}
/** btConstraintSolver provides solver interface */

/** enum btConstraintSolverType */
public static final int
	BT_SEQUENTIAL_IMPULSE_SOLVER = 1,
	BT_MLCP_SOLVER = 2,
	BT_NNCG_SOLVER = 4,
	BT_MULTIBODY_SOLVER = 8,
	BT_BLOCK_SOLVER = 16;

public static class btConstraintSolver extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConstraintSolver(Pointer p) { super(p); }


	public native void prepareSolve(int arg0, int arg1);

	/**solve a group of constraints */
	public native @Cast("btScalar") float solveGroup(@Cast("btCollisionObject**") PointerPointer bodies, int numBodies, @Cast("btPersistentManifold**") PointerPointer manifold, int numManifolds, @Cast("btTypedConstraint**") PointerPointer constraints, int numConstraints, @Const @ByRef btContactSolverInfo info, btIDebugDraw debugDrawer, btDispatcher dispatcher);
	public native @Cast("btScalar") float solveGroup(@ByPtrPtr btCollisionObject bodies, int numBodies, @ByPtrPtr btPersistentManifold manifold, int numManifolds, @ByPtrPtr btTypedConstraint constraints, int numConstraints, @Const @ByRef btContactSolverInfo info, btIDebugDraw debugDrawer, btDispatcher dispatcher);

	public native void allSolved(@Const @ByRef btContactSolverInfo arg0, btIDebugDraw arg1);

	/**clear internal cached data and reset random seed */
	public native void reset();

	public native @Cast("btConstraintSolverType") int getSolverType();
}

// #endif  //BT_CONSTRAINT_SOLVER_H


// Parsed from BulletDynamics/ConstraintSolver/btSequentialImpulseConstraintSolver.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_SEQUENTIAL_IMPULSE_CONSTRAINT_SOLVER_H
// #define BT_SEQUENTIAL_IMPULSE_CONSTRAINT_SOLVER_H
// #include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
// #include "BulletDynamics/ConstraintSolver/btContactSolverInfo.h"
// #include "BulletDynamics/ConstraintSolver/btSolverBody.h"
// #include "BulletDynamics/ConstraintSolver/btSolverConstraint.h"
// #include "BulletCollision/NarrowPhaseCollision/btManifoldPoint.h"
// #include "BulletDynamics/ConstraintSolver/btConstraintSolver.h"

@NoOffset public static class btSolverAnalyticsData extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btSolverAnalyticsData(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btSolverAnalyticsData(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btSolverAnalyticsData position(long position) {
        return (btSolverAnalyticsData)super.position(position);
    }
    @Override public btSolverAnalyticsData getPointer(long i) {
        return new btSolverAnalyticsData((Pointer)this).offsetAddress(i);
    }

	public btSolverAnalyticsData() { super((Pointer)null); allocate(); }
	private native void allocate();
	public native int m_islandId(); public native btSolverAnalyticsData m_islandId(int setter);
	public native int m_numBodies(); public native btSolverAnalyticsData m_numBodies(int setter);
	public native int m_numContactManifolds(); public native btSolverAnalyticsData m_numContactManifolds(int setter);
	public native int m_numSolverCalls(); public native btSolverAnalyticsData m_numSolverCalls(int setter);
	public native int m_numIterationsUsed(); public native btSolverAnalyticsData m_numIterationsUsed(int setter);
	public native double m_remainingLeastSquaresResidual(); public native btSolverAnalyticsData m_remainingLeastSquaresResidual(double setter);
}

/**The btSequentialImpulseConstraintSolver is a fast SIMD implementation of the Projected Gauss Seidel (iterative LCP) method. */
@NoOffset public static class btSequentialImpulseConstraintSolver extends btConstraintSolver {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btSequentialImpulseConstraintSolver(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btSequentialImpulseConstraintSolver(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btSequentialImpulseConstraintSolver position(long position) {
        return (btSequentialImpulseConstraintSolver)super.position(position);
    }
    @Override public btSequentialImpulseConstraintSolver getPointer(long i) {
        return new btSequentialImpulseConstraintSolver((Pointer)this).offsetAddress(i);
    }


	public btSequentialImpulseConstraintSolver() { super((Pointer)null); allocate(); }
	private native void allocate();

	public native @Cast("btScalar") float solveGroup(@Cast("btCollisionObject**") PointerPointer bodies, int numBodies, @Cast("btPersistentManifold**") PointerPointer manifold, int numManifolds, @Cast("btTypedConstraint**") PointerPointer constraints, int numConstraints, @Const @ByRef btContactSolverInfo info, btIDebugDraw debugDrawer, btDispatcher dispatcher);
	public native @Cast("btScalar") float solveGroup(@ByPtrPtr btCollisionObject bodies, int numBodies, @ByPtrPtr btPersistentManifold manifold, int numManifolds, @ByPtrPtr btTypedConstraint constraints, int numConstraints, @Const @ByRef btContactSolverInfo info, btIDebugDraw debugDrawer, btDispatcher dispatcher);

	/**clear internal cached data and reset random seed */
	public native void reset();

	public native @Cast("unsigned long") long btRand2();

	public native int btRandInt2(int n);

	public native void setRandSeed(@Cast("unsigned long") long seed);
	public native @Cast("unsigned long") long getRandSeed();

	public native @Cast("btConstraintSolverType") int getSolverType();



	/**Various implementations of solving a single constraint row using a generic equality constraint, using scalar reference, SSE2 or SSE4 */

	/**Various implementations of solving a single constraint row using an inequality (lower limit) constraint, using scalar reference, SSE2 or SSE4 */
	public native @ByRef btSolverAnalyticsData m_analyticsData(); public native btSequentialImpulseConstraintSolver m_analyticsData(btSolverAnalyticsData setter);
}

// #endif  //BT_SEQUENTIAL_IMPULSE_CONSTRAINT_SOLVER_H


// Parsed from BulletDynamics/Vehicle/btVehicleRaycaster.h

/*
 * Copyright (c) 2005 Erwin Coumans http://bulletphysics.org
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies.
 * Erwin Coumans makes no representations about the suitability 
 * of this software for any purpose.  
 * It is provided "as is" without express or implied warranty.
*/
// #ifndef BT_VEHICLE_RAYCASTER_H
// #define BT_VEHICLE_RAYCASTER_H

// #include "LinearMath/btVector3.h"

/** btVehicleRaycaster is provides interface for between vehicle simulation and raycasting */
public static class btVehicleRaycaster extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btVehicleRaycaster(Pointer p) { super(p); }

	@NoOffset public static class btVehicleRaycasterResult extends Pointer {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public btVehicleRaycasterResult(Pointer p) { super(p); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public btVehicleRaycasterResult(long size) { super((Pointer)null); allocateArray(size); }
	    private native void allocateArray(long size);
	    @Override public btVehicleRaycasterResult position(long position) {
	        return (btVehicleRaycasterResult)super.position(position);
	    }
	    @Override public btVehicleRaycasterResult getPointer(long i) {
	        return new btVehicleRaycasterResult((Pointer)this).offsetAddress(i);
	    }
	
		public btVehicleRaycasterResult() { super((Pointer)null); allocate(); }
		private native void allocate();
		public native @ByRef btVector3 m_hitPointInWorld(); public native btVehicleRaycasterResult m_hitPointInWorld(btVector3 setter);
		public native @ByRef btVector3 m_hitNormalInWorld(); public native btVehicleRaycasterResult m_hitNormalInWorld(btVector3 setter);
		public native @Cast("btScalar") float m_distFraction(); public native btVehicleRaycasterResult m_distFraction(float setter);
	}

	public native Pointer castRay(@Const @ByRef btVector3 from, @Const @ByRef btVector3 to, @ByRef btVehicleRaycasterResult result);
}

// #endif  //BT_VEHICLE_RAYCASTER_H


// Parsed from BulletDynamics/Vehicle/btWheelInfo.h

/*
 * Copyright (c) 2005 Erwin Coumans https://bulletphysics.org
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies.
 * Erwin Coumans makes no representations about the suitability 
 * of this software for any purpose.  
 * It is provided "as is" without express or implied warranty.
*/
// #ifndef BT_WHEEL_INFO_H
// #define BT_WHEEL_INFO_H

// #include "LinearMath/btVector3.h"
// #include "LinearMath/btTransform.h"

public static class btWheelInfoConstructionInfo extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btWheelInfoConstructionInfo() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btWheelInfoConstructionInfo(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btWheelInfoConstructionInfo(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btWheelInfoConstructionInfo position(long position) {
        return (btWheelInfoConstructionInfo)super.position(position);
    }
    @Override public btWheelInfoConstructionInfo getPointer(long i) {
        return new btWheelInfoConstructionInfo((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btVector3 m_chassisConnectionCS(); public native btWheelInfoConstructionInfo m_chassisConnectionCS(btVector3 setter);
	public native @ByRef btVector3 m_wheelDirectionCS(); public native btWheelInfoConstructionInfo m_wheelDirectionCS(btVector3 setter);
	public native @ByRef btVector3 m_wheelAxleCS(); public native btWheelInfoConstructionInfo m_wheelAxleCS(btVector3 setter);
	public native @Cast("btScalar") float m_suspensionRestLength(); public native btWheelInfoConstructionInfo m_suspensionRestLength(float setter);
	public native @Cast("btScalar") float m_maxSuspensionTravelCm(); public native btWheelInfoConstructionInfo m_maxSuspensionTravelCm(float setter);
	public native @Cast("btScalar") float m_wheelRadius(); public native btWheelInfoConstructionInfo m_wheelRadius(float setter);

	public native @Cast("btScalar") float m_suspensionStiffness(); public native btWheelInfoConstructionInfo m_suspensionStiffness(float setter);
	public native @Cast("btScalar") float m_wheelsDampingCompression(); public native btWheelInfoConstructionInfo m_wheelsDampingCompression(float setter);
	public native @Cast("btScalar") float m_wheelsDampingRelaxation(); public native btWheelInfoConstructionInfo m_wheelsDampingRelaxation(float setter);
	public native @Cast("btScalar") float m_frictionSlip(); public native btWheelInfoConstructionInfo m_frictionSlip(float setter);
	public native @Cast("btScalar") float m_maxSuspensionForce(); public native btWheelInfoConstructionInfo m_maxSuspensionForce(float setter);
	public native @Cast("bool") boolean m_bIsFrontWheel(); public native btWheelInfoConstructionInfo m_bIsFrontWheel(boolean setter);
}

/** btWheelInfo contains information per wheel about friction and suspension. */
@NoOffset public static class btWheelInfo extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btWheelInfo(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btWheelInfo(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btWheelInfo position(long position) {
        return (btWheelInfo)super.position(position);
    }
    @Override public btWheelInfo getPointer(long i) {
        return new btWheelInfo((Pointer)this).offsetAddress(i);
    }

	public static class RaycastInfo extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public RaycastInfo() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public RaycastInfo(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public RaycastInfo(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public RaycastInfo position(long position) {
	        return (RaycastInfo)super.position(position);
	    }
	    @Override public RaycastInfo getPointer(long i) {
	        return new RaycastInfo((Pointer)this).offsetAddress(i);
	    }
	
		//set by raycaster
		public native @ByRef btVector3 m_contactNormalWS(); public native RaycastInfo m_contactNormalWS(btVector3 setter);  //contactnormal
		public native @ByRef btVector3 m_contactPointWS(); public native RaycastInfo m_contactPointWS(btVector3 setter);   //raycast hitpoint
		public native @Cast("btScalar") float m_suspensionLength(); public native RaycastInfo m_suspensionLength(float setter);
		public native @ByRef btVector3 m_hardPointWS(); public native RaycastInfo m_hardPointWS(btVector3 setter);       //raycast starting point
		public native @ByRef btVector3 m_wheelDirectionWS(); public native RaycastInfo m_wheelDirectionWS(btVector3 setter);  //direction in worldspace
		public native @ByRef btVector3 m_wheelAxleWS(); public native RaycastInfo m_wheelAxleWS(btVector3 setter);       // axle in worldspace
		public native @Cast("bool") boolean m_isInContact(); public native RaycastInfo m_isInContact(boolean setter);
		public native Pointer m_groundObject(); public native RaycastInfo m_groundObject(Pointer setter);  //could be general void* ptr
	}

	public native @ByRef RaycastInfo m_raycastInfo(); public native btWheelInfo m_raycastInfo(RaycastInfo setter);

	public native @ByRef btTransform m_worldTransform(); public native btWheelInfo m_worldTransform(btTransform setter);

	public native @ByRef btVector3 m_chassisConnectionPointCS(); public native btWheelInfo m_chassisConnectionPointCS(btVector3 setter);  //const
	public native @ByRef btVector3 m_wheelDirectionCS(); public native btWheelInfo m_wheelDirectionCS(btVector3 setter);          //const
	public native @ByRef btVector3 m_wheelAxleCS(); public native btWheelInfo m_wheelAxleCS(btVector3 setter);               // const or modified by steering
	public native @Cast("btScalar") float m_suspensionRestLength1(); public native btWheelInfo m_suspensionRestLength1(float setter);      //const
	public native @Cast("btScalar") float m_maxSuspensionTravelCm(); public native btWheelInfo m_maxSuspensionTravelCm(float setter);
	public native @Cast("btScalar") float getSuspensionRestLength();
	public native @Cast("btScalar") float m_wheelsRadius(); public native btWheelInfo m_wheelsRadius(float setter);              //const
	public native @Cast("btScalar") float m_suspensionStiffness(); public native btWheelInfo m_suspensionStiffness(float setter);       //const
	public native @Cast("btScalar") float m_wheelsDampingCompression(); public native btWheelInfo m_wheelsDampingCompression(float setter);  //const
	public native @Cast("btScalar") float m_wheelsDampingRelaxation(); public native btWheelInfo m_wheelsDampingRelaxation(float setter);   //const
	public native @Cast("btScalar") float m_frictionSlip(); public native btWheelInfo m_frictionSlip(float setter);
	public native @Cast("btScalar") float m_steering(); public native btWheelInfo m_steering(float setter);
	public native @Cast("btScalar") float m_rotation(); public native btWheelInfo m_rotation(float setter);
	public native @Cast("btScalar") float m_deltaRotation(); public native btWheelInfo m_deltaRotation(float setter);
	public native @Cast("btScalar") float m_rollInfluence(); public native btWheelInfo m_rollInfluence(float setter);
	public native @Cast("btScalar") float m_maxSuspensionForce(); public native btWheelInfo m_maxSuspensionForce(float setter);

	public native @Cast("btScalar") float m_engineForce(); public native btWheelInfo m_engineForce(float setter);

	public native @Cast("btScalar") float m_brake(); public native btWheelInfo m_brake(float setter);

	public native @Cast("bool") boolean m_bIsFrontWheel(); public native btWheelInfo m_bIsFrontWheel(boolean setter);

	public native Pointer m_clientInfo(); public native btWheelInfo m_clientInfo(Pointer setter);  //can be used to store pointer to sync transforms...

	public btWheelInfo() { super((Pointer)null); allocate(); }
	private native void allocate();

	public btWheelInfo(@ByRef btWheelInfoConstructionInfo ci) { super((Pointer)null); allocate(ci); }
	private native void allocate(@ByRef btWheelInfoConstructionInfo ci);

	public native void updateWheel(@Const @ByRef btRigidBody chassis, @ByRef RaycastInfo raycastInfo);

	public native @Cast("btScalar") float m_clippedInvContactDotSuspension(); public native btWheelInfo m_clippedInvContactDotSuspension(float setter);
	public native @Cast("btScalar") float m_suspensionRelativeVelocity(); public native btWheelInfo m_suspensionRelativeVelocity(float setter);
	//calculated by suspension
	public native @Cast("btScalar") float m_wheelsSuspensionForce(); public native btWheelInfo m_wheelsSuspensionForce(float setter);
	public native @Cast("btScalar") float m_skidInfo(); public native btWheelInfo m_skidInfo(float setter);
}

// #endif  //BT_WHEEL_INFO_H


// Parsed from BulletDynamics/Vehicle/btRaycastVehicle.h

/*
 * Copyright (c) 2005 Erwin Coumans https://bulletphysics.org
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies.
 * Erwin Coumans makes no representations about the suitability 
 * of this software for any purpose.  
 * It is provided "as is" without express or implied warranty.
*/
// #ifndef BT_RAYCASTVEHICLE_H
// #define BT_RAYCASTVEHICLE_H

// #include "BulletDynamics/Dynamics/btRigidBody.h"
// #include "BulletDynamics/ConstraintSolver/btTypedConstraint.h"
// #include "btVehicleRaycaster.h"
// #include "LinearMath/btAlignedObjectArray.h"
// #include "btWheelInfo.h"
// #include "BulletDynamics/Dynamics/btActionInterface.h"

//class btVehicleTuning;

/**rayCast vehicle, very special constraint that turn a rigidbody into a vehicle. */
@NoOffset public static class btRaycastVehicle extends btActionInterface {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btRaycastVehicle(Pointer p) { super(p); }

	@NoOffset public static class btVehicleTuning extends Pointer {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public btVehicleTuning(Pointer p) { super(p); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public btVehicleTuning(long size) { super((Pointer)null); allocateArray(size); }
	    private native void allocateArray(long size);
	    @Override public btVehicleTuning position(long position) {
	        return (btVehicleTuning)super.position(position);
	    }
	    @Override public btVehicleTuning getPointer(long i) {
	        return new btVehicleTuning((Pointer)this).offsetAddress(i);
	    }
	
		public btVehicleTuning() { super((Pointer)null); allocate(); }
		private native void allocate();
		public native @Cast("btScalar") float m_suspensionStiffness(); public native btVehicleTuning m_suspensionStiffness(float setter);
		public native @Cast("btScalar") float m_suspensionCompression(); public native btVehicleTuning m_suspensionCompression(float setter);
		public native @Cast("btScalar") float m_suspensionDamping(); public native btVehicleTuning m_suspensionDamping(float setter);
		public native @Cast("btScalar") float m_maxSuspensionTravelCm(); public native btVehicleTuning m_maxSuspensionTravelCm(float setter);
		public native @Cast("btScalar") float m_frictionSlip(); public native btVehicleTuning m_frictionSlip(float setter);
		public native @Cast("btScalar") float m_maxSuspensionForce(); public native btVehicleTuning m_maxSuspensionForce(float setter);
	}
	//constructor to create a car from an existing rigidbody
	public btRaycastVehicle(@Const @ByRef btVehicleTuning tuning, btRigidBody chassis, btVehicleRaycaster raycaster) { super((Pointer)null); allocate(tuning, chassis, raycaster); }
	private native void allocate(@Const @ByRef btVehicleTuning tuning, btRigidBody chassis, btVehicleRaycaster raycaster);

	/**btActionInterface interface */
	public native void updateAction(btCollisionWorld collisionWorld, @Cast("btScalar") float step);

	/**btActionInterface interface */
	public native void debugDraw(btIDebugDraw debugDrawer);

	public native @Const @ByRef btTransform getChassisWorldTransform();

	public native @Cast("btScalar") float rayCast(@ByRef btWheelInfo wheel);

	public native void updateVehicle(@Cast("btScalar") float step);

	public native void resetSuspension();

	public native @Cast("btScalar") float getSteeringValue(int wheel);

	public native void setSteeringValue(@Cast("btScalar") float steering, int wheel);

	public native void applyEngineForce(@Cast("btScalar") float force, int wheel);

	public native @Const @ByRef btTransform getWheelTransformWS(int wheelIndex);

	public native void updateWheelTransform(int wheelIndex, @Cast("bool") boolean interpolatedTransform/*=true*/);
	public native void updateWheelTransform(int wheelIndex);

	//	void	setRaycastWheelInfo( int wheelIndex , bool isInContact, const btVector3& hitPoint, const btVector3& hitNormal,btScalar depth);

	public native @ByRef btWheelInfo addWheel(@Const @ByRef btVector3 connectionPointCS0, @Const @ByRef btVector3 wheelDirectionCS0, @Const @ByRef btVector3 wheelAxleCS, @Cast("btScalar") float suspensionRestLength, @Cast("btScalar") float wheelRadius, @Const @ByRef btVehicleTuning tuning, @Cast("bool") boolean isFrontWheel);

	public native int getNumWheels();

	

	public native @ByRef btWheelInfo getWheelInfo(int index);

	public native void updateWheelTransformsWS(@ByRef btWheelInfo wheel, @Cast("bool") boolean interpolatedTransform/*=true*/);
	public native void updateWheelTransformsWS(@ByRef btWheelInfo wheel);

	public native void setBrake(@Cast("btScalar") float brake, int wheelIndex);

	public native void setPitchControl(@Cast("btScalar") float pitch);

	public native void updateSuspension(@Cast("btScalar") float deltaTime);

	public native void updateFriction(@Cast("btScalar") float timeStep);

	public native btRigidBody getRigidBody();

	public native int getRightAxis();
	public native int getUpAxis();

	public native int getForwardAxis();

	/**Worldspace forward vector */
	public native @ByVal btVector3 getForwardVector();

	/**Velocity of vehicle (positive if velocity vector has same direction as foward vector) */
	public native @Cast("btScalar") float getCurrentSpeedKmHour();

	public native void setCoordinateSystem(int rightIndex, int upIndex, int forwardIndex);

	/**backwards compatibility */
	public native int getUserConstraintType();

	public native void setUserConstraintType(int userConstraintType);

	public native void setUserConstraintId(int uid);

	public native int getUserConstraintId();
}

@NoOffset public static class btDefaultVehicleRaycaster extends btVehicleRaycaster {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btDefaultVehicleRaycaster(Pointer p) { super(p); }

	public btDefaultVehicleRaycaster(btDynamicsWorld world) { super((Pointer)null); allocate(world); }
	private native void allocate(btDynamicsWorld world);

	public native Pointer castRay(@Const @ByRef btVector3 from, @Const @ByRef btVector3 to, @ByRef btVehicleRaycasterResult result);
}

// #endif  //BT_RAYCASTVEHICLE_H


}
