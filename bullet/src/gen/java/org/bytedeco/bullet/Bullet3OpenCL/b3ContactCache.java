// Targeted by JavaCPP version 1.5.8-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.bullet.Bullet3OpenCL;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.bullet.Bullet3Common.*;
import static org.bytedeco.bullet.global.Bullet3Common.*;
import org.bytedeco.bullet.Bullet3Collision.*;
import static org.bytedeco.bullet.global.Bullet3Collision.*;
import org.bytedeco.bullet.Bullet3Dynamics.*;
import static org.bytedeco.bullet.global.Bullet3Dynamics.*;

import static org.bytedeco.bullet.global.Bullet3OpenCL.*;


/**b3ContactCache is a contact point cache, it stays persistent as long as objects are overlapping in the broadphase.
 * Those contact points are created by the collision narrow phase.
 * The cache can be empty, or hold 1,2,3 or 4 points. Some collision algorithms (GJK) might only add one point at a time.
 * updates/refreshes old contact points, and throw them away if necessary (distance becomes too large)
 * reduces the cache to 4 points, when more then 4 points are added, using following rules:
 * the contact point with deepest penetration is always kept, and it tries to maximuze the area covered by the points
 * note that some pairs of objects might have more then one contact manifold. */
@Properties(inherit = org.bytedeco.bullet.presets.Bullet3OpenCL.class)
public class b3ContactCache extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b3ContactCache() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b3ContactCache(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b3ContactCache(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b3ContactCache position(long position) {
        return (b3ContactCache)super.position(position);
    }
    @Override public b3ContactCache getPointer(long i) {
        return new b3ContactCache((Pointer)this).offsetAddress(i);
    }


	public native int addManifoldPoint(@Const @ByRef b3Vector3 newPoint);

	/*void replaceContactPoint(const b3Vector3& newPoint,int insertIndex)
	{
		b3Assert(validContactDistance(newPoint));
		m_pointCache[insertIndex] = newPoint;
	}
	*/

	public static native @Cast("bool") boolean validContactDistance(@Const @ByRef b3Vector3 pt);

	/** calculated new worldspace coordinates and depth, and reject points that exceed the collision margin */
	public static native void refreshContactPoints(@Const @ByRef b3Transform trA, @Const @ByRef b3Transform trB, @ByRef b3Contact4Data newContactCache);

	public static native void removeContactPoint(@ByRef b3Contact4Data newContactCache, int i);
}
