// Targeted by JavaCPP version 1.5.8-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.bullet;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

public class clew extends org.bytedeco.bullet.presets.clew {
    static { Loader.load(); }

// Parsed from clew/clew.h

// #ifndef CLEW_HPP_INCLUDED

//!
// #define CLEW_HPP_INCLUDED

//////////////////////////////////////////////////////////////////////////
//  Copyright (c) 2009-2011 Organic Vectory B.V., KindDragon
//  Written by George van Venrooij
//
//  Distributed under the MIT License.
//////////////////////////////////////////////////////////////////////////

/** \file clew.h
 *  \brief OpenCL run-time loader header
 * 
 *  This file contains a copy of the contents of CL.H and CL_PLATFORM.H from the
 *  official OpenCL spec. The purpose of this code is to load the OpenCL dynamic
 *  library at run-time and thus allow the executable to function on many
 *  platforms regardless of the vendor of the OpenCL driver actually installed.
 *  Some of the techniques used here were inspired by work done in the GLEW
 *  library (http://glew.sourceforge.net/) */

//  Run-time dynamic linking functionality based on concepts used in GLEW
// #ifdef __OPENCL_CL_H
// #error cl.h included before clew.h
// #endif

// #ifdef __OPENCL_CL_PLATFORM_H
// #error cl_platform.h included before clew.h
// #endif

//  Prevent cl.h inclusion
// #define __OPENCL_CL_H
//  Prevent cl_platform.h inclusion
// #define __CL_PLATFORM_H

/*******************************************************************************
* Copyright (c) 2008-2010 The Khronos Group Inc.
*
* Permission is hereby granted, free of charge, to any person obtaining a
* copy of this software and/or associated documentation files (the
* "Materials"), to deal in the Materials without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Materials, and to
* permit persons to whom the Materials are furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Materials.
*
* THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
* MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
******************************************************************************/
// #ifdef __APPLE__
/* Contains #defines for AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER below */
// #include <AvailabilityMacros.h>
// #endif

// #ifdef __cplusplus
// #endif

// #if defined(_WIN32)
// #else
// #define CL_API_ENTRY
// #define CL_API_CALL
// #define CL_CALLBACK
// #endif
	//disabled the APPLE thing, don't know why it is there, is just causes tons of warnings

// #ifdef __APPLE1__
// #else
// #define CL_EXTENSION_WEAK_LINK
// #define CL_API_SUFFIX__VERSION_1_0
// #define CL_EXT_SUFFIX__VERSION_1_0
// #define CL_API_SUFFIX__VERSION_1_1
// #define CL_EXT_SUFFIX__VERSION_1_1
// #define CL_EXT_SUFFIX__VERSION_1_0_DEPRECATED
// #endif

// #if (defined(_WIN32) && defined(_MSC_VER))

// #else

// #include <stdint.h>

/* scalar types  */

/* Macro names and corresponding values defined by OpenCL */
public static final int CL_CHAR_BIT = 8;
public static final int CL_SCHAR_MAX = 127;
public static final int CL_SCHAR_MIN = (-127 - 1);
public static final int CL_CHAR_MAX = CL_SCHAR_MAX;
public static final int CL_CHAR_MIN = CL_SCHAR_MIN;
public static final int CL_UCHAR_MAX = 255;
public static final int CL_SHRT_MAX = 32767;
public static final int CL_SHRT_MIN = (-32767 - 1);
public static final int CL_USHRT_MAX = 65535;
public static final int CL_INT_MAX = 2147483647;
public static final int CL_INT_MIN = (-2147483647 - 1);
public static final int CL_UINT_MAX = 0xffffffff;
public static native @MemberGetter long CL_LONG_MAX();
public static final long CL_LONG_MAX = CL_LONG_MAX();
public static native @MemberGetter long CL_LONG_MIN();
public static final long CL_LONG_MIN = CL_LONG_MIN();
public static native @MemberGetter @Cast("unsigned long") long CL_ULONG_MAX();
public static final long CL_ULONG_MAX = CL_ULONG_MAX();

public static final int CL_FLT_DIG = 6;
public static final int CL_FLT_MANT_DIG = 24;
public static final int CL_FLT_MAX_10_EXP = +38;
public static final int CL_FLT_MAX_EXP = +128;
public static final int CL_FLT_MIN_10_EXP = -37;
public static final int CL_FLT_MIN_EXP = -125;
public static final int CL_FLT_RADIX = 2;
public static final double CL_FLT_MAX = 0x1.fffffep127f;
public static final double CL_FLT_MIN = 0x1.0p-126f;
public static final double CL_FLT_EPSILON = 0x1.0p-23f;

public static final int CL_DBL_DIG = 15;
public static final int CL_DBL_MANT_DIG = 53;
public static final int CL_DBL_MAX_10_EXP = +308;
public static final int CL_DBL_MAX_EXP = +1024;
public static final int CL_DBL_MIN_10_EXP = -307;
public static final int CL_DBL_MIN_EXP = -1021;
public static final int CL_DBL_RADIX = 2;
public static final double CL_DBL_MAX = 0x1.fffffffffffffp1023;
public static final double CL_DBL_MIN = 0x1.0p-1022;
public static final double CL_DBL_EPSILON = 0x1.0p-52;

public static final double CL_M_E = 2.718281828459045090796;
public static final double CL_M_LOG2E = 1.442695040888963387005;
public static final double CL_M_LOG10E = 0.434294481903251816668;
public static final double CL_M_LN2 = 0.693147180559945286227;
public static final double CL_M_LN10 = 2.302585092994045901094;
public static final double CL_M_PI = 3.141592653589793115998;
public static final double CL_M_PI_2 = 1.570796326794896557999;
public static final double CL_M_PI_4 = 0.785398163397448278999;
public static final double CL_M_1_PI = 0.318309886183790691216;
public static final double CL_M_2_PI = 0.636619772367581382433;
public static final double CL_M_2_SQRTPI = 1.128379167095512558561;
public static final double CL_M_SQRT2 = 1.414213562373095145475;
public static final double CL_M_SQRT1_2 = 0.707106781186547572737;

public static final double CL_M_E_F = 2.71828174591064f;
public static final double CL_M_LOG2E_F = 1.44269502162933f;
public static final double CL_M_LOG10E_F = 0.43429449200630f;
public static final double CL_M_LN2_F = 0.69314718246460f;
public static final double CL_M_LN10_F = 2.30258512496948f;
public static final double CL_M_PI_F = 3.14159274101257f;
public static final double CL_M_PI_2_F = 1.57079637050629f;
public static final double CL_M_PI_4_F = 0.78539818525314f;
public static final double CL_M_1_PI_F = 0.31830987334251f;
public static final double CL_M_2_PI_F = 0.63661974668503f;
public static final double CL_M_2_SQRTPI_F = 1.12837922573090f;
public static final double CL_M_SQRT2_F = 1.41421353816986f;
public static final double CL_M_SQRT1_2_F = 0.70710676908493f;

// #if defined(__GNUC__)
// #else
public static final double CL_HUGE_VALF = ((float)1e50);
// #define CL_HUGE_VAL ((cl_double)1e500)

// #define CL_NAN nanf("")
// #endif
public static final double CL_MAXFLOAT = CL_FLT_MAX;
public static final double CL_INFINITY = CL_HUGE_VALF;

// #endif

// #include <stddef.h>

	/* Mirror types to GL types. Mirror types allow us to avoid deciding which headers to load based on whether we are using GL or GLES here. */

	/*
 * Vector types 
 *
 *  Note:   OpenCL requires that all types be naturally aligned. 
 *          This means that vector types must be naturally aligned.
 *          For example, a vector of four floats must be aligned to
 *          a 16 byte boundary (calculated as 4 * the natural 4-byte 
 *          alignment of the float).  The alignment qualifiers here
 *          will only function properly if your compiler supports them
 *          and if you don't actively work to defeat them.  For example,
 *          in order for a cl_float4 to be 16 byte aligned in a struct,
 *          the start of the struct must itself be 16-byte aligned. 
 *
 *          Maintaining proper alignment is the user's responsibility.
 */

// #ifdef _MSC_VER
// #if defined(_M_IX86)
// #if _M_IX86_FP >= 0
// #define __SSE__
// #endif
// #if _M_IX86_FP >= 1
// #define __SSE2__
// #endif
// #elif defined(_M_X64)
// #define __SSE__
// #define __SSE2__
// #endif
// #endif

/* Define basic vector types */
// #if defined(__VEC__)
// #endif

// #if defined(__SSE__)
// #endif

// #if defined(__SSE2__)
// #endif

// #if defined(__MMX__)
// #endif

// #if defined(__AVX__)
// #endif

/* Define alignment keys */
// #if defined(__GNUC__)
// #elif defined(_WIN32) && (_MSC_VER)
/* Alignment keys neutered on windows because MSVC can't swallow function arguments with alignment requirements     */
/* http://msdn.microsoft.com/en-us/library/373ak2y1%28VS.71%29.aspx                                                 */
/* #include <crtdefs.h>                                                                                             */
/* #define CL_ALIGNED(_x)          _CRT_ALIGN(_x)                                                                   */
// #define CL_ALIGNED(_x)
// #else
// #warning Need to implement some method to align data here
// #define CL_ALIGNED(_x)
// #endif

/* Indicate whether .xyzw, .s0123 and .hi.lo are supported */
// #if (defined(__GNUC__) && !defined(__STRICT_ANSI__)) || (defined(_MSC_VER) && !defined(__STDC__))
/* .xyzw and .s0123...{f|F} are supported */
public static final int CL_HAS_NAMED_VECTOR_FIELDS = 1;
/* .hi and .lo are supported */
public static final int CL_HAS_HI_LO_VECTOR_FIELDS = 1;

// #define CL_NAMED_STRUCT_SUPPORTED
// #endif

// #if defined(CL_NAMED_STRUCT_SUPPORTED) && defined(_MSC_VER)
// #endif

	/* Define cl_vector types */

	/* ---- cl_charn ---- */
	public static class cl_char2 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_char2() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_char2(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_char2(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_char2 position(long position) {
	        return (cl_char2)super.position(position);
	    }
	    @Override public cl_char2 getPointer(long i) {
	        return new cl_char2((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_char") byte s(int i); public native cl_char2 s(int i, byte setter);
		@MemberGetter public native @Cast("cl_char*") BytePointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_CHAR2__)
// #endif
	}

	public static class cl_char4 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_char4() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_char4(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_char4(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_char4 position(long position) {
	        return (cl_char4)super.position(position);
	    }
	    @Override public cl_char4 getPointer(long i) {
	        return new cl_char4((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_char") byte s(int i); public native cl_char4 s(int i, byte setter);
		@MemberGetter public native @Cast("cl_char*") BytePointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_CHAR2__)
// #endif
// #if defined(__CL_CHAR4__)
// #endif
	}

	/* cl_char3 is identical in size, alignment and behavior to cl_char4. See section 6.1.5. */

	public static class cl_char8 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_char8() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_char8(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_char8(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_char8 position(long position) {
	        return (cl_char8)super.position(position);
	    }
	    @Override public cl_char8 getPointer(long i) {
	        return new cl_char8((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_char") byte s(int i); public native cl_char8 s(int i, byte setter);
		@MemberGetter public native @Cast("cl_char*") BytePointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_CHAR2__)
// #endif
// #if defined(__CL_CHAR4__)
// #endif
// #if defined(__CL_CHAR8__)
// #endif
	}

	public static class cl_char16 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_char16() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_char16(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_char16(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_char16 position(long position) {
	        return (cl_char16)super.position(position);
	    }
	    @Override public cl_char16 getPointer(long i) {
	        return new cl_char16((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_char") byte s(int i); public native cl_char16 s(int i, byte setter);
		@MemberGetter public native @Cast("cl_char*") BytePointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_CHAR2__)
// #endif
// #if defined(__CL_CHAR4__)
// #endif
// #if defined(__CL_CHAR8__)
// #endif
// #if defined(__CL_CHAR16__)
// #endif
	}

	/* ---- cl_ucharn ---- */
	public static class cl_uchar2 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_uchar2() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_uchar2(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_uchar2(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_uchar2 position(long position) {
	        return (cl_uchar2)super.position(position);
	    }
	    @Override public cl_uchar2 getPointer(long i) {
	        return new cl_uchar2((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_uchar") byte s(int i); public native cl_uchar2 s(int i, byte setter);
		@MemberGetter public native @Cast("cl_uchar*") BytePointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__cl_uchar2__)
// #endif
	}

	public static class cl_uchar4 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_uchar4() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_uchar4(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_uchar4(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_uchar4 position(long position) {
	        return (cl_uchar4)super.position(position);
	    }
	    @Override public cl_uchar4 getPointer(long i) {
	        return new cl_uchar4((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_uchar") byte s(int i); public native cl_uchar4 s(int i, byte setter);
		@MemberGetter public native @Cast("cl_uchar*") BytePointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_UCHAR2__)
// #endif
// #if defined(__CL_UCHAR4__)
// #endif
	}

	/* cl_uchar3 is identical in size, alignment and behavior to cl_uchar4. See section 6.1.5. */

	public static class cl_uchar8 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_uchar8() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_uchar8(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_uchar8(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_uchar8 position(long position) {
	        return (cl_uchar8)super.position(position);
	    }
	    @Override public cl_uchar8 getPointer(long i) {
	        return new cl_uchar8((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_uchar") byte s(int i); public native cl_uchar8 s(int i, byte setter);
		@MemberGetter public native @Cast("cl_uchar*") BytePointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_UCHAR2__)
// #endif
// #if defined(__CL_UCHAR4__)
// #endif
// #if defined(__CL_UCHAR8__)
// #endif
	}

	public static class cl_uchar16 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_uchar16() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_uchar16(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_uchar16(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_uchar16 position(long position) {
	        return (cl_uchar16)super.position(position);
	    }
	    @Override public cl_uchar16 getPointer(long i) {
	        return new cl_uchar16((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_uchar") byte s(int i); public native cl_uchar16 s(int i, byte setter);
		@MemberGetter public native @Cast("cl_uchar*") BytePointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_UCHAR2__)
// #endif
// #if defined(__CL_UCHAR4__)
// #endif
// #if defined(__CL_UCHAR8__)
// #endif
// #if defined(__CL_UCHAR16__)
// #endif
	}

	/* ---- cl_shortn ---- */
	public static class cl_short2 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_short2() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_short2(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_short2(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_short2 position(long position) {
	        return (cl_short2)super.position(position);
	    }
	    @Override public cl_short2 getPointer(long i) {
	        return new cl_short2((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_short") short s(int i); public native cl_short2 s(int i, short setter);
		@MemberGetter public native @Cast("cl_short*") ShortPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_SHORT2__)
// #endif
	}

	public static class cl_short4 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_short4() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_short4(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_short4(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_short4 position(long position) {
	        return (cl_short4)super.position(position);
	    }
	    @Override public cl_short4 getPointer(long i) {
	        return new cl_short4((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_short") short s(int i); public native cl_short4 s(int i, short setter);
		@MemberGetter public native @Cast("cl_short*") ShortPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_SHORT2__)
// #endif
// #if defined(__CL_SHORT4__)
// #endif
	}

	/* cl_short3 is identical in size, alignment and behavior to cl_short4. See section 6.1.5. */

	public static class cl_short8 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_short8() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_short8(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_short8(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_short8 position(long position) {
	        return (cl_short8)super.position(position);
	    }
	    @Override public cl_short8 getPointer(long i) {
	        return new cl_short8((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_short") short s(int i); public native cl_short8 s(int i, short setter);
		@MemberGetter public native @Cast("cl_short*") ShortPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_SHORT2__)
// #endif
// #if defined(__CL_SHORT4__)
// #endif
// #if defined(__CL_SHORT8__)
// #endif
	}

	public static class cl_short16 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_short16() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_short16(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_short16(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_short16 position(long position) {
	        return (cl_short16)super.position(position);
	    }
	    @Override public cl_short16 getPointer(long i) {
	        return new cl_short16((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_short") short s(int i); public native cl_short16 s(int i, short setter);
		@MemberGetter public native @Cast("cl_short*") ShortPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_SHORT2__)
// #endif
// #if defined(__CL_SHORT4__)
// #endif
// #if defined(__CL_SHORT8__)
// #endif
// #if defined(__CL_SHORT16__)
// #endif
	}

	/* ---- cl_ushortn ---- */
	public static class cl_ushort2 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_ushort2() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_ushort2(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_ushort2(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_ushort2 position(long position) {
	        return (cl_ushort2)super.position(position);
	    }
	    @Override public cl_ushort2 getPointer(long i) {
	        return new cl_ushort2((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_ushort") short s(int i); public native cl_ushort2 s(int i, short setter);
		@MemberGetter public native @Cast("cl_ushort*") ShortPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_USHORT2__)
// #endif
	}

	public static class cl_ushort4 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_ushort4() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_ushort4(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_ushort4(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_ushort4 position(long position) {
	        return (cl_ushort4)super.position(position);
	    }
	    @Override public cl_ushort4 getPointer(long i) {
	        return new cl_ushort4((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_ushort") short s(int i); public native cl_ushort4 s(int i, short setter);
		@MemberGetter public native @Cast("cl_ushort*") ShortPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_USHORT2__)
// #endif
// #if defined(__CL_USHORT4__)
// #endif
	}

	/* cl_ushort3 is identical in size, alignment and behavior to cl_ushort4. See section 6.1.5. */

	public static class cl_ushort8 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_ushort8() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_ushort8(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_ushort8(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_ushort8 position(long position) {
	        return (cl_ushort8)super.position(position);
	    }
	    @Override public cl_ushort8 getPointer(long i) {
	        return new cl_ushort8((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_ushort") short s(int i); public native cl_ushort8 s(int i, short setter);
		@MemberGetter public native @Cast("cl_ushort*") ShortPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_USHORT2__)
// #endif
// #if defined(__CL_USHORT4__)
// #endif
// #if defined(__CL_USHORT8__)
// #endif
	}

	public static class cl_ushort16 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_ushort16() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_ushort16(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_ushort16(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_ushort16 position(long position) {
	        return (cl_ushort16)super.position(position);
	    }
	    @Override public cl_ushort16 getPointer(long i) {
	        return new cl_ushort16((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_ushort") short s(int i); public native cl_ushort16 s(int i, short setter);
		@MemberGetter public native @Cast("cl_ushort*") ShortPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_USHORT2__)
// #endif
// #if defined(__CL_USHORT4__)
// #endif
// #if defined(__CL_USHORT8__)
// #endif
// #if defined(__CL_USHORT16__)
// #endif
	}

	/* ---- cl_intn ---- */
	public static class cl_int2 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_int2() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_int2(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_int2(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_int2 position(long position) {
	        return (cl_int2)super.position(position);
	    }
	    @Override public cl_int2 getPointer(long i) {
	        return new cl_int2((Pointer)this).offsetAddress(i);
	    }
	
		public native int s(int i); public native cl_int2 s(int i, int setter);
		@MemberGetter public native IntPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_INT2__)
// #endif
	}

	public static class cl_int4 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_int4() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_int4(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_int4(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_int4 position(long position) {
	        return (cl_int4)super.position(position);
	    }
	    @Override public cl_int4 getPointer(long i) {
	        return new cl_int4((Pointer)this).offsetAddress(i);
	    }
	
		public native int s(int i); public native cl_int4 s(int i, int setter);
		@MemberGetter public native IntPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_INT2__)
// #endif
// #if defined(__CL_INT4__)
// #endif
	}

	/* cl_int3 is identical in size, alignment and behavior to cl_int4. See section 6.1.5. */

	public static class cl_int8 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_int8() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_int8(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_int8(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_int8 position(long position) {
	        return (cl_int8)super.position(position);
	    }
	    @Override public cl_int8 getPointer(long i) {
	        return new cl_int8((Pointer)this).offsetAddress(i);
	    }
	
		public native int s(int i); public native cl_int8 s(int i, int setter);
		@MemberGetter public native IntPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_INT2__)
// #endif
// #if defined(__CL_INT4__)
// #endif
// #if defined(__CL_INT8__)
// #endif
	}

	public static class cl_int16 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_int16() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_int16(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_int16(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_int16 position(long position) {
	        return (cl_int16)super.position(position);
	    }
	    @Override public cl_int16 getPointer(long i) {
	        return new cl_int16((Pointer)this).offsetAddress(i);
	    }
	
		public native int s(int i); public native cl_int16 s(int i, int setter);
		@MemberGetter public native IntPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_INT2__)
// #endif
// #if defined(__CL_INT4__)
// #endif
// #if defined(__CL_INT8__)
// #endif
// #if defined(__CL_INT16__)
// #endif
	}

	/* ---- cl_uintn ---- */
	public static class cl_uint2 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_uint2() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_uint2(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_uint2(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_uint2 position(long position) {
	        return (cl_uint2)super.position(position);
	    }
	    @Override public cl_uint2 getPointer(long i) {
	        return new cl_uint2((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("unsigned int") int s(int i); public native cl_uint2 s(int i, int setter);
		@MemberGetter public native @Cast("unsigned int*") IntPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_UINT2__)
// #endif
	}

	public static class cl_uint4 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_uint4() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_uint4(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_uint4(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_uint4 position(long position) {
	        return (cl_uint4)super.position(position);
	    }
	    @Override public cl_uint4 getPointer(long i) {
	        return new cl_uint4((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("unsigned int") int s(int i); public native cl_uint4 s(int i, int setter);
		@MemberGetter public native @Cast("unsigned int*") IntPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_UINT2__)
// #endif
// #if defined(__CL_UINT4__)
// #endif
	}

	/* cl_uint3 is identical in size, alignment and behavior to cl_uint4. See section 6.1.5. */

	public static class cl_uint8 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_uint8() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_uint8(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_uint8(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_uint8 position(long position) {
	        return (cl_uint8)super.position(position);
	    }
	    @Override public cl_uint8 getPointer(long i) {
	        return new cl_uint8((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("unsigned int") int s(int i); public native cl_uint8 s(int i, int setter);
		@MemberGetter public native @Cast("unsigned int*") IntPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_UINT2__)
// #endif
// #if defined(__CL_UINT4__)
// #endif
// #if defined(__CL_UINT8__)
// #endif
	}

	public static class cl_uint16 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_uint16() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_uint16(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_uint16(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_uint16 position(long position) {
	        return (cl_uint16)super.position(position);
	    }
	    @Override public cl_uint16 getPointer(long i) {
	        return new cl_uint16((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("unsigned int") int s(int i); public native cl_uint16 s(int i, int setter);
		@MemberGetter public native @Cast("unsigned int*") IntPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_UINT2__)
// #endif
// #if defined(__CL_UINT4__)
// #endif
// #if defined(__CL_UINT8__)
// #endif
// #if defined(__CL_UINT16__)
// #endif
	}

	/* ---- cl_longn ---- */

	/* cl_long3 is identical in size, alignment and behavior to cl_long4. See section 6.1.5. */

	/* ---- cl_ulongn ---- */
	public static class cl_ulong2 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_ulong2() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_ulong2(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_ulong2(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_ulong2 position(long position) {
	        return (cl_ulong2)super.position(position);
	    }
	    @Override public cl_ulong2 getPointer(long i) {
	        return new cl_ulong2((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("unsigned long") long s(int i); public native cl_ulong2 s(int i, long setter);
		@MemberGetter public native @Cast("unsigned long*") CLongPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_ULONG2__)
// #endif
	}

	public static class cl_ulong4 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_ulong4() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_ulong4(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_ulong4(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_ulong4 position(long position) {
	        return (cl_ulong4)super.position(position);
	    }
	    @Override public cl_ulong4 getPointer(long i) {
	        return new cl_ulong4((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("unsigned long") long s(int i); public native cl_ulong4 s(int i, long setter);
		@MemberGetter public native @Cast("unsigned long*") CLongPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_ULONG2__)
// #endif
// #if defined(__CL_ULONG4__)
// #endif
	}

	/* cl_ulong3 is identical in size, alignment and behavior to cl_ulong4. See section 6.1.5. */

	public static class cl_ulong8 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_ulong8() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_ulong8(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_ulong8(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_ulong8 position(long position) {
	        return (cl_ulong8)super.position(position);
	    }
	    @Override public cl_ulong8 getPointer(long i) {
	        return new cl_ulong8((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("unsigned long") long s(int i); public native cl_ulong8 s(int i, long setter);
		@MemberGetter public native @Cast("unsigned long*") CLongPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_ULONG2__)
// #endif
// #if defined(__CL_ULONG4__)
// #endif
// #if defined(__CL_ULONG8__)
// #endif
	}

	public static class cl_ulong16 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_ulong16() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_ulong16(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_ulong16(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_ulong16 position(long position) {
	        return (cl_ulong16)super.position(position);
	    }
	    @Override public cl_ulong16 getPointer(long i) {
	        return new cl_ulong16((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("unsigned long") long s(int i); public native cl_ulong16 s(int i, long setter);
		@MemberGetter public native @Cast("unsigned long*") CLongPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_ULONG2__)
// #endif
// #if defined(__CL_ULONG4__)
// #endif
// #if defined(__CL_ULONG8__)
// #endif
// #if defined(__CL_ULONG16__)
// #endif
	}

	/* --- cl_floatn ---- */

	public static class cl_float2 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_float2() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_float2(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_float2(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_float2 position(long position) {
	        return (cl_float2)super.position(position);
	    }
	    @Override public cl_float2 getPointer(long i) {
	        return new cl_float2((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_float") float s(int i); public native cl_float2 s(int i, float setter);
		@MemberGetter public native @Cast("cl_float*") FloatPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_FLOAT2__)
// #endif
	}

	public static class cl_float4 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_float4() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_float4(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_float4(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_float4 position(long position) {
	        return (cl_float4)super.position(position);
	    }
	    @Override public cl_float4 getPointer(long i) {
	        return new cl_float4((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_float") float s(int i); public native cl_float4 s(int i, float setter);
		@MemberGetter public native @Cast("cl_float*") FloatPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_FLOAT2__)
// #endif
// #if defined(__CL_FLOAT4__)
// #endif
	}

	/* cl_float3 is identical in size, alignment and behavior to cl_float4. See section 6.1.5. */

	public static class cl_float8 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_float8() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_float8(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_float8(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_float8 position(long position) {
	        return (cl_float8)super.position(position);
	    }
	    @Override public cl_float8 getPointer(long i) {
	        return new cl_float8((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_float") float s(int i); public native cl_float8 s(int i, float setter);
		@MemberGetter public native @Cast("cl_float*") FloatPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_FLOAT2__)
// #endif
// #if defined(__CL_FLOAT4__)
// #endif
// #if defined(__CL_FLOAT8__)
// #endif
	}

	public static class cl_float16 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_float16() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_float16(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_float16(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_float16 position(long position) {
	        return (cl_float16)super.position(position);
	    }
	    @Override public cl_float16 getPointer(long i) {
	        return new cl_float16((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_float") float s(int i); public native cl_float16 s(int i, float setter);
		@MemberGetter public native @Cast("cl_float*") FloatPointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_FLOAT2__)
// #endif
// #if defined(__CL_FLOAT4__)
// #endif
// #if defined(__CL_FLOAT8__)
// #endif
// #if defined(__CL_FLOAT16__)
// #endif
	}

	/* --- cl_doublen ---- */

	public static class cl_double2 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_double2() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_double2(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_double2(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_double2 position(long position) {
	        return (cl_double2)super.position(position);
	    }
	    @Override public cl_double2 getPointer(long i) {
	        return new cl_double2((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_double") double s(int i); public native cl_double2 s(int i, double setter);
		@MemberGetter public native @Cast("cl_double*") DoublePointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_DOUBLE2__)
// #endif
	}

	public static class cl_double4 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_double4() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_double4(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_double4(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_double4 position(long position) {
	        return (cl_double4)super.position(position);
	    }
	    @Override public cl_double4 getPointer(long i) {
	        return new cl_double4((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_double") double s(int i); public native cl_double4 s(int i, double setter);
		@MemberGetter public native @Cast("cl_double*") DoublePointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_DOUBLE2__)
// #endif
// #if defined(__CL_DOUBLE4__)
// #endif
	}

	/* cl_double3 is identical in size, alignment and behavior to cl_double4. See section 6.1.5. */

	public static class cl_double8 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_double8() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_double8(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_double8(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_double8 position(long position) {
	        return (cl_double8)super.position(position);
	    }
	    @Override public cl_double8 getPointer(long i) {
	        return new cl_double8((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_double") double s(int i); public native cl_double8 s(int i, double setter);
		@MemberGetter public native @Cast("cl_double*") DoublePointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_DOUBLE2__)
// #endif
// #if defined(__CL_DOUBLE4__)
// #endif
// #if defined(__CL_DOUBLE8__)
// #endif
	}

	public static class cl_double16 extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_double16() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_double16(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_double16(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_double16 position(long position) {
	        return (cl_double16)super.position(position);
	    }
	    @Override public cl_double16 getPointer(long i) {
	        return new cl_double16((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_double") double s(int i); public native cl_double16 s(int i, double setter);
		@MemberGetter public native @Cast("cl_double*") DoublePointer s();
// #if defined(CL_NAMED_STRUCT_SUPPORTED)
// #endif
// #if defined(__CL_DOUBLE2__)
// #endif
// #if defined(__CL_DOUBLE4__)
// #endif
// #if defined(__CL_DOUBLE8__)
// #endif
// #if defined(__CL_DOUBLE16__)
// #endif
	}

/* Macro to facilitate debugging 
 * Usage:
 *   Place CL_PROGRAM_STRING_DEBUG_INFO on the line before the first line of your source. 
 *   The first line ends with:   CL_PROGRAM_STRING_BEGIN \"
 *   Each line thereafter of OpenCL C source must end with: \n\
 *   The last line ends in ";
 *
 *   Example:
 *
 *   const char *my_program = CL_PROGRAM_STRING_BEGIN "\
 *   kernel void foo( int a, float * b )             \n\
 *   {                                               \n\
 *      // my comment                                \n\
 *      *b[ get_global_id(0)] = a;                   \n\
 *   }                                               \n\
 *   ";
 *
 * This should correctly set up the line, (column) and file information for your source 
 * string so you can do source level debugging.
 */
// #define __CL_STRINGIFY(_x) #_x
// #define _CL_STRINGIFY(_x) __CL_STRINGIFY(_x)
// #define CL_PROGRAM_STRING_DEBUG_INFO "#line " _CL_STRINGIFY(__LINE__) " \"" __FILE__ "\" \n\n"

	//  CL.h contents
	/******************************************************************************/

	@Opaque public static class _cl_platform_id extends Pointer {
	    /** Empty constructor. Calls {@code super((Pointer)null)}. */
	    public _cl_platform_id() { super((Pointer)null); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public _cl_platform_id(Pointer p) { super(p); }
	}
	@Opaque public static class _cl_device_id extends Pointer {
	    /** Empty constructor. Calls {@code super((Pointer)null)}. */
	    public _cl_device_id() { super((Pointer)null); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public _cl_device_id(Pointer p) { super(p); }
	}
	@Opaque public static class _cl_context extends Pointer {
	    /** Empty constructor. Calls {@code super((Pointer)null)}. */
	    public _cl_context() { super((Pointer)null); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public _cl_context(Pointer p) { super(p); }
	}
	@Opaque public static class _cl_command_queue extends Pointer {
	    /** Empty constructor. Calls {@code super((Pointer)null)}. */
	    public _cl_command_queue() { super((Pointer)null); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public _cl_command_queue(Pointer p) { super(p); }
	}
	@Opaque public static class _cl_mem extends Pointer {
	    /** Empty constructor. Calls {@code super((Pointer)null)}. */
	    public _cl_mem() { super((Pointer)null); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public _cl_mem(Pointer p) { super(p); }
	}
	@Opaque public static class _cl_program extends Pointer {
	    /** Empty constructor. Calls {@code super((Pointer)null)}. */
	    public _cl_program() { super((Pointer)null); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public _cl_program(Pointer p) { super(p); }
	}
	@Opaque public static class _cl_kernel extends Pointer {
	    /** Empty constructor. Calls {@code super((Pointer)null)}. */
	    public _cl_kernel() { super((Pointer)null); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public _cl_kernel(Pointer p) { super(p); }
	}
	@Opaque public static class _cl_event extends Pointer {
	    /** Empty constructor. Calls {@code super((Pointer)null)}. */
	    public _cl_event() { super((Pointer)null); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public _cl_event(Pointer p) { super(p); }
	}
	@Opaque public static class _cl_sampler extends Pointer {
	    /** Empty constructor. Calls {@code super((Pointer)null)}. */
	    public _cl_sampler() { super((Pointer)null); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public _cl_sampler(Pointer p) { super(p); }
	} /* WARNING!  Unlike cl_ types in cl_platform.h, cl_bool is not guaranteed to be the same size as the bool in kernels. */

	public static class cl_image_format extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_image_format() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_image_format(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_image_format(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_image_format position(long position) {
	        return (cl_image_format)super.position(position);
	    }
	    @Override public cl_image_format getPointer(long i) {
	        return new cl_image_format((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("cl_channel_order") int image_channel_order(); public native cl_image_format image_channel_order(int setter);
		public native @Cast("cl_channel_type") int image_channel_data_type(); public native cl_image_format image_channel_data_type(int setter);
	}

	public static class cl_buffer_region extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public cl_buffer_region() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public cl_buffer_region(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public cl_buffer_region(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public cl_buffer_region position(long position) {
	        return (cl_buffer_region)super.position(position);
	    }
	    @Override public cl_buffer_region getPointer(long i) {
	        return new cl_buffer_region((Pointer)this).offsetAddress(i);
	    }
	
		public native @Cast("size_t") long origin(); public native cl_buffer_region origin(long setter);
		public native @Cast("size_t") long size(); public native cl_buffer_region size(long setter);
	}

/******************************************************************************/

/* Error Codes */
public static final int CL_SUCCESS = 0;
public static final int CL_DEVICE_NOT_FOUND = -1;
public static final int CL_DEVICE_NOT_AVAILABLE = -2;
public static final int CL_COMPILER_NOT_AVAILABLE = -3;
public static final int CL_MEM_OBJECT_ALLOCATION_FAILURE = -4;
public static final int CL_OUT_OF_RESOURCES = -5;
public static final int CL_OUT_OF_HOST_MEMORY = -6;
public static final int CL_PROFILING_INFO_NOT_AVAILABLE = -7;
public static final int CL_MEM_COPY_OVERLAP = -8;
public static final int CL_IMAGE_FORMAT_MISMATCH = -9;
public static final int CL_IMAGE_FORMAT_NOT_SUPPORTED = -10;
public static final int CL_BUILD_PROGRAM_FAILURE = -11;
public static final int CL_MAP_FAILURE = -12;
public static final int CL_MISALIGNED_SUB_BUFFER_OFFSET = -13;
public static final int CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST = -14;

public static final int CL_INVALID_VALUE = -30;
public static final int CL_INVALID_DEVICE_TYPE = -31;
public static final int CL_INVALID_PLATFORM = -32;
public static final int CL_INVALID_DEVICE = -33;
public static final int CL_INVALID_CONTEXT = -34;
public static final int CL_INVALID_QUEUE_PROPERTIES = -35;
public static final int CL_INVALID_COMMAND_QUEUE = -36;
public static final int CL_INVALID_HOST_PTR = -37;
public static final int CL_INVALID_MEM_OBJECT = -38;
public static final int CL_INVALID_IMAGE_FORMAT_DESCRIPTOR = -39;
public static final int CL_INVALID_IMAGE_SIZE = -40;
public static final int CL_INVALID_SAMPLER = -41;
public static final int CL_INVALID_BINARY = -42;
public static final int CL_INVALID_BUILD_OPTIONS = -43;
public static final int CL_INVALID_PROGRAM = -44;
public static final int CL_INVALID_PROGRAM_EXECUTABLE = -45;
public static final int CL_INVALID_KERNEL_NAME = -46;
public static final int CL_INVALID_KERNEL_DEFINITION = -47;
public static final int CL_INVALID_KERNEL = -48;
public static final int CL_INVALID_ARG_INDEX = -49;
public static final int CL_INVALID_ARG_VALUE = -50;
public static final int CL_INVALID_ARG_SIZE = -51;
public static final int CL_INVALID_KERNEL_ARGS = -52;
public static final int CL_INVALID_WORK_DIMENSION = -53;
public static final int CL_INVALID_WORK_GROUP_SIZE = -54;
public static final int CL_INVALID_WORK_ITEM_SIZE = -55;
public static final int CL_INVALID_GLOBAL_OFFSET = -56;
public static final int CL_INVALID_EVENT_WAIT_LIST = -57;
public static final int CL_INVALID_EVENT = -58;
public static final int CL_INVALID_OPERATION = -59;
public static final int CL_INVALID_GL_OBJECT = -60;
public static final int CL_INVALID_BUFFER_SIZE = -61;
public static final int CL_INVALID_MIP_LEVEL = -62;
public static final int CL_INVALID_GLOBAL_WORK_SIZE = -63;
public static final int CL_INVALID_PROPERTY = -64;

/* OpenCL Version */
public static final int CL_VERSION_1_0 = 1;
public static final int CL_VERSION_1_1 = 1;

/* cl_bool */
public static final int CL_FALSE = 0;
public static final int CL_TRUE = 1;

/* cl_platform_info */
public static final int CL_PLATFORM_PROFILE = 0x0900;
public static final int CL_PLATFORM_VERSION = 0x0901;
public static final int CL_PLATFORM_NAME = 0x0902;
public static final int CL_PLATFORM_VENDOR = 0x0903;
public static final int CL_PLATFORM_EXTENSIONS = 0x0904;

/* cl_device_type - bitfield */
public static final int CL_DEVICE_TYPE_DEFAULT = (1 << 0);
public static final int CL_DEVICE_TYPE_CPU = (1 << 1);
public static final int CL_DEVICE_TYPE_GPU = (1 << 2);
public static final int CL_DEVICE_TYPE_ACCELERATOR = (1 << 3);
public static final int CL_DEVICE_TYPE_ALL = 0xFFFFFFFF;

/* cl_device_info */
public static final int CL_DEVICE_TYPE = 0x1000;
public static final int CL_DEVICE_VENDOR_ID = 0x1001;
public static final int CL_DEVICE_MAX_COMPUTE_UNITS = 0x1002;
public static final int CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS = 0x1003;
public static final int CL_DEVICE_MAX_WORK_GROUP_SIZE = 0x1004;
public static final int CL_DEVICE_MAX_WORK_ITEM_SIZES = 0x1005;
public static final int CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR = 0x1006;
public static final int CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT = 0x1007;
public static final int CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT = 0x1008;
public static final int CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG = 0x1009;
public static final int CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT = 0x100A;
public static final int CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE = 0x100B;
public static final int CL_DEVICE_MAX_CLOCK_FREQUENCY = 0x100C;
public static final int CL_DEVICE_ADDRESS_BITS = 0x100D;
public static final int CL_DEVICE_MAX_READ_IMAGE_ARGS = 0x100E;
public static final int CL_DEVICE_MAX_WRITE_IMAGE_ARGS = 0x100F;
public static final int CL_DEVICE_MAX_MEM_ALLOC_SIZE = 0x1010;
public static final int CL_DEVICE_IMAGE2D_MAX_WIDTH = 0x1011;
public static final int CL_DEVICE_IMAGE2D_MAX_HEIGHT = 0x1012;
public static final int CL_DEVICE_IMAGE3D_MAX_WIDTH = 0x1013;
public static final int CL_DEVICE_IMAGE3D_MAX_HEIGHT = 0x1014;
public static final int CL_DEVICE_IMAGE3D_MAX_DEPTH = 0x1015;
public static final int CL_DEVICE_IMAGE_SUPPORT = 0x1016;
public static final int CL_DEVICE_MAX_PARAMETER_SIZE = 0x1017;
public static final int CL_DEVICE_MAX_SAMPLERS = 0x1018;
public static final int CL_DEVICE_MEM_BASE_ADDR_ALIGN = 0x1019;
public static final int CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE = 0x101A;
public static final int CL_DEVICE_SINGLE_FP_CONFIG = 0x101B;
public static final int CL_DEVICE_GLOBAL_MEM_CACHE_TYPE = 0x101C;
public static final int CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE = 0x101D;
public static final int CL_DEVICE_GLOBAL_MEM_CACHE_SIZE = 0x101E;
public static final int CL_DEVICE_GLOBAL_MEM_SIZE = 0x101F;
public static final int CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE = 0x1020;
public static final int CL_DEVICE_MAX_CONSTANT_ARGS = 0x1021;
public static final int CL_DEVICE_LOCAL_MEM_TYPE = 0x1022;
public static final int CL_DEVICE_LOCAL_MEM_SIZE = 0x1023;
public static final int CL_DEVICE_ERROR_CORRECTION_SUPPORT = 0x1024;
public static final int CL_DEVICE_PROFILING_TIMER_RESOLUTION = 0x1025;
public static final int CL_DEVICE_ENDIAN_LITTLE = 0x1026;
public static final int CL_DEVICE_AVAILABLE = 0x1027;
public static final int CL_DEVICE_COMPILER_AVAILABLE = 0x1028;
public static final int CL_DEVICE_EXECUTION_CAPABILITIES = 0x1029;
public static final int CL_DEVICE_QUEUE_PROPERTIES = 0x102A;
public static final int CL_DEVICE_NAME = 0x102B;
public static final int CL_DEVICE_VENDOR = 0x102C;
public static final int CL_DRIVER_VERSION = 0x102D;
public static final int CL_DEVICE_PROFILE = 0x102E;
public static final int CL_DEVICE_VERSION = 0x102F;
public static final int CL_DEVICE_EXTENSIONS = 0x1030;
public static final int CL_DEVICE_PLATFORM = 0x1031;
/* 0x1032 reserved for CL_DEVICE_DOUBLE_FP_CONFIG */
/* 0x1033 reserved for CL_DEVICE_HALF_FP_CONFIG */
public static final int CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF = 0x1034;
public static final int CL_DEVICE_HOST_UNIFIED_MEMORY = 0x1035;
public static final int CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR = 0x1036;
public static final int CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT = 0x1037;
public static final int CL_DEVICE_NATIVE_VECTOR_WIDTH_INT = 0x1038;
public static final int CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG = 0x1039;
public static final int CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT = 0x103A;
public static final int CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE = 0x103B;
public static final int CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF = 0x103C;
public static final int CL_DEVICE_OPENCL_C_VERSION = 0x103D;

/* cl_device_fp_config - bitfield */
public static final int CL_FP_DENORM = (1 << 0);
public static final int CL_FP_INF_NAN = (1 << 1);
public static final int CL_FP_ROUND_TO_NEAREST = (1 << 2);
public static final int CL_FP_ROUND_TO_ZERO = (1 << 3);
public static final int CL_FP_ROUND_TO_INF = (1 << 4);
public static final int CL_FP_FMA = (1 << 5);
public static final int CL_FP_SOFT_FLOAT = (1 << 6);

/* cl_device_mem_cache_type */
public static final int CL_NONE = 0x0;
public static final int CL_READ_ONLY_CACHE = 0x1;
public static final int CL_READ_WRITE_CACHE = 0x2;

/* cl_device_local_mem_type */
public static final int CL_LOCAL = 0x1;
public static final int CL_GLOBAL = 0x2;

/* cl_device_exec_capabilities - bitfield */
public static final int CL_EXEC_KERNEL = (1 << 0);
public static final int CL_EXEC_NATIVE_KERNEL = (1 << 1);

/* cl_command_queue_properties - bitfield */
public static final int CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE = (1 << 0);
public static final int CL_QUEUE_PROFILING_ENABLE = (1 << 1);

/* cl_context_info  */
public static final int CL_CONTEXT_REFERENCE_COUNT = 0x1080;
public static final int CL_CONTEXT_DEVICES = 0x1081;
public static final int CL_CONTEXT_PROPERTIES = 0x1082;
public static final int CL_CONTEXT_NUM_DEVICES = 0x1083;

/* cl_context_info + cl_context_properties */
public static final int CL_CONTEXT_PLATFORM = 0x1084;

/* cl_command_queue_info */
public static final int CL_QUEUE_CONTEXT = 0x1090;
public static final int CL_QUEUE_DEVICE = 0x1091;
public static final int CL_QUEUE_REFERENCE_COUNT = 0x1092;
public static final int CL_QUEUE_PROPERTIES = 0x1093;

/* cl_mem_flags - bitfield */
public static final int CL_MEM_READ_WRITE = (1 << 0);
public static final int CL_MEM_WRITE_ONLY = (1 << 1);
public static final int CL_MEM_READ_ONLY = (1 << 2);
public static final int CL_MEM_USE_HOST_PTR = (1 << 3);
public static final int CL_MEM_ALLOC_HOST_PTR = (1 << 4);
public static final int CL_MEM_COPY_HOST_PTR = (1 << 5);

/* cl_channel_order */
public static final int CL_R = 0x10B0;
public static final int CL_A = 0x10B1;
public static final int CL_RG = 0x10B2;
public static final int CL_RA = 0x10B3;
public static final int CL_RGB = 0x10B4;
public static final int CL_RGBA = 0x10B5;
public static final int CL_BGRA = 0x10B6;
public static final int CL_ARGB = 0x10B7;
public static final int CL_INTENSITY = 0x10B8;
public static final int CL_LUMINANCE = 0x10B9;
public static final int CL_Rx = 0x10BA;
public static final int CL_RGx = 0x10BB;
public static final int CL_RGBx = 0x10BC;

/* cl_channel_type */
public static final int CL_SNORM_INT8 = 0x10D0;
public static final int CL_SNORM_INT16 = 0x10D1;
public static final int CL_UNORM_INT8 = 0x10D2;
public static final int CL_UNORM_INT16 = 0x10D3;
public static final int CL_UNORM_SHORT_565 = 0x10D4;
public static final int CL_UNORM_SHORT_555 = 0x10D5;
public static final int CL_UNORM_INT_101010 = 0x10D6;
public static final int CL_SIGNED_INT8 = 0x10D7;
public static final int CL_SIGNED_INT16 = 0x10D8;
public static final int CL_SIGNED_INT32 = 0x10D9;
public static final int CL_UNSIGNED_INT8 = 0x10DA;
public static final int CL_UNSIGNED_INT16 = 0x10DB;
public static final int CL_UNSIGNED_INT32 = 0x10DC;
public static final int CL_HALF_FLOAT = 0x10DD;
public static final int CL_FLOAT = 0x10DE;

/* cl_mem_object_type */
public static final int CL_MEM_OBJECT_BUFFER = 0x10F0;
public static final int CL_MEM_OBJECT_IMAGE2D = 0x10F1;
public static final int CL_MEM_OBJECT_IMAGE3D = 0x10F2;

/* cl_mem_info */
public static final int CL_MEM_TYPE = 0x1100;
public static final int CL_MEM_FLAGS = 0x1101;
public static final int CL_MEM_SIZE = 0x1102;
public static final int CL_MEM_HOST_PTR = 0x1103;
public static final int CL_MEM_MAP_COUNT = 0x1104;
public static final int CL_MEM_REFERENCE_COUNT = 0x1105;
public static final int CL_MEM_CONTEXT = 0x1106;
public static final int CL_MEM_ASSOCIATED_MEMOBJECT = 0x1107;
public static final int CL_MEM_OFFSET = 0x1108;

/* cl_image_info */
public static final int CL_IMAGE_FORMAT = 0x1110;
public static final int CL_IMAGE_ELEMENT_SIZE = 0x1111;
public static final int CL_IMAGE_ROW_PITCH = 0x1112;
public static final int CL_IMAGE_SLICE_PITCH = 0x1113;
public static final int CL_IMAGE_WIDTH = 0x1114;
public static final int CL_IMAGE_HEIGHT = 0x1115;
public static final int CL_IMAGE_DEPTH = 0x1116;

/* cl_addressing_mode */
public static final int CL_ADDRESS_NONE = 0x1130;
public static final int CL_ADDRESS_CLAMP_TO_EDGE = 0x1131;
public static final int CL_ADDRESS_CLAMP = 0x1132;
public static final int CL_ADDRESS_REPEAT = 0x1133;
public static final int CL_ADDRESS_MIRRORED_REPEAT = 0x1134;

/* cl_filter_mode */
public static final int CL_FILTER_NEAREST = 0x1140;
public static final int CL_FILTER_LINEAR = 0x1141;

/* cl_sampler_info */
public static final int CL_SAMPLER_REFERENCE_COUNT = 0x1150;
public static final int CL_SAMPLER_CONTEXT = 0x1151;
public static final int CL_SAMPLER_NORMALIZED_COORDS = 0x1152;
public static final int CL_SAMPLER_ADDRESSING_MODE = 0x1153;
public static final int CL_SAMPLER_FILTER_MODE = 0x1154;

/* cl_map_flags - bitfield */
public static final int CL_MAP_READ = (1 << 0);
public static final int CL_MAP_WRITE = (1 << 1);

/* cl_program_info */
public static final int CL_PROGRAM_REFERENCE_COUNT = 0x1160;
public static final int CL_PROGRAM_CONTEXT = 0x1161;
public static final int CL_PROGRAM_NUM_DEVICES = 0x1162;
public static final int CL_PROGRAM_DEVICES = 0x1163;
public static final int CL_PROGRAM_SOURCE = 0x1164;
public static final int CL_PROGRAM_BINARY_SIZES = 0x1165;
public static final int CL_PROGRAM_BINARIES = 0x1166;

/* cl_program_build_info */
public static final int CL_PROGRAM_BUILD_STATUS = 0x1181;
public static final int CL_PROGRAM_BUILD_OPTIONS = 0x1182;
public static final int CL_PROGRAM_BUILD_LOG = 0x1183;

/* cl_build_status */
public static final int CL_BUILD_SUCCESS = 0;
public static final int CL_BUILD_NONE = -1;
public static final int CL_BUILD_ERROR = -2;
public static final int CL_BUILD_IN_PROGRESS = -3;

/* cl_kernel_info */
public static final int CL_KERNEL_FUNCTION_NAME = 0x1190;
public static final int CL_KERNEL_NUM_ARGS = 0x1191;
public static final int CL_KERNEL_REFERENCE_COUNT = 0x1192;
public static final int CL_KERNEL_CONTEXT = 0x1193;
public static final int CL_KERNEL_PROGRAM = 0x1194;

/* cl_kernel_work_group_info */
public static final int CL_KERNEL_WORK_GROUP_SIZE = 0x11B0;
public static final int CL_KERNEL_COMPILE_WORK_GROUP_SIZE = 0x11B1;
public static final int CL_KERNEL_LOCAL_MEM_SIZE = 0x11B2;
public static final int CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = 0x11B3;
public static final int CL_KERNEL_PRIVATE_MEM_SIZE = 0x11B4;

/* cl_event_info  */
public static final int CL_EVENT_COMMAND_QUEUE = 0x11D0;
public static final int CL_EVENT_COMMAND_TYPE = 0x11D1;
public static final int CL_EVENT_REFERENCE_COUNT = 0x11D2;
public static final int CL_EVENT_COMMAND_EXECUTION_STATUS = 0x11D3;
public static final int CL_EVENT_CONTEXT = 0x11D4;

/* cl_command_type */
public static final int CL_COMMAND_NDRANGE_KERNEL = 0x11F0;
public static final int CL_COMMAND_TASK = 0x11F1;
public static final int CL_COMMAND_NATIVE_KERNEL = 0x11F2;
public static final int CL_COMMAND_READ_BUFFER = 0x11F3;
public static final int CL_COMMAND_WRITE_BUFFER = 0x11F4;
public static final int CL_COMMAND_COPY_BUFFER = 0x11F5;
public static final int CL_COMMAND_READ_IMAGE = 0x11F6;
public static final int CL_COMMAND_WRITE_IMAGE = 0x11F7;
public static final int CL_COMMAND_COPY_IMAGE = 0x11F8;
public static final int CL_COMMAND_COPY_IMAGE_TO_BUFFER = 0x11F9;
public static final int CL_COMMAND_COPY_BUFFER_TO_IMAGE = 0x11FA;
public static final int CL_COMMAND_MAP_BUFFER = 0x11FB;
public static final int CL_COMMAND_MAP_IMAGE = 0x11FC;
public static final int CL_COMMAND_UNMAP_MEM_OBJECT = 0x11FD;
public static final int CL_COMMAND_MARKER = 0x11FE;
public static final int CL_COMMAND_ACQUIRE_GL_OBJECTS = 0x11FF;
public static final int CL_COMMAND_RELEASE_GL_OBJECTS = 0x1200;
public static final int CL_COMMAND_READ_BUFFER_RECT = 0x1201;
public static final int CL_COMMAND_WRITE_BUFFER_RECT = 0x1202;
public static final int CL_COMMAND_COPY_BUFFER_RECT = 0x1203;
public static final int CL_COMMAND_USER = 0x1204;

/* command execution status */
public static final int CL_COMPLETE = 0x0;
public static final int CL_RUNNING = 0x1;
public static final int CL_SUBMITTED = 0x2;
public static final int CL_QUEUED = 0x3;

/* cl_buffer_create_type  */
public static final int CL_BUFFER_CREATE_TYPE_REGION = 0x1220;

/* cl_profiling_info  */
public static final int CL_PROFILING_COMMAND_QUEUED = 0x1280;
public static final int CL_PROFILING_COMMAND_SUBMIT = 0x1281;
public static final int CL_PROFILING_COMMAND_START = 0x1282;
public static final int CL_PROFILING_COMMAND_END = 0x1283;

	/********************************************************************************************************/

	/********************************************************************************************************/

	/*  Function signature typedef's */

	/* Platform API */

/**    Success error code */
public static final int CLEW_SUCCESS = 0;
/**    Error code for failing to open the dynamic library */
public static final int CLEW_ERROR_OPEN_FAILED = -1;
/**    Error code for failing to queue the closing of the dynamic library to atexit() */
public static final int CLEW_ERROR_ATEXIT_FAILED = -2;

	/** \brief Load OpenCL dynamic library and set function entry points */
	public static native int clewInit(@Cast("const char*") BytePointer arg0);
	public static native int clewInit(String arg0);

	/** \brief Exit clew and unload OpenCL dynamic library */
	public static native void clewExit();

	/** \brief Convert an OpenCL error code to its string equivalent */
	public static native @Cast("const char*") BytePointer clewErrorString(int error);

// #ifdef __cplusplus
// #endif

// #endif  //  CLEW_HPP_INCLUDED


// Parsed from clew_stubs.h

/*
 * Copyright (C) 2022 Andrey Krainyak
 *
 * Licensed either under the Apache License, Version 2.0, or (at your option)
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation (subject to the "Classpath" exception),
 * either version 2, or any later version (collectively, the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     http://www.gnu.org/licenses/
 *     http://www.gnu.org/software/classpath/license.html
 *
 * or as provided in the LICENSE.txt file that accompanied this code.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



// This #ifdef disables these stubs during native code compilation,
// as the stubs should be used for generation of the Java-side
// code only, and the native code should use the original definitions
// provided by clew's header.
// #ifdef XXXXXXXXXX

public static class BuildProgramCallback extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    BuildProgramCallback(Pointer p) { super(p); }
    protected BuildProgramCallback() { allocate(); }
    private native void allocate();
    public native void call(@ByVal cl_program arg0, Pointer arg1);
}
public static native int clBuildProgram(@ByVal cl_program arg0, @Cast("unsigned int") int arg1, @Const cl_device_id arg2, @Cast("const char*") BytePointer arg3, BuildProgramCallback arg4, Pointer arg5);
public static native int clBuildProgram(@ByVal cl_program arg0, @Cast("unsigned int") int arg1, @Const cl_device_id arg2, String arg3, BuildProgramCallback arg4, Pointer arg5);

public static class CreateContextCallback extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    CreateContextCallback(Pointer p) { super(p); }
    protected CreateContextCallback() { allocate(); }
    private native void allocate();
    public native void call(@Cast("const char*") BytePointer arg0, @Const Pointer arg1, @Cast("size_t") long arg2, Pointer arg3);
}
public static native @ByVal cl_context clCreateContext(@Cast("const cl_context_properties*") SizeTPointer arg0, @Cast("unsigned int") int arg1, @Const cl_device_id arg2, CreateContextCallback arg3, Pointer arg4, IntPointer arg5);
public static native @ByVal cl_context clCreateContext(@Cast("const cl_context_properties*") SizeTPointer arg0, @Cast("unsigned int") int arg1, @Const cl_device_id arg2, CreateContextCallback arg3, Pointer arg4, IntBuffer arg5);
public static native @ByVal cl_context clCreateContext(@Cast("const cl_context_properties*") SizeTPointer arg0, @Cast("unsigned int") int arg1, @Const cl_device_id arg2, CreateContextCallback arg3, Pointer arg4, int[] arg5);
public static native @ByVal cl_context clCreateContextFromType(@Cast("const cl_context_properties*") SizeTPointer arg0, @Cast("cl_device_type") long arg1, CreateContextCallback arg2, Pointer arg3, IntPointer arg4);
public static native @ByVal cl_context clCreateContextFromType(@Cast("const cl_context_properties*") SizeTPointer arg0, @Cast("cl_device_type") long arg1, CreateContextCallback arg2, Pointer arg3, IntBuffer arg4);
public static native @ByVal cl_context clCreateContextFromType(@Cast("const cl_context_properties*") SizeTPointer arg0, @Cast("cl_device_type") long arg1, CreateContextCallback arg2, Pointer arg3, int[] arg4);

public static class EnqueueNativeKernelCallback extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    EnqueueNativeKernelCallback(Pointer p) { super(p); }
    protected EnqueueNativeKernelCallback() { allocate(); }
    private native void allocate();
    public native void call(Pointer arg0);
}
public static native int clEnqueueNativeKernel(@ByVal cl_command_queue arg0, EnqueueNativeKernelCallback arg1, Pointer arg2, @Cast("size_t") long arg3, @Cast("unsigned int") int arg4, @Const cl_mem arg5, @Cast("const void**") PointerPointer arg6, @Cast("unsigned int") int arg7, @Const cl_event arg8, cl_event arg9);
public static native int clEnqueueNativeKernel(@ByVal cl_command_queue arg0, EnqueueNativeKernelCallback arg1, Pointer arg2, @Cast("size_t") long arg3, @Cast("unsigned int") int arg4, @Const cl_mem arg5, @Cast("const void**") @ByPtrPtr Pointer arg6, @Cast("unsigned int") int arg7, @Const cl_event arg8, cl_event arg9);

public static class EventCallback extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    EventCallback(Pointer p) { super(p); }
    protected EventCallback() { allocate(); }
    private native void allocate();
    public native void call(@ByVal cl_event arg0, int arg1, Pointer arg2);
}
public static native int clSetEventCallback(@ByVal cl_event arg0, int arg1, EventCallback arg2, Pointer arg3);

public static class MemObjectDestructorCallback extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    MemObjectDestructorCallback(Pointer p) { super(p); }
    protected MemObjectDestructorCallback() { allocate(); }
    private native void allocate();
    public native void call(@ByVal cl_mem arg0, Pointer arg1);
}
public static native int clSetMemObjectDestructorCallback(@ByVal cl_mem arg0, MemObjectDestructorCallback arg1, Pointer arg2);

/***************************************************************************
              Generated with bullet/gen-clew-stubs script
***************************************************************************/

public static native @ByVal cl_mem clCreateBuffer(@ByVal cl_context arg0, @Cast("cl_mem_flags") long arg1, @Cast("size_t") long arg2, Pointer arg3, IntPointer arg4);
public static native @ByVal cl_mem clCreateBuffer(@ByVal cl_context arg0, @Cast("cl_mem_flags") long arg1, @Cast("size_t") long arg2, Pointer arg3, IntBuffer arg4);
public static native @ByVal cl_mem clCreateBuffer(@ByVal cl_context arg0, @Cast("cl_mem_flags") long arg1, @Cast("size_t") long arg2, Pointer arg3, int[] arg4);
public static native @ByVal cl_command_queue clCreateCommandQueue(@ByVal cl_context arg0, @ByVal cl_device_id arg1, @Cast("cl_command_queue_properties") long arg2, IntPointer arg3);
public static native @ByVal cl_command_queue clCreateCommandQueue(@ByVal cl_context arg0, @ByVal cl_device_id arg1, @Cast("cl_command_queue_properties") long arg2, IntBuffer arg3);
public static native @ByVal cl_command_queue clCreateCommandQueue(@ByVal cl_context arg0, @ByVal cl_device_id arg1, @Cast("cl_command_queue_properties") long arg2, int[] arg3);
public static native @ByVal cl_mem clCreateImage2D(@ByVal cl_context arg0, @Cast("cl_mem_flags") long arg1, @Const cl_image_format arg2, @Cast("size_t") long arg3, @Cast("size_t") long arg4, @Cast("size_t") long arg5, Pointer arg6, IntPointer arg7);
public static native @ByVal cl_mem clCreateImage2D(@ByVal cl_context arg0, @Cast("cl_mem_flags") long arg1, @Const cl_image_format arg2, @Cast("size_t") long arg3, @Cast("size_t") long arg4, @Cast("size_t") long arg5, Pointer arg6, IntBuffer arg7);
public static native @ByVal cl_mem clCreateImage2D(@ByVal cl_context arg0, @Cast("cl_mem_flags") long arg1, @Const cl_image_format arg2, @Cast("size_t") long arg3, @Cast("size_t") long arg4, @Cast("size_t") long arg5, Pointer arg6, int[] arg7);
public static native @ByVal cl_mem clCreateImage3D(@ByVal cl_context arg0, @Cast("cl_mem_flags") long arg1, @Const cl_image_format arg2, @Cast("size_t") long arg3, @Cast("size_t") long arg4, @Cast("size_t") long arg5, @Cast("size_t") long arg6, @Cast("size_t") long arg7, Pointer arg8, IntPointer arg9);
public static native @ByVal cl_mem clCreateImage3D(@ByVal cl_context arg0, @Cast("cl_mem_flags") long arg1, @Const cl_image_format arg2, @Cast("size_t") long arg3, @Cast("size_t") long arg4, @Cast("size_t") long arg5, @Cast("size_t") long arg6, @Cast("size_t") long arg7, Pointer arg8, IntBuffer arg9);
public static native @ByVal cl_mem clCreateImage3D(@ByVal cl_context arg0, @Cast("cl_mem_flags") long arg1, @Const cl_image_format arg2, @Cast("size_t") long arg3, @Cast("size_t") long arg4, @Cast("size_t") long arg5, @Cast("size_t") long arg6, @Cast("size_t") long arg7, Pointer arg8, int[] arg9);
public static native @ByVal cl_kernel clCreateKernel(@ByVal cl_program arg0, @Cast("const char*") BytePointer arg1, IntPointer arg2);
public static native @ByVal cl_kernel clCreateKernel(@ByVal cl_program arg0, String arg1, IntBuffer arg2);
public static native @ByVal cl_kernel clCreateKernel(@ByVal cl_program arg0, @Cast("const char*") BytePointer arg1, int[] arg2);
public static native @ByVal cl_kernel clCreateKernel(@ByVal cl_program arg0, String arg1, IntPointer arg2);
public static native @ByVal cl_kernel clCreateKernel(@ByVal cl_program arg0, @Cast("const char*") BytePointer arg1, IntBuffer arg2);
public static native @ByVal cl_kernel clCreateKernel(@ByVal cl_program arg0, String arg1, int[] arg2);
public static native int clCreateKernelsInProgram(@ByVal cl_program arg0, @Cast("unsigned int") int arg1, cl_kernel arg2, @Cast("unsigned int*") IntPointer arg3);
public static native int clCreateKernelsInProgram(@ByVal cl_program arg0, @Cast("unsigned int") int arg1, cl_kernel arg2, @Cast("unsigned int*") IntBuffer arg3);
public static native int clCreateKernelsInProgram(@ByVal cl_program arg0, @Cast("unsigned int") int arg1, cl_kernel arg2, @Cast("unsigned int*") int[] arg3);
public static native @ByVal cl_program clCreateProgramWithBinary(@ByVal cl_context arg0, @Cast("unsigned int") int arg1, @Const cl_device_id arg2, @Cast("const size_t*") SizeTPointer arg3, @Cast("const unsigned char**") PointerPointer arg4, IntPointer arg5, IntPointer arg6);
public static native @ByVal cl_program clCreateProgramWithBinary(@ByVal cl_context arg0, @Cast("unsigned int") int arg1, @Const cl_device_id arg2, @Cast("const size_t*") SizeTPointer arg3, @Cast("const unsigned char**") @ByPtrPtr BytePointer arg4, IntPointer arg5, IntPointer arg6);
public static native @ByVal cl_program clCreateProgramWithBinary(@ByVal cl_context arg0, @Cast("unsigned int") int arg1, @Const cl_device_id arg2, @Cast("const size_t*") SizeTPointer arg3, @Cast("const unsigned char**") @ByPtrPtr ByteBuffer arg4, IntBuffer arg5, IntBuffer arg6);
public static native @ByVal cl_program clCreateProgramWithBinary(@ByVal cl_context arg0, @Cast("unsigned int") int arg1, @Const cl_device_id arg2, @Cast("const size_t*") SizeTPointer arg3, @Cast("const unsigned char**") @ByPtrPtr byte[] arg4, int[] arg5, int[] arg6);
public static native @ByVal cl_program clCreateProgramWithSource(@ByVal cl_context arg0, @Cast("unsigned int") int arg1, @Cast("const char**") PointerPointer arg2, @Cast("const size_t*") SizeTPointer arg3, IntPointer arg4);
public static native @ByVal cl_program clCreateProgramWithSource(@ByVal cl_context arg0, @Cast("unsigned int") int arg1, @Cast("const char**") @ByPtrPtr BytePointer arg2, @Cast("const size_t*") SizeTPointer arg3, IntPointer arg4);
public static native @ByVal cl_program clCreateProgramWithSource(@ByVal cl_context arg0, @Cast("unsigned int") int arg1, @Cast("const char**") @ByPtrPtr ByteBuffer arg2, @Cast("const size_t*") SizeTPointer arg3, IntBuffer arg4);
public static native @ByVal cl_program clCreateProgramWithSource(@ByVal cl_context arg0, @Cast("unsigned int") int arg1, @Cast("const char**") @ByPtrPtr byte[] arg2, @Cast("const size_t*") SizeTPointer arg3, int[] arg4);
public static native @ByVal cl_sampler clCreateSampler(@ByVal cl_context arg0, @Cast("bool") boolean arg1, @Cast("cl_addressing_mode") int arg2, @Cast("cl_filter_mode") int arg3, IntPointer arg4);
public static native @ByVal cl_sampler clCreateSampler(@ByVal cl_context arg0, @Cast("bool") boolean arg1, @Cast("cl_addressing_mode") int arg2, @Cast("cl_filter_mode") int arg3, IntBuffer arg4);
public static native @ByVal cl_sampler clCreateSampler(@ByVal cl_context arg0, @Cast("bool") boolean arg1, @Cast("cl_addressing_mode") int arg2, @Cast("cl_filter_mode") int arg3, int[] arg4);
public static native @ByVal cl_mem clCreateSubBuffer(@ByVal cl_mem arg0, @Cast("cl_mem_flags") long arg1, @Cast("cl_buffer_create_type") int arg2, @Const Pointer arg3, IntPointer arg4);
public static native @ByVal cl_mem clCreateSubBuffer(@ByVal cl_mem arg0, @Cast("cl_mem_flags") long arg1, @Cast("cl_buffer_create_type") int arg2, @Const Pointer arg3, IntBuffer arg4);
public static native @ByVal cl_mem clCreateSubBuffer(@ByVal cl_mem arg0, @Cast("cl_mem_flags") long arg1, @Cast("cl_buffer_create_type") int arg2, @Const Pointer arg3, int[] arg4);
public static native @ByVal cl_event clCreateUserEvent(@ByVal cl_context arg0, IntPointer arg1);
public static native @ByVal cl_event clCreateUserEvent(@ByVal cl_context arg0, IntBuffer arg1);
public static native @ByVal cl_event clCreateUserEvent(@ByVal cl_context arg0, int[] arg1);
public static native int clEnqueueBarrier(@ByVal cl_command_queue arg0);
public static native int clEnqueueCopyBuffer(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, @ByVal cl_mem arg2, @Cast("size_t") long arg3, @Cast("size_t") long arg4, @Cast("size_t") long arg5, @Cast("unsigned int") int arg6, @Const cl_event arg7, cl_event arg8);
public static native int clEnqueueCopyBufferRect(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, @ByVal cl_mem arg2, @Cast("const size_t*") SizeTPointer arg3, @Cast("const size_t*") SizeTPointer arg4, @Cast("const size_t*") SizeTPointer arg5, @Cast("size_t") long arg6, @Cast("size_t") long arg7, @Cast("size_t") long arg8, @Cast("size_t") long arg9, @Cast("unsigned int") int arg10, @Const cl_event arg11, cl_event arg12);
public static native int clEnqueueCopyBufferToImage(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, @ByVal cl_mem arg2, @Cast("size_t") long arg3, @Cast("const size_t*") SizeTPointer arg4, @Cast("const size_t*") SizeTPointer arg5, @Cast("unsigned int") int arg6, @Const cl_event arg7, cl_event arg8);
public static native int clEnqueueCopyImage(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, @ByVal cl_mem arg2, @Cast("const size_t*") SizeTPointer arg3, @Cast("const size_t*") SizeTPointer arg4, @Cast("const size_t*") SizeTPointer arg5, @Cast("unsigned int") int arg6, @Const cl_event arg7, cl_event arg8);
public static native int clEnqueueCopyImageToBuffer(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, @ByVal cl_mem arg2, @Cast("const size_t*") SizeTPointer arg3, @Cast("const size_t*") SizeTPointer arg4, @Cast("size_t") long arg5, @Cast("unsigned int") int arg6, @Const cl_event arg7, cl_event arg8);
public static native void clEnqueueMapBuffer(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, @Cast("bool") boolean arg2, @Cast("cl_map_flags") long arg3, @Cast("size_t") long arg4, @Cast("size_t") long arg5, @Cast("unsigned int") int arg6, @Const cl_event arg7, cl_event arg8, IntPointer arg9);
public static native void clEnqueueMapBuffer(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, @Cast("bool") boolean arg2, @Cast("cl_map_flags") long arg3, @Cast("size_t") long arg4, @Cast("size_t") long arg5, @Cast("unsigned int") int arg6, @Const cl_event arg7, cl_event arg8, IntBuffer arg9);
public static native void clEnqueueMapBuffer(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, @Cast("bool") boolean arg2, @Cast("cl_map_flags") long arg3, @Cast("size_t") long arg4, @Cast("size_t") long arg5, @Cast("unsigned int") int arg6, @Const cl_event arg7, cl_event arg8, int[] arg9);
public static native void clEnqueueMapImage(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, @Cast("bool") boolean arg2, @Cast("cl_map_flags") long arg3, @Cast("const size_t*") SizeTPointer arg4, @Cast("const size_t*") SizeTPointer arg5, @Cast("size_t*") SizeTPointer arg6, @Cast("size_t*") SizeTPointer arg7, @Cast("unsigned int") int arg8, @Const cl_event arg9, cl_event arg10, IntPointer arg11);
public static native void clEnqueueMapImage(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, @Cast("bool") boolean arg2, @Cast("cl_map_flags") long arg3, @Cast("const size_t*") SizeTPointer arg4, @Cast("const size_t*") SizeTPointer arg5, @Cast("size_t*") SizeTPointer arg6, @Cast("size_t*") SizeTPointer arg7, @Cast("unsigned int") int arg8, @Const cl_event arg9, cl_event arg10, IntBuffer arg11);
public static native void clEnqueueMapImage(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, @Cast("bool") boolean arg2, @Cast("cl_map_flags") long arg3, @Cast("const size_t*") SizeTPointer arg4, @Cast("const size_t*") SizeTPointer arg5, @Cast("size_t*") SizeTPointer arg6, @Cast("size_t*") SizeTPointer arg7, @Cast("unsigned int") int arg8, @Const cl_event arg9, cl_event arg10, int[] arg11);
public static native int clEnqueueMarker(@ByVal cl_command_queue arg0, cl_event arg1);
public static native int clEnqueueNDRangeKernel(@ByVal cl_command_queue arg0, @ByVal cl_kernel arg1, @Cast("unsigned int") int arg2, @Cast("const size_t*") SizeTPointer arg3, @Cast("const size_t*") SizeTPointer arg4, @Cast("const size_t*") SizeTPointer arg5, @Cast("unsigned int") int arg6, @Const cl_event arg7, cl_event arg8);
public static native int clEnqueueReadBuffer(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, @Cast("bool") boolean arg2, @Cast("size_t") long arg3, @Cast("size_t") long arg4, Pointer arg5, @Cast("unsigned int") int arg6, @Const cl_event arg7, cl_event arg8);
public static native int clEnqueueReadBufferRect(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, @Cast("bool") boolean arg2, @Cast("const size_t*") SizeTPointer arg3, @Cast("const size_t*") SizeTPointer arg4, @Cast("const size_t*") SizeTPointer arg5, @Cast("size_t") long arg6, @Cast("size_t") long arg7, @Cast("size_t") long arg8, @Cast("size_t") long arg9, Pointer arg10, @Cast("unsigned int") int arg11, @Const cl_event arg12, cl_event arg13);
public static native int clEnqueueReadImage(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, @Cast("bool") boolean arg2, @Cast("const size_t*") SizeTPointer arg3, @Cast("const size_t*") SizeTPointer arg4, @Cast("size_t") long arg5, @Cast("size_t") long arg6, Pointer arg7, @Cast("unsigned int") int arg8, @Const cl_event arg9, cl_event arg10);
public static native int clEnqueueTask(@ByVal cl_command_queue arg0, @ByVal cl_kernel arg1, @Cast("unsigned int") int arg2, @Const cl_event arg3, cl_event arg4);
public static native int clEnqueueUnmapMemObject(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, Pointer arg2, @Cast("unsigned int") int arg3, @Const cl_event arg4, cl_event arg5);
public static native int clEnqueueWaitForEvents(@ByVal cl_command_queue arg0, @Cast("unsigned int") int arg1, @Const cl_event arg2);
public static native int clEnqueueWriteBuffer(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, @Cast("bool") boolean arg2, @Cast("size_t") long arg3, @Cast("size_t") long arg4, @Const Pointer arg5, @Cast("unsigned int") int arg6, @Const cl_event arg7, cl_event arg8);
public static native int clEnqueueWriteBufferRect(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, @Cast("bool") boolean arg2, @Cast("const size_t*") SizeTPointer arg3, @Cast("const size_t*") SizeTPointer arg4, @Cast("const size_t*") SizeTPointer arg5, @Cast("size_t") long arg6, @Cast("size_t") long arg7, @Cast("size_t") long arg8, @Cast("size_t") long arg9, @Const Pointer arg10, @Cast("unsigned int") int arg11, @Const cl_event arg12, cl_event arg13);
public static native int clEnqueueWriteImage(@ByVal cl_command_queue arg0, @ByVal cl_mem arg1, @Cast("bool") boolean arg2, @Cast("const size_t*") SizeTPointer arg3, @Cast("const size_t*") SizeTPointer arg4, @Cast("size_t") long arg5, @Cast("size_t") long arg6, @Const Pointer arg7, @Cast("unsigned int") int arg8, @Const cl_event arg9, cl_event arg10);
public static native int clFinish(@ByVal cl_command_queue arg0);
public static native int clFlush(@ByVal cl_command_queue arg0);
public static native int clGetCommandQueueInfo(@ByVal cl_command_queue arg0, @Cast("cl_command_queue_info") int arg1, @Cast("size_t") long arg2, Pointer arg3, @Cast("size_t*") SizeTPointer arg4);
public static native int clGetContextInfo(@ByVal cl_context arg0, @Cast("cl_context_info") int arg1, @Cast("size_t") long arg2, Pointer arg3, @Cast("size_t*") SizeTPointer arg4);
public static native int clGetDeviceIDs(@ByVal cl_platform_id arg0, @Cast("cl_device_type") long arg1, @Cast("unsigned int") int arg2, cl_device_id arg3, @Cast("unsigned int*") IntPointer arg4);
public static native int clGetDeviceIDs(@ByVal cl_platform_id arg0, @Cast("cl_device_type") long arg1, @Cast("unsigned int") int arg2, cl_device_id arg3, @Cast("unsigned int*") IntBuffer arg4);
public static native int clGetDeviceIDs(@ByVal cl_platform_id arg0, @Cast("cl_device_type") long arg1, @Cast("unsigned int") int arg2, cl_device_id arg3, @Cast("unsigned int*") int[] arg4);
public static native int clGetDeviceInfo(@ByVal cl_device_id arg0, @Cast("cl_device_info") int arg1, @Cast("size_t") long arg2, Pointer arg3, @Cast("size_t*") SizeTPointer arg4);
public static native int clGetEventInfo(@ByVal cl_event arg0, @Cast("cl_event_info") int arg1, @Cast("size_t") long arg2, Pointer arg3, @Cast("size_t*") SizeTPointer arg4);
public static native int clGetEventProfilingInfo(@ByVal cl_event arg0, @Cast("cl_profiling_info") int arg1, @Cast("size_t") long arg2, Pointer arg3, @Cast("size_t*") SizeTPointer arg4);
public static native void clGetExtensionFunctionAddress(@Cast("const char*") BytePointer arg0);
public static native void clGetExtensionFunctionAddress(String arg0);
public static native int clGetImageInfo(@ByVal cl_mem arg0, @Cast("cl_image_info") int arg1, @Cast("size_t") long arg2, Pointer arg3, @Cast("size_t*") SizeTPointer arg4);
public static native int clGetKernelInfo(@ByVal cl_kernel arg0, @Cast("cl_kernel_info") int arg1, @Cast("size_t") long arg2, Pointer arg3, @Cast("size_t*") SizeTPointer arg4);
public static native int clGetKernelWorkGroupInfo(@ByVal cl_kernel arg0, @ByVal cl_device_id arg1, @Cast("cl_kernel_work_group_info") int arg2, @Cast("size_t") long arg3, Pointer arg4, @Cast("size_t*") SizeTPointer arg5);
public static native int clGetMemObjectInfo(@ByVal cl_mem arg0, @Cast("cl_mem_info") int arg1, @Cast("size_t") long arg2, Pointer arg3, @Cast("size_t*") SizeTPointer arg4);
public static native int clGetPlatformIDs(@Cast("unsigned int") int arg0, cl_platform_id arg1, @Cast("unsigned int*") IntPointer arg2);
public static native int clGetPlatformIDs(@Cast("unsigned int") int arg0, cl_platform_id arg1, @Cast("unsigned int*") IntBuffer arg2);
public static native int clGetPlatformIDs(@Cast("unsigned int") int arg0, cl_platform_id arg1, @Cast("unsigned int*") int[] arg2);
public static native int clGetPlatformInfo(@ByVal cl_platform_id arg0, @Cast("cl_platform_info") int arg1, @Cast("size_t") long arg2, Pointer arg3, @Cast("size_t*") SizeTPointer arg4);
public static native int clGetProgramBuildInfo(@ByVal cl_program arg0, @ByVal cl_device_id arg1, @Cast("cl_program_build_info") int arg2, @Cast("size_t") long arg3, Pointer arg4, @Cast("size_t*") SizeTPointer arg5);
public static native int clGetProgramInfo(@ByVal cl_program arg0, @Cast("cl_program_info") int arg1, @Cast("size_t") long arg2, Pointer arg3, @Cast("size_t*") SizeTPointer arg4);
public static native int clGetSamplerInfo(@ByVal cl_sampler arg0, @Cast("cl_sampler_info") int arg1, @Cast("size_t") long arg2, Pointer arg3, @Cast("size_t*") SizeTPointer arg4);
public static native int clGetSupportedImageFormats(@ByVal cl_context arg0, @Cast("cl_mem_flags") long arg1, @Cast("cl_mem_object_type") int arg2, @Cast("unsigned int") int arg3, cl_image_format arg4, @Cast("unsigned int*") IntPointer arg5);
public static native int clGetSupportedImageFormats(@ByVal cl_context arg0, @Cast("cl_mem_flags") long arg1, @Cast("cl_mem_object_type") int arg2, @Cast("unsigned int") int arg3, cl_image_format arg4, @Cast("unsigned int*") IntBuffer arg5);
public static native int clGetSupportedImageFormats(@ByVal cl_context arg0, @Cast("cl_mem_flags") long arg1, @Cast("cl_mem_object_type") int arg2, @Cast("unsigned int") int arg3, cl_image_format arg4, @Cast("unsigned int*") int[] arg5);
public static native int clReleaseCommandQueue(@ByVal cl_command_queue arg0);
public static native int clReleaseContext(@ByVal cl_context arg0);
public static native int clReleaseEvent(@ByVal cl_event arg0);
public static native int clReleaseKernel(@ByVal cl_kernel arg0);
public static native int clReleaseMemObject(@ByVal cl_mem arg0);
public static native int clReleaseProgram(@ByVal cl_program arg0);
public static native int clReleaseSampler(@ByVal cl_sampler arg0);
public static native int clRetainCommandQueue(@ByVal cl_command_queue arg0);
public static native int clRetainContext(@ByVal cl_context arg0);
public static native int clRetainEvent(@ByVal cl_event arg0);
public static native int clRetainKernel(@ByVal cl_kernel arg0);
public static native int clRetainMemObject(@ByVal cl_mem arg0);
public static native int clRetainProgram(@ByVal cl_program arg0);
public static native int clRetainSampler(@ByVal cl_sampler arg0);
// cl_int clSetCommandQueueProperty(cl_command_queue /* command_queue */, cl_command_queue_properties /* properties */, cl_bool /* enable */, cl_command_queue_properties * /* old_properties */);
public static native int clSetKernelArg(@ByVal cl_kernel arg0, @Cast("unsigned int") int arg1, @Cast("size_t") long arg2, @Const Pointer arg3);
public static native int clSetUserEventStatus(@ByVal cl_event arg0, int arg1);
public static native int clUnloadCompiler();
public static native int clWaitForEvents(@Cast("unsigned int") int arg0, @Const cl_event arg1);

// #endif // XXXXXXXXXX


}
