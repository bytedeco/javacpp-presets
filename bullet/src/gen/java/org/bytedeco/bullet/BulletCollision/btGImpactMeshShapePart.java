// Targeted by JavaCPP version 1.5.8-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.bullet.BulletCollision;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.bullet.LinearMath.*;
import static org.bytedeco.bullet.global.LinearMath.*;

import static org.bytedeco.bullet.global.BulletCollision.*;


/** This class manages a sub part of a mesh supplied by the btStridingMeshInterface interface.
/**
- Simply create this shape by passing the btStridingMeshInterface to the constructor btGImpactMeshShapePart, then you must call updateBound() after creating the mesh
- When making operations with this shape, you must call <b>lock</b> before accessing to the trimesh primitives, and then call <b>unlock</b>
- You can handle deformable meshes with this shape, by calling postUpdate() every time when changing the mesh vertices.
<p>
*/
@Properties(inherit = org.bytedeco.bullet.presets.BulletCollision.class)
public class btGImpactMeshShapePart extends btGImpactShapeInterface {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btGImpactMeshShapePart(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btGImpactMeshShapePart(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btGImpactMeshShapePart position(long position) {
        return (btGImpactMeshShapePart)super.position(position);
    }
    @Override public btGImpactMeshShapePart getPointer(long i) {
        return new btGImpactMeshShapePart((Pointer)this).offsetAddress(i);
    }

	/** Trimesh primitive manager
	/**
	Manages the info from btStridingMeshInterface object and controls the Lock/Unlock mechanism
	*/
	public btGImpactMeshShapePart() { super((Pointer)null); allocate(); }
	private native void allocate();

	public btGImpactMeshShapePart(btStridingMeshInterface meshInterface, int part) { super((Pointer)null); allocate(meshInterface, part); }
	private native void allocate(btStridingMeshInterface meshInterface, int part);

	/** if true, then its children must get transforms. */
	public native @Cast("bool") boolean childrenHasTransform();

	/** call when reading child shapes */
	public native void lockChildShapes();
	public native void unlockChildShapes();

	/** Gets the number of children */
	public native int getNumChildShapes();

	/** Gets the children */
	public native btCollisionShape getChildShape(int index);

	/** Gets the child */

	/** Gets the children transform */
	public native @ByVal btTransform getChildTransform(int index);

	/** Sets the children transform
	/**
	\post You must call updateBound() for update the box set.
	*/
	public native void setChildTransform(int index, @Const @ByRef btTransform transform);

	/** Obtains the primitive manager */

	public native void calculateLocalInertia(@Cast("btScalar") float mass, @ByRef btVector3 inertia);

	public native @Cast("const char*") BytePointer getName();

	public native @Cast("eGIMPACT_SHAPE_TYPE") int getGImpactShapeType();

	/** Determines if this shape has triangles */
	public native @Cast("bool") boolean needsRetrieveTriangles();

	/** Determines if this shape has tetrahedrons */
	public native @Cast("bool") boolean needsRetrieveTetrahedrons();

	public native void getBulletTetrahedron(int prim_index, @ByRef btTetrahedronShapeEx tetrahedron);

	public native int getVertexCount();

	public native void getVertex(int vertex_index, @ByRef btVector3 vertex);

	public native void setMargin(@Cast("btScalar") float margin);

	public native @Cast("btScalar") float getMargin();

	public native void setLocalScaling(@Const @ByRef btVector3 scaling);

	public native @Const @ByRef btVector3 getLocalScaling();

	public native int getPart();

	public native void processAllTriangles(btTriangleCallback callback, @Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax);
	public native void processAllTrianglesRay(btTriangleCallback callback, @Const @ByRef btVector3 rayFrom, @Const @ByRef btVector3 rayTo);
}
