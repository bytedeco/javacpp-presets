// Targeted by JavaCPP version 1.5.9-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.bullet.BulletSoftBody;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.bullet.LinearMath.*;
import static org.bytedeco.bullet.global.LinearMath.*;
import org.bytedeco.bullet.BulletCollision.*;
import static org.bytedeco.bullet.global.BulletCollision.*;
import org.bytedeco.bullet.BulletDynamics.*;
import static org.bytedeco.bullet.global.BulletDynamics.*;

import static org.bytedeco.bullet.global.BulletSoftBody.*;

// #endif

@NoOffset @Properties(inherit = org.bytedeco.bullet.presets.BulletSoftBody.class)
public class btSoftMultiBodyDynamicsWorld extends btMultiBodyDynamicsWorld {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btSoftMultiBodyDynamicsWorld(Pointer p) { super(p); }

	public btSoftMultiBodyDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btMultiBodyConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration, btSoftBodySolver softBodySolver/*=0*/) { super((Pointer)null); allocate(dispatcher, pairCache, constraintSolver, collisionConfiguration, softBodySolver); }
	private native void allocate(btDispatcher dispatcher, btBroadphaseInterface pairCache, btMultiBodyConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration, btSoftBodySolver softBodySolver/*=0*/);
	public btSoftMultiBodyDynamicsWorld(btDispatcher dispatcher, btBroadphaseInterface pairCache, btMultiBodyConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration) { super((Pointer)null); allocate(dispatcher, pairCache, constraintSolver, collisionConfiguration); }
	private native void allocate(btDispatcher dispatcher, btBroadphaseInterface pairCache, btMultiBodyConstraintSolver constraintSolver, btCollisionConfiguration collisionConfiguration);

	public native void debugDrawWorld();

	public native void addSoftBody(btSoftBody body, int collisionFilterGroup/*=btBroadphaseProxy::DefaultFilter*/, int collisionFilterMask/*=btBroadphaseProxy::AllFilter*/);
	public native void addSoftBody(btSoftBody body);

	public native void removeSoftBody(btSoftBody body);

	/**removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btDiscreteDynamicsWorld::removeCollisionObject */
	public native void removeCollisionObject(btCollisionObject collisionObject);

	public native int getDrawFlags();
	public native void setDrawFlags(int f);

	public native @ByRef btSoftBodyWorldInfo getWorldInfo();

	public native @Cast("btDynamicsWorldType") int getWorldType();

	public native @ByRef btSoftBodyArray getSoftBodyArray();

	public native void rayTest(@Const @ByRef btVector3 rayFromWorld, @Const @ByRef btVector3 rayToWorld, @ByRef RayResultCallback resultCallback);

	/** rayTestSingle performs a raycast call and calls the resultCallback. It is used internally by rayTest.
	 *  In a future implementation, we consider moving the ray test as a virtual method in btCollisionShape.
	 *  This allows more customization. */
	public static native void rayTestSingle(@Const @ByRef btTransform rayFromTrans, @Const @ByRef btTransform rayToTrans,
								  btCollisionObject collisionObject,
								  @Const btCollisionShape collisionShape,
								  @Const @ByRef btTransform colObjWorldTransform,
								  @ByRef RayResultCallback resultCallback);

	public native void serialize(btSerializer serializer);
}
