// Targeted by JavaCPP version 1.5.7: DO NOT EDIT THIS FILE

package org.bytedeco.bullet;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.bullet.LinearMath.*;

public class BulletCollision extends org.bytedeco.bullet.presets.BulletCollision {
    static { Loader.load(); }

// Parsed from BulletCollision/BroadphaseCollision/btBroadphaseProxy.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_BROADPHASE_PROXY_H
// #define BT_BROADPHASE_PROXY_H

// #include "LinearMath/btScalar.h"  //for SIMD_FORCE_INLINE
// #include "LinearMath/btVector3.h"
// #include "LinearMath/btAlignedAllocator.h"

/** btDispatcher uses these types
 *  IMPORTANT NOTE:The types are ordered polyhedral, implicit convex and concave
 *  to facilitate type checking
 *  CUSTOM_POLYHEDRAL_SHAPE_TYPE,CUSTOM_CONVEX_SHAPE_TYPE and CUSTOM_CONCAVE_SHAPE_TYPE can be used to extend Bullet without modifying source code */
/** enum BroadphaseNativeTypes */
public static final int
	// polyhedral convex shapes
	BOX_SHAPE_PROXYTYPE = 0,
	TRIANGLE_SHAPE_PROXYTYPE = 1,
	TETRAHEDRAL_SHAPE_PROXYTYPE = 2,
	CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE = 3,
	CONVEX_HULL_SHAPE_PROXYTYPE = 4,
	CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE = 5,
	CUSTOM_POLYHEDRAL_SHAPE_TYPE = 6,
	//implicit convex shapes
	IMPLICIT_CONVEX_SHAPES_START_HERE = 7,
	SPHERE_SHAPE_PROXYTYPE = 8,
	MULTI_SPHERE_SHAPE_PROXYTYPE = 9,
	CAPSULE_SHAPE_PROXYTYPE = 10,
	CONE_SHAPE_PROXYTYPE = 11,
	CONVEX_SHAPE_PROXYTYPE = 12,
	CYLINDER_SHAPE_PROXYTYPE = 13,
	UNIFORM_SCALING_SHAPE_PROXYTYPE = 14,
	MINKOWSKI_SUM_SHAPE_PROXYTYPE = 15,
	MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE = 16,
	BOX_2D_SHAPE_PROXYTYPE = 17,
	CONVEX_2D_SHAPE_PROXYTYPE = 18,
	CUSTOM_CONVEX_SHAPE_TYPE = 19,
	//concave shapes
	CONCAVE_SHAPES_START_HERE = 20,
	//keep all the convex shapetype below here, for the check IsConvexShape in broadphase proxy!
	TRIANGLE_MESH_SHAPE_PROXYTYPE = 21,
	SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE = 22,
	/**used for demo integration FAST/Swift collision library and Bullet */
	FAST_CONCAVE_MESH_PROXYTYPE = 23,
	//terrain
	TERRAIN_SHAPE_PROXYTYPE = 24,
	/**Used for GIMPACT Trimesh integration */
	GIMPACT_SHAPE_PROXYTYPE = 25,
	/**Multimaterial mesh */
	MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE = 26,

	EMPTY_SHAPE_PROXYTYPE = 27,
	STATIC_PLANE_PROXYTYPE = 28,
	CUSTOM_CONCAVE_SHAPE_TYPE = 29,
	SDF_SHAPE_PROXYTYPE = CUSTOM_CONCAVE_SHAPE_TYPE,
	CONCAVE_SHAPES_END_HERE = CUSTOM_CONCAVE_SHAPE_TYPE + 1,

	COMPOUND_SHAPE_PROXYTYPE = CUSTOM_CONCAVE_SHAPE_TYPE + 2,

	SOFTBODY_SHAPE_PROXYTYPE = CUSTOM_CONCAVE_SHAPE_TYPE + 3,
	HFFLUID_SHAPE_PROXYTYPE = CUSTOM_CONCAVE_SHAPE_TYPE + 4,
	HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE = CUSTOM_CONCAVE_SHAPE_TYPE + 5,
	INVALID_SHAPE_PROXYTYPE = CUSTOM_CONCAVE_SHAPE_TYPE + 6,

	MAX_BROADPHASE_COLLISION_TYPES = CUSTOM_CONCAVE_SHAPE_TYPE + 7;

/**The btBroadphaseProxy is the main class that can be used with the Bullet broadphases.
 * It stores collision shape type information, collision filter information and a client object, typically a btCollisionObject or btRigidBody. */
@NoOffset public static class btBroadphaseProxy extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btBroadphaseProxy(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btBroadphaseProxy(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btBroadphaseProxy position(long position) {
        return (btBroadphaseProxy)super.position(position);
    }
    @Override public btBroadphaseProxy getPointer(long i) {
        return new btBroadphaseProxy((Pointer)this).offsetAddress(i);
    }


	/**optional filtering to cull potential collisions */
	/** enum btBroadphaseProxy::CollisionFilterGroups */
	public static final int
		DefaultFilter = 1,
		StaticFilter = 2,
		KinematicFilter = 4,
		DebrisFilter = 8,
		SensorTrigger = 16,
		CharacterFilter = 32,
		AllFilter = -1;  //all bits sets: DefaultFilter | StaticFilter | KinematicFilter | DebrisFilter | SensorTrigger

	//Usually the client btCollisionObject or Rigidbody class
	public native Pointer m_clientObject(); public native btBroadphaseProxy m_clientObject(Pointer setter);
	public native int m_collisionFilterGroup(); public native btBroadphaseProxy m_collisionFilterGroup(int setter);
	public native int m_collisionFilterMask(); public native btBroadphaseProxy m_collisionFilterMask(int setter);

	public native int m_uniqueId(); public native btBroadphaseProxy m_uniqueId(int setter);  //m_uniqueId is introduced for paircache. could get rid of this, by calculating the address offset etc.

	public native @ByRef btVector3 m_aabbMin(); public native btBroadphaseProxy m_aabbMin(btVector3 setter);
	public native @ByRef btVector3 m_aabbMax(); public native btBroadphaseProxy m_aabbMax(btVector3 setter);

	public native int getUid();

	//used for memory pools
	public btBroadphaseProxy() { super((Pointer)null); allocate(); }
	private native void allocate();

	public btBroadphaseProxy(@Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax, Pointer userPtr, int collisionFilterGroup, int collisionFilterMask) { super((Pointer)null); allocate(aabbMin, aabbMax, userPtr, collisionFilterGroup, collisionFilterMask); }
	private native void allocate(@Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax, Pointer userPtr, int collisionFilterGroup, int collisionFilterMask);

	public static native @Cast("bool") boolean isPolyhedral(int proxyType);

	public static native @Cast("bool") boolean isConvex(int proxyType);

	public static native @Cast("bool") boolean isNonMoving(int proxyType);

	public static native @Cast("bool") boolean isConcave(int proxyType);
	public static native @Cast("bool") boolean isCompound(int proxyType);

	public static native @Cast("bool") boolean isSoftBody(int proxyType);

	public static native @Cast("bool") boolean isInfinite(int proxyType);

	public static native @Cast("bool") boolean isConvex2d(int proxyType);
}

@Opaque public static class btCollisionAlgorithm extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public btCollisionAlgorithm() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCollisionAlgorithm(Pointer p) { super(p); }
}

/**The btBroadphasePair class contains a pair of aabb-overlapping objects.
 * A btDispatcher can search a btCollisionAlgorithm that performs exact/narrowphase collision detection on the actual collision shapes. */
@NoOffset public static class btBroadphasePair extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btBroadphasePair(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btBroadphasePair(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btBroadphasePair position(long position) {
        return (btBroadphasePair)super.position(position);
    }
    @Override public btBroadphasePair getPointer(long i) {
        return new btBroadphasePair((Pointer)this).offsetAddress(i);
    }

	public btBroadphasePair() { super((Pointer)null); allocate(); }
	private native void allocate();

	public btBroadphasePair(@ByRef btBroadphaseProxy proxy0, @ByRef btBroadphaseProxy proxy1) { super((Pointer)null); allocate(proxy0, proxy1); }
	private native void allocate(@ByRef btBroadphaseProxy proxy0, @ByRef btBroadphaseProxy proxy1);

	public native btBroadphaseProxy m_pProxy0(); public native btBroadphasePair m_pProxy0(btBroadphaseProxy setter);
	public native btBroadphaseProxy m_pProxy1(); public native btBroadphasePair m_pProxy1(btBroadphaseProxy setter);

	public native btCollisionAlgorithm m_algorithm(); public native btBroadphasePair m_algorithm(btCollisionAlgorithm setter);
		public native Pointer m_internalInfo1(); public native btBroadphasePair m_internalInfo1(Pointer setter);
		public native int m_internalTmpValue(); public native btBroadphasePair m_internalTmpValue(int setter);  //don't use this data, it will be removed in future version.
}

/*
//comparison for set operation, see Solid DT_Encounter
SIMD_FORCE_INLINE bool operator<(const btBroadphasePair& a, const btBroadphasePair& b) 
{ 
    return a.m_pProxy0 < b.m_pProxy0 || 
        (a.m_pProxy0 == b.m_pProxy0 && a.m_pProxy1 < b.m_pProxy1); 
}
*/

public static class btBroadphasePairSortPredicate extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btBroadphasePairSortPredicate() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btBroadphasePairSortPredicate(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btBroadphasePairSortPredicate(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btBroadphasePairSortPredicate position(long position) {
        return (btBroadphasePairSortPredicate)super.position(position);
    }
    @Override public btBroadphasePairSortPredicate getPointer(long i) {
        return new btBroadphasePairSortPredicate((Pointer)this).offsetAddress(i);
    }

	public native @Cast("bool") @Name("operator ()") boolean apply(@Const @ByRef btBroadphasePair a, @Const @ByRef btBroadphasePair b);
}

public static native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef btBroadphasePair a, @Const @ByRef btBroadphasePair b);

// #endif  //BT_BROADPHASE_PROXY_H


// Parsed from BulletCollision/BroadphaseCollision/btDispatcher.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_DISPATCHER_H
// #define BT_DISPATCHER_H
// #include "LinearMath/btScalar.h"
@Opaque public static class btRigidBody extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public btRigidBody() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btRigidBody(Pointer p) { super(p); }
}
@Opaque public static class btCollisionObjectWrapper extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public btCollisionObjectWrapper() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCollisionObjectWrapper(Pointer p) { super(p); }
}

@Opaque public static class btPersistentManifold extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public btPersistentManifold() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btPersistentManifold(Pointer p) { super(p); }
}
@Opaque public static class btPoolAllocator extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public btPoolAllocator() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btPoolAllocator(Pointer p) { super(p); }
}

@NoOffset public static class btDispatcherInfo extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btDispatcherInfo(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btDispatcherInfo(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btDispatcherInfo position(long position) {
        return (btDispatcherInfo)super.position(position);
    }
    @Override public btDispatcherInfo getPointer(long i) {
        return new btDispatcherInfo((Pointer)this).offsetAddress(i);
    }

	/** enum btDispatcherInfo::DispatchFunc */
	public static final int
		DISPATCH_DISCRETE = 1,
		DISPATCH_CONTINUOUS = 2;
	public btDispatcherInfo() { super((Pointer)null); allocate(); }
	private native void allocate();
	public native @Cast("btScalar") float m_timeStep(); public native btDispatcherInfo m_timeStep(float setter);
	public native int m_stepCount(); public native btDispatcherInfo m_stepCount(int setter);
	public native int m_dispatchFunc(); public native btDispatcherInfo m_dispatchFunc(int setter);
	public native @Cast("btScalar") float m_timeOfImpact(); public native btDispatcherInfo m_timeOfImpact(float setter);
	public native @Cast("bool") boolean m_useContinuous(); public native btDispatcherInfo m_useContinuous(boolean setter);
	public native btIDebugDraw m_debugDraw(); public native btDispatcherInfo m_debugDraw(btIDebugDraw setter);
	public native @Cast("bool") boolean m_enableSatConvex(); public native btDispatcherInfo m_enableSatConvex(boolean setter);
	public native @Cast("bool") boolean m_enableSPU(); public native btDispatcherInfo m_enableSPU(boolean setter);
	public native @Cast("bool") boolean m_useEpa(); public native btDispatcherInfo m_useEpa(boolean setter);
	public native @Cast("btScalar") float m_allowedCcdPenetration(); public native btDispatcherInfo m_allowedCcdPenetration(float setter);
	public native @Cast("bool") boolean m_useConvexConservativeDistanceUtil(); public native btDispatcherInfo m_useConvexConservativeDistanceUtil(boolean setter);
	public native @Cast("btScalar") float m_convexConservativeDistanceThreshold(); public native btDispatcherInfo m_convexConservativeDistanceThreshold(float setter);
	public native @Cast("bool") boolean m_deterministicOverlappingPairs(); public native btDispatcherInfo m_deterministicOverlappingPairs(boolean setter);
}

/** enum ebtDispatcherQueryType */
public static final int
	BT_CONTACT_POINT_ALGORITHMS = 1,
	BT_CLOSEST_POINT_ALGORITHMS = 2;

/**The btDispatcher interface class can be used in combination with broadphase to dispatch calculations for overlapping pairs.
 * For example for pairwise collision detection, calculating contact points stored in btPersistentManifold or user callbacks (game logic). */
public static class btDispatcher extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btDispatcher(Pointer p) { super(p); }


	public native btCollisionAlgorithm findAlgorithm(@Const btCollisionObjectWrapper body0Wrap, @Const btCollisionObjectWrapper body1Wrap, btPersistentManifold sharedManifold, @Cast("ebtDispatcherQueryType") int queryType);

	public native btPersistentManifold getNewManifold(@Const btCollisionObject b0, @Const btCollisionObject b1);

	public native void releaseManifold(btPersistentManifold manifold);

	public native void clearManifold(btPersistentManifold manifold);

	public native @Cast("bool") boolean needsCollision(@Const btCollisionObject body0, @Const btCollisionObject body1);

	public native @Cast("bool") boolean needsResponse(@Const btCollisionObject body0, @Const btCollisionObject body1);

	public native void dispatchAllCollisionPairs(btOverlappingPairCache pairCache, @Const @ByRef btDispatcherInfo dispatchInfo, btDispatcher dispatcher);

	public native int getNumManifolds();

	public native btPersistentManifold getManifoldByIndexInternal(int index);

	public native @Cast("btPersistentManifold**") PointerPointer getInternalManifoldPointer();

	public native btPoolAllocator getInternalManifoldPool();

	public native Pointer allocateCollisionAlgorithm(int size);

	public native void freeCollisionAlgorithm(Pointer ptr);
}

// #endif  //BT_DISPATCHER_H


// Parsed from BulletCollision/BroadphaseCollision/btOverlappingPairCallback.h


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef OVERLAPPING_PAIR_CALLBACK_H
// #define OVERLAPPING_PAIR_CALLBACK_H

/**The btOverlappingPairCallback class is an additional optional broadphase user callback for adding/removing overlapping pairs, similar interface to btOverlappingPairCache. */
public static class btOverlappingPairCallback extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btOverlappingPairCallback(Pointer p) { super(p); }


	public native btBroadphasePair addOverlappingPair(btBroadphaseProxy proxy0, btBroadphaseProxy proxy1);

	public native Pointer removeOverlappingPair(btBroadphaseProxy proxy0, btBroadphaseProxy proxy1, btDispatcher dispatcher);

	public native void removeOverlappingPairsContainingProxy(btBroadphaseProxy proxy0, btDispatcher dispatcher);
}

// #endif  //OVERLAPPING_PAIR_CALLBACK_H


// Parsed from BulletCollision/BroadphaseCollision/btOverlappingPairCache.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_OVERLAPPING_PAIR_CACHE_H
// #define BT_OVERLAPPING_PAIR_CACHE_H

// #include "btBroadphaseInterface.h"
// #include "btBroadphaseProxy.h"
// #include "btOverlappingPairCallback.h"

// #include "LinearMath/btAlignedObjectArray.h"

public static class btOverlapCallback extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btOverlapCallback(Pointer p) { super(p); }

	//return true for deletion of the pair
	public native @Cast("bool") boolean processOverlap(@ByRef btBroadphasePair pair);
}

public static class btOverlapFilterCallback extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btOverlapFilterCallback(Pointer p) { super(p); }

	// return true when pairs need collision
	public native @Cast("bool") boolean needBroadphaseCollision(btBroadphaseProxy proxy0, btBroadphaseProxy proxy1);
}

@MemberGetter public static native int BT_NULL_PAIR();

/**The btOverlappingPairCache provides an interface for overlapping pair management (add, remove, storage), used by the btBroadphaseInterface broadphases.
 * The btHashedOverlappingPairCache and btSortedOverlappingPairCache classes are two implementations. */
public static class btOverlappingPairCache extends btOverlappingPairCallback {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btOverlappingPairCache(Pointer p) { super(p); }
  // this is needed so we can get to the derived class destructor

	public native btBroadphasePair getOverlappingPairArrayPtr();

	

	public native void cleanOverlappingPair(@ByRef btBroadphasePair pair, btDispatcher dispatcher);

	public native int getNumOverlappingPairs();
	public native @Cast("bool") boolean needsBroadphaseCollision(btBroadphaseProxy proxy0, btBroadphaseProxy proxy1);
	public native btOverlapFilterCallback getOverlapFilterCallback();
	public native void cleanProxyFromPairs(btBroadphaseProxy proxy, btDispatcher dispatcher);

	public native void setOverlapFilterCallback(btOverlapFilterCallback callback);

	public native void processAllOverlappingPairs(btOverlapCallback arg0, btDispatcher dispatcher);

	public native void processAllOverlappingPairs(btOverlapCallback callback, btDispatcher dispatcher, @Const @ByRef btDispatcherInfo arg2);
	public native btBroadphasePair findPair(btBroadphaseProxy proxy0, btBroadphaseProxy proxy1);

	public native @Cast("bool") boolean hasDeferredRemoval();

	public native void setInternalGhostPairCallback(btOverlappingPairCallback ghostPairCallback);

	public native void sortOverlappingPairs(btDispatcher dispatcher);
}

/** Hash-space based Pair Cache, thanks to Erin Catto, Box2D, http://www.box2d.org, and Pierre Terdiman, Codercorner, http://codercorner.com */

@NoOffset public static class btHashedOverlappingPairCache extends btOverlappingPairCache {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btHashedOverlappingPairCache(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btHashedOverlappingPairCache(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btHashedOverlappingPairCache position(long position) {
        return (btHashedOverlappingPairCache)super.position(position);
    }
    @Override public btHashedOverlappingPairCache getPointer(long i) {
        return new btHashedOverlappingPairCache((Pointer)this).offsetAddress(i);
    }


	public btHashedOverlappingPairCache() { super((Pointer)null); allocate(); }
	private native void allocate();

	public native void removeOverlappingPairsContainingProxy(btBroadphaseProxy proxy, btDispatcher dispatcher);

	public native Pointer removeOverlappingPair(btBroadphaseProxy proxy0, btBroadphaseProxy proxy1, btDispatcher dispatcher);

	public native @Cast("bool") boolean needsBroadphaseCollision(btBroadphaseProxy proxy0, btBroadphaseProxy proxy1);

	// Add a pair and return the new pair. If the pair already exists,
	// no new pair is created and the old one is returned.
	public native btBroadphasePair addOverlappingPair(btBroadphaseProxy proxy0, btBroadphaseProxy proxy1);

	public native void cleanProxyFromPairs(btBroadphaseProxy proxy, btDispatcher dispatcher);

	public native void processAllOverlappingPairs(btOverlapCallback arg0, btDispatcher dispatcher);

	public native void processAllOverlappingPairs(btOverlapCallback callback, btDispatcher dispatcher, @Const @ByRef btDispatcherInfo dispatchInfo);

	public native btBroadphasePair getOverlappingPairArrayPtr();

	

	

	public native void cleanOverlappingPair(@ByRef btBroadphasePair pair, btDispatcher dispatcher);

	public native btBroadphasePair findPair(btBroadphaseProxy proxy0, btBroadphaseProxy proxy1);

	public native int GetCount();
	//	btBroadphasePair* GetPairs() { return m_pairs; }

	public native btOverlapFilterCallback getOverlapFilterCallback();

	public native void setOverlapFilterCallback(btOverlapFilterCallback callback);

	public native int getNumOverlappingPairs();
}

/**btSortedOverlappingPairCache maintains the objects with overlapping AABB
 * Typically managed by the Broadphase, Axis3Sweep or btSimpleBroadphase */
@NoOffset public static class btSortedOverlappingPairCache extends btOverlappingPairCache {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btSortedOverlappingPairCache(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btSortedOverlappingPairCache(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btSortedOverlappingPairCache position(long position) {
        return (btSortedOverlappingPairCache)super.position(position);
    }
    @Override public btSortedOverlappingPairCache getPointer(long i) {
        return new btSortedOverlappingPairCache((Pointer)this).offsetAddress(i);
    }

	public btSortedOverlappingPairCache() { super((Pointer)null); allocate(); }
	private native void allocate();

	public native void processAllOverlappingPairs(btOverlapCallback arg0, btDispatcher dispatcher);

	public native Pointer removeOverlappingPair(btBroadphaseProxy proxy0, btBroadphaseProxy proxy1, btDispatcher dispatcher);

	public native void cleanOverlappingPair(@ByRef btBroadphasePair pair, btDispatcher dispatcher);

	public native btBroadphasePair addOverlappingPair(btBroadphaseProxy proxy0, btBroadphaseProxy proxy1);

	public native btBroadphasePair findPair(btBroadphaseProxy proxy0, btBroadphaseProxy proxy1);

	public native void cleanProxyFromPairs(btBroadphaseProxy proxy, btDispatcher dispatcher);

	public native void removeOverlappingPairsContainingProxy(btBroadphaseProxy proxy, btDispatcher dispatcher);

	public native @Cast("bool") boolean needsBroadphaseCollision(btBroadphaseProxy proxy0, btBroadphaseProxy proxy1);

	

	

	public native btBroadphasePair getOverlappingPairArrayPtr();

	public native int getNumOverlappingPairs();

	public native btOverlapFilterCallback getOverlapFilterCallback();

	public native void setOverlapFilterCallback(btOverlapFilterCallback callback);

	public native @Cast("bool") boolean hasDeferredRemoval();

	public native void setInternalGhostPairCallback(btOverlappingPairCallback ghostPairCallback);

	public native void sortOverlappingPairs(btDispatcher dispatcher);
}

/**btNullPairCache skips add/removal of overlapping pairs. Userful for benchmarking and unit testing. */
@NoOffset public static class btNullPairCache extends btOverlappingPairCache {
    static { Loader.load(); }
    /** Default native constructor. */
    public btNullPairCache() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btNullPairCache(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btNullPairCache(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btNullPairCache position(long position) {
        return (btNullPairCache)super.position(position);
    }
    @Override public btNullPairCache getPointer(long i) {
        return new btNullPairCache((Pointer)this).offsetAddress(i);
    }

	public native btBroadphasePair getOverlappingPairArrayPtr();
	

	public native void cleanOverlappingPair(@ByRef btBroadphasePair arg0, btDispatcher arg1);

	public native int getNumOverlappingPairs();

	public native void cleanProxyFromPairs(btBroadphaseProxy arg0, btDispatcher arg1);

	public native @Cast("bool") boolean needsBroadphaseCollision(btBroadphaseProxy arg0, btBroadphaseProxy arg1);
	public native btOverlapFilterCallback getOverlapFilterCallback();
	public native void setOverlapFilterCallback(btOverlapFilterCallback arg0);

	public native void processAllOverlappingPairs(btOverlapCallback arg0, btDispatcher arg1);

	public native btBroadphasePair findPair(btBroadphaseProxy arg0, btBroadphaseProxy arg1);

	public native @Cast("bool") boolean hasDeferredRemoval();

	public native void setInternalGhostPairCallback(btOverlappingPairCallback arg0);

	public native btBroadphasePair addOverlappingPair(btBroadphaseProxy arg0, btBroadphaseProxy arg1);

	public native Pointer removeOverlappingPair(btBroadphaseProxy arg0, btBroadphaseProxy arg1, btDispatcher arg2);

	public native void removeOverlappingPairsContainingProxy(btBroadphaseProxy arg0, btDispatcher arg1);

	public native void sortOverlappingPairs(btDispatcher dispatcher);
}

// #endif  //BT_OVERLAPPING_PAIR_CACHE_H


// Parsed from BulletCollision/BroadphaseCollision/btQuantizedBvh.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_QUANTIZED_BVH_H
// #define BT_QUANTIZED_BVH_H

//#define DEBUG_CHECK_DEQUANTIZATION 1
// #ifdef DEBUG_CHECK_DEQUANTIZATION
// #ifdef __SPU__
// #endif  //__SPU__

// #include <stdio.h>
// #include <stdlib.h>
// #endif  //DEBUG_CHECK_DEQUANTIZATION

// #include "LinearMath/btVector3.h"
// #include "LinearMath/btAlignedAllocator.h"

// #ifdef BT_USE_DOUBLE_PRECISION
// #else
// #define btQuantizedBvhData btQuantizedBvhFloatData
// #define btOptimizedBvhNodeData btOptimizedBvhNodeFloatData
public static final String btQuantizedBvhDataName = "btQuantizedBvhFloatData";
// #endif

//http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclang/html/vclrf__m128.asp

//Note: currently we have 16 bytes per quantized node
public static final int MAX_SUBTREE_SIZE_IN_BYTES = 2048;

// 10 gives the potential for 1024 parts, with at most 2^21 (2097152) (minus one
// actually) triangles each (since the sign bit is reserved
public static final int MAX_NUM_PARTS_IN_BITS = 10;

/**btQuantizedBvhNode is a compressed aabb node, 16 bytes.
 * Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range). */
public static class btQuantizedBvhNode extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btQuantizedBvhNode() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btQuantizedBvhNode(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btQuantizedBvhNode(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btQuantizedBvhNode position(long position) {
        return (btQuantizedBvhNode)super.position(position);
    }
    @Override public btQuantizedBvhNode getPointer(long i) {
        return new btQuantizedBvhNode((Pointer)this).offsetAddress(i);
    }


	//12 bytes
	public native @Cast("unsigned short int") short m_quantizedAabbMin(int i); public native btQuantizedBvhNode m_quantizedAabbMin(int i, short setter);
	@MemberGetter public native @Cast("unsigned short int*") ShortPointer m_quantizedAabbMin();
	public native @Cast("unsigned short int") short m_quantizedAabbMax(int i); public native btQuantizedBvhNode m_quantizedAabbMax(int i, short setter);
	@MemberGetter public native @Cast("unsigned short int*") ShortPointer m_quantizedAabbMax();
	//4 bytes
	public native int m_escapeIndexOrTriangleIndex(); public native btQuantizedBvhNode m_escapeIndexOrTriangleIndex(int setter);

	public native @Cast("bool") boolean isLeafNode();
	public native int getEscapeIndex();
	public native int getTriangleIndex();
	public native int getPartId();
}

/** btOptimizedBvhNode contains both internal and leaf node information.
 *  Total node size is 44 bytes / node. You can use the compressed version of 16 bytes. */
public static class btOptimizedBvhNode extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btOptimizedBvhNode() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btOptimizedBvhNode(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btOptimizedBvhNode(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btOptimizedBvhNode position(long position) {
        return (btOptimizedBvhNode)super.position(position);
    }
    @Override public btOptimizedBvhNode getPointer(long i) {
        return new btOptimizedBvhNode((Pointer)this).offsetAddress(i);
    }


	//32 bytes
	public native @ByRef btVector3 m_aabbMinOrg(); public native btOptimizedBvhNode m_aabbMinOrg(btVector3 setter);
	public native @ByRef btVector3 m_aabbMaxOrg(); public native btOptimizedBvhNode m_aabbMaxOrg(btVector3 setter);

	//4
	public native int m_escapeIndex(); public native btOptimizedBvhNode m_escapeIndex(int setter);

	//8
	//for child nodes
	public native int m_subPart(); public native btOptimizedBvhNode m_subPart(int setter);
	public native int m_triangleIndex(); public native btOptimizedBvhNode m_triangleIndex(int setter);

	//pad the size to 64 bytes
	public native @Cast("char") byte m_padding(int i); public native btOptimizedBvhNode m_padding(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_padding();
}

/**btBvhSubtreeInfo provides info to gather a subtree of limited size */
@NoOffset public static class btBvhSubtreeInfo extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btBvhSubtreeInfo(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btBvhSubtreeInfo(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btBvhSubtreeInfo position(long position) {
        return (btBvhSubtreeInfo)super.position(position);
    }
    @Override public btBvhSubtreeInfo getPointer(long i) {
        return new btBvhSubtreeInfo((Pointer)this).offsetAddress(i);
    }


	//12 bytes
	public native @Cast("unsigned short int") short m_quantizedAabbMin(int i); public native btBvhSubtreeInfo m_quantizedAabbMin(int i, short setter);
	@MemberGetter public native @Cast("unsigned short int*") ShortPointer m_quantizedAabbMin();
	public native @Cast("unsigned short int") short m_quantizedAabbMax(int i); public native btBvhSubtreeInfo m_quantizedAabbMax(int i, short setter);
	@MemberGetter public native @Cast("unsigned short int*") ShortPointer m_quantizedAabbMax();
	//4 bytes, points to the root of the subtree
	public native int m_rootNodeIndex(); public native btBvhSubtreeInfo m_rootNodeIndex(int setter);
	//4 bytes
	public native int m_subtreeSize(); public native btBvhSubtreeInfo m_subtreeSize(int setter);
	public native int m_padding(int i); public native btBvhSubtreeInfo m_padding(int i, int setter);
	@MemberGetter public native IntPointer m_padding();

	public btBvhSubtreeInfo() { super((Pointer)null); allocate(); }
	private native void allocate();

	public native void setAabbFromQuantizeNode(@Const @ByRef btQuantizedBvhNode quantizedNode);
}

public static class btNodeOverlapCallback extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btNodeOverlapCallback(Pointer p) { super(p); }


	public native void processNode(int subPart, int triangleIndex);
}

// #include "LinearMath/btAlignedAllocator.h"
// #include "LinearMath/btAlignedObjectArray.h"

/**for code readability: */

/**The btQuantizedBvh class stores an AABB tree that can be quickly traversed on CPU and Cell SPU.
 * It is used by the btBvhTriangleMeshShape as midphase.
 * It is recommended to use quantization for better performance and lower memory requirements. */
@NoOffset public static class btQuantizedBvh extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btQuantizedBvh(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btQuantizedBvh(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btQuantizedBvh position(long position) {
        return (btQuantizedBvh)super.position(position);
    }
    @Override public btQuantizedBvh getPointer(long i) {
        return new btQuantizedBvh((Pointer)this).offsetAddress(i);
    }

	/** enum btQuantizedBvh::btTraversalMode */
	public static final int
		TRAVERSAL_STACKLESS = 0,
		TRAVERSAL_STACKLESS_CACHE_FRIENDLY = 1,
		TRAVERSAL_RECURSIVE = 2;

	public btQuantizedBvh() { super((Pointer)null); allocate(); }
	private native void allocate();

	///***************************************** expert/internal use only *************************
	public native void setQuantizationValues(@Const @ByRef btVector3 bvhAabbMin, @Const @ByRef btVector3 bvhAabbMax, @Cast("btScalar") float quantizationMargin/*=btScalar(1.0)*/);
	public native void setQuantizationValues(@Const @ByRef btVector3 bvhAabbMin, @Const @ByRef btVector3 bvhAabbMax);
	public native @Cast("QuantizedNodeArray*") @ByRef btAlignedObjectArray_btVector3 getLeafNodeArray();
	/**buildInternal is expert use only: assumes that setQuantizationValues and LeafNodeArray are initialized */
	public native void buildInternal();
	///***************************************** expert/internal use only *************************

	public native void reportAabbOverlappingNodex(btNodeOverlapCallback nodeCallback, @Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax);
	public native void reportRayOverlappingNodex(btNodeOverlapCallback nodeCallback, @Const @ByRef btVector3 raySource, @Const @ByRef btVector3 rayTarget);
	public native void reportBoxCastOverlappingNodex(btNodeOverlapCallback nodeCallback, @Const @ByRef btVector3 raySource, @Const @ByRef btVector3 rayTarget, @Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax);

	public native void quantize(@Cast("unsigned short*") ShortPointer out, @Const @ByRef btVector3 point, int isMax);
	public native void quantize(@Cast("unsigned short*") ShortBuffer out, @Const @ByRef btVector3 point, int isMax);
	public native void quantize(@Cast("unsigned short*") short[] out, @Const @ByRef btVector3 point, int isMax);

	public native void quantizeWithClamp(@Cast("unsigned short*") ShortPointer out, @Const @ByRef btVector3 point2, int isMax);
	public native void quantizeWithClamp(@Cast("unsigned short*") ShortBuffer out, @Const @ByRef btVector3 point2, int isMax);
	public native void quantizeWithClamp(@Cast("unsigned short*") short[] out, @Const @ByRef btVector3 point2, int isMax);

	public native @ByVal btVector3 unQuantize(@Cast("const unsigned short*") ShortPointer vecIn);
	public native @ByVal btVector3 unQuantize(@Cast("const unsigned short*") ShortBuffer vecIn);
	public native @ByVal btVector3 unQuantize(@Cast("const unsigned short*") short[] vecIn);

	/**setTraversalMode let's you choose between stackless, recursive or stackless cache friendly tree traversal. Note this is only implemented for quantized trees. */
	public native void setTraversalMode(@Cast("btQuantizedBvh::btTraversalMode") int traversalMode);

	public native @Cast("QuantizedNodeArray*") @ByRef btAlignedObjectArray_btVector3 getQuantizedNodeArray();

	public native @Cast("BvhSubtreeInfoArray*") @ByRef btAlignedObjectArray_btVector3 getSubtreeInfoArray();

	////////////////////////////////////////////////////////////////////

	/////Calculate space needed to store BVH for serialization
	public native @Cast("unsigned") int calculateSerializeBufferSize();

	/** Data buffer MUST be 16 byte aligned */
	public native @Cast("bool") boolean serialize(Pointer o_alignedDataBuffer, @Cast("unsigned") int i_dataBufferSize, @Cast("bool") boolean i_swapEndian);

	/**deSerializeInPlace loads and initializes a BVH from a buffer in memory 'in place' */
	public static native btQuantizedBvh deSerializeInPlace(Pointer i_alignedDataBuffer, @Cast("unsigned int") int i_dataBufferSize, @Cast("bool") boolean i_swapEndian);

	public static native @Cast("unsigned int") int getAlignmentSerializationPadding();
	//////////////////////////////////////////////////////////////////////

	public native int calculateSerializeBufferSizeNew();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);

	public native void deSerializeFloat(@ByRef btQuantizedBvhFloatData quantizedBvhFloatData);

	public native void deSerializeDouble(@ByRef btQuantizedBvhDoubleData quantizedBvhDoubleData);

	////////////////////////////////////////////////////////////////////

	public native @Cast("bool") boolean isQuantized();
}

// clang-format off
// parser needs * with the name
public static class btBvhSubtreeInfoData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btBvhSubtreeInfoData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btBvhSubtreeInfoData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btBvhSubtreeInfoData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btBvhSubtreeInfoData position(long position) {
        return (btBvhSubtreeInfoData)super.position(position);
    }
    @Override public btBvhSubtreeInfoData getPointer(long i) {
        return new btBvhSubtreeInfoData((Pointer)this).offsetAddress(i);
    }

	public native int m_rootNodeIndex(); public native btBvhSubtreeInfoData m_rootNodeIndex(int setter);
	public native int m_subtreeSize(); public native btBvhSubtreeInfoData m_subtreeSize(int setter);
	public native @Cast("unsigned short") short m_quantizedAabbMin(int i); public native btBvhSubtreeInfoData m_quantizedAabbMin(int i, short setter);
	@MemberGetter public native @Cast("unsigned short*") ShortPointer m_quantizedAabbMin();
	public native @Cast("unsigned short") short m_quantizedAabbMax(int i); public native btBvhSubtreeInfoData m_quantizedAabbMax(int i, short setter);
	@MemberGetter public native @Cast("unsigned short*") ShortPointer m_quantizedAabbMax();
}

public static class btOptimizedBvhNodeFloatData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btOptimizedBvhNodeFloatData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btOptimizedBvhNodeFloatData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btOptimizedBvhNodeFloatData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btOptimizedBvhNodeFloatData position(long position) {
        return (btOptimizedBvhNodeFloatData)super.position(position);
    }
    @Override public btOptimizedBvhNodeFloatData getPointer(long i) {
        return new btOptimizedBvhNodeFloatData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btVector3FloatData m_aabbMinOrg(); public native btOptimizedBvhNodeFloatData m_aabbMinOrg(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_aabbMaxOrg(); public native btOptimizedBvhNodeFloatData m_aabbMaxOrg(btVector3FloatData setter);
	public native int m_escapeIndex(); public native btOptimizedBvhNodeFloatData m_escapeIndex(int setter);
	public native int m_subPart(); public native btOptimizedBvhNodeFloatData m_subPart(int setter);
	public native int m_triangleIndex(); public native btOptimizedBvhNodeFloatData m_triangleIndex(int setter);
	public native @Cast("char") byte m_pad(int i); public native btOptimizedBvhNodeFloatData m_pad(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_pad();
}

public static class btOptimizedBvhNodeDoubleData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btOptimizedBvhNodeDoubleData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btOptimizedBvhNodeDoubleData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btOptimizedBvhNodeDoubleData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btOptimizedBvhNodeDoubleData position(long position) {
        return (btOptimizedBvhNodeDoubleData)super.position(position);
    }
    @Override public btOptimizedBvhNodeDoubleData getPointer(long i) {
        return new btOptimizedBvhNodeDoubleData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btVector3DoubleData m_aabbMinOrg(); public native btOptimizedBvhNodeDoubleData m_aabbMinOrg(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_aabbMaxOrg(); public native btOptimizedBvhNodeDoubleData m_aabbMaxOrg(btVector3DoubleData setter);
	public native int m_escapeIndex(); public native btOptimizedBvhNodeDoubleData m_escapeIndex(int setter);
	public native int m_subPart(); public native btOptimizedBvhNodeDoubleData m_subPart(int setter);
	public native int m_triangleIndex(); public native btOptimizedBvhNodeDoubleData m_triangleIndex(int setter);
	public native @Cast("char") byte m_pad(int i); public native btOptimizedBvhNodeDoubleData m_pad(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_pad();
}


public static class btQuantizedBvhNodeData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btQuantizedBvhNodeData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btQuantizedBvhNodeData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btQuantizedBvhNodeData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btQuantizedBvhNodeData position(long position) {
        return (btQuantizedBvhNodeData)super.position(position);
    }
    @Override public btQuantizedBvhNodeData getPointer(long i) {
        return new btQuantizedBvhNodeData((Pointer)this).offsetAddress(i);
    }

	public native @Cast("unsigned short") short m_quantizedAabbMin(int i); public native btQuantizedBvhNodeData m_quantizedAabbMin(int i, short setter);
	@MemberGetter public native @Cast("unsigned short*") ShortPointer m_quantizedAabbMin();
	public native @Cast("unsigned short") short m_quantizedAabbMax(int i); public native btQuantizedBvhNodeData m_quantizedAabbMax(int i, short setter);
	@MemberGetter public native @Cast("unsigned short*") ShortPointer m_quantizedAabbMax();
	public native int m_escapeIndexOrTriangleIndex(); public native btQuantizedBvhNodeData m_escapeIndexOrTriangleIndex(int setter);
}

public static class btQuantizedBvhFloatData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btQuantizedBvhFloatData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btQuantizedBvhFloatData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btQuantizedBvhFloatData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btQuantizedBvhFloatData position(long position) {
        return (btQuantizedBvhFloatData)super.position(position);
    }
    @Override public btQuantizedBvhFloatData getPointer(long i) {
        return new btQuantizedBvhFloatData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btVector3FloatData m_bvhAabbMin(); public native btQuantizedBvhFloatData m_bvhAabbMin(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_bvhAabbMax(); public native btQuantizedBvhFloatData m_bvhAabbMax(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_bvhQuantization(); public native btQuantizedBvhFloatData m_bvhQuantization(btVector3FloatData setter);
	public native int m_curNodeIndex(); public native btQuantizedBvhFloatData m_curNodeIndex(int setter);
	public native int m_useQuantization(); public native btQuantizedBvhFloatData m_useQuantization(int setter);
	public native int m_numContiguousLeafNodes(); public native btQuantizedBvhFloatData m_numContiguousLeafNodes(int setter);
	public native int m_numQuantizedContiguousNodes(); public native btQuantizedBvhFloatData m_numQuantizedContiguousNodes(int setter);
	public native btOptimizedBvhNodeFloatData m_contiguousNodesPtr(); public native btQuantizedBvhFloatData m_contiguousNodesPtr(btOptimizedBvhNodeFloatData setter);
	public native btQuantizedBvhNodeData m_quantizedContiguousNodesPtr(); public native btQuantizedBvhFloatData m_quantizedContiguousNodesPtr(btQuantizedBvhNodeData setter);
	public native btBvhSubtreeInfoData m_subTreeInfoPtr(); public native btQuantizedBvhFloatData m_subTreeInfoPtr(btBvhSubtreeInfoData setter);
	public native int m_traversalMode(); public native btQuantizedBvhFloatData m_traversalMode(int setter);
	public native int m_numSubtreeHeaders(); public native btQuantizedBvhFloatData m_numSubtreeHeaders(int setter);
	
}

public static class btQuantizedBvhDoubleData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btQuantizedBvhDoubleData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btQuantizedBvhDoubleData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btQuantizedBvhDoubleData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btQuantizedBvhDoubleData position(long position) {
        return (btQuantizedBvhDoubleData)super.position(position);
    }
    @Override public btQuantizedBvhDoubleData getPointer(long i) {
        return new btQuantizedBvhDoubleData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btVector3DoubleData m_bvhAabbMin(); public native btQuantizedBvhDoubleData m_bvhAabbMin(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_bvhAabbMax(); public native btQuantizedBvhDoubleData m_bvhAabbMax(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_bvhQuantization(); public native btQuantizedBvhDoubleData m_bvhQuantization(btVector3DoubleData setter);
	public native int m_curNodeIndex(); public native btQuantizedBvhDoubleData m_curNodeIndex(int setter);
	public native int m_useQuantization(); public native btQuantizedBvhDoubleData m_useQuantization(int setter);
	public native int m_numContiguousLeafNodes(); public native btQuantizedBvhDoubleData m_numContiguousLeafNodes(int setter);
	public native int m_numQuantizedContiguousNodes(); public native btQuantizedBvhDoubleData m_numQuantizedContiguousNodes(int setter);
	public native btOptimizedBvhNodeDoubleData m_contiguousNodesPtr(); public native btQuantizedBvhDoubleData m_contiguousNodesPtr(btOptimizedBvhNodeDoubleData setter);
	public native btQuantizedBvhNodeData m_quantizedContiguousNodesPtr(); public native btQuantizedBvhDoubleData m_quantizedContiguousNodesPtr(btQuantizedBvhNodeData setter);

	public native int m_traversalMode(); public native btQuantizedBvhDoubleData m_traversalMode(int setter);
	public native int m_numSubtreeHeaders(); public native btQuantizedBvhDoubleData m_numSubtreeHeaders(int setter);
	public native btBvhSubtreeInfoData m_subTreeInfoPtr(); public native btQuantizedBvhDoubleData m_subTreeInfoPtr(btBvhSubtreeInfoData setter);
}
// clang-format on



// #endif  //BT_QUANTIZED_BVH_H


// Parsed from BulletCollision/BroadphaseCollision/btBroadphaseInterface.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_BROADPHASE_INTERFACE_H
// #define BT_BROADPHASE_INTERFACE_H
// #include "btBroadphaseProxy.h"

public static class btBroadphaseAabbCallback extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btBroadphaseAabbCallback(Pointer p) { super(p); }

	public native @Cast("bool") boolean process(@Const btBroadphaseProxy proxy);
}

@NoOffset public static class btBroadphaseRayCallback extends btBroadphaseAabbCallback {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btBroadphaseRayCallback(Pointer p) { super(p); }

	/**added some cached data to accelerate ray-AABB tests */
	public native @ByRef btVector3 m_rayDirectionInverse(); public native btBroadphaseRayCallback m_rayDirectionInverse(btVector3 setter);
	public native @Cast("unsigned int") int m_signs(int i); public native btBroadphaseRayCallback m_signs(int i, int setter);
	@MemberGetter public native @Cast("unsigned int*") IntPointer m_signs();
	public native @Cast("btScalar") float m_lambda_max(); public native btBroadphaseRayCallback m_lambda_max(float setter);
}

// #include "LinearMath/btVector3.h"

/**The btBroadphaseInterface class provides an interface to detect aabb-overlapping object pairs.
 * Some implementations for this broadphase interface include btAxisSweep3, bt32BitAxisSweep3 and btDbvtBroadphase.
 * The actual overlapping pair management, storage, adding and removing of pairs is dealt by the btOverlappingPairCache class. */
public static class btBroadphaseInterface extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btBroadphaseInterface(Pointer p) { super(p); }


	public native btBroadphaseProxy createProxy(@Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax, int shapeType, Pointer userPtr, int collisionFilterGroup, int collisionFilterMask, btDispatcher dispatcher);
	public native void destroyProxy(btBroadphaseProxy proxy, btDispatcher dispatcher);
	public native void setAabb(btBroadphaseProxy proxy, @Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax, btDispatcher dispatcher);
	public native void getAabb(btBroadphaseProxy proxy, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native void rayTest(@Const @ByRef btVector3 rayFrom, @Const @ByRef btVector3 rayTo, @ByRef btBroadphaseRayCallback rayCallback, @Const @ByRef(nullValue = "btVector3(0, 0, 0)") btVector3 aabbMin, @Const @ByRef(nullValue = "btVector3(0, 0, 0)") btVector3 aabbMax);
	public native void rayTest(@Const @ByRef btVector3 rayFrom, @Const @ByRef btVector3 rayTo, @ByRef btBroadphaseRayCallback rayCallback);

	public native void aabbTest(@Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax, @ByRef btBroadphaseAabbCallback callback);

	/**calculateOverlappingPairs is optional: incremental algorithms (sweep and prune) might do it during the set aabb */
	public native void calculateOverlappingPairs(btDispatcher dispatcher);

	public native btOverlappingPairCache getOverlappingPairCache();

	/**getAabb returns the axis aligned bounding box in the 'global' coordinate frame
	 * will add some transform later */
	public native void getBroadphaseAabb(@ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	/**reset broadphase internal structures, to ensure determinism/reproducability */
	public native void resetPool(btDispatcher dispatcher);

	public native void printStats();
}

// #endif  //BT_BROADPHASE_INTERFACE_H


// Parsed from BulletCollision/BroadphaseCollision/btSimpleBroadphase.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_SIMPLE_BROADPHASE_H
// #define BT_SIMPLE_BROADPHASE_H

// #include "btOverlappingPairCache.h"

@NoOffset public static class btSimpleBroadphaseProxy extends btBroadphaseProxy {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btSimpleBroadphaseProxy(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btSimpleBroadphaseProxy(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btSimpleBroadphaseProxy position(long position) {
        return (btSimpleBroadphaseProxy)super.position(position);
    }
    @Override public btSimpleBroadphaseProxy getPointer(long i) {
        return new btSimpleBroadphaseProxy((Pointer)this).offsetAddress(i);
    }

	public native int m_nextFree(); public native btSimpleBroadphaseProxy m_nextFree(int setter);

	//	int			m_handleId;

	public btSimpleBroadphaseProxy() { super((Pointer)null); allocate(); }
	private native void allocate();

	public btSimpleBroadphaseProxy(@Const @ByRef btVector3 minpt, @Const @ByRef btVector3 maxpt, int shapeType, Pointer userPtr, int collisionFilterGroup, int collisionFilterMask) { super((Pointer)null); allocate(minpt, maxpt, shapeType, userPtr, collisionFilterGroup, collisionFilterMask); }
	private native void allocate(@Const @ByRef btVector3 minpt, @Const @ByRef btVector3 maxpt, int shapeType, Pointer userPtr, int collisionFilterGroup, int collisionFilterMask);

	public native void SetNextFree(int next);
	public native int GetNextFree();
}

/**The SimpleBroadphase is just a unit-test for btAxisSweep3, bt32BitAxisSweep3, or btDbvtBroadphase, so use those classes instead.
 * It is a brute force aabb culling broadphase based on O(n^2) aabb checks */
@NoOffset public static class btSimpleBroadphase extends btBroadphaseInterface {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btSimpleBroadphase(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btSimpleBroadphase(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btSimpleBroadphase position(long position) {
        return (btSimpleBroadphase)super.position(position);
    }
    @Override public btSimpleBroadphase getPointer(long i) {
        return new btSimpleBroadphase((Pointer)this).offsetAddress(i);
    }

	public btSimpleBroadphase(int maxProxies/*=16384*/, btOverlappingPairCache overlappingPairCache/*=0*/) { super((Pointer)null); allocate(maxProxies, overlappingPairCache); }
	private native void allocate(int maxProxies/*=16384*/, btOverlappingPairCache overlappingPairCache/*=0*/);
	public btSimpleBroadphase() { super((Pointer)null); allocate(); }
	private native void allocate();

	public static native @Cast("bool") boolean aabbOverlap(btSimpleBroadphaseProxy proxy0, btSimpleBroadphaseProxy proxy1);

	public native btBroadphaseProxy createProxy(@Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax, int shapeType, Pointer userPtr, int collisionFilterGroup, int collisionFilterMask, btDispatcher dispatcher);

	public native void calculateOverlappingPairs(btDispatcher dispatcher);

	public native void destroyProxy(btBroadphaseProxy proxy, btDispatcher dispatcher);
	public native void setAabb(btBroadphaseProxy proxy, @Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax, btDispatcher dispatcher);
	public native void getAabb(btBroadphaseProxy proxy, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native void rayTest(@Const @ByRef btVector3 rayFrom, @Const @ByRef btVector3 rayTo, @ByRef btBroadphaseRayCallback rayCallback, @Const @ByRef(nullValue = "btVector3(0, 0, 0)") btVector3 aabbMin, @Const @ByRef(nullValue = "btVector3(0, 0, 0)") btVector3 aabbMax);
	public native void rayTest(@Const @ByRef btVector3 rayFrom, @Const @ByRef btVector3 rayTo, @ByRef btBroadphaseRayCallback rayCallback);
	public native void aabbTest(@Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax, @ByRef btBroadphaseAabbCallback callback);

	public native btOverlappingPairCache getOverlappingPairCache();

	public native @Cast("bool") boolean testAabbOverlap(btBroadphaseProxy proxy0, btBroadphaseProxy proxy1);

	/**getAabb returns the axis aligned bounding box in the 'global' coordinate frame
	 * will add some transform later */
	public native void getBroadphaseAabb(@ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native void printStats();
}

// #endif  //BT_SIMPLE_BROADPHASE_H


// Parsed from BulletCollision/BroadphaseCollision/btAxisSweep3.h

//Bullet Continuous Collision Detection and Physics Library
//Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

//
// btAxisSweep3.h
//
// Copyright (c) 2006 Simon Hobbs
//
// This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.

// #ifndef BT_AXIS_SWEEP_3_H
// #define BT_AXIS_SWEEP_3_H

// #include "LinearMath/btVector3.h"
// #include "btOverlappingPairCache.h"
// #include "btBroadphaseInterface.h"
// #include "btBroadphaseProxy.h"
// #include "btOverlappingPairCallback.h"
// #include "btDbvtBroadphase.h"
// #include "btAxisSweep3Internal.h"

/** The btAxisSweep3 is an efficient implementation of the 3d axis sweep and prune broadphase.
 *  It uses arrays rather then lists for storage of the 3 axis. Also it operates using 16 bit integer coordinates instead of floats.
 *  For large worlds and many objects, use bt32BitAxisSweep3 or btDbvtBroadphase instead. bt32BitAxisSweep3 has higher precision and allows more then 16384 objects at the cost of more memory and bit of performance. */
public static class btAxisSweep3 extends btBroadphaseInterface {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btAxisSweep3(Pointer p) { super(p); }

	public btAxisSweep3(@Const @ByRef btVector3 worldAabbMin, @Const @ByRef btVector3 worldAabbMax, @Cast("unsigned short int") short maxHandles/*=16384*/, btOverlappingPairCache pairCache/*=0*/, @Cast("bool") boolean disableRaycastAccelerator/*=false*/) { super((Pointer)null); allocate(worldAabbMin, worldAabbMax, maxHandles, pairCache, disableRaycastAccelerator); }
	private native void allocate(@Const @ByRef btVector3 worldAabbMin, @Const @ByRef btVector3 worldAabbMax, @Cast("unsigned short int") short maxHandles/*=16384*/, btOverlappingPairCache pairCache/*=0*/, @Cast("bool") boolean disableRaycastAccelerator/*=false*/);
	public btAxisSweep3(@Const @ByRef btVector3 worldAabbMin, @Const @ByRef btVector3 worldAabbMax) { super((Pointer)null); allocate(worldAabbMin, worldAabbMax); }
	private native void allocate(@Const @ByRef btVector3 worldAabbMin, @Const @ByRef btVector3 worldAabbMax);
}

/** The bt32BitAxisSweep3 allows higher precision quantization and more objects compared to the btAxisSweep3 sweep and prune.
 *  This comes at the cost of more memory per handle, and a bit slower performance.
 *  It uses arrays rather then lists for storage of the 3 axis. */
public static class bt32BitAxisSweep3 extends btBroadphaseInterface {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public bt32BitAxisSweep3(Pointer p) { super(p); }

	public bt32BitAxisSweep3(@Const @ByRef btVector3 worldAabbMin, @Const @ByRef btVector3 worldAabbMax, @Cast("unsigned int") int maxHandles/*=1500000*/, btOverlappingPairCache pairCache/*=0*/, @Cast("bool") boolean disableRaycastAccelerator/*=false*/) { super((Pointer)null); allocate(worldAabbMin, worldAabbMax, maxHandles, pairCache, disableRaycastAccelerator); }
	private native void allocate(@Const @ByRef btVector3 worldAabbMin, @Const @ByRef btVector3 worldAabbMax, @Cast("unsigned int") int maxHandles/*=1500000*/, btOverlappingPairCache pairCache/*=0*/, @Cast("bool") boolean disableRaycastAccelerator/*=false*/);
	public bt32BitAxisSweep3(@Const @ByRef btVector3 worldAabbMin, @Const @ByRef btVector3 worldAabbMax) { super((Pointer)null); allocate(worldAabbMin, worldAabbMax); }
	private native void allocate(@Const @ByRef btVector3 worldAabbMin, @Const @ByRef btVector3 worldAabbMax);
}

// #endif


// Parsed from BulletCollision/BroadphaseCollision/btDbvtBroadphase.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/**btDbvtBroadphase implementation by Nathanael Presson */
// #ifndef BT_DBVT_BROADPHASE_H
// #define BT_DBVT_BROADPHASE_H

// #include "BulletCollision/BroadphaseCollision/btDbvt.h"
// #include "BulletCollision/BroadphaseCollision/btOverlappingPairCache.h"

//
// Compile time config
//

public static native @MemberGetter int DBVT_BP_PROFILE();
public static final int DBVT_BP_PROFILE = DBVT_BP_PROFILE();
//#define DBVT_BP_SORTPAIRS				1
public static final int DBVT_BP_PREVENTFALSEUPDATE = 0;
public static final int DBVT_BP_ACCURATESLEEPING = 0;
public static final int DBVT_BP_ENABLE_BENCHMARK = 0;
//#define DBVT_BP_MARGIN					(btScalar)0.05
public static native @Cast("btScalar") float gDbvtMargin(); public static native void gDbvtMargin(float setter);

// #if DBVT_BP_PROFILE
// #endif

//
// btDbvtProxy
//

/**The btDbvtBroadphase implements a broadphase using two dynamic AABB bounding volume hierarchies/trees (see btDbvt).
 * One tree is used for static/non-moving objects, and another tree is used for dynamic objects. Objects can move from one tree to the other.
 * This is a very fast broadphase, especially for very dynamic worlds where many objects are moving. Its insert/add and remove of objects is generally faster than the sweep and prune broadphases btAxisSweep3 and bt32BitAxisSweep3. */
@NoOffset public static class btDbvtBroadphase extends btBroadphaseInterface {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btDbvtBroadphase(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btDbvtBroadphase(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btDbvtBroadphase position(long position) {
        return (btDbvtBroadphase)super.position(position);
    }
    @Override public btDbvtBroadphase getPointer(long i) {
        return new btDbvtBroadphase((Pointer)this).offsetAddress(i);
    }

	/* Config		*/
	/** enum btDbvtBroadphase:: */
	public static final int
		DYNAMIC_SET = 0, /* Dynamic set index	*/
		FIXED_SET = 1,   /* Fixed set index		*/
		STAGECOUNT = 2;   /* Number of stages		*/
	/* Fields		*/
	public native @ByRef btDbvt m_sets(int i); public native btDbvtBroadphase m_sets(int i, btDbvt setter);
	@MemberGetter public native btDbvt m_sets();                           // Dbvt sets  // Stages list
	public native btOverlappingPairCache m_paircache(); public native btDbvtBroadphase m_paircache(btOverlappingPairCache setter);        // Pair cache
	public native @Cast("btScalar") float m_prediction(); public native btDbvtBroadphase m_prediction(float setter);                      // Velocity prediction
	public native int m_stageCurrent(); public native btDbvtBroadphase m_stageCurrent(int setter);                         // Current stage
	public native int m_fupdates(); public native btDbvtBroadphase m_fupdates(int setter);                             // % of fixed updates per frame
	public native int m_dupdates(); public native btDbvtBroadphase m_dupdates(int setter);                             // % of dynamic updates per frame
	public native int m_cupdates(); public native btDbvtBroadphase m_cupdates(int setter);                             // % of cleanup updates per frame
	public native int m_newpairs(); public native btDbvtBroadphase m_newpairs(int setter);                             // Number of pairs created
	public native int m_fixedleft(); public native btDbvtBroadphase m_fixedleft(int setter);                            // Fixed optimization left
	public native @Cast("unsigned") int m_updates_call(); public native btDbvtBroadphase m_updates_call(int setter);                    // Number of updates call
	public native @Cast("unsigned") int m_updates_done(); public native btDbvtBroadphase m_updates_done(int setter);                    // Number of updates done
	public native @Cast("btScalar") float m_updates_ratio(); public native btDbvtBroadphase m_updates_ratio(float setter);                   // m_updates_done/m_updates_call
	public native int m_pid(); public native btDbvtBroadphase m_pid(int setter);                                  // Parse id
	public native int m_cid(); public native btDbvtBroadphase m_cid(int setter);                                  // Cleanup index
	public native int m_gid(); public native btDbvtBroadphase m_gid(int setter);                                  // Gen id
	public native @Cast("bool") boolean m_releasepaircache(); public native btDbvtBroadphase m_releasepaircache(boolean setter);                    // Release pair cache on delete
	public native @Cast("bool") boolean m_deferedcollide(); public native btDbvtBroadphase m_deferedcollide(boolean setter);                      // Defere dynamic/static collision to collide call
	public native @Cast("bool") boolean m_needcleanup(); public native btDbvtBroadphase m_needcleanup(boolean setter);                         // Need to run cleanup?
	
// #if DBVT_BP_PROFILE
// #endif
	/* Methods		*/
	public btDbvtBroadphase(btOverlappingPairCache paircache/*=0*/) { super((Pointer)null); allocate(paircache); }
	private native void allocate(btOverlappingPairCache paircache/*=0*/);
	public btDbvtBroadphase() { super((Pointer)null); allocate(); }
	private native void allocate();
	public native void collide(btDispatcher dispatcher);
	public native void optimize();

	/* btBroadphaseInterface Implementation	*/
	public native btBroadphaseProxy createProxy(@Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax, int shapeType, Pointer userPtr, int collisionFilterGroup, int collisionFilterMask, btDispatcher dispatcher);
	public native void destroyProxy(btBroadphaseProxy proxy, btDispatcher dispatcher);
	public native void setAabb(btBroadphaseProxy proxy, @Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax, btDispatcher dispatcher);
	public native void rayTest(@Const @ByRef btVector3 rayFrom, @Const @ByRef btVector3 rayTo, @ByRef btBroadphaseRayCallback rayCallback, @Const @ByRef(nullValue = "btVector3(0, 0, 0)") btVector3 aabbMin, @Const @ByRef(nullValue = "btVector3(0, 0, 0)") btVector3 aabbMax);
	public native void rayTest(@Const @ByRef btVector3 rayFrom, @Const @ByRef btVector3 rayTo, @ByRef btBroadphaseRayCallback rayCallback);
	public native void aabbTest(@Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax, @ByRef btBroadphaseAabbCallback callback);

	public native void getAabb(btBroadphaseProxy proxy, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);
	public native void calculateOverlappingPairs(btDispatcher dispatcher);
	public native btOverlappingPairCache getOverlappingPairCache();
	public native void getBroadphaseAabb(@ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);
	public native void printStats();

	/**reset broadphase internal structures, to ensure determinism/reproducability */
	public native void resetPool(btDispatcher dispatcher);

	public native void performDeferredRemoval(btDispatcher dispatcher);

	public native void setVelocityPrediction(@Cast("btScalar") float prediction);
	public native @Cast("btScalar") float getVelocityPrediction();

	/**this setAabbForceUpdate is similar to setAabb but always forces the aabb update.
	 * it is not part of the btBroadphaseInterface but specific to btDbvtBroadphase.
	 * it bypasses certain optimizations that prevent aabb updates (when the aabb shrinks), see
	 * http://code.google.com/p/bullet/issues/detail?id=223 */
	public native void setAabbForceUpdate(btBroadphaseProxy absproxy, @Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax, btDispatcher arg3);

	public static native void benchmark(btBroadphaseInterface arg0);
}

// #endif


// Parsed from BulletCollision/NarrowPhaseCollision/btManifoldPoint.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_MANIFOLD_CONTACT_POINT_H
// #define BT_MANIFOLD_CONTACT_POINT_H

// #include "LinearMath/btVector3.h"
// #include "LinearMath/btTransformUtil.h"

// #ifdef PFX_USE_FREE_VECTORMATH
// #else
// Don't change following order of parameters
public static class btConstraintRow extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btConstraintRow() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btConstraintRow(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConstraintRow(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btConstraintRow position(long position) {
        return (btConstraintRow)super.position(position);
    }
    @Override public btConstraintRow getPointer(long i) {
        return new btConstraintRow((Pointer)this).offsetAddress(i);
    }

	public native @Cast("btScalar") float m_normal(int i); public native btConstraintRow m_normal(int i, float setter);
	@MemberGetter public native @Cast("btScalar*") FloatPointer m_normal();
	public native @Cast("btScalar") float m_rhs(); public native btConstraintRow m_rhs(float setter);
	public native @Cast("btScalar") float m_jacDiagInv(); public native btConstraintRow m_jacDiagInv(float setter);
	public native @Cast("btScalar") float m_lowerLimit(); public native btConstraintRow m_lowerLimit(float setter);
	public native @Cast("btScalar") float m_upperLimit(); public native btConstraintRow m_upperLimit(float setter);
	public native @Cast("btScalar") float m_accumImpulse(); public native btConstraintRow m_accumImpulse(float setter);
}
// #endif  //PFX_USE_FREE_VECTORMATH

/** enum btContactPointFlags */
public static final int
	BT_CONTACT_FLAG_LATERAL_FRICTION_INITIALIZED = 1,
	BT_CONTACT_FLAG_HAS_CONTACT_CFM = 2,
	BT_CONTACT_FLAG_HAS_CONTACT_ERP = 4,
	BT_CONTACT_FLAG_CONTACT_STIFFNESS_DAMPING = 8,
	BT_CONTACT_FLAG_FRICTION_ANCHOR = 16;

/** ManifoldContactPoint collects and maintains persistent contactpoints.
 *  used to improve stability and performance of rigidbody dynamics response. */
@NoOffset public static class btManifoldPoint extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btManifoldPoint(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btManifoldPoint(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btManifoldPoint position(long position) {
        return (btManifoldPoint)super.position(position);
    }
    @Override public btManifoldPoint getPointer(long i) {
        return new btManifoldPoint((Pointer)this).offsetAddress(i);
    }

	public btManifoldPoint() { super((Pointer)null); allocate(); }
	private native void allocate();

	public btManifoldPoint(@Const @ByRef btVector3 pointA, @Const @ByRef btVector3 pointB,
						@Const @ByRef btVector3 normal,
						@Cast("btScalar") float distance) { super((Pointer)null); allocate(pointA, pointB, normal, distance); }
	private native void allocate(@Const @ByRef btVector3 pointA, @Const @ByRef btVector3 pointB,
						@Const @ByRef btVector3 normal,
						@Cast("btScalar") float distance);

	public native @ByRef btVector3 m_localPointA(); public native btManifoldPoint m_localPointA(btVector3 setter);
	public native @ByRef btVector3 m_localPointB(); public native btManifoldPoint m_localPointB(btVector3 setter);
	public native @ByRef btVector3 m_positionWorldOnB(); public native btManifoldPoint m_positionWorldOnB(btVector3 setter);
	/**m_positionWorldOnA is redundant information, see getPositionWorldOnA(), but for clarity */
	public native @ByRef btVector3 m_positionWorldOnA(); public native btManifoldPoint m_positionWorldOnA(btVector3 setter);
	public native @ByRef btVector3 m_normalWorldOnB(); public native btManifoldPoint m_normalWorldOnB(btVector3 setter);

	public native @Cast("btScalar") float m_distance1(); public native btManifoldPoint m_distance1(float setter);
	public native @Cast("btScalar") float m_combinedFriction(); public native btManifoldPoint m_combinedFriction(float setter);
	public native @Cast("btScalar") float m_combinedRollingFriction(); public native btManifoldPoint m_combinedRollingFriction(float setter);   //torsional friction orthogonal to contact normal, useful to make spheres stop rolling forever
	public native @Cast("btScalar") float m_combinedSpinningFriction(); public native btManifoldPoint m_combinedSpinningFriction(float setter);  //torsional friction around contact normal, useful for grasping objects
	public native @Cast("btScalar") float m_combinedRestitution(); public native btManifoldPoint m_combinedRestitution(float setter);

	//BP mod, store contact triangles.
	public native int m_partId0(); public native btManifoldPoint m_partId0(int setter);
	public native int m_partId1(); public native btManifoldPoint m_partId1(int setter);
	public native int m_index0(); public native btManifoldPoint m_index0(int setter);
	public native int m_index1(); public native btManifoldPoint m_index1(int setter);

	public native Pointer m_userPersistentData(); public native btManifoldPoint m_userPersistentData(Pointer setter);
	//bool			m_lateralFrictionInitialized;
	public native int m_contactPointFlags(); public native btManifoldPoint m_contactPointFlags(int setter);

	public native @Cast("btScalar") float m_appliedImpulse(); public native btManifoldPoint m_appliedImpulse(float setter);
	public native @Cast("btScalar") float m_prevRHS(); public native btManifoldPoint m_prevRHS(float setter);
	public native @Cast("btScalar") float m_appliedImpulseLateral1(); public native btManifoldPoint m_appliedImpulseLateral1(float setter);
	public native @Cast("btScalar") float m_appliedImpulseLateral2(); public native btManifoldPoint m_appliedImpulseLateral2(float setter);
	public native @Cast("btScalar") float m_contactMotion1(); public native btManifoldPoint m_contactMotion1(float setter);
	public native @Cast("btScalar") float m_contactMotion2(); public native btManifoldPoint m_contactMotion2(float setter);
		public native @Cast("btScalar") float m_contactCFM(); public native btManifoldPoint m_contactCFM(float setter);
		public native @Cast("btScalar") float m_combinedContactStiffness1(); public native btManifoldPoint m_combinedContactStiffness1(float setter);
		public native @Cast("btScalar") float m_contactERP(); public native btManifoldPoint m_contactERP(float setter);
		public native @Cast("btScalar") float m_combinedContactDamping1(); public native btManifoldPoint m_combinedContactDamping1(float setter);

	public native @Cast("btScalar") float m_frictionCFM(); public native btManifoldPoint m_frictionCFM(float setter);

	public native int m_lifeTime(); public native btManifoldPoint m_lifeTime(int setter);  //lifetime of the contactpoint in frames

	public native @ByRef btVector3 m_lateralFrictionDir1(); public native btManifoldPoint m_lateralFrictionDir1(btVector3 setter);
	public native @ByRef btVector3 m_lateralFrictionDir2(); public native btManifoldPoint m_lateralFrictionDir2(btVector3 setter);

	public native @Cast("btScalar") float getDistance();
	public native int getLifeTime();

	public native @Const @ByRef btVector3 getPositionWorldOnA();

	public native @Const @ByRef btVector3 getPositionWorldOnB();

	public native void setDistance(@Cast("btScalar") float dist);

	/**this returns the most recent applied impulse, to satisfy contact constraints by the constraint solver */
	public native @Cast("btScalar") float getAppliedImpulse();
}

// #endif  //BT_MANIFOLD_CONTACT_POINT_H


// Parsed from BulletCollision/NarrowPhaseCollision/btDiscreteCollisionDetectorInterface.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_DISCRETE_COLLISION_DETECTOR1_INTERFACE_H
// #define BT_DISCRETE_COLLISION_DETECTOR1_INTERFACE_H

// #include "LinearMath/btTransform.h"
// #include "LinearMath/btVector3.h"

/** This interface is made to be used by an iterative approach to do TimeOfImpact calculations
 *  This interface allows to query for closest points and penetration depth between two (convex) objects
 *  the closest point is on the second object (B), and the normal points from the surface on B towards A.
 *  distance is between closest points on B and closest point on A. So you can calculate closest point on A
 *  by taking closestPointInA = closestPointInB + m_distance * m_normalOnSurfaceB */
public static class btDiscreteCollisionDetectorInterface extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btDiscreteCollisionDetectorInterface(Pointer p) { super(p); }

	public static class Result extends Pointer {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public Result(Pointer p) { super(p); }
	

		/**setShapeIdentifiersA/B provides experimental support for per-triangle material / custom material combiner */
		public native void setShapeIdentifiersA(int partId0, int index0);
		public native void setShapeIdentifiersB(int partId1, int index1);
		public native void addContactPoint(@Const @ByRef btVector3 normalOnBInWorld, @Const @ByRef btVector3 pointInWorld, @Cast("btScalar") float depth);
	}

	@NoOffset public static class ClosestPointInput extends Pointer {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public ClosestPointInput(Pointer p) { super(p); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public ClosestPointInput(long size) { super((Pointer)null); allocateArray(size); }
	    private native void allocateArray(long size);
	    @Override public ClosestPointInput position(long position) {
	        return (ClosestPointInput)super.position(position);
	    }
	    @Override public ClosestPointInput getPointer(long i) {
	        return new ClosestPointInput((Pointer)this).offsetAddress(i);
	    }
	
		public ClosestPointInput() { super((Pointer)null); allocate(); }
		private native void allocate();

		public native @ByRef btTransform m_transformA(); public native ClosestPointInput m_transformA(btTransform setter);
		public native @ByRef btTransform m_transformB(); public native ClosestPointInput m_transformB(btTransform setter);
		public native @Cast("btScalar") float m_maximumDistanceSquared(); public native ClosestPointInput m_maximumDistanceSquared(float setter);
	}

	//
	// give either closest points (distance > 0) or penetration (distance)
	// the normal always points from B towards A
	//
	public native void getClosestPoints(@Const @ByRef ClosestPointInput input, @ByRef Result output, btIDebugDraw debugDraw, @Cast("bool") boolean swapResults/*=false*/);
	public native void getClosestPoints(@Const @ByRef ClosestPointInput input, @ByRef Result output, btIDebugDraw debugDraw);
}

@NoOffset public static class btStorageResult extends btDiscreteCollisionDetectorInterface.Result {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btStorageResult(Pointer p) { super(p); }

	public native @ByRef btVector3 m_normalOnSurfaceB(); public native btStorageResult m_normalOnSurfaceB(btVector3 setter);
	public native @ByRef btVector3 m_closestPointInB(); public native btStorageResult m_closestPointInB(btVector3 setter);
	public native @Cast("btScalar") float m_distance(); public native btStorageResult m_distance(float setter);

	public native void addContactPoint(@Const @ByRef btVector3 normalOnBInWorld, @Const @ByRef btVector3 pointInWorld, @Cast("btScalar") float depth);
}

// #endif  //BT_DISCRETE_COLLISION_DETECTOR1_INTERFACE_H


// Parsed from BulletCollision/CollisionDispatch/btCollisionObject.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_COLLISION_OBJECT_H
// #define BT_COLLISION_OBJECT_H

// #include "LinearMath/btTransform.h"

//island management, m_activationState1
public static final int ACTIVE_TAG = 1;
public static final int ISLAND_SLEEPING = 2;
public static final int WANTS_DEACTIVATION = 3;
public static final int DISABLE_DEACTIVATION = 4;
public static final int DISABLE_SIMULATION = 5;
public static final int FIXED_BASE_MULTI_BODY = 6;
// #include "LinearMath/btMotionState.h"
// #include "LinearMath/btAlignedAllocator.h"
// #include "LinearMath/btAlignedObjectArray.h"

// #ifdef BT_USE_DOUBLE_PRECISION
// #else
// #define btCollisionObjectData btCollisionObjectFloatData
public static final String btCollisionObjectDataName = "btCollisionObjectFloatData";
// #endif

/** btCollisionObject can be used to manage collision detection objects.
 *  btCollisionObject maintains all information that is needed for a collision detection: Shape, Transform and AABB proxy.
 *  They can be added to the btCollisionWorld. */
@NoOffset public static class btCollisionObject extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCollisionObject(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btCollisionObject(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btCollisionObject position(long position) {
        return (btCollisionObject)super.position(position);
    }
    @Override public btCollisionObject getPointer(long i) {
        return new btCollisionObject((Pointer)this).offsetAddress(i);
    }


	/** enum btCollisionObject::CollisionFlags */
	public static final int
		CF_DYNAMIC_OBJECT = 0,
		CF_STATIC_OBJECT = 1,
		CF_KINEMATIC_OBJECT = 2,
		CF_NO_CONTACT_RESPONSE = 4,
		CF_CUSTOM_MATERIAL_CALLBACK = 8,  //this allows per-triangle material (friction/restitution)
		CF_CHARACTER_OBJECT = 16,
		CF_DISABLE_VISUALIZE_OBJECT = 32,          //disable debug drawing
		CF_DISABLE_SPU_COLLISION_PROCESSING = 64,  //disable parallel/SPU processing
		CF_HAS_CONTACT_STIFFNESS_DAMPING = 128,
		CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR = 256,
		CF_HAS_FRICTION_ANCHOR = 512,
		CF_HAS_COLLISION_SOUND_TRIGGER = 1024;

	/** enum btCollisionObject::CollisionObjectTypes */
	public static final int
		CO_COLLISION_OBJECT = 1,
		CO_RIGID_BODY = 2,
		/**CO_GHOST_OBJECT keeps track of all objects overlapping its AABB and that pass its collision filter
		 * It is useful for collision sensors, explosion objects, character controller etc. */
		CO_GHOST_OBJECT = 4,
		CO_SOFT_BODY = 8,
		CO_HF_FLUID = 16,
		CO_USER_TYPE = 32,
		CO_FEATHERSTONE_LINK = 64;

	/** enum btCollisionObject::AnisotropicFrictionFlags */
	public static final int
		CF_ANISOTROPIC_FRICTION_DISABLED = 0,
		CF_ANISOTROPIC_FRICTION = 1,
		CF_ANISOTROPIC_ROLLING_FRICTION = 2;

	public native @Cast("bool") boolean mergesSimulationIslands();

	public native @Const @ByRef btVector3 getAnisotropicFriction();
	public native void setAnisotropicFriction(@Const @ByRef btVector3 anisotropicFriction, int frictionMode/*=btCollisionObject::CF_ANISOTROPIC_FRICTION*/);
	public native void setAnisotropicFriction(@Const @ByRef btVector3 anisotropicFriction);
	public native @Cast("bool") boolean hasAnisotropicFriction(int frictionMode/*=btCollisionObject::CF_ANISOTROPIC_FRICTION*/);
	public native @Cast("bool") boolean hasAnisotropicFriction();

	/**the constraint solver can discard solving contacts, if the distance is above this threshold. 0 by default.
	 * Note that using contacts with positive distance can improve stability. It increases, however, the chance of colliding with degerate contacts, such as 'interior' triangle edges */
	public native void setContactProcessingThreshold(@Cast("btScalar") float contactProcessingThreshold);
	public native @Cast("btScalar") float getContactProcessingThreshold();

	public native @Cast("bool") boolean isStaticObject();

	public native @Cast("bool") boolean isKinematicObject();

	public native @Cast("bool") boolean isStaticOrKinematicObject();

	public native @Cast("bool") boolean hasContactResponse();

	public btCollisionObject() { super((Pointer)null); allocate(); }
	private native void allocate();

	public native void setCollisionShape(btCollisionShape collisionShape);

	public native btCollisionShape getCollisionShape();

	public native void setIgnoreCollisionCheck(@Const btCollisionObject co, @Cast("bool") boolean ignoreCollisionCheck);

        public native int getNumObjectsWithoutCollision();

	public native @Const btCollisionObject getObjectWithoutCollision(int index);

	public native @Cast("bool") boolean checkCollideWithOverride(@Const btCollisionObject co);

	/**Avoid using this internal API call, the extension pointer is used by some Bullet extensions.
	 * If you need to store your own user pointer, use 'setUserPointer/getUserPointer' instead. */
	public native Pointer internalGetExtensionPointer();
	/**Avoid using this internal API call, the extension pointer is used by some Bullet extensions
	 * If you need to store your own user pointer, use 'setUserPointer/getUserPointer' instead. */
	public native void internalSetExtensionPointer(Pointer pointer);

	public native int getActivationState();

	public native void setActivationState(int newState);

	public native void setDeactivationTime(@Cast("btScalar") float time);
	public native @Cast("btScalar") float getDeactivationTime();

	public native void forceActivationState(int newState);

	public native void activate(@Cast("bool") boolean forceActivation/*=false*/);
	public native void activate();

	public native @Cast("bool") boolean isActive();

	public native void setRestitution(@Cast("btScalar") float rest);
	public native @Cast("btScalar") float getRestitution();
	public native void setFriction(@Cast("btScalar") float frict);
	public native @Cast("btScalar") float getFriction();

	public native void setRollingFriction(@Cast("btScalar") float frict);
	public native @Cast("btScalar") float getRollingFriction();
	public native void setSpinningFriction(@Cast("btScalar") float frict);
	public native @Cast("btScalar") float getSpinningFriction();
	public native void setContactStiffnessAndDamping(@Cast("btScalar") float stiffness, @Cast("btScalar") float damping);

	public native @Cast("btScalar") float getContactStiffness();

	public native @Cast("btScalar") float getContactDamping();

	/**reserved for Bullet internal usage */
	public native int getInternalType();

	public native @ByRef btTransform getWorldTransform();

	public native void setWorldTransform(@Const @ByRef btTransform worldTrans);

	public native btBroadphaseProxy getBroadphaseHandle();

	public native void setBroadphaseHandle(btBroadphaseProxy handle);

	public native @ByRef btTransform getInterpolationWorldTransform();

	public native void setInterpolationWorldTransform(@Const @ByRef btTransform trans);

	public native void setInterpolationLinearVelocity(@Const @ByRef btVector3 linvel);

	public native void setInterpolationAngularVelocity(@Const @ByRef btVector3 angvel);

	public native @Const @ByRef btVector3 getInterpolationLinearVelocity();

	public native @Const @ByRef btVector3 getInterpolationAngularVelocity();

	public native int getIslandTag();

	public native void setIslandTag(int tag);

	public native int getCompanionId();

	public native void setCompanionId(int id);

	public native int getWorldArrayIndex();

	// only should be called by CollisionWorld
	public native void setWorldArrayIndex(int ix);

	public native @Cast("btScalar") float getHitFraction();

	public native void setHitFraction(@Cast("btScalar") float hitFraction);

	public native int getCollisionFlags();

	public native void setCollisionFlags(int flags);

	/**Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm:: */
	public native @Cast("btScalar") float getCcdSweptSphereRadius();

	/**Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm:: */
	public native void setCcdSweptSphereRadius(@Cast("btScalar") float radius);

	public native @Cast("btScalar") float getCcdMotionThreshold();

	public native @Cast("btScalar") float getCcdSquareMotionThreshold();

	/** Don't do continuous collision detection if the motion (in one step) is less then m_ccdMotionThreshold */
	public native void setCcdMotionThreshold(@Cast("btScalar") float ccdMotionThreshold);

	/**users can point to their objects, userPointer is not used by Bullet */
	public native Pointer getUserPointer();

	public native int getUserIndex();

	public native int getUserIndex2();

	public native int getUserIndex3();

	/**users can point to their objects, userPointer is not used by Bullet */
	public native void setUserPointer(Pointer userPointer);

	/**users can point to their objects, userPointer is not used by Bullet */
	public native void setUserIndex(int index);

	public native void setUserIndex2(int index);

	public native void setUserIndex3(int index);

	public native int getUpdateRevisionInternal();

	public native void setCustomDebugColor(@Const @ByRef btVector3 colorRGB);

	public native void removeCustomDebugColor();

	public native @Cast("bool") boolean getCustomDebugColor(@ByRef btVector3 colorRGB);

	public native @Cast("bool") boolean checkCollideWith(@Const btCollisionObject co);

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);

	public native void serializeSingleObject(btSerializer serializer);
}

// clang-format off

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btCollisionObjectDoubleData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btCollisionObjectDoubleData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btCollisionObjectDoubleData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCollisionObjectDoubleData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btCollisionObjectDoubleData position(long position) {
        return (btCollisionObjectDoubleData)super.position(position);
    }
    @Override public btCollisionObjectDoubleData getPointer(long i) {
        return new btCollisionObjectDoubleData((Pointer)this).offsetAddress(i);
    }

	public native Pointer m_broadphaseHandle(); public native btCollisionObjectDoubleData m_broadphaseHandle(Pointer setter);
	public native Pointer m_collisionShape(); public native btCollisionObjectDoubleData m_collisionShape(Pointer setter);
	public native btCollisionShapeData m_rootCollisionShape(); public native btCollisionObjectDoubleData m_rootCollisionShape(btCollisionShapeData setter);
	public native @Cast("char*") BytePointer m_name(); public native btCollisionObjectDoubleData m_name(BytePointer setter);

	public native @ByRef btTransformDoubleData m_worldTransform(); public native btCollisionObjectDoubleData m_worldTransform(btTransformDoubleData setter);
	public native @ByRef btTransformDoubleData m_interpolationWorldTransform(); public native btCollisionObjectDoubleData m_interpolationWorldTransform(btTransformDoubleData setter);
	public native @ByRef btVector3DoubleData m_interpolationLinearVelocity(); public native btCollisionObjectDoubleData m_interpolationLinearVelocity(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_interpolationAngularVelocity(); public native btCollisionObjectDoubleData m_interpolationAngularVelocity(btVector3DoubleData setter);
	public native @ByRef btVector3DoubleData m_anisotropicFriction(); public native btCollisionObjectDoubleData m_anisotropicFriction(btVector3DoubleData setter);
	public native double m_contactProcessingThreshold(); public native btCollisionObjectDoubleData m_contactProcessingThreshold(double setter);	
	public native double m_deactivationTime(); public native btCollisionObjectDoubleData m_deactivationTime(double setter);
	public native double m_friction(); public native btCollisionObjectDoubleData m_friction(double setter);
	public native double m_rollingFriction(); public native btCollisionObjectDoubleData m_rollingFriction(double setter);
	public native double m_contactDamping(); public native btCollisionObjectDoubleData m_contactDamping(double setter);
	public native double m_contactStiffness(); public native btCollisionObjectDoubleData m_contactStiffness(double setter);
	public native double m_restitution(); public native btCollisionObjectDoubleData m_restitution(double setter);
	public native double m_hitFraction(); public native btCollisionObjectDoubleData m_hitFraction(double setter); 
	public native double m_ccdSweptSphereRadius(); public native btCollisionObjectDoubleData m_ccdSweptSphereRadius(double setter);
	public native double m_ccdMotionThreshold(); public native btCollisionObjectDoubleData m_ccdMotionThreshold(double setter);
	public native int m_hasAnisotropicFriction(); public native btCollisionObjectDoubleData m_hasAnisotropicFriction(int setter);
	public native int m_collisionFlags(); public native btCollisionObjectDoubleData m_collisionFlags(int setter);
	public native int m_islandTag1(); public native btCollisionObjectDoubleData m_islandTag1(int setter);
	public native int m_companionId(); public native btCollisionObjectDoubleData m_companionId(int setter);
	public native int m_activationState1(); public native btCollisionObjectDoubleData m_activationState1(int setter);
	public native int m_internalType(); public native btCollisionObjectDoubleData m_internalType(int setter);
	public native int m_checkCollideWith(); public native btCollisionObjectDoubleData m_checkCollideWith(int setter);
	public native int m_collisionFilterGroup(); public native btCollisionObjectDoubleData m_collisionFilterGroup(int setter);
	public native int m_collisionFilterMask(); public native btCollisionObjectDoubleData m_collisionFilterMask(int setter);
	public native int m_uniqueId(); public native btCollisionObjectDoubleData m_uniqueId(int setter);//m_uniqueId is introduced for paircache. could get rid of this, by calculating the address offset etc.
}

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btCollisionObjectFloatData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btCollisionObjectFloatData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btCollisionObjectFloatData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCollisionObjectFloatData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btCollisionObjectFloatData position(long position) {
        return (btCollisionObjectFloatData)super.position(position);
    }
    @Override public btCollisionObjectFloatData getPointer(long i) {
        return new btCollisionObjectFloatData((Pointer)this).offsetAddress(i);
    }

	public native Pointer m_broadphaseHandle(); public native btCollisionObjectFloatData m_broadphaseHandle(Pointer setter);
	public native Pointer m_collisionShape(); public native btCollisionObjectFloatData m_collisionShape(Pointer setter);
	public native btCollisionShapeData m_rootCollisionShape(); public native btCollisionObjectFloatData m_rootCollisionShape(btCollisionShapeData setter);
	public native @Cast("char*") BytePointer m_name(); public native btCollisionObjectFloatData m_name(BytePointer setter);

	public native @ByRef btTransformFloatData m_worldTransform(); public native btCollisionObjectFloatData m_worldTransform(btTransformFloatData setter);
	public native @ByRef btTransformFloatData m_interpolationWorldTransform(); public native btCollisionObjectFloatData m_interpolationWorldTransform(btTransformFloatData setter);
	public native @ByRef btVector3FloatData m_interpolationLinearVelocity(); public native btCollisionObjectFloatData m_interpolationLinearVelocity(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_interpolationAngularVelocity(); public native btCollisionObjectFloatData m_interpolationAngularVelocity(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_anisotropicFriction(); public native btCollisionObjectFloatData m_anisotropicFriction(btVector3FloatData setter);
	public native float m_contactProcessingThreshold(); public native btCollisionObjectFloatData m_contactProcessingThreshold(float setter);	
	public native float m_deactivationTime(); public native btCollisionObjectFloatData m_deactivationTime(float setter);
	public native float m_friction(); public native btCollisionObjectFloatData m_friction(float setter);
	public native float m_rollingFriction(); public native btCollisionObjectFloatData m_rollingFriction(float setter);
	public native float m_contactDamping(); public native btCollisionObjectFloatData m_contactDamping(float setter);
    public native float m_contactStiffness(); public native btCollisionObjectFloatData m_contactStiffness(float setter);
	public native float m_restitution(); public native btCollisionObjectFloatData m_restitution(float setter);
	public native float m_hitFraction(); public native btCollisionObjectFloatData m_hitFraction(float setter); 
	public native float m_ccdSweptSphereRadius(); public native btCollisionObjectFloatData m_ccdSweptSphereRadius(float setter);
	public native float m_ccdMotionThreshold(); public native btCollisionObjectFloatData m_ccdMotionThreshold(float setter);
	public native int m_hasAnisotropicFriction(); public native btCollisionObjectFloatData m_hasAnisotropicFriction(int setter);
	public native int m_collisionFlags(); public native btCollisionObjectFloatData m_collisionFlags(int setter);
	public native int m_islandTag1(); public native btCollisionObjectFloatData m_islandTag1(int setter);
	public native int m_companionId(); public native btCollisionObjectFloatData m_companionId(int setter);
	public native int m_activationState1(); public native btCollisionObjectFloatData m_activationState1(int setter);
	public native int m_internalType(); public native btCollisionObjectFloatData m_internalType(int setter);
	public native int m_checkCollideWith(); public native btCollisionObjectFloatData m_checkCollideWith(int setter);
	public native int m_collisionFilterGroup(); public native btCollisionObjectFloatData m_collisionFilterGroup(int setter);
	public native int m_collisionFilterMask(); public native btCollisionObjectFloatData m_collisionFilterMask(int setter);
	public native int m_uniqueId(); public native btCollisionObjectFloatData m_uniqueId(int setter);
}
// clang-format on



// #endif  //BT_COLLISION_OBJECT_H


// Parsed from BulletCollision/CollisionDispatch/btCollisionCreateFunc.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_COLLISION_CREATE_FUNC
// #define BT_COLLISION_CREATE_FUNC

// #include "LinearMath/btAlignedObjectArray.h"
@Opaque public static class btCollisionAlgorithmConstructionInfo extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public btCollisionAlgorithmConstructionInfo() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCollisionAlgorithmConstructionInfo(Pointer p) { super(p); }
}

/**Used by the btCollisionDispatcher to register and create instances for btCollisionAlgorithm */
@NoOffset public static class btCollisionAlgorithmCreateFunc extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCollisionAlgorithmCreateFunc(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btCollisionAlgorithmCreateFunc(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btCollisionAlgorithmCreateFunc position(long position) {
        return (btCollisionAlgorithmCreateFunc)super.position(position);
    }
    @Override public btCollisionAlgorithmCreateFunc getPointer(long i) {
        return new btCollisionAlgorithmCreateFunc((Pointer)this).offsetAddress(i);
    }

	public native @Cast("bool") boolean m_swapped(); public native btCollisionAlgorithmCreateFunc m_swapped(boolean setter);

	public btCollisionAlgorithmCreateFunc() { super((Pointer)null); allocate(); }
	private native void allocate();

	public native btCollisionAlgorithm CreateCollisionAlgorithm(@ByRef btCollisionAlgorithmConstructionInfo arg0, @Const btCollisionObjectWrapper body0Wrap, @Const btCollisionObjectWrapper body1Wrap);
}
// #endif  //BT_COLLISION_CREATE_FUNC


// Parsed from BulletCollision/CollisionDispatch/btCollisionDispatcher.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_COLLISION__DISPATCHER_H
// #define BT_COLLISION__DISPATCHER_H

// #include "BulletCollision/BroadphaseCollision/btDispatcher.h"
// #include "BulletCollision/NarrowPhaseCollision/btPersistentManifold.h"

// #include "BulletCollision/CollisionDispatch/btManifoldResult.h"

// #include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
// #include "LinearMath/btAlignedObjectArray.h"
@Opaque public static class btCollisionConfiguration extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public btCollisionConfiguration() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCollisionConfiguration(Pointer p) { super(p); }
}

// #include "btCollisionCreateFunc.h"

public static final int USE_DISPATCH_REGISTRY_ARRAY = 1;
/**user can override this nearcallback for collision filtering and more finegrained control over collision detection */
public static class btNearCallback extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    btNearCallback(Pointer p) { super(p); }
    protected btNearCallback() { allocate(); }
    private native void allocate();
    public native void call(@ByRef btBroadphasePair collisionPair, @ByRef btCollisionDispatcher dispatcher, @Const @ByRef btDispatcherInfo dispatchInfo);
}

/**btCollisionDispatcher supports algorithms that handle ConvexConvex and ConvexConcave collision pairs.
 * Time of Impact, Closest Points and Penetration Depth. */
@NoOffset public static class btCollisionDispatcher extends btDispatcher {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCollisionDispatcher(Pointer p) { super(p); }

	/** enum btCollisionDispatcher::DispatcherFlags */
	public static final int
		CD_STATIC_STATIC_REPORTED = 1,
		CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD = 2,
		CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION = 4;

	public native int getDispatcherFlags();

	public native void setDispatcherFlags(int flags);

	/**registerCollisionCreateFunc allows registration of custom/alternative collision create functions */
	public native void registerCollisionCreateFunc(int proxyType0, int proxyType1, btCollisionAlgorithmCreateFunc createFunc);

	public native void registerClosestPointsCreateFunc(int proxyType0, int proxyType1, btCollisionAlgorithmCreateFunc createFunc);

	public native int getNumManifolds();

	public native @Cast("btPersistentManifold**") PointerPointer getInternalManifoldPointer();

	public native btPersistentManifold getManifoldByIndexInternal(int index);

	public btCollisionDispatcher(btCollisionConfiguration collisionConfiguration) { super((Pointer)null); allocate(collisionConfiguration); }
	private native void allocate(btCollisionConfiguration collisionConfiguration);

	public native btPersistentManifold getNewManifold(@Const btCollisionObject b0, @Const btCollisionObject b1);

	public native void releaseManifold(btPersistentManifold manifold);

	public native void clearManifold(btPersistentManifold manifold);

	public native btCollisionAlgorithm findAlgorithm(@Const btCollisionObjectWrapper body0Wrap, @Const btCollisionObjectWrapper body1Wrap, btPersistentManifold sharedManifold, @Cast("ebtDispatcherQueryType") int queryType);

	public native @Cast("bool") boolean needsCollision(@Const btCollisionObject body0, @Const btCollisionObject body1);

	public native @Cast("bool") boolean needsResponse(@Const btCollisionObject body0, @Const btCollisionObject body1);

	public native void dispatchAllCollisionPairs(btOverlappingPairCache pairCache, @Const @ByRef btDispatcherInfo dispatchInfo, btDispatcher dispatcher);

	public native void setNearCallback(btNearCallback nearCallback);

	public native btNearCallback getNearCallback();

	//by default, Bullet will use this near callback
	public static native void defaultNearCallback(@ByRef btBroadphasePair collisionPair, @ByRef btCollisionDispatcher dispatcher, @Const @ByRef btDispatcherInfo dispatchInfo);

	public native Pointer allocateCollisionAlgorithm(int size);

	public native void freeCollisionAlgorithm(Pointer ptr);

	public native btCollisionConfiguration getCollisionConfiguration();

	public native void setCollisionConfiguration(btCollisionConfiguration config);

	public native btPoolAllocator getInternalManifoldPool();
}

// #endif  //BT_COLLISION__DISPATCHER_H


// Parsed from BulletCollision/CollisionDispatch/btCollisionWorld.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2013 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/**
 * \mainpage Bullet Documentation
 *
 * \section intro_sec Introduction
 * Bullet is a Collision Detection and Rigid Body Dynamics Library. The Library is Open Source and free for commercial use, under the ZLib license ( http://opensource.org/licenses/zlib-license.php ).
 *
 * The main documentation is Bullet_User_Manual.pdf, included in the source code distribution.
 * There is the Physics Forum for feedback and general Collision Detection and Physics discussions.
 * Please visit http://www.bulletphysics.org
 *
 * \section install_sec Installation
 *
 * \subsection step1 Step 1: Download
 * You can download the Bullet Physics Library from the github repository: https://github.com/bulletphysics/bullet3/releases 
 *
 * \subsection step2 Step 2: Building
 * Bullet has multiple build systems, including premake, cmake and autotools. Premake and cmake support all platforms.
 * Premake is included in the Bullet/build folder for Windows, Mac OSX and Linux. 
 * Under Windows you can click on Bullet/build/vs2010.bat to create Microsoft Visual Studio projects. 
 * On Mac OSX and Linux you can open a terminal and generate Makefile, codeblocks or Xcode4 projects:
 * cd Bullet/build
 * ./premake4_osx gmake or ./premake4_linux gmake or ./premake4_linux64 gmake or (for Mac) ./premake4_osx xcode4
 * cd Bullet/build/gmake
 * make
 * 
 * An alternative to premake is cmake. You can download cmake from http://www.cmake.org
 * cmake can autogenerate projectfiles for Microsoft Visual Studio, Apple Xcode, KDevelop and Unix Makefiles.
 * The easiest is to run the CMake cmake-gui graphical user interface and choose the options and generate projectfiles.
 * You can also use cmake in the command-line. Here are some examples for various platforms:
 * cmake . -G "Visual Studio 9 2008"
 * cmake . -G Xcode
 * cmake . -G "Unix Makefiles"
 * Although cmake is recommended, you can also use autotools for UNIX: ./autogen.sh ./configure to create a Makefile and then run make.
 * 
 * \subsection step3 Step 3: Testing demos
 * Try to run and experiment with BasicDemo executable as a starting point.
 * Bullet can be used in several ways, as Full Rigid Body simulation, as Collision Detector Library or Low Level / Snippets like the GJK Closest Point calculation.
 * The Dependencies can be seen in this documentation under Directories
 * 
 * \subsection step4 Step 4: Integrating in your application, full Rigid Body and Soft Body simulation
 * Check out BasicDemo how to create a btDynamicsWorld, btRigidBody and btCollisionShape, Stepping the simulation and synchronizing your graphics object transform.
 * Check out SoftDemo how to use soft body dynamics, using btSoftRigidDynamicsWorld.
 * \subsection step5 Step 5 : Integrate the Collision Detection Library (without Dynamics and other Extras)
 * Bullet Collision Detection can also be used without the Dynamics/Extras.
 * Check out btCollisionWorld and btCollisionObject, and the CollisionInterfaceDemo.
 * \subsection step6 Step 6 : Use Snippets like the GJK Closest Point calculation.
 * Bullet has been designed in a modular way keeping dependencies to a minimum. The ConvexHullDistance demo demonstrates direct use of btGjkPairDetector.
 *
 * \section copyright Copyright
 * For up-to-data information and copyright and contributors list check out the Bullet_User_Manual.pdf
 * 
 */

// #ifndef BT_COLLISION_WORLD_H
// #define BT_COLLISION_WORLD_H
@Opaque public static class btConvexShape extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public btConvexShape() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConvexShape(Pointer p) { super(p); }
}

// #include "LinearMath/btVector3.h"
// #include "LinearMath/btTransform.h"
// #include "btCollisionObject.h"
// #include "btCollisionDispatcher.h"
// #include "BulletCollision/BroadphaseCollision/btOverlappingPairCache.h"
// #include "LinearMath/btAlignedObjectArray.h"

/**CollisionWorld is interface and container for the collision detection */
@NoOffset public static class btCollisionWorld extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCollisionWorld(Pointer p) { super(p); }

	//this constructor doesn't own the dispatcher and paircache/broadphase
	public btCollisionWorld(btDispatcher dispatcher, btBroadphaseInterface broadphasePairCache, btCollisionConfiguration collisionConfiguration) { super((Pointer)null); allocate(dispatcher, broadphasePairCache, collisionConfiguration); }
	private native void allocate(btDispatcher dispatcher, btBroadphaseInterface broadphasePairCache, btCollisionConfiguration collisionConfiguration);

	public native void setBroadphase(btBroadphaseInterface pairCache);

	public native btBroadphaseInterface getBroadphase();

	public native btOverlappingPairCache getPairCache();

	public native btDispatcher getDispatcher();

	public native void updateSingleAabb(btCollisionObject colObj);

	public native void updateAabbs();

	/**the computeOverlappingPairs is usually already called by performDiscreteCollisionDetection (or stepSimulation)
	 * it can be useful to use if you perform ray tests without collision detection/simulation */
	public native void computeOverlappingPairs();

	public native void setDebugDrawer(btIDebugDraw debugDrawer);

	public native btIDebugDraw getDebugDrawer();

	public native void debugDrawWorld();

	public native void debugDrawObject(@Const @ByRef btTransform worldTransform, @Const btCollisionShape shape, @Const @ByRef btVector3 color);

	/**LocalShapeInfo gives extra information for complex shapes
	 * Currently, only btTriangleMeshShape is available, so it just contains triangleIndex and subpart */
	public static class LocalShapeInfo extends Pointer {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public LocalShapeInfo() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public LocalShapeInfo(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public LocalShapeInfo(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public LocalShapeInfo position(long position) {
	        return (LocalShapeInfo)super.position(position);
	    }
	    @Override public LocalShapeInfo getPointer(long i) {
	        return new LocalShapeInfo((Pointer)this).offsetAddress(i);
	    }
	
		public native int m_shapePart(); public native LocalShapeInfo m_shapePart(int setter);
		public native int m_triangleIndex(); public native LocalShapeInfo m_triangleIndex(int setter);

		//const btCollisionShape*	m_shapeTemp;
		//const btTransform*	m_shapeLocalTransform;
	}

	@NoOffset public static class LocalRayResult extends Pointer {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public LocalRayResult(Pointer p) { super(p); }
	
		public LocalRayResult(@Const btCollisionObject collisionObject,
							   LocalShapeInfo localShapeInfo,
							   @Const @ByRef btVector3 hitNormalLocal,
							   @Cast("btScalar") float hitFraction) { super((Pointer)null); allocate(collisionObject, localShapeInfo, hitNormalLocal, hitFraction); }
		private native void allocate(@Const btCollisionObject collisionObject,
							   LocalShapeInfo localShapeInfo,
							   @Const @ByRef btVector3 hitNormalLocal,
							   @Cast("btScalar") float hitFraction);

		public native @Const btCollisionObject m_collisionObject(); public native LocalRayResult m_collisionObject(btCollisionObject setter);
		public native LocalShapeInfo m_localShapeInfo(); public native LocalRayResult m_localShapeInfo(LocalShapeInfo setter);
		public native @ByRef btVector3 m_hitNormalLocal(); public native LocalRayResult m_hitNormalLocal(btVector3 setter);
		public native @Cast("btScalar") float m_hitFraction(); public native LocalRayResult m_hitFraction(float setter);
	}

	/**RayResultCallback is used to report new raycast results */
	@NoOffset public static class RayResultCallback extends Pointer {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public RayResultCallback(Pointer p) { super(p); }
	
		public native @Cast("btScalar") float m_closestHitFraction(); public native RayResultCallback m_closestHitFraction(float setter);
		public native @Const btCollisionObject m_collisionObject(); public native RayResultCallback m_collisionObject(btCollisionObject setter);
		public native int m_collisionFilterGroup(); public native RayResultCallback m_collisionFilterGroup(int setter);
		public native int m_collisionFilterMask(); public native RayResultCallback m_collisionFilterMask(int setter);
		//@BP Mod - Custom flags, currently used to enable backface culling on tri-meshes, see btRaycastCallback.h. Apply any of the EFlags defined there on m_flags here to invoke.
		public native @Cast("unsigned int") int m_flags(); public native RayResultCallback m_flags(int setter);
		public native @Cast("bool") boolean hasHit();

		public native @Cast("bool") boolean needsCollision(btBroadphaseProxy proxy0);

		public native @Cast("btScalar") float addSingleResult(@ByRef LocalRayResult rayResult, @Cast("bool") boolean normalInWorldSpace);
	}

	@NoOffset public static class ClosestRayResultCallback extends RayResultCallback {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public ClosestRayResultCallback(Pointer p) { super(p); }
	
		public ClosestRayResultCallback(@Const @ByRef btVector3 rayFromWorld, @Const @ByRef btVector3 rayToWorld) { super((Pointer)null); allocate(rayFromWorld, rayToWorld); }
		private native void allocate(@Const @ByRef btVector3 rayFromWorld, @Const @ByRef btVector3 rayToWorld);

		public native @ByRef btVector3 m_rayFromWorld(); public native ClosestRayResultCallback m_rayFromWorld(btVector3 setter);  //used to calculate hitPointWorld from hitFraction
		public native @ByRef btVector3 m_rayToWorld(); public native ClosestRayResultCallback m_rayToWorld(btVector3 setter);

		public native @ByRef btVector3 m_hitNormalWorld(); public native ClosestRayResultCallback m_hitNormalWorld(btVector3 setter);
		public native @ByRef btVector3 m_hitPointWorld(); public native ClosestRayResultCallback m_hitPointWorld(btVector3 setter);

		public native @Cast("btScalar") float addSingleResult(@ByRef LocalRayResult rayResult, @Cast("bool") boolean normalInWorldSpace);
	}

	@NoOffset public static class AllHitsRayResultCallback extends RayResultCallback {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public AllHitsRayResultCallback(Pointer p) { super(p); }
	
		public AllHitsRayResultCallback(@Const @ByRef btVector3 rayFromWorld, @Const @ByRef btVector3 rayToWorld) { super((Pointer)null); allocate(rayFromWorld, rayToWorld); }
		private native void allocate(@Const @ByRef btVector3 rayFromWorld, @Const @ByRef btVector3 rayToWorld);

		

		public native @ByRef btVector3 m_rayFromWorld(); public native AllHitsRayResultCallback m_rayFromWorld(btVector3 setter);  //used to calculate hitPointWorld from hitFraction
		public native @ByRef btVector3 m_rayToWorld(); public native AllHitsRayResultCallback m_rayToWorld(btVector3 setter);

		public native @ByRef btAlignedObjectArray_btVector3 m_hitNormalWorld(); public native AllHitsRayResultCallback m_hitNormalWorld(btAlignedObjectArray_btVector3 setter);
		public native @ByRef btAlignedObjectArray_btVector3 m_hitPointWorld(); public native AllHitsRayResultCallback m_hitPointWorld(btAlignedObjectArray_btVector3 setter);
		public native @ByRef btAlignedObjectArray_btScalar m_hitFractions(); public native AllHitsRayResultCallback m_hitFractions(btAlignedObjectArray_btScalar setter);

		public native @Cast("btScalar") float addSingleResult(@ByRef LocalRayResult rayResult, @Cast("bool") boolean normalInWorldSpace);
	}

	@NoOffset public static class LocalConvexResult extends Pointer {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public LocalConvexResult(Pointer p) { super(p); }
	
		public LocalConvexResult(@Const btCollisionObject hitCollisionObject,
								  LocalShapeInfo localShapeInfo,
								  @Const @ByRef btVector3 hitNormalLocal,
								  @Const @ByRef btVector3 hitPointLocal,
								  @Cast("btScalar") float hitFraction) { super((Pointer)null); allocate(hitCollisionObject, localShapeInfo, hitNormalLocal, hitPointLocal, hitFraction); }
		private native void allocate(@Const btCollisionObject hitCollisionObject,
								  LocalShapeInfo localShapeInfo,
								  @Const @ByRef btVector3 hitNormalLocal,
								  @Const @ByRef btVector3 hitPointLocal,
								  @Cast("btScalar") float hitFraction);

		public native @Const btCollisionObject m_hitCollisionObject(); public native LocalConvexResult m_hitCollisionObject(btCollisionObject setter);
		public native LocalShapeInfo m_localShapeInfo(); public native LocalConvexResult m_localShapeInfo(LocalShapeInfo setter);
		public native @ByRef btVector3 m_hitNormalLocal(); public native LocalConvexResult m_hitNormalLocal(btVector3 setter);
		public native @ByRef btVector3 m_hitPointLocal(); public native LocalConvexResult m_hitPointLocal(btVector3 setter);
		public native @Cast("btScalar") float m_hitFraction(); public native LocalConvexResult m_hitFraction(float setter);
	}

	/**RayResultCallback is used to report new raycast results */
	@NoOffset public static class ConvexResultCallback extends Pointer {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public ConvexResultCallback(Pointer p) { super(p); }
	
		public native @Cast("btScalar") float m_closestHitFraction(); public native ConvexResultCallback m_closestHitFraction(float setter);
		public native int m_collisionFilterGroup(); public native ConvexResultCallback m_collisionFilterGroup(int setter);
		public native int m_collisionFilterMask(); public native ConvexResultCallback m_collisionFilterMask(int setter);

		public native @Cast("bool") boolean hasHit();

		public native @Cast("bool") boolean needsCollision(btBroadphaseProxy proxy0);

		public native @Cast("btScalar") float addSingleResult(@ByRef LocalConvexResult convexResult, @Cast("bool") boolean normalInWorldSpace);
	}

	@NoOffset public static class ClosestConvexResultCallback extends ConvexResultCallback {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public ClosestConvexResultCallback(Pointer p) { super(p); }
	
		public ClosestConvexResultCallback(@Const @ByRef btVector3 convexFromWorld, @Const @ByRef btVector3 convexToWorld) { super((Pointer)null); allocate(convexFromWorld, convexToWorld); }
		private native void allocate(@Const @ByRef btVector3 convexFromWorld, @Const @ByRef btVector3 convexToWorld);

		public native @ByRef btVector3 m_convexFromWorld(); public native ClosestConvexResultCallback m_convexFromWorld(btVector3 setter);  //used to calculate hitPointWorld from hitFraction
		public native @ByRef btVector3 m_convexToWorld(); public native ClosestConvexResultCallback m_convexToWorld(btVector3 setter);

		public native @ByRef btVector3 m_hitNormalWorld(); public native ClosestConvexResultCallback m_hitNormalWorld(btVector3 setter);
		public native @ByRef btVector3 m_hitPointWorld(); public native ClosestConvexResultCallback m_hitPointWorld(btVector3 setter);
		public native @Const btCollisionObject m_hitCollisionObject(); public native ClosestConvexResultCallback m_hitCollisionObject(btCollisionObject setter);

		public native @Cast("btScalar") float addSingleResult(@ByRef LocalConvexResult convexResult, @Cast("bool") boolean normalInWorldSpace);
	}

	/**ContactResultCallback is used to report contact points */
	@NoOffset public static class ContactResultCallback extends Pointer {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public ContactResultCallback(Pointer p) { super(p); }
	
		public native int m_collisionFilterGroup(); public native ContactResultCallback m_collisionFilterGroup(int setter);
		public native int m_collisionFilterMask(); public native ContactResultCallback m_collisionFilterMask(int setter);
		public native @Cast("btScalar") float m_closestDistanceThreshold(); public native ContactResultCallback m_closestDistanceThreshold(float setter);

		public native @Cast("bool") boolean needsCollision(btBroadphaseProxy proxy0);

		public native @Cast("btScalar") float addSingleResult(@ByRef btManifoldPoint cp, @Const btCollisionObjectWrapper colObj0Wrap, int partId0, int index0, @Const btCollisionObjectWrapper colObj1Wrap, int partId1, int index1);
	}

	public native int getNumCollisionObjects();

	/** rayTest performs a raycast on all objects in the btCollisionWorld, and calls the resultCallback
	 *  This allows for several queries: first hit, all hits, any hit, dependent on the value returned by the callback. */
	public native void rayTest(@Const @ByRef btVector3 rayFromWorld, @Const @ByRef btVector3 rayToWorld, @ByRef RayResultCallback resultCallback);

	/** convexTest performs a swept convex cast on all objects in the btCollisionWorld, and calls the resultCallback
	 *  This allows for several queries: first hit, all hits, any hit, dependent on the value return by the callback. */
	public native void convexSweepTest(@Const btConvexShape castShape, @Const @ByRef btTransform from, @Const @ByRef btTransform to, @ByRef ConvexResultCallback resultCallback, @Cast("btScalar") float allowedCcdPenetration/*=btScalar(0.)*/);
	public native void convexSweepTest(@Const btConvexShape castShape, @Const @ByRef btTransform from, @Const @ByRef btTransform to, @ByRef ConvexResultCallback resultCallback);

	/**contactTest performs a discrete collision test between colObj against all objects in the btCollisionWorld, and calls the resultCallback.
	 * it reports one or more contact points for every overlapping object (including the one with deepest penetration) */
	public native void contactTest(btCollisionObject colObj, @ByRef ContactResultCallback resultCallback);

	/**contactTest performs a discrete collision test between two collision objects and calls the resultCallback if overlap if detected.
	 * it reports one or more contact points (including the one with deepest penetration) */
	public native void contactPairTest(btCollisionObject colObjA, btCollisionObject colObjB, @ByRef ContactResultCallback resultCallback);

	/** rayTestSingle performs a raycast call and calls the resultCallback. It is used internally by rayTest.
	 *  In a future implementation, we consider moving the ray test as a virtual method in btCollisionShape.
	 *  This allows more customization. */
	public static native void rayTestSingle(@Const @ByRef btTransform rayFromTrans, @Const @ByRef btTransform rayToTrans,
								  btCollisionObject collisionObject,
								  @Const btCollisionShape collisionShape,
								  @Const @ByRef btTransform colObjWorldTransform,
								  @ByRef RayResultCallback resultCallback);

	public static native void rayTestSingleInternal(@Const @ByRef btTransform rayFromTrans, @Const @ByRef btTransform rayToTrans,
										  @Const btCollisionObjectWrapper collisionObjectWrap,
										  @ByRef RayResultCallback resultCallback);

	/** objectQuerySingle performs a collision detection query and calls the resultCallback. It is used internally by rayTest. */
	public static native void objectQuerySingle(@Const btConvexShape castShape, @Const @ByRef btTransform rayFromTrans, @Const @ByRef btTransform rayToTrans,
									  btCollisionObject collisionObject,
									  @Const btCollisionShape collisionShape,
									  @Const @ByRef btTransform colObjWorldTransform,
									  @ByRef ConvexResultCallback resultCallback, @Cast("btScalar") float allowedPenetration);

	public static native void objectQuerySingleInternal(@Const btConvexShape castShape, @Const @ByRef btTransform convexFromTrans, @Const @ByRef btTransform convexToTrans,
											  @Const btCollisionObjectWrapper colObjWrap,
											  @ByRef ConvexResultCallback resultCallback, @Cast("btScalar") float allowedPenetration);

	public native void addCollisionObject(btCollisionObject collisionObject, int collisionFilterGroup/*=btBroadphaseProxy::DefaultFilter*/, int collisionFilterMask/*=btBroadphaseProxy::AllFilter*/);
	public native void addCollisionObject(btCollisionObject collisionObject);

	public native void refreshBroadphaseProxy(btCollisionObject collisionObject);

	public native @Cast("btCollisionObjectArray*") @ByRef btAlignedObjectArray_btVector3 getCollisionObjectArray();

	public native void removeCollisionObject(btCollisionObject collisionObject);

	public native void performDiscreteCollisionDetection();

	public native @ByRef btDispatcherInfo getDispatchInfo();

	public native @Cast("bool") boolean getForceUpdateAllAabbs();
	public native void setForceUpdateAllAabbs(@Cast("bool") boolean forceUpdateAllAabbs);

	/**Preliminary serialization test for Bullet 2.76. Loading those files requires a separate parser (Bullet/Demos/SerializeDemo) */
	public native void serialize(btSerializer serializer);
}

// #endif  //BT_COLLISION_WORLD_H


// Parsed from BulletCollision/CollisionDispatch/btManifoldResult.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_MANIFOLD_RESULT_H
// #define BT_MANIFOLD_RESULT_H

// #include "BulletCollision/NarrowPhaseCollision/btPersistentManifold.h"

// #include "BulletCollision/NarrowPhaseCollision/btDiscreteCollisionDetectorInterface.h"

// #include "LinearMath/btTransform.h"
// #include "BulletCollision/CollisionDispatch/btCollisionObjectWrapper.h"
// #include "BulletCollision/CollisionDispatch/btCollisionObject.h"

public static class ContactAddedCallback extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    ContactAddedCallback(Pointer p) { super(p); }
    protected ContactAddedCallback() { allocate(); }
    private native void allocate();
    public native @Cast("bool") boolean call(@ByRef btManifoldPoint cp, @Const btCollisionObjectWrapper colObj0Wrap, int partId0, int index0, @Const btCollisionObjectWrapper colObj1Wrap, int partId1, int index1);
}
public static native ContactAddedCallback gContactAddedCallback(); public static native void gContactAddedCallback(ContactAddedCallback setter);

//#define DEBUG_PART_INDEX 1

/** These callbacks are used to customize the algorith that combine restitution, friction, damping, Stiffness */
public static class CalculateCombinedCallback extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    CalculateCombinedCallback(Pointer p) { super(p); }
    protected CalculateCombinedCallback() { allocate(); }
    private native void allocate();
    public native @Cast("btScalar") float call(@Const btCollisionObject body0, @Const btCollisionObject body1);
}

public static native CalculateCombinedCallback gCalculateCombinedRestitutionCallback(); public static native void gCalculateCombinedRestitutionCallback(CalculateCombinedCallback setter);
public static native CalculateCombinedCallback gCalculateCombinedFrictionCallback(); public static native void gCalculateCombinedFrictionCallback(CalculateCombinedCallback setter);
public static native CalculateCombinedCallback gCalculateCombinedRollingFrictionCallback(); public static native void gCalculateCombinedRollingFrictionCallback(CalculateCombinedCallback setter);
public static native CalculateCombinedCallback gCalculateCombinedSpinningFrictionCallback(); public static native void gCalculateCombinedSpinningFrictionCallback(CalculateCombinedCallback setter);
public static native CalculateCombinedCallback gCalculateCombinedContactDampingCallback(); public static native void gCalculateCombinedContactDampingCallback(CalculateCombinedCallback setter);
public static native CalculateCombinedCallback gCalculateCombinedContactStiffnessCallback(); public static native void gCalculateCombinedContactStiffnessCallback(CalculateCombinedCallback setter);

/**btManifoldResult is a helper class to manage  contact results. */
@NoOffset public static class btManifoldResult extends btDiscreteCollisionDetectorInterface.Result {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btManifoldResult(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btManifoldResult(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btManifoldResult position(long position) {
        return (btManifoldResult)super.position(position);
    }
    @Override public btManifoldResult getPointer(long i) {
        return new btManifoldResult((Pointer)this).offsetAddress(i);
    }

	public btManifoldResult() { super((Pointer)null); allocate(); }
	private native void allocate();

	public btManifoldResult(@Const btCollisionObjectWrapper body0Wrap, @Const btCollisionObjectWrapper body1Wrap) { super((Pointer)null); allocate(body0Wrap, body1Wrap); }
	private native void allocate(@Const btCollisionObjectWrapper body0Wrap, @Const btCollisionObjectWrapper body1Wrap);

	public native void setPersistentManifold(btPersistentManifold manifoldPtr);
	public native btPersistentManifold getPersistentManifold();

	public native void setShapeIdentifiersA(int partId0, int index0);

	public native void setShapeIdentifiersB(int partId1, int index1);

	public native void addContactPoint(@Const @ByRef btVector3 normalOnBInWorld, @Const @ByRef btVector3 pointInWorld, @Cast("btScalar") float depth);

	public native void refreshContactPoints();

	public native @Const btCollisionObjectWrapper getBody0Wrap();
	public native @Const btCollisionObjectWrapper getBody1Wrap();

	public native void setBody0Wrap(@Const btCollisionObjectWrapper obj0Wrap);

	public native void setBody1Wrap(@Const btCollisionObjectWrapper obj1Wrap);

	public native @Const btCollisionObject getBody0Internal();

	public native @Const btCollisionObject getBody1Internal();

	public native @Cast("btScalar") float m_closestPointDistanceThreshold(); public native btManifoldResult m_closestPointDistanceThreshold(float setter);

	/** in the future we can let the user override the methods to combine restitution and friction */
	public static native @Cast("btScalar") float calculateCombinedRestitution(@Const btCollisionObject body0, @Const btCollisionObject body1);
	public static native @Cast("btScalar") float calculateCombinedFriction(@Const btCollisionObject body0, @Const btCollisionObject body1);
	public static native @Cast("btScalar") float calculateCombinedRollingFriction(@Const btCollisionObject body0, @Const btCollisionObject body1);
	public static native @Cast("btScalar") float calculateCombinedSpinningFriction(@Const btCollisionObject body0, @Const btCollisionObject body1);
	public static native @Cast("btScalar") float calculateCombinedContactDamping(@Const btCollisionObject body0, @Const btCollisionObject body1);
	public static native @Cast("btScalar") float calculateCombinedContactStiffness(@Const btCollisionObject body0, @Const btCollisionObject body1);
}

// #endif  //BT_MANIFOLD_RESULT_H


// Parsed from BulletCollision/CollisionDispatch/btActivatingCollisionAlgorithm.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2008 Erwin Coumans  http://bulletphysics.com

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef __BT_ACTIVATING_COLLISION_ALGORITHM_H
// #define __BT_ACTIVATING_COLLISION_ALGORITHM_H

// #include "BulletCollision/BroadphaseCollision/btCollisionAlgorithm.h"

/**This class is not enabled yet (work-in-progress) to more aggressively activate objects. */
public static class btActivatingCollisionAlgorithm extends btCollisionAlgorithm {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btActivatingCollisionAlgorithm(Pointer p) { super(p); }

}
// #endif  //__BT_ACTIVATING_COLLISION_ALGORITHM_H


// Parsed from BulletCollision/CollisionDispatch/btSphereSphereCollisionAlgorithm.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_SPHERE_SPHERE_COLLISION_ALGORITHM_H
// #define BT_SPHERE_SPHERE_COLLISION_ALGORITHM_H

// #include "btActivatingCollisionAlgorithm.h"
// #include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
// #include "BulletCollision/CollisionDispatch/btCollisionCreateFunc.h"
// #include "btCollisionDispatcher.h"

/** btSphereSphereCollisionAlgorithm  provides sphere-sphere collision detection.
 *  Other features are frame-coherency (persistent data) and collision response.
 *  Also provides the most basic sample for custom/user btCollisionAlgorithm */
@NoOffset public static class btSphereSphereCollisionAlgorithm extends btActivatingCollisionAlgorithm {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btSphereSphereCollisionAlgorithm(Pointer p) { super(p); }

	public btSphereSphereCollisionAlgorithm(btPersistentManifold mf, @Const @ByRef btCollisionAlgorithmConstructionInfo ci, @Const btCollisionObjectWrapper col0Wrap, @Const btCollisionObjectWrapper col1Wrap) { super((Pointer)null); allocate(mf, ci, col0Wrap, col1Wrap); }
	private native void allocate(btPersistentManifold mf, @Const @ByRef btCollisionAlgorithmConstructionInfo ci, @Const btCollisionObjectWrapper col0Wrap, @Const btCollisionObjectWrapper col1Wrap);

	public btSphereSphereCollisionAlgorithm(@Const @ByRef btCollisionAlgorithmConstructionInfo ci) { super((Pointer)null); allocate(ci); }
	private native void allocate(@Const @ByRef btCollisionAlgorithmConstructionInfo ci);

	public native void processCollision(@Const btCollisionObjectWrapper body0Wrap, @Const btCollisionObjectWrapper body1Wrap, @Const @ByRef btDispatcherInfo dispatchInfo, btManifoldResult resultOut);

	public native @Cast("btScalar") float calculateTimeOfImpact(btCollisionObject body0, btCollisionObject body1, @Const @ByRef btDispatcherInfo dispatchInfo, btManifoldResult resultOut);

	

	public static class CreateFunc extends btCollisionAlgorithmCreateFunc {
	    static { Loader.load(); }
	    /** Default native constructor. */
	    public CreateFunc() { super((Pointer)null); allocate(); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public CreateFunc(long size) { super((Pointer)null); allocateArray(size); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public CreateFunc(Pointer p) { super(p); }
	    private native void allocate();
	    private native void allocateArray(long size);
	    @Override public CreateFunc position(long position) {
	        return (CreateFunc)super.position(position);
	    }
	    @Override public CreateFunc getPointer(long i) {
	        return new CreateFunc((Pointer)this).offsetAddress(i);
	    }
	
		public native btCollisionAlgorithm CreateCollisionAlgorithm(@ByRef btCollisionAlgorithmConstructionInfo ci, @Const btCollisionObjectWrapper col0Wrap, @Const btCollisionObjectWrapper col1Wrap);
	}
}

// #endif  //BT_SPHERE_SPHERE_COLLISION_ALGORITHM_H


// Parsed from BulletCollision/CollisionDispatch/btDefaultCollisionConfiguration.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_DEFAULT_COLLISION_CONFIGURATION
// #define BT_DEFAULT_COLLISION_CONFIGURATION

// #include "btCollisionConfiguration.h"
@Opaque public static class btVoronoiSimplexSolver extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public btVoronoiSimplexSolver() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btVoronoiSimplexSolver(Pointer p) { super(p); }
}
@Opaque public static class btConvexPenetrationDepthSolver extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public btConvexPenetrationDepthSolver() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConvexPenetrationDepthSolver(Pointer p) { super(p); }
}

@NoOffset public static class btDefaultCollisionConstructionInfo extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btDefaultCollisionConstructionInfo(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btDefaultCollisionConstructionInfo(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btDefaultCollisionConstructionInfo position(long position) {
        return (btDefaultCollisionConstructionInfo)super.position(position);
    }
    @Override public btDefaultCollisionConstructionInfo getPointer(long i) {
        return new btDefaultCollisionConstructionInfo((Pointer)this).offsetAddress(i);
    }

	public native btPoolAllocator m_persistentManifoldPool(); public native btDefaultCollisionConstructionInfo m_persistentManifoldPool(btPoolAllocator setter);
	public native btPoolAllocator m_collisionAlgorithmPool(); public native btDefaultCollisionConstructionInfo m_collisionAlgorithmPool(btPoolAllocator setter);
	public native int m_defaultMaxPersistentManifoldPoolSize(); public native btDefaultCollisionConstructionInfo m_defaultMaxPersistentManifoldPoolSize(int setter);
	public native int m_defaultMaxCollisionAlgorithmPoolSize(); public native btDefaultCollisionConstructionInfo m_defaultMaxCollisionAlgorithmPoolSize(int setter);
	public native int m_customCollisionAlgorithmMaxElementSize(); public native btDefaultCollisionConstructionInfo m_customCollisionAlgorithmMaxElementSize(int setter);
	public native int m_useEpaPenetrationAlgorithm(); public native btDefaultCollisionConstructionInfo m_useEpaPenetrationAlgorithm(int setter);

	public btDefaultCollisionConstructionInfo() { super((Pointer)null); allocate(); }
	private native void allocate();
}

/**btCollisionConfiguration allows to configure Bullet collision detection
 * stack allocator, pool memory allocators
 * \todo: describe the meaning */
@NoOffset public static class btDefaultCollisionConfiguration extends btCollisionConfiguration {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btDefaultCollisionConfiguration(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btDefaultCollisionConfiguration(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btDefaultCollisionConfiguration position(long position) {
        return (btDefaultCollisionConfiguration)super.position(position);
    }
    @Override public btDefaultCollisionConfiguration getPointer(long i) {
        return new btDefaultCollisionConfiguration((Pointer)this).offsetAddress(i);
    }

	public btDefaultCollisionConfiguration(@Const @ByRef(nullValue = "btDefaultCollisionConstructionInfo()") btDefaultCollisionConstructionInfo constructionInfo) { super((Pointer)null); allocate(constructionInfo); }
	private native void allocate(@Const @ByRef(nullValue = "btDefaultCollisionConstructionInfo()") btDefaultCollisionConstructionInfo constructionInfo);
	public btDefaultCollisionConfiguration() { super((Pointer)null); allocate(); }
	private native void allocate();

	/**memory pools */
	public native btPoolAllocator getPersistentManifoldPool();

	public native btPoolAllocator getCollisionAlgorithmPool();

	public native btCollisionAlgorithmCreateFunc getCollisionAlgorithmCreateFunc(int proxyType0, int proxyType1);

	public native btCollisionAlgorithmCreateFunc getClosestPointsAlgorithmCreateFunc(int proxyType0, int proxyType1);

	/**Use this method to allow to generate multiple contact points between at once, between two objects using the generic convex-convex algorithm.
	 * By default, this feature is disabled for best performance.
	 * @param numPerturbationIterations controls the number of collision queries. Set it to zero to disable the feature.
	 * @param minimumPointsPerturbationThreshold is the minimum number of points in the contact cache, above which the feature is disabled
	 * 3 is a good value for both params, if you want to enable the feature. This is because the default contact cache contains a maximum of 4 points, and one collision query at the unperturbed orientation is performed first.
	 * See Bullet/Demos/CollisionDemo for an example how this feature gathers multiple points.
	 * \todo we could add a per-object setting of those parameters, for level-of-detail collision detection. */
	public native void setConvexConvexMultipointIterations(int numPerturbationIterations/*=3*/, int minimumPointsPerturbationThreshold/*=3*/);
	public native void setConvexConvexMultipointIterations();

	public native void setPlaneConvexMultipointIterations(int numPerturbationIterations/*=3*/, int minimumPointsPerturbationThreshold/*=3*/);
	public native void setPlaneConvexMultipointIterations();
}

// #endif  //BT_DEFAULT_COLLISION_CONFIGURATION


// Parsed from BulletCollision/CollisionShapes/btCollisionShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_COLLISION_SHAPE_H
// #define BT_COLLISION_SHAPE_H

// #include "LinearMath/btTransform.h"
// #include "LinearMath/btVector3.h"
// #include "LinearMath/btMatrix3x3.h"
// #include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"  //for the shape types

/**The btCollisionShape class provides an interface for collision shapes that can be shared among btCollisionObjects. */
@NoOffset public static class btCollisionShape extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCollisionShape(Pointer p) { super(p); }


	/**getAabb returns the axis aligned bounding box in the coordinate frame of the given transform t. */
	public native void getAabb(@Const @ByRef btTransform t, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native void getBoundingSphere(@ByRef btVector3 center, @Cast("btScalar*") @ByRef FloatPointer radius);
	public native void getBoundingSphere(@ByRef btVector3 center, @Cast("btScalar*") @ByRef FloatBuffer radius);
	public native void getBoundingSphere(@ByRef btVector3 center, @Cast("btScalar*") @ByRef float[] radius);

	/**getAngularMotionDisc returns the maximum radius needed for Conservative Advancement to handle time-of-impact with rotations. */
	public native @Cast("btScalar") float getAngularMotionDisc();

	public native @Cast("btScalar") float getContactBreakingThreshold(@Cast("btScalar") float defaultContactThresholdFactor);

	/**calculateTemporalAabb calculates the enclosing aabb for the moving object over interval [0..timeStep)
	 * result is conservative */
	public native void calculateTemporalAabb(@Const @ByRef btTransform curTrans, @Const @ByRef btVector3 linvel, @Const @ByRef btVector3 angvel, @Cast("btScalar") float timeStep, @ByRef btVector3 temporalAabbMin, @ByRef btVector3 temporalAabbMax);

	public native @Cast("bool") boolean isPolyhedral();

	public native @Cast("bool") boolean isConvex2d();

	public native @Cast("bool") boolean isConvex();
	public native @Cast("bool") boolean isNonMoving();
	public native @Cast("bool") boolean isConcave();
	public native @Cast("bool") boolean isCompound();

	public native @Cast("bool") boolean isSoftBody();

	/**isInfinite is used to catch simulation error (aabb check) */
	public native @Cast("bool") boolean isInfinite();

// #ifndef __SPU__
	public native void setLocalScaling(@Const @ByRef btVector3 scaling);
	public native @Const @ByRef btVector3 getLocalScaling();
	public native void calculateLocalInertia(@Cast("btScalar") float mass, @ByRef btVector3 inertia);

	//debugging support
	public native @Cast("const char*") BytePointer getName();
// #endif  //__SPU__

	public native int getShapeType();

	/**the getAnisotropicRollingFrictionDirection can be used in combination with setAnisotropicFriction
	 * See Bullet/Demos/RollingFrictionDemo for an example */
	public native @ByVal btVector3 getAnisotropicRollingFrictionDirection();
	public native void setMargin(@Cast("btScalar") float margin);
	public native @Cast("btScalar") float getMargin();

	/**optional user data pointer */
	public native void setUserPointer(Pointer userPtr);

	public native Pointer getUserPointer();
	public native void setUserIndex(int index);

	public native int getUserIndex();

	public native void setUserIndex2(int index);

	public native int getUserIndex2();

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);

	public native void serializeSingleShape(btSerializer serializer);
}

// clang-format off
// parser needs * with the name
/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btCollisionShapeData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btCollisionShapeData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btCollisionShapeData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCollisionShapeData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btCollisionShapeData position(long position) {
        return (btCollisionShapeData)super.position(position);
    }
    @Override public btCollisionShapeData getPointer(long i) {
        return new btCollisionShapeData((Pointer)this).offsetAddress(i);
    }

	public native @Cast("char*") BytePointer m_name(); public native btCollisionShapeData m_name(BytePointer setter);
	public native int m_shapeType(); public native btCollisionShapeData m_shapeType(int setter);
	public native @Cast("char") byte m_padding(int i); public native btCollisionShapeData m_padding(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_padding();
}
// clang-format on


// #endif  //BT_COLLISION_SHAPE_H


// Parsed from BulletCollision/CollisionShapes/btPolyhedralConvexShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_POLYHEDRAL_CONVEX_SHAPE_H
// #define BT_POLYHEDRAL_CONVEX_SHAPE_H

// #include "LinearMath/btMatrix3x3.h"
// #include "btConvexInternalShape.h"
@Opaque public static class btConvexPolyhedron extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public btConvexPolyhedron() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConvexPolyhedron(Pointer p) { super(p); }
}

/**The btPolyhedralConvexShape is an internal interface class for polyhedral convex shapes. */
@NoOffset public static class btPolyhedralConvexShape extends btConvexInternalShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btPolyhedralConvexShape(Pointer p) { super(p); }


	/**optional method mainly used to generate multiple contact points by clipping polyhedral features (faces/edges)
	 * experimental/work-in-progress */
	public native @Cast("bool") boolean initializePolyhedralFeatures(int shiftVerticesByMargin/*=0*/);
	public native @Cast("bool") boolean initializePolyhedralFeatures();

	public native void setPolyhedralFeatures(@ByRef btConvexPolyhedron polyhedron);

	public native @Const btConvexPolyhedron getConvexPolyhedron();

	//brute force implementations

	public native @ByVal btVector3 localGetSupportingVertexWithoutMargin(@Const @ByRef btVector3 vec);
	public native void batchedUnitVectorGetSupportingVertexWithoutMargin(@Const btVector3 vectors, btVector3 supportVerticesOut, int numVectors);

	public native void calculateLocalInertia(@Cast("btScalar") float mass, @ByRef btVector3 inertia);

	public native int getNumVertices();
	public native int getNumEdges();
	public native void getEdge(int i, @ByRef btVector3 pa, @ByRef btVector3 pb);
	public native void getVertex(int i, @ByRef btVector3 vtx);
	public native int getNumPlanes();
	public native void getPlane(@ByRef btVector3 planeNormal, @ByRef btVector3 planeSupport, int i);
	//	virtual int getIndex(int i) const = 0 ;

	public native @Cast("bool") boolean isInside(@Const @ByRef btVector3 pt, @Cast("btScalar") float tolerance);
}

/**The btPolyhedralConvexAabbCachingShape adds aabb caching to the btPolyhedralConvexShape */
@NoOffset public static class btPolyhedralConvexAabbCachingShape extends btPolyhedralConvexShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btPolyhedralConvexAabbCachingShape(Pointer p) { super(p); }

	public native void getNonvirtualAabb(@Const @ByRef btTransform trans, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax, @Cast("btScalar") float margin);

	public native void setLocalScaling(@Const @ByRef btVector3 scaling);

	public native void getAabb(@Const @ByRef btTransform t, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native void recalcLocalAabb();
}

// #endif  //BT_POLYHEDRAL_CONVEX_SHAPE_H


// Parsed from BulletCollision/CollisionShapes/btConvexInternalShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_CONVEX_INTERNAL_SHAPE_H
// #define BT_CONVEX_INTERNAL_SHAPE_H

// #include "btConvexShape.h"
// #include "LinearMath/btAabbUtil2.h"

/**The btConvexInternalShape is an internal base class, shared by most convex shape implementations.
 * The btConvexInternalShape uses a default collision margin set to CONVEX_DISTANCE_MARGIN.
 * This collision margin used by Gjk and some other algorithms, see also btCollisionMargin.h
 * Note that when creating small shapes (derived from btConvexInternalShape),
 * you need to make sure to set a smaller collision margin, using the 'setMargin' API
 * There is a automatic mechanism 'setSafeMargin' used by btBoxShape and btCylinderShape */
@NoOffset public static class btConvexInternalShape extends btConvexShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConvexInternalShape(Pointer p) { super(p); }


	public native @ByVal btVector3 localGetSupportingVertex(@Const @ByRef btVector3 vec);

	public native @Const @ByRef btVector3 getImplicitShapeDimensions();

	/**warning: use setImplicitShapeDimensions with care
	 * changing a collision shape while the body is in the world is not recommended,
	 * it is best to remove the body from the world, then make the change, and re-add it
	 * alternatively flush the contact points, see documentation for 'cleanProxyFromPairs' */
	public native void setImplicitShapeDimensions(@Const @ByRef btVector3 dimensions);

	public native void setSafeMargin(@Cast("btScalar") float minDimension, @Cast("btScalar") float defaultMarginMultiplier/*=0.1f*/);
	public native void setSafeMargin(@Cast("btScalar") float minDimension);
	public native void setSafeMargin(@Const @ByRef btVector3 halfExtents, @Cast("btScalar") float defaultMarginMultiplier/*=0.1f*/);
	public native void setSafeMargin(@Const @ByRef btVector3 halfExtents);

	/**getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version */
	public native void getAabb(@Const @ByRef btTransform t, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native void getAabbSlow(@Const @ByRef btTransform t, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native void setLocalScaling(@Const @ByRef btVector3 scaling);
	public native @Const @ByRef btVector3 getLocalScaling();

	public native @Const @ByRef btVector3 getLocalScalingNV();

	public native void setMargin(@Cast("btScalar") float margin);
	public native @Cast("btScalar") float getMargin();

	public native @Cast("btScalar") float getMarginNV();

	public native int getNumPreferredPenetrationDirections();

	public native void getPreferredPenetrationDirection(int index, @ByRef btVector3 penetrationVector);

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);
}

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btConvexInternalShapeData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btConvexInternalShapeData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btConvexInternalShapeData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConvexInternalShapeData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btConvexInternalShapeData position(long position) {
        return (btConvexInternalShapeData)super.position(position);
    }
    @Override public btConvexInternalShapeData getPointer(long i) {
        return new btConvexInternalShapeData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btCollisionShapeData m_collisionShapeData(); public native btConvexInternalShapeData m_collisionShapeData(btCollisionShapeData setter);

	public native @ByRef btVector3FloatData m_localScaling(); public native btConvexInternalShapeData m_localScaling(btVector3FloatData setter);

	public native @ByRef btVector3FloatData m_implicitShapeDimensions(); public native btConvexInternalShapeData m_implicitShapeDimensions(btVector3FloatData setter);

	public native float m_collisionMargin(); public native btConvexInternalShapeData m_collisionMargin(float setter);

	public native int m_padding(); public native btConvexInternalShapeData m_padding(int setter);
}



/**fills the dataBuffer and returns the struct name (and 0 on failure) */


/**btConvexInternalAabbCachingShape adds local aabb caching for convex shapes, to avoid expensive bounding box calculations */
@NoOffset public static class btConvexInternalAabbCachingShape extends btConvexInternalShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConvexInternalAabbCachingShape(Pointer p) { super(p); }

	public native void setLocalScaling(@Const @ByRef btVector3 scaling);

	public native void getAabb(@Const @ByRef btTransform t, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native void recalcLocalAabb();
}

// #endif  //BT_CONVEX_INTERNAL_SHAPE_H


// Parsed from BulletCollision/CollisionShapes/btBoxShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_OBB_BOX_MINKOWSKI_H
// #define BT_OBB_BOX_MINKOWSKI_H

// #include "btPolyhedralConvexShape.h"
// #include "btCollisionMargin.h"
// #include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"
// #include "LinearMath/btVector3.h"
// #include "LinearMath/btMinMax.h"

/**The btBoxShape is a box primitive around the origin, its sides axis aligned with length specified by half extents, in local shape coordinates. When used as part of a btCollisionObject or btRigidBody it will be an oriented box in world space. */
public static class btBoxShape extends btPolyhedralConvexShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btBoxShape(Pointer p) { super(p); }


	public native @ByVal btVector3 getHalfExtentsWithMargin();

	public native @Const @ByRef btVector3 getHalfExtentsWithoutMargin();

	public native @ByVal btVector3 localGetSupportingVertex(@Const @ByRef btVector3 vec);

	public native @ByVal btVector3 localGetSupportingVertexWithoutMargin(@Const @ByRef btVector3 vec);

	public native void batchedUnitVectorGetSupportingVertexWithoutMargin(@Const btVector3 vectors, btVector3 supportVerticesOut, int numVectors);

	public btBoxShape(@Const @ByRef btVector3 boxHalfExtents) { super((Pointer)null); allocate(boxHalfExtents); }
	private native void allocate(@Const @ByRef btVector3 boxHalfExtents);

	public native void setMargin(@Cast("btScalar") float collisionMargin);
	public native void setLocalScaling(@Const @ByRef btVector3 scaling);

	public native void getAabb(@Const @ByRef btTransform t, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native void calculateLocalInertia(@Cast("btScalar") float mass, @ByRef btVector3 inertia);

	public native void getPlane(@ByRef btVector3 planeNormal, @ByRef btVector3 planeSupport, int i);

	public native int getNumPlanes();

	public native int getNumVertices();

	public native int getNumEdges();

	public native void getVertex(int i, @ByRef btVector3 vtx);

	public native void getPlaneEquation(@ByRef btVector4 plane, int i);

	public native void getEdge(int i, @ByRef btVector3 pa, @ByRef btVector3 pb);

	public native @Cast("bool") boolean isInside(@Const @ByRef btVector3 pt, @Cast("btScalar") float tolerance);

	//debugging
	public native @Cast("const char*") BytePointer getName();

	public native int getNumPreferredPenetrationDirections();

	public native void getPreferredPenetrationDirection(int index, @ByRef btVector3 penetrationVector);
}

// #endif  //BT_OBB_BOX_MINKOWSKI_H


// Parsed from BulletCollision/CollisionShapes/btSphereShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
// #ifndef BT_SPHERE_MINKOWSKI_H
// #define BT_SPHERE_MINKOWSKI_H

// #include "btConvexInternalShape.h"
// #include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"  // for the types

/**The btSphereShape implements an implicit sphere, centered around a local origin with radius. */
public static class btSphereShape extends btConvexInternalShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btSphereShape(Pointer p) { super(p); }


	public btSphereShape(@Cast("btScalar") float radius) { super((Pointer)null); allocate(radius); }
	private native void allocate(@Cast("btScalar") float radius);

	public native @ByVal btVector3 localGetSupportingVertex(@Const @ByRef btVector3 vec);
	public native @ByVal btVector3 localGetSupportingVertexWithoutMargin(@Const @ByRef btVector3 vec);
	//notice that the vectors should be unit length
	public native void batchedUnitVectorGetSupportingVertexWithoutMargin(@Const btVector3 vectors, btVector3 supportVerticesOut, int numVectors);

	public native void calculateLocalInertia(@Cast("btScalar") float mass, @ByRef btVector3 inertia);

	public native void getAabb(@Const @ByRef btTransform t, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native @Cast("btScalar") float getRadius();

	public native void setUnscaledRadius(@Cast("btScalar") float radius);

	//debugging
	public native @Cast("const char*") BytePointer getName();

	public native void setMargin(@Cast("btScalar") float margin);
	public native @Cast("btScalar") float getMargin();
}

// #endif  //BT_SPHERE_MINKOWSKI_H


// Parsed from BulletCollision/CollisionShapes/btCapsuleShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_CAPSULE_SHAPE_H
// #define BT_CAPSULE_SHAPE_H

// #include "btConvexInternalShape.h"
// #include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"  // for the types

/**The btCapsuleShape represents a capsule around the Y axis, there is also the btCapsuleShapeX aligned around the X axis and btCapsuleShapeZ around the Z axis.
 * The total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
 * The btCapsuleShape is a convex hull of two spheres. The btMultiSphereShape is a more general collision shape that takes the convex hull of multiple sphere, so it can also represent a capsule when just using two spheres. */
@NoOffset public static class btCapsuleShape extends btConvexInternalShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCapsuleShape(Pointer p) { super(p); }


	public btCapsuleShape(@Cast("btScalar") float radius, @Cast("btScalar") float height) { super((Pointer)null); allocate(radius, height); }
	private native void allocate(@Cast("btScalar") float radius, @Cast("btScalar") float height);

	/**CollisionShape Interface */
	public native void calculateLocalInertia(@Cast("btScalar") float mass, @ByRef btVector3 inertia);

	/** btConvexShape Interface */
	public native @ByVal btVector3 localGetSupportingVertexWithoutMargin(@Const @ByRef btVector3 vec);

	public native void batchedUnitVectorGetSupportingVertexWithoutMargin(@Const btVector3 vectors, btVector3 supportVerticesOut, int numVectors);

	public native void setMargin(@Cast("btScalar") float collisionMargin);

	public native void getAabb(@Const @ByRef btTransform t, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native @Cast("const char*") BytePointer getName();

	public native int getUpAxis();

	public native @Cast("btScalar") float getRadius();

	public native @Cast("btScalar") float getHalfHeight();

	public native void setLocalScaling(@Const @ByRef btVector3 scaling);

	public native @ByVal btVector3 getAnisotropicRollingFrictionDirection();

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);

	public native void deSerializeFloat(btCapsuleShapeData dataBuffer);
}

/**btCapsuleShapeX represents a capsule around the Z axis
 * the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps. */
public static class btCapsuleShapeX extends btCapsuleShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCapsuleShapeX(Pointer p) { super(p); }

	public btCapsuleShapeX(@Cast("btScalar") float radius, @Cast("btScalar") float height) { super((Pointer)null); allocate(radius, height); }
	private native void allocate(@Cast("btScalar") float radius, @Cast("btScalar") float height);

	//debugging
	public native @Cast("const char*") BytePointer getName();
}

/**btCapsuleShapeZ represents a capsule around the Z axis
 * the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps. */
public static class btCapsuleShapeZ extends btCapsuleShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCapsuleShapeZ(Pointer p) { super(p); }

	public btCapsuleShapeZ(@Cast("btScalar") float radius, @Cast("btScalar") float height) { super((Pointer)null); allocate(radius, height); }
	private native void allocate(@Cast("btScalar") float radius, @Cast("btScalar") float height);

	//debugging
	public native @Cast("const char*") BytePointer getName();
}

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btCapsuleShapeData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btCapsuleShapeData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btCapsuleShapeData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCapsuleShapeData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btCapsuleShapeData position(long position) {
        return (btCapsuleShapeData)super.position(position);
    }
    @Override public btCapsuleShapeData getPointer(long i) {
        return new btCapsuleShapeData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btConvexInternalShapeData m_convexInternalShapeData(); public native btCapsuleShapeData m_convexInternalShapeData(btConvexInternalShapeData setter);

	public native int m_upAxis(); public native btCapsuleShapeData m_upAxis(int setter);

	public native @Cast("char") byte m_padding(int i); public native btCapsuleShapeData m_padding(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_padding();
}



/**fills the dataBuffer and returns the struct name (and 0 on failure) */




// #endif  //BT_CAPSULE_SHAPE_H


// Parsed from BulletCollision/CollisionShapes/btCylinderShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_CYLINDER_MINKOWSKI_H
// #define BT_CYLINDER_MINKOWSKI_H

// #include "btBoxShape.h"
// #include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"  // for the types
// #include "LinearMath/btVector3.h"

/** The btCylinderShape class implements a cylinder shape primitive, centered around the origin. Its central axis aligned with the Y axis. btCylinderShapeX is aligned with the X axis and btCylinderShapeZ around the Z axis. */
@NoOffset public static class btCylinderShape extends btConvexInternalShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCylinderShape(Pointer p) { super(p); }


	public native @ByVal btVector3 getHalfExtentsWithMargin();

	public native @Const @ByRef btVector3 getHalfExtentsWithoutMargin();

	public btCylinderShape(@Const @ByRef btVector3 halfExtents) { super((Pointer)null); allocate(halfExtents); }
	private native void allocate(@Const @ByRef btVector3 halfExtents);

	public native void getAabb(@Const @ByRef btTransform t, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native void calculateLocalInertia(@Cast("btScalar") float mass, @ByRef btVector3 inertia);

	public native @ByVal btVector3 localGetSupportingVertexWithoutMargin(@Const @ByRef btVector3 vec);

	public native void batchedUnitVectorGetSupportingVertexWithoutMargin(@Const btVector3 vectors, btVector3 supportVerticesOut, int numVectors);

	public native void setMargin(@Cast("btScalar") float collisionMargin);

	public native @ByVal btVector3 localGetSupportingVertex(@Const @ByRef btVector3 vec);

	//use box inertia
	//	virtual void	calculateLocalInertia(btScalar mass,btVector3& inertia) const;

	public native int getUpAxis();

	public native @ByVal btVector3 getAnisotropicRollingFrictionDirection();

	public native @Cast("btScalar") float getRadius();

	public native void setLocalScaling(@Const @ByRef btVector3 scaling);

	//debugging
	public native @Cast("const char*") BytePointer getName();

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);
}

public static class btCylinderShapeX extends btCylinderShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCylinderShapeX(Pointer p) { super(p); }


	public btCylinderShapeX(@Const @ByRef btVector3 halfExtents) { super((Pointer)null); allocate(halfExtents); }
	private native void allocate(@Const @ByRef btVector3 halfExtents);

	public native @ByVal btVector3 localGetSupportingVertexWithoutMargin(@Const @ByRef btVector3 vec);
	public native void batchedUnitVectorGetSupportingVertexWithoutMargin(@Const btVector3 vectors, btVector3 supportVerticesOut, int numVectors);

	//debugging
	public native @Cast("const char*") BytePointer getName();

	public native @Cast("btScalar") float getRadius();
}

public static class btCylinderShapeZ extends btCylinderShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCylinderShapeZ(Pointer p) { super(p); }


	public btCylinderShapeZ(@Const @ByRef btVector3 halfExtents) { super((Pointer)null); allocate(halfExtents); }
	private native void allocate(@Const @ByRef btVector3 halfExtents);

	public native @ByVal btVector3 localGetSupportingVertexWithoutMargin(@Const @ByRef btVector3 vec);
	public native void batchedUnitVectorGetSupportingVertexWithoutMargin(@Const btVector3 vectors, btVector3 supportVerticesOut, int numVectors);

	//debugging
	public native @Cast("const char*") BytePointer getName();

	public native @Cast("btScalar") float getRadius();
}

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btCylinderShapeData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btCylinderShapeData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btCylinderShapeData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCylinderShapeData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btCylinderShapeData position(long position) {
        return (btCylinderShapeData)super.position(position);
    }
    @Override public btCylinderShapeData getPointer(long i) {
        return new btCylinderShapeData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btConvexInternalShapeData m_convexInternalShapeData(); public native btCylinderShapeData m_convexInternalShapeData(btConvexInternalShapeData setter);

	public native int m_upAxis(); public native btCylinderShapeData m_upAxis(int setter);

	public native @Cast("char") byte m_padding(int i); public native btCylinderShapeData m_padding(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_padding();
}



/**fills the dataBuffer and returns the struct name (and 0 on failure) */


// #endif  //BT_CYLINDER_MINKOWSKI_H


// Parsed from BulletCollision/CollisionShapes/btConeShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_CONE_MINKOWSKI_H
// #define BT_CONE_MINKOWSKI_H

// #include "btConvexInternalShape.h"
// #include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"  // for the types

/**The btConeShape implements a cone shape primitive, centered around the origin and aligned with the Y axis. The btConeShapeX is aligned around the X axis and btConeShapeZ around the Z axis. */
@NoOffset public static class btConeShape extends btConvexInternalShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConeShape(Pointer p) { super(p); }


	public btConeShape(@Cast("btScalar") float radius, @Cast("btScalar") float height) { super((Pointer)null); allocate(radius, height); }
	private native void allocate(@Cast("btScalar") float radius, @Cast("btScalar") float height);

	public native @ByVal btVector3 localGetSupportingVertex(@Const @ByRef btVector3 vec);
	public native @ByVal btVector3 localGetSupportingVertexWithoutMargin(@Const @ByRef btVector3 vec);
	public native void batchedUnitVectorGetSupportingVertexWithoutMargin(@Const btVector3 vectors, btVector3 supportVerticesOut, int numVectors);

	public native @Cast("btScalar") float getRadius();
	public native @Cast("btScalar") float getHeight();

	public native void setRadius(@Cast("const btScalar") float radius);
	public native void setHeight(@Cast("const btScalar") float height);

	public native void calculateLocalInertia(@Cast("btScalar") float mass, @ByRef btVector3 inertia);

	public native @Cast("const char*") BytePointer getName();

	/**choose upAxis index */
	public native void setConeUpIndex(int upIndex);

	public native int getConeUpIndex();

	public native @ByVal btVector3 getAnisotropicRollingFrictionDirection();

	public native void setLocalScaling(@Const @ByRef btVector3 scaling);

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);
}

/**btConeShape implements a Cone shape, around the X axis */
public static class btConeShapeX extends btConeShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConeShapeX(Pointer p) { super(p); }

	public btConeShapeX(@Cast("btScalar") float radius, @Cast("btScalar") float height) { super((Pointer)null); allocate(radius, height); }
	private native void allocate(@Cast("btScalar") float radius, @Cast("btScalar") float height);

	public native @ByVal btVector3 getAnisotropicRollingFrictionDirection();

	//debugging
	public native @Cast("const char*") BytePointer getName();
}

/**btConeShapeZ implements a Cone shape, around the Z axis */
public static class btConeShapeZ extends btConeShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConeShapeZ(Pointer p) { super(p); }

	public btConeShapeZ(@Cast("btScalar") float radius, @Cast("btScalar") float height) { super((Pointer)null); allocate(radius, height); }
	private native void allocate(@Cast("btScalar") float radius, @Cast("btScalar") float height);

	public native @ByVal btVector3 getAnisotropicRollingFrictionDirection();

	//debugging
	public native @Cast("const char*") BytePointer getName();
}

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btConeShapeData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btConeShapeData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btConeShapeData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConeShapeData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btConeShapeData position(long position) {
        return (btConeShapeData)super.position(position);
    }
    @Override public btConeShapeData getPointer(long i) {
        return new btConeShapeData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btConvexInternalShapeData m_convexInternalShapeData(); public native btConeShapeData m_convexInternalShapeData(btConvexInternalShapeData setter);

	public native int m_upIndex(); public native btConeShapeData m_upIndex(int setter);

	public native @Cast("char") byte m_padding(int i); public native btConeShapeData m_padding(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_padding();
}



/**fills the dataBuffer and returns the struct name (and 0 on failure) */


// #endif  //BT_CONE_MINKOWSKI_H


// Parsed from BulletCollision/CollisionShapes/btConcaveShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_CONCAVE_SHAPE_H
// #define BT_CONCAVE_SHAPE_H

// #include "btCollisionShape.h"
// #include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"  // for the types
// #include "btTriangleCallback.h"

/** PHY_ScalarType enumerates possible scalar types.
 *  See the btStridingMeshInterface or btHeightfieldTerrainShape for its use */
/** enum PHY_ScalarType */
public static final int
	PHY_FLOAT = 0,
	PHY_DOUBLE = 1,
	PHY_INTEGER = 2,
	PHY_SHORT = 3,
	PHY_FIXEDPOINT88 = 4,
	PHY_UCHAR = 5;

/**The btConcaveShape class provides an interface for non-moving (static) concave shapes.
 * It has been implemented by the btStaticPlaneShape, btBvhTriangleMeshShape and btHeightfieldTerrainShape. */
@NoOffset public static class btConcaveShape extends btCollisionShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConcaveShape(Pointer p) { super(p); }


	public native void processAllTriangles(btTriangleCallback callback, @Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax);

	public native @Cast("btScalar") float getMargin();
	public native void setMargin(@Cast("btScalar") float collisionMargin);
}

// #endif  //BT_CONCAVE_SHAPE_H


// Parsed from BulletCollision/CollisionShapes/btTriangleCallback.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_TRIANGLE_CALLBACK_H
// #define BT_TRIANGLE_CALLBACK_H

// #include "LinearMath/btVector3.h"

/**The btTriangleCallback provides a callback for each overlapping triangle when calling processAllTriangles.
 * This callback is called by processAllTriangles for all btConcaveShape derived class, such as  btBvhTriangleMeshShape, btStaticPlaneShape and btHeightfieldTerrainShape. */
public static class btTriangleCallback extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btTriangleCallback(Pointer p) { super(p); }

	public native void processTriangle(btVector3 triangle, int partId, int triangleIndex);
}

public static class btInternalTriangleIndexCallback extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btInternalTriangleIndexCallback(Pointer p) { super(p); }

	public native void internalProcessTriangleIndex(btVector3 triangle, int partId, int triangleIndex);
}

// #endif  //BT_TRIANGLE_CALLBACK_H


// Parsed from BulletCollision/CollisionShapes/btStaticPlaneShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_STATIC_PLANE_SHAPE_H
// #define BT_STATIC_PLANE_SHAPE_H

// #include "btConcaveShape.h"

/**The btStaticPlaneShape simulates an infinite non-moving (static) collision plane. */
@NoOffset public static class btStaticPlaneShape extends btConcaveShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btStaticPlaneShape(Pointer p) { super(p); }


	public btStaticPlaneShape(@Const @ByRef btVector3 planeNormal, @Cast("btScalar") float planeConstant) { super((Pointer)null); allocate(planeNormal, planeConstant); }
	private native void allocate(@Const @ByRef btVector3 planeNormal, @Cast("btScalar") float planeConstant);

	public native void getAabb(@Const @ByRef btTransform t, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native void processAllTriangles(btTriangleCallback callback, @Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax);

	public native void calculateLocalInertia(@Cast("btScalar") float mass, @ByRef btVector3 inertia);

	public native void setLocalScaling(@Const @ByRef btVector3 scaling);
	public native @Const @ByRef btVector3 getLocalScaling();

	public native @Const @ByRef btVector3 getPlaneNormal();

	public native @Cast("const btScalar") float getPlaneConstant();

	//debugging
	public native @Cast("const char*") BytePointer getName();

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);
}

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btStaticPlaneShapeData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btStaticPlaneShapeData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btStaticPlaneShapeData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btStaticPlaneShapeData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btStaticPlaneShapeData position(long position) {
        return (btStaticPlaneShapeData)super.position(position);
    }
    @Override public btStaticPlaneShapeData getPointer(long i) {
        return new btStaticPlaneShapeData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btCollisionShapeData m_collisionShapeData(); public native btStaticPlaneShapeData m_collisionShapeData(btCollisionShapeData setter);

	public native @ByRef btVector3FloatData m_localScaling(); public native btStaticPlaneShapeData m_localScaling(btVector3FloatData setter);
	public native @ByRef btVector3FloatData m_planeNormal(); public native btStaticPlaneShapeData m_planeNormal(btVector3FloatData setter);
	public native float m_planeConstant(); public native btStaticPlaneShapeData m_planeConstant(float setter);
	public native @Cast("char") byte m_pad(int i); public native btStaticPlaneShapeData m_pad(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_pad();
}



/**fills the dataBuffer and returns the struct name (and 0 on failure) */


// #endif  //BT_STATIC_PLANE_SHAPE_H


// Parsed from BulletCollision/CollisionShapes/btConvexHullShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_CONVEX_HULL_SHAPE_H
// #define BT_CONVEX_HULL_SHAPE_H

// #include "btPolyhedralConvexShape.h"
// #include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"  // for the types
// #include "LinearMath/btAlignedObjectArray.h"

/**The btConvexHullShape implements an implicit convex hull of an array of vertices.
 * Bullet provides a general and fast collision detector for convex shapes based on GJK and EPA using localGetSupportingVertex. */
@NoOffset public static class btConvexHullShape extends btPolyhedralConvexAabbCachingShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConvexHullShape(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btConvexHullShape(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btConvexHullShape position(long position) {
        return (btConvexHullShape)super.position(position);
    }
    @Override public btConvexHullShape getPointer(long i) {
        return new btConvexHullShape((Pointer)this).offsetAddress(i);
    }


	/**this constructor optionally takes in a pointer to points. Each point is assumed to be 3 consecutive btScalar (x,y,z), the striding defines the number of bytes between each point, in memory.
	 * It is easier to not pass any points in the constructor, and just add one point at a time, using addPoint.
	 * btConvexHullShape make an internal copy of the points. */
	public btConvexHullShape(@Cast("const btScalar*") FloatPointer points/*=0*/, int numPoints/*=0*/, int stride/*=sizeof(btVector3)*/) { super((Pointer)null); allocate(points, numPoints, stride); }
	private native void allocate(@Cast("const btScalar*") FloatPointer points/*=0*/, int numPoints/*=0*/, int stride/*=sizeof(btVector3)*/);
	public btConvexHullShape() { super((Pointer)null); allocate(); }
	private native void allocate();
	public btConvexHullShape(@Cast("const btScalar*") FloatBuffer points/*=0*/, int numPoints/*=0*/, int stride/*=sizeof(btVector3)*/) { super((Pointer)null); allocate(points, numPoints, stride); }
	private native void allocate(@Cast("const btScalar*") FloatBuffer points/*=0*/, int numPoints/*=0*/, int stride/*=sizeof(btVector3)*/);
	public btConvexHullShape(@Cast("const btScalar*") float[] points/*=0*/, int numPoints/*=0*/, int stride/*=sizeof(btVector3)*/) { super((Pointer)null); allocate(points, numPoints, stride); }
	private native void allocate(@Cast("const btScalar*") float[] points/*=0*/, int numPoints/*=0*/, int stride/*=sizeof(btVector3)*/);

	public native void addPoint(@Const @ByRef btVector3 point, @Cast("bool") boolean recalculateLocalAabb/*=true*/);
	public native void addPoint(@Const @ByRef btVector3 point);

	public native btVector3 getUnscaledPoints();

	/**getPoints is obsolete, please use getUnscaledPoints */
	public native @Const btVector3 getPoints();

	public native void optimizeConvexHull();

	public native @ByVal btVector3 getScaledPoint(int i);

	public native int getNumPoints();

	public native @ByVal btVector3 localGetSupportingVertex(@Const @ByRef btVector3 vec);
	public native @ByVal btVector3 localGetSupportingVertexWithoutMargin(@Const @ByRef btVector3 vec);
	public native void batchedUnitVectorGetSupportingVertexWithoutMargin(@Const btVector3 vectors, btVector3 supportVerticesOut, int numVectors);

	public native void project(@Const @ByRef btTransform trans, @Const @ByRef btVector3 dir, @Cast("btScalar*") @ByRef FloatPointer minProj, @Cast("btScalar*") @ByRef FloatPointer maxProj, @ByRef btVector3 witnesPtMin, @ByRef btVector3 witnesPtMax);
	public native void project(@Const @ByRef btTransform trans, @Const @ByRef btVector3 dir, @Cast("btScalar*") @ByRef FloatBuffer minProj, @Cast("btScalar*") @ByRef FloatBuffer maxProj, @ByRef btVector3 witnesPtMin, @ByRef btVector3 witnesPtMax);
	public native void project(@Const @ByRef btTransform trans, @Const @ByRef btVector3 dir, @Cast("btScalar*") @ByRef float[] minProj, @Cast("btScalar*") @ByRef float[] maxProj, @ByRef btVector3 witnesPtMin, @ByRef btVector3 witnesPtMax);

	//debugging
	public native @Cast("const char*") BytePointer getName();

	public native int getNumVertices();
	public native int getNumEdges();
	public native void getEdge(int i, @ByRef btVector3 pa, @ByRef btVector3 pb);
	public native void getVertex(int i, @ByRef btVector3 vtx);
	public native int getNumPlanes();
	public native void getPlane(@ByRef btVector3 planeNormal, @ByRef btVector3 planeSupport, int i);
	public native @Cast("bool") boolean isInside(@Const @ByRef btVector3 pt, @Cast("btScalar") float tolerance);

	/**in case we receive negative scaling */
	public native void setLocalScaling(@Const @ByRef btVector3 scaling);

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);
}

// clang-format off

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btConvexHullShapeData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btConvexHullShapeData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btConvexHullShapeData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConvexHullShapeData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btConvexHullShapeData position(long position) {
        return (btConvexHullShapeData)super.position(position);
    }
    @Override public btConvexHullShapeData getPointer(long i) {
        return new btConvexHullShapeData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btConvexInternalShapeData m_convexInternalShapeData(); public native btConvexHullShapeData m_convexInternalShapeData(btConvexInternalShapeData setter);

	public native btVector3FloatData m_unscaledPointsFloatPtr(); public native btConvexHullShapeData m_unscaledPointsFloatPtr(btVector3FloatData setter);
	public native btVector3DoubleData m_unscaledPointsDoublePtr(); public native btConvexHullShapeData m_unscaledPointsDoublePtr(btVector3DoubleData setter);

	public native int m_numUnscaledPoints(); public native btConvexHullShapeData m_numUnscaledPoints(int setter);
	public native @Cast("char") byte m_padding3(int i); public native btConvexHullShapeData m_padding3(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_padding3();

}

// clang-format on



// #endif  //BT_CONVEX_HULL_SHAPE_H


// Parsed from BulletCollision/CollisionShapes/btStridingMeshInterface.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_STRIDING_MESHINTERFACE_H
// #define BT_STRIDING_MESHINTERFACE_H

// #include "LinearMath/btVector3.h"
// #include "btTriangleCallback.h"
// #include "btConcaveShape.h"

/**	The btStridingMeshInterface is the interface class for high performance generic access to triangle meshes, used in combination with btBvhTriangleMeshShape and some other collision shapes.
 *  Using index striding of 3*sizeof(integer) it can use triangle arrays, using index striding of 1*sizeof(integer) it can handle triangle strips.
 *  It allows for sharing graphics and collision meshes. Also it provides locking/unlocking of graphics meshes that are in gpu memory. */
@NoOffset public static class btStridingMeshInterface extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btStridingMeshInterface(Pointer p) { super(p); }


	public native void InternalProcessAllTriangles(btInternalTriangleIndexCallback callback, @Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax);

	/**brute force method to calculate aabb */
	public native void calculateAabbBruteForce(@ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	/** get read and write access to a subpart of a triangle mesh
	 *  this subpart has a continuous array of vertices and indices
	 *  in this way the mesh can be handled as chunks of memory with striding
	 *  very similar to OpenGL vertexarray support
	 *  make a call to unLockVertexBase when the read and write access is finished */
	public native void getLockedVertexIndexBase(@Cast("unsigned char**") PointerPointer vertexbase, @ByRef IntPointer numverts, @Cast("PHY_ScalarType*") @ByRef IntPointer type, @ByRef IntPointer stride, @Cast("unsigned char**") PointerPointer indexbase, @ByRef IntPointer indexstride, @ByRef IntPointer numfaces, @Cast("PHY_ScalarType*") @ByRef IntPointer indicestype, int subpart/*=0*/);
	public native void getLockedVertexIndexBase(@Cast("unsigned char**") @ByPtrPtr BytePointer vertexbase, @ByRef IntPointer numverts, @Cast("PHY_ScalarType*") @ByRef IntPointer type, @ByRef IntPointer stride, @Cast("unsigned char**") @ByPtrPtr BytePointer indexbase, @ByRef IntPointer indexstride, @ByRef IntPointer numfaces, @Cast("PHY_ScalarType*") @ByRef IntPointer indicestype);
	public native void getLockedVertexIndexBase(@Cast("unsigned char**") @ByPtrPtr BytePointer vertexbase, @ByRef IntPointer numverts, @Cast("PHY_ScalarType*") @ByRef IntPointer type, @ByRef IntPointer stride, @Cast("unsigned char**") @ByPtrPtr BytePointer indexbase, @ByRef IntPointer indexstride, @ByRef IntPointer numfaces, @Cast("PHY_ScalarType*") @ByRef IntPointer indicestype, int subpart/*=0*/);
	public native void getLockedVertexIndexBase(@Cast("unsigned char**") @ByPtrPtr ByteBuffer vertexbase, @ByRef IntBuffer numverts, @Cast("PHY_ScalarType*") @ByRef IntBuffer type, @ByRef IntBuffer stride, @Cast("unsigned char**") @ByPtrPtr ByteBuffer indexbase, @ByRef IntBuffer indexstride, @ByRef IntBuffer numfaces, @Cast("PHY_ScalarType*") @ByRef IntBuffer indicestype, int subpart/*=0*/);
	public native void getLockedVertexIndexBase(@Cast("unsigned char**") @ByPtrPtr ByteBuffer vertexbase, @ByRef IntBuffer numverts, @Cast("PHY_ScalarType*") @ByRef IntBuffer type, @ByRef IntBuffer stride, @Cast("unsigned char**") @ByPtrPtr ByteBuffer indexbase, @ByRef IntBuffer indexstride, @ByRef IntBuffer numfaces, @Cast("PHY_ScalarType*") @ByRef IntBuffer indicestype);
	public native void getLockedVertexIndexBase(@Cast("unsigned char**") @ByPtrPtr byte[] vertexbase, @ByRef int[] numverts, @Cast("PHY_ScalarType*") @ByRef int[] type, @ByRef int[] stride, @Cast("unsigned char**") @ByPtrPtr byte[] indexbase, @ByRef int[] indexstride, @ByRef int[] numfaces, @Cast("PHY_ScalarType*") @ByRef int[] indicestype, int subpart/*=0*/);
	public native void getLockedVertexIndexBase(@Cast("unsigned char**") @ByPtrPtr byte[] vertexbase, @ByRef int[] numverts, @Cast("PHY_ScalarType*") @ByRef int[] type, @ByRef int[] stride, @Cast("unsigned char**") @ByPtrPtr byte[] indexbase, @ByRef int[] indexstride, @ByRef int[] numfaces, @Cast("PHY_ScalarType*") @ByRef int[] indicestype);

	public native void getLockedReadOnlyVertexIndexBase(@Cast("const unsigned char**") PointerPointer vertexbase, @ByRef IntPointer numverts, @Cast("PHY_ScalarType*") @ByRef IntPointer type, @ByRef IntPointer stride, @Cast("const unsigned char**") PointerPointer indexbase, @ByRef IntPointer indexstride, @ByRef IntPointer numfaces, @Cast("PHY_ScalarType*") @ByRef IntPointer indicestype, int subpart/*=0*/);
	public native void getLockedReadOnlyVertexIndexBase(@Cast("const unsigned char**") @ByPtrPtr BytePointer vertexbase, @ByRef IntPointer numverts, @Cast("PHY_ScalarType*") @ByRef IntPointer type, @ByRef IntPointer stride, @Cast("const unsigned char**") @ByPtrPtr BytePointer indexbase, @ByRef IntPointer indexstride, @ByRef IntPointer numfaces, @Cast("PHY_ScalarType*") @ByRef IntPointer indicestype);
	public native void getLockedReadOnlyVertexIndexBase(@Cast("const unsigned char**") @ByPtrPtr BytePointer vertexbase, @ByRef IntPointer numverts, @Cast("PHY_ScalarType*") @ByRef IntPointer type, @ByRef IntPointer stride, @Cast("const unsigned char**") @ByPtrPtr BytePointer indexbase, @ByRef IntPointer indexstride, @ByRef IntPointer numfaces, @Cast("PHY_ScalarType*") @ByRef IntPointer indicestype, int subpart/*=0*/);
	public native void getLockedReadOnlyVertexIndexBase(@Cast("const unsigned char**") @ByPtrPtr ByteBuffer vertexbase, @ByRef IntBuffer numverts, @Cast("PHY_ScalarType*") @ByRef IntBuffer type, @ByRef IntBuffer stride, @Cast("const unsigned char**") @ByPtrPtr ByteBuffer indexbase, @ByRef IntBuffer indexstride, @ByRef IntBuffer numfaces, @Cast("PHY_ScalarType*") @ByRef IntBuffer indicestype, int subpart/*=0*/);
	public native void getLockedReadOnlyVertexIndexBase(@Cast("const unsigned char**") @ByPtrPtr ByteBuffer vertexbase, @ByRef IntBuffer numverts, @Cast("PHY_ScalarType*") @ByRef IntBuffer type, @ByRef IntBuffer stride, @Cast("const unsigned char**") @ByPtrPtr ByteBuffer indexbase, @ByRef IntBuffer indexstride, @ByRef IntBuffer numfaces, @Cast("PHY_ScalarType*") @ByRef IntBuffer indicestype);
	public native void getLockedReadOnlyVertexIndexBase(@Cast("const unsigned char**") @ByPtrPtr byte[] vertexbase, @ByRef int[] numverts, @Cast("PHY_ScalarType*") @ByRef int[] type, @ByRef int[] stride, @Cast("const unsigned char**") @ByPtrPtr byte[] indexbase, @ByRef int[] indexstride, @ByRef int[] numfaces, @Cast("PHY_ScalarType*") @ByRef int[] indicestype, int subpart/*=0*/);
	public native void getLockedReadOnlyVertexIndexBase(@Cast("const unsigned char**") @ByPtrPtr byte[] vertexbase, @ByRef int[] numverts, @Cast("PHY_ScalarType*") @ByRef int[] type, @ByRef int[] stride, @Cast("const unsigned char**") @ByPtrPtr byte[] indexbase, @ByRef int[] indexstride, @ByRef int[] numfaces, @Cast("PHY_ScalarType*") @ByRef int[] indicestype);

	/** unLockVertexBase finishes the access to a subpart of the triangle mesh
	 *  make a call to unLockVertexBase when the read and write access (using getLockedVertexIndexBase) is finished */
	public native void unLockVertexBase(int subpart);

	public native void unLockReadOnlyVertexBase(int subpart);

	/** getNumSubParts returns the number of separate subparts
	 *  each subpart has a continuous array of vertices and indices */
	public native int getNumSubParts();

	public native void preallocateVertices(int numverts);
	public native void preallocateIndices(int numindices);

	public native @Cast("bool") boolean hasPremadeAabb();
	public native void setPremadeAabb(@Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax);
	public native void getPremadeAabb(btVector3 aabbMin, btVector3 aabbMax);

	public native @Const @ByRef btVector3 getScaling();
	public native void setScaling(@Const @ByRef btVector3 scaling);

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);
}

public static class btIntIndexData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btIntIndexData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btIntIndexData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btIntIndexData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btIntIndexData position(long position) {
        return (btIntIndexData)super.position(position);
    }
    @Override public btIntIndexData getPointer(long i) {
        return new btIntIndexData((Pointer)this).offsetAddress(i);
    }

	public native int m_value(); public native btIntIndexData m_value(int setter);
}

public static class btShortIntIndexData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btShortIntIndexData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btShortIntIndexData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btShortIntIndexData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btShortIntIndexData position(long position) {
        return (btShortIntIndexData)super.position(position);
    }
    @Override public btShortIntIndexData getPointer(long i) {
        return new btShortIntIndexData((Pointer)this).offsetAddress(i);
    }

	public native short m_value(); public native btShortIntIndexData m_value(short setter);
	public native @Cast("char") byte m_pad(int i); public native btShortIntIndexData m_pad(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_pad();
}

public static class btShortIntIndexTripletData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btShortIntIndexTripletData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btShortIntIndexTripletData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btShortIntIndexTripletData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btShortIntIndexTripletData position(long position) {
        return (btShortIntIndexTripletData)super.position(position);
    }
    @Override public btShortIntIndexTripletData getPointer(long i) {
        return new btShortIntIndexTripletData((Pointer)this).offsetAddress(i);
    }

	public native short m_values(int i); public native btShortIntIndexTripletData m_values(int i, short setter);
	@MemberGetter public native ShortPointer m_values();
	public native @Cast("char") byte m_pad(int i); public native btShortIntIndexTripletData m_pad(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_pad();
}

public static class btCharIndexTripletData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btCharIndexTripletData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btCharIndexTripletData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCharIndexTripletData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btCharIndexTripletData position(long position) {
        return (btCharIndexTripletData)super.position(position);
    }
    @Override public btCharIndexTripletData getPointer(long i) {
        return new btCharIndexTripletData((Pointer)this).offsetAddress(i);
    }

	public native @Cast("unsigned char") byte m_values(int i); public native btCharIndexTripletData m_values(int i, byte setter);
	@MemberGetter public native @Cast("unsigned char*") BytePointer m_values();
	public native @Cast("char") byte m_pad(); public native btCharIndexTripletData m_pad(byte setter);
}

// clang-format off

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btMeshPartData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btMeshPartData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btMeshPartData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btMeshPartData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btMeshPartData position(long position) {
        return (btMeshPartData)super.position(position);
    }
    @Override public btMeshPartData getPointer(long i) {
        return new btMeshPartData((Pointer)this).offsetAddress(i);
    }

	public native btVector3FloatData m_vertices3f(); public native btMeshPartData m_vertices3f(btVector3FloatData setter);
	public native btVector3DoubleData m_vertices3d(); public native btMeshPartData m_vertices3d(btVector3DoubleData setter);

	public native btIntIndexData m_indices32(); public native btMeshPartData m_indices32(btIntIndexData setter);
	public native btShortIntIndexTripletData m_3indices16(); public native btMeshPartData m_3indices16(btShortIntIndexTripletData setter);
	public native btCharIndexTripletData m_3indices8(); public native btMeshPartData m_3indices8(btCharIndexTripletData setter);

	public native btShortIntIndexData m_indices16(); public native btMeshPartData m_indices16(btShortIntIndexData setter);//backwards compatibility

	public native int m_numTriangles(); public native btMeshPartData m_numTriangles(int setter);//length of m_indices = m_numTriangles
	public native int m_numVertices(); public native btMeshPartData m_numVertices(int setter);
}


/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btStridingMeshInterfaceData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btStridingMeshInterfaceData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btStridingMeshInterfaceData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btStridingMeshInterfaceData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btStridingMeshInterfaceData position(long position) {
        return (btStridingMeshInterfaceData)super.position(position);
    }
    @Override public btStridingMeshInterfaceData getPointer(long i) {
        return new btStridingMeshInterfaceData((Pointer)this).offsetAddress(i);
    }

	public native btMeshPartData m_meshPartsPtr(); public native btStridingMeshInterfaceData m_meshPartsPtr(btMeshPartData setter);
	public native @ByRef btVector3FloatData m_scaling(); public native btStridingMeshInterfaceData m_scaling(btVector3FloatData setter);
	public native int m_numMeshParts(); public native btStridingMeshInterfaceData m_numMeshParts(int setter);
	public native @Cast("char") byte m_padding(int i); public native btStridingMeshInterfaceData m_padding(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_padding();
}

// clang-format on



// #endif  //BT_STRIDING_MESHINTERFACE_H


// Parsed from BulletCollision/CollisionShapes/btTriangleIndexVertexArray.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_TRIANGLE_INDEX_VERTEX_ARRAY_H
// #define BT_TRIANGLE_INDEX_VERTEX_ARRAY_H

// #include "btStridingMeshInterface.h"
// #include "LinearMath/btAlignedObjectArray.h"
// #include "LinearMath/btScalar.h"

/**The btIndexedMesh indexes a single vertex and index array. Multiple btIndexedMesh objects can be passed into a btTriangleIndexVertexArray using addIndexedMesh.
 * Instead of the number of indices, we pass the number of triangles. */
@NoOffset public static class btIndexedMesh extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btIndexedMesh(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btIndexedMesh(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btIndexedMesh position(long position) {
        return (btIndexedMesh)super.position(position);
    }
    @Override public btIndexedMesh getPointer(long i) {
        return new btIndexedMesh((Pointer)this).offsetAddress(i);
    }


	public native int m_numTriangles(); public native btIndexedMesh m_numTriangles(int setter);
	public native @Cast("const unsigned char*") BytePointer m_triangleIndexBase(); public native btIndexedMesh m_triangleIndexBase(BytePointer setter);
	// Size in byte of the indices for one triangle (3*sizeof(index_type) if the indices are tightly packed)
	public native int m_triangleIndexStride(); public native btIndexedMesh m_triangleIndexStride(int setter);
	public native int m_numVertices(); public native btIndexedMesh m_numVertices(int setter);
	public native @Cast("const unsigned char*") BytePointer m_vertexBase(); public native btIndexedMesh m_vertexBase(BytePointer setter);
	// Size of a vertex, in bytes
	public native int m_vertexStride(); public native btIndexedMesh m_vertexStride(int setter);

	// The index type is set when adding an indexed mesh to the
	// btTriangleIndexVertexArray, do not set it manually
	public native @Cast("PHY_ScalarType") int m_indexType(); public native btIndexedMesh m_indexType(int setter);

	// The vertex type has a default type similar to Bullet's precision mode (float or double)
	// but can be set manually if you for example run Bullet with double precision but have
	// mesh data in single precision..
	public native @Cast("PHY_ScalarType") int m_vertexType(); public native btIndexedMesh m_vertexType(int setter);

	public btIndexedMesh() { super((Pointer)null); allocate(); }
	private native void allocate();
}

/**The btTriangleIndexVertexArray allows to access multiple triangle meshes, by indexing into existing triangle/index arrays.
 * Additional meshes can be added using addIndexedMesh
 * No duplicate is made of the vertex/index data, it only indexes into external vertex/index arrays.
 * So keep those arrays around during the lifetime of this btTriangleIndexVertexArray. */
@NoOffset public static class btTriangleIndexVertexArray extends btStridingMeshInterface {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btTriangleIndexVertexArray(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btTriangleIndexVertexArray(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btTriangleIndexVertexArray position(long position) {
        return (btTriangleIndexVertexArray)super.position(position);
    }
    @Override public btTriangleIndexVertexArray getPointer(long i) {
        return new btTriangleIndexVertexArray((Pointer)this).offsetAddress(i);
    }


	public btTriangleIndexVertexArray() { super((Pointer)null); allocate(); }
	private native void allocate();

	//just to be backwards compatible
	public btTriangleIndexVertexArray(int numTriangles, IntPointer triangleIndexBase, int triangleIndexStride, int numVertices, @Cast("btScalar*") FloatPointer vertexBase, int vertexStride) { super((Pointer)null); allocate(numTriangles, triangleIndexBase, triangleIndexStride, numVertices, vertexBase, vertexStride); }
	private native void allocate(int numTriangles, IntPointer triangleIndexBase, int triangleIndexStride, int numVertices, @Cast("btScalar*") FloatPointer vertexBase, int vertexStride);
	public btTriangleIndexVertexArray(int numTriangles, IntBuffer triangleIndexBase, int triangleIndexStride, int numVertices, @Cast("btScalar*") FloatBuffer vertexBase, int vertexStride) { super((Pointer)null); allocate(numTriangles, triangleIndexBase, triangleIndexStride, numVertices, vertexBase, vertexStride); }
	private native void allocate(int numTriangles, IntBuffer triangleIndexBase, int triangleIndexStride, int numVertices, @Cast("btScalar*") FloatBuffer vertexBase, int vertexStride);
	public btTriangleIndexVertexArray(int numTriangles, int[] triangleIndexBase, int triangleIndexStride, int numVertices, @Cast("btScalar*") float[] vertexBase, int vertexStride) { super((Pointer)null); allocate(numTriangles, triangleIndexBase, triangleIndexStride, numVertices, vertexBase, vertexStride); }
	private native void allocate(int numTriangles, int[] triangleIndexBase, int triangleIndexStride, int numVertices, @Cast("btScalar*") float[] vertexBase, int vertexStride);

	public native void addIndexedMesh(@Const @ByRef btIndexedMesh mesh, @Cast("PHY_ScalarType") int indexType/*=PHY_INTEGER*/);
	public native void addIndexedMesh(@Const @ByRef btIndexedMesh mesh);

	public native void getLockedVertexIndexBase(@Cast("unsigned char**") PointerPointer vertexbase, @ByRef IntPointer numverts, @Cast("PHY_ScalarType*") @ByRef IntPointer type, @ByRef IntPointer vertexStride, @Cast("unsigned char**") PointerPointer indexbase, @ByRef IntPointer indexstride, @ByRef IntPointer numfaces, @Cast("PHY_ScalarType*") @ByRef IntPointer indicestype, int subpart/*=0*/);
	public native void getLockedVertexIndexBase(@Cast("unsigned char**") @ByPtrPtr BytePointer vertexbase, @ByRef IntPointer numverts, @Cast("PHY_ScalarType*") @ByRef IntPointer type, @ByRef IntPointer vertexStride, @Cast("unsigned char**") @ByPtrPtr BytePointer indexbase, @ByRef IntPointer indexstride, @ByRef IntPointer numfaces, @Cast("PHY_ScalarType*") @ByRef IntPointer indicestype);
	public native void getLockedVertexIndexBase(@Cast("unsigned char**") @ByPtrPtr BytePointer vertexbase, @ByRef IntPointer numverts, @Cast("PHY_ScalarType*") @ByRef IntPointer type, @ByRef IntPointer vertexStride, @Cast("unsigned char**") @ByPtrPtr BytePointer indexbase, @ByRef IntPointer indexstride, @ByRef IntPointer numfaces, @Cast("PHY_ScalarType*") @ByRef IntPointer indicestype, int subpart/*=0*/);
	public native void getLockedVertexIndexBase(@Cast("unsigned char**") @ByPtrPtr ByteBuffer vertexbase, @ByRef IntBuffer numverts, @Cast("PHY_ScalarType*") @ByRef IntBuffer type, @ByRef IntBuffer vertexStride, @Cast("unsigned char**") @ByPtrPtr ByteBuffer indexbase, @ByRef IntBuffer indexstride, @ByRef IntBuffer numfaces, @Cast("PHY_ScalarType*") @ByRef IntBuffer indicestype, int subpart/*=0*/);
	public native void getLockedVertexIndexBase(@Cast("unsigned char**") @ByPtrPtr ByteBuffer vertexbase, @ByRef IntBuffer numverts, @Cast("PHY_ScalarType*") @ByRef IntBuffer type, @ByRef IntBuffer vertexStride, @Cast("unsigned char**") @ByPtrPtr ByteBuffer indexbase, @ByRef IntBuffer indexstride, @ByRef IntBuffer numfaces, @Cast("PHY_ScalarType*") @ByRef IntBuffer indicestype);
	public native void getLockedVertexIndexBase(@Cast("unsigned char**") @ByPtrPtr byte[] vertexbase, @ByRef int[] numverts, @Cast("PHY_ScalarType*") @ByRef int[] type, @ByRef int[] vertexStride, @Cast("unsigned char**") @ByPtrPtr byte[] indexbase, @ByRef int[] indexstride, @ByRef int[] numfaces, @Cast("PHY_ScalarType*") @ByRef int[] indicestype, int subpart/*=0*/);
	public native void getLockedVertexIndexBase(@Cast("unsigned char**") @ByPtrPtr byte[] vertexbase, @ByRef int[] numverts, @Cast("PHY_ScalarType*") @ByRef int[] type, @ByRef int[] vertexStride, @Cast("unsigned char**") @ByPtrPtr byte[] indexbase, @ByRef int[] indexstride, @ByRef int[] numfaces, @Cast("PHY_ScalarType*") @ByRef int[] indicestype);

	public native void getLockedReadOnlyVertexIndexBase(@Cast("const unsigned char**") PointerPointer vertexbase, @ByRef IntPointer numverts, @Cast("PHY_ScalarType*") @ByRef IntPointer type, @ByRef IntPointer vertexStride, @Cast("const unsigned char**") PointerPointer indexbase, @ByRef IntPointer indexstride, @ByRef IntPointer numfaces, @Cast("PHY_ScalarType*") @ByRef IntPointer indicestype, int subpart/*=0*/);
	public native void getLockedReadOnlyVertexIndexBase(@Cast("const unsigned char**") @ByPtrPtr BytePointer vertexbase, @ByRef IntPointer numverts, @Cast("PHY_ScalarType*") @ByRef IntPointer type, @ByRef IntPointer vertexStride, @Cast("const unsigned char**") @ByPtrPtr BytePointer indexbase, @ByRef IntPointer indexstride, @ByRef IntPointer numfaces, @Cast("PHY_ScalarType*") @ByRef IntPointer indicestype);
	public native void getLockedReadOnlyVertexIndexBase(@Cast("const unsigned char**") @ByPtrPtr BytePointer vertexbase, @ByRef IntPointer numverts, @Cast("PHY_ScalarType*") @ByRef IntPointer type, @ByRef IntPointer vertexStride, @Cast("const unsigned char**") @ByPtrPtr BytePointer indexbase, @ByRef IntPointer indexstride, @ByRef IntPointer numfaces, @Cast("PHY_ScalarType*") @ByRef IntPointer indicestype, int subpart/*=0*/);
	public native void getLockedReadOnlyVertexIndexBase(@Cast("const unsigned char**") @ByPtrPtr ByteBuffer vertexbase, @ByRef IntBuffer numverts, @Cast("PHY_ScalarType*") @ByRef IntBuffer type, @ByRef IntBuffer vertexStride, @Cast("const unsigned char**") @ByPtrPtr ByteBuffer indexbase, @ByRef IntBuffer indexstride, @ByRef IntBuffer numfaces, @Cast("PHY_ScalarType*") @ByRef IntBuffer indicestype, int subpart/*=0*/);
	public native void getLockedReadOnlyVertexIndexBase(@Cast("const unsigned char**") @ByPtrPtr ByteBuffer vertexbase, @ByRef IntBuffer numverts, @Cast("PHY_ScalarType*") @ByRef IntBuffer type, @ByRef IntBuffer vertexStride, @Cast("const unsigned char**") @ByPtrPtr ByteBuffer indexbase, @ByRef IntBuffer indexstride, @ByRef IntBuffer numfaces, @Cast("PHY_ScalarType*") @ByRef IntBuffer indicestype);
	public native void getLockedReadOnlyVertexIndexBase(@Cast("const unsigned char**") @ByPtrPtr byte[] vertexbase, @ByRef int[] numverts, @Cast("PHY_ScalarType*") @ByRef int[] type, @ByRef int[] vertexStride, @Cast("const unsigned char**") @ByPtrPtr byte[] indexbase, @ByRef int[] indexstride, @ByRef int[] numfaces, @Cast("PHY_ScalarType*") @ByRef int[] indicestype, int subpart/*=0*/);
	public native void getLockedReadOnlyVertexIndexBase(@Cast("const unsigned char**") @ByPtrPtr byte[] vertexbase, @ByRef int[] numverts, @Cast("PHY_ScalarType*") @ByRef int[] type, @ByRef int[] vertexStride, @Cast("const unsigned char**") @ByPtrPtr byte[] indexbase, @ByRef int[] indexstride, @ByRef int[] numfaces, @Cast("PHY_ScalarType*") @ByRef int[] indicestype);

	/** unLockVertexBase finishes the access to a subpart of the triangle mesh
	 *  make a call to unLockVertexBase when the read and write access (using getLockedVertexIndexBase) is finished */
	public native void unLockVertexBase(int subpart);

	public native void unLockReadOnlyVertexBase(int subpart);

	/** getNumSubParts returns the number of separate subparts
	 *  each subpart has a continuous array of vertices and indices */
	public native int getNumSubParts();

	public native @Cast("IndexedMeshArray*") @ByRef btAlignedObjectArray_btVector3 getIndexedMeshArray();

	public native void preallocateVertices(int numverts);
	public native void preallocateIndices(int numindices);

	public native @Cast("bool") boolean hasPremadeAabb();
	public native void setPremadeAabb(@Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax);
	public native void getPremadeAabb(btVector3 aabbMin, btVector3 aabbMax);
}

// #endif  //BT_TRIANGLE_INDEX_VERTEX_ARRAY_H


// Parsed from BulletCollision/CollisionShapes/btTriangleMesh.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_TRIANGLE_MESH_H
// #define BT_TRIANGLE_MESH_H

// #include "btTriangleIndexVertexArray.h"
// #include "LinearMath/btVector3.h"
// #include "LinearMath/btAlignedObjectArray.h"

/**The btTriangleMesh class is a convenience class derived from btTriangleIndexVertexArray, that provides storage for a concave triangle mesh. It can be used as data for the btBvhTriangleMeshShape.
 * It allows either 32bit or 16bit indices, and 4 (x-y-z-w) or 3 (x-y-z) component vertices.
 * If you want to share triangle/index data between graphics mesh and collision mesh (btBvhTriangleMeshShape), you can directly use btTriangleIndexVertexArray or derive your own class from btStridingMeshInterface.
 * Performance of btTriangleMesh and btTriangleIndexVertexArray used in a btBvhTriangleMeshShape is the same. */
@NoOffset public static class btTriangleMesh extends btTriangleIndexVertexArray {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btTriangleMesh(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btTriangleMesh(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btTriangleMesh position(long position) {
        return (btTriangleMesh)super.position(position);
    }
    @Override public btTriangleMesh getPointer(long i) {
        return new btTriangleMesh((Pointer)this).offsetAddress(i);
    }

	public native @Cast("btScalar") float m_weldingThreshold(); public native btTriangleMesh m_weldingThreshold(float setter);

	public btTriangleMesh(@Cast("bool") boolean use32bitIndices/*=true*/, @Cast("bool") boolean use4componentVertices/*=true*/) { super((Pointer)null); allocate(use32bitIndices, use4componentVertices); }
	private native void allocate(@Cast("bool") boolean use32bitIndices/*=true*/, @Cast("bool") boolean use4componentVertices/*=true*/);
	public btTriangleMesh() { super((Pointer)null); allocate(); }
	private native void allocate();

	public native @Cast("bool") boolean getUse32bitIndices();

	public native @Cast("bool") boolean getUse4componentVertices();
	/**By default addTriangle won't search for duplicate vertices, because the search is very slow for large triangle meshes.
	 * In general it is better to directly use btTriangleIndexVertexArray instead. */
	public native void addTriangle(@Const @ByRef btVector3 vertex0, @Const @ByRef btVector3 vertex1, @Const @ByRef btVector3 vertex2, @Cast("bool") boolean removeDuplicateVertices/*=false*/);
	public native void addTriangle(@Const @ByRef btVector3 vertex0, @Const @ByRef btVector3 vertex1, @Const @ByRef btVector3 vertex2);

	/**Add a triangle using its indices. Make sure the indices are pointing within the vertices array, so add the vertices first (and to be sure, avoid removal of duplicate vertices) */
	public native void addTriangleIndices(int index1, int index2, int index3);

	public native int getNumTriangles();

	public native void preallocateVertices(int numverts);
	public native void preallocateIndices(int numindices);

	/**findOrAddVertex is an internal method, use addTriangle instead */
	public native int findOrAddVertex(@Const @ByRef btVector3 vertex, @Cast("bool") boolean removeDuplicateVertices);
	/**addIndex is an internal method, use addTriangle instead */
	public native void addIndex(int index);
}

// #endif  //BT_TRIANGLE_MESH_H


// Parsed from BulletCollision/CollisionShapes/btConvexTriangleMeshShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/
// #ifndef BT_CONVEX_TRIANGLEMESH_SHAPE_H
// #define BT_CONVEX_TRIANGLEMESH_SHAPE_H

// #include "btPolyhedralConvexShape.h"
// #include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"  // for the types

/** The btConvexTriangleMeshShape is a convex hull of a triangle mesh, but the performance is not as good as btConvexHullShape.
 *  A small benefit of this class is that it uses the btStridingMeshInterface, so you can avoid the duplication of the triangle mesh data. Nevertheless, most users should use the much better performing btConvexHullShape instead. */
@NoOffset public static class btConvexTriangleMeshShape extends btPolyhedralConvexAabbCachingShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btConvexTriangleMeshShape(Pointer p) { super(p); }


	public btConvexTriangleMeshShape(btStridingMeshInterface meshInterface, @Cast("bool") boolean calcAabb/*=true*/) { super((Pointer)null); allocate(meshInterface, calcAabb); }
	private native void allocate(btStridingMeshInterface meshInterface, @Cast("bool") boolean calcAabb/*=true*/);
	public btConvexTriangleMeshShape(btStridingMeshInterface meshInterface) { super((Pointer)null); allocate(meshInterface); }
	private native void allocate(btStridingMeshInterface meshInterface);

	public native btStridingMeshInterface getMeshInterface();

	public native @ByVal btVector3 localGetSupportingVertex(@Const @ByRef btVector3 vec);
	public native @ByVal btVector3 localGetSupportingVertexWithoutMargin(@Const @ByRef btVector3 vec);
	public native void batchedUnitVectorGetSupportingVertexWithoutMargin(@Const btVector3 vectors, btVector3 supportVerticesOut, int numVectors);

	//debugging
	public native @Cast("const char*") BytePointer getName();

	public native int getNumVertices();
	public native int getNumEdges();
	public native void getEdge(int i, @ByRef btVector3 pa, @ByRef btVector3 pb);
	public native void getVertex(int i, @ByRef btVector3 vtx);
	public native int getNumPlanes();
	public native void getPlane(@ByRef btVector3 planeNormal, @ByRef btVector3 planeSupport, int i);
	public native @Cast("bool") boolean isInside(@Const @ByRef btVector3 pt, @Cast("btScalar") float tolerance);

	public native void setLocalScaling(@Const @ByRef btVector3 scaling);
	public native @Const @ByRef btVector3 getLocalScaling();

	/**computes the exact moment of inertia and the transform from the coordinate system defined by the principal axes of the moment of inertia
	 * and the center of mass to the current coordinate system. A mass of 1 is assumed, for other masses just multiply the computed "inertia"
	 * by the mass. The resulting transform "principal" has to be applied inversely to the mesh in order for the local coordinate system of the
	 * shape to be centered at the center of mass and to coincide with the principal axes. This also necessitates a correction of the world transform
	 * of the collision object by the principal transform. This method also computes the volume of the convex mesh. */
	public native void calculatePrincipalAxisTransform(@ByRef btTransform principal, @ByRef btVector3 inertia, @Cast("btScalar*") @ByRef FloatPointer volume);
	public native void calculatePrincipalAxisTransform(@ByRef btTransform principal, @ByRef btVector3 inertia, @Cast("btScalar*") @ByRef FloatBuffer volume);
	public native void calculatePrincipalAxisTransform(@ByRef btTransform principal, @ByRef btVector3 inertia, @Cast("btScalar*") @ByRef float[] volume);
}

// #endif  //BT_CONVEX_TRIANGLEMESH_SHAPE_H


// Parsed from BulletCollision/CollisionShapes/btTriangleMeshShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_TRIANGLE_MESH_SHAPE_H
// #define BT_TRIANGLE_MESH_SHAPE_H

// #include "btConcaveShape.h"
// #include "btStridingMeshInterface.h"

/**The btTriangleMeshShape is an internal concave triangle mesh interface. Don't use this class directly, use btBvhTriangleMeshShape instead. */
@NoOffset public static class btTriangleMeshShape extends btConcaveShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btTriangleMeshShape(Pointer p) { super(p); }


	public native @ByVal btVector3 localGetSupportingVertex(@Const @ByRef btVector3 vec);

	public native @ByVal btVector3 localGetSupportingVertexWithoutMargin(@Const @ByRef btVector3 vec);

	public native void recalcLocalAabb();

	public native void getAabb(@Const @ByRef btTransform t, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native void processAllTriangles(btTriangleCallback callback, @Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax);

	public native void calculateLocalInertia(@Cast("btScalar") float mass, @ByRef btVector3 inertia);

	public native void setLocalScaling(@Const @ByRef btVector3 scaling);
	public native @Const @ByRef btVector3 getLocalScaling();

	public native btStridingMeshInterface getMeshInterface();

	public native @Const @ByRef btVector3 getLocalAabbMin();
	public native @Const @ByRef btVector3 getLocalAabbMax();

	//debugging
	public native @Cast("const char*") BytePointer getName();
}

// #endif  //BT_TRIANGLE_MESH_SHAPE_H


// Parsed from BulletCollision/CollisionShapes/btOptimizedBvh.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

/**Contains contributions from Disney Studio's */

// #ifndef BT_OPTIMIZED_BVH_H
// #define BT_OPTIMIZED_BVH_H

// #include "BulletCollision/BroadphaseCollision/btQuantizedBvh.h"

/**The btOptimizedBvh extends the btQuantizedBvh to create AABB tree for triangle meshes, through the btStridingMeshInterface. */
public static class btOptimizedBvh extends btQuantizedBvh {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btOptimizedBvh(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btOptimizedBvh(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btOptimizedBvh position(long position) {
        return (btOptimizedBvh)super.position(position);
    }
    @Override public btOptimizedBvh getPointer(long i) {
        return new btOptimizedBvh((Pointer)this).offsetAddress(i);
    }

	public btOptimizedBvh() { super((Pointer)null); allocate(); }
	private native void allocate();

	public native void build(btStridingMeshInterface triangles, @Cast("bool") boolean useQuantizedAabbCompression, @Const @ByRef btVector3 bvhAabbMin, @Const @ByRef btVector3 bvhAabbMax);

	public native void refit(btStridingMeshInterface triangles, @Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax);

	public native void refitPartial(btStridingMeshInterface triangles, @Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax);

	public native void updateBvhNodes(btStridingMeshInterface meshInterface, int firstNode, int endNode, int index);

	/** Data buffer MUST be 16 byte aligned */
	public native @Cast("bool") boolean serializeInPlace(Pointer o_alignedDataBuffer, @Cast("unsigned") int i_dataBufferSize, @Cast("bool") boolean i_swapEndian);

	/**deSerializeInPlace loads and initializes a BVH from a buffer in memory 'in place' */
	public static native btOptimizedBvh deSerializeInPlace(Pointer i_alignedDataBuffer, @Cast("unsigned int") int i_dataBufferSize, @Cast("bool") boolean i_swapEndian);
}

// #endif  //BT_OPTIMIZED_BVH_H


// Parsed from BulletCollision/CollisionShapes/btTriangleInfoMap.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2010 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef _BT_TRIANGLE_INFO_MAP_H
// #define _BT_TRIANGLE_INFO_MAP_H

// #include "LinearMath/btHashMap.h"
// #include "LinearMath/btSerializer.h"

/**for btTriangleInfo m_flags */
public static final int TRI_INFO_V0V1_CONVEX = 1;
public static final int TRI_INFO_V1V2_CONVEX = 2;
public static final int TRI_INFO_V2V0_CONVEX = 4;

public static final int TRI_INFO_V0V1_SWAP_NORMALB = 8;
public static final int TRI_INFO_V1V2_SWAP_NORMALB = 16;
public static final int TRI_INFO_V2V0_SWAP_NORMALB = 32;

/**The btTriangleInfo structure stores information to adjust collision normals to avoid collisions against internal edges
 * it can be generated using */
@NoOffset public static class btTriangleInfo extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btTriangleInfo(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btTriangleInfo(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btTriangleInfo position(long position) {
        return (btTriangleInfo)super.position(position);
    }
    @Override public btTriangleInfo getPointer(long i) {
        return new btTriangleInfo((Pointer)this).offsetAddress(i);
    }

	public btTriangleInfo() { super((Pointer)null); allocate(); }
	private native void allocate();

	public native int m_flags(); public native btTriangleInfo m_flags(int setter);

	public native @Cast("btScalar") float m_edgeV0V1Angle(); public native btTriangleInfo m_edgeV0V1Angle(float setter);
	public native @Cast("btScalar") float m_edgeV1V2Angle(); public native btTriangleInfo m_edgeV1V2Angle(float setter);
	public native @Cast("btScalar") float m_edgeV2V0Angle(); public native btTriangleInfo m_edgeV2V0Angle(float setter);
}

/**The btTriangleInfoMap stores edge angle information for some triangles. You can compute this information yourself or using btGenerateInternalEdgeInfo. */
@NoOffset public static class btTriangleInfoMap extends btHashMap_btHashPtr_voidPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btTriangleInfoMap(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btTriangleInfoMap(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btTriangleInfoMap position(long position) {
        return (btTriangleInfoMap)super.position(position);
    }
    @Override public btTriangleInfoMap getPointer(long i) {
        return new btTriangleInfoMap((Pointer)this).offsetAddress(i);
    }

	public native @Cast("btScalar") float m_convexEpsilon(); public native btTriangleInfoMap m_convexEpsilon(float setter);          /**used to determine if an edge or contact normal is convex, using the dot product */
	public native @Cast("btScalar") float m_planarEpsilon(); public native btTriangleInfoMap m_planarEpsilon(float setter);          /**used to determine if a triangle edge is planar with zero angle */
	public native @Cast("btScalar") float m_equalVertexThreshold(); public native btTriangleInfoMap m_equalVertexThreshold(float setter);   /**used to compute connectivity: if the distance between two vertices is smaller than m_equalVertexThreshold, they are considered to be 'shared' */
	public native @Cast("btScalar") float m_edgeDistanceThreshold(); public native btTriangleInfoMap m_edgeDistanceThreshold(float setter);  /**used to determine edge contacts: if the closest distance between a contact point and an edge is smaller than this distance threshold it is considered to "hit the edge" */
	public native @Cast("btScalar") float m_maxEdgeAngleThreshold(); public native btTriangleInfoMap m_maxEdgeAngleThreshold(float setter);  //ignore edges that connect triangles at an angle larger than this m_maxEdgeAngleThreshold
	public native @Cast("btScalar") float m_zeroAreaThreshold(); public native btTriangleInfoMap m_zeroAreaThreshold(float setter);      /**used to determine if a triangle is degenerate (length squared of cross product of 2 triangle edges < threshold) */

	public btTriangleInfoMap() { super((Pointer)null); allocate(); }
	private native void allocate();

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);

	public native void deSerialize(@ByRef btTriangleInfoMapData data);
}

// clang-format off

/**those fields have to be float and not btScalar for the serialization to work properly */
public static class btTriangleInfoData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btTriangleInfoData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btTriangleInfoData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btTriangleInfoData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btTriangleInfoData position(long position) {
        return (btTriangleInfoData)super.position(position);
    }
    @Override public btTriangleInfoData getPointer(long i) {
        return new btTriangleInfoData((Pointer)this).offsetAddress(i);
    }

	public native int m_flags(); public native btTriangleInfoData m_flags(int setter);
	public native float m_edgeV0V1Angle(); public native btTriangleInfoData m_edgeV0V1Angle(float setter);
	public native float m_edgeV1V2Angle(); public native btTriangleInfoData m_edgeV1V2Angle(float setter);
	public native float m_edgeV2V0Angle(); public native btTriangleInfoData m_edgeV2V0Angle(float setter);
}

public static class btTriangleInfoMapData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btTriangleInfoMapData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btTriangleInfoMapData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btTriangleInfoMapData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btTriangleInfoMapData position(long position) {
        return (btTriangleInfoMapData)super.position(position);
    }
    @Override public btTriangleInfoMapData getPointer(long i) {
        return new btTriangleInfoMapData((Pointer)this).offsetAddress(i);
    }

	public native IntPointer m_hashTablePtr(); public native btTriangleInfoMapData m_hashTablePtr(IntPointer setter);
	public native IntPointer m_nextPtr(); public native btTriangleInfoMapData m_nextPtr(IntPointer setter);
	public native btTriangleInfoData m_valueArrayPtr(); public native btTriangleInfoMapData m_valueArrayPtr(btTriangleInfoData setter);
	public native IntPointer m_keyArrayPtr(); public native btTriangleInfoMapData m_keyArrayPtr(IntPointer setter);

	public native float m_convexEpsilon(); public native btTriangleInfoMapData m_convexEpsilon(float setter);
	public native float m_planarEpsilon(); public native btTriangleInfoMapData m_planarEpsilon(float setter);
	public native float m_equalVertexThreshold(); public native btTriangleInfoMapData m_equalVertexThreshold(float setter); 
	public native float m_edgeDistanceThreshold(); public native btTriangleInfoMapData m_edgeDistanceThreshold(float setter);
	public native float m_zeroAreaThreshold(); public native btTriangleInfoMapData m_zeroAreaThreshold(float setter);

	public native int m_nextSize(); public native btTriangleInfoMapData m_nextSize(int setter);
	public native int m_hashTableSize(); public native btTriangleInfoMapData m_hashTableSize(int setter);
	public native int m_numValues(); public native btTriangleInfoMapData m_numValues(int setter);
	public native int m_numKeys(); public native btTriangleInfoMapData m_numKeys(int setter);
	public native @Cast("char") byte m_padding(int i); public native btTriangleInfoMapData m_padding(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_padding();
}

// clang-format on



/**fills the dataBuffer and returns the struct name (and 0 on failure) */


/**fills the dataBuffer and returns the struct name (and 0 on failure) */


// #endif  //_BT_TRIANGLE_INFO_MAP_H


// Parsed from BulletCollision/CollisionShapes/btBvhTriangleMeshShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_BVH_TRIANGLE_MESH_SHAPE_H
// #define BT_BVH_TRIANGLE_MESH_SHAPE_H

// #include "btTriangleMeshShape.h"
// #include "btOptimizedBvh.h"
// #include "LinearMath/btAlignedAllocator.h"
// #include "btTriangleInfoMap.h"

/**The btBvhTriangleMeshShape is a static-triangle mesh shape, it can only be used for fixed/non-moving objects.
 * If you required moving concave triangle meshes, it is recommended to perform convex decomposition
 * using HACD, see Bullet/Demos/ConvexDecompositionDemo.
 * Alternatively, you can use btGimpactMeshShape for moving concave triangle meshes.
 * btBvhTriangleMeshShape has several optimizations, such as bounding volume hierarchy and
 * cache friendly traversal for PlayStation 3 Cell SPU.
 * It is recommended to enable useQuantizedAabbCompression for better memory usage.
 * It takes a triangle mesh as input, for example a btTriangleMesh or btTriangleIndexVertexArray. The btBvhTriangleMeshShape class allows for triangle mesh deformations by a refit or partialRefit method.
 * Instead of building the bounding volume hierarchy acceleration structure, it is also possible to serialize (save) and deserialize (load) the structure from disk.
 * See Demos\ConcaveDemo\ConcavePhysicsDemo.cpp for an example. */
@NoOffset public static class btBvhTriangleMeshShape extends btTriangleMeshShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btBvhTriangleMeshShape(Pointer p) { super(p); }


	public btBvhTriangleMeshShape(btStridingMeshInterface meshInterface, @Cast("bool") boolean useQuantizedAabbCompression, @Cast("bool") boolean buildBvh/*=true*/) { super((Pointer)null); allocate(meshInterface, useQuantizedAabbCompression, buildBvh); }
	private native void allocate(btStridingMeshInterface meshInterface, @Cast("bool") boolean useQuantizedAabbCompression, @Cast("bool") boolean buildBvh/*=true*/);
	public btBvhTriangleMeshShape(btStridingMeshInterface meshInterface, @Cast("bool") boolean useQuantizedAabbCompression) { super((Pointer)null); allocate(meshInterface, useQuantizedAabbCompression); }
	private native void allocate(btStridingMeshInterface meshInterface, @Cast("bool") boolean useQuantizedAabbCompression);

	/**optionally pass in a larger bvh aabb, used for quantization. This allows for deformations within this aabb */
	public btBvhTriangleMeshShape(btStridingMeshInterface meshInterface, @Cast("bool") boolean useQuantizedAabbCompression, @Const @ByRef btVector3 bvhAabbMin, @Const @ByRef btVector3 bvhAabbMax, @Cast("bool") boolean buildBvh/*=true*/) { super((Pointer)null); allocate(meshInterface, useQuantizedAabbCompression, bvhAabbMin, bvhAabbMax, buildBvh); }
	private native void allocate(btStridingMeshInterface meshInterface, @Cast("bool") boolean useQuantizedAabbCompression, @Const @ByRef btVector3 bvhAabbMin, @Const @ByRef btVector3 bvhAabbMax, @Cast("bool") boolean buildBvh/*=true*/);
	public btBvhTriangleMeshShape(btStridingMeshInterface meshInterface, @Cast("bool") boolean useQuantizedAabbCompression, @Const @ByRef btVector3 bvhAabbMin, @Const @ByRef btVector3 bvhAabbMax) { super((Pointer)null); allocate(meshInterface, useQuantizedAabbCompression, bvhAabbMin, bvhAabbMax); }
	private native void allocate(btStridingMeshInterface meshInterface, @Cast("bool") boolean useQuantizedAabbCompression, @Const @ByRef btVector3 bvhAabbMin, @Const @ByRef btVector3 bvhAabbMax);

	public native @Cast("bool") boolean getOwnsBvh();

	public native void performRaycast(btTriangleCallback callback, @Const @ByRef btVector3 raySource, @Const @ByRef btVector3 rayTarget);
	public native void performConvexcast(btTriangleCallback callback, @Const @ByRef btVector3 boxSource, @Const @ByRef btVector3 boxTarget, @Const @ByRef btVector3 boxMin, @Const @ByRef btVector3 boxMax);

	public native void processAllTriangles(btTriangleCallback callback, @Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax);

	public native void refitTree(@Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax);

	/**for a fast incremental refit of parts of the tree. Note: the entire AABB of the tree will become more conservative, it never shrinks */
	public native void partialRefitTree(@Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax);

	//debugging
	public native @Cast("const char*") BytePointer getName();

	public native void setLocalScaling(@Const @ByRef btVector3 scaling);

	public native btOptimizedBvh getOptimizedBvh();

	public native void setOptimizedBvh(btOptimizedBvh bvh, @Const @ByRef(nullValue = "btVector3(1, 1, 1)") btVector3 localScaling);
	public native void setOptimizedBvh(btOptimizedBvh bvh);

	public native void buildOptimizedBvh();

	public native @Cast("bool") boolean usesQuantizedAabbCompression();

	public native void setTriangleInfoMap(btTriangleInfoMap triangleInfoMap);

	public native btTriangleInfoMap getTriangleInfoMap();

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);

	public native void serializeSingleBvh(btSerializer serializer);

	public native void serializeSingleTriangleInfoMap(btSerializer serializer);
}

// clang-format off

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btTriangleMeshShapeData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btTriangleMeshShapeData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btTriangleMeshShapeData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btTriangleMeshShapeData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btTriangleMeshShapeData position(long position) {
        return (btTriangleMeshShapeData)super.position(position);
    }
    @Override public btTriangleMeshShapeData getPointer(long i) {
        return new btTriangleMeshShapeData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btCollisionShapeData m_collisionShapeData(); public native btTriangleMeshShapeData m_collisionShapeData(btCollisionShapeData setter);

	public native @ByRef btStridingMeshInterfaceData m_meshInterface(); public native btTriangleMeshShapeData m_meshInterface(btStridingMeshInterfaceData setter);

	public native btQuantizedBvhFloatData m_quantizedFloatBvh(); public native btTriangleMeshShapeData m_quantizedFloatBvh(btQuantizedBvhFloatData setter);
	public native btQuantizedBvhDoubleData m_quantizedDoubleBvh(); public native btTriangleMeshShapeData m_quantizedDoubleBvh(btQuantizedBvhDoubleData setter);

	public native btTriangleInfoMapData m_triangleInfoMap(); public native btTriangleMeshShapeData m_triangleInfoMap(btTriangleInfoMapData setter);
	
	public native float m_collisionMargin(); public native btTriangleMeshShapeData m_collisionMargin(float setter);

	public native @Cast("char") byte m_pad3(int i); public native btTriangleMeshShapeData m_pad3(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_pad3();
	
}

// clang-format on



// #endif  //BT_BVH_TRIANGLE_MESH_SHAPE_H


// Parsed from BulletCollision/CollisionShapes/btScaledBvhTriangleMeshShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_SCALED_BVH_TRIANGLE_MESH_SHAPE_H
// #define BT_SCALED_BVH_TRIANGLE_MESH_SHAPE_H

// #include "BulletCollision/CollisionShapes/btBvhTriangleMeshShape.h"

/**The btScaledBvhTriangleMeshShape allows to instance a scaled version of an existing btBvhTriangleMeshShape.
 * Note that each btBvhTriangleMeshShape still can have its own local scaling, independent from this btScaledBvhTriangleMeshShape 'localScaling' */
@NoOffset public static class btScaledBvhTriangleMeshShape extends btConcaveShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btScaledBvhTriangleMeshShape(Pointer p) { super(p); }


	public btScaledBvhTriangleMeshShape(btBvhTriangleMeshShape childShape, @Const @ByRef btVector3 localScaling) { super((Pointer)null); allocate(childShape, localScaling); }
	private native void allocate(btBvhTriangleMeshShape childShape, @Const @ByRef btVector3 localScaling);

	public native void getAabb(@Const @ByRef btTransform t, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);
	public native void setLocalScaling(@Const @ByRef btVector3 scaling);
	public native @Const @ByRef btVector3 getLocalScaling();
	public native void calculateLocalInertia(@Cast("btScalar") float mass, @ByRef btVector3 inertia);

	public native void processAllTriangles(btTriangleCallback callback, @Const @ByRef btVector3 aabbMin, @Const @ByRef btVector3 aabbMax);

	public native btBvhTriangleMeshShape getChildShape();

	//debugging
	public native @Cast("const char*") BytePointer getName();

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);
}

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btScaledTriangleMeshShapeData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btScaledTriangleMeshShapeData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btScaledTriangleMeshShapeData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btScaledTriangleMeshShapeData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btScaledTriangleMeshShapeData position(long position) {
        return (btScaledTriangleMeshShapeData)super.position(position);
    }
    @Override public btScaledTriangleMeshShapeData getPointer(long i) {
        return new btScaledTriangleMeshShapeData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btTriangleMeshShapeData m_trimeshShapeData(); public native btScaledTriangleMeshShapeData m_trimeshShapeData(btTriangleMeshShapeData setter);

	public native @ByRef btVector3FloatData m_localScaling(); public native btScaledTriangleMeshShapeData m_localScaling(btVector3FloatData setter);
}



/**fills the dataBuffer and returns the struct name (and 0 on failure) */


// #endif  //BT_SCALED_BVH_TRIANGLE_MESH_SHAPE_H


// Parsed from BulletCollision/CollisionShapes/btCompoundShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_COMPOUND_SHAPE_H
// #define BT_COMPOUND_SHAPE_H

// #include "btCollisionShape.h"

// #include "LinearMath/btVector3.h"
// #include "LinearMath/btTransform.h"
// #include "LinearMath/btMatrix3x3.h"
// #include "btCollisionMargin.h"
// #include "LinearMath/btAlignedObjectArray.h"

//class btOptimizedBvh;
@Opaque public static class btDbvt extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public btDbvt() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btDbvt(Pointer p) { super(p); }
}

public static class btCompoundShapeChild extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btCompoundShapeChild() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btCompoundShapeChild(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCompoundShapeChild(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btCompoundShapeChild position(long position) {
        return (btCompoundShapeChild)super.position(position);
    }
    @Override public btCompoundShapeChild getPointer(long i) {
        return new btCompoundShapeChild((Pointer)this).offsetAddress(i);
    }


	public native @ByRef btTransform m_transform(); public native btCompoundShapeChild m_transform(btTransform setter);
	public native btCollisionShape m_childShape(); public native btCompoundShapeChild m_childShape(btCollisionShape setter);
	public native int m_childShapeType(); public native btCompoundShapeChild m_childShapeType(int setter);
	public native @Cast("btScalar") float m_childMargin(); public native btCompoundShapeChild m_childMargin(float setter);
	
}

public static native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef btCompoundShapeChild c1, @Const @ByRef btCompoundShapeChild c2);

/** The btCompoundShape allows to store multiple other btCollisionShapes
 *  This allows for moving concave collision objects. This is more general then the static concave btBvhTriangleMeshShape.
 *  It has an (optional) dynamic aabb tree to accelerate early rejection tests.
 *  \todo: This aabb tree can also be use to speed up ray tests on btCompoundShape, see http://code.google.com/p/bullet/issues/detail?id=25
 *  Currently, removal of child shapes is only supported when disabling the aabb tree (pass 'false' in the constructor of btCompoundShape) */
@NoOffset public static class btCompoundShape extends btCollisionShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCompoundShape(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btCompoundShape(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btCompoundShape position(long position) {
        return (btCompoundShape)super.position(position);
    }
    @Override public btCompoundShape getPointer(long i) {
        return new btCompoundShape((Pointer)this).offsetAddress(i);
    }


	public btCompoundShape(@Cast("bool") boolean enableDynamicAabbTree/*=true*/, int initialChildCapacity/*=0*/) { super((Pointer)null); allocate(enableDynamicAabbTree, initialChildCapacity); }
	private native void allocate(@Cast("bool") boolean enableDynamicAabbTree/*=true*/, int initialChildCapacity/*=0*/);
	public btCompoundShape() { super((Pointer)null); allocate(); }
	private native void allocate();

	public native void addChildShape(@Const @ByRef btTransform localTransform, btCollisionShape shape);

	/** Remove all children shapes that contain the specified shape */
	public native void removeChildShape(btCollisionShape shape);

	public native void removeChildShapeByIndex(int childShapeindex);

	public native int getNumChildShapes();

	public native btCollisionShape getChildShape(int index);

	public native @ByRef btTransform getChildTransform(int index);

	/**set a new transform for a child, and update internal data structures (local aabb and dynamic tree) */
	public native void updateChildTransform(int childIndex, @Const @ByRef btTransform newChildTransform, @Cast("bool") boolean shouldRecalculateLocalAabb/*=true*/);
	public native void updateChildTransform(int childIndex, @Const @ByRef btTransform newChildTransform);

	public native btCompoundShapeChild getChildList();

	/**getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version */
	public native void getAabb(@Const @ByRef btTransform t, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	/** Re-calculate the local Aabb. Is called at the end of removeChildShapes. 
	Use this yourself if you modify the children or their transforms. */
	public native void recalculateLocalAabb();

	public native void setLocalScaling(@Const @ByRef btVector3 scaling);

	public native @Const @ByRef btVector3 getLocalScaling();

	public native void calculateLocalInertia(@Cast("btScalar") float mass, @ByRef btVector3 inertia);

	public native void setMargin(@Cast("btScalar") float margin);
	public native @Cast("btScalar") float getMargin();
	public native @Cast("const char*") BytePointer getName();

	public native btDbvt getDynamicAabbTree();

	public native void createAabbTreeFromChildren();

	/**computes the exact moment of inertia and the transform from the coordinate system defined by the principal axes of the moment of inertia
	 * and the center of mass to the current coordinate system. "masses" points to an array of masses of the children. The resulting transform
	 * "principal" has to be applied inversely to all children transforms in order for the local coordinate system of the compound
	 * shape to be centered at the center of mass and to coincide with the principal axes. This also necessitates a correction of the world transform
	 * of the collision object by the principal transform. */
	public native void calculatePrincipalAxisTransform(@Cast("const btScalar*") FloatPointer masses, @ByRef btTransform principal, @ByRef btVector3 inertia);
	public native void calculatePrincipalAxisTransform(@Cast("const btScalar*") FloatBuffer masses, @ByRef btTransform principal, @ByRef btVector3 inertia);
	public native void calculatePrincipalAxisTransform(@Cast("const btScalar*") float[] masses, @ByRef btTransform principal, @ByRef btVector3 inertia);

	public native int getUpdateRevision();

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);
}

// clang-format off

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btCompoundShapeChildData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btCompoundShapeChildData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btCompoundShapeChildData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCompoundShapeChildData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btCompoundShapeChildData position(long position) {
        return (btCompoundShapeChildData)super.position(position);
    }
    @Override public btCompoundShapeChildData getPointer(long i) {
        return new btCompoundShapeChildData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btTransformFloatData m_transform(); public native btCompoundShapeChildData m_transform(btTransformFloatData setter);
	public native btCollisionShapeData m_childShape(); public native btCompoundShapeChildData m_childShape(btCollisionShapeData setter);
	public native int m_childShapeType(); public native btCompoundShapeChildData m_childShapeType(int setter);
	public native float m_childMargin(); public native btCompoundShapeChildData m_childMargin(float setter);
}

/**do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64 */
public static class btCompoundShapeData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btCompoundShapeData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btCompoundShapeData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btCompoundShapeData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btCompoundShapeData position(long position) {
        return (btCompoundShapeData)super.position(position);
    }
    @Override public btCompoundShapeData getPointer(long i) {
        return new btCompoundShapeData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btCollisionShapeData m_collisionShapeData(); public native btCompoundShapeData m_collisionShapeData(btCollisionShapeData setter);

	public native btCompoundShapeChildData m_childShapePtr(); public native btCompoundShapeData m_childShapePtr(btCompoundShapeChildData setter);

	public native int m_numChildShapes(); public native btCompoundShapeData m_numChildShapes(int setter);

	public native float m_collisionMargin(); public native btCompoundShapeData m_collisionMargin(float setter);

}

// clang-format on



// #endif  //BT_COMPOUND_SHAPE_H


// Parsed from BulletCollision/CollisionShapes/btTetrahedronShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_SIMPLEX_1TO4_SHAPE
// #define BT_SIMPLEX_1TO4_SHAPE

// #include "btPolyhedralConvexShape.h"
// #include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"

/**The btBU_Simplex1to4 implements tetrahedron, triangle, line, vertex collision shapes. In most cases it is better to use btConvexHullShape instead. */
@NoOffset public static class btBU_Simplex1to4 extends btPolyhedralConvexAabbCachingShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btBU_Simplex1to4(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btBU_Simplex1to4(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btBU_Simplex1to4 position(long position) {
        return (btBU_Simplex1to4)super.position(position);
    }
    @Override public btBU_Simplex1to4 getPointer(long i) {
        return new btBU_Simplex1to4((Pointer)this).offsetAddress(i);
    }


	public btBU_Simplex1to4() { super((Pointer)null); allocate(); }
	private native void allocate();

	public btBU_Simplex1to4(@Const @ByRef btVector3 pt0) { super((Pointer)null); allocate(pt0); }
	private native void allocate(@Const @ByRef btVector3 pt0);
	public btBU_Simplex1to4(@Const @ByRef btVector3 pt0, @Const @ByRef btVector3 pt1) { super((Pointer)null); allocate(pt0, pt1); }
	private native void allocate(@Const @ByRef btVector3 pt0, @Const @ByRef btVector3 pt1);
	public btBU_Simplex1to4(@Const @ByRef btVector3 pt0, @Const @ByRef btVector3 pt1, @Const @ByRef btVector3 pt2) { super((Pointer)null); allocate(pt0, pt1, pt2); }
	private native void allocate(@Const @ByRef btVector3 pt0, @Const @ByRef btVector3 pt1, @Const @ByRef btVector3 pt2);
	public btBU_Simplex1to4(@Const @ByRef btVector3 pt0, @Const @ByRef btVector3 pt1, @Const @ByRef btVector3 pt2, @Const @ByRef btVector3 pt3) { super((Pointer)null); allocate(pt0, pt1, pt2, pt3); }
	private native void allocate(@Const @ByRef btVector3 pt0, @Const @ByRef btVector3 pt1, @Const @ByRef btVector3 pt2, @Const @ByRef btVector3 pt3);

	public native void reset();

	public native void getAabb(@Const @ByRef btTransform t, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native void addVertex(@Const @ByRef btVector3 pt);

	//PolyhedralConvexShape interface

	public native int getNumVertices();

	public native int getNumEdges();

	public native void getEdge(int i, @ByRef btVector3 pa, @ByRef btVector3 pb);

	public native void getVertex(int i, @ByRef btVector3 vtx);

	public native int getNumPlanes();

	public native void getPlane(@ByRef btVector3 planeNormal, @ByRef btVector3 planeSupport, int i);

	public native int getIndex(int i);

	public native @Cast("bool") boolean isInside(@Const @ByRef btVector3 pt, @Cast("btScalar") float tolerance);

	/**getName is for debugging */
	public native @Cast("const char*") BytePointer getName();
}

// #endif  //BT_SIMPLEX_1TO4_SHAPE


// Parsed from BulletCollision/CollisionShapes/btEmptyShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_EMPTY_SHAPE_H
// #define BT_EMPTY_SHAPE_H

// #include "btConcaveShape.h"

// #include "LinearMath/btVector3.h"
// #include "LinearMath/btTransform.h"
// #include "LinearMath/btMatrix3x3.h"
// #include "btCollisionMargin.h"

/** The btEmptyShape is a collision shape without actual collision detection shape, so most users should ignore this class.
 *  It can be replaced by another shape during runtime, but the inertia tensor should be recomputed. */
@NoOffset public static class btEmptyShape extends btConcaveShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btEmptyShape(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btEmptyShape(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btEmptyShape position(long position) {
        return (btEmptyShape)super.position(position);
    }
    @Override public btEmptyShape getPointer(long i) {
        return new btEmptyShape((Pointer)this).offsetAddress(i);
    }


	public btEmptyShape() { super((Pointer)null); allocate(); }
	private native void allocate();

	/**getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version */
	public native void getAabb(@Const @ByRef btTransform t, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native void setLocalScaling(@Const @ByRef btVector3 scaling);
	public native @Const @ByRef btVector3 getLocalScaling();

	public native void calculateLocalInertia(@Cast("btScalar") float mass, @ByRef btVector3 inertia);

	public native @Cast("const char*") BytePointer getName();

	public native void processAllTriangles(btTriangleCallback arg0, @Const @ByRef btVector3 arg1, @Const @ByRef btVector3 arg2);
}

// #endif  //BT_EMPTY_SHAPE_H


// Parsed from BulletCollision/CollisionShapes/btMultiSphereShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_MULTI_SPHERE_MINKOWSKI_H
// #define BT_MULTI_SPHERE_MINKOWSKI_H

// #include "btConvexInternalShape.h"
// #include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"  // for the types
// #include "LinearMath/btAlignedObjectArray.h"
// #include "LinearMath/btAabbUtil2.h"

/**The btMultiSphereShape represents the convex hull of a collection of spheres. You can create special capsules or other smooth volumes.
 * It is possible to animate the spheres for deformation, but call 'recalcLocalAabb' after changing any sphere position/radius */
@NoOffset public static class btMultiSphereShape extends btConvexInternalAabbCachingShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btMultiSphereShape(Pointer p) { super(p); }


	public btMultiSphereShape(@Const btVector3 positions, @Cast("const btScalar*") FloatPointer radi, int numSpheres) { super((Pointer)null); allocate(positions, radi, numSpheres); }
	private native void allocate(@Const btVector3 positions, @Cast("const btScalar*") FloatPointer radi, int numSpheres);
	public btMultiSphereShape(@Const btVector3 positions, @Cast("const btScalar*") FloatBuffer radi, int numSpheres) { super((Pointer)null); allocate(positions, radi, numSpheres); }
	private native void allocate(@Const btVector3 positions, @Cast("const btScalar*") FloatBuffer radi, int numSpheres);
	public btMultiSphereShape(@Const btVector3 positions, @Cast("const btScalar*") float[] radi, int numSpheres) { super((Pointer)null); allocate(positions, radi, numSpheres); }
	private native void allocate(@Const btVector3 positions, @Cast("const btScalar*") float[] radi, int numSpheres);

	/**CollisionShape Interface */
	public native void calculateLocalInertia(@Cast("btScalar") float mass, @ByRef btVector3 inertia);

	/** btConvexShape Interface */
	public native @ByVal btVector3 localGetSupportingVertexWithoutMargin(@Const @ByRef btVector3 vec);

	public native void batchedUnitVectorGetSupportingVertexWithoutMargin(@Const btVector3 vectors, btVector3 supportVerticesOut, int numVectors);

	public native int getSphereCount();

	public native @Const @ByRef btVector3 getSpherePosition(int index);

	public native @Cast("btScalar") float getSphereRadius(int index);

	public native @Cast("const char*") BytePointer getName();

	public native int calculateSerializeBufferSize();

	/**fills the dataBuffer and returns the struct name (and 0 on failure) */
	public native @Cast("const char*") BytePointer serialize(Pointer dataBuffer, btSerializer serializer);
}

public static class btPositionAndRadius extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btPositionAndRadius() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btPositionAndRadius(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btPositionAndRadius(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btPositionAndRadius position(long position) {
        return (btPositionAndRadius)super.position(position);
    }
    @Override public btPositionAndRadius getPointer(long i) {
        return new btPositionAndRadius((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btVector3FloatData m_pos(); public native btPositionAndRadius m_pos(btVector3FloatData setter);
	public native float m_radius(); public native btPositionAndRadius m_radius(float setter);
}

// clang-format off

public static class btMultiSphereShapeData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btMultiSphereShapeData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btMultiSphereShapeData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btMultiSphereShapeData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btMultiSphereShapeData position(long position) {
        return (btMultiSphereShapeData)super.position(position);
    }
    @Override public btMultiSphereShapeData getPointer(long i) {
        return new btMultiSphereShapeData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btConvexInternalShapeData m_convexInternalShapeData(); public native btMultiSphereShapeData m_convexInternalShapeData(btConvexInternalShapeData setter);

	public native btPositionAndRadius m_localPositionArrayPtr(); public native btMultiSphereShapeData m_localPositionArrayPtr(btPositionAndRadius setter);
	public native int m_localPositionArraySize(); public native btMultiSphereShapeData m_localPositionArraySize(int setter);
	public native @Cast("char") byte m_padding(int i); public native btMultiSphereShapeData m_padding(int i, byte setter);
	@MemberGetter public native @Cast("char*") BytePointer m_padding();
}

// clang-format on



// #endif  //BT_MULTI_SPHERE_MINKOWSKI_H


// Parsed from BulletCollision/CollisionShapes/btUniformScalingShape.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_UNIFORM_SCALING_SHAPE_H
// #define BT_UNIFORM_SCALING_SHAPE_H

// #include "btConvexShape.h"
// #include "BulletCollision/BroadphaseCollision/btBroadphaseProxy.h"  // for the types

/**The btUniformScalingShape allows to re-use uniform scaled instances of btConvexShape in a memory efficient way.
 * Istead of using btUniformScalingShape, it is better to use the non-uniform setLocalScaling method on convex shapes that implement it. */
@NoOffset public static class btUniformScalingShape extends btConvexShape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btUniformScalingShape(Pointer p) { super(p); }


	public btUniformScalingShape(btConvexShape convexChildShape, @Cast("btScalar") float uniformScalingFactor) { super((Pointer)null); allocate(convexChildShape, uniformScalingFactor); }
	private native void allocate(btConvexShape convexChildShape, @Cast("btScalar") float uniformScalingFactor);

	public native @ByVal btVector3 localGetSupportingVertexWithoutMargin(@Const @ByRef btVector3 vec);

	public native @ByVal btVector3 localGetSupportingVertex(@Const @ByRef btVector3 vec);

	public native void batchedUnitVectorGetSupportingVertexWithoutMargin(@Const btVector3 vectors, btVector3 supportVerticesOut, int numVectors);

	public native void calculateLocalInertia(@Cast("btScalar") float mass, @ByRef btVector3 inertia);

	public native @Cast("btScalar") float getUniformScalingFactor();

	public native btConvexShape getChildShape();

	public native @Cast("const char*") BytePointer getName();

	///////////////////////////

	/**getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version */
	public native void getAabb(@Const @ByRef btTransform t, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native void getAabbSlow(@Const @ByRef btTransform t, @ByRef btVector3 aabbMin, @ByRef btVector3 aabbMax);

	public native void setLocalScaling(@Const @ByRef btVector3 scaling);
	public native @Const @ByRef btVector3 getLocalScaling();

	public native void setMargin(@Cast("btScalar") float margin);
	public native @Cast("btScalar") float getMargin();

	public native int getNumPreferredPenetrationDirections();

	public native void getPreferredPenetrationDirection(int index, @ByRef btVector3 penetrationVector);
}

// #endif  //BT_UNIFORM_SCALING_SHAPE_H


}
