// Targeted by JavaCPP version 1.5.7: DO NOT EDIT THIS FILE

package org.bytedeco.bullet;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

public class LinearMath extends org.bytedeco.bullet.presets.LinearMath {
    static { Loader.load(); }

// Parsed from LinearMath/btScalar.h

/*
Copyright (c) 2003-2009 Erwin Coumans  http://bullet.googlecode.com

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_SCALAR_H
// #define BT_SCALAR_H

// #ifdef BT_MANAGED_CODE
//Aligned data types not supported in managed code
// #pragma unmanaged
// #endif

// #include <math.h>
// #include <stdlib.h>  //size_t for MSVC 6.0
// #include <float.h>

/* SVN $Revision$ on $Date$ from http://bullet.googlecode.com*/
public static final int BT_BULLET_VERSION = 320;

public static native int btGetVersion();

public static native int btIsDoublePrecision();


// The following macro "BT_NOT_EMPTY_FILE" can be put into a file
// in order suppress the MS Visual C++ Linker warning 4221
//
// warning LNK4221: no public symbols found; archive member will be inaccessible
//
// This warning occurs on PC and XBOX when a file compiles out completely
// has no externally visible symbols which may be dependant on configuration
// #defines and options.
//
// see more https://stackoverflow.com/questions/1822887/what-is-the-best-way-to-eliminate-ms-visual-c-linker-warning-warning-lnk422

// #if defined(_MSC_VER)
// #else
// #define BT_NOT_EMPTY_FILE
// #endif

// clang and most formatting tools don't support indentation of preprocessor guards, so turn it off
// clang-format off
// #if defined(DEBUG) || defined (_DEBUG)
// #endif

// #ifdef _WIN32

// #else//_WIN32
	
// 	#if defined	(__CELLOS_LV2__)

// 	#else//defined	(__CELLOS_LV2__)

// 		#ifdef USE_LIBSPE2
		

// 		#else//USE_LIBSPE2
	//non-windows systems

// 			#if (defined (__APPLE__) && (!defined (BT_USE_DOUBLE_PRECISION)))

// 			#else//__APPLE__

// 				#define SIMD_FORCE_INLINE inline
				/**\todo: check out alignment methods for other platforms/compilers
				 * #define ATTRIBUTE_ALIGNED16(a) a __attribute__ ((aligned (16)))
				 * #define ATTRIBUTE_ALIGNED64(a) a __attribute__ ((aligned (64)))
				 * #define ATTRIBUTE_ALIGNED128(a) a __attribute__ ((aligned (128))) */
// 				#define ATTRIBUTE_ALIGNED16(a) a
// 				#define ATTRIBUTE_ALIGNED64(a) a
// 				#define ATTRIBUTE_ALIGNED128(a) a
// 				#ifndef assert
// 				#include <assert.h>
// 				#endif

// 				#if defined(DEBUG) || defined (_DEBUG)
// 				#else
// 					#define btAssert(x)
// 				#endif

				//btFullAssert is optional, slows down a lot
// 				#define btFullAssert(x)
// 				#define btLikely(_c)  _c
// 				#define btUnlikely(_c) _c
// 			#endif //__APPLE__ 
// 		#endif // LIBSPE2
// 	#endif	//__CELLOS_LV2__
// #endif//_WIN32


/**The btScalar type abstracts floating point numbers, to easily switch between double and single floating point precision. */
// #if defined(BT_USE_DOUBLE_PRECISION)
// #else
	//keep BT_LARGE_FLOAT*BT_LARGE_FLOAT < FLT_MAX
	public static final double BT_LARGE_FLOAT = 1e18f;
// #endif

// #ifdef BT_USE_SSE
// #endif  //BT_USE_SSE

// #if defined(BT_USE_SSE)
// #else//BT_USE_SSE

// 	#ifdef BT_USE_NEON
// 	#else  //BT_USE_NEON

// 	#ifndef BT_INFINITY
	public static class btInfMaskConverter extends Pointer {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public btInfMaskConverter(Pointer p) { super(p); }
	
			public native float mask(); public native btInfMaskConverter mask(float setter);
			public native int intmask(); public native btInfMaskConverter intmask(int setter);
		public btInfMaskConverter(int _mask/*=0x7F800000*/) { super((Pointer)null); allocate(_mask); }
		private native void allocate(int _mask/*=0x7F800000*/);
		public btInfMaskConverter() { super((Pointer)null); allocate(); }
		private native void allocate();
	}
	public static native @ByRef btInfMaskConverter btInfinityMask(); public static native void btInfinityMask(btInfMaskConverter setter);
// 	#define BT_INFINITY (btInfinityMask.mask)
	public static native int btGetInfinityMask();
// 	#endif
// 	#endif  //BT_USE_NEON

// #endif  //BT_USE_SSE

// #ifdef BT_USE_NEON
// #endif//BT_USE_NEON

// #define BT_DECLARE_ALIGNED_ALLOCATOR()
// 	SIMD_FORCE_INLINE void *operator new(size_t sizeInBytes) { return btAlignedAlloc(sizeInBytes, 16); }
// 	SIMD_FORCE_INLINE void operator delete(void *ptr) { btAlignedFree(ptr); }
// 	SIMD_FORCE_INLINE void *operator new(size_t, void *ptr) { return ptr; }
// 	SIMD_FORCE_INLINE void operator delete(void *, void *) {}
// 	SIMD_FORCE_INLINE void *operator new[](size_t sizeInBytes) { return btAlignedAlloc(sizeInBytes, 16); }
// 	SIMD_FORCE_INLINE void operator delete[](void *ptr) { btAlignedFree(ptr); }
// 	SIMD_FORCE_INLINE void *operator new[](size_t, void *ptr) { return ptr; }
// 	SIMD_FORCE_INLINE void operator delete[](void *, void *) {}

// #if defined(BT_USE_DOUBLE_PRECISION) || defined(BT_FORCE_DOUBLE_FUNCTIONS)

	public static native @Cast("btScalar") float btSqrt(@Cast("btScalar") float x);
	public static native @Cast("btScalar") float btFabs(@Cast("btScalar") float x);
	public static native @Cast("btScalar") float btCos(@Cast("btScalar") float x);
	public static native @Cast("btScalar") float btSin(@Cast("btScalar") float x);
	public static native @Cast("btScalar") float btTan(@Cast("btScalar") float x);
	public static native @Cast("btScalar") float btAcos(@Cast("btScalar") float x);
	public static native @Cast("btScalar") float btAsin(@Cast("btScalar") float x);
	public static native @Cast("btScalar") float btAtan(@Cast("btScalar") float x);
	public static native @Cast("btScalar") float btAtan2(@Cast("btScalar") float x, @Cast("btScalar") float y);
	public static native @Cast("btScalar") float btExp(@Cast("btScalar") float x);
	public static native @Cast("btScalar") float btLog(@Cast("btScalar") float x);
	public static native @Cast("btScalar") float btPow(@Cast("btScalar") float x, @Cast("btScalar") float y);
	public static native @Cast("btScalar") float btFmod(@Cast("btScalar") float x, @Cast("btScalar") float y);

// #else//BT_USE_DOUBLE_PRECISION

// #endif//BT_USE_DOUBLE_PRECISION

public static native @MemberGetter double SIMD_PI();
public static final double SIMD_PI = SIMD_PI();
public static native @MemberGetter double SIMD_2_PI();
public static final double SIMD_2_PI = SIMD_2_PI();
public static native @MemberGetter double SIMD_HALF_PI();
public static final double SIMD_HALF_PI = SIMD_HALF_PI();
public static native @MemberGetter double SIMD_RADS_PER_DEG();
public static final double SIMD_RADS_PER_DEG = SIMD_RADS_PER_DEG();
public static native @MemberGetter double SIMD_DEGS_PER_RAD();
public static final double SIMD_DEGS_PER_RAD = SIMD_DEGS_PER_RAD();
public static native @MemberGetter double SIMDSQRT12();
public static final double SIMDSQRT12 = SIMDSQRT12();
// #define btRecipSqrt(x) ((btScalar)(btScalar(1.0) / btSqrt(btScalar(x)))) /* reciprocal square root */
// #define btRecip(x) (btScalar(1.0) / btScalar(x))

// #ifdef BT_USE_DOUBLE_PRECISION
// #else
// 	#define SIMD_EPSILON FLT_EPSILON
// 	#define SIMD_INFINITY FLT_MAX
	public static final double BT_ONE = 1.0f;
	public static final double BT_ZERO = 0.0f;
	public static final double BT_TWO = 2.0f;
	public static final double BT_HALF = 0.5f;
// #endif

// clang-format on

public static native @Cast("btScalar") float btAtan2Fast(@Cast("btScalar") float y, @Cast("btScalar") float x);

public static native @Cast("bool") boolean btFuzzyZero(@Cast("btScalar") float x);

public static native @Cast("bool") boolean btEqual(@Cast("btScalar") float a, @Cast("btScalar") float eps);
public static native @Cast("bool") boolean btGreaterEqual(@Cast("btScalar") float a, @Cast("btScalar") float eps);

public static native int btIsNegative(@Cast("btScalar") float x);

public static native @Cast("btScalar") float btRadians(@Cast("btScalar") float x);
public static native @Cast("btScalar") float btDegrees(@Cast("btScalar") float x);

// #define BT_DECLARE_HANDLE(name)
// 	typedef struct name##__
// 	{
// 		int unused;
// 	} * name

// #ifndef btFsel
public static native @Cast("btScalar") float btFsel(@Cast("btScalar") float a, @Cast("btScalar") float b, @Cast("btScalar") float c);
// #endif
// #define btFsels(a, b, c) (btScalar) btFsel(a, b, c)

public static native @Cast("bool") boolean btMachineIsLittleEndian();

/**btSelect avoids branches, which makes performance much better for consoles like Playstation 3 and XBox 360
 * Thanks Phil Knight. See also http://www.cellperformance.com/articles/2006/04/more_techniques_for_eliminatin_1.html */
public static native @Cast("unsigned") int btSelect(@Cast("unsigned") int condition, @Cast("unsigned") int valueIfConditionNonZero, @Cast("unsigned") int valueIfConditionZero);
public static native float btSelect(@Cast("unsigned") int condition, float valueIfConditionNonZero, float valueIfConditionZero);

//PCK: endian swapping functions
public static native @Cast("unsigned") int btSwapEndian(@Cast("unsigned") int val);

public static native @Cast("unsigned short") short btSwapEndian(@Cast("unsigned short") short val);

/**btSwapFloat uses using char pointers to swap the endianness
////btSwapFloat/btSwapDouble will NOT return a float, because the machine might 'correct' invalid floating point values
 * Not all values of sign/exponent/mantissa are valid floating point numbers according to IEEE 754.
 * When a floating point unit is faced with an invalid value, it may actually change the value, or worse, throw an exception.
 * In most systems, running user mode code, you wouldn't get an exception, but instead the hardware/os/runtime will 'fix' the number for you.
 * so instead of returning a float/double, we return integer/long long integer */
public static native @Cast("unsigned int") int btSwapEndianFloat(float d);

// unswap using char pointers
public static native float btUnswapEndianFloat(@Cast("unsigned int") int a);

// swap using char pointers
public static native void btSwapEndianDouble(double d, @Cast("unsigned char*") BytePointer dst);
public static native void btSwapEndianDouble(double d, @Cast("unsigned char*") ByteBuffer dst);
public static native void btSwapEndianDouble(double d, @Cast("unsigned char*") byte[] dst);

// unswap using char pointers
public static native double btUnswapEndianDouble(@Cast("const unsigned char*") BytePointer src);
public static native double btUnswapEndianDouble(@Cast("const unsigned char*") ByteBuffer src);
public static native double btUnswapEndianDouble(@Cast("const unsigned char*") byte[] src);

public static native @Cast("btScalar") float btLargeDot(@Cast("const btScalar*") FloatPointer a, @Cast("const btScalar*") FloatPointer b, int n);
public static native @Cast("btScalar") float btLargeDot(@Cast("const btScalar*") FloatBuffer a, @Cast("const btScalar*") FloatBuffer b, int n);
public static native @Cast("btScalar") float btLargeDot(@Cast("const btScalar*") float[] a, @Cast("const btScalar*") float[] b, int n);

// returns normalized value in range [-SIMD_PI, SIMD_PI]
public static native @Cast("btScalar") float btNormalizeAngle(@Cast("btScalar") float angleInRadians);

/**rudimentary class to provide type info */
@NoOffset public static class btTypedObject extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btTypedObject(Pointer p) { super(p); }

	public btTypedObject(int objectType) { super((Pointer)null); allocate(objectType); }
	private native void allocate(int objectType);
	public native int m_objectType(); public native btTypedObject m_objectType(int setter);
	public native int getObjectType();
}

/**align a pointer to the provided alignment, upwards */

// #endif  //BT_SCALAR_H


// Parsed from LinearMath/btVector3.h

/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_VECTOR3_H
// #define BT_VECTOR3_H

//#include <stdint.h>
// #include "btScalar.h"
// #include "btMinMax.h"
// #include "btAlignedAllocator.h"

// #ifdef BT_USE_DOUBLE_PRECISION
// #else
// #define btVector3Data btVector3FloatData
public static final String btVector3DataName = "btVector3FloatData";
// #endif  //BT_USE_DOUBLE_PRECISION

// #if defined BT_USE_SSE

// #endif

// #ifdef BT_USE_NEON

// #endif

/**\brief btVector3 can be used to represent 3D points and vectors.
 * It has an un-used w component to suit 16-byte alignment when btVector3 is stored in containers. This extra component can be used by derived classes (Quaternion?) or by user
 * Ideally, this class should be replaced by a platform optimized SIMD version that keeps the data in registers
 */
@NoOffset public static class btVector3 extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btVector3(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btVector3(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btVector3 position(long position) {
        return (btVector3)super.position(position);
    }
    @Override public btVector3 getPointer(long i) {
        return new btVector3((Pointer)this).offsetAddress(i);
    }


// #if defined(__SPU__) && defined(__CELLOS_LV2__)
// #else                                            //__CELLOS_LV2__ __SPU__
// #if defined(BT_USE_SSE) || defined(BT_USE_NEON)  // _WIN32 || ARM
// #else
	public native @Cast("btScalar") float m_floats(int i); public native btVector3 m_floats(int i, float setter);
	@MemberGetter public native @Cast("btScalar*") FloatPointer m_floats();
	/**\brief No initialization constructor */
	public btVector3() { super((Pointer)null); allocate(); }
	private native void allocate();

	/**\brief Constructor from scalars 
   * @param x X value
   * @param y Y value 
   * @param z Z value 
   */
	public btVector3(@Cast("const btScalar") float _x, @Cast("const btScalar") float _y, @Cast("const btScalar") float _z) { super((Pointer)null); allocate(_x, _y, _z); }
	private native void allocate(@Cast("const btScalar") float _x, @Cast("const btScalar") float _y, @Cast("const btScalar") float _z);

// #if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
// #endif  // #if defined (BT_USE_SSE_IN_API) || defined (BT_USE_NEON)

	/**\brief Add a vector to this one 
 * @param The vector to add to this one */
	public native @ByRef @Name("operator +=") btVector3 addPut(@Const @ByRef btVector3 v);

	/**\brief Subtract a vector from this one
   * @param The vector to subtract */
	public native @ByRef @Name("operator -=") btVector3 subtractPut(@Const @ByRef btVector3 v);

	/**\brief Scale the vector
   * @param s Scale factor */
	public native @ByRef @Name("operator *=") btVector3 multiplyPut(@Cast("const btScalar") float s);

	/**\brief Inversely scale the vector 
   * @param s Scale factor to divide by */
	public native @ByRef @Name("operator /=") btVector3 dividePut(@Cast("const btScalar") float s);

	/**\brief Return the dot product
   * @param v The other vector in the dot product */
	public native @Cast("btScalar") float dot(@Const @ByRef btVector3 v);

	/**\brief Return the length of the vector squared */
	public native @Cast("btScalar") float length2();

	/**\brief Return the length of the vector */
	public native @Cast("btScalar") float length();

	/**\brief Return the norm (length) of the vector */
	public native @Cast("btScalar") float norm();

	/**\brief Return the norm (length) of the vector */
	public native @Cast("btScalar") float safeNorm();

	/**\brief Return the distance squared between the ends of this and another vector
   * This is symantically treating the vector like a point */
	public native @Cast("btScalar") float distance2(@Const @ByRef btVector3 v);

	/**\brief Return the distance between the ends of this and another vector
   * This is symantically treating the vector like a point */
	public native @Cast("btScalar") float distance(@Const @ByRef btVector3 v);

	public native @ByRef btVector3 safeNormalize();

	/**\brief Normalize this vector 
   * x^2 + y^2 + z^2 = 1 */
	public native @ByRef btVector3 normalize();

	/**\brief Return a normalized version of this vector */
	public native @ByVal btVector3 normalized();

	/**\brief Return a rotated version of this vector
   * @param wAxis The axis to rotate about 
   * @param angle The angle to rotate by */
	public native @ByVal btVector3 rotate(@Const @ByRef btVector3 wAxis, @Cast("const btScalar") float angle);

	/**\brief Return the angle between this and another vector
   * @param v The other vector */
	public native @Cast("btScalar") float angle(@Const @ByRef btVector3 v);

	/**\brief Return a vector with the absolute values of each element */
	public native @ByVal btVector3 absolute();

	/**\brief Return the cross product between this and another vector 
   * @param v The other vector */
	public native @ByVal btVector3 cross(@Const @ByRef btVector3 v);

	public native @Cast("btScalar") float triple(@Const @ByRef btVector3 v1, @Const @ByRef btVector3 v2);

	/**\brief Return the axis with the smallest value 
   * Note return values are 0,1,2 for x, y, or z */
	public native int minAxis();

	/**\brief Return the axis with the largest value 
   * Note return values are 0,1,2 for x, y, or z */
	public native int maxAxis();

	public native int furthestAxis();

	public native int closestAxis();

	public native void setInterpolate3(@Const @ByRef btVector3 v0, @Const @ByRef btVector3 v1, @Cast("btScalar") float rt);

	/**\brief Return the linear interpolation between this and another vector 
   * @param v The other vector 
   * @param t The ration of this to v (t = 0 => return this, t=1 => return other) */
	public native @ByVal btVector3 lerp(@Const @ByRef btVector3 v, @Cast("const btScalar") float t);

	/**\brief Elementwise multiply this vector by the other 
   * @param v The other vector */
	public native @ByRef @Name("operator *=") btVector3 multiplyPut(@Const @ByRef btVector3 v);

	/**\brief Return the x value */
	public native @Cast("const btScalar") float getX();
	/**\brief Return the y value */
	public native @Cast("const btScalar") float getY();
	/**\brief Return the z value */
	public native @Cast("const btScalar") float getZ();
	/**\brief Set the x value */
	public native void setX(@Cast("btScalar") float _x);
	/**\brief Set the y value */
	public native void setY(@Cast("btScalar") float _y);
	/**\brief Set the z value */
	public native void setZ(@Cast("btScalar") float _z);
	/**\brief Set the w value */
	public native void setW(@Cast("btScalar") float _w);
	/**\brief Return the x value */
	public native @Cast("const btScalar") float x();
	/**\brief Return the y value */
	public native @Cast("const btScalar") float y();
	/**\brief Return the z value */
	public native @Cast("const btScalar") float z();
	/**\brief Return the w value */
	public native @Cast("const btScalar") float w();

	//SIMD_FORCE_INLINE btScalar&       operator[](int i)       { return (&m_floats[0])[i];	}
	//SIMD_FORCE_INLINE const btScalar& operator[](int i) const { return (&m_floats[0])[i]; }
	/**operator btScalar*() replaces operator[], using implicit conversion. We added operator != and operator == to avoid pointer comparisons. */
	public native @Cast("btScalar*") @Name("operator btScalar*") FloatPointer asFloatPointer();

	public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef btVector3 other);

	public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef btVector3 other);

	/**\brief Set each element to the max of the current values and the values of another btVector3
   * @param other The other btVector3 to compare with 
   */
	public native void setMax(@Const @ByRef btVector3 other);

	/**\brief Set each element to the min of the current values and the values of another btVector3
   * @param other The other btVector3 to compare with 
   */
	public native void setMin(@Const @ByRef btVector3 other);

	public native void setValue(@Cast("const btScalar") float _x, @Cast("const btScalar") float _y, @Cast("const btScalar") float _z);

	public native void getSkewSymmetricMatrix(btVector3 v0, btVector3 v1, btVector3 v2);

	public native void setZero();

	public native @Cast("bool") boolean isZero();

	public native @Cast("bool") boolean fuzzyZero();

	public native void serialize(@ByRef btVector3FloatData dataOut);

	public native void deSerialize(@Const @ByRef btVector3DoubleData dataIn);

	public native void deSerialize(@Const @ByRef btVector3FloatData dataIn);

	public native void serializeFloat(@ByRef btVector3FloatData dataOut);

	public native void deSerializeFloat(@Const @ByRef btVector3FloatData dataIn);

	public native void serializeDouble(@ByRef btVector3DoubleData dataOut);

	public native void deSerializeDouble(@Const @ByRef btVector3DoubleData dataIn);

	/**\brief returns index of maximum dot product between this and vectors in array[]
         * @param array The other vectors 
         * @param array_count The number of other vectors 
         * @param dotOut The maximum dot product */
	public native long maxDot(@Const btVector3 array, long array_count, @Cast("btScalar*") @ByRef FloatPointer dotOut);
	public native long maxDot(@Const btVector3 array, long array_count, @Cast("btScalar*") @ByRef FloatBuffer dotOut);
	public native long maxDot(@Const btVector3 array, long array_count, @Cast("btScalar*") @ByRef float[] dotOut);

	/**\brief returns index of minimum dot product between this and vectors in array[]
         * @param array The other vectors 
         * @param array_count The number of other vectors 
         * @param dotOut The minimum dot product */
	public native long minDot(@Const btVector3 array, long array_count, @Cast("btScalar*") @ByRef FloatPointer dotOut);
	public native long minDot(@Const btVector3 array, long array_count, @Cast("btScalar*") @ByRef FloatBuffer dotOut);
	public native long minDot(@Const btVector3 array, long array_count, @Cast("btScalar*") @ByRef float[] dotOut);

	/* create a vector as  btVector3( this->dot( btVector3 v0 ), this->dot( btVector3 v1), this->dot( btVector3 v2 ))  */
	public native @ByVal btVector3 dot3(@Const @ByRef btVector3 v0, @Const @ByRef btVector3 v1, @Const @ByRef btVector3 v2);
}

/**\brief Return the sum of two vectors (Point symantics)*/
public static native @ByVal @Name("operator +") btVector3 add(@Const @ByRef btVector3 v1, @Const @ByRef btVector3 v2);

/**\brief Return the elementwise product of two vectors */
public static native @ByVal @Name("operator *") btVector3 multiply(@Const @ByRef btVector3 v1, @Const @ByRef btVector3 v2);

/**\brief Return the difference between two vectors */
public static native @ByVal @Name("operator -") btVector3 subtract(@Const @ByRef btVector3 v1, @Const @ByRef btVector3 v2);

/**\brief Return the negative of the vector */
public static native @ByVal @Name("operator -") btVector3 subtract(@Const @ByRef btVector3 v);

/**\brief Return the vector scaled by s */
public static native @ByVal @Name("operator *") btVector3 multiply(@Const @ByRef btVector3 v, @Cast("const btScalar") float s);

/**\brief Return the vector scaled by s */
public static native @ByVal @Name("operator *") btVector3 multiply(@Cast("const btScalar") float s, @Const @ByRef btVector3 v);

/**\brief Return the vector inversely scaled by s */
public static native @ByVal @Name("operator /") btVector3 divide(@Const @ByRef btVector3 v, @Cast("const btScalar") float s);

/**\brief Return the vector inversely scaled by s */
public static native @ByVal @Name("operator /") btVector3 divide(@Const @ByRef btVector3 v1, @Const @ByRef btVector3 v2);

/**\brief Return the dot product between two vectors */
public static native @Cast("btScalar") float btDot(@Const @ByRef btVector3 v1, @Const @ByRef btVector3 v2);

/**\brief Return the distance squared between two vectors */
public static native @Cast("btScalar") float btDistance2(@Const @ByRef btVector3 v1, @Const @ByRef btVector3 v2);

/**\brief Return the distance between two vectors */
public static native @Cast("btScalar") float btDistance(@Const @ByRef btVector3 v1, @Const @ByRef btVector3 v2);

/**\brief Return the angle between two vectors */
public static native @Cast("btScalar") float btAngle(@Const @ByRef btVector3 v1, @Const @ByRef btVector3 v2);

/**\brief Return the cross product of two vectors */
public static native @ByVal btVector3 btCross(@Const @ByRef btVector3 v1, @Const @ByRef btVector3 v2);

public static native @Cast("btScalar") float btTriple(@Const @ByRef btVector3 v1, @Const @ByRef btVector3 v2, @Const @ByRef btVector3 v3);

/**\brief Return the linear interpolation between two vectors
 * @param v1 One vector 
 * @param v2 The other vector 
 * @param t The ration of this to v (t = 0 => return v1, t=1 => return v2) */
public static native @ByVal btVector3 lerp(@Const @ByRef btVector3 v1, @Const @ByRef btVector3 v2, @Cast("const btScalar") float t);













public static class btVector4 extends btVector3 {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btVector4(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btVector4(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btVector4 position(long position) {
        return (btVector4)super.position(position);
    }
    @Override public btVector4 getPointer(long i) {
        return new btVector4((Pointer)this).offsetAddress(i);
    }

	public btVector4() { super((Pointer)null); allocate(); }
	private native void allocate();

	public btVector4(@Cast("const btScalar") float _x, @Cast("const btScalar") float _y, @Cast("const btScalar") float _z, @Cast("const btScalar") float _w) { super((Pointer)null); allocate(_x, _y, _z, _w); }
	private native void allocate(@Cast("const btScalar") float _x, @Cast("const btScalar") float _y, @Cast("const btScalar") float _z, @Cast("const btScalar") float _w);

// #if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)
// #endif  // #if defined (BT_USE_SSE_IN_API) || defined (BT_USE_NEON)

	public native @ByVal btVector4 absolute4();

	public native @Cast("btScalar") float getW();

	public native int maxAxis4();

	public native int minAxis4();

	public native int closestAxis4();

	/**\brief Set x,y,z and zero w 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   */

	/*		void getValue(btScalar *m) const 
		{
			m[0] = m_floats[0];
			m[1] = m_floats[1];
			m[2] =m_floats[2];
		}
*/
	/**\brief Set the values 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   * @param w Value of w
   */
	public native void setValue(@Cast("const btScalar") float _x, @Cast("const btScalar") float _y, @Cast("const btScalar") float _z, @Cast("const btScalar") float _w);
}

/**btSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization */
public static native void btSwapScalarEndian(@Cast("const btScalar") float sourceVal, @Cast("btScalar*") @ByRef FloatPointer destVal);
public static native void btSwapScalarEndian(@Cast("const btScalar") float sourceVal, @Cast("btScalar*") @ByRef FloatBuffer destVal);
public static native void btSwapScalarEndian(@Cast("const btScalar") float sourceVal, @Cast("btScalar*") @ByRef float[] destVal);
/**btSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization */
public static native void btSwapVector3Endian(@Const @ByRef btVector3 sourceVec, @ByRef btVector3 destVec);

/**btUnSwapVector3Endian swaps vector endianness, useful for network and cross-platform serialization */
public static native void btUnSwapVector3Endian(@ByRef btVector3 vector);

public static class btVector3FloatData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btVector3FloatData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btVector3FloatData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btVector3FloatData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btVector3FloatData position(long position) {
        return (btVector3FloatData)super.position(position);
    }
    @Override public btVector3FloatData getPointer(long i) {
        return new btVector3FloatData((Pointer)this).offsetAddress(i);
    }

	public native float m_floats(int i); public native btVector3FloatData m_floats(int i, float setter);
	@MemberGetter public native FloatPointer m_floats();
}

public static class btVector3DoubleData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btVector3DoubleData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btVector3DoubleData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btVector3DoubleData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btVector3DoubleData position(long position) {
        return (btVector3DoubleData)super.position(position);
    }
    @Override public btVector3DoubleData getPointer(long i) {
        return new btVector3DoubleData((Pointer)this).offsetAddress(i);
    }

	public native double m_floats(int i); public native btVector3DoubleData m_floats(int i, double setter);
	@MemberGetter public native DoublePointer m_floats();
}















// #endif  //BT_VECTOR3_H


// Parsed from LinearMath/btQuadWord.h

/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_SIMD_QUADWORD_H
// #define BT_SIMD_QUADWORD_H

// #include "btScalar.h"
// #include "btMinMax.h"

// #if defined(__CELLOS_LV2) && defined(__SPU__)
// #include <altivec.h>
// #endif

/**\brief The btQuadWord class is base class for btVector3 and btQuaternion. 
 * Some issues under PS3 Linux with IBM 2.1 SDK, gcc compiler prevent from using aligned quadword.
 */
// #ifndef USE_LIBSPE2
@NoOffset public static class btQuadWord extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btQuadWord(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btQuadWord(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btQuadWord position(long position) {
        return (btQuadWord)super.position(position);
    }
    @Override public btQuadWord getPointer(long i) {
        return new btQuadWord((Pointer)this).offsetAddress(i);
    }

// #if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)

// #endif

	/**\brief Return the x value */
	public native @Cast("const btScalar") float getX();
	/**\brief Return the y value */
	public native @Cast("const btScalar") float getY();
	/**\brief Return the z value */
	public native @Cast("const btScalar") float getZ();
	/**\brief Set the x value */
	public native void setX(@Cast("btScalar") float _x);
	/**\brief Set the y value */
	public native void setY(@Cast("btScalar") float _y);
	/**\brief Set the z value */
	public native void setZ(@Cast("btScalar") float _z);
	/**\brief Set the w value */
	public native void setW(@Cast("btScalar") float _w);
	/**\brief Return the x value */
	public native @Cast("const btScalar") float x();
	/**\brief Return the y value */
	public native @Cast("const btScalar") float y();
	/**\brief Return the z value */
	public native @Cast("const btScalar") float z();
	/**\brief Return the w value */
	public native @Cast("const btScalar") float w();

	//SIMD_FORCE_INLINE btScalar&       operator[](int i)       { return (&m_floats[0])[i];	}
	//SIMD_FORCE_INLINE const btScalar& operator[](int i) const { return (&m_floats[0])[i]; }
	/**operator btScalar*() replaces operator[], using implicit conversion. We added operator != and operator == to avoid pointer comparisons. */
	public native @Cast("btScalar*") @Name("operator btScalar*") FloatPointer asFloatPointer();

	public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef btQuadWord other);

	public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef btQuadWord other);

	/**\brief Set x,y,z and zero w 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   */
	public native void setValue(@Cast("const btScalar") float _x, @Cast("const btScalar") float _y, @Cast("const btScalar") float _z);

	/*		void getValue(btScalar *m) const 
		{
			m[0] = m_floats[0];
			m[1] = m_floats[1];
			m[2] = m_floats[2];
		}
*/
	/**\brief Set the values 
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   * @param w Value of w
   */
	public native void setValue(@Cast("const btScalar") float _x, @Cast("const btScalar") float _y, @Cast("const btScalar") float _z, @Cast("const btScalar") float _w);
	/**\brief No initialization constructor */
	public btQuadWord() { super((Pointer)null); allocate(); }
	private native void allocate();

	/**\brief Three argument constructor (zeros w)
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   */
	public btQuadWord(@Cast("const btScalar") float _x, @Cast("const btScalar") float _y, @Cast("const btScalar") float _z) { super((Pointer)null); allocate(_x, _y, _z); }
	private native void allocate(@Cast("const btScalar") float _x, @Cast("const btScalar") float _y, @Cast("const btScalar") float _z);

	/**\brief Initializing constructor
   * @param x Value of x
   * @param y Value of y
   * @param z Value of z
   * @param w Value of w
   */
	public btQuadWord(@Cast("const btScalar") float _x, @Cast("const btScalar") float _y, @Cast("const btScalar") float _z, @Cast("const btScalar") float _w) { super((Pointer)null); allocate(_x, _y, _z, _w); }
	private native void allocate(@Cast("const btScalar") float _x, @Cast("const btScalar") float _y, @Cast("const btScalar") float _z, @Cast("const btScalar") float _w);

	/**\brief Set each element to the max of the current values and the values of another btQuadWord
   * @param other The other btQuadWord to compare with 
   */
	public native void setMax(@Const @ByRef btQuadWord other);
	/**\brief Set each element to the min of the current values and the values of another btQuadWord
   * @param other The other btQuadWord to compare with 
   */
	public native void setMin(@Const @ByRef btQuadWord other);
}

// #endif  //BT_SIMD_QUADWORD_H


// Parsed from LinearMath/btQuaternion.h

/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_SIMD__QUATERNION_H_
// #define BT_SIMD__QUATERNION_H_

// #include "btVector3.h"
// #include "btQuadWord.h"

// #ifdef BT_USE_DOUBLE_PRECISION
// #else
// #define btQuaternionData btQuaternionFloatData
public static final String btQuaternionDataName = "btQuaternionFloatData";
// #endif  //BT_USE_DOUBLE_PRECISION

// #ifdef BT_USE_SSE

// #endif

// #if defined(BT_USE_SSE)

// #elif defined(BT_USE_NEON)

// #endif

/**\brief The btQuaternion implements quaternion to perform linear algebra rotations in combination with btMatrix3x3, btVector3 and btTransform. */
public static class btQuaternion extends btQuadWord {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btQuaternion(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btQuaternion(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btQuaternion position(long position) {
        return (btQuaternion)super.position(position);
    }
    @Override public btQuaternion getPointer(long i) {
        return new btQuaternion((Pointer)this).offsetAddress(i);
    }

	/**\brief No initialization constructor */
	public btQuaternion() { super((Pointer)null); allocate(); }
	private native void allocate();

// #if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)

// #endif

	//		template <typename btScalar>
	//		explicit Quaternion(const btScalar *v) : Tuple4<btScalar>(v) {}
	/**\brief Constructor from scalars */
	public btQuaternion(@Cast("const btScalar") float _x, @Cast("const btScalar") float _y, @Cast("const btScalar") float _z, @Cast("const btScalar") float _w) { super((Pointer)null); allocate(_x, _y, _z, _w); }
	private native void allocate(@Cast("const btScalar") float _x, @Cast("const btScalar") float _y, @Cast("const btScalar") float _z, @Cast("const btScalar") float _w);
	/**\brief Axis angle Constructor
   * @param axis The axis which the rotation is around
   * @param angle The magnitude of the rotation around the angle (Radians) */
	public btQuaternion(@Const @ByRef btVector3 _axis, @Cast("const btScalar") float _angle) { super((Pointer)null); allocate(_axis, _angle); }
	private native void allocate(@Const @ByRef btVector3 _axis, @Cast("const btScalar") float _angle);
	/**\brief Constructor from Euler angles
   * @param yaw Angle around Y unless BT_EULER_DEFAULT_ZYX defined then Z
   * @param pitch Angle around X unless BT_EULER_DEFAULT_ZYX defined then Y
   * @param roll Angle around Z unless BT_EULER_DEFAULT_ZYX defined then X */
	public btQuaternion(@Cast("const btScalar") float yaw, @Cast("const btScalar") float pitch, @Cast("const btScalar") float roll) { super((Pointer)null); allocate(yaw, pitch, roll); }
	private native void allocate(@Cast("const btScalar") float yaw, @Cast("const btScalar") float pitch, @Cast("const btScalar") float roll);
	/**\brief Set the rotation using axis angle notation 
   * @param axis The axis around which to rotate
   * @param angle The magnitude of the rotation in Radians */
	public native void setRotation(@Const @ByRef btVector3 axis, @Cast("const btScalar") float _angle);
	/**\brief Set the quaternion using Euler angles
   * @param yaw Angle around Y
   * @param pitch Angle around X
   * @param roll Angle around Z */
	public native void setEuler(@Cast("const btScalar") float yaw, @Cast("const btScalar") float pitch, @Cast("const btScalar") float roll);
	/**\brief Set the quaternion using euler angles 
   * @param yaw Angle around Z
   * @param pitch Angle around Y
   * @param roll Angle around X */
	public native void setEulerZYX(@Cast("const btScalar") float yawZ, @Cast("const btScalar") float pitchY, @Cast("const btScalar") float rollX);

	/**\brief Get the euler angles from this quaternion
	   * @param yaw Angle around Z
	   * @param pitch Angle around Y
	   * @param roll Angle around X */
	public native void getEulerZYX(@Cast("btScalar*") @ByRef FloatPointer yawZ, @Cast("btScalar*") @ByRef FloatPointer pitchY, @Cast("btScalar*") @ByRef FloatPointer rollX);
	public native void getEulerZYX(@Cast("btScalar*") @ByRef FloatBuffer yawZ, @Cast("btScalar*") @ByRef FloatBuffer pitchY, @Cast("btScalar*") @ByRef FloatBuffer rollX);
	public native void getEulerZYX(@Cast("btScalar*") @ByRef float[] yawZ, @Cast("btScalar*") @ByRef float[] pitchY, @Cast("btScalar*") @ByRef float[] rollX);

	/**\brief Add two quaternions
   * @param q The quaternion to add to this one */
	public native @ByRef @Name("operator +=") btQuaternion addPut(@Const @ByRef btQuaternion q);

	/**\brief Subtract out a quaternion
   * @param q The quaternion to subtract from this one */
	public native @ByRef @Name("operator -=") btQuaternion subtractPut(@Const @ByRef btQuaternion q);

	/**\brief Scale this quaternion
   * @param s The scalar to scale by */
	public native @ByRef @Name("operator *=") btQuaternion multiplyPut(@Cast("const btScalar") float s);

	/**\brief Multiply this quaternion by q on the right
   * @param q The other quaternion 
   * Equivilant to this = this * q */
	public native @ByRef @Name("operator *=") btQuaternion multiplyPut(@Const @ByRef btQuaternion q);
	/**\brief Return the dot product between this quaternion and another
   * @param q The other quaternion */
	public native @Cast("btScalar") float dot(@Const @ByRef btQuaternion q);

	/**\brief Return the length squared of the quaternion */
	public native @Cast("btScalar") float length2();

	/**\brief Return the length of the quaternion */
	public native @Cast("btScalar") float length();
	public native @ByRef btQuaternion safeNormalize();
	/**\brief Normalize the quaternion 
   * Such that x^2 + y^2 + z^2 +w^2 = 1 */
	public native @ByRef btQuaternion normalize();

	/**\brief Return a scaled version of this quaternion
   * @param s The scale factor */
	public native @ByVal @Name("operator *") btQuaternion multiply(@Cast("const btScalar") float s);

	/**\brief Return an inversely scaled versionof this quaternion
   * @param s The inverse scale factor */
	public native @ByVal @Name("operator /") btQuaternion divide(@Cast("const btScalar") float s);

	/**\brief Inversely scale this quaternion
   * @param s The scale factor */
	public native @ByRef @Name("operator /=") btQuaternion dividePut(@Cast("const btScalar") float s);

	/**\brief Return a normalized version of this quaternion */
	public native @ByVal btQuaternion normalized();
	/**\brief Return the ***half*** angle between this quaternion and the other
   * @param q The other quaternion */
	public native @Cast("btScalar") float angle(@Const @ByRef btQuaternion q);

	/**\brief Return the angle between this quaternion and the other along the shortest path
	* @param q The other quaternion */
	public native @Cast("btScalar") float angleShortestPath(@Const @ByRef btQuaternion q);

	/**\brief Return the angle [0, 2Pi] of rotation represented by this quaternion */
	public native @Cast("btScalar") float getAngle();

	/**\brief Return the angle [0, Pi] of rotation represented by this quaternion along the shortest path */
	public native @Cast("btScalar") float getAngleShortestPath();

	/**\brief Return the axis of the rotation represented by this quaternion */
	public native @ByVal btVector3 getAxis();

	/**\brief Return the inverse of this quaternion */
	public native @ByVal btQuaternion inverse();

	/**\brief Return the sum of this quaternion and the other 
   * @param q2 The other quaternion */
	public native @ByVal @Name("operator +") btQuaternion add(@Const @ByRef btQuaternion q2);

	/**\brief Return the difference between this quaternion and the other 
   * @param q2 The other quaternion */
	public native @ByVal @Name("operator -") btQuaternion subtract(@Const @ByRef btQuaternion q2);

	/**\brief Return the negative of this quaternion 
   * This simply negates each element */
	public native @ByVal @Name("operator -") btQuaternion subtract();
	/**\todo document this and it's use */
	public native @ByVal btQuaternion farthest(@Const @ByRef btQuaternion qd);

	/**\todo document this and it's use */
	public native @ByVal btQuaternion nearest(@Const @ByRef btQuaternion qd);

	/**\brief Return the quaternion which is the result of Spherical Linear Interpolation between this and the other quaternion
   * @param q The other quaternion to interpolate with 
   * @param t The ratio between this and q to interpolate.  If t = 0 the result is this, if t=1 the result is q.
   * Slerp interpolates assuming constant velocity.  */
	public native @ByVal btQuaternion slerp(@Const @ByRef btQuaternion q, @Cast("const btScalar") float t);

	public static native @Const @ByRef btQuaternion getIdentity();

	public native @Cast("const btScalar") float getW();

	public native void serialize(@ByRef btQuaternionFloatData dataOut);

	public native void deSerialize(@Const @ByRef btQuaternionFloatData dataIn);

	public native void deSerialize(@Const @ByRef btQuaternionDoubleData dataIn);

	public native void serializeFloat(@ByRef btQuaternionFloatData dataOut);

	public native void deSerializeFloat(@Const @ByRef btQuaternionFloatData dataIn);

	public native void serializeDouble(@ByRef btQuaternionDoubleData dataOut);

	public native void deSerializeDouble(@Const @ByRef btQuaternionDoubleData dataIn);
}

/**\brief Return the product of two quaternions */
public static native @ByVal @Name("operator *") btQuaternion multiply(@Const @ByRef btQuaternion q1, @Const @ByRef btQuaternion q2);

public static native @ByVal @Name("operator *") btQuaternion multiply(@Const @ByRef btQuaternion q, @Const @ByRef btVector3 w);

public static native @ByVal @Name("operator *") btQuaternion multiply(@Const @ByRef btVector3 w, @Const @ByRef btQuaternion q);

/**\brief Calculate the dot product between two quaternions */
public static native @Cast("btScalar") float dot(@Const @ByRef btQuaternion q1, @Const @ByRef btQuaternion q2);

/**\brief Return the length of a quaternion */
public static native @Cast("btScalar") float length(@Const @ByRef btQuaternion q);

/**\brief Return the angle between two quaternions*/
public static native @Cast("btScalar") float btAngle(@Const @ByRef btQuaternion q1, @Const @ByRef btQuaternion q2);

/**\brief Return the inverse of a quaternion*/
public static native @ByVal btQuaternion inverse(@Const @ByRef btQuaternion q);

/**\brief Return the result of spherical linear interpolation betwen two quaternions 
 * @param q1 The first quaternion
 * @param q2 The second quaternion 
 * @param t The ration between q1 and q2.  t = 0 return q1, t=1 returns q2 
 * Slerp assumes constant velocity between positions. */
public static native @ByVal btQuaternion slerp(@Const @ByRef btQuaternion q1, @Const @ByRef btQuaternion q2, @Cast("const btScalar") float t);

public static native @ByVal btVector3 quatRotate(@Const @ByRef btQuaternion rotation, @Const @ByRef btVector3 v);

public static native @ByVal btQuaternion shortestArcQuat(@Const @ByRef btVector3 v0, @Const @ByRef btVector3 v1);

public static native @ByVal btQuaternion shortestArcQuatNormalize2(@ByRef btVector3 v0, @ByRef btVector3 v1);

public static class btQuaternionFloatData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btQuaternionFloatData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btQuaternionFloatData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btQuaternionFloatData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btQuaternionFloatData position(long position) {
        return (btQuaternionFloatData)super.position(position);
    }
    @Override public btQuaternionFloatData getPointer(long i) {
        return new btQuaternionFloatData((Pointer)this).offsetAddress(i);
    }

	public native float m_floats(int i); public native btQuaternionFloatData m_floats(int i, float setter);
	@MemberGetter public native FloatPointer m_floats();
}

public static class btQuaternionDoubleData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btQuaternionDoubleData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btQuaternionDoubleData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btQuaternionDoubleData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btQuaternionDoubleData position(long position) {
        return (btQuaternionDoubleData)super.position(position);
    }
    @Override public btQuaternionDoubleData getPointer(long i) {
        return new btQuaternionDoubleData((Pointer)this).offsetAddress(i);
    }

	public native double m_floats(int i); public native btQuaternionDoubleData m_floats(int i, double setter);
	@MemberGetter public native DoublePointer m_floats();
}















// #endif  //BT_SIMD__QUATERNION_H_


// Parsed from LinearMath/btMatrix3x3.h

/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_MATRIX3x3_H
// #define BT_MATRIX3x3_H

// #include "btVector3.h"
// #include "btQuaternion.h"
// #include <stdio.h>

// #ifdef BT_USE_SSE
// #endif

// #if defined(BT_USE_SSE)
// #elif defined(BT_USE_NEON)
// #endif

// #ifdef BT_USE_DOUBLE_PRECISION
// #else
// #define btMatrix3x3Data btMatrix3x3FloatData
// #endif  //BT_USE_DOUBLE_PRECISION

/**\brief The btMatrix3x3 class implements a 3x3 rotation matrix, to perform linear algebra in combination with btQuaternion, btTransform and btVector3.
* Make sure to only include a pure orthogonal matrix without scaling. */
@NoOffset public static class btMatrix3x3 extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btMatrix3x3(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btMatrix3x3(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btMatrix3x3 position(long position) {
        return (btMatrix3x3)super.position(position);
    }
    @Override public btMatrix3x3 getPointer(long i) {
        return new btMatrix3x3((Pointer)this).offsetAddress(i);
    }

	/** \brief No initializaion constructor */
	public btMatrix3x3() { super((Pointer)null); allocate(); }
	private native void allocate();

	//		explicit btMatrix3x3(const btScalar *m) { setFromOpenGLSubMatrix(m); }

	/**\brief Constructor from Quaternion */
	public btMatrix3x3(@Const @ByRef btQuaternion q) { super((Pointer)null); allocate(q); }
	private native void allocate(@Const @ByRef btQuaternion q);
	/*
	template <typename btScalar>
	Matrix3x3(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
	{ 
	setEulerYPR(yaw, pitch, roll);
	}
	*/
	/** \brief Constructor with row major formatting */
	public btMatrix3x3(@Cast("const btScalar") float xx, @Cast("const btScalar") float xy, @Cast("const btScalar") float xz,
					@Cast("const btScalar") float yx, @Cast("const btScalar") float yy, @Cast("const btScalar") float yz,
					@Cast("const btScalar") float zx, @Cast("const btScalar") float zy, @Cast("const btScalar") float zz) { super((Pointer)null); allocate(xx, xy, xz, yx, yy, yz, zx, zy, zz); }
	private native void allocate(@Cast("const btScalar") float xx, @Cast("const btScalar") float xy, @Cast("const btScalar") float xz,
					@Cast("const btScalar") float yx, @Cast("const btScalar") float yy, @Cast("const btScalar") float yz,
					@Cast("const btScalar") float zx, @Cast("const btScalar") float zy, @Cast("const btScalar") float zz);

// #if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)

// #else

	/** \brief Copy constructor */
	public btMatrix3x3(@Const @ByRef btMatrix3x3 other) { super((Pointer)null); allocate(other); }
	private native void allocate(@Const @ByRef btMatrix3x3 other);

	/** \brief Assignment Operator */
	public native @ByRef @Name("operator =") btMatrix3x3 put(@Const @ByRef btMatrix3x3 other);
    
    public btMatrix3x3(@Const @ByRef btVector3 v0, @Const @ByRef btVector3 v1, @Const @ByRef btVector3 v2) { super((Pointer)null); allocate(v0, v1, v2); }
    private native void allocate(@Const @ByRef btVector3 v0, @Const @ByRef btVector3 v1, @Const @ByRef btVector3 v2);

// #endif

	/** \brief Get a column of the matrix as a vector 
	*  @param i Column number 0 indexed */
	public native @ByVal btVector3 getColumn(int i);

	/** \brief Get a row of the matrix as a vector 
	*  @param i Row number 0 indexed */
	public native @Const @ByRef btVector3 getRow(int i);

	/** \brief Get a mutable reference to a row of the matrix as a vector 
	*  @param i Row number 0 indexed */
	public native @ByRef @Name("operator []") btVector3 get(int i);

	/** \brief Get a const reference to a row of the matrix as a vector 
	*  @param i Row number 0 indexed */

	/** \brief Multiply by the target matrix on the right
	*  @param m Rotation matrix to be applied 
	* Equivilant to this = this * m */
	public native @ByRef @Name("operator *=") btMatrix3x3 multiplyPut(@Const @ByRef btMatrix3x3 m);

	/** \brief Adds by the target matrix on the right
	*  @param m matrix to be applied 
	* Equivilant to this = this + m */
	public native @ByRef @Name("operator +=") btMatrix3x3 addPut(@Const @ByRef btMatrix3x3 m);

	/** \brief Substractss by the target matrix on the right
	*  @param m matrix to be applied 
	* Equivilant to this = this - m */
	public native @ByRef @Name("operator -=") btMatrix3x3 subtractPut(@Const @ByRef btMatrix3x3 m);

	/** \brief Set from the rotational part of a 4x4 OpenGL matrix
	*  @param m A pointer to the beginning of the array of scalars*/
	public native void setFromOpenGLSubMatrix(@Cast("const btScalar*") FloatPointer m);
	public native void setFromOpenGLSubMatrix(@Cast("const btScalar*") FloatBuffer m);
	public native void setFromOpenGLSubMatrix(@Cast("const btScalar*") float[] m);
	/** \brief Set the values of the matrix explicitly (row major)
	*  @param xx Top left
	*  @param xy Top Middle
	*  @param xz Top Right
	*  @param yx Middle Left
	*  @param yy Middle Middle
	*  @param yz Middle Right
	*  @param zx Bottom Left
	*  @param zy Bottom Middle
	*  @param zz Bottom Right*/
	public native void setValue(@Cast("const btScalar") float xx, @Cast("const btScalar") float xy, @Cast("const btScalar") float xz,
					  @Cast("const btScalar") float yx, @Cast("const btScalar") float yy, @Cast("const btScalar") float yz,
					  @Cast("const btScalar") float zx, @Cast("const btScalar") float zy, @Cast("const btScalar") float zz);

	/** \brief Set the matrix from a quaternion
	*  @param q The Quaternion to match */
	public native void setRotation(@Const @ByRef btQuaternion q);

	/** \brief Set the matrix from euler angles using YPR around YXZ respectively
	*  @param yaw Yaw about Y axis
	*  @param pitch Pitch about X axis
	*  @param roll Roll about Z axis 
	*/
	public native void setEulerYPR(@Cast("const btScalar") float yaw, @Cast("const btScalar") float pitch, @Cast("const btScalar") float roll);

	/** \brief Set the matrix from euler angles YPR around ZYX axes
	* @param eulerX Roll about X axis
	* @param eulerY Pitch around Y axis
	* @param eulerZ Yaw about Z axis
	* 
	* These angles are used to produce a rotation matrix. The euler
	* angles are applied in ZYX order. I.e a vector is first rotated 
	* about X then Y and then Z
	**/
	public native void setEulerZYX(@Cast("btScalar") float eulerX, @Cast("btScalar") float eulerY, @Cast("btScalar") float eulerZ);

	/**\brief Set the matrix to the identity */
	public native void setIdentity();
    
    /**\brief Set the matrix to the identity */
    public native void setZero();

	public static native @Const @ByRef btMatrix3x3 getIdentity();

	/**\brief Fill the rotational part of an OpenGL matrix and clear the shear/perspective
	* @param m The array to be filled */
	public native void getOpenGLSubMatrix(@Cast("btScalar*") FloatPointer m);
	public native void getOpenGLSubMatrix(@Cast("btScalar*") FloatBuffer m);
	public native void getOpenGLSubMatrix(@Cast("btScalar*") float[] m);

	/**\brief Get the matrix represented as a quaternion 
	* @param q The quaternion which will be set */
	public native void getRotation(@ByRef btQuaternion q);

	/**\brief Get the matrix represented as euler angles around YXZ, roundtrip with setEulerYPR
	* @param yaw Yaw around Y axis
	* @param pitch Pitch around X axis
	* @param roll around Z axis */
	public native void getEulerYPR(@Cast("btScalar*") @ByRef FloatPointer yaw, @Cast("btScalar*") @ByRef FloatPointer pitch, @Cast("btScalar*") @ByRef FloatPointer roll);
	public native void getEulerYPR(@Cast("btScalar*") @ByRef FloatBuffer yaw, @Cast("btScalar*") @ByRef FloatBuffer pitch, @Cast("btScalar*") @ByRef FloatBuffer roll);
	public native void getEulerYPR(@Cast("btScalar*") @ByRef float[] yaw, @Cast("btScalar*") @ByRef float[] pitch, @Cast("btScalar*") @ByRef float[] roll);

	/**\brief Get the matrix represented as euler angles around ZYX
	* @param yaw Yaw around Z axis
	* @param pitch Pitch around Y axis
	* @param roll around X axis 
	* @param solution_number Which solution of two possible solutions ( 1 or 2) are possible values*/
	public native void getEulerZYX(@Cast("btScalar*") @ByRef FloatPointer yaw, @Cast("btScalar*") @ByRef FloatPointer pitch, @Cast("btScalar*") @ByRef FloatPointer roll, @Cast("unsigned int") int solution_number/*=1*/);
	public native void getEulerZYX(@Cast("btScalar*") @ByRef FloatPointer yaw, @Cast("btScalar*") @ByRef FloatPointer pitch, @Cast("btScalar*") @ByRef FloatPointer roll);
	public native void getEulerZYX(@Cast("btScalar*") @ByRef FloatBuffer yaw, @Cast("btScalar*") @ByRef FloatBuffer pitch, @Cast("btScalar*") @ByRef FloatBuffer roll, @Cast("unsigned int") int solution_number/*=1*/);
	public native void getEulerZYX(@Cast("btScalar*") @ByRef FloatBuffer yaw, @Cast("btScalar*") @ByRef FloatBuffer pitch, @Cast("btScalar*") @ByRef FloatBuffer roll);
	public native void getEulerZYX(@Cast("btScalar*") @ByRef float[] yaw, @Cast("btScalar*") @ByRef float[] pitch, @Cast("btScalar*") @ByRef float[] roll, @Cast("unsigned int") int solution_number/*=1*/);
	public native void getEulerZYX(@Cast("btScalar*") @ByRef float[] yaw, @Cast("btScalar*") @ByRef float[] pitch, @Cast("btScalar*") @ByRef float[] roll);

	/**\brief Create a scaled copy of the matrix 
	* @param s Scaling vector The elements of the vector will scale each column */

	public native @ByVal btMatrix3x3 scaled(@Const @ByRef btVector3 s);

	/**\brief Return the determinant of the matrix */
	public native @Cast("btScalar") float determinant();
	/**\brief Return the adjoint of the matrix */
	public native @ByVal btMatrix3x3 adjoint();
	/**\brief Return the matrix with all values non negative */
	public native @ByVal btMatrix3x3 absolute();
	/**\brief Return the transpose of the matrix */
	public native @ByVal btMatrix3x3 transpose();
	/**\brief Return the inverse of the matrix */
	public native @ByVal btMatrix3x3 inverse();

	/** Solve A * x = b, where b is a column vector. This is more efficient
	 *  than computing the inverse in one-shot cases.
	 * Solve33 is from Box2d, thanks to Erin Catto, */
	public native @ByVal btVector3 solve33(@Const @ByRef btVector3 b);

	public native @ByVal btMatrix3x3 transposeTimes(@Const @ByRef btMatrix3x3 m);
	public native @ByVal btMatrix3x3 timesTranspose(@Const @ByRef btMatrix3x3 m);

	public native @Cast("btScalar") float tdotx(@Const @ByRef btVector3 v);
	public native @Cast("btScalar") float tdoty(@Const @ByRef btVector3 v);
	public native @Cast("btScalar") float tdotz(@Const @ByRef btVector3 v);

	/**extractRotation is from "A robust method to extract the rotational part of deformations"
	 * See http://dl.acm.org/citation.cfm?doid=2994258.2994269
	 * decomposes a matrix A in a orthogonal matrix R and a
	 * symmetric matrix S:
	 * A = R*S.
	 * note that R can include both rotation and scaling. */
	public native void extractRotation(@ByRef btQuaternion q, @Cast("btScalar") float tolerance/*=1.0e-9*/, int maxIter/*=100*/);
	public native void extractRotation(@ByRef btQuaternion q);

	/**\brief diagonalizes this matrix by the Jacobi method.
	* @param rot stores the rotation from the coordinate system in which the matrix is diagonal to the original
	* coordinate system, i.e., old_this = rot * new_this * rot^T.
	* @param threshold See iteration
	* @param iteration The iteration stops when all off-diagonal elements are less than the threshold multiplied
	* by the sum of the absolute values of the diagonal, or when maxSteps have been executed.
	*
	* Note that this matrix is assumed to be symmetric.
	*/
	public native void diagonalize(@ByRef btMatrix3x3 rot, @Cast("btScalar") float threshold, int maxSteps);

	/**\brief Calculate the matrix cofactor 
	* @param r1 The first row to use for calculating the cofactor
	* @param c1 The first column to use for calculating the cofactor
	* @param r1 The second row to use for calculating the cofactor
	* @param c1 The second column to use for calculating the cofactor
	* See http://en.wikipedia.org/wiki/Cofactor_(linear_algebra) for more details
	*/
	public native @Cast("btScalar") float cofac(int r1, int c1, int r2, int c2);

	public native void serialize(@ByRef btMatrix3x3FloatData dataOut);

	public native void serializeFloat(@ByRef btMatrix3x3FloatData dataOut);

	public native void deSerialize(@Const @ByRef btMatrix3x3FloatData dataIn);

	public native void deSerializeFloat(@Const @ByRef btMatrix3x3FloatData dataIn);

	public native void deSerializeDouble(@Const @ByRef btMatrix3x3DoubleData dataIn);
}





public static native @ByVal @Name("operator *") btMatrix3x3 multiply(@Const @ByRef btMatrix3x3 m, @Cast("const btScalar") float k);

public static native @ByVal @Name("operator +") btMatrix3x3 add(@Const @ByRef btMatrix3x3 m1, @Const @ByRef btMatrix3x3 m2);

public static native @ByVal @Name("operator -") btMatrix3x3 subtract(@Const @ByRef btMatrix3x3 m1, @Const @ByRef btMatrix3x3 m2);

















public static native @ByVal @Name("operator *") btVector3 multiply(@Const @ByRef btMatrix3x3 m, @Const @ByRef btVector3 v);

public static native @ByVal @Name("operator *") btVector3 multiply(@Const @ByRef btVector3 v, @Const @ByRef btMatrix3x3 m);

public static native @ByVal @Name("operator *") btMatrix3x3 multiply(@Const @ByRef btMatrix3x3 m1, @Const @ByRef btMatrix3x3 m2);

/*
SIMD_FORCE_INLINE btMatrix3x3 btMultTransposeLeft(const btMatrix3x3& m1, const btMatrix3x3& m2) {
return btMatrix3x3(
m1[0][0] * m2[0][0] + m1[1][0] * m2[1][0] + m1[2][0] * m2[2][0],
m1[0][0] * m2[0][1] + m1[1][0] * m2[1][1] + m1[2][0] * m2[2][1],
m1[0][0] * m2[0][2] + m1[1][0] * m2[1][2] + m1[2][0] * m2[2][2],
m1[0][1] * m2[0][0] + m1[1][1] * m2[1][0] + m1[2][1] * m2[2][0],
m1[0][1] * m2[0][1] + m1[1][1] * m2[1][1] + m1[2][1] * m2[2][1],
m1[0][1] * m2[0][2] + m1[1][1] * m2[1][2] + m1[2][1] * m2[2][2],
m1[0][2] * m2[0][0] + m1[1][2] * m2[1][0] + m1[2][2] * m2[2][0],
m1[0][2] * m2[0][1] + m1[1][2] * m2[1][1] + m1[2][2] * m2[2][1],
m1[0][2] * m2[0][2] + m1[1][2] * m2[1][2] + m1[2][2] * m2[2][2]);
}
*/

/**\brief Equality operator between two matrices
* It will test all elements are equal.  */
public static native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef btMatrix3x3 m1, @Const @ByRef btMatrix3x3 m2);

/**for serialization */
public static class btMatrix3x3FloatData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btMatrix3x3FloatData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btMatrix3x3FloatData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btMatrix3x3FloatData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btMatrix3x3FloatData position(long position) {
        return (btMatrix3x3FloatData)super.position(position);
    }
    @Override public btMatrix3x3FloatData getPointer(long i) {
        return new btMatrix3x3FloatData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btVector3FloatData m_el(int i); public native btMatrix3x3FloatData m_el(int i, btVector3FloatData setter);
	@MemberGetter public native btVector3FloatData m_el();
}

/**for serialization */
public static class btMatrix3x3DoubleData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btMatrix3x3DoubleData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btMatrix3x3DoubleData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btMatrix3x3DoubleData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btMatrix3x3DoubleData position(long position) {
        return (btMatrix3x3DoubleData)super.position(position);
    }
    @Override public btMatrix3x3DoubleData getPointer(long i) {
        return new btMatrix3x3DoubleData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btVector3DoubleData m_el(int i); public native btMatrix3x3DoubleData m_el(int i, btVector3DoubleData setter);
	@MemberGetter public native btVector3DoubleData m_el();
}











// #endif  //BT_MATRIX3x3_H


// Parsed from LinearMath/btTransform.h

/*
Copyright (c) 2003-2006 Gino van den Bergen / Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_TRANSFORM_H
// #define BT_TRANSFORM_H

// #include "btMatrix3x3.h"

// #ifdef BT_USE_DOUBLE_PRECISION
// #else
// #define btTransformData btTransformFloatData
// #endif

/**\brief The btTransform class supports rigid transforms with only translation and rotation and no scaling/shear.
 *It can be used in combination with btVector3, btQuaternion and btMatrix3x3 linear algebra classes. */
@NoOffset public static class btTransform extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btTransform(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btTransform(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btTransform position(long position) {
        return (btTransform)super.position(position);
    }
    @Override public btTransform getPointer(long i) {
        return new btTransform((Pointer)this).offsetAddress(i);
    }

	/**\brief No initialization constructor */
	public btTransform() { super((Pointer)null); allocate(); }
	private native void allocate();
	/**\brief Constructor from btQuaternion (optional btVector3 )
   * @param q Rotation from quaternion 
   * @param c Translation from Vector (default 0,0,0) */
	public btTransform(@Const @ByRef btQuaternion q,
											   @Const @ByRef(nullValue = "btVector3(btScalar(0), btScalar(0), btScalar(0))") btVector3 c) { super((Pointer)null); allocate(q, c); }
	private native void allocate(@Const @ByRef btQuaternion q,
											   @Const @ByRef(nullValue = "btVector3(btScalar(0), btScalar(0), btScalar(0))") btVector3 c);
	public btTransform(@Const @ByRef btQuaternion q) { super((Pointer)null); allocate(q); }
	private native void allocate(@Const @ByRef btQuaternion q);

	/**\brief Constructor from btMatrix3x3 (optional btVector3)
   * @param b Rotation from Matrix 
   * @param c Translation from Vector default (0,0,0)*/
	public btTransform(@Const @ByRef btMatrix3x3 b,
											   @Const @ByRef(nullValue = "btVector3(btScalar(0), btScalar(0), btScalar(0))") btVector3 c) { super((Pointer)null); allocate(b, c); }
	private native void allocate(@Const @ByRef btMatrix3x3 b,
											   @Const @ByRef(nullValue = "btVector3(btScalar(0), btScalar(0), btScalar(0))") btVector3 c);
	public btTransform(@Const @ByRef btMatrix3x3 b) { super((Pointer)null); allocate(b); }
	private native void allocate(@Const @ByRef btMatrix3x3 b);
	/**\brief Copy constructor */
	public btTransform(@Const @ByRef btTransform other) { super((Pointer)null); allocate(other); }
	private native void allocate(@Const @ByRef btTransform other);
	/**\brief Assignment Operator */
	public native @ByRef @Name("operator =") btTransform put(@Const @ByRef btTransform other);

	/**\brief Set the current transform as the value of the product of two transforms
   * @param t1 Transform 1
   * @param t2 Transform 2
   * This = Transform1 * Transform2 */
	public native void mult(@Const @ByRef btTransform t1, @Const @ByRef btTransform t2);

	/*		void multInverseLeft(const btTransform& t1, const btTransform& t2) {
			btVector3 v = t2.m_origin - t1.m_origin;
			m_basis = btMultTransposeLeft(t1.m_basis, t2.m_basis);
			m_origin = v * t1.m_basis;
		}
		*/

	/**\brief Return the transform of the vector */
	public native @ByVal @Name("operator ()") btVector3 apply(@Const @ByRef btVector3 x);

	/**\brief Return the transform of the vector */
	public native @ByVal @Name("operator *") btVector3 multiply(@Const @ByRef btVector3 x);

	/**\brief Return the transform of the btQuaternion */
	public native @ByVal @Name("operator *") btQuaternion multiply(@Const @ByRef btQuaternion q);

	/**\brief Return the basis matrix for the rotation */
	public native @ByRef btMatrix3x3 getBasis();
	/**\brief Return the basis matrix for the rotation */

	/**\brief Return the origin vector translation */
	public native @ByRef btVector3 getOrigin();
	/**\brief Return the origin vector translation */

	/**\brief Return a quaternion representing the rotation */
	public native @ByVal btQuaternion getRotation();

	/**\brief Set from an array 
   * @param m A pointer to a 16 element array (12 rotation(row major padded on the right by 1), and 3 translation */
	public native void setFromOpenGLMatrix(@Cast("const btScalar*") FloatPointer m);
	public native void setFromOpenGLMatrix(@Cast("const btScalar*") FloatBuffer m);
	public native void setFromOpenGLMatrix(@Cast("const btScalar*") float[] m);

	/**\brief Fill an array representation
   * @param m A pointer to a 16 element array (12 rotation(row major padded on the right by 1), and 3 translation */
	public native void getOpenGLMatrix(@Cast("btScalar*") FloatPointer m);
	public native void getOpenGLMatrix(@Cast("btScalar*") FloatBuffer m);
	public native void getOpenGLMatrix(@Cast("btScalar*") float[] m);

	/**\brief Set the translational element
   * @param origin The vector to set the translation to */
	public native void setOrigin(@Const @ByRef btVector3 origin);

	public native @ByVal btVector3 invXform(@Const @ByRef btVector3 inVec);

	/**\brief Set the rotational element by btMatrix3x3 */
	public native void setBasis(@Const @ByRef btMatrix3x3 basis);

	/**\brief Set the rotational element by btQuaternion */
	public native void setRotation(@Const @ByRef btQuaternion q);

	/**\brief Set this transformation to the identity */
	public native void setIdentity();

	/**\brief Multiply this Transform by another(this = this * another) 
   * @param t The other transform */
	public native @ByRef @Name("operator *=") btTransform multiplyPut(@Const @ByRef btTransform t);

	/**\brief Return the inverse of this transform */
	public native @ByVal btTransform inverse();

	/**\brief Return the inverse of this transform times the other transform
   * @param t The other transform 
   * return this.inverse() * the other */
	public native @ByVal btTransform inverseTimes(@Const @ByRef btTransform t);

	/**\brief Return the product of this transform and the other */
	public native @ByVal @Name("operator *") btTransform multiply(@Const @ByRef btTransform t);

	/**\brief Return an identity transform */
	public static native @Const @ByRef btTransform getIdentity();

	public native void serialize(@ByRef btTransformFloatData dataOut);

	public native void serializeFloat(@ByRef btTransformFloatData dataOut);

	public native void deSerialize(@Const @ByRef btTransformFloatData dataIn);

	public native void deSerializeDouble(@Const @ByRef btTransformDoubleData dataIn);

	public native void deSerializeFloat(@Const @ByRef btTransformFloatData dataIn);
}







/**\brief Test if two transforms have all elements equal */
public static native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef btTransform t1, @Const @ByRef btTransform t2);

/**for serialization */
public static class btTransformFloatData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btTransformFloatData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btTransformFloatData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btTransformFloatData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btTransformFloatData position(long position) {
        return (btTransformFloatData)super.position(position);
    }
    @Override public btTransformFloatData getPointer(long i) {
        return new btTransformFloatData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btMatrix3x3FloatData m_basis(); public native btTransformFloatData m_basis(btMatrix3x3FloatData setter);
	public native @ByRef btVector3FloatData m_origin(); public native btTransformFloatData m_origin(btVector3FloatData setter);
}

public static class btTransformDoubleData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btTransformDoubleData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btTransformDoubleData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btTransformDoubleData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btTransformDoubleData position(long position) {
        return (btTransformDoubleData)super.position(position);
    }
    @Override public btTransformDoubleData getPointer(long i) {
        return new btTransformDoubleData((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btMatrix3x3DoubleData m_basis(); public native btTransformDoubleData m_basis(btMatrix3x3DoubleData setter);
	public native @ByRef btVector3DoubleData m_origin(); public native btTransformDoubleData m_origin(btVector3DoubleData setter);
}











// #endif  //BT_TRANSFORM_H


// Parsed from LinearMath/btAlignedObjectArray.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_OBJECT_ARRAY__
// #define BT_OBJECT_ARRAY__

// #include "btScalar.h"  // has definitions like SIMD_FORCE_INLINE
// #include "btAlignedAllocator.h"

/**If the platform doesn't support placement new, you can disable BT_USE_PLACEMENT_NEW
 * then the btAlignedObjectArray doesn't support objects with virtual methods, and non-trivial constructors/destructors
 * You can enable BT_USE_MEMCPY, then swapping elements in the array will use memcpy instead of operator=
 * see discussion here: https://bulletphysics.orgphpBB2/viewtopic.php?t=1231 and
 * http://www.continuousphysics.com/Bullet/phpBB2/viewtopic.php?t=1240 */

public static final int BT_USE_PLACEMENT_NEW = 1;
//#define BT_USE_MEMCPY 1 //disable, because it is cumbersome to find out for each platform where memcpy is defined. It can be in <memory.h> or <string.h> or otherwise...
// #define BT_ALLOW_ARRAY_COPY_OPERATOR  // enabling this can accidently perform deep copies of data if you are not careful

// #ifdef BT_USE_MEMCPY
// #include <memory.h>
// #include <string.h>
// #endif  //BT_USE_MEMCPY

// #ifdef BT_USE_PLACEMENT_NEW
// #include <new>  //for placement new
// #endif          //BT_USE_PLACEMENT_NEW

/**The btAlignedObjectArray template class uses a subset of the stl::vector interface for its methods
 * It is developed to replace stl::vector to avoid portability issues, including STL alignment issues to add SIMD/SSE data */
@Name("btAlignedObjectArray<btVector3>") @NoOffset public static class btAlignedObjectArray_btVector3 extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btAlignedObjectArray_btVector3(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btAlignedObjectArray_btVector3(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btAlignedObjectArray_btVector3 position(long position) {
        return (btAlignedObjectArray_btVector3)super.position(position);
    }
    @Override public btAlignedObjectArray_btVector3 getPointer(long i) {
        return new btAlignedObjectArray_btVector3((Pointer)this).offsetAddress(i);
    }

	public native @ByRef @Name("operator =") btAlignedObjectArray_btVector3 put(@Const @ByRef btAlignedObjectArray_btVector3 other);
	public btAlignedObjectArray_btVector3() { super((Pointer)null); allocate(); }
	private native void allocate();

	/**Generally it is best to avoid using the copy constructor of an btAlignedObjectArray, and use a (const) reference to the array instead. */
	public btAlignedObjectArray_btVector3(@Const @ByRef btAlignedObjectArray_btVector3 otherArray) { super((Pointer)null); allocate(otherArray); }
	private native void allocate(@Const @ByRef btAlignedObjectArray_btVector3 otherArray);

	/** return the number of elements in the array */
	public native int size();

	public native @ByRef btVector3 at(int n);

	public native @ByRef @Name("operator []") btVector3 get(int n);

	/**clear the array, deallocated memory. Generally it is better to use array.resize(0), to reduce performance overhead of run-time memory (de)allocations. */
	public native void clear();

	public native void pop_back();

	/**resize changes the number of elements in the array. If the new size is larger, the new elements will be constructed using the optional second argument.
	 * when the new number of elements is smaller, the destructor will be called, but memory will not be freed, to reduce performance overhead of run-time memory (de)allocations. */
	public native void resizeNoInitialize(int newsize);

	public native void resize(int newsize, @Const @ByRef(nullValue = "btVector3()") btVector3 fillData);
	public native void resize(int newsize);
	public native @ByRef btVector3 expandNonInitializing();

	public native @ByRef btVector3 expand(@Const @ByRef(nullValue = "btVector3()") btVector3 fillValue);
	public native @ByRef btVector3 expand();

	public native void push_back(@Const @ByRef btVector3 _Val);

	/** return the pre-allocated (reserved) elements, this is at least as large as the total number of elements,see size() and reserve() */
	public native @Name("capacity") int _capacity();

	public native void reserve(int _Count);

	/**heap sort from http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Sort/Heap/ */ /*downHeap*/

	public native void swap(int index0, int index1);

	/**non-recursive binary search, assumes sorted array */
	public native int findBinarySearch(@Const @ByRef btVector3 key);

	public native int findLinearSearch(@Const @ByRef btVector3 key);

	// If the key is not in the array, return -1 instead of 0,
	// since 0 also means the first element in the array.
	public native int findLinearSearch2(@Const @ByRef btVector3 key);

	public native void removeAtIndex(int index);
	public native void remove(@Const @ByRef btVector3 key);

	//PCK: whole function
	public native void initializeFromBuffer(Pointer buffer, int size, int _capacity);

	public native void copyFromArray(@Const @ByRef btAlignedObjectArray_btVector3 otherArray);
}
@Name("btAlignedObjectArray<btScalar>") @NoOffset public static class btAlignedObjectArray_btScalar extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btAlignedObjectArray_btScalar(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btAlignedObjectArray_btScalar(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btAlignedObjectArray_btScalar position(long position) {
        return (btAlignedObjectArray_btScalar)super.position(position);
    }
    @Override public btAlignedObjectArray_btScalar getPointer(long i) {
        return new btAlignedObjectArray_btScalar((Pointer)this).offsetAddress(i);
    }

	public native @ByRef @Name("operator =") btAlignedObjectArray_btScalar put(@Const @ByRef btAlignedObjectArray_btScalar other);
	public btAlignedObjectArray_btScalar() { super((Pointer)null); allocate(); }
	private native void allocate();

	/**Generally it is best to avoid using the copy constructor of an btAlignedObjectArray, and use a (const) reference to the array instead. */
	public btAlignedObjectArray_btScalar(@Const @ByRef btAlignedObjectArray_btScalar otherArray) { super((Pointer)null); allocate(otherArray); }
	private native void allocate(@Const @ByRef btAlignedObjectArray_btScalar otherArray);

	/** return the number of elements in the array */
	public native int size();

	public native @Cast("btScalar*") @ByRef FloatPointer at(int n);

	public native @Cast("btScalar*") @ByRef @Name("operator []") FloatPointer get(int n);

	/**clear the array, deallocated memory. Generally it is better to use array.resize(0), to reduce performance overhead of run-time memory (de)allocations. */
	public native void clear();

	public native void pop_back();

	/**resize changes the number of elements in the array. If the new size is larger, the new elements will be constructed using the optional second argument.
	 * when the new number of elements is smaller, the destructor will be called, but memory will not be freed, to reduce performance overhead of run-time memory (de)allocations. */
	public native void resizeNoInitialize(int newsize);

	public native void resize(int newsize, @Cast("const btScalar") float fillData/*=btScalar()*/);
	public native void resize(int newsize);
	public native @Cast("btScalar*") @ByRef FloatPointer expandNonInitializing();

	public native @Cast("btScalar*") @ByRef FloatPointer expand(@Cast("const btScalar") float fillValue/*=btScalar()*/);
	public native @Cast("btScalar*") @ByRef FloatPointer expand();

	public native void push_back(@Cast("const btScalar") float _Val);

	/** return the pre-allocated (reserved) elements, this is at least as large as the total number of elements,see size() and reserve() */
	public native @Name("capacity") int _capacity();

	public native void reserve(int _Count);

	/**heap sort from http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Sort/Heap/ */ /*downHeap*/

	public native void swap(int index0, int index1);

	/**non-recursive binary search, assumes sorted array */
	public native int findBinarySearch(@Cast("const btScalar") float key);

	public native int findLinearSearch(@Cast("const btScalar") float key);

	// If the key is not in the array, return -1 instead of 0,
	// since 0 also means the first element in the array.
	public native int findLinearSearch2(@Cast("const btScalar") float key);

	public native void removeAtIndex(int index);
	public native void remove(@Cast("const btScalar") float key);

	//PCK: whole function
	public native void initializeFromBuffer(Pointer buffer, int size, int _capacity);

	public native void copyFromArray(@Const @ByRef btAlignedObjectArray_btScalar otherArray);
}

// #endif  //BT_OBJECT_ARRAY__


// Parsed from LinearMath/btHashMap.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_HASH_MAP_H
// #define BT_HASH_MAP_H

// #include <string>
// #include "btAlignedObjectArray.h"

/**very basic hashable string implementation, compatible with btHashMap */
@NoOffset public static class btHashString extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btHashString(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btHashString(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btHashString position(long position) {
        return (btHashString)super.position(position);
    }
    @Override public btHashString getPointer(long i) {
        return new btHashString((Pointer)this).offsetAddress(i);
    }

	public native @StdString BytePointer m_string1(); public native btHashString m_string1(BytePointer setter);
	public native @Cast("unsigned int") int m_hash(); public native btHashString m_hash(int setter);

	public native @Cast("unsigned int") int getHash();

	public btHashString() { super((Pointer)null); allocate(); }
	private native void allocate();
	public btHashString(@Cast("const char*") BytePointer name) { super((Pointer)null); allocate(name); }
	private native void allocate(@Cast("const char*") BytePointer name);
	public btHashString(String name) { super((Pointer)null); allocate(name); }
	private native void allocate(String name);

	public native @Cast("bool") boolean equals(@Const @ByRef btHashString other);
}

@MemberGetter public static native int BT_HASH_NULL();

@NoOffset public static class btHashInt extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btHashInt(Pointer p) { super(p); }

	public btHashInt() { super((Pointer)null); allocate(); }
	private native void allocate();

	public btHashInt(int uid) { super((Pointer)null); allocate(uid); }
	private native void allocate(int uid);

	public native int getUid1();

	public native void setUid1(int uid);

	public native @Cast("bool") boolean equals(@Const @ByRef btHashInt other);
	//to our success
	public native @Cast("unsigned int") int getHash();
}

public static class btHashPtr extends Pointer {
    static { Loader.load(); }

	public btHashPtr(@Const Pointer ptr) { super((Pointer)null); allocate(ptr); }
	private native void allocate(@Const Pointer ptr);

	public native @Const Pointer getPointer();

	public native @Cast("bool") boolean equals(@Const @ByRef btHashPtr other);

	//to our success
	public native @Cast("unsigned int") int getHash();
}

/**The btHashMap template class implements a generic and lightweight hashmap.
 * A basic sample of how to use btHashMap is located in Demos\BasicDemo\main.cpp */
@Name("btHashMap<btHashPtr,void*>") public static class btHashMap_btHashPtr_voidPointer extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btHashMap_btHashPtr_voidPointer() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btHashMap_btHashPtr_voidPointer(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btHashMap_btHashPtr_voidPointer(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btHashMap_btHashPtr_voidPointer position(long position) {
        return (btHashMap_btHashPtr_voidPointer)super.position(position);
    }
    @Override public btHashMap_btHashPtr_voidPointer getPointer(long i) {
        return new btHashMap_btHashPtr_voidPointer((Pointer)this).offsetAddress(i);
    }

	public native void insert(@Const @ByRef btHashPtr key, @ByPtrRef Pointer value);

	public native void remove(@Const @ByRef btHashPtr key);

	public native int size();

	public native @Cast("void**") PointerPointer getAtIndex(int index);

	public native @ByVal btHashPtr getKeyAtIndex(int index);

	public native @Cast("void**") @Name("operator []") PointerPointer get(@Const @ByRef btHashPtr key);

	public native @Cast("void**") PointerPointer find(@Const @ByRef btHashPtr key);

	public native int findIndex(@Const @ByRef btHashPtr key);

	public native void clear();
}

// #endif  //BT_HASH_MAP_H


// Parsed from LinearMath/btSerializer.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_SERIALIZER_H
// #define BT_SERIALIZER_H

// #include "btScalar.h"  // has definitions like SIMD_FORCE_INLINE
// #include "btHashMap.h"

// #if !defined(__CELLOS_LV2__) && !defined(__MWERKS__)
// #include <memory.h>
// #endif
// #include <string.h>

public static native @Cast("char") byte sBulletDNAstr(int i); public static native void sBulletDNAstr(int i, byte setter);
@MemberGetter public static native @Cast("char*") BytePointer sBulletDNAstr();
public static native int sBulletDNAlen(); public static native void sBulletDNAlen(int setter);
public static native @Cast("char") byte sBulletDNAstr64(int i); public static native void sBulletDNAstr64(int i, byte setter);
@MemberGetter public static native @Cast("char*") BytePointer sBulletDNAstr64();
public static native int sBulletDNAlen64(); public static native void sBulletDNAlen64(int setter);

public static native int btStrLen(@Cast("const char*") BytePointer str);
public static native int btStrLen(String str);

public static class btChunk extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btChunk() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btChunk(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btChunk(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btChunk position(long position) {
        return (btChunk)super.position(position);
    }
    @Override public btChunk getPointer(long i) {
        return new btChunk((Pointer)this).offsetAddress(i);
    }

	public native int m_chunkCode(); public native btChunk m_chunkCode(int setter);
	public native int m_length(); public native btChunk m_length(int setter);
	public native Pointer m_oldPtr(); public native btChunk m_oldPtr(Pointer setter);
	public native int m_dna_nr(); public native btChunk m_dna_nr(int setter);
	public native int m_number(); public native btChunk m_number(int setter);
}

/** enum btSerializationFlags */
public static final int
	BT_SERIALIZE_NO_BVH = 1,
	BT_SERIALIZE_NO_TRIANGLEINFOMAP = 2,
	BT_SERIALIZE_NO_DUPLICATE_ASSERT = 4,
	BT_SERIALIZE_CONTACT_MANIFOLDS = 8;

public static class btSerializer extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btSerializer(Pointer p) { super(p); }


	public native @Cast("const unsigned char*") BytePointer getBufferPointer();

	public native int getCurrentBufferSize();

	public native @Name("allocate") btChunk _allocate(@Cast("size_t") long size, int numElements);

	public native void finalizeChunk(btChunk chunk, @Cast("const char*") BytePointer structType, int chunkCode, Pointer oldPtr);
	public native void finalizeChunk(btChunk chunk, String structType, int chunkCode, Pointer oldPtr);

	public native Pointer findPointer(Pointer oldPtr);

	public native Pointer getUniquePointer(Pointer oldPtr);

	public native void startSerialization();

	public native void finishSerialization();

	public native @Cast("const char*") BytePointer findNameForPointer(@Const Pointer ptr);

	public native void registerNameForPointer(@Const Pointer ptr, @Cast("const char*") BytePointer name);
	public native void registerNameForPointer(@Const Pointer ptr, String name);

	public native void serializeName(@Cast("const char*") BytePointer ptr);
	public native void serializeName(String ptr);

	public native int getSerializationFlags();

	public native void setSerializationFlags(int flags);

	public native int getNumChunks();

	public native @Const btChunk getChunk(int chunkIndex);
}

public static final int BT_HEADER_LENGTH = 12;
// #if defined(__sgi) || defined(__sparc) || defined(__sparc__) || defined(__PPC__) || defined(__ppc__) || defined(__BIG_ENDIAN__)
// #define BT_MAKE_ID(a, b, c, d) ((int)(a) << 24 | (int)(b) << 16 | (c) << 8 | (d))
// #else
// #define BT_MAKE_ID(a, b, c, d) ((int)(d) << 24 | (int)(c) << 16 | (b) << 8 | (a))
// #endif

public static native @MemberGetter int BT_MULTIBODY_CODE();
public static final int BT_MULTIBODY_CODE = BT_MULTIBODY_CODE();
public static native @MemberGetter int BT_MB_LINKCOLLIDER_CODE();
public static final int BT_MB_LINKCOLLIDER_CODE = BT_MB_LINKCOLLIDER_CODE();
public static native @MemberGetter int BT_SOFTBODY_CODE();
public static final int BT_SOFTBODY_CODE = BT_SOFTBODY_CODE();
public static native @MemberGetter int BT_COLLISIONOBJECT_CODE();
public static final int BT_COLLISIONOBJECT_CODE = BT_COLLISIONOBJECT_CODE();
public static native @MemberGetter int BT_RIGIDBODY_CODE();
public static final int BT_RIGIDBODY_CODE = BT_RIGIDBODY_CODE();
public static native @MemberGetter int BT_CONSTRAINT_CODE();
public static final int BT_CONSTRAINT_CODE = BT_CONSTRAINT_CODE();
public static native @MemberGetter int BT_BOXSHAPE_CODE();
public static final int BT_BOXSHAPE_CODE = BT_BOXSHAPE_CODE();
public static native @MemberGetter int BT_QUANTIZED_BVH_CODE();
public static final int BT_QUANTIZED_BVH_CODE = BT_QUANTIZED_BVH_CODE();
public static native @MemberGetter int BT_TRIANLGE_INFO_MAP();
public static final int BT_TRIANLGE_INFO_MAP = BT_TRIANLGE_INFO_MAP();
public static native @MemberGetter int BT_SHAPE_CODE();
public static final int BT_SHAPE_CODE = BT_SHAPE_CODE();
public static native @MemberGetter int BT_ARRAY_CODE();
public static final int BT_ARRAY_CODE = BT_ARRAY_CODE();
public static native @MemberGetter int BT_SBMATERIAL_CODE();
public static final int BT_SBMATERIAL_CODE = BT_SBMATERIAL_CODE();
public static native @MemberGetter int BT_SBNODE_CODE();
public static final int BT_SBNODE_CODE = BT_SBNODE_CODE();
public static native @MemberGetter int BT_DYNAMICSWORLD_CODE();
public static final int BT_DYNAMICSWORLD_CODE = BT_DYNAMICSWORLD_CODE();
public static native @MemberGetter int BT_CONTACTMANIFOLD_CODE();
public static final int BT_CONTACTMANIFOLD_CODE = BT_CONTACTMANIFOLD_CODE();
public static native @MemberGetter int BT_DNA_CODE();
public static final int BT_DNA_CODE = BT_DNA_CODE();

public static class btPointerUid extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public btPointerUid() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btPointerUid(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btPointerUid(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public btPointerUid position(long position) {
        return (btPointerUid)super.position(position);
    }
    @Override public btPointerUid getPointer(long i) {
        return new btPointerUid((Pointer)this).offsetAddress(i);
    }

		public native Pointer m_ptr(); public native btPointerUid m_ptr(Pointer setter);
		public native int m_uniqueIds(int i); public native btPointerUid m_uniqueIds(int i, int setter);
		@MemberGetter public native IntPointer m_uniqueIds();
}

/**The btDefaultSerializer is the main Bullet serialization class.
 * The constructor takes an optional argument for backwards compatibility, it is recommended to leave this empty/zero. */
@NoOffset public static class btDefaultSerializer extends btSerializer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btDefaultSerializer(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btDefaultSerializer(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btDefaultSerializer position(long position) {
        return (btDefaultSerializer)super.position(position);
    }
    @Override public btDefaultSerializer getPointer(long i) {
        return new btDefaultSerializer((Pointer)this).offsetAddress(i);
    }

	@MemberGetter public native @ByRef btHashMap_btHashPtr_voidPointer m_skipPointers();

	public btDefaultSerializer(int totalSize/*=0*/, @Cast("unsigned char*") BytePointer buffer/*=0*/) { super((Pointer)null); allocate(totalSize, buffer); }
	private native void allocate(int totalSize/*=0*/, @Cast("unsigned char*") BytePointer buffer/*=0*/);
	public btDefaultSerializer() { super((Pointer)null); allocate(); }
	private native void allocate();
	public btDefaultSerializer(int totalSize/*=0*/, @Cast("unsigned char*") ByteBuffer buffer/*=0*/) { super((Pointer)null); allocate(totalSize, buffer); }
	private native void allocate(int totalSize/*=0*/, @Cast("unsigned char*") ByteBuffer buffer/*=0*/);
	public btDefaultSerializer(int totalSize/*=0*/, @Cast("unsigned char*") byte[] buffer/*=0*/) { super((Pointer)null); allocate(totalSize, buffer); }
	private native void allocate(int totalSize/*=0*/, @Cast("unsigned char*") byte[] buffer/*=0*/);

	public static native int getMemoryDnaSizeInBytes();
	public static native @Cast("const char*") BytePointer getMemoryDna();

	public native void insertHeader();

	public native void writeHeader(@Cast("unsigned char*") BytePointer buffer);
	public native void writeHeader(@Cast("unsigned char*") ByteBuffer buffer);
	public native void writeHeader(@Cast("unsigned char*") byte[] buffer);

	public native void startSerialization();

	public native void finishSerialization();

	public native Pointer getUniquePointer(Pointer oldPtr);

	public native @Cast("const unsigned char*") BytePointer getBufferPointer();

	public native int getCurrentBufferSize();

	public native void finalizeChunk(btChunk chunk, @Cast("const char*") BytePointer structType, int chunkCode, Pointer oldPtr);
	public native void finalizeChunk(btChunk chunk, String structType, int chunkCode, Pointer oldPtr);

	public native @Cast("unsigned char*") BytePointer internalAlloc(@Cast("size_t") long size);

	public native @Name("allocate") btChunk _allocate(@Cast("size_t") long size, int numElements);

	public native @Cast("const char*") BytePointer findNameForPointer(@Const Pointer ptr);

	public native void registerNameForPointer(@Const Pointer ptr, @Cast("const char*") BytePointer name);
	public native void registerNameForPointer(@Const Pointer ptr, String name);

	public native void serializeName(@Cast("const char*") BytePointer name);
	public native void serializeName(String name);

	public native int getSerializationFlags();

	public native void setSerializationFlags(int flags);
	public native int getNumChunks();

	public native @Const btChunk getChunk(int chunkIndex);
}

/**In general it is best to use btDefaultSerializer,
 * in particular when writing the data to disk or sending it over the network.
 * The btInMemorySerializer is experimental and only suitable in a few cases.
 * The btInMemorySerializer takes a shortcut and can be useful to create a deep-copy
 * of objects. There will be a demo on how to use the btInMemorySerializer. */
// #ifdef ENABLE_INMEMORY_SERIALIZER
// #endif  //ENABLE_INMEMORY_SERIALIZER

// #endif  //BT_SERIALIZER_H


// Parsed from LinearMath/btIDebugDraw.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2009 Erwin Coumans  http://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it freely,
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_IDEBUG_DRAW__H
// #define BT_IDEBUG_DRAW__H

// #include "btVector3.h"
// #include "btTransform.h"

/**The btIDebugDraw interface class allows hooking up a debug renderer to visually debug simulations.
 * Typical use case: create a debug drawer object, and assign it to a btCollisionWorld or btDynamicsWorld using setDebugDrawer and call debugDrawWorld.
 * A class that implements the btIDebugDraw interface will need to provide non-empty implementations of the the drawLine and getDebugMode methods at a minimum.
 * For color arguments the X,Y,Z components refer to Red, Green and Blue each in the range [0..1] */
public static class btIDebugDraw extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btIDebugDraw(Pointer p) { super(p); }

	@NoOffset public static class DefaultColors extends Pointer {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public DefaultColors(Pointer p) { super(p); }
	    /** Native array allocator. Access with {@link Pointer#position(long)}. */
	    public DefaultColors(long size) { super((Pointer)null); allocateArray(size); }
	    private native void allocateArray(long size);
	    @Override public DefaultColors position(long position) {
	        return (DefaultColors)super.position(position);
	    }
	    @Override public DefaultColors getPointer(long i) {
	        return new DefaultColors((Pointer)this).offsetAddress(i);
	    }
	
		public native @ByRef btVector3 m_activeObject(); public native DefaultColors m_activeObject(btVector3 setter);
		public native @ByRef btVector3 m_deactivatedObject(); public native DefaultColors m_deactivatedObject(btVector3 setter);
		public native @ByRef btVector3 m_wantsDeactivationObject(); public native DefaultColors m_wantsDeactivationObject(btVector3 setter);
		public native @ByRef btVector3 m_disabledDeactivationObject(); public native DefaultColors m_disabledDeactivationObject(btVector3 setter);
		public native @ByRef btVector3 m_disabledSimulationObject(); public native DefaultColors m_disabledSimulationObject(btVector3 setter);
		public native @ByRef btVector3 m_aabb(); public native DefaultColors m_aabb(btVector3 setter);
		public native @ByRef btVector3 m_contactPoint(); public native DefaultColors m_contactPoint(btVector3 setter);

		public DefaultColors() { super((Pointer)null); allocate(); }
		private native void allocate();
	}

	/** enum btIDebugDraw::DebugDrawModes */
	public static final int
		DBG_NoDebug = 0,
		DBG_DrawWireframe = 1,
		DBG_DrawAabb = 2,
		DBG_DrawFeaturesText = 4,
		DBG_DrawContactPoints = 8,
		DBG_NoDeactivation = 16,
		DBG_NoHelpText = 32,
		DBG_DrawText = 64,
		DBG_ProfileTimings = 128,
		DBG_EnableSatComparison = 256,
		DBG_DisableBulletLCP = 512,
		DBG_EnableCCD = 1024,
		DBG_DrawConstraints = (1 << 11),
		DBG_DrawConstraintLimits = (1 << 12),
		DBG_FastWireframe = (1 << 13),
		DBG_DrawNormals = (1 << 14),
		DBG_DrawFrames = (1 << 15),
		DBG_MAX_DEBUG_DRAW_MODE = (1 << 15) + 1;

	public native @ByVal DefaultColors getDefaultColors();
	/**the default implementation for setDefaultColors has no effect. A derived class can implement it and store the colors. */
	public native void setDefaultColors(@Const @ByRef DefaultColors arg0);

	public native void drawLine(@Const @ByRef btVector3 from, @Const @ByRef btVector3 to, @Const @ByRef btVector3 color);

	public native void drawLine(@Const @ByRef btVector3 from, @Const @ByRef btVector3 to, @Const @ByRef btVector3 fromColor, @Const @ByRef btVector3 toColor);

	public native void drawSphere(@Cast("btScalar") float radius, @Const @ByRef btTransform transform, @Const @ByRef btVector3 color);

	public native void drawSphere(@Const @ByRef btVector3 p, @Cast("btScalar") float radius, @Const @ByRef btVector3 color);

	public native void drawTriangle(@Const @ByRef btVector3 v0, @Const @ByRef btVector3 v1, @Const @ByRef btVector3 v2, @Const @ByRef btVector3 arg3, @Const @ByRef btVector3 arg4, @Const @ByRef btVector3 arg5, @Const @ByRef btVector3 color, @Cast("btScalar") float alpha);
	public native void drawTriangle(@Const @ByRef btVector3 v0, @Const @ByRef btVector3 v1, @Const @ByRef btVector3 v2, @Const @ByRef btVector3 color, @Cast("btScalar") float arg4);

	public native void drawContactPoint(@Const @ByRef btVector3 PointOnB, @Const @ByRef btVector3 normalOnB, @Cast("btScalar") float distance, int lifeTime, @Const @ByRef btVector3 color);

	public native void reportErrorWarning(@Cast("const char*") BytePointer warningString);
	public native void reportErrorWarning(String warningString);

	public native void draw3dText(@Const @ByRef btVector3 location, @Cast("const char*") BytePointer textString);
	public native void draw3dText(@Const @ByRef btVector3 location, String textString);

	public native void setDebugMode(int debugMode);

	public native int getDebugMode();

	public native void drawAabb(@Const @ByRef btVector3 from, @Const @ByRef btVector3 to, @Const @ByRef btVector3 color);
	public native void drawTransform(@Const @ByRef btTransform transform, @Cast("btScalar") float orthoLen);

	public native void drawArc(@Const @ByRef btVector3 center, @Const @ByRef btVector3 normal, @Const @ByRef btVector3 axis, @Cast("btScalar") float radiusA, @Cast("btScalar") float radiusB, @Cast("btScalar") float minAngle, @Cast("btScalar") float maxAngle,
							 @Const @ByRef btVector3 color, @Cast("bool") boolean drawSect, @Cast("btScalar") float stepDegrees/*=btScalar(10.f)*/);
	public native void drawArc(@Const @ByRef btVector3 center, @Const @ByRef btVector3 normal, @Const @ByRef btVector3 axis, @Cast("btScalar") float radiusA, @Cast("btScalar") float radiusB, @Cast("btScalar") float minAngle, @Cast("btScalar") float maxAngle,
							 @Const @ByRef btVector3 color, @Cast("bool") boolean drawSect);
	public native void drawSpherePatch(@Const @ByRef btVector3 center, @Const @ByRef btVector3 up, @Const @ByRef btVector3 axis, @Cast("btScalar") float radius,
									 @Cast("btScalar") float minTh, @Cast("btScalar") float maxTh, @Cast("btScalar") float minPs, @Cast("btScalar") float maxPs, @Const @ByRef btVector3 color, @Cast("btScalar") float stepDegrees/*=btScalar(10.f)*/, @Cast("bool") boolean drawCenter/*=true*/);
	public native void drawSpherePatch(@Const @ByRef btVector3 center, @Const @ByRef btVector3 up, @Const @ByRef btVector3 axis, @Cast("btScalar") float radius,
									 @Cast("btScalar") float minTh, @Cast("btScalar") float maxTh, @Cast("btScalar") float minPs, @Cast("btScalar") float maxPs, @Const @ByRef btVector3 color);

	public native void drawBox(@Const @ByRef btVector3 bbMin, @Const @ByRef btVector3 bbMax, @Const @ByRef btVector3 color);
	public native void drawBox(@Const @ByRef btVector3 bbMin, @Const @ByRef btVector3 bbMax, @Const @ByRef btTransform trans, @Const @ByRef btVector3 color);

	public native void drawCapsule(@Cast("btScalar") float radius, @Cast("btScalar") float halfHeight, int upAxis, @Const @ByRef btTransform transform, @Const @ByRef btVector3 color);

	public native void drawCylinder(@Cast("btScalar") float radius, @Cast("btScalar") float halfHeight, int upAxis, @Const @ByRef btTransform transform, @Const @ByRef btVector3 color);

	public native void drawCone(@Cast("btScalar") float radius, @Cast("btScalar") float height, int upAxis, @Const @ByRef btTransform transform, @Const @ByRef btVector3 color);

	public native void drawPlane(@Const @ByRef btVector3 planeNormal, @Cast("btScalar") float planeConst, @Const @ByRef btTransform transform, @Const @ByRef btVector3 color);

	public native void clearLines();

	public native void flushLines();
}

// #endif  //BT_IDEBUG_DRAW__H


// Parsed from LinearMath/btQuickprof.h


/***************************************************************************************************
**
** Real-Time Hierarchical Profiling for Game Programming Gems 3
**
** by Greg Hjelstrom & Byon Garrabrant
**
***************************************************************************************************/

// Credits: The Clock class was inspired by the Timer classes in
// Ogre (www.ogre3d.org).

// #ifndef BT_QUICK_PROF_H
// #define BT_QUICK_PROF_H

// #include "btScalar.h"
public static final int USE_BT_CLOCK = 1;

// #ifdef USE_BT_CLOCK

/**The btClock is a portable basic clock that measures accurate time in seconds, use for profiling. */
@NoOffset public static class btClock extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btClock(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btClock(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btClock position(long position) {
        return (btClock)super.position(position);
    }
    @Override public btClock getPointer(long i) {
        return new btClock((Pointer)this).offsetAddress(i);
    }

	public btClock() { super((Pointer)null); allocate(); }
	private native void allocate();

	public btClock(@Const @ByRef btClock other) { super((Pointer)null); allocate(other); }
	private native void allocate(@Const @ByRef btClock other);
	public native @ByRef @Name("operator =") btClock put(@Const @ByRef btClock other);

	/** Resets the initial reference time. */
	public native void reset();

	/** Returns the time in ms since the last call to reset or since
	 *  the btClock was created. */
	public native @Cast("unsigned long long int") long getTimeMilliseconds();

	/** Returns the time in us since the last call to reset or since
	 *  the Clock was created. */
	public native @Cast("unsigned long long int") long getTimeMicroseconds();

	public native @Cast("unsigned long long int") long getTimeNanoseconds();

	/** Returns the time in s since the last call to reset or since
	 *  the Clock was created. */
	public native @Cast("btScalar") float getTimeSeconds();
}

// #endif  //USE_BT_CLOCK

public static class btEnterProfileZoneFunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    btEnterProfileZoneFunc(Pointer p) { super(p); }
    protected btEnterProfileZoneFunc() { allocate(); }
    private native void allocate();
    public native void call(@Cast("const char*") BytePointer msg);
}
public static class btLeaveProfileZoneFunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    btLeaveProfileZoneFunc(Pointer p) { super(p); }
    protected btLeaveProfileZoneFunc() { allocate(); }
    private native void allocate();
    public native void call();
}

public static native btEnterProfileZoneFunc btGetCurrentEnterProfileZoneFunc();
public static native btLeaveProfileZoneFunc btGetCurrentLeaveProfileZoneFunc();

public static native void btSetCustomEnterProfileZoneFunc(btEnterProfileZoneFunc enterFunc);
public static native void btSetCustomLeaveProfileZoneFunc(btLeaveProfileZoneFunc leaveFunc);

// #ifndef BT_ENABLE_PROFILE
public static final int BT_NO_PROFILE = 1;
// #endif  //BT_NO_PROFILE

@MemberGetter public static native @Cast("const unsigned int") int BT_QUICKPROF_MAX_THREAD_COUNT();

//btQuickprofGetCurrentThreadIndex will return -1 if thread index cannot be determined,
//otherwise returns thread index in range [0..maxThreads]
public static native @Cast("unsigned int") int btQuickprofGetCurrentThreadIndex2();

// #ifndef BT_NO_PROFILE

// #endif  //#ifndef BT_NO_PROFILE

/**ProfileSampleClass is a simple way to profile a function's scope
 * Use the BT_PROFILE macro at the start of scope to time */
public static class CProfileSample extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CProfileSample(Pointer p) { super(p); }

	public CProfileSample(@Cast("const char*") BytePointer name) { super((Pointer)null); allocate(name); }
	private native void allocate(@Cast("const char*") BytePointer name);
	public CProfileSample(String name) { super((Pointer)null); allocate(name); }
	private native void allocate(String name);
}

// #define BT_PROFILE(name) CProfileSample __profile(name)

// #endif  //BT_QUICK_PROF_H


// Parsed from LinearMath/btMotionState.h

/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  https://bulletphysics.org

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef BT_MOTIONSTATE_H
// #define BT_MOTIONSTATE_H

// #include "btTransform.h"

/**The btMotionState interface class allows the dynamics world to synchronize and interpolate the updated world transforms with graphics
 * For optimizations, potentially only moving objects get synchronized (using setWorldPosition/setWorldOrientation) */
public static class btMotionState extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btMotionState(Pointer p) { super(p); }


	public native void getWorldTransform(@ByRef btTransform worldTrans);

	//Bullet only calls the update of worldtransform for active objects
	public native void setWorldTransform(@Const @ByRef btTransform worldTrans);
}

// #endif  //BT_MOTIONSTATE_H


// Parsed from LinearMath/btDefaultMotionState.h

// #ifndef BT_DEFAULT_MOTION_STATE_H
// #define BT_DEFAULT_MOTION_STATE_H

// #include "btMotionState.h"

/**The btDefaultMotionState provides a common implementation to synchronize world transforms with offsets. */
@NoOffset public static class btDefaultMotionState extends btMotionState {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public btDefaultMotionState(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public btDefaultMotionState(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public btDefaultMotionState position(long position) {
        return (btDefaultMotionState)super.position(position);
    }
    @Override public btDefaultMotionState getPointer(long i) {
        return new btDefaultMotionState((Pointer)this).offsetAddress(i);
    }

	public native @ByRef btTransform m_graphicsWorldTrans(); public native btDefaultMotionState m_graphicsWorldTrans(btTransform setter);
	public native @ByRef btTransform m_centerOfMassOffset(); public native btDefaultMotionState m_centerOfMassOffset(btTransform setter);
	public native @ByRef btTransform m_startWorldTrans(); public native btDefaultMotionState m_startWorldTrans(btTransform setter);
	public native Pointer m_userPointer(); public native btDefaultMotionState m_userPointer(Pointer setter);

	public btDefaultMotionState(@Const @ByRef(nullValue = "btTransform::getIdentity()") btTransform startTrans, @Const @ByRef(nullValue = "btTransform::getIdentity()") btTransform centerOfMassOffset) { super((Pointer)null); allocate(startTrans, centerOfMassOffset); }
	private native void allocate(@Const @ByRef(nullValue = "btTransform::getIdentity()") btTransform startTrans, @Const @ByRef(nullValue = "btTransform::getIdentity()") btTransform centerOfMassOffset);
	public btDefaultMotionState() { super((Pointer)null); allocate(); }
	private native void allocate();

	/**synchronizes world transform from user to physics */
	public native void getWorldTransform(@ByRef btTransform centerOfMassWorldTrans);

	/**synchronizes world transform from physics to user
	 * Bullet only calls the update of worldtransform for active objects */
	public native void setWorldTransform(@Const @ByRef btTransform centerOfMassWorldTrans);
}

// #endif  //BT_DEFAULT_MOTION_STATE_H


}
