// Targeted by JavaCPP version 1.5.3-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.cudf;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.cudf.global.cudf.*;
  // namespace detail

/**---------------------------------------------------------------------------*
 * \brief A non-owning, immutable view of device data as a column of elements,
 * some of which may be null as indicated by a bitmask.
 *
 * A {@code column_view} can be constructed implicitly from a {@code cudf::column}, or may
 * be constructed explicitly from a pointer to pre-existing device memory.
 *
 * Unless otherwise noted, the memory layout of the {@code column_view}'s data and
 * bitmask is expected to adhere to the Arrow Physical Memory Layout
 * Specification: https://arrow.apache.org/docs/memory_layout.html
 *
 * Because {@code column_view} is non-owning, no device memory is allocated nor free'd
 * when {@code column_view} objects are created or destroyed.
 *
 * To enable zero-copy slicing, a {@code column_view} has an {@code offset} that indicates
 * the index of the first element in the column relative to the base device
 * memory allocation. By default, {@code offset()} is zero.
 *
 *---------------------------------------------------------------------------**/
@Namespace("cudf") @NoOffset @Properties(inherit = org.bytedeco.cudf.presets.cudf.class)
public class column_view extends column_view_base {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public column_view(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public column_view(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public column_view position(long position) {
        return (column_view)super.position(position);
    }

  public column_view() { super((Pointer)null); allocate(); }
  private native void allocate();
  public column_view(@Const @ByRef column_view arg0) { super((Pointer)null); allocate(arg0); }
  private native void allocate(@Const @ByRef column_view arg0);
  public native @ByRef @Name("operator =") column_view put(@Const @ByRef column_view arg0);

  /**---------------------------------------------------------------------------*
   * \brief Construct a {@code column_view} from pointers to device memory for the
   * elements and bitmask of the column.
   *
   * If {@code null_count()} is zero, {@code null_mask} is optional.
   *
   * If the null count of the {@code null_mask} is not specified, it defaults to
   * {@code UNKNOWN_NULL_COUNT}. The first invocation of {@code null_count()} will then
   * compute the null count if {@code null_mask} exists.
   *
   * If {@code type} is {@code EMPTY}, the specified {@code null_count} will be ignored and
   * {@code null_count()} will always return the same value as {@code size()}
   *
   * @throws {@code cudf::logic_error} if {@code size < 0}
   * @throws {@code cudf::logic_error} if {@code size > 0} but {@code data == nullptr}
   * @throws {@code cudf::logic_error} if {@code type.id() == EMPTY} but {@code data != nullptr}
   *or {@code null_mask != nullptr}
   * @throws {@code cudf::logic_error} if {@code null_count > 0}, but {@code null_mask == nullptr}
   * @throws {@code cudf::logic_error} if {@code offset < 0}
   *
   * @param type The element type
   * @param size The number of elements
   * @param data Pointer to device memory containing the column elements
   * @param null_mask Optional, pointer to device memory containing the null
   * indicator bitmask
   * @param null_count Optional, the number of null elements.
   * @param offset optional, index of the first element
   * @param children optional, depending on the element type, child columns may
   * contain additional data
   *---------------------------------------------------------------------------**/
  public column_view(@ByVal data_type type, @Cast("cudf::size_type") int size, @Const Pointer data,
                @Cast("const cudf::bitmask_type*") IntPointer null_mask/*=nullptr*/,
                @Cast("cudf::size_type") int null_count/*=cudf::UNKNOWN_NULL_COUNT*/, @Cast("cudf::size_type") int offset/*=0*/,
                @StdVector column_view children/*={}*/) { super((Pointer)null); allocate(type, size, data, null_mask, null_count, offset, children); }
  private native void allocate(@ByVal data_type type, @Cast("cudf::size_type") int size, @Const Pointer data,
                @Cast("const cudf::bitmask_type*") IntPointer null_mask/*=nullptr*/,
                @Cast("cudf::size_type") int null_count/*=cudf::UNKNOWN_NULL_COUNT*/, @Cast("cudf::size_type") int offset/*=0*/,
                @StdVector column_view children/*={}*/);
  public column_view(@ByVal data_type type, @Cast("cudf::size_type") int size, @Const Pointer data) { super((Pointer)null); allocate(type, size, data); }
  private native void allocate(@ByVal data_type type, @Cast("cudf::size_type") int size, @Const Pointer data);
  public column_view(@ByVal data_type type, @Cast("cudf::size_type") int size, @Const Pointer data,
                @Cast("const cudf::bitmask_type*") IntBuffer null_mask/*=nullptr*/,
                @Cast("cudf::size_type") int null_count/*=cudf::UNKNOWN_NULL_COUNT*/, @Cast("cudf::size_type") int offset/*=0*/,
                @StdVector column_view children/*={}*/) { super((Pointer)null); allocate(type, size, data, null_mask, null_count, offset, children); }
  private native void allocate(@ByVal data_type type, @Cast("cudf::size_type") int size, @Const Pointer data,
                @Cast("const cudf::bitmask_type*") IntBuffer null_mask/*=nullptr*/,
                @Cast("cudf::size_type") int null_count/*=cudf::UNKNOWN_NULL_COUNT*/, @Cast("cudf::size_type") int offset/*=0*/,
                @StdVector column_view children/*={}*/);
  public column_view(@ByVal data_type type, @Cast("cudf::size_type") int size, @Const Pointer data,
                @Cast("const cudf::bitmask_type*") int[] null_mask/*=nullptr*/,
                @Cast("cudf::size_type") int null_count/*=cudf::UNKNOWN_NULL_COUNT*/, @Cast("cudf::size_type") int offset/*=0*/,
                @StdVector column_view children/*={}*/) { super((Pointer)null); allocate(type, size, data, null_mask, null_count, offset, children); }
  private native void allocate(@ByVal data_type type, @Cast("cudf::size_type") int size, @Const Pointer data,
                @Cast("const cudf::bitmask_type*") int[] null_mask/*=nullptr*/,
                @Cast("cudf::size_type") int null_count/*=cudf::UNKNOWN_NULL_COUNT*/, @Cast("cudf::size_type") int offset/*=0*/,
                @StdVector column_view children/*={}*/);

  /**---------------------------------------------------------------------------*
   * \brief Returns the specified child
   *
   * @param child_index The index of the desired child
   * @return column_view The requested child {@code column_view}
   *---------------------------------------------------------------------------**/
  public native @ByVal @NoException column_view child(@Cast("cudf::size_type") int child_index);

  /**---------------------------------------------------------------------------*
   * \brief Returns the number of child columns.
   *---------------------------------------------------------------------------**/
  public native @Cast("cudf::size_type") @NoException int num_children();
}
