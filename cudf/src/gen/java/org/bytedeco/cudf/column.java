// Targeted by JavaCPP version 1.5.3-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.cudf;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.cudf.global.cudf.*;


@Namespace("cudf") @NoOffset @Properties(inherit = org.bytedeco.cudf.presets.cudf.class)
public class column extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public column(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public column(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public column position(long position) {
        return (column)super.position(position);
    }

  public column() { super((Pointer)null); allocate(); }
  private native void allocate();
  
  

  /**---------------------------------------------------------------------------*
   * \brief Construct a new column by deep copying the contents of {@code other}.
   *
   * All device memory allocation and copying is done using the
   * {@code device_memory_resource} and {@code stream} from {@code other}.
   *
   * @param other The column to copy
   *---------------------------------------------------------------------------**/
  public column(@Const @ByRef column other) { super((Pointer)null); allocate(other); }
  private native void allocate(@Const @ByRef column other);

  /**---------------------------------------------------------------------------*
   * \brief Construct a new column object by deep copying the contents of
   *{@code other}.
   *
   * Uses the specified {@code stream} and device_memory_resource for all allocations
   * and copies.
   *
   * @param other The {@code column} to copy
   * @param stream The stream on which to execute all allocations and copies
   * @param mr The resource to use for all allocations
   *---------------------------------------------------------------------------**/
  public column(@Const @ByRef column other, @Cast("cudaStream_t") org.bytedeco.cuda.cudart.CUstream_st stream,
           device_memory_resource mr/*=rmm::mr::get_default_resource()*/) { super((Pointer)null); allocate(other, stream, mr); }
  private native void allocate(@Const @ByRef column other, @Cast("cudaStream_t") org.bytedeco.cuda.cudart.CUstream_st stream,
           device_memory_resource mr/*=rmm::mr::get_default_resource()*/);
  public column(@Const @ByRef column other, @Cast("cudaStream_t") org.bytedeco.cuda.cudart.CUstream_st stream) { super((Pointer)null); allocate(other, stream); }
  private native void allocate(@Const @ByRef column other, @Cast("cudaStream_t") org.bytedeco.cuda.cudart.CUstream_st stream);

  /**---------------------------------------------------------------------------*
   * \brief Move the contents from {@code other} to create a new column.
   *
   * After the move, {@code other.size() == 0} and {@code other.type() = {EMPTY}}
   *
   * @param other The column whose contents will be moved into the new column
   *---------------------------------------------------------------------------**/

  /**---------------------------------------------------------------------------*
   * \brief Construct a new column from existing device memory.
   *
   * \note This constructor is primarily intended for use in column factory
   * functions.
   *
   * @param dtype [in] The element type
   * @param size [in] The number of elements in the column
   * @param data [in] The column's data
   * @param null_mask [in] Optional, column's null value indicator bitmask. May
   * be empty if {@code null_count} is 0 or {@code UNKNOWN_NULL_COUNT}.
   * @param null_count Optional, the count of null elements. If unknown, specify
   * {@code UNKNOWN_NULL_COUNT} to indicate that the null count should be computed on
   * the first invocation of {@code null_count()}.
   * @param children Optional, vector of child columns
   *---------------------------------------------------------------------------**/

  /**---------------------------------------------------------------------------*
   * \brief Construct a new column by deep copying the contents of a
   * {@code column_view}.
   *
   * This accounts for the {@code column_view}'s offset.
   *
   * @param view The view to copy
   * @param stream The stream on which all allocations and copies will be
   * executed
   * @param mr The resource to use for all allocations
   *---------------------------------------------------------------------------**/
  public column(
        @ByVal column_view view, @Cast("cudaStream_t") org.bytedeco.cuda.cudart.CUstream_st stream/*=0*/,
        device_memory_resource mr/*=rmm::mr::get_default_resource()*/) { super((Pointer)null); allocate(view, stream, mr); }
  private native void allocate(
        @ByVal column_view view, @Cast("cudaStream_t") org.bytedeco.cuda.cudart.CUstream_st stream/*=0*/,
        device_memory_resource mr/*=rmm::mr::get_default_resource()*/);
  public column(
        @ByVal column_view view) { super((Pointer)null); allocate(view); }
  private native void allocate(
        @ByVal column_view view);

  /**---------------------------------------------------------------------------*
   * \brief Returns the column's logical element type
   *---------------------------------------------------------------------------**/
  public native @ByVal @NoException data_type type();

  /**---------------------------------------------------------------------------*
   * \brief Returns the number of elements
   *---------------------------------------------------------------------------**/
  public native @Cast("cudf::size_type") @NoException int size();

  /**---------------------------------------------------------------------------*
   * \brief Returns the count of null elements.
   *
   * \note If the column was constructed with {@code UNKNOWN_NULL_COUNT}, or if at any
   * point {@code set_null_count(UNKNOWN_NULL_COUNT)} was invoked, then the
   * first invocation of {@code null_count()} will compute and store the count of null
   * elements indicated by the {@code null_mask} (if it exists).
   *---------------------------------------------------------------------------**/
  public native @Cast("cudf::size_type") int null_count();

  /**---------------------------------------------------------------------------*
   * \brief Sets the column's null value indicator bitmask to {@code new_null_mask}.
   *
   * @throws cudf::logic_error if new_null_count is larger than 0 and the size
   * of {@code new_null_mask} does not match the size of this column.
   *
   * @param new_null_mask New null value indicator bitmask (rvalue overload &
   * moved) to set the column's null value indicator mask. May be empty if
   * {@code new_null_count} is 0 or {@code UNKOWN_NULL_COUNT}.
   * @param new_null_count Optional, the count of null elements. If unknown,
   * specify {@code UNKNOWN_NULL_COUNT} to indicate that the null count should be
   * computed on the first invocation of {@code null_count()}.
   *---------------------------------------------------------------------------**/
  public native void set_null_mask(@ByVal device_buffer new_null_mask,
                       @Cast("cudf::size_type") int new_null_count/*=cudf::UNKNOWN_NULL_COUNT*/);
  public native void set_null_mask(@ByVal device_buffer new_null_mask);

  /**---------------------------------------------------------------------------*
   * \brief Sets the column's null value indicator bitmask to {@code new_null_mask}.
   *
   * @throws cudf::logic_error if new_null_count is larger than 0 and the size
   * of {@code new_null_mask} does not match the size of this column.
   *
   * @param new_null_mask New null value indicator bitmask (lvalue overload &
   * copied) to set the column's null value indicator mask. May be empty if
   * {@code new_null_count} is 0 or {@code UNKOWN_NULL_COUNT}.
   * @param new_null_count Optional, the count of null elements. If unknown,
   * specify {@code UNKNOWN_NULL_COUNT} to indicate that the null count should be
   * computed on the first invocation of {@code null_count()}.
   *---------------------------------------------------------------------------**/

  /**---------------------------------------------------------------------------*
   * \brief Updates the count of null elements.
   *
   * \note {@code UNKNOWN_NULL_COUNT} can be specified as {@code new_null_count} to force
   * the next invocation of {@code null_count()} to recompute the null count from the
   * null mask.
   *
   * @throws cudf::logic_error if {@code new_null_count > 0 and nullable() == false}
   *
   * @param new_null_count The new null count.
   *---------------------------------------------------------------------------**/
  public native void set_null_count(@Cast("cudf::size_type") int new_null_count);

  /**---------------------------------------------------------------------------*
   * \brief Indicates whether it is possible for the column to contain null
   * values, i.e., it has an allocated null mask.
   *
   * This may return {@code false} iff {@code null_count() == 0}.
   *
   * May return true even if {@code null_count() == 0}. This function simply indicates
   * whether the column has an allocated null mask.
   *
   * @return true The column can hold null values
   * @return false The column cannot hold null values
   *---------------------------------------------------------------------------**/
  public native @Cast("bool") @NoException boolean nullable();

  /**---------------------------------------------------------------------------*
   * \brief Indicates whether the column contains null elements.
   *
   * @return true One or more elements are null
   * @return false Zero elements are null
   *---------------------------------------------------------------------------**/
  public native @Cast("bool") @NoException boolean has_nulls();

  /**---------------------------------------------------------------------------*
   * \brief Returns the number of child columns
   *---------------------------------------------------------------------------**/
  public native @Cast("cudf::size_type") @NoException int num_children();

  /**---------------------------------------------------------------------------*
   * \brief Returns a reference to the specified child
   *
   * @param child_index Index of the desired child
   * @return column& Reference to the desired child
   *---------------------------------------------------------------------------**/
  public native @ByRef @NoException column child(@Cast("cudf::size_type") int child_index);

  /**---------------------------------------------------------------------------*
   * \brief Returns a const reference to the specified child
   *
   * @param child_index Index of the desired child
   * @return column const& Const reference to the desired child
   *---------------------------------------------------------------------------**/

  /**---------------------------------------------------------------------------*
   * \brief Wrapper for the contents of a column.
   *
   * Returned by {@code column::release()}.
   *---------------------------------------------------------------------------**/
  public static class contents extends Pointer {
      static { Loader.load(); }
      /** Default native constructor. */
      public contents() { super((Pointer)null); allocate(); }
      /** Native array allocator. Access with {@link Pointer#position(long)}. */
      public contents(long size) { super((Pointer)null); allocateArray(size); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public contents(Pointer p) { super(p); }
      private native void allocate();
      private native void allocateArray(long size);
      @Override public contents position(long position) {
          return (contents)super.position(position);
      }
  
    public native @UniquePtr device_buffer data(); public native contents data(device_buffer setter);
    public native @UniquePtr device_buffer null_mask(); public native contents null_mask(device_buffer setter);
  }

  /**---------------------------------------------------------------------------*
   * \brief Releases ownership of the column's contents.
   *
   * It is the caller's responsibility to query the {@code size(), null_count(),
   * type()} before invoking {@code release()}.
   *
   * After calling {@code release()} on a column it will be empty, i.e.:
   * - {@code type() == data_type{EMPTY}}
   * - {@code size() == 0}
   * - {@code null_count() == 0}
   * - {@code num_children() == 0}
   *
   * @return A {@code contents} struct containing the data, null mask, and children of
   * the column.
   *---------------------------------------------------------------------------**/
  public native @ByVal @NoException contents release();

  /**---------------------------------------------------------------------------*
   * \brief Creates an immutable, non-owning view of the column's data and
   * children.
   *
   * @return column_view The immutable, non-owning view
   *---------------------------------------------------------------------------**/
  public native @ByVal column_view view();

  /**---------------------------------------------------------------------------*
   * \brief Implicit conversion operator to a {@code column_view}.
   *
   * This allows passing a {@code column} object directly into a function that
   * requires a {@code column_view}. The conversion is automatic.
   *
   * @return column_view Immutable, non-owning {@code column_view}
   *---------------------------------------------------------------------------**/
  public native @ByVal @Name("operator cudf::column_view") column_view asColumn_view();

  /**---------------------------------------------------------------------------*
   * \brief Creates a mutable, non-owning view of the column's data and
   * children.
   *
   * \note Creating a mutable view of a {@code column} invalidates the {@code column}'s
   * {@code null_count()} by setting it to {@code UNKNOWN_NULL_COUNT}. The user can
   * either explicitly update the null count with {@code set_null_count()}, or
   * if not, the null count will be recomputed on the next invocation of
   *{@code null_count()}.
   *
   * @return mutable_column_view The mutable, non-owning view
   *---------------------------------------------------------------------------**/
  public native @ByVal mutable_column_view mutable_view();

  /**---------------------------------------------------------------------------*
   * \brief Implicit conversion operator to a {@code mutable_column_view}.
   *
   * This allows pasing a {@code column} object into a function that accepts a
   *{@code mutable_column_view}. The conversion is automatic.
   <p>
   * \note Creating a mutable view of a {@code column} invalidates the {@code column}'s
   * {@code null_count()} by setting it to {@code UNKNOWN_NULL_COUNT}. For best performance,
   * the user should explicitly update the null count with {@code set_null_count()}.
   * Otherwise, the null count will be recomputed on the next invocation of
   * {@code null_count()}.
   *
   * @return mutable_column_view Mutable, non-owning {@code mutable_column_view}
   *---------------------------------------------------------------------------**/
  public native @ByVal @Name("operator cudf::mutable_column_view") mutable_column_view asMutable_column_view();
}
