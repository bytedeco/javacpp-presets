// Targeted by JavaCPP version 1.5.3-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.cudf.global;

import org.bytedeco.cudf.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class cudf extends org.bytedeco.cudf.presets.cudf {
    static { Loader.load(); }

// Parsed from <cudf/unary.hpp>

/*
 * Copyright (c) 2018-2020, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #pragma once 

// #include <memory>
// #include <cudf/types.hpp>

@Namespace("cudf::experimental") public enum unary_op {
  SIN(0),          // < Trigonometric sine
  COS(1),          // < Trigonometric cosine
  TAN(2),          // < Trigonometric tangent
  ARCSIN(3),       // < Trigonometric sine inverse
  ARCCOS(4),       // < Trigonometric cosine inverse
  ARCTAN(5),       // < Trigonometric tangent inverse
  SINH(6),         // < Hyperbolic sine
  COSH(7),         // < Hyperbolic cosine
  TANH(8),         // < Hyperbolic tangent
  ARCSINH(9),      // < Hyperbolic sine inverse
  ARCCOSH(10),      // < Hperbolic cosine inverse
  ARCTANH(11),      // < Hyperbolic tangent inverse
  EXP(12),          // < Exponential (base e, Euler number)
  LOG(13),          // < Natural Logarithm (base e)
  SQRT(14),         // < Square-root (x^0.5)
  CBRT(15),         // < Cube-root (x^(1.0/3))
  CEIL(16),         // < Smallest integer value not less than arg
  FLOOR(17),        // < largest integer value not greater than arg
  ABS(18),          // < Absolute value
  RINT(19),         // < Rounds the floating-point argument arg to an integer value
  BIT_INVERT(20),   // < Bitwise Not (~)
  NOT(21);         // < Logical Not (!)

    public final int value;
    private unary_op(int v) { this.value = v; }
    private unary_op(unary_op e) { this.value = e.value; }
    public unary_op intern() { for (unary_op e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/**
 * \brief Performs unary op on all values in column
 *
 * @param input A {@code column_view} as input
 * @param op operation to perform
 * @param mr Optional, The resource to use for all allocations
 *
 * @return std::unique_ptr<cudf::column> Result of the operation
 */
@Namespace("cudf::experimental") public static native @MoveUniquePtr column unary_operation(@Const @ByRef column_view input,
                                              unary_op op,
                                              device_memory_resource mr/*=rmm::mr::get_default_resource()*/);
@Namespace("cudf::experimental") public static native @MoveUniquePtr column unary_operation(@Const @ByRef column_view input,
                                              unary_op op);
@Namespace("cudf::experimental") public static native @MoveUniquePtr column unary_operation(@Const @ByRef column_view input,
                                              @Cast("cudf::experimental::unary_op") int op,
                                              device_memory_resource mr/*=rmm::mr::get_default_resource()*/);
@Namespace("cudf::experimental") public static native @MoveUniquePtr column unary_operation(@Const @ByRef column_view input,
                                              @Cast("cudf::experimental::unary_op") int op);

/**
 * \brief Creates a column of {@code BOOL8} elements where for every element in {@code input} {@code true}
 * indicates the value is null and {@code false} indicates the value is valid.
 *
 * @param input A {@code column_view} as input
 * @param mr Optional, The resource to use for all allocations
 *
 * @return std::unique_ptr<cudf::column> A non-nulalble column of {@code BOOL8} elements with {@code true} representing {@code null} values.
 */
@Namespace("cudf::experimental") public static native @MoveUniquePtr column is_null(@Const @ByRef column_view input,
                                      device_memory_resource mr/*=rmm::mr::get_default_resource()*/);
@Namespace("cudf::experimental") public static native @MoveUniquePtr column is_null(@Const @ByRef column_view input);

/**
 * \brief Creates a column of {@code BOOL8} elements where for every element in {@code input} {@code true}
 * indicates the value is valid and {@code false} indicates the value is null.
 *
 * @param input A {@code column_view} as input
 * @param mr Optional, The resource to use for all allocations
 *
 * @return std::unique_ptr<cudf::column> A non-nulalble column of {@code BOOL8} elements with {@code false} representing {@code null} values.
 */
@Namespace("cudf::experimental") public static native @MoveUniquePtr column is_valid(@Const @ByRef column_view input,
                                       device_memory_resource mr/*=rmm::mr::get_default_resource()*/);
@Namespace("cudf::experimental") public static native @MoveUniquePtr column is_valid(@Const @ByRef column_view input);

/**
 * \brief  Casts data from dtype specified in input to dtype specified in output.
 * Supports only fixed-width types.
 *
 * @param column_view Input column
 * @param out_type Desired datatype of output column
 * @param mr Optional, The resource to use for all allocations
 *
 * @return unique_ptr<column> Result of the cast operation
 * @throws cudf::logic_error if {@code out_type} is not a fixed-width type
 */
@Namespace("cudf::experimental") public static native @UniquePtr column cast(@Const @ByRef column_view input, @ByVal data_type out_type,
                             device_memory_resource mr/*=rmm::mr::get_default_resource()*/);
@Namespace("cudf::experimental") public static native @UniquePtr column cast(@Const @ByRef column_view input, @ByVal data_type out_type);

/**
 * \brief Creates a column of {@code BOOL8} elements indicating the presence of {@code NaN} values
 * in a column of floating point values.
 * The output element at row {@code i} is {@code true} if the element in {@code input} at row i is {@code NAN}, else {@code false}
 *
 * @throws cudf::logic_error if {@code input} is a non-floating point type
 *
 * @param input A column of floating-point elements
 * @param mr Optional, The resource to use for allocating the device memory in the returned column.
 *
 * @return unique_ptr<column> A non-nulalble column of {@code BOOL8} elements with {@code true}
 * representing {@code NAN} values
 */
@Namespace("cudf::experimental") public static native @UniquePtr column is_nan(@Const @ByRef column_view input,
                               device_memory_resource mr/*=rmm::mr::get_default_resource()*/);
@Namespace("cudf::experimental") public static native @UniquePtr column is_nan(@Const @ByRef column_view input);

/**
 * \brief Creates a column of {@code BOOL8} elements indicating the absence of {@code NaN} values
 * in a column of floating point values.
 * The output element at row {@code i} is {@code false} if the element in {@code input} at row i is {@code NAN}, else {@code true}
 *
 * @throws cudf::logic_error if {@code input} is a non-floating point type
 *
 * @param input A column of floating-point elements
 * @param mr Optional, The resource to use for allocating the device memory in the returned column.
 *
 * @return unique_ptr<column> A non-nulalble column of {@code BOOL8} elements with {@code false}
 * representing {@code NAN} values
 */
@Namespace("cudf::experimental") public static native @UniquePtr column is_not_nan(@Const @ByRef column_view input,
                                 device_memory_resource mr/*=rmm::mr::get_default_resource()*/);
@Namespace("cudf::experimental") public static native @UniquePtr column is_not_nan(@Const @ByRef column_view input);

 // namespace experimental
 // namespace cudf


// Parsed from <cudf/types.hpp>

/*
 * Copyright (c) 2018-2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #pragma once

// #ifdef __CUDACC__
// #define CUDA_HOST_DEVICE_CALLABLE __host__ __device__ inline
// #define CUDA_DEVICE_CALLABLE __device__ inline
// #else
// #define CUDA_HOST_DEVICE_CALLABLE inline
// #define CUDA_DEVICE_CALLABLE inline
// #endif

// #include <cstddef>
// #include <cstdint>

/**---------------------------------------------------------------------------*
 * \file types.hpp
 * \brief Type declarations for libcudf.
 *
 *---------------------------------------------------------------------------**/

/**---------------------------------------------------------------------------*
 * \brief Forward declaration of cudaStream_t
 *---------------------------------------------------------------------------**/

// Targeting ../device_buffer.java


// Targeting ../device_memory_resource.java


@Namespace("rmm::mr") public static native device_memory_resource get_default_resource();
  // namespace mr

  // namespace rmm
// Targeting ../table.java


// Targeting ../string_view.java


// Targeting ../scalar.java


// Targeting ../string_scalar.java


// Targeting ../string_scalar_device_view.java



// Targeting ../table_view.java


// Targeting ../mutable_table_view.java



/**---------------------------------------------------------------------------*
 * \brief Indicates an unknown null count.
 *
 * Use this value when constructing any column-like object to indicate that
 * the null count should be computed on the first invocation of {@code null_count()}.
 *---------------------------------------------------------------------------**/
@Namespace("cudf") @MemberGetter public static native @Cast("const cudf::size_type") int UNKNOWN_NULL_COUNT();
public static final int UNKNOWN_NULL_COUNT = UNKNOWN_NULL_COUNT();

/**---------------------------------------------------------------------------*
 * \brief Indicates the order in which elements should be sorted.
 *---------------------------------------------------------------------------**/
@Namespace("cudf") public enum order {
  /** Elements ordered from small to large */
  ASCENDING(0),
  /** Elements ordered from large to small */
  DESCENDING(1);

    public final int value;
    private order(int v) { this.value = v; }
    private order(order e) { this.value = e.value; }
    public order intern() { for (order e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/**
 * \brief Enum to specify whether to include nulls or exclude nulls
 */
@Namespace("cudf") public enum include_nulls {
  NO(0),
  YES(1);

    public final int value;
    private include_nulls(int v) { this.value = v; }
    private include_nulls(include_nulls e) { this.value = e.value; }
    public include_nulls intern() { for (include_nulls e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/**---------------------------------------------------------------------------*
 * \brief Indicates how null values compare against all other values.
 *---------------------------------------------------------------------------**/
@Namespace("cudf") public enum null_order {
  /** NULL values ordered *after* all other values */
  AFTER(0),
  /** NULL values ordered *before* all other values */
  BEFORE(1);

    public final int value;
    private null_order(int v) { this.value = v; }
    private null_order(null_order e) { this.value = e.value; }
    public null_order intern() { for (null_order e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/**---------------------------------------------------------------------------*
 * \brief Indicates whether a collection of values is known to be sorted.
 *---------------------------------------------------------------------------**/
@Namespace("cudf") public enum sorted {
    NO(0),
    YES(1);

    public final int value;
    private sorted(int v) { this.value = v; }
    private sorted(sorted e) { this.value = e.value; }
    public sorted intern() { for (sorted e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}
// Targeting ../order_info.java



/**---------------------------------------------------------------------------*
 * \brief Controls the allocation/initialization of a null mask.
 *---------------------------------------------------------------------------**/
@Namespace("cudf") public enum mask_state {
  /** Null mask not allocated, (all elements are valid) */
  UNALLOCATED(0),
  /** Null mask allocated, but not initialized */
  UNINITIALIZED(1),
  /** Null mask allocated, initialized to all elements valid */
  ALL_VALID(2),
  /** Null mask allocated, initialized to all elements NULL */
  ALL_NULL(3);

    public final int value;
    private mask_state(int v) { this.value = v; }
    private mask_state(mask_state e) { this.value = e.value; }
    public mask_state intern() { for (mask_state e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/**
 * \brief Interpolation method to use when the desired quantile lies between
 * two data points i and j
 *
 */
@Namespace("cudf::experimental") public enum interpolation {
    /** Linear interpolation between i and j */
    LINEAR(0),
    /** Lower data point (i) */
    LOWER(1),
    /** Higher data point (j) */
    HIGHER(2),
    /** (i + j)/2 */
    MIDPOINT(3),
    /** i or j, whichever is nearest */
    NEAREST(4);

    public final int value;
    private interpolation(int v) { this.value = v; }
    private interpolation(interpolation e) { this.value = e.value; }
    public interpolation intern() { for (interpolation e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

 // namespace experimental

/**---------------------------------------------------------------------------*
 * \brief Identifies a column's logical element type
 *---------------------------------------------------------------------------**/
@Namespace("cudf") public enum type_id {
  /** Always null with no underlying data */
  EMPTY(0),
  /** 1 byte signed integer */
  INT8(1),
  /** 2 byte signed integer */
  INT16(2),
  /** 4 byte signed integer */
  INT32(3),
  /** 8 byte signed integer */
  INT64(4),
  /** 4 byte floating point */
  FLOAT32(5),
  /** 8 byte floating point */
  FLOAT64(6),
  /** Boolean using one byte per value, 0 == false, else true */
  BOOL8(7),
  /** days since Unix Epoch in int32 */
  TIMESTAMP_DAYS(8),
  /** duration of seconds since Unix Epoch in int64 */
  TIMESTAMP_SECONDS(9),
  /** duration of milliseconds since Unix Epoch in int64 */
  TIMESTAMP_MILLISECONDS(10),
  /** duration of microseconds since Unix Epoch in int64 */
  TIMESTAMP_MICROSECONDS(11),
  /** duration of nanoseconds since Unix Epoch in int64 */
  TIMESTAMP_NANOSECONDS(12),
  /** Dictionary type using int32 indices */
  DICTIONARY32(13),
  /** String elements */
  STRING(14),
  // `NUM_TYPE_IDS` must be last!
  /** Total number of type ids */
  NUM_TYPE_IDS(15);

    public final int value;
    private type_id(int v) { this.value = v; }
    private type_id(type_id e) { this.value = e.value; }
    public type_id intern() { for (type_id e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}
// Targeting ../data_type.java



/**---------------------------------------------------------------------------*
 * \brief Compares two {@code data_type} objects for equality.
 *
 * // TODO Define exactly what it means for two {@code data_type}s to be equal. e.g.,
 * are two timestamps with different resolutions equal? How about decimals with
 * different scale/precision?
 *
 * @param lhs The first {@code data_type} to compare
 * @param rhs The second {@code data_type} to compare
 * @return true {@code lhs} is equal to {@code rhs}
 * @return false {@code lhs} is not equal to {@code rhs}
 *---------------------------------------------------------------------------**/
@Namespace("cudf") public static native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef data_type lhs, @Const @ByRef data_type rhs);

/**
 * \brief Returns the size in bytes of elements of the specified {@code data_type}
 *
 * \note Only fixed-width types are supported
 *
 * @throws cudf::logic_error if {@code is_fixed_width(element_type) == false}
 *
 * @return Size in bytes of an element of the specified {@code data_type}
 */
@Namespace("cudf") public static native @Cast("std::size_t") long size_of(@ByVal data_type t);


  // namespace cudf


// Parsed from <cudf/column/column.hpp>

/*
 * Copyright (c) 2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// #pragma once

// #include <cudf/null_mask.hpp>
// #include <cudf/types.hpp>
// #include "column_view.hpp"

// #include <rmm/device_buffer.hpp>

// #include <memory>
// #include <type_traits>
// #include <utility>
// #include <vector>
// Targeting ../column.java



  // namespace cudf


// Parsed from <cudf/column/column_view.hpp>

/*
 * Copyright (c) 2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// #pragma once

// #include <cudf/types.hpp>
// #include <vector>
// Targeting ../column_view_base.java


// Targeting ../mutable_column_view_base.java



// Targeting ../column_view.java


// Targeting ../mutable_column_view.java



/**---------------------------------------------------------------------------*
 * \brief Counts the number of descendants of the specified parent.
 *
 * @param parent The parent whose descendants will be counted
 * @return size_type The number of descendants of the parent
 *---------------------------------------------------------------------------**/
@Namespace("cudf") public static native @Cast("cudf::size_type") int count_descendants(@ByVal column_view parent);

// namespace cudf


}
