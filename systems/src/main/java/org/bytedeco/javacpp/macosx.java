// Targeted by JavaCPP version 1.4.4: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class macosx extends org.bytedeco.javacpp.presets.macosx {
    static { Loader.load(); }

// Parsed from cpuid.h

/*===---- cpuid.h - X86 cpu model detection --------------------------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

// #if !(__x86_64__ || __i386__)
// #error this header is for x86 only
// #endif

/* Responses identification request with %eax 0 */
/* AMD:     "AuthenticAMD" */
public static final int signature_AMD_ebx = 0x68747541;
public static final int signature_AMD_edx = 0x69746e65;
public static final int signature_AMD_ecx = 0x444d4163;
/* CENTAUR: "CentaurHauls" */
public static final int signature_CENTAUR_ebx = 0x746e6543;
public static final int signature_CENTAUR_edx = 0x48727561;
public static final int signature_CENTAUR_ecx = 0x736c7561;
/* CYRIX:   "CyrixInstead" */
public static final int signature_CYRIX_ebx = 0x69727943;
public static final int signature_CYRIX_edx = 0x736e4978;
public static final int signature_CYRIX_ecx = 0x64616574;
/* INTEL:   "GenuineIntel" */
public static final int signature_INTEL_ebx = 0x756e6547;
public static final int signature_INTEL_edx = 0x49656e69;
public static final int signature_INTEL_ecx = 0x6c65746e;
/* TM1:     "TransmetaCPU" */
public static final int signature_TM1_ebx = 0x6e617254;
public static final int signature_TM1_edx = 0x74656d73;
public static final int signature_TM1_ecx = 0x55504361;
/* TM2:     "GenuineTMx86" */
public static final int signature_TM2_ebx = 0x756e6547;
public static final int signature_TM2_edx = 0x54656e69;
public static final int signature_TM2_ecx = 0x3638784d;
/* NSC:     "Geode by NSC" */
public static final int signature_NSC_ebx = 0x646f6547;
public static final int signature_NSC_edx = 0x43534e20;
public static final int signature_NSC_ecx = 0x79622065;
/* NEXGEN:  "NexGenDriven" */
public static final int signature_NEXGEN_ebx = 0x4778654e;
public static final int signature_NEXGEN_edx = 0x72446e65;
public static final int signature_NEXGEN_ecx = 0x6e657669;
/* RISE:    "RiseRiseRise" */
public static final int signature_RISE_ebx = 0x65736952;
public static final int signature_RISE_edx = 0x65736952;
public static final int signature_RISE_ecx = 0x65736952;
/* SIS:     "SiS SiS SiS " */
public static final int signature_SIS_ebx = 0x20536953;
public static final int signature_SIS_edx = 0x20536953;
public static final int signature_SIS_ecx = 0x20536953;
/* UMC:     "UMC UMC UMC " */
public static final int signature_UMC_ebx = 0x20434d55;
public static final int signature_UMC_edx = 0x20434d55;
public static final int signature_UMC_ecx = 0x20434d55;
/* VIA:     "VIA VIA VIA " */
public static final int signature_VIA_ebx = 0x20414956;
public static final int signature_VIA_edx = 0x20414956;
public static final int signature_VIA_ecx = 0x20414956;
/* VORTEX:  "Vortex86 SoC" */
public static final int signature_VORTEX_ebx = 0x74726f56;
public static final int signature_VORTEX_edx = 0x36387865;
public static final int signature_VORTEX_ecx = 0x436f5320;

/* Features in %ecx for level 1 */
public static final int bit_SSE3 =        0x00000001;
public static final int bit_PCLMULQDQ =   0x00000002;
public static final int bit_DTES64 =      0x00000004;
public static final int bit_MONITOR =     0x00000008;
public static final int bit_DSCPL =       0x00000010;
public static final int bit_VMX =         0x00000020;
public static final int bit_SMX =         0x00000040;
public static final int bit_EIST =        0x00000080;
public static final int bit_TM2 =         0x00000100;
public static final int bit_SSSE3 =       0x00000200;
public static final int bit_CNXTID =      0x00000400;
public static final int bit_FMA =         0x00001000;
public static final int bit_CMPXCHG16B =  0x00002000;
public static final int bit_xTPR =        0x00004000;
public static final int bit_PDCM =        0x00008000;
public static final int bit_PCID =        0x00020000;
public static final int bit_DCA =         0x00040000;
public static final int bit_SSE41 =       0x00080000;
public static final int bit_SSE42 =       0x00100000;
public static final int bit_x2APIC =      0x00200000;
public static final int bit_MOVBE =       0x00400000;
public static final int bit_POPCNT =      0x00800000;
public static final int bit_TSCDeadline = 0x01000000;
public static final int bit_AESNI =       0x02000000;
public static final int bit_XSAVE =       0x04000000;
public static final int bit_OSXSAVE =     0x08000000;
public static final int bit_AVX =         0x10000000;
public static final int bit_RDRND =       0x40000000;

/* Features in %edx for level 1 */
public static final int bit_FPU =         0x00000001;
public static final int bit_VME =         0x00000002;
public static final int bit_DE =          0x00000004;
public static final int bit_PSE =         0x00000008;
public static final int bit_TSC =         0x00000010;
public static final int bit_MSR =         0x00000020;
public static final int bit_PAE =         0x00000040;
public static final int bit_MCE =         0x00000080;
public static final int bit_CX8 =         0x00000100;
public static final int bit_APIC =        0x00000200;
public static final int bit_SEP =         0x00000800;
public static final int bit_MTRR =        0x00001000;
public static final int bit_PGE =         0x00002000;
public static final int bit_MCA =         0x00004000;
public static final int bit_CMOV =        0x00008000;
public static final int bit_PAT =         0x00010000;
public static final int bit_PSE36 =       0x00020000;
public static final int bit_PSN =         0x00040000;
public static final int bit_CLFSH =       0x00080000;
public static final int bit_DS =          0x00200000;
public static final int bit_ACPI =        0x00400000;
public static final int bit_MMX =         0x00800000;
public static final int bit_FXSR =        0x01000000;
public static final int bit_FXSAVE =      bit_FXSR;    /* for gcc compat */
public static final int bit_SSE =         0x02000000;
public static final int bit_SSE2 =        0x04000000;
public static final int bit_SS =          0x08000000;
public static final int bit_HTT =         0x10000000;
public static final int bit_TM =          0x20000000;
public static final int bit_PBE =         0x80000000;

/* Features in %ebx for level 7 sub-leaf 0 */
public static final int bit_FSGSBASE =    0x00000001;
public static final int bit_SMEP =        0x00000080;
public static final int bit_ENH_MOVSB =   0x00000200;

// #if __i386__
public static native void __cpuid(int __level, @ByRef IntPointer __eax, @ByRef IntPointer __ebx, @ByRef IntPointer __ecx, @ByRef IntPointer __edx);
public static native void __cpuid(int __level, @ByRef IntBuffer __eax, @ByRef IntBuffer __ebx, @ByRef IntBuffer __ecx, @ByRef IntBuffer __edx);
public static native void __cpuid(int __level, @ByRef int[] __eax, @ByRef int[] __ebx, @ByRef int[] __ecx, @ByRef int[] __edx);

public static native void __cpuid_count(int __level, int __count, @ByRef IntPointer __eax, @ByRef IntPointer __ebx, @ByRef IntPointer __ecx, @ByRef IntPointer __edx);
public static native void __cpuid_count(int __level, int __count, @ByRef IntBuffer __eax, @ByRef IntBuffer __ebx, @ByRef IntBuffer __ecx, @ByRef IntBuffer __edx);
public static native void __cpuid_count(int __level, int __count, @ByRef int[] __eax, @ByRef int[] __ebx, @ByRef int[] __ecx, @ByRef int[] __edx);
// #else
/* x86-64 uses %rbx as the base register, so preserve it. */
// #endif

public static native int __get_cpuid(@Cast("unsigned int") int __level, @Cast("unsigned int*") IntPointer __eax,
                                 @Cast("unsigned int*") IntPointer __ebx, @Cast("unsigned int*") IntPointer __ecx,
                                 @Cast("unsigned int*") IntPointer __edx);
public static native int __get_cpuid(@Cast("unsigned int") int __level, @Cast("unsigned int*") IntBuffer __eax,
                                 @Cast("unsigned int*") IntBuffer __ebx, @Cast("unsigned int*") IntBuffer __ecx,
                                 @Cast("unsigned int*") IntBuffer __edx);
public static native int __get_cpuid(@Cast("unsigned int") int __level, @Cast("unsigned int*") int[] __eax,
                                 @Cast("unsigned int*") int[] __ebx, @Cast("unsigned int*") int[] __ecx,
                                 @Cast("unsigned int*") int[] __edx);

public static native int __get_cpuid_max(@Cast("unsigned int") int __level, @Cast("unsigned int*") IntPointer __sig);
public static native int __get_cpuid_max(@Cast("unsigned int") int __level, @Cast("unsigned int*") IntBuffer __sig);
public static native int __get_cpuid_max(@Cast("unsigned int") int __level, @Cast("unsigned int*") int[] __sig);


// Parsed from dlfcn.h

/*
 * Copyright (c) 2004-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

/*
  Based on the dlcompat work done by:
		Jorge Acereda  <jacereda@users.sourceforge.net> &
		Peter O'Gorman <ogorman@users.sourceforge.net>
*/

// #ifndef _DLFCN_H_
// #define _DLFCN_H_

// #ifdef __cplusplus
// #endif

// #include <sys/cdefs.h>

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
// #include <stdbool.h>
// #include <Availability.h>
/*
 * Structure filled in by dladdr().
 */
public static class Dl_info extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public Dl_info() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Dl_info(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Dl_info(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public Dl_info position(long position) {
        return (Dl_info)super.position(position);
    }

        @MemberGetter public native @Cast("const char*") BytePointer dli_fname();     /* Pathname of shared object */
        public native Pointer dli_fbase(); public native Dl_info dli_fbase(Pointer dli_fbase);     /* Base address of shared object */
        @MemberGetter public native @Cast("const char*") BytePointer dli_sname();     /* Name of nearest symbol */
        public native Pointer dli_saddr(); public native Dl_info dli_saddr(Pointer dli_saddr);     /* Address of nearest symbol */
}

public static native int dladdr(@Const Pointer arg0, Dl_info arg1);
// #endif /* not POSIX */

public static native int dlclose(Pointer __handle);
public static native @Cast("char*") BytePointer dlerror();
public static native Pointer dlopen(@Cast("const char*") BytePointer __path, int __mode);
public static native Pointer dlopen(String __path, int __mode);
public static native Pointer dlsym(Pointer __handle, @Cast("const char*") BytePointer __symbol);
public static native Pointer dlsym(Pointer __handle, String __symbol);

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static native @Cast("bool") boolean dlopen_preflight(@Cast("const char*") BytePointer __path);
public static native @Cast("bool") boolean dlopen_preflight(String __path);
// #endif /* not POSIX */


public static final int RTLD_LAZY =	0x1;
public static final int RTLD_NOW =	0x2;
public static final int RTLD_LOCAL =	0x4;
public static final int RTLD_GLOBAL =	0x8;

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int RTLD_NOLOAD =	0x10;
public static final int RTLD_NODELETE =	0x80;
public static final int RTLD_FIRST =	0x100;	/* Mac OS X 10.5 and later */

/*
 * Special handle arguments for dlsym().
 */
public static native @MemberGetter Pointer RTLD_NEXT();
public static final Pointer RTLD_NEXT = RTLD_NEXT();	/* Search subsequent objects. */
public static native @MemberGetter Pointer RTLD_DEFAULT();
public static final Pointer RTLD_DEFAULT = RTLD_DEFAULT();	/* Use default search algorithm. */
public static native @MemberGetter Pointer RTLD_SELF();
public static final Pointer RTLD_SELF = RTLD_SELF();	/* Search this and subsequent objects (Mac OS X 10.5 and later) */
public static native @MemberGetter Pointer RTLD_MAIN_ONLY();
public static final Pointer RTLD_MAIN_ONLY = RTLD_MAIN_ONLY();	/* Search main executable only (Mac OS X 10.5 and later) */
// #endif /* not POSIX */

// #ifdef __cplusplus
// #endif

// #endif /* _DLFCN_H_ */


// Parsed from nl_types.h

/*	$NetBSD: nl_types.h,v 1.9 2000/10/03 19:53:32 sommerfeld Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by J.T. Conklin.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/include/nl_types.h,v 1.11 2005/02/27 16:20:53 phantom Exp $
 */

// #ifndef _NL_TYPES_H_
// #define _NL_TYPES_H_

// #include <sys/cdefs.h>
// #include <sys/types.h>
// #include <_types.h>

// #ifdef _NLS_PRIVATE

// #endif	/* _NLS_PRIVATE */

public static final int NL_SETD =		1;
public static final int NL_CAT_LOCALE =	1;

public static class __nl_cat_d extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public __nl_cat_d() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public __nl_cat_d(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public __nl_cat_d(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public __nl_cat_d position(long position) {
        return (__nl_cat_d)super.position(position);
    }

	public native Pointer __data(); public native __nl_cat_d __data(Pointer __data);
	public native int __size(); public native __nl_cat_d __size(int __size);
}

// #include <_types/_nl_item.h>

public static native __nl_cat_d catopen(@Cast("const char*") BytePointer arg0, int arg1);
public static native __nl_cat_d catopen(String arg0, int arg1);
public static native @Cast("char*") BytePointer catgets(__nl_cat_d arg0, int arg1, int arg2, @Cast("const char*") BytePointer arg3);
public static native @Cast("char*") ByteBuffer catgets(__nl_cat_d arg0, int arg1, int arg2, String arg3);
public static native int catclose(__nl_cat_d arg0);
// #endif	/* _NL_TYPES_H_ */


// Parsed from xlocale.h

/*
 * Copyright (c) 2005 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

// #ifndef _XLOCALE_H_
// #define _XLOCALE_H_

// #include <sys/cdefs.h>

// #ifndef _USE_EXTENDED_LOCALES_
// #define _USE_EXTENDED_LOCALES_
// #endif /* _USE_EXTENDED_LOCALES_ */

@Opaque public static class _xlocale extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public _xlocale() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _xlocale(Pointer p) { super(p); }
} /* forward reference */

// #include <_locale.h>
// #include <_xlocale.h>

public static native @MemberGetter int LC_ALL_MASK();
public static final int LC_ALL_MASK = LC_ALL_MASK();
public static final int LC_COLLATE_MASK =			(1 << 0);
public static final int LC_CTYPE_MASK =			(1 << 1);
public static final int LC_MESSAGES_MASK =		(1 << 2);
public static final int LC_MONETARY_MASK =		(1 << 3);
public static final int LC_NUMERIC_MASK =			(1 << 4);
public static final int LC_TIME_MASK =			(1 << 5);

public static final int _LC_NUM_MASK =			6;
public static final int _LC_LAST_MASK =			(1 << (_LC_NUM_MASK - 1));

public static native @MemberGetter _xlocale LC_GLOBAL_LOCALE();
public static final _xlocale LC_GLOBAL_LOCALE = LC_GLOBAL_LOCALE();

// #ifdef MB_CUR_MAX
// #undef MB_CUR_MAX
public static native @MemberGetter int MB_CUR_MAX();
public static final int MB_CUR_MAX = MB_CUR_MAX();
// #ifndef MB_CUR_MAX_L
// #define MB_CUR_MAX_L(x)			(___mb_cur_max_l(x))
// #endif /* !MB_CUR_MAX_L */
// #endif /* MB_CUR_MAX */

@MemberGetter public static native _xlocale _c_locale();

public static native _xlocale duplocale(_xlocale arg0);
public static native int freelocale(_xlocale arg0);
public static native lconv localeconv_l(_xlocale arg0);
public static native _xlocale newlocale(int arg0, @Cast("const char*") BytePointer arg1, _xlocale arg2);
public static native _xlocale newlocale(int arg0, String arg1, _xlocale arg2);
public static native @Cast("const char*") BytePointer querylocale(int arg0, _xlocale arg1);
public static native _xlocale uselocale(_xlocale arg0);
// #ifdef _CTYPE_H_
// #include <xlocale/_ctype.h>
// #endif /* _CTYPE_H_ */
// #ifdef __WCTYPE_H_
// #include <xlocale/__wctype.h>
// #endif /* __WCTYPE_H_ */
// #ifdef _INTTYPES_H_
// #include <xlocale/_inttypes.h>
// #endif /* _INTTYPES_H_ */
// #ifdef _LANGINFO_H_
// #include <xlocale/_langinfo.h>
// #endif /* _LANGINFO_H_ */
// #ifdef _MONETARY_H_
// #include <xlocale/_monetary.h>
// #endif /* _MONETARY_H_ */
// #ifdef _REGEX_H_
// #include <xlocale/_regex.h>
// #endif /* _REGEX_H_ */
// #ifdef _STDIO_H_
// #include <xlocale/_stdio.h>
// #endif /* _STDIO_H_ */
// #ifdef _STDLIB_H_
// #include <xlocale/_stdlib.h>
// #endif /* _STDLIB_H_ */
// #ifdef _STRING_H_
// #include <xlocale/_string.h>
// #endif /*STRING_CTYPE_H_ */
// #ifdef _TIME_H_
// #include <xlocale/_time.h>
// #endif /* _TIME_H_ */
// #ifdef _WCHAR_H_
// #include <xlocale/_wchar.h>
// #endif /*WCHAR_CTYPE_H_ */
// #ifdef _WCTYPE_H_
// #include <xlocale/_wctype.h>
// #endif /* _WCTYPE_H_ */

// #endif /* _XLOCALE_H_ */


// Parsed from _locale.h

/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)locale.h	8.1 (Berkeley) 6/2/93
 * $FreeBSD: /repoman/r/ncvs/src/include/locale.h,v 1.7 2002/10/09 09:19:27 tjr Exp $
 */

// #ifndef __LOCALE_H_
// #define __LOCALE_H_

// #include <sys/cdefs.h>
// #include <_types.h>

public static class lconv extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public lconv() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public lconv(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public lconv(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public lconv position(long position) {
        return (lconv)super.position(position);
    }

	public native @Cast("char*") BytePointer decimal_point(); public native lconv decimal_point(BytePointer decimal_point);
	public native @Cast("char*") BytePointer thousands_sep(); public native lconv thousands_sep(BytePointer thousands_sep);
	public native @Cast("char*") BytePointer grouping(); public native lconv grouping(BytePointer grouping);
	public native @Cast("char*") BytePointer int_curr_symbol(); public native lconv int_curr_symbol(BytePointer int_curr_symbol);
	public native @Cast("char*") BytePointer currency_symbol(); public native lconv currency_symbol(BytePointer currency_symbol);
	public native @Cast("char*") BytePointer mon_decimal_point(); public native lconv mon_decimal_point(BytePointer mon_decimal_point);
	public native @Cast("char*") BytePointer mon_thousands_sep(); public native lconv mon_thousands_sep(BytePointer mon_thousands_sep);
	public native @Cast("char*") BytePointer mon_grouping(); public native lconv mon_grouping(BytePointer mon_grouping);
	public native @Cast("char*") BytePointer positive_sign(); public native lconv positive_sign(BytePointer positive_sign);
	public native @Cast("char*") BytePointer negative_sign(); public native lconv negative_sign(BytePointer negative_sign);
	public native @Cast("char") byte int_frac_digits(); public native lconv int_frac_digits(byte int_frac_digits);
	public native @Cast("char") byte frac_digits(); public native lconv frac_digits(byte frac_digits);
	public native @Cast("char") byte p_cs_precedes(); public native lconv p_cs_precedes(byte p_cs_precedes);
	public native @Cast("char") byte p_sep_by_space(); public native lconv p_sep_by_space(byte p_sep_by_space);
	public native @Cast("char") byte n_cs_precedes(); public native lconv n_cs_precedes(byte n_cs_precedes);
	public native @Cast("char") byte n_sep_by_space(); public native lconv n_sep_by_space(byte n_sep_by_space);
	public native @Cast("char") byte p_sign_posn(); public native lconv p_sign_posn(byte p_sign_posn);
	public native @Cast("char") byte n_sign_posn(); public native lconv n_sign_posn(byte n_sign_posn);
	public native @Cast("char") byte int_p_cs_precedes(); public native lconv int_p_cs_precedes(byte int_p_cs_precedes);
	public native @Cast("char") byte int_n_cs_precedes(); public native lconv int_n_cs_precedes(byte int_n_cs_precedes);
	public native @Cast("char") byte int_p_sep_by_space(); public native lconv int_p_sep_by_space(byte int_p_sep_by_space);
	public native @Cast("char") byte int_n_sep_by_space(); public native lconv int_n_sep_by_space(byte int_n_sep_by_space);
	public native @Cast("char") byte int_p_sign_posn(); public native lconv int_p_sign_posn(byte int_p_sign_posn);
	public native @Cast("char") byte int_n_sign_posn(); public native lconv int_n_sign_posn(byte int_n_sign_posn);
}

// #include <sys/_types/_null.h>

public static native lconv localeconv();
// #endif /* __LOCALE_H_ */


// Parsed from langinfo.h

/*-
 * Copyright (c) 2001 Alexey Zelkin <phantom@FreeBSD.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: /repoman/r/ncvs/src/include/langinfo.h,v 1.6 2002/09/18 05:54:25 mike Exp $
 */

// #ifndef _LANGINFO_H_
// #define	_LANGINFO_H_

// #include <_types.h>
// #include <_types/_nl_item.h>

public static final int CODESET =		0;	/* codeset name */
public static final int D_T_FMT =		1;	/* string for formatting date and time */
public static final int D_FMT =		2;	/* date format string */
public static final int T_FMT =		3;	/* time format string */
public static final int T_FMT_AMPM =	4;	/* a.m. or p.m. time formatting string */
public static final int AM_STR =		5;	/* Ante Meridian affix */
public static final int PM_STR =		6;	/* Post Meridian affix */

/* week day names */
public static final int DAY_1 =		7;
public static final int DAY_2 =		8;
public static final int DAY_3 =		9;
public static final int DAY_4 =		10;
public static final int DAY_5 =		11;
public static final int DAY_6 =		12;
public static final int DAY_7 =		13;

/* abbreviated week day names */
public static final int ABDAY_1 =		14;
public static final int ABDAY_2 =		15;
public static final int ABDAY_3 =		16;
public static final int ABDAY_4 =		17;
public static final int ABDAY_5 =		18;
public static final int ABDAY_6 =		19;
public static final int ABDAY_7 =		20;

/* month names */
public static final int MON_1 =		21;
public static final int MON_2 =		22;
public static final int MON_3 =		23;
public static final int MON_4 =		24;
public static final int MON_5 =		25;
public static final int MON_6 =		26;
public static final int MON_7 =		27;
public static final int MON_8 =		28;
public static final int MON_9 =		29;
public static final int MON_10 =		30;
public static final int MON_11 =		31;
public static final int MON_12 =		32;

/* abbreviated month names */
public static final int ABMON_1 =		33;
public static final int ABMON_2 =		34;
public static final int ABMON_3 =		35;
public static final int ABMON_4 =		36;
public static final int ABMON_5 =		37;
public static final int ABMON_6 =		38;
public static final int ABMON_7 =		39;
public static final int ABMON_8 =		40;
public static final int ABMON_9 =		41;
public static final int ABMON_10 =	42;
public static final int ABMON_11 =	43;
public static final int ABMON_12 =	44;

public static final int ERA =		45;	/* era description segments */
public static final int ERA_D_FMT =	46;	/* era date format string */
public static final int ERA_D_T_FMT =	47;	/* era date and time format string */
public static final int ERA_T_FMT =	48;	/* era time format string */
public static final int ALT_DIGITS =	49;	/* alternative symbols for digits */

public static final int RADIXCHAR =	50;	/* radix char */
public static final int THOUSEP =		51;	/* separator for thousands */

public static final int YESEXPR =		52;	/* affirmative response expression */
public static final int NOEXPR =		53;	/* negative response expression */

// #if (__DARWIN_C_LEVEL > __DARWIN_C_ANSI && __DARWIN_C_LEVEL < 200112L) || __DARWIN_C_LEVEL == __DARWIN_C_FULL
public static final int YESSTR =		54;	/* affirmative response for yes/no queries */
public static final int NOSTR =		55;	/* negative response for yes/no queries */
// #endif

public static final int CRNCYSTR =	56;	/* currency symbol */

// #if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
public static final int D_MD_ORDER =	57;	/* month/day order (local extension) */
// #endif

public static native @Cast("char*") BytePointer nl_langinfo(@Cast("nl_item") int arg0);
// #ifdef _USE_EXTENDED_LOCALES_
// #endif /* _USE_EXTENDED_LOCALES_ */

// #endif /* !_LANGINFO_H_ */


// Parsed from locale.h

/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)locale.h	8.1 (Berkeley) 6/2/93
 * $FreeBSD: /repoman/r/ncvs/src/include/locale.h,v 1.7 2002/10/09 09:19:27 tjr Exp $
 */

// #ifndef _LOCALE_H_
// #define _LOCALE_H_

// #include <_locale.h>

public static final int LC_ALL =		0;
public static final int LC_COLLATE =	1;
public static final int LC_CTYPE =	2;
public static final int LC_MONETARY =	3;
public static final int LC_NUMERIC =	4;
public static final int LC_TIME =		5;
public static final int LC_MESSAGES =	6;

public static final int _LC_LAST =	7;		/* marks end */

public static native @Cast("char*") BytePointer setlocale(int arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") ByteBuffer setlocale(int arg0, String arg1);
// #endif /* _LOCALE_H_ */


// Parsed from sys/uio.h

/*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)uio.h	8.5 (Berkeley) 2/22/94
 */

// #ifndef _SYS_UIO_H_
// #define	_SYS_UIO_H_

// #include <sys/cdefs.h>
// #include <sys/_types.h>

/*
 * [XSI] The ssize_t and size_t types shall be defined as described
 * in <sys/types.h>.
 */
// #include <sys/_types/_size_t.h>
// #include <sys/_types/_ssize_t.h>

/*
 * [XSI] Structure whose address is passed as the second parameter to the
 * readv() and writev() functions.
 */
// #include <sys/_types/_iovec_t.h>


// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/*
 * IO direction for uio_t.
 *	UIO_READ - data moves into iovec(s) associated with uio_t
 *	UIO_WRITE - data moves out of iovec(s) associated with uio_t
 */
/** enum uio_rw */
public static final int UIO_READ = 0, UIO_WRITE = 1;
// #endif



public static native @Cast("ssize_t") long readv(int arg0, @Const iovec arg1, int arg2);
public static native @Cast("ssize_t") long writev(int arg0, @Const iovec arg1, int arg2);
// #endif /* !_SYS_UIO_H_ */


// Parsed from sys/_types/_iovec_t.h

/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
// #ifndef _STRUCT_IOVEC
// #define	_STRUCT_IOVEC
public static class iovec extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public iovec() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public iovec(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public iovec(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public iovec position(long position) {
        return (iovec)super.position(position);
    }

	public native Pointer iov_base(); public native iovec iov_base(Pointer iov_base);	/* [XSI] Base address of I/O memory region */
	public native @Cast("size_t") long iov_len(); public native iovec iov_len(long iov_len);	/* [XSI] Size of region iov_base points to */
}
// #endif /* _STRUCT_IOVEC */


// Parsed from sys/socket.h

/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1998, 1999 Apple Computer, Inc. All Rights Reserved */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1985, 1986, 1988, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)socket.h	8.4 (Berkeley) 2/21/94
 * $FreeBSD: src/sys/sys/socket.h,v 1.39.2.7 2001/07/03 11:02:01 ume Exp $
 */
/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */

// #ifndef _SYS_SOCKET_H_
// #define	_SYS_SOCKET_H_

// #include <sys/types.h>
// #include <sys/cdefs.h>
// #include <machine/_param.h>


// #include <Availability.h>

/*
 * Definitions related to sockets: types, address families, options.
 */

/*
 * Data types.
 */

// #include <sys/_types/_gid_t.h>
// #include <sys/_types/_off_t.h>
// #include <sys/_types/_pid_t.h>
// #include <sys/_types/_sa_family_t.h>
// #include <sys/_types/_socklen_t.h>

/* XXX Not explicitly defined by POSIX, but function return types are */
// #include <sys/_types/_size_t.h>
 
/* XXX Not explicitly defined by POSIX, but function return types are */
// #include <sys/_types/_ssize_t.h>

/*
 * [XSI] The iovec structure shall be defined as described in <sys/uio.h>.
 */
// #include <sys/_types/_iovec_t.h>

 
/*
 * Types
 */
public static final int SOCK_STREAM =	1;		/* stream socket */
public static final int SOCK_DGRAM =	2;		/* datagram socket */
public static final int SOCK_RAW =	3;		/* raw-protocol interface */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SOCK_RDM =	4;		/* reliably-delivered message */
// #endif	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int SOCK_SEQPACKET =	5;		/* sequenced packet stream */

/*
 * Option flags per-socket.
 */
public static final int SO_DEBUG =	0x0001;		/* turn on debugging info recording */
public static final int SO_ACCEPTCONN =	0x0002;		/* socket has had listen() */
public static final int SO_REUSEADDR =	0x0004;		/* allow local address reuse */
public static final int SO_KEEPALIVE =	0x0008;		/* keep connections alive */
public static final int SO_DONTROUTE =	0x0010;		/* just use interface addresses */
public static final int SO_BROADCAST =	0x0020;		/* permit sending of broadcast msgs */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SO_USELOOPBACK =	0x0040;		/* bypass hardware when possible */
public static final int SO_LINGER =	0x0080;          /* linger on close if data present (in ticks) */
// #else
// #endif	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int SO_OOBINLINE =	0x0100;		/* leave received OOB data in line */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SO_REUSEPORT =	0x0200;		/* allow local address & port reuse */
public static final int SO_TIMESTAMP =	0x0400;		/* timestamp received dgram traffic */
public static final int SO_TIMESTAMP_MONOTONIC =	0x0800;	/* Monotonically increasing timestamp on rcvd dgram */
// #ifndef __APPLE__
// #else
public static final int SO_DONTTRUNC =	0x2000;		/* APPLE: Retain unread data */
					/*  (ATOMIC proto) */
public static final int SO_WANTMORE =	0x4000;		/* APPLE: Give hint when more data ready */
public static final int SO_WANTOOBFLAG =	0x8000;		/* APPLE: Want OOB in MSG_FLAG on receive */


// #endif  /* (!__APPLE__) */
// #endif	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * Additional options, not kept in so_options.
 */
public static final int SO_SNDBUF =	0x1001;		/* send buffer size */
public static final int SO_RCVBUF =	0x1002;		/* receive buffer size */
public static final int SO_SNDLOWAT =	0x1003;		/* send low-water mark */
public static final int SO_RCVLOWAT =	0x1004;		/* receive low-water mark */
public static final int SO_SNDTIMEO =	0x1005;		/* send timeout */
public static final int SO_RCVTIMEO =	0x1006;		/* receive timeout */
public static final int SO_ERROR =	0x1007;		/* get error status and clear */
public static final int SO_TYPE =		0x1008;		/* get socket type */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/*efine	SO_PRIVSTATE	0x1009		   get/deny privileged state */
public static final int SO_LABEL =        0x1010;          /* socket's MAC label */
public static final int SO_PEERLABEL =    0x1011;          /* socket's peer MAC label */
// #ifdef __APPLE__
public static final int SO_NREAD =	0x1020;		/* APPLE: get 1st-packet byte count */
public static final int SO_NKE =		0x1021;		/* APPLE: Install socket-level NKE */
public static final int SO_NOSIGPIPE =	0x1022;		/* APPLE: No SIGPIPE on EPIPE */
public static final int SO_NOADDRERR =	0x1023;		/* APPLE: Returns EADDRNOTAVAIL when src is not available anymore */
public static final int SO_NWRITE =	0x1024;		/* APPLE: Get number of bytes currently in send socket buffer */
public static final int SO_REUSESHAREUID =	0x1025;		/* APPLE: Allow reuse of port/socket by different userids */
// #ifdef __APPLE_API_PRIVATE
public static final int SO_NOTIFYCONFLICT =	0x1026;	/* APPLE: send notification if there is a bind on a port which is already in use */
public static final int SO_UPCALLCLOSEWAIT =	0x1027;	/* APPLE: block on close until an upcall returns */
// #endif
public static final int SO_LINGER_SEC =	0x1080;          /* linger on close if data present (in seconds) */
public static final int SO_RANDOMPORT =   0x1082;  /* APPLE: request local port randomization */
public static final int SO_NP_EXTENSIONS =	0x1083;	/* To turn off some POSIX behavior */
// #endif


public static final int SO_NUMRCVPKT =		0x1112;	/* number of datagrams in receive socket buffer */

// #endif	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * Structure used for manipulating linger option.
 */
public static class linger extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public linger() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public linger(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public linger(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public linger position(long position) {
        return (linger)super.position(position);
    }

	public native int l_onoff(); public native linger l_onoff(int l_onoff);		/* option on/off */
	public native int l_linger(); public native linger l_linger(int l_linger);		/* linger time */
}

// #ifndef __APPLE__
// #endif

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
// #ifdef __APPLE__

/*
 * Structure to control non-portable Sockets extension to POSIX  
 */
public static class so_np_extensions extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public so_np_extensions() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public so_np_extensions(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public so_np_extensions(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public so_np_extensions position(long position) {
        return (so_np_extensions)super.position(position);
    }

	public native @Cast("u_int32_t") int npx_flags(); public native so_np_extensions npx_flags(int npx_flags);
	public native @Cast("u_int32_t") int npx_mask(); public native so_np_extensions npx_mask(int npx_mask);
}

public static final int SONPX_SETOPTSHUT =	0x000000001;     /* flag for allowing setsockopt after shutdown */



// #endif
// #endif

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
public static final int SOL_SOCKET =	0xffff;		/* options for socket level */


/*
 * Address families.
 */
public static final int AF_UNSPEC =	0;		/* unspecified */
public static final int AF_UNIX =		1;		/* local to host (pipes) */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int AF_LOCAL =	AF_UNIX;		/* backward compatibility */
// #endif	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int AF_INET =		2;		/* internetwork: UDP, TCP, etc. */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int AF_IMPLINK =	3;		/* arpanet imp addresses */
public static final int AF_PUP =		4;		/* pup protocols: e.g. BSP */
public static final int AF_CHAOS =	5;		/* mit CHAOS protocols */
public static final int AF_NS =		6;		/* XEROX NS protocols */
public static final int AF_ISO =		7;		/* ISO protocols */
public static final int AF_OSI =		AF_ISO;
public static final int AF_ECMA =		8;		/* European computer manufacturers */
public static final int AF_DATAKIT =	9;		/* datakit protocols */
public static final int AF_CCITT =	10;		/* CCITT protocols, X.25 etc */
public static final int AF_SNA =		11;		/* IBM SNA */
public static final int AF_DECnet =	12;		/* DECnet */
public static final int AF_DLI =		13;		/* DEC Direct data link interface */
public static final int AF_LAT =		14;		/* LAT */
public static final int AF_HYLINK =	15;		/* NSC Hyperchannel */
public static final int AF_APPLETALK =	16;		/* Apple Talk */
public static final int AF_ROUTE =	17;		/* Internal Routing Protocol */
public static final int AF_LINK =		18;		/* Link layer interface */
public static final int pseudo_AF_XTP =	19;		/* eXpress Transfer Protocol (no AF) */
public static final int AF_COIP =		20;		/* connection-oriented IP, aka ST II */
public static final int AF_CNT =		21;		/* Computer Network Technology */
public static final int pseudo_AF_RTIP =	22;		/* Help Identify RTIP packets */
public static final int AF_IPX =		23;		/* Novell Internet Protocol */
public static final int AF_SIP =		24;		/* Simple Internet Protocol */
public static final int pseudo_AF_PIP =	25;		/* Help Identify PIP packets */
/*define pseudo_AF_BLUE	26	   Identify packets for Blue Box - Not used */
public static final int AF_NDRV =		27;		/* Network Driver 'raw' access */
public static final int AF_ISDN =		28;		/* Integrated Services Digital Network*/
public static final int AF_E164 =		AF_ISDN;		/* CCITT E.164 recommendation */
public static final int pseudo_AF_KEY =	29;		/* Internal key-management function */
// #endif	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int AF_INET6 =	30;		/* IPv6 */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int AF_NATM =		31;		/* native ATM access */
public static final int AF_SYSTEM =	32;		/* Kernel event messages */
public static final int AF_NETBIOS =	33;		/* NetBIOS */
public static final int AF_PPP =		34;		/* PPP communication protocol */
public static final int pseudo_AF_HDRCMPLT = 35;		/* Used by BPF to not rewrite headers
					 * in interface output routine */
public static final int AF_RESERVED_36 =	36;		/* Reserved for internal usage */
public static final int AF_IEEE80211 =    37;              /* IEEE 802.11 protocol */
public static final int AF_UTUN =		38;
public static final int AF_MAX =		40;
// #endif	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * [XSI] Structure used by kernel to store most addresses.
 */
public static class sockaddr extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public sockaddr() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public sockaddr(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public sockaddr(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public sockaddr position(long position) {
        return (sockaddr)super.position(position);
    }

	public native @Cast("__uint8_t") byte sa_len(); public native sockaddr sa_len(byte sa_len);		/* total length */
	public native @Cast("sa_family_t") byte sa_family(); public native sockaddr sa_family(byte sa_family);	/* [XSI] address family */
	public native @Cast("char") byte sa_data(int i); public native sockaddr sa_data(int i, byte sa_data);
	@MemberGetter public native @Cast("char*") BytePointer sa_data();	/* [XSI] addr value (actually larger) */
}

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SOCK_MAXADDRLEN =	255;		/* longest possible addresses */

/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */
public static class sockproto extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public sockproto() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public sockproto(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public sockproto(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public sockproto position(long position) {
        return (sockproto)super.position(position);
    }

	public native @Cast("__uint16_t") short sp_family(); public native sockproto sp_family(short sp_family);		/* address family */
	public native @Cast("__uint16_t") short sp_protocol(); public native sockproto sp_protocol(short sp_protocol);		/* protocol */
}
// #endif	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE)*/

/*
 * RFC 2553: protocol-independent placeholder for socket addresses
 */
public static final int _SS_MAXSIZE =	128;
public static native @MemberGetter int _SS_ALIGNSIZE();
public static final int _SS_ALIGNSIZE = _SS_ALIGNSIZE();
public static native @MemberGetter int _SS_PAD1SIZE();
public static final int _SS_PAD1SIZE = _SS_PAD1SIZE();
public static native @MemberGetter int _SS_PAD2SIZE();
public static final int _SS_PAD2SIZE = _SS_PAD2SIZE();

/*
 * [XSI] sockaddr_storage
 */
public static class sockaddr_storage extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public sockaddr_storage() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public sockaddr_storage(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public sockaddr_storage(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public sockaddr_storage position(long position) {
        return (sockaddr_storage)super.position(position);
    }

	public native @Cast("__uint8_t") byte ss_len(); public native sockaddr_storage ss_len(byte ss_len);		/* address length */
	public native @Cast("sa_family_t") byte ss_family(); public native sockaddr_storage ss_family(byte ss_family);	/* [XSI] address family */
	public native @Cast("char") byte __ss_pad1(int i); public native sockaddr_storage __ss_pad1(int i, byte __ss_pad1);
	@MemberGetter public native @Cast("char*") BytePointer __ss_pad1();
	public native @Cast("__int64_t") long __ss_align(); public native sockaddr_storage __ss_align(long __ss_align);	/* force structure storage alignment */
	public native @Cast("char") byte __ss_pad2(int i); public native sockaddr_storage __ss_pad2(int i, byte __ss_pad2);
	@MemberGetter public native @Cast("char*") BytePointer __ss_pad2();
}


/*
 * Protocol families, same as address families for now.
 */
public static final int PF_UNSPEC =	AF_UNSPEC;
public static final int PF_LOCAL =	AF_LOCAL;
public static final int PF_UNIX =		PF_LOCAL;	/* backward compatibility */
public static final int PF_INET =		AF_INET;
public static final int PF_IMPLINK =	AF_IMPLINK;
public static final int PF_PUP =		AF_PUP;
public static final int PF_CHAOS =	AF_CHAOS;
public static final int PF_NS =		AF_NS;
public static final int PF_ISO =		AF_ISO;
public static final int PF_OSI =		AF_ISO;
public static final int PF_ECMA =		AF_ECMA;
public static final int PF_DATAKIT =	AF_DATAKIT;
public static final int PF_CCITT =	AF_CCITT;
public static final int PF_SNA =		AF_SNA;
public static final int PF_DECnet =	AF_DECnet;
public static final int PF_DLI =		AF_DLI;
public static final int PF_LAT =		AF_LAT;
public static final int PF_HYLINK =	AF_HYLINK;
public static final int PF_APPLETALK =	AF_APPLETALK;
public static final int PF_ROUTE =	AF_ROUTE;
public static final int PF_LINK =		AF_LINK;
public static final int PF_XTP =		pseudo_AF_XTP;	/* really just proto family, no AF */
public static final int PF_COIP =		AF_COIP;
public static final int PF_CNT =		AF_CNT;
public static final int PF_SIP =		AF_SIP;
public static final int PF_IPX =		AF_IPX;		/* same format as AF_NS */
public static final int PF_RTIP =		pseudo_AF_RTIP;	/* same format as AF_INET */
public static final int PF_PIP =		pseudo_AF_PIP;
public static final int PF_NDRV =		AF_NDRV;
public static final int PF_ISDN =		AF_ISDN;
public static final int PF_KEY =		pseudo_AF_KEY;
public static final int PF_INET6 =	AF_INET6;
public static final int PF_NATM =		AF_NATM;
public static final int PF_SYSTEM =	AF_SYSTEM;
public static final int PF_NETBIOS =	AF_NETBIOS;
public static final int PF_PPP =		AF_PPP;
public static final int PF_RESERVED_36 =  AF_RESERVED_36;
public static final int PF_UTUN =		AF_UTUN;
public static final int PF_MAX =		AF_MAX;

/*
 * These do not have socket-layer support:
 */
public static native @MemberGetter int PF_VLAN();
public static final int PF_VLAN = PF_VLAN();	/* 'vlan' */
public static native @MemberGetter int PF_BOND();
public static final int PF_BOND = PF_BOND();	/* 'bond' */

/*
 * Definitions for network related sysctl, CTL_NET.
 *
 * Second level is protocol family.
 * Third level is protocol number.
 *
 * Further levels are defined by the individual families below.
 */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int NET_MAXID =	AF_MAX;
// #endif /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */


// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/*
 * PF_ROUTE - Routing table
 *
 * Three additional levels are defined:
 *	Fourth: address family, 0 is wildcard
 *	Fifth: type of info, defined below
 *	Sixth: flag(s) to mask with for NET_RT_FLAGS
 */
public static final int NET_RT_DUMP =		1;	/* dump; may limit to a.f. */
public static final int NET_RT_FLAGS =		2;	/* by flags, e.g. RESOLVING */
public static final int NET_RT_IFLIST =		3;	/* survey interface list */
public static final int NET_RT_STAT =		4;	/* routing statistics */
public static final int NET_RT_TRASH =		5;	/* routes not in table but not freed */
public static final int NET_RT_IFLIST2 =		6;	/* interface list with addresses */
public static final int NET_RT_DUMP2 =		7;	/* dump; may limit to a.f. */
public static final int NET_RT_MAXID =		10;
// #endif /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */


/*
 * Maximum queue length specifiable by listen.
 */
public static final int SOMAXCONN =	128;

/*
 * [XSI] Message header for recvmsg and sendmsg calls.
 * Used value-result for recvmsg, value only for sendmsg.
 */
public static class msghdr extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public msghdr() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public msghdr(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public msghdr(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public msghdr position(long position) {
        return (msghdr)super.position(position);
    }

	public native Pointer msg_name(); public native msghdr msg_name(Pointer msg_name);	/* [XSI] optional address */
	public native @Cast("socklen_t") int msg_namelen(); public native msghdr msg_namelen(int msg_namelen);	/* [XSI] size of address */
	public native iovec msg_iov(); public native msghdr msg_iov(iovec msg_iov);	/* [XSI] scatter/gather array */
	public native int msg_iovlen(); public native msghdr msg_iovlen(int msg_iovlen);	/* [XSI] # elements in msg_iov */
	public native Pointer msg_control(); public native msghdr msg_control(Pointer msg_control);	/* [XSI] ancillary data, see below */
	public native @Cast("socklen_t") int msg_controllen(); public native msghdr msg_controllen(int msg_controllen);	/* [XSI] ancillary data buffer len */
	public native int msg_flags(); public native msghdr msg_flags(int msg_flags);	/* [XSI] flags on received message */
}



public static final int MSG_OOB =		0x1;		/* process out-of-band data */
public static final int MSG_PEEK =	0x2;		/* peek at incoming message */
public static final int MSG_DONTROUTE =	0x4;		/* send without using routing tables */
public static final int MSG_EOR =		0x8;		/* data completes record */
public static final int MSG_TRUNC =	0x10;		/* data discarded before delivery */
public static final int MSG_CTRUNC =	0x20;		/* control data lost before delivery */
public static final int MSG_WAITALL =	0x40;		/* wait for full request or error */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int MSG_DONTWAIT =	0x80;		/* this message should be nonblocking */
public static final int MSG_EOF =		0x100;		/* data completes connection */
// #ifdef __APPLE__
// #ifdef __APPLE_API_OBSOLETE
public static final int MSG_WAITSTREAM =  0x200;           /* wait up to full request.. may return partial */
// #endif
public static final int MSG_FLUSH =	0x400;		/* Start of 'hold' seq; dump so_temp */
public static final int MSG_HOLD =	0x800;		/* Hold frag in so_temp */
public static final int MSG_SEND =	0x1000;		/* Send the packet in so_temp */
public static final int MSG_HAVEMORE =	0x2000;		/* Data ready to be read */
public static final int MSG_RCVMORE =	0x4000;		/* Data remains in current pkt */
// #endif
public static final int MSG_NEEDSA =	0x10000;		/* Fail receive if socket address cannot be allocated */
// #endif	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * Header for ancillary data objects in msg_control buffer.
 * Used for additional information with/about a datagram
 * not expressible by flags.  The format is a sequence
 * of message elements headed by cmsghdr structures.
 */
public static class cmsghdr extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public cmsghdr() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public cmsghdr(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public cmsghdr(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public cmsghdr position(long position) {
        return (cmsghdr)super.position(position);
    }

	public native @Cast("socklen_t") int cmsg_len(); public native cmsghdr cmsg_len(int cmsg_len);	/* [XSI] data byte count, including hdr */
	public native int cmsg_level(); public native cmsghdr cmsg_level(int cmsg_level);	/* [XSI] originating protocol */
	public native int cmsg_type(); public native cmsghdr cmsg_type(int cmsg_type);	/* [XSI] protocol-specific type */
/* followed by	unsigned char  cmsg_data[]; */
}

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
// #ifndef __APPLE__
// #endif
// #endif	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/* given pointer to struct cmsghdr, return pointer to data */
// #define	CMSG_DATA(cmsg)		((unsigned char *)(cmsg) +
// 				 __DARWIN_ALIGN32(sizeof(struct cmsghdr)))

/*
 * RFC 2292 requires to check msg_controllen, in case that the kernel returns
 * an empty list for some reasons.
 */
// #define CMSG_FIRSTHDR(mhdr)
//         ((mhdr)->msg_controllen >= sizeof(struct cmsghdr) ?
//          (struct cmsghdr *)(mhdr)->msg_control :
//          (struct cmsghdr *)0L)


/* 
 * Given pointer to struct cmsghdr, return pointer to next cmsghdr
 * RFC 2292 says that CMSG_NXTHDR(mhdr, NULL) is equivalent to CMSG_FIRSTHDR(mhdr)
 */
// #define	CMSG_NXTHDR(mhdr, cmsg)
// 	((char *)(cmsg) == (char *)0L ? CMSG_FIRSTHDR(mhdr) :
// 	 ((((unsigned char *)(cmsg) +
// 	    __DARWIN_ALIGN32((__uint32_t)(cmsg)->cmsg_len) +
// 	    __DARWIN_ALIGN32(sizeof(struct cmsghdr))) >
// 	    ((unsigned char *)(mhdr)->msg_control +
// 	     (mhdr)->msg_controllen)) ?
// 	  (struct cmsghdr *)0L /* NULL */ :
// 	  (struct cmsghdr *)(void *)((unsigned char *)(cmsg) +
// 	 		    __DARWIN_ALIGN32((__uint32_t)(cmsg)->cmsg_len))))

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/* RFC 2292 additions */
// #define	CMSG_SPACE(l)		(__DARWIN_ALIGN32(sizeof(struct cmsghdr)) + __DARWIN_ALIGN32(l))
// #define	CMSG_LEN(l)		(__DARWIN_ALIGN32(sizeof(struct cmsghdr)) + (l))

// #endif	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/* "Socket"-level control message types: */
public static final int SCM_RIGHTS =			0x01;	/* access rights (array of int) */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SCM_TIMESTAMP =			0x02;	/* timestamp (struct timeval) */
public static final int SCM_CREDS =			0x03;	/* process creds (struct cmsgcred) */
public static final int SCM_TIMESTAMP_MONOTONIC =		0x04;	/* timestamp (uint64_t) */ 


// #endif	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * howto arguments for shutdown(2), specified by Posix.1g.
 */
public static final int SHUT_RD =		0;		/* shut down the reading side */
public static final int SHUT_WR =		1;		/* shut down the writing side */
public static final int SHUT_RDWR =	2;		/* shut down both sides */

// #if !defined(_POSIX_C_SOURCE)
/*
 * sendfile(2) header/trailer struct
 */
public static class sf_hdtr extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public sf_hdtr() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public sf_hdtr(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public sf_hdtr(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public sf_hdtr position(long position) {
        return (sf_hdtr)super.position(position);
    }

	public native iovec headers(); public native sf_hdtr headers(iovec headers);	/* pointer to an array of header struct iovec's */
	public native int hdr_cnt(); public native sf_hdtr hdr_cnt(int hdr_cnt);		/* number of header iovec's */
	public native iovec trailers(); public native sf_hdtr trailers(iovec trailers);	/* pointer to an array of trailer struct iovec's */
	public native int trl_cnt(); public native sf_hdtr trl_cnt(int trl_cnt);		/* number of trailer iovec's */
}


// #endif	/* !_POSIX_C_SOURCE */


public static native int accept(int arg0, sockaddr arg1, @Cast("socklen_t*") IntPointer arg2);
public static native int accept(int arg0, sockaddr arg1, @Cast("socklen_t*") IntBuffer arg2);
public static native int accept(int arg0, sockaddr arg1, @Cast("socklen_t*") int[] arg2);
public static native int bind(int arg0, @Const sockaddr arg1, @Cast("socklen_t") int arg2);
public static native int connect(int arg0, @Const sockaddr arg1, @Cast("socklen_t") int arg2);
public static native int getpeername(int arg0, sockaddr arg1, @Cast("socklen_t*") IntPointer arg2);
public static native int getpeername(int arg0, sockaddr arg1, @Cast("socklen_t*") IntBuffer arg2);
public static native int getpeername(int arg0, sockaddr arg1, @Cast("socklen_t*") int[] arg2);
public static native int getsockname(int arg0, sockaddr arg1, @Cast("socklen_t*") IntPointer arg2);
public static native int getsockname(int arg0, sockaddr arg1, @Cast("socklen_t*") IntBuffer arg2);
public static native int getsockname(int arg0, sockaddr arg1, @Cast("socklen_t*") int[] arg2);
public static native int getsockopt(int arg0, int arg1, int arg2, Pointer arg3, @Cast("socklen_t*") IntPointer arg4);
public static native int getsockopt(int arg0, int arg1, int arg2, Pointer arg3, @Cast("socklen_t*") IntBuffer arg4);
public static native int getsockopt(int arg0, int arg1, int arg2, Pointer arg3, @Cast("socklen_t*") int[] arg4);
public static native int listen(int arg0, int arg1);
public static native @Cast("ssize_t") long recv(int arg0, Pointer arg1, @Cast("size_t") long arg2, int arg3);
public static native @Cast("ssize_t") long recvfrom(int arg0, Pointer arg1, @Cast("size_t") long arg2, int arg3, sockaddr arg4,
		@Cast("socklen_t*") IntPointer arg5);
public static native @Cast("ssize_t") long recvfrom(int arg0, Pointer arg1, @Cast("size_t") long arg2, int arg3, sockaddr arg4,
		@Cast("socklen_t*") IntBuffer arg5);
public static native @Cast("ssize_t") long recvfrom(int arg0, Pointer arg1, @Cast("size_t") long arg2, int arg3, sockaddr arg4,
		@Cast("socklen_t*") int[] arg5);
public static native @Cast("ssize_t") long recvmsg(int arg0, msghdr arg1, int arg2);
public static native @Cast("ssize_t") long send(int arg0, @Const Pointer arg1, @Cast("size_t") long arg2, int arg3);
public static native @Cast("ssize_t") long sendmsg(int arg0, @Const msghdr arg1, int arg2);
public static native @Cast("ssize_t") long sendto(int arg0, @Const Pointer arg1, @Cast("size_t") long arg2,
		int arg3, @Const sockaddr arg4, @Cast("socklen_t") int arg5);
public static native int setsockopt(int arg0, int arg1, int arg2, @Const Pointer arg3, @Cast("socklen_t") int arg4);
public static native int shutdown(int arg0, int arg1);
public static native int sockatmark(int arg0);
public static native int socket(int arg0, int arg1, int arg2);
public static native int socketpair(int arg0, int arg1, int arg2, IntPointer arg3);
public static native int socketpair(int arg0, int arg1, int arg2, IntBuffer arg3);
public static native int socketpair(int arg0, int arg1, int arg2, int[] arg3);

// #if !defined(_POSIX_C_SOURCE)
public static native int sendfile(int arg0, int arg1, @Cast("off_t") long arg2, @Cast("off_t*") LongPointer arg3, sf_hdtr arg4, int arg5);
public static native int sendfile(int arg0, int arg1, @Cast("off_t") long arg2, @Cast("off_t*") LongBuffer arg3, sf_hdtr arg4, int arg5);
public static native int sendfile(int arg0, int arg1, @Cast("off_t") long arg2, @Cast("off_t*") long[] arg3, sf_hdtr arg4, int arg5);
// #endif	/* !_POSIX_C_SOURCE */

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static native void pfctlinput(int arg0, sockaddr arg1);
// #endif	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
// #endif /* !_SYS_SOCKET_H_ */


// Parsed from sys/errno.h

/*
 * Copyright (c) 2000-2012 Apple, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)errno.h	8.5 (Berkeley) 1/21/94
 */

// #ifndef	_SYS_ERRNO_H_
// #define	_SYS_ERRNO_H_

// #include <sys/cdefs.h>


// #if defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1
// #include <sys/_types/_errno_t.h>
// #endif

public static native IntPointer __error();
public static native @MemberGetter int errno();
public static final int errno = errno();
/*
 * Error codes
 */

public static final int EPERM =		1;		/* Operation not permitted */
public static final int ENOENT =		2;		/* No such file or directory */
public static final int ESRCH =		3;		/* No such process */
public static final int EINTR =		4;		/* Interrupted system call */
public static final int EIO =		5;		/* Input/output error */
public static final int ENXIO =		6;		/* Device not configured */
public static final int E2BIG =		7;		/* Argument list too long */
public static final int ENOEXEC =		8;		/* Exec format error */
public static final int EBADF =		9;		/* Bad file descriptor */
public static final int ECHILD =		10;		/* No child processes */
public static final int EDEADLK =		11;		/* Resource deadlock avoided */
					/* 11 was EAGAIN */
public static final int ENOMEM =		12;		/* Cannot allocate memory */
public static final int EACCES =		13;		/* Permission denied */
public static final int EFAULT =		14;		/* Bad address */
// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static final int ENOTBLK =		15;		/* Block device required */
// #endif
public static final int EBUSY =		16;		/* Device / Resource busy */
public static final int EEXIST =		17;		/* File exists */
public static final int EXDEV =		18;		/* Cross-device link */
public static final int ENODEV =		19;		/* Operation not supported by device */
public static final int ENOTDIR =		20;		/* Not a directory */
public static final int EISDIR =		21;		/* Is a directory */
public static final int EINVAL =		22;		/* Invalid argument */
public static final int ENFILE =		23;		/* Too many open files in system */
public static final int EMFILE =		24;		/* Too many open files */
public static final int ENOTTY =		25;		/* Inappropriate ioctl for device */
public static final int ETXTBSY =		26;		/* Text file busy */
public static final int EFBIG =		27;		/* File too large */
public static final int ENOSPC =		28;		/* No space left on device */
public static final int ESPIPE =		29;		/* Illegal seek */
public static final int EROFS =		30;		/* Read-only file system */
public static final int EMLINK =		31;		/* Too many links */
public static final int EPIPE =		32;		/* Broken pipe */

/* math software */
public static final int EDOM =		33;		/* Numerical argument out of domain */
public static final int ERANGE =		34;		/* Result too large */

/* non-blocking and interrupt i/o */
public static final int EAGAIN =		35;		/* Resource temporarily unavailable */
public static final int EWOULDBLOCK =	EAGAIN;		/* Operation would block */
public static final int EINPROGRESS =	36;		/* Operation now in progress */
public static final int EALREADY =	37;		/* Operation already in progress */

/* ipc/network software -- argument errors */
public static final int ENOTSOCK =	38;		/* Socket operation on non-socket */
public static final int EDESTADDRREQ =	39;		/* Destination address required */
public static final int EMSGSIZE =	40;		/* Message too long */
public static final int EPROTOTYPE =	41;		/* Protocol wrong type for socket */
public static final int ENOPROTOOPT =	42;		/* Protocol not available */
public static final int EPROTONOSUPPORT =	43;		/* Protocol not supported */
// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static final int ESOCKTNOSUPPORT =	44;		/* Socket type not supported */
// #endif
public static final int ENOTSUP =		45;		/* Operation not supported */
// #if !__DARWIN_UNIX03 && !defined(KERNEL)
/*
 * This is the same for binary and source copmpatability, unless compiling
 * the kernel itself, or compiling __DARWIN_UNIX03; if compiling for the
 * kernel, the correct value will be returned.  If compiling non-POSIX
 * source, the kernel return value will be converted by a stub in libc, and
 * if compiling source with __DARWIN_UNIX03, the conversion in libc is not
 * done, and the caller gets the expected (discrete) value.
 */
public static final int EOPNOTSUPP =	 ENOTSUP;	/* Operation not supported on socket */
// #endif /* !__DARWIN_UNIX03 && !KERNEL */

// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static final int EPFNOSUPPORT =	46;		/* Protocol family not supported */
// #endif
public static final int EAFNOSUPPORT =	47;		/* Address family not supported by protocol family */
public static final int EADDRINUSE =	48;		/* Address already in use */
public static final int EADDRNOTAVAIL =	49;		/* Can't assign requested address */

/* ipc/network software -- operational errors */
public static final int ENETDOWN =	50;		/* Network is down */
public static final int ENETUNREACH =	51;		/* Network is unreachable */
public static final int ENETRESET =	52;		/* Network dropped connection on reset */
public static final int ECONNABORTED =	53;		/* Software caused connection abort */
public static final int ECONNRESET =	54;		/* Connection reset by peer */
public static final int ENOBUFS =		55;		/* No buffer space available */
public static final int EISCONN =		56;		/* Socket is already connected */
public static final int ENOTCONN =	57;		/* Socket is not connected */
// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static final int ESHUTDOWN =	58;		/* Can't send after socket shutdown */
public static final int ETOOMANYREFS =	59;		/* Too many references: can't splice */
// #endif
public static final int ETIMEDOUT =	60;		/* Operation timed out */
public static final int ECONNREFUSED =	61;		/* Connection refused */

public static final int ELOOP =		62;		/* Too many levels of symbolic links */
public static final int ENAMETOOLONG =	63;		/* File name too long */

/* should be rearranged */
// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static final int EHOSTDOWN =	64;		/* Host is down */
// #endif
public static final int EHOSTUNREACH =	65;		/* No route to host */
public static final int ENOTEMPTY =	66;		/* Directory not empty */

/* quotas & mush */
// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static final int EPROCLIM =	67;		/* Too many processes */
public static final int EUSERS =		68;		/* Too many users */
// #endif
public static final int EDQUOT =		69;		/* Disc quota exceeded */

/* Network File System */
public static final int ESTALE =		70;		/* Stale NFS file handle */
// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static final int EREMOTE =		71;		/* Too many levels of remote in path */
public static final int EBADRPC =		72;		/* RPC struct is bad */
public static final int ERPCMISMATCH =	73;		/* RPC version wrong */
public static final int EPROGUNAVAIL =	74;		/* RPC prog. not avail */
public static final int EPROGMISMATCH =	75;		/* Program version wrong */
public static final int EPROCUNAVAIL =	76;		/* Bad procedure for program */
// #endif

public static final int ENOLCK =		77;		/* No locks available */
public static final int ENOSYS =		78;		/* Function not implemented */

// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static final int EFTYPE =		79;		/* Inappropriate file type or format */
public static final int EAUTH =		80;		/* Authentication error */
public static final int ENEEDAUTH =	81;		/* Need authenticator */

/* Intelligent device errors */
public static final int EPWROFF =		82;	/* Device power is off */
public static final int EDEVERR =		83;	/* Device error, e.g. paper out */
// #endif

public static final int EOVERFLOW =	84;		/* Value too large to be stored in data type */

/* Program loading errors */
// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static final int EBADEXEC =	85;	/* Bad executable */
public static final int EBADARCH =	86;	/* Bad CPU type in executable */
public static final int ESHLIBVERS =	87;	/* Shared library version mismatch */
public static final int EBADMACHO =	88;	/* Malformed Macho file */
// #endif

public static final int ECANCELED =	89;		/* Operation canceled */

public static final int EIDRM =		90;		/* Identifier removed */
public static final int ENOMSG =		91;		/* No message of desired type */   
public static final int EILSEQ =		92;		/* Illegal byte sequence */
// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static final int ENOATTR =		93;		/* Attribute not found */
// #endif

public static final int EBADMSG =		94;		/* Bad message */
public static final int EMULTIHOP =	95;		/* Reserved */
public static final int ENODATA =		96;		/* No message available on STREAM */
public static final int ENOLINK =		97;		/* Reserved */
public static final int ENOSR =		98;		/* No STREAM resources */
public static final int ENOSTR =		99;		/* Not a STREAM */
public static final int EPROTO =		100;		/* Protocol error */
public static final int ETIME =		101;		/* STREAM ioctl timeout */

// #if __DARWIN_UNIX03 || defined(KERNEL)
/* This value is only discrete when compiling __DARWIN_UNIX03, or KERNEL */		/* Operation not supported on socket */
// #endif /* __DARWIN_UNIX03 || KERNEL */

public static final int ENOPOLICY =	103;		/* No such policy registered */

// #if __DARWIN_C_LEVEL >= 200809L
public static final int ENOTRECOVERABLE = 104;		/* State not recoverable */
public static final int EOWNERDEAD =      105;		/* Previous owner died */
// #endif

// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static final int EQFULL =		106;		/* Interface output queue is full */
public static final int ELAST =		106;		/* Must be equal largest errno */
// #endif

// #endif /* _SYS_ERRNO_H_ */


// Parsed from string.h

/*
 * Copyright (c) 2000, 2007, 2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)string.h	8.1 (Berkeley) 6/2/93
 */

// #ifndef _STRING_H_
// #define	_STRING_H_

// #include <_types.h>
// #include <sys/cdefs.h>
// #include <Availability.h>
// #include <sys/_types/_size_t.h>
// #include <sys/_types/_null.h>

/* ANSI-C */

public static native Pointer memchr(@Const Pointer arg0, int arg1, @Cast("size_t") long arg2);
public static native int memcmp(@Const Pointer arg0, @Const Pointer arg1, @Cast("size_t") long arg2);
public static native Pointer memcpy(Pointer arg0, @Const Pointer arg1, @Cast("size_t") long arg2);
public static native Pointer memmove(Pointer arg0, @Const Pointer arg1, @Cast("size_t") long arg2);
public static native Pointer memset(Pointer arg0, int arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") BytePointer strcat(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") ByteBuffer strcat(@Cast("char*") ByteBuffer arg0, String arg1);
public static native @Cast("char*") byte[] strcat(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") BytePointer strcat(@Cast("char*") BytePointer arg0, String arg1);
public static native @Cast("char*") ByteBuffer strcat(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") byte[] strcat(@Cast("char*") byte[] arg0, String arg1);
public static native @Cast("char*") BytePointer strchr(@Cast("const char*") BytePointer arg0, int arg1);
public static native @Cast("char*") ByteBuffer strchr(String arg0, int arg1);
public static native int strcmp(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native int strcmp(String arg0, String arg1);
public static native int strcoll(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native int strcoll(String arg0, String arg1);
public static native @Cast("char*") BytePointer strcpy(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") ByteBuffer strcpy(@Cast("char*") ByteBuffer arg0, String arg1);
public static native @Cast("char*") byte[] strcpy(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") BytePointer strcpy(@Cast("char*") BytePointer arg0, String arg1);
public static native @Cast("char*") ByteBuffer strcpy(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") byte[] strcpy(@Cast("char*") byte[] arg0, String arg1);
public static native @Cast("size_t") long strcspn(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("size_t") long strcspn(String arg0, String arg1);
public static native @Cast("char*") BytePointer strerror(int arg0);
public static native @Cast("size_t") long strlen(@Cast("const char*") BytePointer arg0);
public static native @Cast("size_t") long strlen(String arg0);
public static native @Cast("char*") BytePointer strncat(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") ByteBuffer strncat(@Cast("char*") ByteBuffer arg0, String arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") byte[] strncat(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") BytePointer strncat(@Cast("char*") BytePointer arg0, String arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") ByteBuffer strncat(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") byte[] strncat(@Cast("char*") byte[] arg0, String arg1, @Cast("size_t") long arg2);
public static native int strncmp(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native int strncmp(String arg0, String arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") BytePointer strncpy(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") ByteBuffer strncpy(@Cast("char*") ByteBuffer arg0, String arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") byte[] strncpy(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") BytePointer strncpy(@Cast("char*") BytePointer arg0, String arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") ByteBuffer strncpy(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") byte[] strncpy(@Cast("char*") byte[] arg0, String arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") BytePointer strpbrk(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") ByteBuffer strpbrk(String arg0, String arg1);
public static native @Cast("char*") BytePointer strrchr(@Cast("const char*") BytePointer arg0, int arg1);
public static native @Cast("char*") ByteBuffer strrchr(String arg0, int arg1);
public static native @Cast("size_t") long strspn(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("size_t") long strspn(String arg0, String arg1);
public static native @Cast("char*") BytePointer strstr(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") ByteBuffer strstr(String arg0, String arg1);
public static native @Cast("char*") BytePointer strtok(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") ByteBuffer strtok(@Cast("char*") ByteBuffer arg0, String arg1);
public static native @Cast("char*") byte[] strtok(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") BytePointer strtok(@Cast("char*") BytePointer arg0, String arg1);
public static native @Cast("char*") ByteBuffer strtok(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") byte[] strtok(@Cast("char*") byte[] arg0, String arg1);
public static native @Cast("size_t") long strxfrm(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long strxfrm(@Cast("char*") ByteBuffer arg0, String arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long strxfrm(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long strxfrm(@Cast("char*") BytePointer arg0, String arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long strxfrm(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long strxfrm(@Cast("char*") byte[] arg0, String arg1, @Cast("size_t") long arg2);
/* Additional functionality provided by:
 * POSIX.1c-1995,
 * POSIX.1i-1995,
 * and the omnibus ISO/IEC 9945-1: 1996
 */

// #if __DARWIN_C_LEVEL >= 199506L
public static native @Cast("char*") BytePointer strtok_r(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("char**") PointerPointer arg2);
public static native @Cast("char*") BytePointer strtok_r(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("char**") @ByPtrPtr BytePointer arg2);
public static native @Cast("char*") ByteBuffer strtok_r(@Cast("char*") ByteBuffer arg0, String arg1, @Cast("char**") @ByPtrPtr ByteBuffer arg2);
public static native @Cast("char*") byte[] strtok_r(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1, @Cast("char**") @ByPtrPtr byte[] arg2);
public static native @Cast("char*") BytePointer strtok_r(@Cast("char*") BytePointer arg0, String arg1, @Cast("char**") @ByPtrPtr BytePointer arg2);
public static native @Cast("char*") ByteBuffer strtok_r(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1, @Cast("char**") @ByPtrPtr ByteBuffer arg2);
public static native @Cast("char*") byte[] strtok_r(@Cast("char*") byte[] arg0, String arg1, @Cast("char**") @ByPtrPtr byte[] arg2);
// #endif /* __DARWIN_C_LEVEL >= 199506L */



/* Additional functionality provided by:
 * POSIX.1-2001
 */

// #if __DARWIN_C_LEVEL >= 200112L
public static native int strerror_r(int arg0, @Cast("char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native int strerror_r(int arg0, @Cast("char*") ByteBuffer arg1, @Cast("size_t") long arg2);
public static native int strerror_r(int arg0, @Cast("char*") byte[] arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") BytePointer strdup(@Cast("const char*") BytePointer arg0);
public static native @Cast("char*") ByteBuffer strdup(String arg0);
public static native Pointer memccpy(Pointer arg0, @Const Pointer arg1, int arg2, @Cast("size_t") long arg3);
// #endif /* __DARWIN_C_LEVEL >= 200112L */



/* Additional functionality provided by:
 * POSIX.1-2008
 */

// #if __DARWIN_C_LEVEL >= 200809L
public static native @Cast("char*") BytePointer stpcpy(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") ByteBuffer stpcpy(@Cast("char*") ByteBuffer arg0, String arg1);
public static native @Cast("char*") byte[] stpcpy(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") BytePointer stpcpy(@Cast("char*") BytePointer arg0, String arg1);
public static native @Cast("char*") ByteBuffer stpcpy(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") byte[] stpcpy(@Cast("char*") byte[] arg0, String arg1);
public static native @Cast("char*") BytePointer stpncpy(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") ByteBuffer stpncpy(@Cast("char*") ByteBuffer arg0, String arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") byte[] stpncpy(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") BytePointer stpncpy(@Cast("char*") BytePointer arg0, String arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") ByteBuffer stpncpy(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") byte[] stpncpy(@Cast("char*") byte[] arg0, String arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") BytePointer strndup(@Cast("const char*") BytePointer arg0, @Cast("size_t") long arg1);
public static native @Cast("char*") ByteBuffer strndup(String arg0, @Cast("size_t") long arg1);
public static native @Cast("size_t") long strnlen(@Cast("const char*") BytePointer arg0, @Cast("size_t") long arg1);
public static native @Cast("size_t") long strnlen(String arg0, @Cast("size_t") long arg1);
public static native @Cast("char*") BytePointer strsignal(int sig);
// #endif /* __DARWIN_C_LEVEL >= 200809L */

/* C11 Annex K */

// #if defined(__STDC_WANT_LIB_EXT1__) && __STDC_WANT_LIB_EXT1__ >= 1
// #include <sys/_types/_rsize_t.h>
// #include <sys/_types/_errno_t.h>

public static native @Cast("errno_t") int memset_s(Pointer arg0, @Cast("rsize_t") long arg1, int arg2, @Cast("rsize_t") long arg3);
// #endif

/* Darwin extensions */

// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
// #include <sys/_types/_ssize_t.h>

public static native Pointer memmem(@Const Pointer arg0, @Cast("size_t") long arg1, @Const Pointer arg2, @Cast("size_t") long arg3);
public static native void memset_pattern4(Pointer arg0, @Const Pointer arg1, @Cast("size_t") long arg2);
public static native void memset_pattern8(Pointer arg0, @Const Pointer arg1, @Cast("size_t") long arg2);
public static native void memset_pattern16(Pointer arg0, @Const Pointer arg1, @Cast("size_t") long arg2);

public static native @Cast("char*") BytePointer strcasestr(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") ByteBuffer strcasestr(String arg0, String arg1);
public static native @Cast("char*") BytePointer strnstr(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") ByteBuffer strnstr(String arg0, String arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long strlcat(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long strlcat(@Cast("char*") ByteBuffer arg0, String arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long strlcat(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long strlcat(@Cast("char*") BytePointer arg0, String arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long strlcat(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long strlcat(@Cast("char*") byte[] arg0, String arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long strlcpy(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long strlcpy(@Cast("char*") ByteBuffer arg0, String arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long strlcpy(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long strlcpy(@Cast("char*") BytePointer arg0, String arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long strlcpy(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long strlcpy(@Cast("char*") byte[] arg0, String arg1, @Cast("size_t") long arg2);
public static native void strmode(int arg0, @Cast("char*") BytePointer arg1);
public static native void strmode(int arg0, @Cast("char*") ByteBuffer arg1);
public static native void strmode(int arg0, @Cast("char*") byte[] arg1);
public static native @Cast("char*") BytePointer strsep(@Cast("char**") PointerPointer arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") BytePointer strsep(@Cast("char**") @ByPtrPtr BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") ByteBuffer strsep(@Cast("char**") @ByPtrPtr ByteBuffer arg0, String arg1);
public static native @Cast("char*") byte[] strsep(@Cast("char**") @ByPtrPtr byte[] arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") BytePointer strsep(@Cast("char**") @ByPtrPtr BytePointer arg0, String arg1);
public static native @Cast("char*") ByteBuffer strsep(@Cast("char**") @ByPtrPtr ByteBuffer arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") byte[] strsep(@Cast("char**") @ByPtrPtr byte[] arg0, String arg1);

/* SUS places swab() in unistd.h.  It is listed here for source compatibility */
public static native void swab(@Const Pointer arg0, Pointer arg1, @Cast("ssize_t") long arg2);
/* Some functions historically defined in string.h were placed in strings.h
 * by SUS.  We are using "strings.h" instead of <strings.h> to avoid an issue
 * where /Developer/Headers/FlatCarbon/Strings.h could be included instead on
 * case-insensitive file systems.
 */
// #include "strings.h"
// #endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */


// #ifdef _USE_EXTENDED_LOCALES_
// #endif /* _USE_EXTENDED_LOCALES_ */

// #if defined (__GNUC__) && _FORTIFY_SOURCE > 0 && !defined (__cplusplus)
/* Security checking functions.  */
// #include <secure/_string.h>
// #endif

// #endif /* _STRING_H_ */


// Parsed from stdlib.h

/*
 * Copyright (c) 2000, 2002 - 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
 */

// #ifndef _STDLIB_H_
// #define _STDLIB_H_

// #include <Availability.h>

// #include <_types.h>
// #if !defined(_ANSI_SOURCE)
// #include <sys/wait.h>
// #if (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
// #include <alloca.h>
// #endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
// #endif /* !_ANSI_SOURCE */

/* DO NOT REMOVE THIS COMMENT: fixincludes needs to see:
 * _GCC_SIZE_T */
// #include <sys/_types/_size_t.h>

// #if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
// #include <sys/_types/_ct_rune_t.h>
// #include <sys/_types/_rune_t.h>
// #endif	/* !_ANSI_SOURCE && (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

// #include <sys/_types/_wchar_t.h>

public static class div_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public div_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public div_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public div_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public div_t position(long position) {
        return (div_t)super.position(position);
    }

	public native int quot(); public native div_t quot(int quot);		/* quotient */
	public native int rem(); public native div_t rem(int rem);		/* remainder */
}

public static class ldiv_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public ldiv_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ldiv_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ldiv_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public ldiv_t position(long position) {
        return (ldiv_t)super.position(position);
    }

	public native long quot(); public native ldiv_t quot(long quot);		/* quotient */
	public native long rem(); public native ldiv_t rem(long rem);		/* remainder */
}

// #if !__DARWIN_NO_LONG_LONG
public static class lldiv_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public lldiv_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public lldiv_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public lldiv_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public lldiv_t position(long position) {
        return (lldiv_t)super.position(position);
    }

	public native long quot(); public native lldiv_t quot(long quot);
	public native long rem(); public native lldiv_t rem(long rem);
}
// #endif /* !__DARWIN_NO_LONG_LONG */

// #include <sys/_types/_null.h>

public static final int EXIT_FAILURE =	1;
public static final int EXIT_SUCCESS =	0;

public static final int RAND_MAX =	0x7fffffff;

// #ifdef _USE_EXTENDED_LOCALES_
// #endif /* _USE_EXTENDED_LOCALES_ */

// #ifndef MB_CUR_MAX
// #endif /* MB_CUR_MAX */

// #if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
//     && defined(_USE_EXTENDED_LOCALES_) && !defined(MB_CUR_MAX_L)
// #define	MB_CUR_MAX_L(x)	(___mb_cur_max_l(x))
// #endif

public static native void abort();
public static native int abs(int arg0);
public static class Arg0 extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Arg0(Pointer p) { super(p); }
    protected Arg0() { allocate(); }
    private native void allocate();
    public native void call();
}
public static native int atexit(Arg0 arg0);
public static native double atof(@Cast("const char*") BytePointer arg0);
public static native double atof(String arg0);
public static native int atoi(@Cast("const char*") BytePointer arg0);
public static native int atoi(String arg0);
public static native long atol(@Cast("const char*") BytePointer arg0);
public static native long atol(String arg0);
// #if !__DARWIN_NO_LONG_LONG
public static native long atoll(@Cast("const char*") BytePointer arg0);
public static native long atoll(String arg0);
// #endif /* !__DARWIN_NO_LONG_LONG */
public static class Arg4_Pointer_Pointer extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Arg4_Pointer_Pointer(Pointer p) { super(p); }
    protected Arg4_Pointer_Pointer() { allocate(); }
    private native void allocate();
    public native int call(@Const Pointer arg0, @Const Pointer arg1);
}
public static native Pointer bsearch(@Const Pointer arg0, @Const Pointer arg1, @Cast("size_t") long arg2,
	    @Cast("size_t") long arg3, Arg4_Pointer_Pointer arg4);
public static native Pointer calloc(@Cast("size_t") long arg0, @Cast("size_t") long arg1);
public static native @ByVal div_t div(int arg0, int arg1);
public static native void exit(int arg0);
public static native void free(Pointer arg0);
public static native @Cast("char*") BytePointer getenv(@Cast("const char*") BytePointer arg0);
public static native @Cast("char*") ByteBuffer getenv(String arg0);
public static native long labs(long arg0);
public static native @ByVal ldiv_t ldiv(long arg0, long arg1);
// #if !__DARWIN_NO_LONG_LONG
public static native long llabs(long arg0);
public static native @ByVal lldiv_t lldiv(long arg0, long arg1);
// #endif /* !__DARWIN_NO_LONG_LONG */
public static native Pointer malloc(@Cast("size_t") long arg0);
public static native int mblen(@Cast("const char*") BytePointer arg0, @Cast("size_t") long arg1);
public static native int mblen(String arg0, @Cast("size_t") long arg1);
public static native @Cast("size_t") long mbstowcs(@Cast("wchar_t*") CharPointer arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long mbstowcs(@Cast("wchar_t*") CharPointer arg0, String arg1, @Cast("size_t") long arg2);
public static native int mbtowc(@Cast("wchar_t*") CharPointer arg0, @Cast("const char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native int mbtowc(@Cast("wchar_t*") CharPointer arg0, String arg1, @Cast("size_t") long arg2);
public static native int posix_memalign(@Cast("void**") PointerPointer arg0, @Cast("size_t") long arg1, @Cast("size_t") long arg2);
public static native int posix_memalign(@Cast("void**") @ByPtrPtr Pointer arg0, @Cast("size_t") long arg1, @Cast("size_t") long arg2);
public static class Arg3_Pointer_Pointer extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Arg3_Pointer_Pointer(Pointer p) { super(p); }
    protected Arg3_Pointer_Pointer() { allocate(); }
    private native void allocate();
    public native int call(@Const Pointer arg0, @Const Pointer arg1);
}
public static native void qsort(Pointer arg0, @Cast("size_t") long arg1, @Cast("size_t") long arg2,
	    Arg3_Pointer_Pointer arg3);
public static native int rand();
public static native Pointer realloc(Pointer arg0, @Cast("size_t") long arg1);
public static native void srand(@Cast("unsigned") int arg0);
public static native double strtod(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1);
public static native double strtod(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1);
public static native double strtod(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1);
public static native double strtod(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1);
public static native double strtod(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1);
public static native double strtod(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1);
public static native double strtod(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1);
public static native float strtof(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1);
public static native float strtof(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1);
public static native float strtof(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1);
public static native float strtof(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1);
public static native float strtof(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1);
public static native float strtof(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1);
public static native float strtof(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1);
public static native long strtol(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1, int arg2);
public static native long strtol(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
public static native long strtol(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
public static native long strtol(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
public static native long strtol(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
public static native long strtol(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
public static native long strtol(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
public static native @Cast("long double") double strtold(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1);
public static native @Cast("long double") double strtold(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1);
public static native @Cast("long double") double strtold(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1);
public static native @Cast("long double") double strtold(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1);
public static native @Cast("long double") double strtold(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1);
public static native @Cast("long double") double strtold(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1);
public static native @Cast("long double") double strtold(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1);
// #if !__DARWIN_NO_LONG_LONG
public static native long strtoll(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1, int arg2);
public static native long strtoll(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
public static native long strtoll(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
public static native long strtoll(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
public static native long strtoll(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
public static native long strtoll(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
public static native long strtoll(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
// #endif /* !__DARWIN_NO_LONG_LONG */
public static native @Cast("unsigned long") long strtoul(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1, int arg2);
public static native @Cast("unsigned long") long strtoul(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
public static native @Cast("unsigned long") long strtoul(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
public static native @Cast("unsigned long") long strtoul(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
public static native @Cast("unsigned long") long strtoul(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
public static native @Cast("unsigned long") long strtoul(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
public static native @Cast("unsigned long") long strtoul(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
// #if !__DARWIN_NO_LONG_LONG
public static native @Cast("unsigned long long") long strtoull(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1, int arg2);
public static native @Cast("unsigned long long") long strtoull(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
public static native @Cast("unsigned long long") long strtoull(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
public static native @Cast("unsigned long long") long strtoull(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
public static native @Cast("unsigned long long") long strtoull(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
public static native @Cast("unsigned long long") long strtoull(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
public static native @Cast("unsigned long long") long strtoull(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
// #endif /* !__DARWIN_NO_LONG_LONG */
public static native int system(@Cast("const char*") BytePointer arg0);
public static native int system(String arg0);
public static native @Cast("size_t") long wcstombs(@Cast("char*") BytePointer arg0, @Cast("const wchar_t*") CharPointer arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long wcstombs(@Cast("char*") ByteBuffer arg0, @Cast("const wchar_t*") CharPointer arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long wcstombs(@Cast("char*") byte[] arg0, @Cast("const wchar_t*") CharPointer arg1, @Cast("size_t") long arg2);
public static native int wctomb(@Cast("char*") BytePointer arg0, @Cast("wchar_t") char arg1);
public static native int wctomb(@Cast("char*") ByteBuffer arg0, @Cast("wchar_t") char arg1);
public static native int wctomb(@Cast("char*") byte[] arg0, @Cast("wchar_t") char arg1);

// #ifndef _ANSI_SOURCE
public static native void _Exit(int arg0);
public static native long a64l(@Cast("const char*") BytePointer arg0);
public static native long a64l(String arg0);
public static native double drand48();
public static native @Cast("char*") BytePointer ecvt(double arg0, int arg1, IntPointer arg2, IntPointer arg3);
public static native @Cast("char*") ByteBuffer ecvt(double arg0, int arg1, IntBuffer arg2, IntBuffer arg3);
public static native @Cast("char*") byte[] ecvt(double arg0, int arg1, int[] arg2, int[] arg3); /* LEGACY */
public static native double erand48(@Cast("unsigned short*") ShortPointer arg0);
public static native double erand48(@Cast("unsigned short*") ShortBuffer arg0);
public static native double erand48(@Cast("unsigned short*") short[] arg0); 
public static native @Cast("char*") BytePointer fcvt(double arg0, int arg1, IntPointer arg2, IntPointer arg3);
public static native @Cast("char*") ByteBuffer fcvt(double arg0, int arg1, IntBuffer arg2, IntBuffer arg3);
public static native @Cast("char*") byte[] fcvt(double arg0, int arg1, int[] arg2, int[] arg3); /* LEGACY */
public static native @Cast("char*") BytePointer gcvt(double arg0, int arg1, @Cast("char*") BytePointer arg2);
public static native @Cast("char*") ByteBuffer gcvt(double arg0, int arg1, @Cast("char*") ByteBuffer arg2);
public static native @Cast("char*") byte[] gcvt(double arg0, int arg1, @Cast("char*") byte[] arg2); /* LEGACY */
public static native int getsubopt(@Cast("char**") PointerPointer arg0, @Cast("char*const*") PointerPointer arg1, @Cast("char**") PointerPointer arg2);
public static native int getsubopt(@Cast("char**") @ByPtrPtr BytePointer arg0, @Cast("char*const*") @ByPtrPtr BytePointer arg1, @Cast("char**") @ByPtrPtr BytePointer arg2);
public static native int getsubopt(@Cast("char**") @ByPtrPtr ByteBuffer arg0, @Cast("char*const*") @ByPtrPtr ByteBuffer arg1, @Cast("char**") @ByPtrPtr ByteBuffer arg2);
public static native int getsubopt(@Cast("char**") @ByPtrPtr byte[] arg0, @Cast("char*const*") @ByPtrPtr byte[] arg1, @Cast("char**") @ByPtrPtr byte[] arg2);
public static native int grantpt(int arg0);
// #if __DARWIN_UNIX03
public static native @Cast("char*") BytePointer initstate(@Cast("unsigned") int arg0, @Cast("char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") ByteBuffer initstate(@Cast("unsigned") int arg0, @Cast("char*") ByteBuffer arg1, @Cast("size_t") long arg2);
public static native @Cast("char*") byte[] initstate(@Cast("unsigned") int arg0, @Cast("char*") byte[] arg1, @Cast("size_t") long arg2); /* no  __DARWIN_ALIAS needed */
// #else /* !__DARWIN_UNIX03 */
// #endif /* __DARWIN_UNIX03 */
public static native long jrand48(@Cast("unsigned short*") ShortPointer arg0);
public static native long jrand48(@Cast("unsigned short*") ShortBuffer arg0);
public static native long jrand48(@Cast("unsigned short*") short[] arg0);
public static native @Cast("char*") BytePointer l64a(long arg0);
public static native void lcong48(@Cast("unsigned short*") ShortPointer arg0);
public static native void lcong48(@Cast("unsigned short*") ShortBuffer arg0);
public static native void lcong48(@Cast("unsigned short*") short[] arg0);
public static native long lrand48();
public static native @Cast("char*") BytePointer mktemp(@Cast("char*") BytePointer arg0);
public static native @Cast("char*") ByteBuffer mktemp(@Cast("char*") ByteBuffer arg0);
public static native @Cast("char*") byte[] mktemp(@Cast("char*") byte[] arg0);
public static native int mkstemp(@Cast("char*") BytePointer arg0);
public static native int mkstemp(@Cast("char*") ByteBuffer arg0);
public static native int mkstemp(@Cast("char*") byte[] arg0);
public static native long mrand48(); 
public static native long nrand48(@Cast("unsigned short*") ShortPointer arg0);
public static native long nrand48(@Cast("unsigned short*") ShortBuffer arg0);
public static native long nrand48(@Cast("unsigned short*") short[] arg0);
public static native int posix_openpt(int arg0);
public static native @Cast("char*") BytePointer ptsname(int arg0);
public static native int putenv(@Cast("char*") BytePointer arg0);
public static native int putenv(@Cast("char*") ByteBuffer arg0);
public static native int putenv(@Cast("char*") byte[] arg0);
public static native long random();
public static native int rand_r(@Cast("unsigned*") IntPointer arg0);
public static native int rand_r(@Cast("unsigned*") IntBuffer arg0);
public static native int rand_r(@Cast("unsigned*") int[] arg0);
// #if (__DARWIN_UNIX03 && !defined(_POSIX_C_SOURCE)) || defined(_DARWIN_C_SOURCE) || defined(_DARWIN_BETTER_REALPATH)
public static native @Cast("char*") BytePointer realpath(@Cast("const char*") BytePointer arg0, @Cast("char*") BytePointer arg1);
public static native @Cast("char*") ByteBuffer realpath(String arg0, @Cast("char*") ByteBuffer arg1);
public static native @Cast("char*") byte[] realpath(@Cast("const char*") BytePointer arg0, @Cast("char*") byte[] arg1);
public static native @Cast("char*") BytePointer realpath(String arg0, @Cast("char*") BytePointer arg1);
public static native @Cast("char*") ByteBuffer realpath(@Cast("const char*") BytePointer arg0, @Cast("char*") ByteBuffer arg1);
public static native @Cast("char*") byte[] realpath(String arg0, @Cast("char*") byte[] arg1);
// #else /* (!__DARWIN_UNIX03 || _POSIX_C_SOURCE) && !_DARWIN_C_SOURCE && !_DARWIN_BETTER_REALPATH */
// #endif /* (__DARWIN_UNIX03 && _POSIX_C_SOURCE) || _DARWIN_C_SOURCE || _DARWIN_BETTER_REALPATH */
public static native @Cast("unsigned short*") ShortPointer seed48(@Cast("unsigned short*") ShortPointer arg0);
public static native @Cast("unsigned short*") ShortBuffer seed48(@Cast("unsigned short*") ShortBuffer arg0);
public static native @Cast("unsigned short*") short[] seed48(@Cast("unsigned short*") short[] arg0);
public static native int setenv(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, int arg2);
public static native int setenv(String arg0, String arg1, int arg2);
// #if __DARWIN_UNIX03
public static native void setkey(@Cast("const char*") BytePointer arg0);
public static native void setkey(String arg0);
// #else /* !__DARWIN_UNIX03 */
// #endif /* __DARWIN_UNIX03 */
public static native @Cast("char*") BytePointer setstate(@Cast("const char*") BytePointer arg0);
public static native @Cast("char*") ByteBuffer setstate(String arg0);
public static native void srand48(long arg0);
// #if __DARWIN_UNIX03
public static native void srandom(@Cast("unsigned") int arg0);
// #else /* !__DARWIN_UNIX03 */
// #endif /* __DARWIN_UNIX03 */
public static native int unlockpt(int arg0);
// #if __DARWIN_UNIX03
public static native int unsetenv(@Cast("const char*") BytePointer arg0);
public static native int unsetenv(String arg0);
// #else /* !__DARWIN_UNIX03 */
// #endif /* __DARWIN_UNIX03 */
// #endif	/* !_ANSI_SOURCE */

// #if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
// #include <machine/types.h>

// #include <sys/_types/_dev_t.h>
// #include <sys/_types/_mode_t.h>

public static native @Cast("u_int32_t") int arc4random();
public static native void arc4random_addrandom(@Cast("unsigned char*") BytePointer arg0, int arg1);
public static native void arc4random_addrandom(@Cast("unsigned char*") ByteBuffer arg0, int arg1);
public static native void arc4random_addrandom(@Cast("unsigned char*") byte[] arg0, int arg1);
public static native void arc4random_buf(Pointer arg0, @Cast("size_t") long arg1);
public static native void arc4random_stir();
public static native @Cast("u_int32_t") int arc4random_uniform(@Cast("u_int32_t") int arg0);
// #ifdef __BLOCKS__
// #endif /* __BLOCKS__ */

	 /* getcap(3) functions */
public static native @Cast("char*") BytePointer cgetcap(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, int arg2);
public static native @Cast("char*") ByteBuffer cgetcap(@Cast("char*") ByteBuffer arg0, String arg1, int arg2);
public static native @Cast("char*") byte[] cgetcap(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1, int arg2);
public static native @Cast("char*") BytePointer cgetcap(@Cast("char*") BytePointer arg0, String arg1, int arg2);
public static native @Cast("char*") ByteBuffer cgetcap(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1, int arg2);
public static native @Cast("char*") byte[] cgetcap(@Cast("char*") byte[] arg0, String arg1, int arg2);
public static native int cgetclose();
public static native int cgetent(@Cast("char**") PointerPointer arg0, @Cast("char**") PointerPointer arg1, @Cast("const char*") BytePointer arg2);
public static native int cgetent(@Cast("char**") @ByPtrPtr BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, @Cast("const char*") BytePointer arg2);
public static native int cgetent(@Cast("char**") @ByPtrPtr ByteBuffer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, String arg2);
public static native int cgetent(@Cast("char**") @ByPtrPtr byte[] arg0, @Cast("char**") @ByPtrPtr byte[] arg1, @Cast("const char*") BytePointer arg2);
public static native int cgetent(@Cast("char**") @ByPtrPtr BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, String arg2);
public static native int cgetent(@Cast("char**") @ByPtrPtr ByteBuffer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, @Cast("const char*") BytePointer arg2);
public static native int cgetent(@Cast("char**") @ByPtrPtr byte[] arg0, @Cast("char**") @ByPtrPtr byte[] arg1, String arg2);
public static native int cgetfirst(@Cast("char**") PointerPointer arg0, @Cast("char**") PointerPointer arg1);
public static native int cgetfirst(@Cast("char**") @ByPtrPtr BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1);
public static native int cgetfirst(@Cast("char**") @ByPtrPtr ByteBuffer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1);
public static native int cgetfirst(@Cast("char**") @ByPtrPtr byte[] arg0, @Cast("char**") @ByPtrPtr byte[] arg1);
public static native int cgetmatch(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native int cgetmatch(String arg0, String arg1);
public static native int cgetnext(@Cast("char**") PointerPointer arg0, @Cast("char**") PointerPointer arg1);
public static native int cgetnext(@Cast("char**") @ByPtrPtr BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1);
public static native int cgetnext(@Cast("char**") @ByPtrPtr ByteBuffer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1);
public static native int cgetnext(@Cast("char**") @ByPtrPtr byte[] arg0, @Cast("char**") @ByPtrPtr byte[] arg1);
public static native int cgetnum(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, CLongPointer arg2);
public static native int cgetnum(@Cast("char*") ByteBuffer arg0, String arg1, CLongPointer arg2);
public static native int cgetnum(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1, CLongPointer arg2);
public static native int cgetnum(@Cast("char*") BytePointer arg0, String arg1, CLongPointer arg2);
public static native int cgetnum(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1, CLongPointer arg2);
public static native int cgetnum(@Cast("char*") byte[] arg0, String arg1, CLongPointer arg2);
public static native int cgetset(@Cast("const char*") BytePointer arg0);
public static native int cgetset(String arg0);
public static native int cgetstr(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("char**") PointerPointer arg2);
public static native int cgetstr(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("char**") @ByPtrPtr BytePointer arg2);
public static native int cgetstr(@Cast("char*") ByteBuffer arg0, String arg1, @Cast("char**") @ByPtrPtr ByteBuffer arg2);
public static native int cgetstr(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1, @Cast("char**") @ByPtrPtr byte[] arg2);
public static native int cgetstr(@Cast("char*") BytePointer arg0, String arg1, @Cast("char**") @ByPtrPtr BytePointer arg2);
public static native int cgetstr(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1, @Cast("char**") @ByPtrPtr ByteBuffer arg2);
public static native int cgetstr(@Cast("char*") byte[] arg0, String arg1, @Cast("char**") @ByPtrPtr byte[] arg2);
public static native int cgetustr(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("char**") PointerPointer arg2);
public static native int cgetustr(@Cast("char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("char**") @ByPtrPtr BytePointer arg2);
public static native int cgetustr(@Cast("char*") ByteBuffer arg0, String arg1, @Cast("char**") @ByPtrPtr ByteBuffer arg2);
public static native int cgetustr(@Cast("char*") byte[] arg0, @Cast("const char*") BytePointer arg1, @Cast("char**") @ByPtrPtr byte[] arg2);
public static native int cgetustr(@Cast("char*") BytePointer arg0, String arg1, @Cast("char**") @ByPtrPtr BytePointer arg2);
public static native int cgetustr(@Cast("char*") ByteBuffer arg0, @Cast("const char*") BytePointer arg1, @Cast("char**") @ByPtrPtr ByteBuffer arg2);
public static native int cgetustr(@Cast("char*") byte[] arg0, String arg1, @Cast("char**") @ByPtrPtr byte[] arg2);

public static native int daemon(int arg0, int arg1);
public static native @Cast("char*") BytePointer devname(@Cast("dev_t") int arg0, @Cast("mode_t") short arg1);
public static native @Cast("char*") BytePointer devname_r(@Cast("dev_t") int arg0, @Cast("mode_t") short arg1, @Cast("char*") BytePointer buf, int len);
public static native @Cast("char*") ByteBuffer devname_r(@Cast("dev_t") int arg0, @Cast("mode_t") short arg1, @Cast("char*") ByteBuffer buf, int len);
public static native @Cast("char*") byte[] devname_r(@Cast("dev_t") int arg0, @Cast("mode_t") short arg1, @Cast("char*") byte[] buf, int len);
public static native @Cast("char*") BytePointer getbsize(IntPointer arg0, CLongPointer arg1);
public static native @Cast("char*") ByteBuffer getbsize(IntBuffer arg0, CLongPointer arg1);
public static native @Cast("char*") byte[] getbsize(int[] arg0, CLongPointer arg1);
public static native int getloadavg(DoublePointer arg0, int arg1);
public static native int getloadavg(DoubleBuffer arg0, int arg1);
public static native int getloadavg(double[] arg0, int arg1);
public static native @Cast("const char*") BytePointer getprogname();

public static native int heapsort(Pointer arg0, @Cast("size_t") long arg1, @Cast("size_t") long arg2,
	    Arg3_Pointer_Pointer arg3);
// #ifdef __BLOCKS__
// #endif /* __BLOCKS__ */
public static native int mergesort(Pointer arg0, @Cast("size_t") long arg1, @Cast("size_t") long arg2,
	    Arg3_Pointer_Pointer arg3);
// #ifdef __BLOCKS__
// #endif /* __BLOCKS__ */
public static native void psort(Pointer arg0, @Cast("size_t") long arg1, @Cast("size_t") long arg2,
	    Arg3_Pointer_Pointer arg3);
// #ifdef __BLOCKS__
// #endif /* __BLOCKS__ */
public static class Arg4_Pointer_Pointer_Pointer extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Arg4_Pointer_Pointer_Pointer(Pointer p) { super(p); }
    protected Arg4_Pointer_Pointer_Pointer() { allocate(); }
    private native void allocate();
    public native int call(Pointer arg0, @Const Pointer arg1, @Const Pointer arg2);
}
public static native void psort_r(Pointer arg0, @Cast("size_t") long arg1, @Cast("size_t") long arg2, Pointer arg3,
	    Arg4_Pointer_Pointer_Pointer arg4);
// #ifdef __BLOCKS__
// #endif /* __BLOCKS__ */
public static native void qsort_r(Pointer arg0, @Cast("size_t") long arg1, @Cast("size_t") long arg2, Pointer arg3,
	    Arg4_Pointer_Pointer_Pointer arg4);
public static native int radixsort(@Cast("const unsigned char**") PointerPointer arg0, int arg1, @Cast("const unsigned char*") BytePointer arg2,
	    @Cast("unsigned") int arg3);
public static native int radixsort(@Cast("const unsigned char**") @ByPtrPtr BytePointer arg0, int arg1, @Cast("const unsigned char*") BytePointer arg2,
	    @Cast("unsigned") int arg3);
public static native int radixsort(@Cast("const unsigned char**") @ByPtrPtr ByteBuffer arg0, int arg1, @Cast("const unsigned char*") ByteBuffer arg2,
	    @Cast("unsigned") int arg3);
public static native int radixsort(@Cast("const unsigned char**") @ByPtrPtr byte[] arg0, int arg1, @Cast("const unsigned char*") byte[] arg2,
	    @Cast("unsigned") int arg3);
public static native void setprogname(@Cast("const char*") BytePointer arg0);
public static native void setprogname(String arg0);
public static native int sradixsort(@Cast("const unsigned char**") PointerPointer arg0, int arg1, @Cast("const unsigned char*") BytePointer arg2,
	    @Cast("unsigned") int arg3);
public static native int sradixsort(@Cast("const unsigned char**") @ByPtrPtr BytePointer arg0, int arg1, @Cast("const unsigned char*") BytePointer arg2,
	    @Cast("unsigned") int arg3);
public static native int sradixsort(@Cast("const unsigned char**") @ByPtrPtr ByteBuffer arg0, int arg1, @Cast("const unsigned char*") ByteBuffer arg2,
	    @Cast("unsigned") int arg3);
public static native int sradixsort(@Cast("const unsigned char**") @ByPtrPtr byte[] arg0, int arg1, @Cast("const unsigned char*") byte[] arg2,
	    @Cast("unsigned") int arg3);
public static native void sranddev();
public static native void srandomdev();
public static native Pointer reallocf(Pointer arg0, @Cast("size_t") long arg1);
// #if !__DARWIN_NO_LONG_LONG
public static native long strtoq(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1, int arg2);
public static native long strtoq(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
public static native long strtoq(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
public static native long strtoq(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
public static native long strtoq(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
public static native long strtoq(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
public static native long strtoq(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
public static native @Cast("unsigned long long") long strtouq(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1, int arg2);
public static native @Cast("unsigned long long") long strtouq(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
public static native @Cast("unsigned long long") long strtouq(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
public static native @Cast("unsigned long long") long strtouq(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
public static native @Cast("unsigned long long") long strtouq(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
public static native @Cast("unsigned long long") long strtouq(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
public static native @Cast("unsigned long long") long strtouq(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
// #endif /* !__DARWIN_NO_LONG_LONG */
public static native @Cast("char*") BytePointer suboptarg(); public static native void suboptarg(BytePointer suboptarg);		/* getsubopt(3) external variable */
public static native Pointer valloc(@Cast("size_t") long arg0);
// #endif	/* !_ANSI_SOURCE && !_POSIX_SOURCE */

/* Poison the following routines if -fshort-wchar is set */
// #if !defined(__cplusplus) && defined(__WCHAR_MAX__) && __WCHAR_MAX__ <= 0xffff
// #pragma GCC poison mbstowcs mbtowc wcstombs wctomb
// #endif
// #ifdef _USE_EXTENDED_LOCALES_
// #endif /* _USE_EXTENDED_LOCALES_ */

// #endif /* _STDLIB_H_ */


// Parsed from sys/_types/_timespec.h

/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
// #ifndef _STRUCT_TIMESPEC
// #define _STRUCT_TIMESPEC	struct timespec
public static class timespec extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public timespec() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public timespec(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public timespec(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public timespec position(long position) {
        return (timespec)super.position(position);
    }

	public native @Cast("__darwin_time_t") long tv_sec(); public native timespec tv_sec(long tv_sec);
	public native long tv_nsec(); public native timespec tv_nsec(long tv_nsec);
}
// #endif /* _STRUCT_TIMESPEC */


// Parsed from sys/_types/_timeval.h

/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
// #ifndef _STRUCT_TIMEVAL
// #define _STRUCT_TIMEVAL		struct timeval
public static class timeval extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public timeval() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public timeval(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public timeval(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public timeval position(long position) {
        return (timeval)super.position(position);
    }

	public native @Cast("__darwin_time_t") long tv_sec(); public native timeval tv_sec(long tv_sec);	        /* seconds */
	public native @Cast("__darwin_suseconds_t") int tv_usec(); public native timeval tv_usec(int tv_usec);        /* and microseconds */
}
// #endif /* _STRUCT_TIMEVAL */


// Parsed from sys/time.h

/*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.2 (Berkeley) 7/10/94
 */

// #ifndef _SYS_TIME_H_
// #define _SYS_TIME_H_

// #include <sys/cdefs.h>
// #include <sys/_types.h>
// #include <Availability.h>

/*
 * [XSI] The fd_set type shall be defined as described in <sys/select.h>.
 * The timespec structure shall be defined as described in <time.h>
 */
// #include <sys/_types/_fd_def.h>
// #include <sys/_types/_timespec.h>
// #include <sys/_types/_timeval.h>

// #include <sys/_types/_time_t.h>
// #include <sys/_types/_suseconds_t.h>

/*
 * Structure used as a parameter by getitimer(2) and setitimer(2) system
 * calls.
 */
public static class itimerval extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public itimerval() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public itimerval(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public itimerval(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public itimerval position(long position) {
        return (itimerval)super.position(position);
    }

	public native @ByRef timeval it_interval(); public native itimerval it_interval(timeval it_interval);	/* timer interval */
	public native @ByRef timeval it_value(); public native itimerval it_value(timeval it_value);	/* current value */
}

/*
 * Names of the interval timers, and structure
 * defining a timer setting.
 */
public static final int ITIMER_REAL =	0;
public static final int ITIMER_VIRTUAL =	1;
public static final int ITIMER_PROF =	2;

/*
 * Select uses bit masks of file descriptors in longs.  These macros
 * manipulate such bit fields (the filesystem macros use chars).  The
 * extra protection here is to permit application redefinition above
 * the default size.
 */
// #include <sys/_types/_fd_setsize.h>
// #include <sys/_types/_fd_set.h>
// #include <sys/_types/_fd_clr.h>
// #include <sys/_types/_fd_isset.h>
// #include <sys/_types/_fd_zero.h>

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)

// #include <sys/_types/_fd_copy.h>

// #define	TIMEVAL_TO_TIMESPEC(tv, ts) {
// 	(ts)->tv_sec = (tv)->tv_sec;
// 	(ts)->tv_nsec = (tv)->tv_usec * 1000;
// }
// #define	TIMESPEC_TO_TIMEVAL(tv, ts) {
// 	(tv)->tv_sec = (ts)->tv_sec;
// 	(tv)->tv_usec = (ts)->tv_nsec / 1000;
// }

@Name("struct timezone") public static class timezone extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public timezone() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public timezone(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public timezone(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public timezone position(long position) {
        return (timezone)super.position(position);
    }

	public native int tz_minuteswest(); public native timezone tz_minuteswest(int tz_minuteswest);	/* minutes west of Greenwich */
	public native int tz_dsttime(); public native timezone tz_dsttime(int tz_dsttime);	/* type of dst correction */
}
public static final int DST_NONE =	0;	/* not on dst */
public static final int DST_USA =		1;	/* USA style dst */
public static final int DST_AUST =	2;	/* Australian style dst */
public static final int DST_WET =		3;	/* Western European dst */
public static final int DST_MET =		4;	/* Middle European dst */
public static final int DST_EET =		5;	/* Eastern European dst */
public static final int DST_CAN =		6;	/* Canada */

/* Operations on timevals. */
// #define	timerclear(tvp)		(tvp)->tv_sec = (tvp)->tv_usec = 0
// #define	timerisset(tvp)		((tvp)->tv_sec || (tvp)->tv_usec)
// #define	timercmp(tvp, uvp, cmp)
// 	(((tvp)->tv_sec == (uvp)->tv_sec) ?
// 	    ((tvp)->tv_usec cmp (uvp)->tv_usec) :
// 	    ((tvp)->tv_sec cmp (uvp)->tv_sec))
// #define	timeradd(tvp, uvp, vvp)
// 	do {
// 		(vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec;
// 		(vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec;
// 		if ((vvp)->tv_usec >= 1000000) {
// 			(vvp)->tv_sec++;
// 			(vvp)->tv_usec -= 1000000;
// 		}
// 	} while (0)
// #define	timersub(tvp, uvp, vvp)
// 	do {
// 		(vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec;
// 		(vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec;
// 		if ((vvp)->tv_usec < 0) {
// 			(vvp)->tv_sec--;
// 			(vvp)->tv_usec += 1000000;
// 		}
// 	} while (0)

// #define timevalcmp(l, r, cmp)   timercmp(l, r, cmp) /* freebsd */

/*
 * Getkerninfo clock information structure
 */
public static class clockinfo extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public clockinfo() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public clockinfo(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public clockinfo(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public clockinfo position(long position) {
        return (clockinfo)super.position(position);
    }

	public native int hz(); public native clockinfo hz(int hz);		/* clock frequency */
	public native int tick(); public native clockinfo tick(int tick);		/* micro-seconds per hz tick */
	public native int tickadj(); public native clockinfo tickadj(int tickadj);	/* clock skew rate for adjtime() */
	public native int stathz(); public native clockinfo stathz(int stathz);		/* statistics clock frequency */
	public native int profhz(); public native clockinfo profhz(int profhz);		/* profiling clock frequency */
}
// #endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */


// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
// #include <time.h>
// #endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static native int adjtime(@Const timeval arg0, timeval arg1);
public static native int futimes(int arg0, @Const timeval arg1);
public static native int lutimes(@Cast("const char*") BytePointer arg0, @Const timeval arg1);
public static native int lutimes(String arg0, @Const timeval arg1);
public static native int settimeofday(@Const timeval arg0, @Const timezone arg1);
// #endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

public static native int getitimer(int arg0, itimerval arg1);
public static native int gettimeofday(timeval arg0, Pointer arg1);

// #include <sys/_select.h>	/* select() prototype */

public static native int setitimer(int arg0, @Const itimerval arg1,
		itimerval arg2);
public static native int utimes(@Cast("const char*") BytePointer arg0, @Const timeval arg1);
public static native int utimes(String arg0, @Const timeval arg1);

// #endif /* !_SYS_TIME_H_ */


// Parsed from time.h

/*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)time.h	8.3 (Berkeley) 1/21/94
 */

// #ifndef _TIME_H_
// #define	_TIME_H_

// #include <_types.h>
// #include <sys/_types/_clock_t.h>
// #include <sys/_types/_null.h>
// #include <sys/_types/_size_t.h>
// #include <sys/_types/_time_t.h>
// #include <sys/_types/_timespec.h>

public static class tm extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public tm() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public tm(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public tm(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public tm position(long position) {
        return (tm)super.position(position);
    }

	public native int tm_sec(); public native tm tm_sec(int tm_sec);		/* seconds after the minute [0-60] */
	public native int tm_min(); public native tm tm_min(int tm_min);		/* minutes after the hour [0-59] */
	public native int tm_hour(); public native tm tm_hour(int tm_hour);	/* hours since midnight [0-23] */
	public native int tm_mday(); public native tm tm_mday(int tm_mday);	/* day of the month [1-31] */
	public native int tm_mon(); public native tm tm_mon(int tm_mon);		/* months since January [0-11] */
	public native int tm_year(); public native tm tm_year(int tm_year);	/* years since 1900 */
	public native int tm_wday(); public native tm tm_wday(int tm_wday);	/* days since Sunday [0-6] */
	public native int tm_yday(); public native tm tm_yday(int tm_yday);	/* days since January 1 [0-365] */
	public native int tm_isdst(); public native tm tm_isdst(int tm_isdst);	/* Daylight Savings Time flag */
	public native long tm_gmtoff(); public native tm tm_gmtoff(long tm_gmtoff);	/* offset from CUT in seconds */
	public native @Cast("char*") BytePointer tm_zone(); public native tm tm_zone(BytePointer tm_zone);	/* timezone abbreviation */
}

// #if __DARWIN_UNIX03
public static native @MemberGetter long CLOCKS_PER_SEC();
public static final long CLOCKS_PER_SEC = CLOCKS_PER_SEC();	/* [XSI] */
// #else /* !__DARWIN_UNIX03 */
// #endif /* __DARWIN_UNIX03 */

// #ifndef _ANSI_SOURCE
public static native @Cast("char*") BytePointer tzname(int i); public static native void tzname(int i, BytePointer tzname);
@MemberGetter public static native @Cast("char**") PointerPointer tzname();
// #endif

public static native int getdate_err(); public static native void getdate_err(int getdate_err);
// #if __DARWIN_UNIX03
// #endif /* __DARWIN_UNIX03 */
public static native int daylight(); public static native void daylight(int daylight);

public static native @Cast("char*") BytePointer asctime(@Const tm arg0);
public static native @Cast("clock_t") long clock();
public static native @Cast("char*") BytePointer ctime(@Cast("const time_t*") Pointer arg0);
public static native double difftime(@ByVal @Cast("time_t*") Pointer arg0, @ByVal @Cast("time_t*") Pointer arg1);
public static native tm getdate(@Cast("const char*") BytePointer arg0);
public static native tm getdate(String arg0);
public static native tm gmtime(@Cast("const time_t*") Pointer arg0);
public static native tm localtime(@Cast("const time_t*") Pointer arg0);
public static native @ByVal @Cast("time_t*") Pointer mktime(tm arg0);
public static native @Cast("size_t") long strftime(@Cast("char*") BytePointer arg0, @Cast("size_t") long arg1, @Cast("const char*") BytePointer arg2, @Const tm arg3);
public static native @Cast("size_t") long strftime(@Cast("char*") ByteBuffer arg0, @Cast("size_t") long arg1, String arg2, @Const tm arg3);
public static native @Cast("size_t") long strftime(@Cast("char*") byte[] arg0, @Cast("size_t") long arg1, @Cast("const char*") BytePointer arg2, @Const tm arg3);
public static native @Cast("size_t") long strftime(@Cast("char*") BytePointer arg0, @Cast("size_t") long arg1, String arg2, @Const tm arg3);
public static native @Cast("size_t") long strftime(@Cast("char*") ByteBuffer arg0, @Cast("size_t") long arg1, @Cast("const char*") BytePointer arg2, @Const tm arg3);
public static native @Cast("size_t") long strftime(@Cast("char*") byte[] arg0, @Cast("size_t") long arg1, String arg2, @Const tm arg3);
public static native @Cast("char*") BytePointer strptime(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, tm arg2);
public static native @Cast("char*") ByteBuffer strptime(String arg0, String arg1, tm arg2);
public static native @ByVal @Cast("time_t*") Pointer time(@Cast("time_t*") Pointer arg0);

// #ifndef _ANSI_SOURCE
public static native void tzset();
// #endif /* not ANSI */

/* [TSF] Thread safe functions */
public static native @Cast("char*") BytePointer asctime_r(@Const tm arg0, @Cast("char*") BytePointer arg1);
public static native @Cast("char*") ByteBuffer asctime_r(@Const tm arg0, @Cast("char*") ByteBuffer arg1);
public static native @Cast("char*") byte[] asctime_r(@Const tm arg0, @Cast("char*") byte[] arg1);
public static native @Cast("char*") BytePointer ctime_r(@Cast("const time_t*") Pointer arg0, @Cast("char*") BytePointer arg1);
public static native @Cast("char*") ByteBuffer ctime_r(@Cast("const time_t*") Pointer arg0, @Cast("char*") ByteBuffer arg1);
public static native @Cast("char*") byte[] ctime_r(@Cast("const time_t*") Pointer arg0, @Cast("char*") byte[] arg1);
public static native tm gmtime_r(@Cast("const time_t*") Pointer arg0, tm arg1);
public static native tm localtime_r(@Cast("const time_t*") Pointer arg0, tm arg1);

// #if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
public static native @ByVal @Cast("time_t*") Pointer posix2time(@ByVal @Cast("time_t*") Pointer arg0);
// #if !__DARWIN_UNIX03
// #endif /* !__DARWIN_UNIX03 */
public static native void tzsetwall();
public static native @ByVal @Cast("time_t*") Pointer time2posix(@ByVal @Cast("time_t*") Pointer arg0);
public static native @ByVal @Cast("time_t*") Pointer timelocal(tm arg0);
public static native @ByVal @Cast("time_t*") Pointer timegm(tm arg0);
// #endif /* neither ANSI nor POSIX */

// #if !defined(_ANSI_SOURCE)
public static native int nanosleep(@Const timespec arg0, timespec arg1);
// #endif
// #ifdef _USE_EXTENDED_LOCALES_
// #endif /* _USE_EXTENDED_LOCALES_ */

// #endif /* !_TIME_H_ */


// Parsed from utime.h

/*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)utime.h	8.1 (Berkeley) 6/2/93
 */

// #ifndef	_UTIME_H_
// #define	_UTIME_H_

// #include <_types.h>
// #include <sys/_types/_time_t.h>

public static class utimbuf extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public utimbuf() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public utimbuf(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public utimbuf(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public utimbuf position(long position) {
        return (utimbuf)super.position(position);
    }

	public native @ByRef @Cast("time_t*") Pointer actime(); public native utimbuf actime(Pointer actime);		/* Access time */
	public native @ByRef @Cast("time_t*") Pointer modtime(); public native utimbuf modtime(Pointer modtime);		/* Modification time */
}

// #include <sys/cdefs.h>

public static native int utime(@Cast("const char*") BytePointer arg0, @Const utimbuf arg1);
public static native int utime(String arg0, @Const utimbuf arg1);
// #endif /* !_UTIME_H_ */


// Parsed from sys/_types/_s_ifmt.h

/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/*
 * [XSI] The symbolic names for file modes for use as values of mode_t
 * shall be defined as described in <sys/stat.h>
 */
// #ifndef S_IFMT
/* File type */
public static final int S_IFMT =		0170000;		/* [XSI] type of file mask */
public static final int S_IFIFO =		0010000;		/* [XSI] named pipe (fifo) */
public static final int S_IFCHR =		0020000;		/* [XSI] character special */
public static final int S_IFDIR =		0040000;		/* [XSI] directory */
public static final int S_IFBLK =		0060000;		/* [XSI] block special */
public static final int S_IFREG =		0100000;		/* [XSI] regular */
public static final int S_IFLNK =		0120000;		/* [XSI] symbolic link */
public static final int S_IFSOCK =	0140000;		/* [XSI] socket */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int S_IFWHT =		0160000;		/* OBSOLETE: whiteout */
// #endif

/* File mode */
/* Read, write, execute/search by owner */
public static final int S_IRWXU =		0000700;		/* [XSI] RWX mask for owner */
public static final int S_IRUSR =		0000400;		/* [XSI] R for owner */
public static final int S_IWUSR =		0000200;		/* [XSI] W for owner */
public static final int S_IXUSR =		0000100;		/* [XSI] X for owner */
/* Read, write, execute/search by group */
public static final int S_IRWXG =		0000070;		/* [XSI] RWX mask for group */
public static final int S_IRGRP =		0000040;		/* [XSI] R for group */
public static final int S_IWGRP =		0000020;		/* [XSI] W for group */
public static final int S_IXGRP =		0000010;		/* [XSI] X for group */
/* Read, write, execute/search by others */
public static final int S_IRWXO =		0000007;		/* [XSI] RWX mask for other */
public static final int S_IROTH =		0000004;		/* [XSI] R for other */
public static final int S_IWOTH =		0000002;		/* [XSI] W for other */
public static final int S_IXOTH =		0000001;		/* [XSI] X for other */

public static final int S_ISUID =		0004000;		/* [XSI] set user id on execution */
public static final int S_ISGID =		0002000;		/* [XSI] set group id on execution */
public static final int S_ISVTX =		0001000;		/* [XSI] directory restrcted delete */

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int S_ISTXT =		S_ISVTX;		/* sticky bit: not supported */
public static final int S_IREAD =		S_IRUSR;		/* backward compatability */
public static final int S_IWRITE =	S_IWUSR;		/* backward compatability */
public static final int S_IEXEC =		S_IXUSR;		/* backward compatability */
// #endif
// #endif	/* !S_IFMT */


// Parsed from sys/_types/_filesec_t.h

/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
// #ifndef _FILESEC_T
// #define _FILESEC_T
@Opaque public static class _filesec extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public _filesec() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _filesec(Pointer p) { super(p); }
}
// #endif /* _FILESEC_T */


// Parsed from sys/stat.h

/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*-
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)stat.h	8.9 (Berkeley) 8/17/94
 */


// #ifndef _SYS_STAT_H_
// #define	_SYS_STAT_H_

// #include <sys/_types.h>
// #include <sys/cdefs.h>
// #include <Availability.h>

/* [XSI] The timespec structure may be defined as described in <time.h> */
// #include <sys/_types/_timespec.h>

/*
 * [XSI] The blkcnt_t, blksize_t, dev_t, ino_t, mode_t, nlink_t, uid_t,
 * gid_t, off_t, and time_t types shall be defined as described in
 * <sys/types.h>.
 */
// #include <sys/_types/_blkcnt_t.h>
// #include <sys/_types/_blksize_t.h>
// #include <sys/_types/_dev_t.h>			/* device number */
// #include <sys/_types/_ino_t.h>

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
// #include <sys/_types/_ino64_t.h>
// #endif /* !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE) */

// #include <sys/_types/_mode_t.h>
// #include <sys/_types/_nlink_t.h>
// #include <sys/_types/_uid_t.h>
// #include <sys/_types/_gid_t.h>
// #include <sys/_types/_off_t.h>
// #include <sys/_types/_time_t.h>

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/*
 * XXX So deprecated, it would make your head spin
 *
 * The old stat structure.  In fact, this is not used by the kernel at all,
 * and should not be used by user space, and should be removed from this
 * header file entirely (along with the unused cvtstat() prototype in
 * vnode_internal.h).
 */
public static class ostat extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public ostat() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ostat(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ostat(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public ostat position(long position) {
        return (ostat)super.position(position);
    }

	public native @Cast("__uint16_t") short st_dev(); public native ostat st_dev(short st_dev);		/* inode's device */
	public native @Cast("ino_t") long st_ino(); public native ostat st_ino(long st_ino);		/* inode's number */
	public native @Cast("mode_t") short st_mode(); public native ostat st_mode(short st_mode);	/* inode protection mode */
	public native @Cast("nlink_t") short st_nlink(); public native ostat st_nlink(short st_nlink);	/* number of hard links */
	public native @Cast("__uint16_t") short st_uid(); public native ostat st_uid(short st_uid);		/* user ID of the file's owner */
	public native @Cast("__uint16_t") short st_gid(); public native ostat st_gid(short st_gid);		/* group ID of the file's group */
	public native @Cast("__uint16_t") short st_rdev(); public native ostat st_rdev(short st_rdev);	/* device type */
	public native @Cast("__int32_t") int st_size(); public native ostat st_size(int st_size);	/* file size, in bytes */
	public native @ByRef timespec st_atimespec(); public native ostat st_atimespec(timespec st_atimespec);	/* time of last access */
	public native @ByRef timespec st_mtimespec(); public native ostat st_mtimespec(timespec st_mtimespec);	/* time of last data modification */
	public native @ByRef timespec st_ctimespec(); public native ostat st_ctimespec(timespec st_ctimespec);	/* time of last file status change */
	public native @Cast("__int32_t") int st_blksize(); public native ostat st_blksize(int st_blksize);	/* optimal blocksize for I/O */
	public native @Cast("__int32_t") int st_blocks(); public native ostat st_blocks(int st_blocks);	/* blocks allocated for file */
	public native @Cast("__uint32_t") int st_flags(); public native ostat st_flags(int st_flags);	/* user defined flags for file */
	public native @Cast("__uint32_t") int st_gen(); public native ostat st_gen(int st_gen);		/* file generation number */
}

// #define __DARWIN_STRUCT_STAT64_TIMES
// 	struct timespec st_atimespec;		/* time of last access */
// 	struct timespec st_mtimespec;		/* time of last data modification */
// 	struct timespec st_ctimespec;		/* time of last status change */
// 	struct timespec st_birthtimespec;	/* time of file creation(birth) */

// #else /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */

// #endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * This structure is used as the second parameter to the fstat64(),
 * lstat64(), and stat64() functions, and for struct stat when
 * __DARWIN_64_BIT_INO_T is set. __DARWIN_STRUCT_STAT64 is defined
 * above, depending on whether we use struct timespec or the direct
 * components.
 *
 * This is simillar to stat except for 64bit inode number
 * number instead of 32bit ino_t and the addition of create(birth) time.
 */
// #define __DARWIN_STRUCT_STAT64 {
// 	dev_t		st_dev;			/* [XSI] ID of device containing file */
// 	mode_t		st_mode;		/* [XSI] Mode of file (see below) */
// 	nlink_t		st_nlink;		/* [XSI] Number of hard links */
// 	__darwin_ino64_t st_ino;		/* [XSI] File serial number */
// 	uid_t		st_uid;			/* [XSI] User ID of the file */
// 	gid_t		st_gid;			/* [XSI] Group ID of the file */
// 	dev_t		st_rdev;		/* [XSI] Device ID */
// 	__DARWIN_STRUCT_STAT64_TIMES
// 	off_t		st_size;		/* [XSI] file size, in bytes */
// 	blkcnt_t	st_blocks;		/* [XSI] blocks allocated for file */
// 	blksize_t	st_blksize;		/* [XSI] optimal blocksize for I/O */
// 	__uint32_t	st_flags;		/* user defined flags for file */
// 	__uint32_t	st_gen;			/* file generation number */
// 	__int32_t	st_lspare;		/* RESERVED: DO NOT USE! */
// 	__int64_t	st_qspare[2];		/* RESERVED: DO NOT USE! */
// }

/*
 * [XSI] This structure is used as the second parameter to the fstat(),
 * lstat(), and stat() functions.
 */
// #if __DARWIN_64_BIT_INO_T

@Name("struct stat") public static class stat extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public stat() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public stat(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public stat(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public stat position(long position) {
        return (stat)super.position(position);
    }

	public native @Cast("dev_t") int st_dev(); public native stat st_dev(int st_dev);			/* [XSI] ID of device containing file */
	public native @Cast("mode_t") short st_mode(); public native stat st_mode(short st_mode);		/* [XSI] Mode of file (see below) */
	public native @Cast("nlink_t") short st_nlink(); public native stat st_nlink(short st_nlink);		/* [XSI] Number of hard links */
	public native @Cast("__darwin_ino64_t") long st_ino(); public native stat st_ino(long st_ino);		/* [XSI] File serial number */
	public native @Cast("uid_t") int st_uid(); public native stat st_uid(int st_uid);			/* [XSI] User ID of the file */
	public native @Cast("gid_t") int st_gid(); public native stat st_gid(int st_gid);			/* [XSI] Group ID of the file */
	public native @Cast("dev_t") int st_rdev(); public native stat st_rdev(int st_rdev);		/* [XSI] Device ID */
	public native @ByRef timespec st_atimespec(); public native stat st_atimespec(timespec st_atimespec);		/* time of last access */
	public native @ByRef timespec st_mtimespec(); public native stat st_mtimespec(timespec st_mtimespec);		/* time of last data modification */
	public native @ByRef timespec st_ctimespec(); public native stat st_ctimespec(timespec st_ctimespec);		/* time of last status change */
	public native @ByRef timespec st_birthtimespec(); public native stat st_birthtimespec(timespec st_birthtimespec);	/* time of file creation(birth) */
	public native @Cast("off_t") long st_size(); public native stat st_size(long st_size);		/* [XSI] file size, in bytes */
	public native @Cast("blkcnt_t") long st_blocks(); public native stat st_blocks(long st_blocks);		/* [XSI] blocks allocated for file */
	public native @Cast("blksize_t") int st_blksize(); public native stat st_blksize(int st_blksize);		/* [XSI] optimal blocksize for I/O */
	public native @Cast("__uint32_t") int st_flags(); public native stat st_flags(int st_flags);		/* user defined flags for file */
	public native @Cast("__uint32_t") int st_gen(); public native stat st_gen(int st_gen);			/* file generation number */
	public native @Cast("__int32_t") int st_lspare(); public native stat st_lspare(int st_lspare);		/* RESERVED: DO NOT USE! */
	public native @Cast("__int64_t") long st_qspare(int i); public native stat st_qspare(int i, long st_qspare);
	@MemberGetter public native @Cast("__int64_t*") LongPointer st_qspare();		/* RESERVED: DO NOT USE! */
}

// #else /* !__DARWIN_64_BIT_INO_T */

// #endif /* __DARWIN_64_BIT_INO_T */

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)

// #if !__DARWIN_ONLY_64_BIT_INO_T

@Name("struct stat64") public static class stat64 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public stat64() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public stat64(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public stat64(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public stat64 position(long position) {
        return (stat64)super.position(position);
    }

	public native @Cast("dev_t") int st_dev(); public native stat64 st_dev(int st_dev);			/* [XSI] ID of device containing file */
	public native @Cast("mode_t") short st_mode(); public native stat64 st_mode(short st_mode);		/* [XSI] Mode of file (see below) */
	public native @Cast("nlink_t") short st_nlink(); public native stat64 st_nlink(short st_nlink);		/* [XSI] Number of hard links */
	public native @Cast("__darwin_ino64_t") long st_ino(); public native stat64 st_ino(long st_ino);		/* [XSI] File serial number */
	public native @Cast("uid_t") int st_uid(); public native stat64 st_uid(int st_uid);			/* [XSI] User ID of the file */
	public native @Cast("gid_t") int st_gid(); public native stat64 st_gid(int st_gid);			/* [XSI] Group ID of the file */
	public native @Cast("dev_t") int st_rdev(); public native stat64 st_rdev(int st_rdev);		/* [XSI] Device ID */
	public native @ByRef timespec st_atimespec(); public native stat64 st_atimespec(timespec st_atimespec);		/* time of last access */
	public native @ByRef timespec st_mtimespec(); public native stat64 st_mtimespec(timespec st_mtimespec);		/* time of last data modification */
	public native @ByRef timespec st_ctimespec(); public native stat64 st_ctimespec(timespec st_ctimespec);		/* time of last status change */
	public native @ByRef timespec st_birthtimespec(); public native stat64 st_birthtimespec(timespec st_birthtimespec);	/* time of file creation(birth) */
	public native @Cast("off_t") long st_size(); public native stat64 st_size(long st_size);		/* [XSI] file size, in bytes */
	public native @Cast("blkcnt_t") long st_blocks(); public native stat64 st_blocks(long st_blocks);		/* [XSI] blocks allocated for file */
	public native @Cast("blksize_t") int st_blksize(); public native stat64 st_blksize(int st_blksize);		/* [XSI] optimal blocksize for I/O */
	public native @Cast("__uint32_t") int st_flags(); public native stat64 st_flags(int st_flags);		/* user defined flags for file */
	public native @Cast("__uint32_t") int st_gen(); public native stat64 st_gen(int st_gen);			/* file generation number */
	public native @Cast("__int32_t") int st_lspare(); public native stat64 st_lspare(int st_lspare);		/* RESERVED: DO NOT USE! */
	public native @Cast("__int64_t") long st_qspare(int i); public native stat64 st_qspare(int i, long st_qspare);
	@MemberGetter public native @Cast("__int64_t*") LongPointer st_qspare();		/* RESERVED: DO NOT USE! */
}

// #endif /* !__DARWIN_ONLY_64_BIT_INO_T */

// #endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */




// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
// #endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * [XSI] The following are symbolic names for the values of type mode_t.  They
 * are bitmap values.
 */
// #include <sys/_types/_s_ifmt.h>

/*
 * [XSI] The following macros shall be provided to test whether a file is
 * of the specified type.  The value m supplied to the macros is the value
 * of st_mode from a stat structure.  The macro shall evaluate to a non-zero
 * value if the test is true; 0 if the test is false.
 */
// #define	S_ISBLK(m)	(((m) & S_IFMT) == S_IFBLK)	/* block special */
// #define	S_ISCHR(m)	(((m) & S_IFMT) == S_IFCHR)	/* char special */
// #define	S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)	/* directory */
// #define	S_ISFIFO(m)	(((m) & S_IFMT) == S_IFIFO)	/* fifo or socket */
// #define	S_ISREG(m)	(((m) & S_IFMT) == S_IFREG)	/* regular file */
// #define	S_ISLNK(m)	(((m) & S_IFMT) == S_IFLNK)	/* symbolic link */
// #define	S_ISSOCK(m)	(((m) & S_IFMT) == S_IFSOCK)	/* socket */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
// #define	S_ISWHT(m)	(((m) & S_IFMT) == S_IFWHT)	/* OBSOLETE: whiteout */
// #endif

/*
 * [XSI] The implementation may implement message queues, semaphores, or
 * shared memory objects as distinct file types.  The following macros
 * shall be provided to test whether a file is of the specified type.
 * The value of the buf argument supplied to the macros is a pointer to
 * a stat structure.  The macro shall evaluate to a non-zero value if
 * the specified object is implemented as a distinct file type and the
 * specified file type is contained in the stat structure referenced by
 * buf.  Otherwise, the macro shall evaluate to zero.
 *
 * NOTE:	The current implementation does not do this, although
 *		this may change in future revisions, and co currently only
 *		provides these macros to ensure source compatability with
 *		implementations which do.
 */
// #define	S_TYPEISMQ(buf)		(0)	/* Test for a message queue */
// #define	S_TYPEISSEM(buf)	(0)	/* Test for a semaphore */
// #define	S_TYPEISSHM(buf)	(0)	/* Test for a shared memory object */

/*
 * [TYM] The implementation may implement typed memory objects as distinct
 * file types, and the following macro shall test whether a file is of the
 * specified type.  The value of the buf argument supplied to the macros is
 * a pointer to a stat structure.  The macro shall evaluate to a non-zero
 * value if the specified object is implemented as a distinct file type and
 * the specified file type is contained in the stat structure referenced by
 * buf.  Otherwise, the macro shall evaluate to zero.
 *
 * NOTE:	The current implementation does not do this, although
 *		this may change in future revisions, and co currently only
 *		provides this macro to ensure source compatability with
 *		implementations which do.
 */
// #define	S_TYPEISTMO(buf)	(0)	/* Test for a typed memory object */


// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int ACCESSPERMS =	(S_IRWXU|S_IRWXG|S_IRWXO);	/* 0777 */
							/* 7777 */
public static final int ALLPERMS =	(S_ISUID|S_ISGID|S_ISTXT|S_IRWXU|S_IRWXG|S_IRWXO);
							/* 0666 */
public static final int DEFFILEMODE =	(S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);

public static final int S_BLKSIZE =	512;		/* block size used in the stat struct */

/*
 * Definitions of flags stored in file flags word.
 *
 * Super-user and owner changeable flags.
 */
public static final int UF_SETTABLE =	0x0000ffff;	/* mask of owner changeable flags */
public static final int UF_NODUMP =	0x00000001;	/* do not dump file */
public static final int UF_IMMUTABLE =	0x00000002;	/* file may not be changed */
public static final int UF_APPEND =	0x00000004;	/* writes to file may only append */
public static final int UF_OPAQUE =	0x00000008;	/* directory is opaque wrt. union */
/*
 * The following bit is reserved for FreeBSD.  It is not implemented
 * in Mac OS X.
 */
/* #define UF_NOUNLINK	0x00000010 */	/* file may not be removed or renamed */
public static final int UF_COMPRESSED =	0x00000020;	/* file is hfs-compressed */

/* UF_TRACKED is used for dealing with document IDs.  We no longer issue
   notifications for deletes or renames for files which have UF_TRACKED set. */
public static final int UF_TRACKED =		0x00000040;

/* Bits 0x0080 through 0x4000 are currently undefined. */
public static final int UF_HIDDEN =	0x00008000;	/* hint that this item should not be */
					/* displayed in a GUI */
/*
 * Super-user changeable flags.
 */
public static final int SF_SETTABLE =	0xffff0000;	/* mask of superuser changeable flags */
public static final int SF_ARCHIVED =	0x00010000;	/* file is archived */
public static final int SF_IMMUTABLE =	0x00020000;	/* file may not be changed */
public static final int SF_APPEND =	0x00040000;	/* writes to file may only append */
public static final int SF_RESTRICTED =	0x00080000;	/* restricted access */

/*
 * The following two bits are reserved for FreeBSD.  They are not
 * implemented in Mac OS X.
 */
/* #define SF_NOUNLINK	0x00100000 */	/* file may not be removed or renamed */
/* #define SF_SNAPSHOT	0x00200000 */	/* snapshot inode */
/* NOTE: There is no SF_HIDDEN bit. */

// #endif


/* [XSI] */
public static native int chmod(@Cast("const char*") BytePointer arg0, @Cast("mode_t") short arg1);
public static native int chmod(String arg0, @Cast("mode_t") short arg1);
public static native int fchmod(int arg0, @Cast("mode_t") short arg1);
public static native int fstat(int arg0, stat arg1);
public static native int lstat(@Cast("const char*") BytePointer arg0, stat arg1);
public static native int lstat(String arg0, stat arg1);
public static native int mkdir(@Cast("const char*") BytePointer arg0, @Cast("mode_t") short arg1);
public static native int mkdir(String arg0, @Cast("mode_t") short arg1);
public static native int mkfifo(@Cast("const char*") BytePointer arg0, @Cast("mode_t") short arg1);
public static native int mkfifo(String arg0, @Cast("mode_t") short arg1);
public static native int stat(@Cast("const char*") BytePointer arg0, stat arg1);
public static native int stat(String arg0, stat arg1);
public static native int mknod(@Cast("const char*") BytePointer arg0, @Cast("mode_t") short arg1, @Cast("dev_t") int arg2);
public static native int mknod(String arg0, @Cast("mode_t") short arg1, @Cast("dev_t") int arg2);
public static native @Cast("mode_t") short umask(@Cast("mode_t") short arg0);

// #if __DARWIN_C_LEVEL >= 200809L
public static native int fchmodat(int arg0, @Cast("const char*") BytePointer arg1, @Cast("mode_t") short arg2, int arg3);
public static native int fchmodat(int arg0, String arg1, @Cast("mode_t") short arg2, int arg3);
public static native int fstatat(int arg0, @Cast("const char*") BytePointer arg1, stat arg2, int arg3);
public static native int fstatat(int arg0, String arg1, stat arg2, int arg3);
public static native int mkdirat(int arg0, @Cast("const char*") BytePointer arg1, @Cast("mode_t") short arg2);
public static native int mkdirat(int arg0, String arg1, @Cast("mode_t") short arg2);
// #endif

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)

// #include <sys/_types/_filesec_t.h>

public static native int chflags(@Cast("const char*") BytePointer arg0, @Cast("__uint32_t") int arg1);
public static native int chflags(String arg0, @Cast("__uint32_t") int arg1);
public static native int chmodx_np(@Cast("const char*") BytePointer arg0, _filesec arg1);
public static native int chmodx_np(String arg0, _filesec arg1);
public static native int fchflags(int arg0, @Cast("__uint32_t") int arg1);
public static native int fchmodx_np(int arg0, _filesec arg1);
public static native int fstatx_np(int arg0, stat arg1, _filesec arg2);
public static native int lchflags(@Cast("const char*") BytePointer arg0, @Cast("__uint32_t") int arg1);
public static native int lchflags(String arg0, @Cast("__uint32_t") int arg1);
public static native int lchmod(@Cast("const char*") BytePointer arg0, @Cast("mode_t") short arg1);
public static native int lchmod(String arg0, @Cast("mode_t") short arg1);
public static native int lstatx_np(@Cast("const char*") BytePointer arg0, stat arg1, _filesec arg2);
public static native int lstatx_np(String arg0, stat arg1, _filesec arg2);
public static native int mkdirx_np(@Cast("const char*") BytePointer arg0, _filesec arg1);
public static native int mkdirx_np(String arg0, _filesec arg1);
public static native int mkfifox_np(@Cast("const char*") BytePointer arg0, _filesec arg1);
public static native int mkfifox_np(String arg0, _filesec arg1);
public static native int statx_np(@Cast("const char*") BytePointer arg0, stat arg1, _filesec arg2);
public static native int statx_np(String arg0, stat arg1, _filesec arg2);
public static native int umaskx_np(_filesec arg0);

// #if !__DARWIN_ONLY_64_BIT_INO_T
/* The following deprecated routines are simillar to stat and friends except provide struct stat64 instead of struct stat  */
public static native int fstatx64_np(int arg0, stat64 arg1, _filesec arg2);
public static native int lstatx64_np(@Cast("const char*") BytePointer arg0, stat64 arg1, _filesec arg2);
public static native int lstatx64_np(String arg0, stat64 arg1, _filesec arg2);
public static native int statx64_np(@Cast("const char*") BytePointer arg0, stat64 arg1, _filesec arg2);
public static native int statx64_np(String arg0, stat64 arg1, _filesec arg2);
public static native int fstat64(int arg0, stat64 arg1);
public static native int lstat64(@Cast("const char*") BytePointer arg0, stat64 arg1);
public static native int lstat64(String arg0, stat64 arg1);
public static native int stat64(@Cast("const char*") BytePointer arg0, stat64 arg1);
public static native int stat64(String arg0, stat64 arg1);
// #endif /* !__DARWIN_ONLY_64_BIT_INO_T */
// #endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

// #endif /* !_SYS_STAT_H_ */


// Parsed from fcntl.h

/*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
// #include <sys/fcntl.h>


// Parsed from sys/file.h

/*
 * Copyright (c) 2000-2008 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995, 1997 Apple Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)file.h	8.3 (Berkeley) 1/9/95
 */

// #ifndef _SYS_FILE_H_
// #define	_SYS_FILE_H_

// #include <sys/appleapiopts.h>
// #include <sys/types.h>
// #include <sys/fcntl.h>
// #include <sys/unistd.h>
// #include <sys/queue.h>
// #include <sys/cdefs.h>


// #ifndef _KAUTH_CRED_T
// #define	_KAUTH_CRED_T
@Opaque public static class ucred extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ucred() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ucred(Pointer p) { super(p); }
}
@Opaque public static class posix_cred extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public posix_cred() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public posix_cred(Pointer p) { super(p); }
}
// #endif	/* !_KAUTH_CRED_T */

// #endif /* !_SYS_FILE_H_ */


// Parsed from grp.h

/*-
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)grp.h	8.2 (Berkeley) 1/21/94
 */
/* Portions copyright (c) 2000-2011 Apple Inc. All rights reserved. */ 

// #ifndef _GRP_H_
// #define	_GRP_H_

// #include <_types.h>
// #include <sys/_types/_gid_t.h>	/* [XBD] */
// #include <sys/_types/_size_t.h> /* SUSv4 */

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final String _PATH_GROUP =		"/etc/group";
// #endif

public static class group extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public group() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public group(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public group(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public group position(long position) {
        return (group)super.position(position);
    }

	public native @Cast("char*") BytePointer gr_name(); public native group gr_name(BytePointer gr_name);		/* [XBD] group name */
	public native @Cast("char*") BytePointer gr_passwd(); public native group gr_passwd(BytePointer gr_passwd);		/* [???] group password */
	public native @Cast("gid_t") int gr_gid(); public native group gr_gid(int gr_gid);			/* [XBD] group id */
	public native @Cast("char*") BytePointer gr_mem(int i); public native group gr_mem(int i, BytePointer gr_mem);
	public native @Cast("char**") PointerPointer gr_mem(); public native group gr_mem(PointerPointer gr_mem);		/* [XBD] group members */
}

// #include <sys/cdefs.h>

/* [XBD] */
public static native group getgrgid(@Cast("gid_t") int arg0);
public static native group getgrnam(@Cast("const char*") BytePointer arg0);
public static native group getgrnam(String arg0);
/* [TSF] */
public static native int getgrgid_r(@Cast("gid_t") int arg0, group arg1, @Cast("char*") BytePointer arg2, @Cast("size_t") long arg3, @Cast("group**") PointerPointer arg4);
public static native int getgrgid_r(@Cast("gid_t") int arg0, group arg1, @Cast("char*") BytePointer arg2, @Cast("size_t") long arg3, @ByPtrPtr group arg4);
public static native int getgrgid_r(@Cast("gid_t") int arg0, group arg1, @Cast("char*") ByteBuffer arg2, @Cast("size_t") long arg3, @ByPtrPtr group arg4);
public static native int getgrgid_r(@Cast("gid_t") int arg0, group arg1, @Cast("char*") byte[] arg2, @Cast("size_t") long arg3, @ByPtrPtr group arg4);
public static native int getgrnam_r(@Cast("const char*") BytePointer arg0, group arg1, @Cast("char*") BytePointer arg2, @Cast("size_t") long arg3, @Cast("group**") PointerPointer arg4);
public static native int getgrnam_r(@Cast("const char*") BytePointer arg0, group arg1, @Cast("char*") BytePointer arg2, @Cast("size_t") long arg3, @ByPtrPtr group arg4);
public static native int getgrnam_r(String arg0, group arg1, @Cast("char*") ByteBuffer arg2, @Cast("size_t") long arg3, @ByPtrPtr group arg4);
public static native int getgrnam_r(@Cast("const char*") BytePointer arg0, group arg1, @Cast("char*") byte[] arg2, @Cast("size_t") long arg3, @ByPtrPtr group arg4);
public static native int getgrnam_r(String arg0, group arg1, @Cast("char*") BytePointer arg2, @Cast("size_t") long arg3, @ByPtrPtr group arg4);
public static native int getgrnam_r(@Cast("const char*") BytePointer arg0, group arg1, @Cast("char*") ByteBuffer arg2, @Cast("size_t") long arg3, @ByPtrPtr group arg4);
public static native int getgrnam_r(String arg0, group arg1, @Cast("char*") byte[] arg2, @Cast("size_t") long arg3, @ByPtrPtr group arg4);
/* [XSI] */
public static native group getgrent();
public static native void setgrent();
public static native void endgrent();
// #if (!defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE)) || defined(_DARWIN_C_SOURCE)
// #include <uuid/uuid.h>
public static native @Cast("char*") BytePointer group_from_gid(@Cast("gid_t") int arg0, int arg1);
public static native group getgruuid(@Cast("unsigned char*") BytePointer arg0);
public static native group getgruuid(@Cast("unsigned char*") ByteBuffer arg0);
public static native group getgruuid(@Cast("unsigned char*") byte[] arg0);
public static native int getgruuid_r(@Cast("unsigned char*") BytePointer arg0, group arg1, @Cast("char*") BytePointer arg2, @Cast("size_t") long arg3, @Cast("group**") PointerPointer arg4);
public static native int getgruuid_r(@Cast("unsigned char*") BytePointer arg0, group arg1, @Cast("char*") BytePointer arg2, @Cast("size_t") long arg3, @ByPtrPtr group arg4);
public static native int getgruuid_r(@Cast("unsigned char*") ByteBuffer arg0, group arg1, @Cast("char*") ByteBuffer arg2, @Cast("size_t") long arg3, @ByPtrPtr group arg4);
public static native int getgruuid_r(@Cast("unsigned char*") byte[] arg0, group arg1, @Cast("char*") byte[] arg2, @Cast("size_t") long arg3, @ByPtrPtr group arg4);
// #endif

// #if !defined(_XOPEN_SOURCE) || defined(_DARWIN_C_SOURCE)
public static native void setgrfile(@Cast("const char*") BytePointer arg0);
public static native void setgrfile(String arg0);
public static native int setgroupent(int arg0);
// #endif

// #endif /* !_GRP_H_ */


// Parsed from pwd.h

/*-
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 * Portions Copyright(C) 1995, Jason Downs.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)pwd.h	8.2 (Berkeley) 1/21/94
 */
/* Portions copyright (c) 2000-2011 Apple Inc. All rights reserved. */

// #ifndef _PWD_H_
// #define	_PWD_H_

// #include <_types.h>
// #include <sys/_types/_gid_t.h>
// #include <sys/_types/_size_t.h>
// #include <sys/_types/_uid_t.h>

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final String _PATH_PWD =		"/etc";
public static final String _PATH_PASSWD =		"/etc/passwd";
public static final String _PASSWD =			"passwd";
public static final String _PATH_MASTERPASSWD =	"/etc/master.passwd";
public static final String _PATH_MASTERPASSWD_LOCK =	"/etc/ptmp";
public static final String _MASTERPASSWD =		"master.passwd";

public static final String _PATH_MP_DB =		"/etc/pwd.db";
public static final String _MP_DB =			"pwd.db";
public static final String _PATH_SMP_DB =		"/etc/spwd.db";
public static final String _SMP_DB =			"spwd.db";

public static final String _PATH_PWD_MKDB =		"/usr/sbin/pwd_mkdb";

public static final int _PW_KEYBYNAME =		'1';	/* stored by name */
public static final int _PW_KEYBYNUM =		'2';	/* stored by entry in the "file" */
public static final int _PW_KEYBYUID =		'3';	/* stored by uid */

public static final int _PASSWORD_EFMT1 =		'_';	/* extended encryption format */

public static final int _PASSWORD_LEN =		128;	/* max length, not counting NULL */

public static final int _PASSWORD_NOUID =		0x01;	/* flag for no specified uid. */
public static final int _PASSWORD_NOGID =		0x02;	/* flag for no specified gid. */
public static final int _PASSWORD_NOCHG =		0x04;	/* flag for no specified change. */
public static final int _PASSWORD_NOEXP =		0x08;	/* flag for no specified expire. */

public static final int _PASSWORD_WARNDAYS =	14;	/* days to warn about expiry */
public static final int _PASSWORD_CHGNOW =	-1;	/* special day to force password
					 * change at next login */
// #endif

public static class passwd extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public passwd() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public passwd(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public passwd(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public passwd position(long position) {
        return (passwd)super.position(position);
    }

	public native @Cast("char*") BytePointer pw_name(); public native passwd pw_name(BytePointer pw_name);		/* user name */
	public native @Cast("char*") BytePointer pw_passwd(); public native passwd pw_passwd(BytePointer pw_passwd);		/* encrypted password */
	public native @Cast("uid_t") int pw_uid(); public native passwd pw_uid(int pw_uid);			/* user uid */
	public native @Cast("gid_t") int pw_gid(); public native passwd pw_gid(int pw_gid);			/* user gid */
	public native @Cast("__darwin_time_t") long pw_change(); public native passwd pw_change(long pw_change);		/* password change time */
	public native @Cast("char*") BytePointer pw_class(); public native passwd pw_class(BytePointer pw_class);		/* user access class */
	public native @Cast("char*") BytePointer pw_gecos(); public native passwd pw_gecos(BytePointer pw_gecos);		/* Honeywell login info */
	public native @Cast("char*") BytePointer pw_dir(); public native passwd pw_dir(BytePointer pw_dir);		/* home directory */
	public native @Cast("char*") BytePointer pw_shell(); public native passwd pw_shell(BytePointer pw_shell);		/* default shell */
	public native @Cast("__darwin_time_t") long pw_expire(); public native passwd pw_expire(long pw_expire);		/* account expiration */
}

// #include <sys/cdefs.h>

public static native passwd getpwuid(@Cast("uid_t") int arg0);
public static native passwd getpwnam(@Cast("const char*") BytePointer arg0);
public static native passwd getpwnam(String arg0);
public static native int getpwuid_r(@Cast("uid_t") int arg0, passwd arg1, @Cast("char*") BytePointer arg2, @Cast("size_t") long arg3, @Cast("passwd**") PointerPointer arg4);
public static native int getpwuid_r(@Cast("uid_t") int arg0, passwd arg1, @Cast("char*") BytePointer arg2, @Cast("size_t") long arg3, @ByPtrPtr passwd arg4);
public static native int getpwuid_r(@Cast("uid_t") int arg0, passwd arg1, @Cast("char*") ByteBuffer arg2, @Cast("size_t") long arg3, @ByPtrPtr passwd arg4);
public static native int getpwuid_r(@Cast("uid_t") int arg0, passwd arg1, @Cast("char*") byte[] arg2, @Cast("size_t") long arg3, @ByPtrPtr passwd arg4);
public static native int getpwnam_r(@Cast("const char*") BytePointer arg0, passwd arg1, @Cast("char*") BytePointer arg2, @Cast("size_t") long arg3, @Cast("passwd**") PointerPointer arg4);
public static native int getpwnam_r(@Cast("const char*") BytePointer arg0, passwd arg1, @Cast("char*") BytePointer arg2, @Cast("size_t") long arg3, @ByPtrPtr passwd arg4);
public static native int getpwnam_r(String arg0, passwd arg1, @Cast("char*") ByteBuffer arg2, @Cast("size_t") long arg3, @ByPtrPtr passwd arg4);
public static native int getpwnam_r(@Cast("const char*") BytePointer arg0, passwd arg1, @Cast("char*") byte[] arg2, @Cast("size_t") long arg3, @ByPtrPtr passwd arg4);
public static native int getpwnam_r(String arg0, passwd arg1, @Cast("char*") BytePointer arg2, @Cast("size_t") long arg3, @ByPtrPtr passwd arg4);
public static native int getpwnam_r(@Cast("const char*") BytePointer arg0, passwd arg1, @Cast("char*") ByteBuffer arg2, @Cast("size_t") long arg3, @ByPtrPtr passwd arg4);
public static native int getpwnam_r(String arg0, passwd arg1, @Cast("char*") byte[] arg2, @Cast("size_t") long arg3, @ByPtrPtr passwd arg4);
public static native passwd getpwent();
public static native void setpwent();
public static native void endpwent();
// #if (!defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE)) || defined(_DARWIN_C_SOURCE)
// #include <uuid/uuid.h>
public static native int setpassent(int arg0);
public static native @Cast("char*") BytePointer user_from_uid(@Cast("uid_t") int arg0, int arg1);
public static native passwd getpwuuid(@Cast("unsigned char*") BytePointer arg0);
public static native passwd getpwuuid(@Cast("unsigned char*") ByteBuffer arg0);
public static native passwd getpwuuid(@Cast("unsigned char*") byte[] arg0);
public static native int getpwuuid_r(@Cast("unsigned char*") BytePointer arg0, passwd arg1, @Cast("char*") BytePointer arg2, @Cast("size_t") long arg3, @Cast("passwd**") PointerPointer arg4);
public static native int getpwuuid_r(@Cast("unsigned char*") BytePointer arg0, passwd arg1, @Cast("char*") BytePointer arg2, @Cast("size_t") long arg3, @ByPtrPtr passwd arg4);
public static native int getpwuuid_r(@Cast("unsigned char*") ByteBuffer arg0, passwd arg1, @Cast("char*") ByteBuffer arg2, @Cast("size_t") long arg3, @ByPtrPtr passwd arg4);
public static native int getpwuuid_r(@Cast("unsigned char*") byte[] arg0, passwd arg1, @Cast("char*") byte[] arg2, @Cast("size_t") long arg3, @ByPtrPtr passwd arg4);
// #endif

// #endif /* !_PWD_H_ */


// Parsed from sys/_types/_sigaltstack.h

/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/* Structure used in sigaltstack call. */
// #ifndef _STRUCT_SIGALTSTACK
// #if __DARWIN_UNIX03
// #define _STRUCT_SIGALTSTACK	struct __darwin_sigaltstack
// #else /* !__DARWIN_UNIX03 */
// #endif /* __DARWIN_UNIX03 */
@Name("__darwin_sigaltstack") public static class stack_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public stack_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public stack_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public stack_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public stack_t position(long position) {
        return (stack_t)super.position(position);
    }

	public native Pointer ss_sp(); public native stack_t ss_sp(Pointer ss_sp);	        /* signal stack base */
	public native @Cast("__darwin_size_t") long ss_size(); public native stack_t ss_size(long ss_size);        /* signal stack length */
	public native int ss_flags(); public native stack_t ss_flags(int ss_flags);       /* SA_DISABLE and/or SA_ONSTACK */
} /* [???] signal stack */

// #endif /* _STRUCT_SIGALTSTACK */


// Parsed from sys/signal.h

/*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)signal.h	8.2 (Berkeley) 1/21/94
 */

// #ifndef	_SYS_SIGNAL_H_
// #define	_SYS_SIGNAL_H_

// #include <sys/cdefs.h>
// #include <sys/appleapiopts.h>

public static final int __DARWIN_NSIG =	32;	/* counting 0; could be 33 (mask is 1-32) */

// #if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
public static native @MemberGetter long NSIG();
public static final long NSIG = NSIG();
// #endif

// #include <machine/signal.h>	/* sigcontext; codes for SIGILL, SIGFPE */

public static final int SIGHUP =	1;	/* hangup */
public static final int SIGINT =	2;	/* interrupt */
public static final int SIGQUIT =	3;	/* quit */
public static final int SIGILL =	4;	/* illegal instruction (not reset when caught) */
public static final int SIGTRAP =	5;	/* trace trap (not reset when caught) */
public static final int SIGABRT =	6;	/* abort() */
// #if  (defined(_POSIX_C_SOURCE) && !defined(_DARWIN_C_SOURCE))
public static final int SIGPOLL =	7;	/* pollable event ([XSR] generated, not supported) */
// #else	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int SIGIOT =	SIGABRT;	/* compatibility */
public static final int SIGEMT =	7;	/* EMT instruction */
// #endif	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
public static final int SIGFPE =	8;	/* floating point exception */
public static final int SIGKILL =	9;	/* kill (cannot be caught or ignored) */
public static final int SIGBUS =	10;	/* bus error */
public static final int SIGSEGV =	11;	/* segmentation violation */
public static final int SIGSYS =	12;	/* bad argument to system call */
public static final int SIGPIPE =	13;	/* write on a pipe with no one to read it */
public static final int SIGALRM =	14;	/* alarm clock */
public static final int SIGTERM =	15;	/* software termination signal from kill */
public static final int SIGURG =	16;	/* urgent condition on IO channel */
public static final int SIGSTOP =	17;	/* sendable stop signal not from tty */
public static final int SIGTSTP =	18;	/* stop signal from tty */
public static final int SIGCONT =	19;	/* continue a stopped process */
public static final int SIGCHLD =	20;	/* to parent on child stop or exit */
public static final int SIGTTIN =	21;	/* to readers pgrp upon background tty read */
public static final int SIGTTOU =	22;	/* like TTIN for output if (tp->t_local&LTOSTOP) */
// #if  (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
public static final int SIGIO =	23;	/* input/output possible signal */
// #endif
public static final int SIGXCPU =	24;	/* exceeded CPU time limit */
public static final int SIGXFSZ =	25;	/* exceeded file size limit */
public static final int SIGVTALRM = 26;	/* virtual time alarm */
public static final int SIGPROF =	27;	/* profiling time alarm */
// #if  (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
public static final int SIGWINCH = 28;	/* window size changes */
public static final int SIGINFO =	29;	/* information request */
// #endif
public static final int SIGUSR1 = 30;	/* user defined signal 1 */
public static final int SIGUSR2 = 31;	/* user defined signal 2 */

// #if defined(_ANSI_SOURCE) || __DARWIN_UNIX03 || defined(__cplusplus)
/*
 * Language spec sez we must list exactly one parameter, even though we
 * actually supply three.  Ugh!
 * SIG_HOLD is chosen to avoid KERN_SIG_* values in <sys/signalvar.h>
 */
@Cast("void*") public static native @MemberGetter Pointer SIG_DFL();
public static final Pointer SIG_DFL = SIG_DFL();
@Cast("void*") public static native @MemberGetter Pointer SIG_IGN();
public static final Pointer SIG_IGN = SIG_IGN();
@Cast("void*") public static native @MemberGetter Pointer SIG_HOLD();
public static final Pointer SIG_HOLD = SIG_HOLD();
@Cast("void*") public static native @MemberGetter Pointer SIG_ERR();
public static final Pointer SIG_ERR = SIG_ERR();
// #else
/* DO NOT REMOVE THE COMMENTED OUT int: fixincludes needs to see them */
// #endif

// #ifndef _ANSI_SOURCE
// #include <sys/_types.h>

// #include <machine/_mcontext.h>

// #include <sys/_pthread/_pthread_attr_t.h>

// #include <sys/_types/_sigaltstack.h>
// #include <sys/_types/_ucontext.h>

// #include <sys/_types/_pid_t.h>
// #include <sys/_types/_sigset_t.h>
// #include <sys/_types/_size_t.h>
// #include <sys/_types/_uid_t.h>

public static class sigval extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public sigval() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public sigval(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public sigval(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public sigval position(long position) {
        return (sigval)super.position(position);
    }

	/* Members as suggested by Annex C of POSIX 1003.1b. */
	public native int sival_int(); public native sigval sival_int(int sival_int);
	public native Pointer sival_ptr(); public native sigval sival_ptr(Pointer sival_ptr);
}

public static final int SIGEV_NONE =	0;	/* No async notification */
public static final int SIGEV_SIGNAL =	1;	/* aio - completion notification */
public static final int SIGEV_THREAD =	3;	/* [NOTIMP] [RTS] call notification function */

public static class sigevent extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public sigevent() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public sigevent(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public sigevent(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public sigevent position(long position) {
        return (sigevent)super.position(position);
    }

	public native int sigev_notify(); public native sigevent sigev_notify(int sigev_notify);				/* Notification type */
	public native int sigev_signo(); public native sigevent sigev_signo(int sigev_signo);				/* Signal number */
	public native @ByRef sigval sigev_value(); public native sigevent sigev_value(sigval sigev_value);				/* Signal value */
	public static class Sigev_notify_function_sigval extends FunctionPointer {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public    Sigev_notify_function_sigval(Pointer p) { super(p); }
	    protected Sigev_notify_function_sigval() { allocate(); }
	    private native void allocate();
	    public native void call(@ByVal sigval arg0);
	}
	public native Sigev_notify_function_sigval sigev_notify_function(); public native sigevent sigev_notify_function(Sigev_notify_function_sigval sigev_notify_function);	  /* Notification function */
	public native @Cast("pthread_attr_t*") Pointer sigev_notify_attributes(); public native sigevent sigev_notify_attributes(Pointer sigev_notify_attributes);	/* Notification attributes */
}


public static class siginfo_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public siginfo_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public siginfo_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public siginfo_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public siginfo_t position(long position) {
        return (siginfo_t)super.position(position);
    }

	public native int si_signo(); public native siginfo_t si_signo(int si_signo);		/* signal number */
	public native int si_errno(); public native siginfo_t si_errno(int si_errno);		/* errno association */
	public native int si_code(); public native siginfo_t si_code(int si_code);		/* signal code */
	public native @Cast("pid_t") int si_pid(); public native siginfo_t si_pid(int si_pid);			/* sending process */
	public native @Cast("uid_t") int si_uid(); public native siginfo_t si_uid(int si_uid);			/* sender's ruid */
	public native int si_status(); public native siginfo_t si_status(int si_status);		/* exit value */
	public native Pointer si_addr(); public native siginfo_t si_addr(Pointer si_addr);		/* faulting instruction */
	public native @ByRef sigval si_value(); public native siginfo_t si_value(sigval si_value);		/* signal value */
	public native long si_band(); public native siginfo_t si_band(long si_band);		/* band event for SIGPOLL */
	public native @Cast("unsigned long") long __pad(int i); public native siginfo_t __pad(int i, long __pad);
	@MemberGetter public native @Cast("unsigned long*") CLongPointer __pad();	/* Reserved for Future Use */
}


/* 
 * When the signal is SIGILL or SIGFPE, si_addr contains the address of 
 * the faulting instruction.
 * When the signal is SIGSEGV or SIGBUS, si_addr contains the address of 
 * the faulting memory reference. Although for x86 there are cases of SIGSEGV
 * for which si_addr cannot be determined and is NULL. 
 * If the signal is SIGCHLD, the si_pid field will contain the child process ID,
 *  si_status contains the exit value or signal and
 *  si_uid contains the real user ID of the process that sent the signal.
 */

/* Values for si_code */

/* Codes for SIGILL */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int ILL_NOOP =	0;	/* if only I knew... */
// #endif
public static final int ILL_ILLOPC =	1;	/* [XSI] illegal opcode */
public static final int ILL_ILLTRP =	2;	/* [XSI] illegal trap */
public static final int ILL_PRVOPC =	3;	/* [XSI] privileged opcode */
public static final int ILL_ILLOPN =	4;	/* [XSI] illegal operand -NOTIMP */
public static final int ILL_ILLADR =	5;	/* [XSI] illegal addressing mode -NOTIMP */
public static final int ILL_PRVREG =	6;	/* [XSI] privileged register -NOTIMP */
public static final int ILL_COPROC =	7;	/* [XSI] coprocessor error -NOTIMP */
public static final int ILL_BADSTK =	8;	/* [XSI] internal stack error -NOTIMP */

/* Codes for SIGFPE */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int FPE_NOOP =	0;	/* if only I knew... */
// #endif
public static final int FPE_FLTDIV =	1;	/* [XSI] floating point divide by zero */
public static final int FPE_FLTOVF =	2;	/* [XSI] floating point overflow */
public static final int FPE_FLTUND =	3;	/* [XSI] floating point underflow */
public static final int FPE_FLTRES =	4;	/* [XSI] floating point inexact result */
public static final int FPE_FLTINV =	5;	/* [XSI] invalid floating point operation */
public static final int FPE_FLTSUB =	6;	/* [XSI] subscript out of range -NOTIMP */
public static final int FPE_INTDIV =	7;	/* [XSI] integer divide by zero */
public static final int FPE_INTOVF =	8;	/* [XSI] integer overflow */

/* Codes for SIGSEGV */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SEGV_NOOP =	0;	/* if only I knew... */
// #endif
public static final int SEGV_MAPERR =	1;	/* [XSI] address not mapped to object */
public static final int SEGV_ACCERR =	2;	/* [XSI] invalid permission for mapped object */

/* Codes for SIGBUS */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int BUS_NOOP =	0;	/* if only I knew... */
// #endif
public static final int BUS_ADRALN =	1;	/* [XSI] Invalid address alignment */
public static final int BUS_ADRERR =	2;	/* [XSI] Nonexistent physical address -NOTIMP */
public static final int BUS_OBJERR =	3;	/* [XSI] Object-specific HW error - NOTIMP */

/* Codes for SIGTRAP */
public static final int TRAP_BRKPT =	1;	/* [XSI] Process breakpoint -NOTIMP */
public static final int TRAP_TRACE =	2;	/* [XSI] Process trace trap -NOTIMP */

/* Codes for SIGCHLD */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int CLD_NOOP =	0;	/* if only I knew... */
// #endif
public static final int CLD_EXITED =	1;	/* [XSI] child has exited */
public static final int CLD_KILLED =	2;	/* [XSI] terminated abnormally, no core file */
public static final int CLD_DUMPED =	3;	/* [XSI] terminated abnormally, core file */
public static final int CLD_TRAPPED =	4;	/* [XSI] traced child has trapped */
public static final int CLD_STOPPED =	5;	/* [XSI] child has stopped */
public static final int CLD_CONTINUED =	6;	/* [XSI] stopped child has continued */

/* Codes for SIGPOLL */
public static final int POLL_IN =		1;	/* [XSR] Data input available */
public static final int POLL_OUT =	2;	/* [XSR] Output buffers available */
public static final int POLL_MSG =	3;	/* [XSR] Input message available */
public static final int POLL_ERR =	4;	/* [XSR] I/O error */
public static final int POLL_PRI =	5;	/* [XSR] High priority input available */
public static final int POLL_HUP =	6;	/* [XSR] Device disconnected */

/* union for signal handlers */
public static class __sigaction_u extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public __sigaction_u() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public __sigaction_u(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public __sigaction_u(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public __sigaction_u position(long position) {
        return (__sigaction_u)super.position(position);
    }

	public static class __sa_handler_int extends FunctionPointer {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public    __sa_handler_int(Pointer p) { super(p); }
	    protected __sa_handler_int() { allocate(); }
	    private native void allocate();
	    public native void call(int arg0);
	}
	public native __sa_handler_int __sa_handler(); public native __sigaction_u __sa_handler(__sa_handler_int __sa_handler);
	public static class __sa_sigaction_int_siginfo_t_Pointer extends FunctionPointer {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public    __sa_sigaction_int_siginfo_t_Pointer(Pointer p) { super(p); }
	    protected __sa_sigaction_int_siginfo_t_Pointer() { allocate(); }
	    private native void allocate();
	    public native void call(int arg0, siginfo_t arg1,
			       Pointer arg2);
	}
	public native __sa_sigaction_int_siginfo_t_Pointer __sa_sigaction(); public native __sigaction_u __sa_sigaction(__sa_sigaction_int_siginfo_t_Pointer __sa_sigaction);
}

/* Signal vector template for Kernel user boundary */
public static class __sigaction extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public __sigaction() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public __sigaction(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public __sigaction(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public __sigaction position(long position) {
        return (__sigaction)super.position(position);
    }

	public native @ByRef __sigaction_u __sigaction_u(); public native __sigaction __sigaction_u(__sigaction_u __sigaction_u);  /* signal handler */
	public static class Sa_tramp_Pointer_int_int_siginfo_t_Pointer extends FunctionPointer {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public    Sa_tramp_Pointer_int_int_siginfo_t_Pointer(Pointer p) { super(p); }
	    protected Sa_tramp_Pointer_int_int_siginfo_t_Pointer() { allocate(); }
	    private native void allocate();
	    public native void call(Pointer arg0, int arg1, int arg2, siginfo_t arg3, Pointer arg4);
	}
	public native Sa_tramp_Pointer_int_int_siginfo_t_Pointer sa_tramp(); public native __sigaction sa_tramp(Sa_tramp_Pointer_int_int_siginfo_t_Pointer sa_tramp);
	public native @Cast("sigset_t") int sa_mask(); public native __sigaction sa_mask(int sa_mask);		/* signal mask to apply */
	public native int sa_flags(); public native __sigaction sa_flags(int sa_flags);		/* see signal options below */
}

/*
 * Signal vector "template" used in sigaction call.
 */
@Name("struct sigaction") public static class sigaction extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public sigaction() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public sigaction(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public sigaction(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public sigaction position(long position) {
        return (sigaction)super.position(position);
    }

	public native @ByRef __sigaction_u __sigaction_u(); public native sigaction __sigaction_u(__sigaction_u __sigaction_u);  /* signal handler */
	public native @Cast("sigset_t") int sa_mask(); public native sigaction sa_mask(int sa_mask);		/* signal mask to apply */
	public native int sa_flags(); public native sigaction sa_flags(int sa_flags);		/* see signal options below */
}



/* if SA_SIGINFO is set, sa_sigaction is to be used instead of sa_handler. */

public static final int SA_ONSTACK =	0x0001;	/* take signal on signal stack */
public static final int SA_RESTART =	0x0002;	/* restart system on signal return */
public static final int SA_RESETHAND =	0x0004;	/* reset to SIG_DFL when taking signal */
public static final int SA_NOCLDSTOP =	0x0008;	/* do not generate SIGCHLD on child stop */
public static final int SA_NODEFER =	0x0010;	/* don't mask the signal we're delivering */
public static final int SA_NOCLDWAIT =	0x0020;	/* don't keep zombies around */
public static final int SA_SIGINFO =	0x0040;	/* signal handler with SA_SIGINFO args */
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int SA_USERTRAMP =	0x0100;	/* do not bounce off kernel's sigtramp */
/* This will provide 64bit register set in a 32bit user address space */
public static final int SA_64REGSET =	0x0200;	/* signal handler with SA_SIGINFO args with 64bit regs information */
// #endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/* the following are the only bits we support from user space, the 
 * rest are for kernel use only.
 */
public static final int SA_USERSPACE_MASK = (SA_ONSTACK | SA_RESTART | SA_RESETHAND | SA_NOCLDSTOP | SA_NODEFER | SA_NOCLDWAIT | SA_SIGINFO);

/*
 * Flags for sigprocmask:
 */
public static final int SIG_BLOCK =	1;	/* block specified signal set */
public static final int SIG_UNBLOCK =	2;	/* unblock specified signal set */
public static final int SIG_SETMASK =	3;	/* set specified signal set */

/* POSIX 1003.1b required values. */
public static final int SI_USER =		0x10001;	/* [CX] signal from kill() */
public static final int SI_QUEUE =	0x10002;	/* [CX] signal from sigqueue() */
public static final int SI_TIMER =	0x10003;	/* [CX] timer expiration */
public static final int SI_ASYNCIO =	0x10004;	/* [CX] aio request completion */
public static final int SI_MESGQ =	0x10005;	/* [CX]	from message arrival on empty queue */

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static class sig_t extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    sig_t(Pointer p) { super(p); }
    protected sig_t() { allocate(); }
    private native void allocate();
    public native void call(int arg0);
}	/* type of signal function */
// #endif

/*
 * Structure used in sigaltstack call.
 */

public static final int SS_ONSTACK =	0x0001;	/* take signal on signal stack */
public static final int SS_DISABLE =	0x0004;	/* disable taking signals on alternate stack */
public static final int MINSIGSTKSZ =	32768;	/* (32K)minimum allowable stack */
public static final int SIGSTKSZ =	131072;	/* (128K)recommended stack size */

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/*
 * 4.3 compatibility:
 * Signal vector "template" used in sigvec call.
 */
@Name("struct sigvec") public static class sigvec extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public sigvec() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public sigvec(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public sigvec(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public sigvec position(long position) {
        return (sigvec)super.position(position);
    }

	public static class Sv_handler_int extends FunctionPointer {
	    static { Loader.load(); }
	    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
	    public    Sv_handler_int(Pointer p) { super(p); }
	    protected Sv_handler_int() { allocate(); }
	    private native void allocate();
	    public native void call(int arg0);
	}
	public native Sv_handler_int sv_handler(); public native sigvec sv_handler(Sv_handler_int sv_handler);	/* signal handler */
	public native int sv_mask(); public native sigvec sv_mask(int sv_mask);		/* signal mask to apply */
	public native int sv_flags(); public native sigvec sv_flags(int sv_flags);		/* see signal options below */
}

public static final int SV_ONSTACK =	SA_ONSTACK;
public static final int SV_INTERRUPT =	SA_RESTART;	/* same bit, opposite sense */
public static final int SV_RESETHAND =	SA_RESETHAND;
public static final int SV_NODEFER =	SA_NODEFER;
public static final int SV_NOCLDSTOP =	SA_NOCLDSTOP;
public static final int SV_SIGINFO =	SA_SIGINFO;

// #define sv_onstack sv_flags	/* isn't compatibility wonderful! */
// #endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * Structure used in sigstack call.
 */
public static class sigstack extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public sigstack() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public sigstack(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public sigstack(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public sigstack position(long position) {
        return (sigstack)super.position(position);
    }

	public native @Cast("char*") BytePointer ss_sp(); public native sigstack ss_sp(BytePointer ss_sp);			/* signal stack pointer */
	public native int ss_onstack(); public native sigstack ss_onstack(int ss_onstack);		/* current status */
}

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/*
 * Macro for converting signal number to a mask suitable for
 * sigblock().
 */
// #define sigmask(m)	(1 << ((m)-1))


@Cast("void*") public static native @MemberGetter Pointer BADSIG();
public static final Pointer BADSIG = BADSIG();

// #endif	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
// #endif	/* !_ANSI_SOURCE */

/*
 * For historical reasons; programs expect signal's return value to be
 * defined by <sys/signal.h>.
 */
public static class Arg1_int extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Arg1_int(Pointer p) { super(p); }
    protected Arg1_int() { allocate(); }
    private native void allocate();
    public native void call(int arg0);
}
public static native void signal(int arg0, Arg1_int arg1);
// #endif	/* !_SYS_SIGNAL_H_ */


// Parsed from signal.h

/*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)signal.h	8.3 (Berkeley) 3/30/94
 */

// #ifndef _USER_SIGNAL_H
// #define _USER_SIGNAL_H

// #include <sys/cdefs.h>
// #include <_types.h>
// #include <sys/signal.h>

// #include <sys/_pthread/_pthread_types.h>
// #include <sys/_pthread/_pthread_t.h>

// #if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
@MemberGetter public static native @Cast("const char*") BytePointer sys_signame(int i);
@MemberGetter public static native @Cast("const char*__const*") PointerPointer sys_signame();
@MemberGetter public static native @Cast("const char*") BytePointer sys_siglist(int i);
@MemberGetter public static native @Cast("const char*__const*") PointerPointer sys_siglist();
// #endif

public static native int raise(int arg0);
// #ifndef	_ANSI_SOURCE
public static native void bsd_signal(int arg0, Arg1_int arg1);
public static native int kill(@Cast("pid_t") int arg0, int arg1);
public static native int killpg(@Cast("pid_t") int arg0, int arg1);
public static native int pthread_kill(@ByVal @Cast("pthread_t*") Pointer arg0, int arg1);
public static native int pthread_sigmask(int arg0, @Cast("const sigset_t*") IntPointer arg1, @Cast("sigset_t*") IntPointer arg2);
public static native int pthread_sigmask(int arg0, @Cast("const sigset_t*") IntBuffer arg1, @Cast("sigset_t*") IntBuffer arg2);
public static native int pthread_sigmask(int arg0, @Cast("const sigset_t*") int[] arg1, @Cast("sigset_t*") int[] arg2);
public static native int sigaction(int arg0, @Const sigaction arg1,
	    sigaction arg2);
public static native int sigaddset(@Cast("sigset_t*") IntPointer arg0, int arg1);
public static native int sigaddset(@Cast("sigset_t*") IntBuffer arg0, int arg1);
public static native int sigaddset(@Cast("sigset_t*") int[] arg0, int arg1);
public static native int sigaltstack(@Const stack_t arg0, stack_t arg1);
public static native int sigdelset(@Cast("sigset_t*") IntPointer arg0, int arg1);
public static native int sigdelset(@Cast("sigset_t*") IntBuffer arg0, int arg1);
public static native int sigdelset(@Cast("sigset_t*") int[] arg0, int arg1);
public static native int sigemptyset(@Cast("sigset_t*") IntPointer arg0);
public static native int sigemptyset(@Cast("sigset_t*") IntBuffer arg0);
public static native int sigemptyset(@Cast("sigset_t*") int[] arg0);
public static native int sigfillset(@Cast("sigset_t*") IntPointer arg0);
public static native int sigfillset(@Cast("sigset_t*") IntBuffer arg0);
public static native int sigfillset(@Cast("sigset_t*") int[] arg0);
public static native int sighold(int arg0);
public static native int sigignore(int arg0);
public static native int siginterrupt(int arg0, int arg1);
public static native int sigismember(@Cast("const sigset_t*") IntPointer arg0, int arg1);
public static native int sigismember(@Cast("const sigset_t*") IntBuffer arg0, int arg1);
public static native int sigismember(@Cast("const sigset_t*") int[] arg0, int arg1);
public static native int sigpause(int arg0);
public static native int sigpending(@Cast("sigset_t*") IntPointer arg0);
public static native int sigpending(@Cast("sigset_t*") IntBuffer arg0);
public static native int sigpending(@Cast("sigset_t*") int[] arg0);
public static native int sigprocmask(int arg0, @Cast("const sigset_t*") IntPointer arg1, @Cast("sigset_t*") IntPointer arg2);
public static native int sigprocmask(int arg0, @Cast("const sigset_t*") IntBuffer arg1, @Cast("sigset_t*") IntBuffer arg2);
public static native int sigprocmask(int arg0, @Cast("const sigset_t*") int[] arg1, @Cast("sigset_t*") int[] arg2);
public static native int sigrelse(int arg0);
public static native void sigset(int arg0, Arg1_int arg1); 
public static native int sigsuspend(@Cast("const sigset_t*") IntPointer arg0);
public static native int sigsuspend(@Cast("const sigset_t*") IntBuffer arg0);
public static native int sigsuspend(@Cast("const sigset_t*") int[] arg0);
public static native int sigwait(@Cast("const sigset_t*") IntPointer arg0, IntPointer arg1);
public static native int sigwait(@Cast("const sigset_t*") IntBuffer arg0, IntBuffer arg1);
public static native int sigwait(@Cast("const sigset_t*") int[] arg0, int[] arg1);
// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static native void psignal(@Cast("unsigned int") int arg0, @Cast("const char*") BytePointer arg1);
public static native void psignal(@Cast("unsigned int") int arg0, String arg1);
public static native int sigblock(int arg0);
public static native int sigsetmask(int arg0);
public static native int sigvec(int arg0, sigvec arg1, sigvec arg2);
// #endif	/* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
/* List definitions after function declarations, or Reiser cpp gets upset. */
// #if defined(__i386__) || defined(__x86_64__)
/* The left shift operator on intel is modulo 32 */
public static native int __sigbits(int __signo);
// #else /* !__i386__ && !__x86_64__ */
// #define __sigbits(signo)	(1 << ((signo) - 1))
// #endif /* __i386__ || __x86_64__ */

// #define	sigaddset(set, signo)	(*(set) |= __sigbits(signo), 0)
// #define	sigdelset(set, signo)	(*(set) &= ~__sigbits(signo), 0)
// #define	sigismember(set, signo)	((*(set) & __sigbits(signo)) != 0)
// #define	sigemptyset(set)	(*(set) = 0, 0)
// #define	sigfillset(set)		(*(set) = ~(sigset_t)0, 0)
// #endif	/* !_ANSI_SOURCE */

// #endif	/* !_USER_SIGNAL_H */


// Parsed from sched.h

/*
 * Copyright (c) 2000-2003 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

// #ifndef _SCHED_H_
// #define _SCHED_H_

// #include <pthread_impl.h>
// #include <sys/cdefs.h>

/*
 * Scheduling paramters
 */
// #ifndef __POSIX_LIB__
public static class sched_param extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public sched_param() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public sched_param(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public sched_param(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public sched_param position(long position) {
        return (sched_param)super.position(position);
    }
 public native int sched_priority(); public native sched_param sched_priority(int sched_priority);  public native @Cast("char") byte __opaque(int i); public native sched_param __opaque(int i, byte __opaque);
@MemberGetter public native @Cast("char*") BytePointer __opaque(); }
// #endif

public static native int sched_yield();
public static native int sched_get_priority_min(int arg0);
public static native int sched_get_priority_max(int arg0);
// #endif /* _SCHED_H_ */



// Parsed from mach/machine.h

/*
 * Copyright (c) 2000-2007 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */
/*	File:	machine.h
 *	Author:	Avadis Tevanian, Jr.
 *	Date:	1986
 *
 *	Machine independent machine abstraction.
 */

// #ifndef	_MACH_MACHINE_H_
// #define _MACH_MACHINE_H_

// #ifndef __ASSEMBLER__

// #include <stdint.h>
// #include <mach/machine/vm_types.h>
// #include <mach/boolean.h>

public static final int CPU_STATE_MAX =		4;

public static final int CPU_STATE_USER =		0;
public static final int CPU_STATE_SYSTEM =	1;
public static final int CPU_STATE_IDLE =		2;
public static final int CPU_STATE_NICE =		3;



/*
 * Capability bits used in the definition of cpu_type.
 */
public static final int CPU_ARCH_MASK =	0xff000000;		/* mask for architecture bits */
public static final int CPU_ARCH_ABI64 =	0x01000000;		/* 64 bit ABI */

/*
 *	Machine types known by all.
 */
 
public static final int CPU_TYPE_ANY =		((int) -1);

public static final int CPU_TYPE_VAX =		((int) 1);
/* skip				((cpu_type_t) 2)	*/
/* skip				((cpu_type_t) 3)	*/
/* skip				((cpu_type_t) 4)	*/
/* skip				((cpu_type_t) 5)	*/
public static final int CPU_TYPE_MC680x0 =	((int) 6);
public static final int CPU_TYPE_X86 =		((int) 7);
public static final int CPU_TYPE_I386 =		CPU_TYPE_X86;		/* compatibility */
public static final int CPU_TYPE_X86_64 =		(CPU_TYPE_X86 | CPU_ARCH_ABI64);

/* skip CPU_TYPE_MIPS		((cpu_type_t) 8)	*/
/* skip 			((cpu_type_t) 9)	*/
public static final int CPU_TYPE_MC98000 =	((int) 10);
public static final int CPU_TYPE_HPPA =           ((int) 11);
public static final int CPU_TYPE_ARM =		((int) 12);
public static final int CPU_TYPE_ARM64 =          (CPU_TYPE_ARM | CPU_ARCH_ABI64);
public static final int CPU_TYPE_MC88000 =	((int) 13);
public static final int CPU_TYPE_SPARC =		((int) 14);
public static final int CPU_TYPE_I860 =		((int) 15);
/* skip	CPU_TYPE_ALPHA		((cpu_type_t) 16)	*/
/* skip				((cpu_type_t) 17)	*/
public static final int CPU_TYPE_POWERPC =		((int) 18);
public static final int CPU_TYPE_POWERPC64 =		(CPU_TYPE_POWERPC | CPU_ARCH_ABI64);

/*
 *	Machine subtypes (these are defined here, instead of in a machine
 *	dependent directory, so that any program can get all definitions
 *	regardless of where is it compiled).
 */

/*
 * Capability bits used in the definition of cpu_subtype.
 */
public static final int CPU_SUBTYPE_MASK =	0xff000000;	/* mask for feature flags */
public static final int CPU_SUBTYPE_LIB64 =	0x80000000;	/* 64 bit libraries */


/*
 *	Object files that are hand-crafted to run on any
 *	implementation of an architecture are tagged with
 *	CPU_SUBTYPE_MULTIPLE.  This functions essentially the same as
 *	the "ALL" subtype of an architecture except that it allows us
 *	to easily find object files that may need to be modified
 *	whenever a new implementation of an architecture comes out.
 *
 *	It is the responsibility of the implementor to make sure the
 *	software handles unsupported implementations elegantly.
 */
public static final int CPU_SUBTYPE_MULTIPLE =		((int) -1);
public static final int CPU_SUBTYPE_LITTLE_ENDIAN =	((int) 0);
public static final int CPU_SUBTYPE_BIG_ENDIAN =		((int) 1);

/*
 *     Machine threadtypes.
 *     This is none - not defined - for most machine types/subtypes.
 */
public static final int CPU_THREADTYPE_NONE =		((int) 0);

/*
 *	VAX subtypes (these do *not* necessary conform to the actual cpu
 *	ID assigned by DEC available via the SID register).
 */

public static final int CPU_SUBTYPE_VAX_ALL =	((int) 0); 
public static final int CPU_SUBTYPE_VAX780 =	((int) 1);
public static final int CPU_SUBTYPE_VAX785 =	((int) 2);
public static final int CPU_SUBTYPE_VAX750 =	((int) 3);
public static final int CPU_SUBTYPE_VAX730 =	((int) 4);
public static final int CPU_SUBTYPE_UVAXI =	((int) 5);
public static final int CPU_SUBTYPE_UVAXII =	((int) 6);
public static final int CPU_SUBTYPE_VAX8200 =	((int) 7);
public static final int CPU_SUBTYPE_VAX8500 =	((int) 8);
public static final int CPU_SUBTYPE_VAX8600 =	((int) 9);
public static final int CPU_SUBTYPE_VAX8650 =	((int) 10);
public static final int CPU_SUBTYPE_VAX8800 =	((int) 11);
public static final int CPU_SUBTYPE_UVAXIII =	((int) 12);

/*
 * 	680x0 subtypes
 *
 * The subtype definitions here are unusual for historical reasons.
 * NeXT used to consider 68030 code as generic 68000 code.  For
 * backwards compatability:
 * 
 *	CPU_SUBTYPE_MC68030 symbol has been preserved for source code
 *	compatability.
 *
 *	CPU_SUBTYPE_MC680x0_ALL has been defined to be the same
 *	subtype as CPU_SUBTYPE_MC68030 for binary comatability.
 *
 *	CPU_SUBTYPE_MC68030_ONLY has been added to allow new object
 *	files to be tagged as containing 68030-specific instructions.
 */

public static final int CPU_SUBTYPE_MC680x0_ALL =		((int) 1);
public static final int CPU_SUBTYPE_MC68030 =		((int) 1); /* compat */
public static final int CPU_SUBTYPE_MC68040 =		((int) 2); 
public static final int CPU_SUBTYPE_MC68030_ONLY =	((int) 3);

/*
 *	I386 subtypes
 */

// #define CPU_SUBTYPE_INTEL(f, m)	((cpu_subtype_t) (f) + ((m) << 4))

public static native @MemberGetter int CPU_SUBTYPE_I386_ALL();
public static final int CPU_SUBTYPE_I386_ALL = CPU_SUBTYPE_I386_ALL();
public static native @MemberGetter int CPU_SUBTYPE_386();
public static final int CPU_SUBTYPE_386 = CPU_SUBTYPE_386();
public static native @MemberGetter int CPU_SUBTYPE_486();
public static final int CPU_SUBTYPE_486 = CPU_SUBTYPE_486();
public static native @MemberGetter int CPU_SUBTYPE_486SX();
public static final int CPU_SUBTYPE_486SX = CPU_SUBTYPE_486SX();	// 8 << 4 = 128
public static native @MemberGetter int CPU_SUBTYPE_586();
public static final int CPU_SUBTYPE_586 = CPU_SUBTYPE_586();
public static native @MemberGetter int CPU_SUBTYPE_PENT();
public static final int CPU_SUBTYPE_PENT = CPU_SUBTYPE_PENT();
public static native @MemberGetter int CPU_SUBTYPE_PENTPRO();
public static final int CPU_SUBTYPE_PENTPRO = CPU_SUBTYPE_PENTPRO();
public static native @MemberGetter int CPU_SUBTYPE_PENTII_M3();
public static final int CPU_SUBTYPE_PENTII_M3 = CPU_SUBTYPE_PENTII_M3();
public static native @MemberGetter int CPU_SUBTYPE_PENTII_M5();
public static final int CPU_SUBTYPE_PENTII_M5 = CPU_SUBTYPE_PENTII_M5();
public static native @MemberGetter int CPU_SUBTYPE_CELERON();
public static final int CPU_SUBTYPE_CELERON = CPU_SUBTYPE_CELERON();
public static native @MemberGetter int CPU_SUBTYPE_CELERON_MOBILE();
public static final int CPU_SUBTYPE_CELERON_MOBILE = CPU_SUBTYPE_CELERON_MOBILE();
public static native @MemberGetter int CPU_SUBTYPE_PENTIUM_3();
public static final int CPU_SUBTYPE_PENTIUM_3 = CPU_SUBTYPE_PENTIUM_3();
public static native @MemberGetter int CPU_SUBTYPE_PENTIUM_3_M();
public static final int CPU_SUBTYPE_PENTIUM_3_M = CPU_SUBTYPE_PENTIUM_3_M();
public static native @MemberGetter int CPU_SUBTYPE_PENTIUM_3_XEON();
public static final int CPU_SUBTYPE_PENTIUM_3_XEON = CPU_SUBTYPE_PENTIUM_3_XEON();
public static native @MemberGetter int CPU_SUBTYPE_PENTIUM_M();
public static final int CPU_SUBTYPE_PENTIUM_M = CPU_SUBTYPE_PENTIUM_M();
public static native @MemberGetter int CPU_SUBTYPE_PENTIUM_4();
public static final int CPU_SUBTYPE_PENTIUM_4 = CPU_SUBTYPE_PENTIUM_4();
public static native @MemberGetter int CPU_SUBTYPE_PENTIUM_4_M();
public static final int CPU_SUBTYPE_PENTIUM_4_M = CPU_SUBTYPE_PENTIUM_4_M();
public static native @MemberGetter int CPU_SUBTYPE_ITANIUM();
public static final int CPU_SUBTYPE_ITANIUM = CPU_SUBTYPE_ITANIUM();
public static native @MemberGetter int CPU_SUBTYPE_ITANIUM_2();
public static final int CPU_SUBTYPE_ITANIUM_2 = CPU_SUBTYPE_ITANIUM_2();
public static native @MemberGetter int CPU_SUBTYPE_XEON();
public static final int CPU_SUBTYPE_XEON = CPU_SUBTYPE_XEON();
public static native @MemberGetter int CPU_SUBTYPE_XEON_MP();
public static final int CPU_SUBTYPE_XEON_MP = CPU_SUBTYPE_XEON_MP();

// #define CPU_SUBTYPE_INTEL_FAMILY(x)	((x) & 15)
public static final int CPU_SUBTYPE_INTEL_FAMILY_MAX =	15;

// #define CPU_SUBTYPE_INTEL_MODEL(x)	((x) >> 4)
public static final int CPU_SUBTYPE_INTEL_MODEL_ALL =	0;

/*
 *	X86 subtypes.
 */

public static final int CPU_SUBTYPE_X86_ALL =		((int)3);
public static final int CPU_SUBTYPE_X86_64_ALL =		((int)3);
public static final int CPU_SUBTYPE_X86_ARCH1 =		((int)4);
public static final int CPU_SUBTYPE_X86_64_H =		((int)8);	/* Haswell feature subset */


public static final int CPU_THREADTYPE_INTEL_HTT =	((int) 1);

/*
 *	Mips subtypes.
 */

public static final int CPU_SUBTYPE_MIPS_ALL =	((int) 0);
public static final int CPU_SUBTYPE_MIPS_R2300 =	((int) 1);
public static final int CPU_SUBTYPE_MIPS_R2600 =	((int) 2);
public static final int CPU_SUBTYPE_MIPS_R2800 =	((int) 3);
public static final int CPU_SUBTYPE_MIPS_R2000a =	((int) 4);	/* pmax */
public static final int CPU_SUBTYPE_MIPS_R2000 =	((int) 5);
public static final int CPU_SUBTYPE_MIPS_R3000a =	((int) 6);	/* 3max */
public static final int CPU_SUBTYPE_MIPS_R3000 =	((int) 7);

/*
 *	MC98000 (PowerPC) subtypes
 */
public static final int CPU_SUBTYPE_MC98000_ALL =	((int) 0);
public static final int CPU_SUBTYPE_MC98601 =	((int) 1);

/*
 *	HPPA subtypes for Hewlett-Packard HP-PA family of
 *	risc processors. Port by NeXT to 700 series. 
 */

public static final int CPU_SUBTYPE_HPPA_ALL =		((int) 0);
public static final int CPU_SUBTYPE_HPPA_7100 =		((int) 0); /* compat */
public static final int CPU_SUBTYPE_HPPA_7100LC =		((int) 1);

/*
 *	MC88000 subtypes.
 */
public static final int CPU_SUBTYPE_MC88000_ALL =	((int) 0);
public static final int CPU_SUBTYPE_MC88100 =	((int) 1);
public static final int CPU_SUBTYPE_MC88110 =	((int) 2);

/*
 *	SPARC subtypes
 */
public static final int CPU_SUBTYPE_SPARC_ALL =		((int) 0);

/*
 *	I860 subtypes
 */
public static final int CPU_SUBTYPE_I860_ALL =	((int) 0);
public static final int CPU_SUBTYPE_I860_860 =	((int) 1);

/*
 *	PowerPC subtypes
 */
public static final int CPU_SUBTYPE_POWERPC_ALL =		((int) 0);
public static final int CPU_SUBTYPE_POWERPC_601 =		((int) 1);
public static final int CPU_SUBTYPE_POWERPC_602 =		((int) 2);
public static final int CPU_SUBTYPE_POWERPC_603 =		((int) 3);
public static final int CPU_SUBTYPE_POWERPC_603e =	((int) 4);
public static final int CPU_SUBTYPE_POWERPC_603ev =	((int) 5);
public static final int CPU_SUBTYPE_POWERPC_604 =		((int) 6);
public static final int CPU_SUBTYPE_POWERPC_604e =	((int) 7);
public static final int CPU_SUBTYPE_POWERPC_620 =		((int) 8);
public static final int CPU_SUBTYPE_POWERPC_750 =		((int) 9);
public static final int CPU_SUBTYPE_POWERPC_7400 =	((int) 10);
public static final int CPU_SUBTYPE_POWERPC_7450 =	((int) 11);
public static final int CPU_SUBTYPE_POWERPC_970 =		((int) 100);

/*
 *	ARM subtypes
 */
public static final int CPU_SUBTYPE_ARM_ALL =             ((int) 0);
public static final int CPU_SUBTYPE_ARM_V4T =             ((int) 5);
public static final int CPU_SUBTYPE_ARM_V6 =              ((int) 6);
public static final int CPU_SUBTYPE_ARM_V5TEJ =           ((int) 7);
public static final int CPU_SUBTYPE_ARM_XSCALE =		((int) 8);
public static final int CPU_SUBTYPE_ARM_V7 =		((int) 9);
public static final int CPU_SUBTYPE_ARM_V7F =		((int) 10); /* Cortex A9 */
public static final int CPU_SUBTYPE_ARM_V7S =		((int) 11); /* Swift */
public static final int CPU_SUBTYPE_ARM_V7K =		((int) 12);
public static final int CPU_SUBTYPE_ARM_V6M =		((int) 14); /* Not meant to be run under xnu */
public static final int CPU_SUBTYPE_ARM_V7M =		((int) 15); /* Not meant to be run under xnu */
public static final int CPU_SUBTYPE_ARM_V7EM =		((int) 16); /* Not meant to be run under xnu */

public static final int CPU_SUBTYPE_ARM_V8 =		((int) 13);

/*
 *  ARM64 subtypes
 */
public static final int CPU_SUBTYPE_ARM64_ALL =           ((int) 0);
public static final int CPU_SUBTYPE_ARM64_V8 =            ((int) 1);

// #endif /* !__ASSEMBLER__ */

/*
 *	CPU families (sysctl hw.cpufamily)
 *
 * These are meant to identify the CPU's marketing name - an
 * application can map these to (possibly) localized strings.
 * NB: the encodings of the CPU families are intentionally arbitrary.
 * There is no ordering, and you should never try to deduce whether
 * or not some feature is available based on the family.
 * Use feature flags (eg, hw.optional.altivec) to test for optional
 * functionality.
 */
public static final int CPUFAMILY_UNKNOWN =   		0;
public static final int CPUFAMILY_POWERPC_G3 =		0xcee41549;
public static final int CPUFAMILY_POWERPC_G4 =		0x77c184ae;
public static final int CPUFAMILY_POWERPC_G5 =		0xed76d8aa;
public static final int CPUFAMILY_INTEL_6_13 =		0xaa33392b;
public static final int CPUFAMILY_INTEL_YONAH =		0x73d67300;
public static final int CPUFAMILY_INTEL_MEROM =		0x426f69ef;
public static final int CPUFAMILY_INTEL_PENRYN =		0x78ea4fbc;
public static final int CPUFAMILY_INTEL_NEHALEM =		0x6b5a4cd2;
public static final int CPUFAMILY_INTEL_WESTMERE =	0x573b5eec;
public static final int CPUFAMILY_INTEL_SANDYBRIDGE =	0x5490b78c;
public static final int CPUFAMILY_INTEL_IVYBRIDGE =	0x1f65e835;
public static final int CPUFAMILY_INTEL_HASWELL =		0x10b282dc;
public static final int CPUFAMILY_INTEL_BROADWELL =	0x582ed09c;
public static final int CPUFAMILY_ARM_9 =			0xe73283ae;
public static final int CPUFAMILY_ARM_11 =		0x8ff620d8;
public static final int CPUFAMILY_ARM_XSCALE =		0x53b005f5;
public static final int CPUFAMILY_ARM_12 =		0xbd1b0ae9;
public static final int CPUFAMILY_ARM_13 =		0x0cc90e64;
public static final int CPUFAMILY_ARM_14 =		0x96077ef1;
public static final int CPUFAMILY_ARM_15 =		0xa8511bca;
public static final int CPUFAMILY_ARM_SWIFT = 		0x1e2d6381;
public static final int CPUFAMILY_ARM_CYCLONE =		0x37a09642;

/* The following synonyms are deprecated: */
public static final int CPUFAMILY_INTEL_6_14 =	CPUFAMILY_INTEL_YONAH;
public static final int CPUFAMILY_INTEL_6_15 =	CPUFAMILY_INTEL_MEROM;
public static final int CPUFAMILY_INTEL_6_23 =	CPUFAMILY_INTEL_PENRYN;
public static final int CPUFAMILY_INTEL_6_26 =	CPUFAMILY_INTEL_NEHALEM;

public static final int CPUFAMILY_INTEL_CORE =	CPUFAMILY_INTEL_YONAH;
public static final int CPUFAMILY_INTEL_CORE2 =	CPUFAMILY_INTEL_MEROM;


// #endif	/* _MACH_MACHINE_H_ */


// Parsed from spawn.h

/*
 * Copyright (c) 2006, 2010 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */


// #ifndef	_SPAWN_H_
// #define	_SPAWN_H_

/*
 * [SPN] Support for _POSIX_SPAWN
 */

// #include <sys/cdefs.h> 
// #include <_types.h>
// #include <sys/spawn.h>	/* shared types */

// #include <Availability.h>

/*
 * [SPN] Inclusion of the <spawn.h> header may make visible symbols defined
 * in the <sched.h>, <signal.h>, and <sys/types.h> headers.
 */
// #include <sys/_types/_pid_t.h>
// #include <sys/_types/_sigset_t.h>
// #include <sys/_types/_mode_t.h>

/*
 * Opaque types for use with posix_spawn() family functions.  Internals are
 * not defined, and should not be accessed directly.  Types are defined as
 * mandated by POSIX.
 */
@Namespace @Name("void") @Opaque public static class posix_spawnattr_t extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public posix_spawnattr_t() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public posix_spawnattr_t(Pointer p) { super(p); }
}
@Namespace @Name("void") @Opaque public static class posix_spawn_file_actions_t extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public posix_spawn_file_actions_t() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public posix_spawn_file_actions_t(Pointer p) { super(p); }
}

/*
 * gcc under c99 mode won't compile "[ __restrict]" by itself.  As a workaround,
 * a dummy argument name is added.
 */
public static native int posix_spawn(@Cast("pid_t*") IntPointer arg0, @Cast("const char*") BytePointer arg1,
		@Cast("const posix_spawn_file_actions_t*") @ByPtrPtr posix_spawn_file_actions_t arg2,
		@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg3,
		@Cast("char*const*") PointerPointer __argv,
		@Cast("char*const*") PointerPointer __envp);
public static native int posix_spawn(@Cast("pid_t*") IntPointer arg0, @Cast("const char*") BytePointer arg1,
		@Cast("const posix_spawn_file_actions_t*") @ByPtrPtr posix_spawn_file_actions_t arg2,
		@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg3,
		@Cast("char*const*") @ByPtrPtr BytePointer __argv,
		@Cast("char*const*") @ByPtrPtr BytePointer __envp);
public static native int posix_spawn(@Cast("pid_t*") IntBuffer arg0, String arg1,
		@Cast("const posix_spawn_file_actions_t*") PointerPointer arg2,
		@Cast("const posix_spawnattr_t*") PointerPointer arg3,
		@Cast("char*const*") @ByPtrPtr ByteBuffer __argv,
		@Cast("char*const*") @ByPtrPtr ByteBuffer __envp);
public static native int posix_spawn(@Cast("pid_t*") int[] arg0, @Cast("const char*") BytePointer arg1,
		@Cast("const posix_spawn_file_actions_t*") @ByPtrPtr posix_spawn_file_actions_t arg2,
		@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg3,
		@Cast("char*const*") @ByPtrPtr byte[] __argv,
		@Cast("char*const*") @ByPtrPtr byte[] __envp);
public static native int posix_spawn(@Cast("pid_t*") IntPointer arg0, String arg1,
		@Cast("const posix_spawn_file_actions_t*") PointerPointer arg2,
		@Cast("const posix_spawnattr_t*") PointerPointer arg3,
		@Cast("char*const*") @ByPtrPtr BytePointer __argv,
		@Cast("char*const*") @ByPtrPtr BytePointer __envp);
public static native int posix_spawn(@Cast("pid_t*") IntBuffer arg0, @Cast("const char*") BytePointer arg1,
		@Cast("const posix_spawn_file_actions_t*") @ByPtrPtr posix_spawn_file_actions_t arg2,
		@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg3,
		@Cast("char*const*") @ByPtrPtr ByteBuffer __argv,
		@Cast("char*const*") @ByPtrPtr ByteBuffer __envp);
public static native int posix_spawn(@Cast("pid_t*") int[] arg0, String arg1,
		@Cast("const posix_spawn_file_actions_t*") PointerPointer arg2,
		@Cast("const posix_spawnattr_t*") PointerPointer arg3,
		@Cast("char*const*") @ByPtrPtr byte[] __argv,
		@Cast("char*const*") @ByPtrPtr byte[] __envp);
public static native int posix_spawnp(@Cast("pid_t*") IntPointer arg0, @Cast("const char*") BytePointer arg1,
		@Cast("const posix_spawn_file_actions_t*") @ByPtrPtr posix_spawn_file_actions_t arg2,
		@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg3,
		@Cast("char*const*") PointerPointer __argv,
		@Cast("char*const*") PointerPointer __envp);
public static native int posix_spawnp(@Cast("pid_t*") IntPointer arg0, @Cast("const char*") BytePointer arg1,
		@Cast("const posix_spawn_file_actions_t*") @ByPtrPtr posix_spawn_file_actions_t arg2,
		@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg3,
		@Cast("char*const*") @ByPtrPtr BytePointer __argv,
		@Cast("char*const*") @ByPtrPtr BytePointer __envp);
public static native int posix_spawnp(@Cast("pid_t*") IntBuffer arg0, String arg1,
		@Cast("const posix_spawn_file_actions_t*") PointerPointer arg2,
		@Cast("const posix_spawnattr_t*") PointerPointer arg3,
		@Cast("char*const*") @ByPtrPtr ByteBuffer __argv,
		@Cast("char*const*") @ByPtrPtr ByteBuffer __envp);
public static native int posix_spawnp(@Cast("pid_t*") int[] arg0, @Cast("const char*") BytePointer arg1,
		@Cast("const posix_spawn_file_actions_t*") @ByPtrPtr posix_spawn_file_actions_t arg2,
		@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg3,
		@Cast("char*const*") @ByPtrPtr byte[] __argv,
		@Cast("char*const*") @ByPtrPtr byte[] __envp);
public static native int posix_spawnp(@Cast("pid_t*") IntPointer arg0, String arg1,
		@Cast("const posix_spawn_file_actions_t*") PointerPointer arg2,
		@Cast("const posix_spawnattr_t*") PointerPointer arg3,
		@Cast("char*const*") @ByPtrPtr BytePointer __argv,
		@Cast("char*const*") @ByPtrPtr BytePointer __envp);
public static native int posix_spawnp(@Cast("pid_t*") IntBuffer arg0, @Cast("const char*") BytePointer arg1,
		@Cast("const posix_spawn_file_actions_t*") @ByPtrPtr posix_spawn_file_actions_t arg2,
		@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg3,
		@Cast("char*const*") @ByPtrPtr ByteBuffer __argv,
		@Cast("char*const*") @ByPtrPtr ByteBuffer __envp);
public static native int posix_spawnp(@Cast("pid_t*") int[] arg0, String arg1,
		@Cast("const posix_spawn_file_actions_t*") PointerPointer arg2,
		@Cast("const posix_spawnattr_t*") PointerPointer arg3,
		@Cast("char*const*") @ByPtrPtr byte[] __argv,
		@Cast("char*const*") @ByPtrPtr byte[] __envp);
public static native int posix_spawn_file_actions_addclose(@Cast("posix_spawn_file_actions_t*") @ByPtrPtr posix_spawn_file_actions_t arg0, int arg1);
public static native int posix_spawn_file_actions_addclose(@Cast("posix_spawn_file_actions_t*") PointerPointer arg0, int arg1);
public static native int posix_spawn_file_actions_adddup2(@Cast("posix_spawn_file_actions_t*") @ByPtrPtr posix_spawn_file_actions_t arg0, int arg1,
		int arg2);
public static native int posix_spawn_file_actions_adddup2(@Cast("posix_spawn_file_actions_t*") PointerPointer arg0, int arg1,
		int arg2);
public static native int posix_spawn_file_actions_addopen(
		@Cast("posix_spawn_file_actions_t*") @ByPtrPtr posix_spawn_file_actions_t arg0, int arg1,
		@Cast("const char*") BytePointer arg2, int arg3, @Cast("mode_t") short arg4);
public static native int posix_spawn_file_actions_addopen(
		@Cast("posix_spawn_file_actions_t*") PointerPointer arg0, int arg1,
		String arg2, int arg3, @Cast("mode_t") short arg4);
public static native int posix_spawn_file_actions_destroy(@Cast("posix_spawn_file_actions_t*") @ByPtrPtr posix_spawn_file_actions_t arg0);
public static native int posix_spawn_file_actions_destroy(@Cast("posix_spawn_file_actions_t*") PointerPointer arg0);
public static native int posix_spawn_file_actions_init(@Cast("posix_spawn_file_actions_t*") @ByPtrPtr posix_spawn_file_actions_t arg0);
public static native int posix_spawn_file_actions_init(@Cast("posix_spawn_file_actions_t*") PointerPointer arg0);
public static native int posix_spawnattr_destroy(@Cast("posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0);
public static native int posix_spawnattr_destroy(@Cast("posix_spawnattr_t*") PointerPointer arg0);
public static native int posix_spawnattr_getsigdefault(@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("sigset_t*") IntPointer arg1);
public static native int posix_spawnattr_getsigdefault(@Cast("const posix_spawnattr_t*") PointerPointer arg0,
		@Cast("sigset_t*") IntBuffer arg1);
public static native int posix_spawnattr_getsigdefault(@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("sigset_t*") int[] arg1);
public static native int posix_spawnattr_getsigdefault(@Cast("const posix_spawnattr_t*") PointerPointer arg0,
		@Cast("sigset_t*") IntPointer arg1);
public static native int posix_spawnattr_getsigdefault(@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("sigset_t*") IntBuffer arg1);
public static native int posix_spawnattr_getsigdefault(@Cast("const posix_spawnattr_t*") PointerPointer arg0,
		@Cast("sigset_t*") int[] arg1);
public static native int posix_spawnattr_getflags(@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		ShortPointer arg1);
public static native int posix_spawnattr_getflags(@Cast("const posix_spawnattr_t*") PointerPointer arg0,
		ShortBuffer arg1);
public static native int posix_spawnattr_getflags(@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		short[] arg1);
public static native int posix_spawnattr_getflags(@Cast("const posix_spawnattr_t*") PointerPointer arg0,
		ShortPointer arg1);
public static native int posix_spawnattr_getflags(@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		ShortBuffer arg1);
public static native int posix_spawnattr_getflags(@Cast("const posix_spawnattr_t*") PointerPointer arg0,
		short[] arg1);
public static native int posix_spawnattr_getpgroup(@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("pid_t*") IntPointer arg1);
public static native int posix_spawnattr_getpgroup(@Cast("const posix_spawnattr_t*") PointerPointer arg0,
		@Cast("pid_t*") IntBuffer arg1);
public static native int posix_spawnattr_getpgroup(@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("pid_t*") int[] arg1);
public static native int posix_spawnattr_getpgroup(@Cast("const posix_spawnattr_t*") PointerPointer arg0,
		@Cast("pid_t*") IntPointer arg1);
public static native int posix_spawnattr_getpgroup(@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("pid_t*") IntBuffer arg1);
public static native int posix_spawnattr_getpgroup(@Cast("const posix_spawnattr_t*") PointerPointer arg0,
		@Cast("pid_t*") int[] arg1);
public static native int posix_spawnattr_getsigmask(@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("sigset_t*") IntPointer arg1);
public static native int posix_spawnattr_getsigmask(@Cast("const posix_spawnattr_t*") PointerPointer arg0,
		@Cast("sigset_t*") IntBuffer arg1);
public static native int posix_spawnattr_getsigmask(@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("sigset_t*") int[] arg1);
public static native int posix_spawnattr_getsigmask(@Cast("const posix_spawnattr_t*") PointerPointer arg0,
		@Cast("sigset_t*") IntPointer arg1);
public static native int posix_spawnattr_getsigmask(@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("sigset_t*") IntBuffer arg1);
public static native int posix_spawnattr_getsigmask(@Cast("const posix_spawnattr_t*") PointerPointer arg0,
		@Cast("sigset_t*") int[] arg1);
public static native int posix_spawnattr_init(@Cast("posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0);
public static native int posix_spawnattr_init(@Cast("posix_spawnattr_t*") PointerPointer arg0);
public static native int posix_spawnattr_setsigdefault(@Cast("posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("const sigset_t*") IntPointer arg1);
public static native int posix_spawnattr_setsigdefault(@Cast("posix_spawnattr_t*") PointerPointer arg0,
		@Cast("const sigset_t*") IntBuffer arg1);
public static native int posix_spawnattr_setsigdefault(@Cast("posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("const sigset_t*") int[] arg1);
public static native int posix_spawnattr_setsigdefault(@Cast("posix_spawnattr_t*") PointerPointer arg0,
		@Cast("const sigset_t*") IntPointer arg1);
public static native int posix_spawnattr_setsigdefault(@Cast("posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("const sigset_t*") IntBuffer arg1);
public static native int posix_spawnattr_setsigdefault(@Cast("posix_spawnattr_t*") PointerPointer arg0,
		@Cast("const sigset_t*") int[] arg1);
public static native int posix_spawnattr_setflags(@Cast("posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0, short arg1);
public static native int posix_spawnattr_setflags(@Cast("posix_spawnattr_t*") PointerPointer arg0, short arg1);
public static native int posix_spawnattr_setpgroup(@Cast("posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0, @Cast("pid_t") int arg1);
public static native int posix_spawnattr_setpgroup(@Cast("posix_spawnattr_t*") PointerPointer arg0, @Cast("pid_t") int arg1);
public static native int posix_spawnattr_setsigmask(@Cast("posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("const sigset_t*") IntPointer arg1);
public static native int posix_spawnattr_setsigmask(@Cast("posix_spawnattr_t*") PointerPointer arg0,
		@Cast("const sigset_t*") IntBuffer arg1);
public static native int posix_spawnattr_setsigmask(@Cast("posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("const sigset_t*") int[] arg1);
public static native int posix_spawnattr_setsigmask(@Cast("posix_spawnattr_t*") PointerPointer arg0,
		@Cast("const sigset_t*") IntPointer arg1);
public static native int posix_spawnattr_setsigmask(@Cast("posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("const sigset_t*") IntBuffer arg1);
public static native int posix_spawnattr_setsigmask(@Cast("posix_spawnattr_t*") PointerPointer arg0,
		@Cast("const sigset_t*") int[] arg1);

// #if 0	/* _POSIX_PRIORITY_SCHEDULING [PS] : not supported */
// #endif	/* 0 */

// #if	!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/*
 * Darwin-specific extensions below
 */
// #include <mach/exception_types.h>
// #include <mach/machine.h>
// #include <mach/port.h>

// #include <sys/_types/_size_t.h>

public static native int posix_spawnattr_getbinpref_np(@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("size_t") long arg1, @Cast("cpu_type_t*") IntPointer arg2, @Cast("size_t*") SizeTPointer arg3);
public static native int posix_spawnattr_getbinpref_np(@Cast("const posix_spawnattr_t*") PointerPointer arg0,
		@Cast("size_t") long arg1, @Cast("cpu_type_t*") IntBuffer arg2, @Cast("size_t*") SizeTPointer arg3);
public static native int posix_spawnattr_getbinpref_np(@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("size_t") long arg1, @Cast("cpu_type_t*") int[] arg2, @Cast("size_t*") SizeTPointer arg3);
public static native int posix_spawnattr_getbinpref_np(@Cast("const posix_spawnattr_t*") PointerPointer arg0,
		@Cast("size_t") long arg1, @Cast("cpu_type_t*") IntPointer arg2, @Cast("size_t*") SizeTPointer arg3);
public static native int posix_spawnattr_getbinpref_np(@Cast("const posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("size_t") long arg1, @Cast("cpu_type_t*") IntBuffer arg2, @Cast("size_t*") SizeTPointer arg3);
public static native int posix_spawnattr_getbinpref_np(@Cast("const posix_spawnattr_t*") PointerPointer arg0,
		@Cast("size_t") long arg1, @Cast("cpu_type_t*") int[] arg2, @Cast("size_t*") SizeTPointer arg3);
public static native int posix_spawnattr_setauditsessionport_np(@Cast("posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("mach_port_t") int arg1);
public static native int posix_spawnattr_setauditsessionport_np(@Cast("posix_spawnattr_t*") PointerPointer arg0,
		@Cast("mach_port_t") int arg1);
public static native int posix_spawnattr_setbinpref_np(@Cast("posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("size_t") long arg1, @Cast("cpu_type_t*") IntPointer arg2, @Cast("size_t*") SizeTPointer arg3);
public static native int posix_spawnattr_setbinpref_np(@Cast("posix_spawnattr_t*") PointerPointer arg0,
		@Cast("size_t") long arg1, @Cast("cpu_type_t*") IntBuffer arg2, @Cast("size_t*") SizeTPointer arg3);
public static native int posix_spawnattr_setbinpref_np(@Cast("posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("size_t") long arg1, @Cast("cpu_type_t*") int[] arg2, @Cast("size_t*") SizeTPointer arg3);
public static native int posix_spawnattr_setbinpref_np(@Cast("posix_spawnattr_t*") PointerPointer arg0,
		@Cast("size_t") long arg1, @Cast("cpu_type_t*") IntPointer arg2, @Cast("size_t*") SizeTPointer arg3);
public static native int posix_spawnattr_setbinpref_np(@Cast("posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("size_t") long arg1, @Cast("cpu_type_t*") IntBuffer arg2, @Cast("size_t*") SizeTPointer arg3);
public static native int posix_spawnattr_setbinpref_np(@Cast("posix_spawnattr_t*") PointerPointer arg0,
		@Cast("size_t") long arg1, @Cast("cpu_type_t*") int[] arg2, @Cast("size_t*") SizeTPointer arg3);
public static native int posix_spawnattr_setexceptionports_np(@Cast("posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("exception_mask_t") int arg1, @Cast("mach_port_t") int arg2,
		@Cast("exception_behavior_t") int arg3, @Cast("thread_state_flavor_t") int arg4);
public static native int posix_spawnattr_setexceptionports_np(@Cast("posix_spawnattr_t*") PointerPointer arg0,
		@Cast("exception_mask_t") int arg1, @Cast("mach_port_t") int arg2,
		@Cast("exception_behavior_t") int arg3, @Cast("thread_state_flavor_t") int arg4);
public static native int posix_spawnattr_setspecialport_np(@Cast("posix_spawnattr_t*") @ByPtrPtr posix_spawnattr_t arg0,
		@Cast("mach_port_t") int arg1, int arg2);
public static native int posix_spawnattr_setspecialport_np(@Cast("posix_spawnattr_t*") PointerPointer arg0,
		@Cast("mach_port_t") int arg1, int arg2);
public static native int posix_spawn_file_actions_addinherit_np(@Cast("posix_spawn_file_actions_t*") @ByPtrPtr posix_spawn_file_actions_t arg0,
		int arg1);
public static native int posix_spawn_file_actions_addinherit_np(@Cast("posix_spawn_file_actions_t*") PointerPointer arg0,
		int arg1);

// #endif /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
// #endif	/* _SPAWN_H_ */


// Parsed from sys/_types/_seek_set.h

/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

/* whence values for lseek(2) */
// #ifndef SEEK_SET
public static final int SEEK_SET =	0;	/* set file offset to offset */
public static final int SEEK_CUR =	1;	/* set file offset to current plus offset */
public static final int SEEK_END =	2;	/* set file offset to EOF plus offset */
// #endif	/* !SEEK_SET */


// Parsed from sys/unistd.h

/*
 * Copyright (c) 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)unistd.h	8.2 (Berkeley) 1/7/94
 */

// #ifndef _SYS_UNISTD_H_
// #define	_SYS_UNISTD_H_

// #include <sys/cdefs.h>

/*
 * Although we have saved user/group IDs, we do not use them in setuid
 * as described in POSIX 1003.1, because the feature does not work for
 * root.  We use the saved IDs in seteuid/setegid, which are not currently
 * part of the POSIX 1003.1 specification.
 */
// #ifdef	_NOT_AVAILABLE
// #define	_POSIX_SAVED_IDS	/* saved set-user-ID and set-group-ID */
// #endif

public static final long _POSIX_VERSION =		200112L;
public static native @MemberGetter long _POSIX2_VERSION();
public static final long _POSIX2_VERSION = _POSIX2_VERSION();

/* execution-time symbolic constants */
				/* may disable terminal special characters */
// #include <sys/_types/_posix_vdisable.h>

public static final int _POSIX_THREAD_KEYS_MAX = 128;

/* access function */
public static final int F_OK =		0;	/* test for existence of file */
public static final int X_OK =		(1<<0);	/* test for execute or search permission */
public static final int W_OK =		(1<<1);	/* test for write permission */
public static final int R_OK =		(1<<2);	/* test for read permission */

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/*
 * Extended access functions.
 * Note that we depend on these matching the definitions in sys/kauth.h,
 * but with the bits shifted left by 8.
 */
public static final int _READ_OK =	(1<<9);	/* read file data / read directory */
public static final int _WRITE_OK =	(1<<10);	/* write file data / add file to directory */
public static final int _EXECUTE_OK =	(1<<11); /* execute file / search in directory*/
public static final int _DELETE_OK =	(1<<12);	/* delete file / delete directory */
public static final int _APPEND_OK =	(1<<13);	/* append to file / add subdirectory to directory */
public static final int _RMFILE_OK =	(1<<14);	/* - / remove file from directory */
public static final int _RATTR_OK =	(1<<15);	/* read basic attributes */
public static final int _WATTR_OK =	(1<<16);	/* write basic attributes */
public static final int _REXT_OK =	(1<<17);	/* read extended attributes */
public static final int _WEXT_OK =	(1<<18);	/* write extended attributes */
public static final int _RPERM_OK =	(1<<19);	/* read permissions */
public static final int _WPERM_OK =	(1<<20);	/* write permissions */
public static final int _CHOWN_OK =	(1<<21);	/* change ownership */

public static final int _ACCESS_EXTENDED_MASK = (_READ_OK | _WRITE_OK | _EXECUTE_OK | 
				_DELETE_OK | _APPEND_OK | 
				_RMFILE_OK | _REXT_OK | 
				_WEXT_OK | _RATTR_OK | _WATTR_OK | _RPERM_OK | 
				_WPERM_OK | _CHOWN_OK);
// #endif

/* whence values for lseek(2) */
// #include <sys/_types/_seek_set.h>

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
/* whence values for lseek(2); renamed by POSIX 1003.1 */
public static final int L_SET =		SEEK_SET;
public static final int L_INCR =		SEEK_CUR;
public static final int L_XTND =		SEEK_END;
// #endif

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static class accessx_descriptor extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public accessx_descriptor() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public accessx_descriptor(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public accessx_descriptor(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public accessx_descriptor position(long position) {
        return (accessx_descriptor)super.position(position);
    }

	public native @Cast("unsigned int") int ad_name_offset(); public native accessx_descriptor ad_name_offset(int ad_name_offset);
	public native int ad_flags(); public native accessx_descriptor ad_flags(int ad_flags);
	public native int ad_pad(int i); public native accessx_descriptor ad_pad(int i, int ad_pad);
	@MemberGetter public native IntPointer ad_pad();
}
public static final int ACCESSX_MAX_DESCRIPTORS =	100;
public static final int ACCESSX_MAX_TABLESIZE =	(16 * 1024);
// #endif

/* configurable pathname variables */
public static final int _PC_LINK_MAX =		 1;
public static final int _PC_MAX_CANON =		 2;
public static final int _PC_MAX_INPUT =		 3;
public static final int _PC_NAME_MAX =		 4;
public static final int _PC_PATH_MAX =		 5;
public static final int _PC_PIPE_BUF =		 6;
public static final int _PC_CHOWN_RESTRICTED =	 7;
public static final int _PC_NO_TRUNC =		 8;
public static final int _PC_VDISABLE =		 9;

// #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
public static final int _PC_NAME_CHARS_MAX =	 10;
public static final int _PC_CASE_SENSITIVE =		 11;
public static final int _PC_CASE_PRESERVING =		 12;
public static final int _PC_EXTENDED_SECURITY_NP =        13;
public static final int _PC_AUTH_OPAQUE_NP =      14;
// #endif

public static final int _PC_2_SYMLINKS =		15;	/* Symlink supported in directory */
public static final int _PC_ALLOC_SIZE_MIN =	16;	/* Minimum storage actually allocated */
public static final int _PC_ASYNC_IO =		17;	/* Async I/O [AIO] supported? */
public static final int _PC_FILESIZEBITS =	18;	/* # of bits to represent file size */
public static final int _PC_PRIO_IO =		19;	/* Priority I/O [PIO] supported? */
public static final int _PC_REC_INCR_XFER_SIZE =	20;	/* Recommended increment for next two */
public static final int _PC_REC_MAX_XFER_SIZE =	21;	/* Recommended max file transfer size */
public static final int _PC_REC_MIN_XFER_SIZE =	22;	/* Recommended min file transfer size */
public static final int _PC_REC_XFER_ALIGN =	23;	/* Recommended buffer alignment */
public static final int _PC_SYMLINK_MAX =		24;	/* Max # of bytes in symlink name */
public static final int _PC_SYNC_IO =		25;	/* Sync I/O [SIO] supported? */
public static final int _PC_XATTR_SIZE_BITS = 	26;	/* # of bits to represent maximum xattr size */

/* configurable system strings */
public static final int _CS_PATH =		 1;

// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL

// #include <machine/_types.h>
// #include <sys/_types/_size_t.h>
// #include <_types/_uint64_t.h>
// #include <Availability.h>

public static native int getattrlistbulk(int arg0, Pointer arg1, Pointer arg2, @Cast("size_t") long arg3, @Cast("uint64_t") long arg4);

// #endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */

// #if __DARWIN_C_LEVEL >= 200809L

// #include <machine/_types.h>
// #include <sys/_types/_size_t.h>
// #include <sys/_types/_ssize_t.h>
// #include <sys/_types.h>
// #include <sys/_types/_uid_t.h>
// #include <sys/_types/_gid_t.h>
// #include <Availability.h>

public static native int faccessat(int arg0, @Cast("const char*") BytePointer arg1, int arg2, int arg3);
public static native int faccessat(int arg0, String arg1, int arg2, int arg3);
public static native int fchownat(int arg0, @Cast("const char*") BytePointer arg1, @Cast("uid_t") int arg2, @Cast("gid_t") int arg3, int arg4);
public static native int fchownat(int arg0, String arg1, @Cast("uid_t") int arg2, @Cast("gid_t") int arg3, int arg4);
public static native int linkat(int arg0, @Cast("const char*") BytePointer arg1, int arg2, @Cast("const char*") BytePointer arg3, int arg4);
public static native int linkat(int arg0, String arg1, int arg2, String arg3, int arg4);
public static native @Cast("ssize_t") long readlinkat(int arg0, @Cast("const char*") BytePointer arg1, @Cast("char*") BytePointer arg2, @Cast("size_t") long arg3);
public static native @Cast("ssize_t") long readlinkat(int arg0, String arg1, @Cast("char*") ByteBuffer arg2, @Cast("size_t") long arg3);
public static native @Cast("ssize_t") long readlinkat(int arg0, @Cast("const char*") BytePointer arg1, @Cast("char*") byte[] arg2, @Cast("size_t") long arg3);
public static native @Cast("ssize_t") long readlinkat(int arg0, String arg1, @Cast("char*") BytePointer arg2, @Cast("size_t") long arg3);
public static native @Cast("ssize_t") long readlinkat(int arg0, @Cast("const char*") BytePointer arg1, @Cast("char*") ByteBuffer arg2, @Cast("size_t") long arg3);
public static native @Cast("ssize_t") long readlinkat(int arg0, String arg1, @Cast("char*") byte[] arg2, @Cast("size_t") long arg3);
public static native int symlinkat(@Cast("const char*") BytePointer arg0, int arg1, @Cast("const char*") BytePointer arg2);
public static native int symlinkat(String arg0, int arg1, String arg2);
public static native int unlinkat(int arg0, @Cast("const char*") BytePointer arg1, int arg2);
public static native int unlinkat(int arg0, String arg1, int arg2);
public static native int getattrlistat(int arg0, @Cast("const char*") BytePointer arg1, Pointer arg2, Pointer arg3, @Cast("size_t") long arg4, @Cast("unsigned long") long arg5);
public static native int getattrlistat(int arg0, String arg1, Pointer arg2, Pointer arg3, @Cast("size_t") long arg4, @Cast("unsigned long") long arg5);

// #endif /* __DARWIN_C_LEVEL >= 200809L */

// #endif /* !_SYS_UNISTD_H_ */


// Parsed from unistd.h

/*
 * Copyright (c) 2000, 2002-2006, 2008-2010, 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1998-1999 Apple Computer, Inc. All Rights Reserved
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)unistd.h	8.12 (Berkeley) 4/27/95
 *
 *  Copyright (c)  1998 Apple Compter, Inc.
 *  All Rights Reserved
 */

/* History:
        7/14/99 EKN at Apple fixed getdirentriesattr from getdirentryattr
        3/26/98 CHW at Apple added real interface to searchfs call
  	3/5/98  CHW at Apple added hfs semantic system calls headers
*/

// #ifndef _UNISTD_H_
// #define	_UNISTD_H_

// #include <_types.h>
// #include <sys/unistd.h>
// #include <Availability.h>
// #include <sys/_types/_gid_t.h>
// #include <sys/_types/_intptr_t.h>
// #include <sys/_types/_off_t.h>
// #include <sys/_types/_pid_t.h>
/* DO NOT REMOVE THIS COMMENT: fixincludes needs to see:
 * _GCC_SIZE_T */
// #include <sys/_types/_size_t.h>
// #include <sys/_types/_ssize_t.h>
// #include <sys/_types/_uid_t.h>
// #include <sys/_types/_useconds_t.h>
// #include <sys/_types/_null.h>

public static final int STDIN_FILENO =	0;	/* standard input file descriptor */
public static final int STDOUT_FILENO =	1;	/* standard output file descriptor */
public static final int STDERR_FILENO =	2;	/* standard error file descriptor */


/* Version test macros */
/* _POSIX_VERSION and _POSIX2_VERSION from sys/unistd.h */
public static final int _XOPEN_VERSION =			600;		/* [XSI] */
public static final int _XOPEN_XCU_VERSION =		4;		/* Older standard */


/* Please keep this list in the same order as the applicable standard */
public static final int _POSIX_ADVISORY_INFO =		(-1);		/* [ADV] */
public static final int _POSIX_ASYNCHRONOUS_IO =		(-1);		/* [AIO] */
public static final int _POSIX_BARRIERS =			(-1);		/* [BAR] */
public static final long _POSIX_CHOWN_RESTRICTED =		200112L;
public static final int _POSIX_CLOCK_SELECTION =		(-1);		/* [CS] */
public static final int _POSIX_CPUTIME =			(-1);		/* [CPT] */
public static final long _POSIX_FSYNC =			200112L;		/* [FSC] */
public static final long _POSIX_IPV6 =			200112L;
public static final long _POSIX_JOB_CONTROL =		200112L;
public static final long _POSIX_MAPPED_FILES =		200112L;		/* [MF] */
public static final int _POSIX_MEMLOCK =			(-1);		/* [ML] */
public static final int _POSIX_MEMLOCK_RANGE =		(-1);		/* [MR] */
public static final long _POSIX_MEMORY_PROTECTION =	200112L;		/* [MPR] */
public static final int _POSIX_MESSAGE_PASSING =		(-1);		/* [MSG] */
public static final int _POSIX_MONOTONIC_CLOCK =		(-1);		/* [MON] */
public static final long _POSIX_NO_TRUNC =			200112L;
public static final int _POSIX_PRIORITIZED_IO =		(-1);		/* [PIO] */
public static final int _POSIX_PRIORITY_SCHEDULING =	(-1);		/* [PS] */
public static final int _POSIX_RAW_SOCKETS =		(-1);		/* [RS] */
public static final long _POSIX_READER_WRITER_LOCKS =	200112L;		/* [THR] */
public static final int _POSIX_REALTIME_SIGNALS =		(-1);		/* [RTS] */
public static final long _POSIX_REGEXP =			200112L;
public static final long _POSIX_SAVED_IDS =		200112L;		/* XXX required */
public static final int _POSIX_SEMAPHORES =		(-1);		/* [SEM] */
public static final int _POSIX_SHARED_MEMORY_OBJECTS =	(-1);		/* [SHM] */
public static final long _POSIX_SHELL =			200112L;
public static final int _POSIX_SPAWN =			(-1);		/* [SPN] */
public static final int _POSIX_SPIN_LOCKS =		(-1);		/* [SPI] */
public static final int _POSIX_SPORADIC_SERVER =		(-1);		/* [SS] */
public static final int _POSIX_SYNCHRONIZED_IO =		(-1);		/* [SIO] */
public static final long _POSIX_THREAD_ATTR_STACKADDR =	200112L;		/* [TSA] */
public static final long _POSIX_THREAD_ATTR_STACKSIZE =	200112L;		/* [TSS] */
public static final int _POSIX_THREAD_CPUTIME =		(-1);		/* [TCT] */
public static final int _POSIX_THREAD_PRIO_INHERIT =	(-1);		/* [TPI] */
public static final int _POSIX_THREAD_PRIO_PROTECT =	(-1);		/* [TPP] */
public static final int _POSIX_THREAD_PRIORITY_SCHEDULING =	(-1);	/* [TPS] */
public static final long _POSIX_THREAD_PROCESS_SHARED =	200112L;		/* [TSH] */
public static final long _POSIX_THREAD_SAFE_FUNCTIONS =	200112L;		/* [TSF] */
public static final int _POSIX_THREAD_SPORADIC_SERVER =	(-1);		/* [TSP] */
public static final long _POSIX_THREADS =			200112L;		/* [THR] */
public static final int _POSIX_TIMEOUTS =			(-1);		/* [TMO] */
public static final int _POSIX_TIMERS =			(-1);		/* [TMR] */
public static final int _POSIX_TRACE =			(-1);		/* [TRC] */
public static final int _POSIX_TRACE_EVENT_FILTER =	(-1);		/* [TEF] */
public static final int _POSIX_TRACE_INHERIT =		(-1);		/* [TRI] */
public static final int _POSIX_TRACE_LOG =		(-1);		/* [TRL] */
public static final int _POSIX_TYPED_MEMORY_OBJECTS =	(-1);		/* [TYM] */
// #ifndef _POSIX_VDISABLE
public static final int _POSIX_VDISABLE =			0xff;		/* same as sys/termios.h */
// #endif /* _POSIX_VDISABLE */

// #if __DARWIN_C_LEVEL >= 199209L
public static native @MemberGetter long _POSIX2_C_BIND();
public static final long _POSIX2_C_BIND = _POSIX2_C_BIND();
public static native @MemberGetter long _POSIX2_C_DEV();
public static final long _POSIX2_C_DEV = _POSIX2_C_DEV();		/* c99 command */
public static final long _POSIX2_CHAR_TERM =		200112L;
public static final int _POSIX2_FORT_DEV =		(-1);		/* fort77 command */
public static final long _POSIX2_FORT_RUN =		200112L;
public static native @MemberGetter long _POSIX2_LOCALEDEF();
public static final long _POSIX2_LOCALEDEF = _POSIX2_LOCALEDEF();		/* localedef command */
public static final int _POSIX2_PBS =			(-1);
public static final int _POSIX2_PBS_ACCOUNTING =		(-1);
public static final int _POSIX2_PBS_CHECKPOINT =		(-1);
public static final int _POSIX2_PBS_LOCATE =		(-1);
public static final int _POSIX2_PBS_MESSAGE =		(-1);
public static final int _POSIX2_PBS_TRACK =		(-1);
public static native @MemberGetter long _POSIX2_SW_DEV();
public static final long _POSIX2_SW_DEV = _POSIX2_SW_DEV();
public static final long _POSIX2_UPE =			200112L;	/* XXXX no fc, newgrp, tabs */
// #endif /* __DARWIN_C_LEVEL */

public static final int __ILP32_OFF32 =          (-1);
public static final int __ILP32_OFFBIG =         (1);
public static final int __LP64_OFF64 =           (1);
public static final int __LPBIG_OFFBIG =         (1);

// #if __DARWIN_C_LEVEL >= 200112L
public static final int _POSIX_V6_ILP32_OFF32 =		__ILP32_OFF32;
public static final int _POSIX_V6_ILP32_OFFBIG =		__ILP32_OFFBIG;
public static final int _POSIX_V6_LP64_OFF64 =		__LP64_OFF64;
public static final int _POSIX_V6_LPBIG_OFFBIG =		__LPBIG_OFFBIG;
// #endif /* __DARWIN_C_LEVEL >= 200112L */

// #if __DARWIN_C_LEVEL >= 200809L
public static final int _POSIX_V7_ILP32_OFF32 =		__ILP32_OFF32;
public static final int _POSIX_V7_ILP32_OFFBIG =		__ILP32_OFFBIG;
public static final int _POSIX_V7_LP64_OFF64 =		__LP64_OFF64;
public static final int _POSIX_V7_LPBIG_OFFBIG =		__LPBIG_OFFBIG;
// #endif /* __DARWIN_C_LEVEL >= 200809L */

// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static final int _V6_ILP32_OFF32 =             __ILP32_OFF32;
public static final int _V6_ILP32_OFFBIG =            __ILP32_OFFBIG;
public static final int _V6_LP64_OFF64 =              __LP64_OFF64;
public static final int _V6_LPBIG_OFFBIG =            __LPBIG_OFFBIG;
// #endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */

// #if (__DARWIN_C_LEVEL >= 199506L && __DARWIN_C_LEVEL < 200809L) || __DARWIN_C_LEVEL >= __DARWIN_C_FULL
/* Removed in Issue 7 */
public static final int _XBS5_ILP32_OFF32 =		    __ILP32_OFF32;
public static final int _XBS5_ILP32_OFFBIG =		    __ILP32_OFFBIG;
public static final int _XBS5_LP64_OFF64 =		    __LP64_OFF64;
public static final int _XBS5_LPBIG_OFFBIG =		    __LPBIG_OFFBIG;
// #endif /* __DARWIN_C_LEVEL < 200809L */

// #if __DARWIN_C_LEVEL >= 199506L /* This really should be XSI */ 
public static final int _XOPEN_CRYPT =			(1);
public static final int _XOPEN_ENH_I18N =			(1);		/* XXX required */
public static final int _XOPEN_LEGACY =			(-1);	/* no ftime gcvt, wcswcs */
public static final int _XOPEN_REALTIME =			(-1);	/* no q'ed signals, mq_* */
public static final int _XOPEN_REALTIME_THREADS =		(-1);	/* no posix_spawn, et. al. */
public static final int _XOPEN_SHM =			(1);
public static final int _XOPEN_STREAMS =			(-1);   /* Issue 6 */
public static final int _XOPEN_UNIX =			(1);
// #endif /* XSI */

/* configurable system variables */
public static final int _SC_ARG_MAX =			 1;
public static final int _SC_CHILD_MAX =			 2;
public static final int _SC_CLK_TCK =			 3;
public static final int _SC_NGROUPS_MAX =			 4;
public static final int _SC_OPEN_MAX =			 5;
public static final int _SC_JOB_CONTROL =			 6;
public static final int _SC_SAVED_IDS =			 7;
public static final int _SC_VERSION =			 8;
public static final int _SC_BC_BASE_MAX =			 9;
public static final int _SC_BC_DIM_MAX =			10;
public static final int _SC_BC_SCALE_MAX =		11;
public static final int _SC_BC_STRING_MAX =		12;
public static final int _SC_COLL_WEIGHTS_MAX =		13;
public static final int _SC_EXPR_NEST_MAX =		14;
public static final int _SC_LINE_MAX =			15;
public static final int _SC_RE_DUP_MAX =			16;
public static final int _SC_2_VERSION =			17;
public static final int _SC_2_C_BIND =			18;
public static final int _SC_2_C_DEV =			19;
public static final int _SC_2_CHAR_TERM =			20;
public static final int _SC_2_FORT_DEV =			21;
public static final int _SC_2_FORT_RUN =			22;
public static final int _SC_2_LOCALEDEF =			23;
public static final int _SC_2_SW_DEV =			24;
public static final int _SC_2_UPE =			25;
public static final int _SC_STREAM_MAX =			26;
public static final int _SC_TZNAME_MAX =			27;

// #if __DARWIN_C_LEVEL >= 199309L
public static final int _SC_ASYNCHRONOUS_IO =		28;
public static final int _SC_PAGESIZE =			29;
public static final int _SC_MEMLOCK =			30;
public static final int _SC_MEMLOCK_RANGE =		31;
public static final int _SC_MEMORY_PROTECTION =		32;
public static final int _SC_MESSAGE_PASSING =		33;
public static final int _SC_PRIORITIZED_IO =		34;
public static final int _SC_PRIORITY_SCHEDULING =		35;
public static final int _SC_REALTIME_SIGNALS =		36;
public static final int _SC_SEMAPHORES =			37;
public static final int _SC_FSYNC =			38;
public static final int _SC_SHARED_MEMORY_OBJECTS = 	39;
public static final int _SC_SYNCHRONIZED_IO =		40;
public static final int _SC_TIMERS =			41;
public static final int _SC_AIO_LISTIO_MAX =		42;
public static final int _SC_AIO_MAX =			43;
public static final int _SC_AIO_PRIO_DELTA_MAX =		44;
public static final int _SC_DELAYTIMER_MAX =		45;
public static final int _SC_MQ_OPEN_MAX =			46;
public static final int _SC_MAPPED_FILES =		47;	/* swap _SC_PAGESIZE vs. BSD */
public static final int _SC_RTSIG_MAX =			48;
public static final int _SC_SEM_NSEMS_MAX =		49;
public static final int _SC_SEM_VALUE_MAX =		50;
public static final int _SC_SIGQUEUE_MAX =		51;
public static final int _SC_TIMER_MAX =			52;
// #endif /* __DARWIN_C_LEVEL >= 199309L */

// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static final int _SC_NPROCESSORS_CONF =		57;
public static final int _SC_NPROCESSORS_ONLN =		58;
// #endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */

// #if __DARWIN_C_LEVEL >= 200112L
public static final int _SC_2_PBS =			59;
public static final int _SC_2_PBS_ACCOUNTING =		60;
public static final int _SC_2_PBS_CHECKPOINT =		61;
public static final int _SC_2_PBS_LOCATE =		62;
public static final int _SC_2_PBS_MESSAGE =		63;
public static final int _SC_2_PBS_TRACK =			64;
public static final int _SC_ADVISORY_INFO =		65;
public static final int _SC_BARRIERS =			66;
public static final int _SC_CLOCK_SELECTION =		67;
public static final int _SC_CPUTIME =			68;
public static final int _SC_FILE_LOCKING =		69;
public static final int _SC_GETGR_R_SIZE_MAX =		70;
public static final int _SC_GETPW_R_SIZE_MAX =		71;
public static final int _SC_HOST_NAME_MAX =		72;
public static final int _SC_LOGIN_NAME_MAX =		73;
public static final int _SC_MONOTONIC_CLOCK =		74;
public static final int _SC_MQ_PRIO_MAX =			75;
public static final int _SC_READER_WRITER_LOCKS =		76;
public static final int _SC_REGEXP =			77;
public static final int _SC_SHELL =			78;
public static final int _SC_SPAWN =			79;
public static final int _SC_SPIN_LOCKS =			80;
public static final int _SC_SPORADIC_SERVER =		81;
public static final int _SC_THREAD_ATTR_STACKADDR =	82;
public static final int _SC_THREAD_ATTR_STACKSIZE =	83;
public static final int _SC_THREAD_CPUTIME =		84;
public static final int _SC_THREAD_DESTRUCTOR_ITERATIONS = 85;
public static final int _SC_THREAD_KEYS_MAX =		86;
public static final int _SC_THREAD_PRIO_INHERIT =		87;
public static final int _SC_THREAD_PRIO_PROTECT =		88;
public static final int _SC_THREAD_PRIORITY_SCHEDULING =	89;
public static final int _SC_THREAD_PROCESS_SHARED =	90;
public static final int _SC_THREAD_SAFE_FUNCTIONS =	91;
public static final int _SC_THREAD_SPORADIC_SERVER =	92;
public static final int _SC_THREAD_STACK_MIN =		93;
public static final int _SC_THREAD_THREADS_MAX =		94;
public static final int _SC_TIMEOUTS =			95;
public static final int _SC_THREADS =			96;
public static final int _SC_TRACE =			97;
public static final int _SC_TRACE_EVENT_FILTER =		98;
public static final int _SC_TRACE_INHERIT =		99;
public static final int _SC_TRACE_LOG =			100;
public static final int _SC_TTY_NAME_MAX =		101;
public static final int _SC_TYPED_MEMORY_OBJECTS =	102;
public static final int _SC_V6_ILP32_OFF32 =		103;
public static final int _SC_V6_ILP32_OFFBIG =		104;
public static final int _SC_V6_LP64_OFF64 =		105;
public static final int _SC_V6_LPBIG_OFFBIG =		106;
public static final int _SC_IPV6 =			118;
public static final int _SC_RAW_SOCKETS =			119;
public static final int _SC_SYMLOOP_MAX =			120;
// #endif /* __DARWIN_C_LEVEL >= 200112L */

// #if __DARWIN_C_LEVEL >= 199506L /* Really XSI */
public static final int _SC_ATEXIT_MAX =			107;
public static final int _SC_IOV_MAX =			56;
public static final int _SC_PAGE_SIZE =			_SC_PAGESIZE;
public static final int _SC_XOPEN_CRYPT =			108;
public static final int _SC_XOPEN_ENH_I18N =		109;
public static final int _SC_XOPEN_LEGACY =		110;      /* Issue 6 */
public static final int _SC_XOPEN_REALTIME =		111;      /* Issue 6 */
public static final int _SC_XOPEN_REALTIME_THREADS =	112;  /* Issue 6 */
public static final int _SC_XOPEN_SHM =			113;
public static final int _SC_XOPEN_STREAMS =		114;      /* Issue 6 */
public static final int _SC_XOPEN_UNIX =			115;
public static final int _SC_XOPEN_VERSION =		116;
public static final int _SC_XOPEN_XCU_VERSION =		121;
// #endif /* XSI */

// #if (__DARWIN_C_LEVEL >= 199506L && __DARWIN_C_LEVEL < 200809L) || __DARWIN_C_LEVEL >= __DARWIN_C_FULL
/* Removed in Issue 7 */
public static final int _SC_XBS5_ILP32_OFF32 =		122;
public static final int _SC_XBS5_ILP32_OFFBIG =		123;
public static final int _SC_XBS5_LP64_OFF64 =		124;
public static final int _SC_XBS5_LPBIG_OFFBIG =		125;
// #endif /* __DARWIN_C_LEVEL <= 200809L */

// #if __DARWIN_C_LEVEL >= 200112L
public static final int _SC_SS_REPL_MAX =			126;
public static final int _SC_TRACE_EVENT_NAME_MAX =	127;
public static final int _SC_TRACE_NAME_MAX =		128;
public static final int _SC_TRACE_SYS_MAX =		129;
public static final int _SC_TRACE_USER_EVENT_MAX =	130;
// #endif

// #if __DARWIN_C_LEVEL < 200112L || __DARWIN_C_LEVEL >= __DARWIN_C_FULL
/* Removed in Issue 6 */
public static final int _SC_PASS_MAX =			131;
// #endif

// #if __DARWIN_C_LEVEL >= 199209L
// #ifndef _CS_PATH /* Defined in <sys/unistd.h> */
// #endif
// #endif

// #if __DARWIN_C_LEVEL >= 200112
public static final int _CS_POSIX_V6_ILP32_OFF32_CFLAGS =		2;
public static final int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS =	3;
public static final int _CS_POSIX_V6_ILP32_OFF32_LIBS =		4;
public static final int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS =	5;
public static final int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS =	6;
public static final int _CS_POSIX_V6_ILP32_OFFBIG_LIBS =		7;
public static final int _CS_POSIX_V6_LP64_OFF64_CFLAGS =		8;
public static final int _CS_POSIX_V6_LP64_OFF64_LDFLAGS =		9;
public static final int _CS_POSIX_V6_LP64_OFF64_LIBS =		10;
public static final int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS =	11;
public static final int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS =	12;
public static final int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS =		13;
public static final int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS =	14;
// #endif

// #if (__DARWIN_C_LEVEL >= 199506L && __DARWIN_C_LEVEL < 200809L) || __DARWIN_C_LEVEL >= __DARWIN_C_FULL
/* Removed in Issue 7 */
public static final int _CS_XBS5_ILP32_OFF32_CFLAGS =		20;
public static final int _CS_XBS5_ILP32_OFF32_LDFLAGS =		21;
public static final int _CS_XBS5_ILP32_OFF32_LIBS =		22;
public static final int _CS_XBS5_ILP32_OFF32_LINTFLAGS =		23;
public static final int _CS_XBS5_ILP32_OFFBIG_CFLAGS =		24;
public static final int _CS_XBS5_ILP32_OFFBIG_LDFLAGS =		25;
public static final int _CS_XBS5_ILP32_OFFBIG_LIBS =		26;
public static final int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS =		27;
public static final int _CS_XBS5_LP64_OFF64_CFLAGS =		28;
public static final int _CS_XBS5_LP64_OFF64_LDFLAGS =		29;
public static final int _CS_XBS5_LP64_OFF64_LIBS =		30;
public static final int _CS_XBS5_LP64_OFF64_LINTFLAGS =		31;
public static final int _CS_XBS5_LPBIG_OFFBIG_CFLAGS =		32;
public static final int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS =		33;
public static final int _CS_XBS5_LPBIG_OFFBIG_LIBS =		34;
public static final int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS =		35;
// #endif

// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static final int _CS_DARWIN_USER_DIR =			65536;
public static final int _CS_DARWIN_USER_TEMP_DIR =		65537;
public static final int _CS_DARWIN_USER_CACHE_DIR =		65538;
// #endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */


// #ifdef _DARWIN_UNLIMITED_GETGROUPS
// #if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED < __IPHONE_3_2
// #error "_DARWIN_UNLIMITED_GETGROUPS specified, but -miphoneos-version-min version does not support it."
// #elif defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_6
// #error "_DARWIN_UNLIMITED_GETGROUPS specified, but -mmacosx-version-min version does not support it."
// #endif
// #endif

/* POSIX.1-1990 */

public static native void _exit(int arg0);
public static native int access(@Cast("const char*") BytePointer arg0, int arg1);
public static native int access(String arg0, int arg1);
public static native @Cast("unsigned int") int alarm(@Cast("unsigned int") int arg0);
public static native int chdir(@Cast("const char*") BytePointer arg0);
public static native int chdir(String arg0);
public static native int chown(@Cast("const char*") BytePointer arg0, @Cast("uid_t") int arg1, @Cast("gid_t") int arg2);
public static native int chown(String arg0, @Cast("uid_t") int arg1, @Cast("gid_t") int arg2);

public static native @Name("close") int _close(int arg0);

public static native int dup(int arg0);
public static native int dup2(int arg0, int arg1);
public static native int execl(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native int execl(String arg0, String arg1);
public static native int execle(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native int execle(String arg0, String arg1);
public static native int execlp(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native int execlp(String arg0, String arg1);
public static native int execv(@Cast("const char*") BytePointer arg0, @Cast("char*const*") PointerPointer arg1);
public static native int execv(@Cast("const char*") BytePointer arg0, @Cast("char*const*") @ByPtrPtr BytePointer arg1);
public static native int execv(String arg0, @Cast("char*const*") @ByPtrPtr ByteBuffer arg1);
public static native int execv(@Cast("const char*") BytePointer arg0, @Cast("char*const*") @ByPtrPtr byte[] arg1);
public static native int execv(String arg0, @Cast("char*const*") @ByPtrPtr BytePointer arg1);
public static native int execv(@Cast("const char*") BytePointer arg0, @Cast("char*const*") @ByPtrPtr ByteBuffer arg1);
public static native int execv(String arg0, @Cast("char*const*") @ByPtrPtr byte[] arg1);
public static native int execve(@Cast("const char*") BytePointer arg0, @Cast("char*const*") PointerPointer arg1, @Cast("char*const*") PointerPointer arg2);
public static native int execve(@Cast("const char*") BytePointer arg0, @Cast("char*const*") @ByPtrPtr BytePointer arg1, @Cast("char*const*") @ByPtrPtr BytePointer arg2);
public static native int execve(String arg0, @Cast("char*const*") @ByPtrPtr ByteBuffer arg1, @Cast("char*const*") @ByPtrPtr ByteBuffer arg2);
public static native int execve(@Cast("const char*") BytePointer arg0, @Cast("char*const*") @ByPtrPtr byte[] arg1, @Cast("char*const*") @ByPtrPtr byte[] arg2);
public static native int execve(String arg0, @Cast("char*const*") @ByPtrPtr BytePointer arg1, @Cast("char*const*") @ByPtrPtr BytePointer arg2);
public static native int execve(@Cast("const char*") BytePointer arg0, @Cast("char*const*") @ByPtrPtr ByteBuffer arg1, @Cast("char*const*") @ByPtrPtr ByteBuffer arg2);
public static native int execve(String arg0, @Cast("char*const*") @ByPtrPtr byte[] arg1, @Cast("char*const*") @ByPtrPtr byte[] arg2);
public static native int execvp(@Cast("const char*") BytePointer arg0, @Cast("char*const*") PointerPointer arg1);
public static native int execvp(@Cast("const char*") BytePointer arg0, @Cast("char*const*") @ByPtrPtr BytePointer arg1);
public static native int execvp(String arg0, @Cast("char*const*") @ByPtrPtr ByteBuffer arg1);
public static native int execvp(@Cast("const char*") BytePointer arg0, @Cast("char*const*") @ByPtrPtr byte[] arg1);
public static native int execvp(String arg0, @Cast("char*const*") @ByPtrPtr BytePointer arg1);
public static native int execvp(@Cast("const char*") BytePointer arg0, @Cast("char*const*") @ByPtrPtr ByteBuffer arg1);
public static native int execvp(String arg0, @Cast("char*const*") @ByPtrPtr byte[] arg1);
public static native @Cast("pid_t") int fork();
public static native long fpathconf(int arg0, int arg1);
public static native @Cast("char*") BytePointer getcwd(@Cast("char*") BytePointer arg0, @Cast("size_t") long arg1);
public static native @Cast("char*") ByteBuffer getcwd(@Cast("char*") ByteBuffer arg0, @Cast("size_t") long arg1);
public static native @Cast("char*") byte[] getcwd(@Cast("char*") byte[] arg0, @Cast("size_t") long arg1);
public static native @Cast("gid_t") int getegid();
public static native @Cast("uid_t") int geteuid();
public static native @Cast("gid_t") int getgid();
// #if defined(_DARWIN_UNLIMITED_GETGROUPS) || defined(_DARWIN_C_SOURCE)
public static native int getgroups(int arg0, @Cast("gid_t*") IntPointer arg1);
public static native int getgroups(int arg0, @Cast("gid_t*") IntBuffer arg1);
public static native int getgroups(int arg0, @Cast("gid_t*") int[] arg1);
// #else /* !_DARWIN_UNLIMITED_GETGROUPS && !_DARWIN_C_SOURCE */
// #endif /* _DARWIN_UNLIMITED_GETGROUPS || _DARWIN_C_SOURCE */
public static native @Cast("char*") BytePointer getlogin();
public static native @Cast("pid_t") int getpgrp();
public static native @Cast("pid_t") int getpid();
public static native @Cast("pid_t") int getppid();
public static native @Cast("uid_t") int getuid();
public static native int isatty(int arg0);
public static native int link(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native int link(String arg0, String arg1);
public static native @Cast("off_t") long lseek(int arg0, @Cast("off_t") long arg1, int arg2);
public static native long pathconf(@Cast("const char*") BytePointer arg0, int arg1);
public static native long pathconf(String arg0, int arg1);

public static native int pause();

public static native int pipe(IntPointer arg0);
public static native int pipe(IntBuffer arg0);
public static native int pipe(int[] arg0);

public static native @Cast("ssize_t") long read(int arg0, Pointer arg1, @Cast("size_t") long arg2);

public static native int rmdir(@Cast("const char*") BytePointer arg0);
public static native int rmdir(String arg0);
public static native int setgid(@Cast("gid_t") int arg0);
public static native int setpgid(@Cast("pid_t") int arg0, @Cast("pid_t") int arg1);
public static native @Cast("pid_t") int setsid();
public static native int setuid(@Cast("uid_t") int arg0);

public static native @Cast("unsigned int") int sleep(@Cast("unsigned int") int arg0);

public static native long sysconf(int arg0);
public static native @Cast("pid_t") int tcgetpgrp(int arg0);
public static native int tcsetpgrp(int arg0, @Cast("pid_t") int arg1);
public static native @Cast("char*") BytePointer ttyname(int arg0);

// #if __DARWIN_UNIX03
public static native int ttyname_r(int arg0, @Cast("char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native int ttyname_r(int arg0, @Cast("char*") ByteBuffer arg1, @Cast("size_t") long arg2);
public static native int ttyname_r(int arg0, @Cast("char*") byte[] arg1, @Cast("size_t") long arg2);
// #else /* !__DARWIN_UNIX03 */
// #endif /* __DARWIN_UNIX03 */

public static native int unlink(@Cast("const char*") BytePointer arg0);
public static native int unlink(String arg0);

public static native @Cast("ssize_t") long write(int arg0, @Const Pointer arg1, @Cast("size_t") long arg2);
/* Additional functionality provided by:
 * POSIX.2-1992 C Language Binding Option
 */

// #if __DARWIN_C_LEVEL >= 199209L
public static native @Cast("size_t") long confstr(int arg0, @Cast("char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long confstr(int arg0, @Cast("char*") ByteBuffer arg1, @Cast("size_t") long arg2);
public static native @Cast("size_t") long confstr(int arg0, @Cast("char*") byte[] arg1, @Cast("size_t") long arg2);

public static native int getopt(int arg0, @Cast("char*const*") PointerPointer arg1, @Cast("const char*") BytePointer arg2);
public static native int getopt(int arg0, @Cast("char*const*") @ByPtrPtr BytePointer arg1, @Cast("const char*") BytePointer arg2);
public static native int getopt(int arg0, @Cast("char*const*") @ByPtrPtr ByteBuffer arg1, String arg2);
public static native int getopt(int arg0, @Cast("char*const*") @ByPtrPtr byte[] arg1, @Cast("const char*") BytePointer arg2);
public static native int getopt(int arg0, @Cast("char*const*") @ByPtrPtr BytePointer arg1, String arg2);
public static native int getopt(int arg0, @Cast("char*const*") @ByPtrPtr ByteBuffer arg1, @Cast("const char*") BytePointer arg2);
public static native int getopt(int arg0, @Cast("char*const*") @ByPtrPtr byte[] arg1, String arg2);

public static native @Cast("char*") BytePointer optarg(); public static native void optarg(BytePointer optarg);			/* getopt(3) external variables */
public static native int optind(); public static native void optind(int optind);
public static native int opterr(); public static native void opterr(int opterr);
public static native int optopt(); public static native void optopt(int optopt);
// #endif /* __DARWIN_C_LEVEL >= 199209L */



/* Additional functionality provided by:
 * POSIX.1c-1995,
 * POSIX.1i-1995,
 * and the omnibus ISO/IEC 9945-1: 1996
 */

// #if __DARWIN_C_LEVEL >= 199506L
                               /* These F_* are really XSI or Issue 6 */
public static final int F_ULOCK =         0;      /* unlock locked section */
public static final int F_LOCK =          1;      /* lock a section for exclusive use */
public static final int F_TLOCK =         2;      /* test and lock a section for exclusive use */
public static final int F_TEST =          3;      /* test a section for locks by other procs */

 /* Begin XSI */
/* Removed in Issue 6 */
// #if !defined(_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 200112L
// #if !defined(_POSIX_C_SOURCE)
public static native @Deprecated Pointer brk(@Const Pointer arg0);
public static native int chroot(@Cast("const char*") BytePointer arg0);
public static native int chroot(String arg0);
// #endif

public static native @Cast("char*") BytePointer crypt(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native @Cast("char*") ByteBuffer crypt(String arg0, String arg1);
// #ifndef __CTERMID_DEFINED
/* Multiply defined in stdio.h and unistd.h by SUS */
public static final int __CTERMID_DEFINED = 1;
public static native @Cast("char*") BytePointer ctermid(@Cast("char*") BytePointer arg0);
public static native @Cast("char*") ByteBuffer ctermid(@Cast("char*") ByteBuffer arg0);
public static native @Cast("char*") byte[] ctermid(@Cast("char*") byte[] arg0);
// #endif
// #if __DARWIN_UNIX03
public static native void encrypt(@Cast("char*") BytePointer arg0, int arg1);
public static native void encrypt(@Cast("char*") ByteBuffer arg0, int arg1);
public static native void encrypt(@Cast("char*") byte[] arg0, int arg1);
// #else /* !__DARWIN_UNIX03 */
// #endif /* __DARWIN_UNIX03 */
public static native int fchdir(int arg0);
public static native long gethostid();
public static native @Cast("pid_t") int getpgid(@Cast("pid_t") int arg0);
public static native @Cast("pid_t") int getsid(@Cast("pid_t") int arg0);

/* Removed in Issue 6 */
// #if !defined(_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 200112L
public static native int getdtablesize();
public static native int getpagesize();
public static native @Cast("char*") BytePointer getpass(@Cast("const char*") BytePointer arg0);
public static native @Cast("char*") ByteBuffer getpass(String arg0);
// #endif

/* Removed in Issue 7 */
// #if !defined(_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 200809L
 /* obsoleted by getcwd() */
// #endif

public static native int lchown(@Cast("const char*") BytePointer arg0, @Cast("uid_t") int arg1, @Cast("gid_t") int arg2);
public static native int lchown(String arg0, @Cast("uid_t") int arg1, @Cast("gid_t") int arg2);

public static native int lockf(int arg0, int arg1, @Cast("off_t") long arg2);

public static native int nice(int arg0);

public static native @Cast("ssize_t") long pread(int arg0, Pointer arg1, @Cast("size_t") long arg2, @Cast("off_t") long arg3);

public static native @Cast("ssize_t") long pwrite(int arg0, @Const Pointer arg1, @Cast("size_t") long arg2, @Cast("off_t") long arg3);

/* Removed in Issue 6 */
// #if !defined(_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 200112L
/* Note that Issue 5 changed the argument as intprt_t,
 * but we keep it as int for binary compatability. */
// #if !defined(_POSIX_C_SOURCE)
public static native @Deprecated Pointer sbrk(int arg0);
// #endif

// #if __DARWIN_UNIX03
public static native @Cast("pid_t") int setpgrp();
// #else /* !__DARWIN_UNIX03 */
// #endif /* __DARWIN_UNIX03 */

public static native int setregid(@Cast("gid_t") int arg0, @Cast("gid_t") int arg1);

public static native int setreuid(@Cast("uid_t") int arg0, @Cast("uid_t") int arg1);
public static native void sync();
public static native int truncate(@Cast("const char*") BytePointer arg0, @Cast("off_t") long arg1);
public static native int truncate(String arg0, @Cast("off_t") long arg1);
public static native @Cast("useconds_t") int ualarm(@Cast("useconds_t") int arg0, @Cast("useconds_t") int arg1);
public static native int usleep(@Cast("useconds_t") int arg0);
public static native @Cast("pid_t") int vfork();
/* End XSI */

public static native int fsync(int arg0);

public static native int ftruncate(int arg0, @Cast("off_t") long arg1);
public static native int getlogin_r(@Cast("char*") BytePointer arg0, @Cast("size_t") long arg1);
public static native int getlogin_r(@Cast("char*") ByteBuffer arg0, @Cast("size_t") long arg1);
public static native int getlogin_r(@Cast("char*") byte[] arg0, @Cast("size_t") long arg1);
// #endif /* __DARWIN_C_LEVEL >= 199506L */



/* Additional functionality provided by:
 * POSIX.1-2001
 * ISO C99
 */

// #if __DARWIN_C_LEVEL >= 200112L
public static native int fchown(int arg0, @Cast("uid_t") int arg1, @Cast("gid_t") int arg2);
public static native int gethostname(@Cast("char*") BytePointer arg0, @Cast("size_t") long arg1);
public static native int gethostname(@Cast("char*") ByteBuffer arg0, @Cast("size_t") long arg1);
public static native int gethostname(@Cast("char*") byte[] arg0, @Cast("size_t") long arg1);
public static native @Cast("ssize_t") long readlink(@Cast("const char*") BytePointer arg0, @Cast("char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("ssize_t") long readlink(String arg0, @Cast("char*") ByteBuffer arg1, @Cast("size_t") long arg2);
public static native @Cast("ssize_t") long readlink(@Cast("const char*") BytePointer arg0, @Cast("char*") byte[] arg1, @Cast("size_t") long arg2);
public static native @Cast("ssize_t") long readlink(String arg0, @Cast("char*") BytePointer arg1, @Cast("size_t") long arg2);
public static native @Cast("ssize_t") long readlink(@Cast("const char*") BytePointer arg0, @Cast("char*") ByteBuffer arg1, @Cast("size_t") long arg2);
public static native @Cast("ssize_t") long readlink(String arg0, @Cast("char*") byte[] arg1, @Cast("size_t") long arg2);
public static native int setegid(@Cast("gid_t") int arg0);
public static native int seteuid(@Cast("uid_t") int arg0);
public static native int symlink(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
public static native int symlink(String arg0, String arg1);
// #endif /* __DARWIN_C_LEVEL >= 200112L */



/* Darwin extensions */

// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
// #include <sys/select.h>

// #include <sys/_types/_dev_t.h>
// #include <sys/_types/_mode_t.h>
// #include <sys/_types/_uuid_t.h>
public static native int accessx_np(@Const accessx_descriptor arg0, @Cast("size_t") long arg1, IntPointer arg2, @Cast("uid_t") int arg3);
public static native int accessx_np(@Const accessx_descriptor arg0, @Cast("size_t") long arg1, IntBuffer arg2, @Cast("uid_t") int arg3);
public static native int accessx_np(@Const accessx_descriptor arg0, @Cast("size_t") long arg1, int[] arg2, @Cast("uid_t") int arg3);
public static native int acct(@Cast("const char*") BytePointer arg0);
public static native int acct(String arg0);
public static native int add_profil(@Cast("char*") BytePointer arg0, @Cast("size_t") long arg1, @Cast("unsigned long") long arg2, @Cast("unsigned int") int arg3);
public static native int add_profil(@Cast("char*") ByteBuffer arg0, @Cast("size_t") long arg1, @Cast("unsigned long") long arg2, @Cast("unsigned int") int arg3);
public static native int add_profil(@Cast("char*") byte[] arg0, @Cast("size_t") long arg1, @Cast("unsigned long") long arg2, @Cast("unsigned int") int arg3);
public static native void endusershell();
public static native int execvP(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("char*const*") PointerPointer arg2);
public static native int execvP(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("char*const*") @ByPtrPtr BytePointer arg2);
public static native int execvP(String arg0, String arg1, @Cast("char*const*") @ByPtrPtr ByteBuffer arg2);
public static native int execvP(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("char*const*") @ByPtrPtr byte[] arg2);
public static native int execvP(String arg0, String arg1, @Cast("char*const*") @ByPtrPtr BytePointer arg2);
public static native int execvP(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("char*const*") @ByPtrPtr ByteBuffer arg2);
public static native int execvP(String arg0, String arg1, @Cast("char*const*") @ByPtrPtr byte[] arg2);
public static native @Cast("char*") BytePointer fflagstostr(@Cast("unsigned long") long arg0);
public static native int getdomainname(@Cast("char*") BytePointer arg0, int arg1);
public static native int getdomainname(@Cast("char*") ByteBuffer arg0, int arg1);
public static native int getdomainname(@Cast("char*") byte[] arg0, int arg1);
public static native int getgrouplist(@Cast("const char*") BytePointer arg0, int arg1, IntPointer arg2, IntPointer arg3);
public static native int getgrouplist(String arg0, int arg1, IntBuffer arg2, IntBuffer arg3);
public static native int getgrouplist(@Cast("const char*") BytePointer arg0, int arg1, int[] arg2, int[] arg3);
public static native int getgrouplist(String arg0, int arg1, IntPointer arg2, IntPointer arg3);
public static native int getgrouplist(@Cast("const char*") BytePointer arg0, int arg1, IntBuffer arg2, IntBuffer arg3);
public static native int getgrouplist(String arg0, int arg1, int[] arg2, int[] arg3);
// #if defined(__has_include)
// #if __has_include(<gethostuuid_private.h>)
// #include <gethostuuid_private.h>
// #else
// #include <gethostuuid.h>
// #endif
// #else
// #include <gethostuuid.h>
// #endif
public static native @Cast("mode_t") short getmode(@Const Pointer arg0, @Cast("mode_t") short arg1);
public static native int getpeereid(int arg0, @Cast("uid_t*") IntPointer arg1, @Cast("gid_t*") IntPointer arg2);
public static native int getpeereid(int arg0, @Cast("uid_t*") IntBuffer arg1, @Cast("gid_t*") IntBuffer arg2);
public static native int getpeereid(int arg0, @Cast("uid_t*") int[] arg1, @Cast("gid_t*") int[] arg2);
public static native int getsgroups_np(IntPointer arg0, @Cast("unsigned char*") BytePointer arg1);
public static native int getsgroups_np(IntBuffer arg0, @Cast("unsigned char*") ByteBuffer arg1);
public static native int getsgroups_np(int[] arg0, @Cast("unsigned char*") byte[] arg1);
public static native @Cast("char*") BytePointer getusershell();
public static native int getwgroups_np(IntPointer arg0, @Cast("unsigned char*") BytePointer arg1);
public static native int getwgroups_np(IntBuffer arg0, @Cast("unsigned char*") ByteBuffer arg1);
public static native int getwgroups_np(int[] arg0, @Cast("unsigned char*") byte[] arg1);
public static native int initgroups(@Cast("const char*") BytePointer arg0, int arg1);
public static native int initgroups(String arg0, int arg1);
public static native int iruserok(@Cast("unsigned long") long arg0, int arg1, @Cast("const char*") BytePointer arg2, @Cast("const char*") BytePointer arg3);
public static native int iruserok(@Cast("unsigned long") long arg0, int arg1, String arg2, String arg3);
public static native int iruserok_sa(@Const Pointer arg0, int arg1, int arg2, @Cast("const char*") BytePointer arg3, @Cast("const char*") BytePointer arg4);
public static native int iruserok_sa(@Const Pointer arg0, int arg1, int arg2, String arg3, String arg4);
public static native int issetugid();
public static native @Cast("char*") BytePointer mkdtemp(@Cast("char*") BytePointer arg0);
public static native @Cast("char*") ByteBuffer mkdtemp(@Cast("char*") ByteBuffer arg0);
public static native @Cast("char*") byte[] mkdtemp(@Cast("char*") byte[] arg0);
public static native int mkpath_np(@Cast("const char*") BytePointer path, @Cast("mode_t") short omode);
public static native int mkpath_np(String path, @Cast("mode_t") short omode); /* returns errno */
public static native int mkstemps(@Cast("char*") BytePointer arg0, int arg1);
public static native int mkstemps(@Cast("char*") ByteBuffer arg0, int arg1);
public static native int mkstemps(@Cast("char*") byte[] arg0, int arg1);
public static native int nfssvc(int arg0, Pointer arg1);
public static native int profil(@Cast("char*") BytePointer arg0, @Cast("size_t") long arg1, @Cast("unsigned long") long arg2, @Cast("unsigned int") int arg3);
public static native int profil(@Cast("char*") ByteBuffer arg0, @Cast("size_t") long arg1, @Cast("unsigned long") long arg2, @Cast("unsigned int") int arg3);
public static native int profil(@Cast("char*") byte[] arg0, @Cast("size_t") long arg1, @Cast("unsigned long") long arg2, @Cast("unsigned int") int arg3);
public static native int pthread_setugid_np(@Cast("uid_t") int arg0, @Cast("gid_t") int arg1);
public static native int pthread_getugid_np( @Cast("uid_t*") IntPointer arg0, @Cast("gid_t*") IntPointer arg1);
public static native int pthread_getugid_np( @Cast("uid_t*") IntBuffer arg0, @Cast("gid_t*") IntBuffer arg1);
public static native int pthread_getugid_np( @Cast("uid_t*") int[] arg0, @Cast("gid_t*") int[] arg1);
public static native int rcmd(@Cast("char**") PointerPointer arg0, int arg1, @Cast("const char*") BytePointer arg2, @Cast("const char*") BytePointer arg3, @Cast("const char*") BytePointer arg4, IntPointer arg5);
public static native int rcmd(@Cast("char**") @ByPtrPtr BytePointer arg0, int arg1, @Cast("const char*") BytePointer arg2, @Cast("const char*") BytePointer arg3, @Cast("const char*") BytePointer arg4, IntPointer arg5);
public static native int rcmd(@Cast("char**") @ByPtrPtr ByteBuffer arg0, int arg1, String arg2, String arg3, String arg4, IntBuffer arg5);
public static native int rcmd(@Cast("char**") @ByPtrPtr byte[] arg0, int arg1, @Cast("const char*") BytePointer arg2, @Cast("const char*") BytePointer arg3, @Cast("const char*") BytePointer arg4, int[] arg5);
public static native int rcmd(@Cast("char**") @ByPtrPtr BytePointer arg0, int arg1, String arg2, String arg3, String arg4, IntPointer arg5);
public static native int rcmd(@Cast("char**") @ByPtrPtr ByteBuffer arg0, int arg1, @Cast("const char*") BytePointer arg2, @Cast("const char*") BytePointer arg3, @Cast("const char*") BytePointer arg4, IntBuffer arg5);
public static native int rcmd(@Cast("char**") @ByPtrPtr byte[] arg0, int arg1, String arg2, String arg3, String arg4, int[] arg5);
public static native int rcmd_af(@Cast("char**") PointerPointer arg0, int arg1, @Cast("const char*") BytePointer arg2, @Cast("const char*") BytePointer arg3, @Cast("const char*") BytePointer arg4, IntPointer arg5,
		int arg6);
public static native int rcmd_af(@Cast("char**") @ByPtrPtr BytePointer arg0, int arg1, @Cast("const char*") BytePointer arg2, @Cast("const char*") BytePointer arg3, @Cast("const char*") BytePointer arg4, IntPointer arg5,
		int arg6);
public static native int rcmd_af(@Cast("char**") @ByPtrPtr ByteBuffer arg0, int arg1, String arg2, String arg3, String arg4, IntBuffer arg5,
		int arg6);
public static native int rcmd_af(@Cast("char**") @ByPtrPtr byte[] arg0, int arg1, @Cast("const char*") BytePointer arg2, @Cast("const char*") BytePointer arg3, @Cast("const char*") BytePointer arg4, int[] arg5,
		int arg6);
public static native int rcmd_af(@Cast("char**") @ByPtrPtr BytePointer arg0, int arg1, String arg2, String arg3, String arg4, IntPointer arg5,
		int arg6);
public static native int rcmd_af(@Cast("char**") @ByPtrPtr ByteBuffer arg0, int arg1, @Cast("const char*") BytePointer arg2, @Cast("const char*") BytePointer arg3, @Cast("const char*") BytePointer arg4, IntBuffer arg5,
		int arg6);
public static native int rcmd_af(@Cast("char**") @ByPtrPtr byte[] arg0, int arg1, String arg2, String arg3, String arg4, int[] arg5,
		int arg6);
public static native int reboot(int arg0);
public static native int revoke(@Cast("const char*") BytePointer arg0);
public static native int revoke(String arg0);
public static native int rresvport(IntPointer arg0);
public static native int rresvport(IntBuffer arg0);
public static native int rresvport(int[] arg0);
public static native int rresvport_af(IntPointer arg0, int arg1);
public static native int rresvport_af(IntBuffer arg0, int arg1);
public static native int rresvport_af(int[] arg0, int arg1);
public static native int ruserok(@Cast("const char*") BytePointer arg0, int arg1, @Cast("const char*") BytePointer arg2, @Cast("const char*") BytePointer arg3);
public static native int ruserok(String arg0, int arg1, String arg2, String arg3);
public static native int setdomainname(@Cast("const char*") BytePointer arg0, int arg1);
public static native int setdomainname(String arg0, int arg1);
public static native int setgroups(int arg0, @Cast("const gid_t*") IntPointer arg1);
public static native int setgroups(int arg0, @Cast("const gid_t*") IntBuffer arg1);
public static native int setgroups(int arg0, @Cast("const gid_t*") int[] arg1);
public static native void sethostid(long arg0);
public static native int sethostname(@Cast("const char*") BytePointer arg0, int arg1);
public static native int sethostname(String arg0, int arg1);
// #if __DARWIN_UNIX03
// #else /* !__DARWIN_UNIX03 */
// #endif /* __DARWIN_UNIX03 */
public static native int setlogin(@Cast("const char*") BytePointer arg0);
public static native int setlogin(String arg0);
public static native Pointer setmode(@Cast("const char*") BytePointer arg0);
public static native Pointer setmode(String arg0);
public static native int setrgid(@Cast("gid_t") int arg0);
public static native int setruid(@Cast("uid_t") int arg0);
public static native int setsgroups_np(int arg0, @Cast("unsigned char*") BytePointer arg1);
public static native int setsgroups_np(int arg0, @Cast("unsigned char*") ByteBuffer arg1);
public static native int setsgroups_np(int arg0, @Cast("unsigned char*") byte[] arg1);
public static native void setusershell();
public static native int setwgroups_np(int arg0, @Cast("unsigned char*") BytePointer arg1);
public static native int setwgroups_np(int arg0, @Cast("unsigned char*") ByteBuffer arg1);
public static native int setwgroups_np(int arg0, @Cast("unsigned char*") byte[] arg1);
public static native int strtofflags(@Cast("char**") PointerPointer arg0, @Cast("unsigned long*") CLongPointer arg1, @Cast("unsigned long*") CLongPointer arg2);
public static native int strtofflags(@Cast("char**") @ByPtrPtr BytePointer arg0, @Cast("unsigned long*") CLongPointer arg1, @Cast("unsigned long*") CLongPointer arg2);
public static native int strtofflags(@Cast("char**") @ByPtrPtr ByteBuffer arg0, @Cast("unsigned long*") CLongPointer arg1, @Cast("unsigned long*") CLongPointer arg2);
public static native int strtofflags(@Cast("char**") @ByPtrPtr byte[] arg0, @Cast("unsigned long*") CLongPointer arg1, @Cast("unsigned long*") CLongPointer arg2);
public static native int swapon(@Cast("const char*") BytePointer arg0);
public static native int swapon(String arg0);
public static native int syscall(int arg0);
public static native int ttyslot();
public static native int undelete(@Cast("const char*") BytePointer arg0);
public static native int undelete(String arg0);
public static native int unwhiteout(@Cast("const char*") BytePointer arg0);
public static native int unwhiteout(String arg0);			/* getsubopt(3) external variable */

/*  HFS & HFS Plus semantics system calls go here */
// #ifdef __LP64__
public static native int fgetattrlist(int arg0,Pointer arg1,Pointer arg2,@Cast("size_t") long arg3,@Cast("unsigned int") int arg4);
public static native int fsetattrlist(int arg0,Pointer arg1,Pointer arg2,@Cast("size_t") long arg3,@Cast("unsigned int") int arg4);
public static native int getattrlist(@Cast("const char*") BytePointer arg0,Pointer arg1,Pointer arg2,@Cast("size_t") long arg3,@Cast("unsigned int") int arg4);
public static native int getattrlist(String arg0,Pointer arg1,Pointer arg2,@Cast("size_t") long arg3,@Cast("unsigned int") int arg4);
public static native int setattrlist(@Cast("const char*") BytePointer arg0,Pointer arg1,Pointer arg2,@Cast("size_t") long arg3,@Cast("unsigned int") int arg4);
public static native int setattrlist(String arg0,Pointer arg1,Pointer arg2,@Cast("size_t") long arg3,@Cast("unsigned int") int arg4);
public static native int exchangedata(@Cast("const char*") BytePointer arg0,@Cast("const char*") BytePointer arg1,@Cast("unsigned int") int arg2);
public static native int exchangedata(String arg0,String arg1,@Cast("unsigned int") int arg2);
public static native int getdirentriesattr(int arg0,Pointer arg1,Pointer arg2,@Cast("size_t") long arg3,@Cast("unsigned int*") IntPointer arg4,@Cast("unsigned int*") IntPointer arg5,@Cast("unsigned int*") IntPointer arg6,@Cast("unsigned int") int arg7);
public static native int getdirentriesattr(int arg0,Pointer arg1,Pointer arg2,@Cast("size_t") long arg3,@Cast("unsigned int*") IntBuffer arg4,@Cast("unsigned int*") IntBuffer arg5,@Cast("unsigned int*") IntBuffer arg6,@Cast("unsigned int") int arg7);
public static native int getdirentriesattr(int arg0,Pointer arg1,Pointer arg2,@Cast("size_t") long arg3,@Cast("unsigned int*") int[] arg4,@Cast("unsigned int*") int[] arg5,@Cast("unsigned int*") int[] arg6,@Cast("unsigned int") int arg7);

// #else /* __LP64__ */

// #endif /* __LP64__ */

@Opaque public static class fssearchblock extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public fssearchblock() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public fssearchblock(Pointer p) { super(p); }
}
@Opaque public static class searchstate extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public searchstate() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public searchstate(Pointer p) { super(p); }
}

public static native int searchfs(@Cast("const char*") BytePointer arg0, fssearchblock arg1, @Cast("unsigned long*") CLongPointer arg2, @Cast("unsigned int") int arg3, @Cast("unsigned int") int arg4, searchstate arg5);
public static native int searchfs(String arg0, fssearchblock arg1, @Cast("unsigned long*") CLongPointer arg2, @Cast("unsigned int") int arg3, @Cast("unsigned int") int arg4, searchstate arg5);
public static native int fsctl(@Cast("const char*") BytePointer arg0,@Cast("unsigned long") long arg1,Pointer arg2,@Cast("unsigned int") int arg3);
public static native int fsctl(String arg0,@Cast("unsigned long") long arg1,Pointer arg2,@Cast("unsigned int") int arg3);
public static native int ffsctl(int arg0,@Cast("unsigned long") long arg1,Pointer arg2,@Cast("unsigned int") int arg3);

public static final int SYNC_VOLUME_FULLSYNC =	0x01;	/* Flush data and metadata to platter, not just to disk cache */
public static final int SYNC_VOLUME_WAIT =	0x02;	/* Wait for sync to complete */

public static native int fsync_volume_np(int arg0, int arg1);
public static native int sync_volume_np(@Cast("const char*") BytePointer arg0, int arg1);
public static native int sync_volume_np(String arg0, int arg1);

public static native int optreset(); public static native void optreset(int optreset);

// #endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */

// #endif /* _UNISTD_H_ */


// Parsed from sys/poll.h

/*
 * Copyright (c) 2000-2004 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/*-
 * Copyright (c) 1997 Peter Wemm <peter@freebsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

// #ifndef _SYS_POLL_H_
// #define	_SYS_POLL_H_

/*
 * This file is intended to be compatible with the traditional poll.h.
 */

/*
 * Requestable events.  If poll(2) finds any of these set, they are
 * copied to revents on return.
 */
public static final int POLLIN =		0x0001;		/* any readable data available */
public static final int POLLPRI =		0x0002;		/* OOB/Urgent readable data */
public static final int POLLOUT =		0x0004;		/* file descriptor is writeable */
public static final int POLLRDNORM =	0x0040;		/* non-OOB/URG data available */
public static final int POLLWRNORM =	POLLOUT;		/* no write type differentiation */
public static final int POLLRDBAND =	0x0080;		/* OOB/Urgent readable data */
public static final int POLLWRBAND =	0x0100;		/* OOB/Urgent data can be written */

/*
 * FreeBSD extensions: polling on a regular file might return one
 * of these events (currently only supported on local filesystems).
 */
public static final int POLLEXTEND =	0x0200;		/* file may have been extended */
public static final int POLLATTRIB =	0x0400;		/* file attributes may have changed */
public static final int POLLNLINK =	0x0800;		/* (un)link/rename may have happened */
public static final int POLLWRITE =	0x1000;		/* file's contents may have changed */

/*
 * These events are set if they occur regardless of whether they were
 * requested.
 */
public static final int POLLERR =		0x0008;		/* some poll error occurred */
public static final int POLLHUP =		0x0010;		/* file descriptor was "hung up" */
public static final int POLLNVAL =	0x0020;		/* requested events "invalid" */

public static final int POLLSTANDARD =	(POLLIN|POLLPRI|POLLOUT|POLLRDNORM|POLLRDBAND|
			 POLLWRBAND|POLLERR|POLLHUP|POLLNVAL);

public static class pollfd extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public pollfd() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public pollfd(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public pollfd(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public pollfd position(long position) {
        return (pollfd)super.position(position);
    }

	public native int fd(); public native pollfd fd(int fd);
	public native short events(); public native pollfd events(short events);
	public native short revents(); public native pollfd revents(short revents);
}


// #include <sys/cdefs.h>

/*
 * This is defined here (instead of <poll.h>) because this is where
 * traditional SVR4 code will look to find it.
 */
public static native int poll(pollfd arg0, @Cast("nfds_t") int arg1, int arg2);

// #endif /* !_SYS_POLL_H_ */


// Parsed from sys/reboot.h

/*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1988, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)reboot.h	8.3 (Berkeley) 12/13/94
 */

// #ifndef	_SYS_REBOOT_H_
// #define _SYS_REBOOT_H_

// #include <sys/appleapiopts.h>

/*
 * Arguments to reboot system call.
 */

// #ifdef __APPLE_API_PRIVATE
public static final int RB_AUTOBOOT =	0;	/* flags for system auto-booting itself */

public static final int RB_ASKNAME =	0x01;	/* ask for file name to reboot from */
public static final int RB_SINGLE =	0x02;	/* reboot to single user only */
public static final int RB_NOSYNC =	0x04;	/* dont sync before reboot */
public static final int RB_HALT =		0x08;	/* don't reboot, just halt */
public static final int RB_INITNAME =	0x10;	/* name given for /etc/init */
public static final int RB_DFLTROOT =	0x20;	/* use compiled-in rootdev */
public static final int RB_ALTBOOT =	0x40;	/* use /boot.old vs /boot */
public static final int RB_UNIPROC =	0x80;	/* don't start slaves */
public static final int RB_SAFEBOOT =	0x100;	/* booting safe */
public static final int RB_UPSDELAY = 0x200;   /* Delays restart by 5 minutes */
public static final int RB_QUICK =	0x400;	/* quick and ungraceful reboot with file system caches flushed*/
public static final int RB_PANIC =	0;	/* reboot due to panic */
public static final int RB_BOOT =		1;	/* reboot due to boot() */

// #endif /* __APPLE_API_PRIVATE */

// #ifdef __APPLE_API_OBSOLETE
/*
 * Constants for converting boot-style device number to type,
 * adaptor (uba, mba, etc), unit number and partition number.
 * Type (== major device number) is in the low byte
 * for backward compatibility.  Except for that of the "magic
 * number", each mask applies to the shifted value.
 * Format:
 *	 (4) (4) (4) (4)  (8)     (8)
 *	--------------------------------
 *	|MA | AD| CT| UN| PART  | TYPE |
 *	--------------------------------
 */
public static final int B_ADAPTORSHIFT =	24;
public static final int B_ADAPTORMASK =	0x0f;
// #define	B_ADAPTOR(val)		(((val) >> B_ADAPTORSHIFT) & B_ADAPTORMASK)
public static final int B_CONTROLLERSHIFT =	20;
public static final int B_CONTROLLERMASK =	0xf;
// #define	B_CONTROLLER(val)	(((val)>>B_CONTROLLERSHIFT) & B_CONTROLLERMASK)
public static final int B_UNITSHIFT =	16;
public static final int B_UNITMASK =	0xff;
// #define	B_UNIT(val)		(((val) >> B_UNITSHIFT) & B_UNITMASK)
public static final int B_PARTITIONSHIFT = 8;
public static final int B_PARTITIONMASK =	0xff;
// #define	B_PARTITION(val)	(((val) >> B_PARTITIONSHIFT) & B_PARTITIONMASK)
public static final int B_TYPESHIFT =	0;
public static final int B_TYPEMASK =	0xff;
// #define	B_TYPE(val)		(((val) >> B_TYPESHIFT) & B_TYPEMASK)
public static final int B_MAGICMASK =	0xf0000000;
public static final int B_DEVMAGIC =	0xa0000000;

// #define MAKEBOOTDEV(type, adaptor, controller, unit, partition)
// 	(((type) << B_TYPESHIFT) | ((adaptor) << B_ADAPTORSHIFT) |
// 	((controller) << B_CONTROLLERSHIFT) | ((unit) << B_UNITSHIFT) |
// 	((partition) << B_PARTITIONSHIFT) | B_DEVMAGIC)

// #endif /* __APPLE_API_OBSOLETE */


// #endif	/* _SYS_REBOOT_H_ */


// Parsed from sys/resource.h

/*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)resource.h	8.2 (Berkeley) 1/4/94
 */

// #ifndef _SYS_RESOURCE_H_
// #define	_SYS_RESOURCE_H_

// #include <sys/appleapiopts.h>
// #include <sys/cdefs.h>
// #include <sys/_types.h>

// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
// #include <stdint.h>
// #endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */

// #include <Availability.h>

/* [XSI] The timeval structure shall be defined as described in
 * <sys/time.h>
 */
// #include <sys/_types/_timeval.h>

/* The id_t type shall be defined as described in <sys/types.h> */
// #include <sys/_types/_id_t.h>


/*
 * Resource limit type (low 63 bits, excluding the sign bit)
 */


/*****
 * PRIORITY
 */

/*
 * Possible values of the first parameter to getpriority()/setpriority(),
 * used to indicate the type of the second parameter.
 */
public static final int PRIO_PROCESS =	0;		/* Second argument is a PID */
public static final int PRIO_PGRP =	1;		/* Second argument is a GID */
public static final int PRIO_USER =	2;		/* Second argument is a UID */

// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static final int PRIO_DARWIN_THREAD =	3;		/* Second argument is always 0 (current thread) */
public static final int PRIO_DARWIN_PROCESS =	4;		/* Second argument is a PID */


/*
 * Range limitations for the value of the third parameter to setpriority().
 */
public static final int PRIO_MIN =	-20;
public static final int PRIO_MAX =	20;

/* 
 * use PRIO_DARWIN_BG to set the current thread into "background" state
 * which lowers CPU, disk IO, and networking priorites until thread terminates
 * or "background" state is revoked
 */
public static final int PRIO_DARWIN_BG = 0x1000;

/*
 * use PRIO_DARWIN_NONUI to restrict a process's ability to make calls to
 * the GPU. (deprecated)
 */
public static final int PRIO_DARWIN_NONUI = 0x1001;

// #endif	/* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */



/*****
 * RESOURCE USAGE
 */

/*
 * Possible values of the first parameter to getrusage(), used to indicate
 * the scope of the information to be returned.
 */
public static final int RUSAGE_SELF =	0;		/* Current process information */
public static final int RUSAGE_CHILDREN =	-1;		/* Current process' children */

/*
 * A structure representing an accounting of resource utilization.  The
 * address of an instance of this structure is the second parameter to
 * getrusage().
 *
 * Note: All values other than ru_utime and ru_stime are implementaiton
 *       defined and subject to change in a future release.  Their use
 *       is discouraged for standards compliant programs.
 */
public static class rusage extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public rusage() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public rusage(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public rusage(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public rusage position(long position) {
        return (rusage)super.position(position);
    }

	public native @ByRef timeval ru_utime(); public native rusage ru_utime(timeval ru_utime);	/* user time used (PL) */
	public native @ByRef timeval ru_stime(); public native rusage ru_stime(timeval ru_stime);	/* system time used (PL) */
// #if __DARWIN_C_LEVEL < __DARWIN_C_FULL
// #else
	/*
	 * Informational aliases for source compatibility with programs
	 * that need more information than that provided by standards,
	 * and which do not mind being OS-dependent.
	 */
	public native long ru_maxrss(); public native rusage ru_maxrss(long ru_maxrss);		/* max resident set size (PL) */
// #define	ru_first	ru_ixrss	/* internal: ruadd() range start */
	public native long ru_ixrss(); public native rusage ru_ixrss(long ru_ixrss);		/* integral shared memory size (NU) */
	public native long ru_idrss(); public native rusage ru_idrss(long ru_idrss);		/* integral unshared data (NU)  */
	public native long ru_isrss(); public native rusage ru_isrss(long ru_isrss);		/* integral unshared stack (NU) */
	public native long ru_minflt(); public native rusage ru_minflt(long ru_minflt);		/* page reclaims (NU) */
	public native long ru_majflt(); public native rusage ru_majflt(long ru_majflt);		/* page faults (NU) */
	public native long ru_nswap(); public native rusage ru_nswap(long ru_nswap);		/* swaps (NU) */
	public native long ru_inblock(); public native rusage ru_inblock(long ru_inblock);		/* block input operations (atomic) */
	public native long ru_oublock(); public native rusage ru_oublock(long ru_oublock);		/* block output operations (atomic) */
	public native long ru_msgsnd(); public native rusage ru_msgsnd(long ru_msgsnd);		/* messages sent (atomic) */
	public native long ru_msgrcv(); public native rusage ru_msgrcv(long ru_msgrcv);		/* messages received (atomic) */
	public native long ru_nsignals(); public native rusage ru_nsignals(long ru_nsignals);		/* signals received (atomic) */
	public native long ru_nvcsw(); public native rusage ru_nvcsw(long ru_nvcsw);		/* voluntary context switches (atomic) */
	public native long ru_nivcsw(); public native rusage ru_nivcsw(long ru_nivcsw);		/* involuntary " */
// #define	ru_last		ru_nivcsw	/* internal: ruadd() range end */
// #endif	/* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */
}

// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
/*
 * Flavors for proc_pid_rusage().
 */
public static final int RUSAGE_INFO_V0 =	0;
public static final int RUSAGE_INFO_V1 =	1;
public static final int RUSAGE_INFO_V2 =	2;
public static final int RUSAGE_INFO_V3 =	3;
public static final int RUSAGE_INFO_CURRENT = RUSAGE_INFO_V3;

@Namespace @Name("void") @Opaque public static class rusage_info_t extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public rusage_info_t() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public rusage_info_t(Pointer p) { super(p); }
}

public static class rusage_info_v0 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public rusage_info_v0() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public rusage_info_v0(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public rusage_info_v0(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public rusage_info_v0 position(long position) {
        return (rusage_info_v0)super.position(position);
    }

	public native @Cast("uint8_t") byte ri_uuid(int i); public native rusage_info_v0 ri_uuid(int i, byte ri_uuid);
	@MemberGetter public native @Cast("uint8_t*") BytePointer ri_uuid();
	public native @Cast("uint64_t") long ri_user_time(); public native rusage_info_v0 ri_user_time(long ri_user_time);
	public native @Cast("uint64_t") long ri_system_time(); public native rusage_info_v0 ri_system_time(long ri_system_time);
	public native @Cast("uint64_t") long ri_pkg_idle_wkups(); public native rusage_info_v0 ri_pkg_idle_wkups(long ri_pkg_idle_wkups);
	public native @Cast("uint64_t") long ri_interrupt_wkups(); public native rusage_info_v0 ri_interrupt_wkups(long ri_interrupt_wkups);
	public native @Cast("uint64_t") long ri_pageins(); public native rusage_info_v0 ri_pageins(long ri_pageins);
	public native @Cast("uint64_t") long ri_wired_size(); public native rusage_info_v0 ri_wired_size(long ri_wired_size);
	public native @Cast("uint64_t") long ri_resident_size(); public native rusage_info_v0 ri_resident_size(long ri_resident_size);	
	public native @Cast("uint64_t") long ri_phys_footprint(); public native rusage_info_v0 ri_phys_footprint(long ri_phys_footprint);
	public native @Cast("uint64_t") long ri_proc_start_abstime(); public native rusage_info_v0 ri_proc_start_abstime(long ri_proc_start_abstime);
	public native @Cast("uint64_t") long ri_proc_exit_abstime(); public native rusage_info_v0 ri_proc_exit_abstime(long ri_proc_exit_abstime);
}

public static class rusage_info_v1 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public rusage_info_v1() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public rusage_info_v1(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public rusage_info_v1(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public rusage_info_v1 position(long position) {
        return (rusage_info_v1)super.position(position);
    }

	public native @Cast("uint8_t") byte ri_uuid(int i); public native rusage_info_v1 ri_uuid(int i, byte ri_uuid);
	@MemberGetter public native @Cast("uint8_t*") BytePointer ri_uuid();
	public native @Cast("uint64_t") long ri_user_time(); public native rusage_info_v1 ri_user_time(long ri_user_time);
	public native @Cast("uint64_t") long ri_system_time(); public native rusage_info_v1 ri_system_time(long ri_system_time);
	public native @Cast("uint64_t") long ri_pkg_idle_wkups(); public native rusage_info_v1 ri_pkg_idle_wkups(long ri_pkg_idle_wkups);
	public native @Cast("uint64_t") long ri_interrupt_wkups(); public native rusage_info_v1 ri_interrupt_wkups(long ri_interrupt_wkups);
	public native @Cast("uint64_t") long ri_pageins(); public native rusage_info_v1 ri_pageins(long ri_pageins);
	public native @Cast("uint64_t") long ri_wired_size(); public native rusage_info_v1 ri_wired_size(long ri_wired_size);
	public native @Cast("uint64_t") long ri_resident_size(); public native rusage_info_v1 ri_resident_size(long ri_resident_size);	
	public native @Cast("uint64_t") long ri_phys_footprint(); public native rusage_info_v1 ri_phys_footprint(long ri_phys_footprint);
	public native @Cast("uint64_t") long ri_proc_start_abstime(); public native rusage_info_v1 ri_proc_start_abstime(long ri_proc_start_abstime);
	public native @Cast("uint64_t") long ri_proc_exit_abstime(); public native rusage_info_v1 ri_proc_exit_abstime(long ri_proc_exit_abstime);
	public native @Cast("uint64_t") long ri_child_user_time(); public native rusage_info_v1 ri_child_user_time(long ri_child_user_time);
	public native @Cast("uint64_t") long ri_child_system_time(); public native rusage_info_v1 ri_child_system_time(long ri_child_system_time);
	public native @Cast("uint64_t") long ri_child_pkg_idle_wkups(); public native rusage_info_v1 ri_child_pkg_idle_wkups(long ri_child_pkg_idle_wkups);
	public native @Cast("uint64_t") long ri_child_interrupt_wkups(); public native rusage_info_v1 ri_child_interrupt_wkups(long ri_child_interrupt_wkups);
	public native @Cast("uint64_t") long ri_child_pageins(); public native rusage_info_v1 ri_child_pageins(long ri_child_pageins);
	public native @Cast("uint64_t") long ri_child_elapsed_abstime(); public native rusage_info_v1 ri_child_elapsed_abstime(long ri_child_elapsed_abstime);
}

public static class rusage_info_v2 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public rusage_info_v2() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public rusage_info_v2(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public rusage_info_v2(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public rusage_info_v2 position(long position) {
        return (rusage_info_v2)super.position(position);
    }

	public native @Cast("uint8_t") byte ri_uuid(int i); public native rusage_info_v2 ri_uuid(int i, byte ri_uuid);
	@MemberGetter public native @Cast("uint8_t*") BytePointer ri_uuid();
	public native @Cast("uint64_t") long ri_user_time(); public native rusage_info_v2 ri_user_time(long ri_user_time);
	public native @Cast("uint64_t") long ri_system_time(); public native rusage_info_v2 ri_system_time(long ri_system_time);
	public native @Cast("uint64_t") long ri_pkg_idle_wkups(); public native rusage_info_v2 ri_pkg_idle_wkups(long ri_pkg_idle_wkups);
	public native @Cast("uint64_t") long ri_interrupt_wkups(); public native rusage_info_v2 ri_interrupt_wkups(long ri_interrupt_wkups);
	public native @Cast("uint64_t") long ri_pageins(); public native rusage_info_v2 ri_pageins(long ri_pageins);
	public native @Cast("uint64_t") long ri_wired_size(); public native rusage_info_v2 ri_wired_size(long ri_wired_size);
	public native @Cast("uint64_t") long ri_resident_size(); public native rusage_info_v2 ri_resident_size(long ri_resident_size);	
	public native @Cast("uint64_t") long ri_phys_footprint(); public native rusage_info_v2 ri_phys_footprint(long ri_phys_footprint);
	public native @Cast("uint64_t") long ri_proc_start_abstime(); public native rusage_info_v2 ri_proc_start_abstime(long ri_proc_start_abstime);
	public native @Cast("uint64_t") long ri_proc_exit_abstime(); public native rusage_info_v2 ri_proc_exit_abstime(long ri_proc_exit_abstime);
	public native @Cast("uint64_t") long ri_child_user_time(); public native rusage_info_v2 ri_child_user_time(long ri_child_user_time);
	public native @Cast("uint64_t") long ri_child_system_time(); public native rusage_info_v2 ri_child_system_time(long ri_child_system_time);
	public native @Cast("uint64_t") long ri_child_pkg_idle_wkups(); public native rusage_info_v2 ri_child_pkg_idle_wkups(long ri_child_pkg_idle_wkups);
	public native @Cast("uint64_t") long ri_child_interrupt_wkups(); public native rusage_info_v2 ri_child_interrupt_wkups(long ri_child_interrupt_wkups);
	public native @Cast("uint64_t") long ri_child_pageins(); public native rusage_info_v2 ri_child_pageins(long ri_child_pageins);
	public native @Cast("uint64_t") long ri_child_elapsed_abstime(); public native rusage_info_v2 ri_child_elapsed_abstime(long ri_child_elapsed_abstime);
	public native @Cast("uint64_t") long ri_diskio_bytesread(); public native rusage_info_v2 ri_diskio_bytesread(long ri_diskio_bytesread);
	public native @Cast("uint64_t") long ri_diskio_byteswritten(); public native rusage_info_v2 ri_diskio_byteswritten(long ri_diskio_byteswritten);
}

public static class rusage_info_v3 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public rusage_info_v3() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public rusage_info_v3(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public rusage_info_v3(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public rusage_info_v3 position(long position) {
        return (rusage_info_v3)super.position(position);
    }

	public native @Cast("uint8_t") byte ri_uuid(int i); public native rusage_info_v3 ri_uuid(int i, byte ri_uuid);
	@MemberGetter public native @Cast("uint8_t*") BytePointer ri_uuid();
	public native @Cast("uint64_t") long ri_user_time(); public native rusage_info_v3 ri_user_time(long ri_user_time);
	public native @Cast("uint64_t") long ri_system_time(); public native rusage_info_v3 ri_system_time(long ri_system_time);
	public native @Cast("uint64_t") long ri_pkg_idle_wkups(); public native rusage_info_v3 ri_pkg_idle_wkups(long ri_pkg_idle_wkups);
	public native @Cast("uint64_t") long ri_interrupt_wkups(); public native rusage_info_v3 ri_interrupt_wkups(long ri_interrupt_wkups);
	public native @Cast("uint64_t") long ri_pageins(); public native rusage_info_v3 ri_pageins(long ri_pageins);
	public native @Cast("uint64_t") long ri_wired_size(); public native rusage_info_v3 ri_wired_size(long ri_wired_size);
	public native @Cast("uint64_t") long ri_resident_size(); public native rusage_info_v3 ri_resident_size(long ri_resident_size);	
	public native @Cast("uint64_t") long ri_phys_footprint(); public native rusage_info_v3 ri_phys_footprint(long ri_phys_footprint);
	public native @Cast("uint64_t") long ri_proc_start_abstime(); public native rusage_info_v3 ri_proc_start_abstime(long ri_proc_start_abstime);
	public native @Cast("uint64_t") long ri_proc_exit_abstime(); public native rusage_info_v3 ri_proc_exit_abstime(long ri_proc_exit_abstime);
	public native @Cast("uint64_t") long ri_child_user_time(); public native rusage_info_v3 ri_child_user_time(long ri_child_user_time);
	public native @Cast("uint64_t") long ri_child_system_time(); public native rusage_info_v3 ri_child_system_time(long ri_child_system_time);
	public native @Cast("uint64_t") long ri_child_pkg_idle_wkups(); public native rusage_info_v3 ri_child_pkg_idle_wkups(long ri_child_pkg_idle_wkups);
	public native @Cast("uint64_t") long ri_child_interrupt_wkups(); public native rusage_info_v3 ri_child_interrupt_wkups(long ri_child_interrupt_wkups);
	public native @Cast("uint64_t") long ri_child_pageins(); public native rusage_info_v3 ri_child_pageins(long ri_child_pageins);
	public native @Cast("uint64_t") long ri_child_elapsed_abstime(); public native rusage_info_v3 ri_child_elapsed_abstime(long ri_child_elapsed_abstime);
	public native @Cast("uint64_t") long ri_diskio_bytesread(); public native rusage_info_v3 ri_diskio_bytesread(long ri_diskio_bytesread);
	public native @Cast("uint64_t") long ri_diskio_byteswritten(); public native rusage_info_v3 ri_diskio_byteswritten(long ri_diskio_byteswritten);
	public native @Cast("uint64_t") long ri_cpu_time_qos_default(); public native rusage_info_v3 ri_cpu_time_qos_default(long ri_cpu_time_qos_default);
	public native @Cast("uint64_t") long ri_cpu_time_qos_maintenance(); public native rusage_info_v3 ri_cpu_time_qos_maintenance(long ri_cpu_time_qos_maintenance);
	public native @Cast("uint64_t") long ri_cpu_time_qos_background(); public native rusage_info_v3 ri_cpu_time_qos_background(long ri_cpu_time_qos_background);
	public native @Cast("uint64_t") long ri_cpu_time_qos_utility(); public native rusage_info_v3 ri_cpu_time_qos_utility(long ri_cpu_time_qos_utility);
	public native @Cast("uint64_t") long ri_cpu_time_qos_legacy(); public native rusage_info_v3 ri_cpu_time_qos_legacy(long ri_cpu_time_qos_legacy);
	public native @Cast("uint64_t") long ri_cpu_time_qos_user_initiated(); public native rusage_info_v3 ri_cpu_time_qos_user_initiated(long ri_cpu_time_qos_user_initiated);
	public native @Cast("uint64_t") long ri_cpu_time_qos_user_interactive(); public native rusage_info_v3 ri_cpu_time_qos_user_interactive(long ri_cpu_time_qos_user_interactive);
	public native @Cast("uint64_t") long ri_billed_system_time(); public native rusage_info_v3 ri_billed_system_time(long ri_billed_system_time);
	public native @Cast("uint64_t") long ri_serviced_system_time(); public native rusage_info_v3 ri_serviced_system_time(long ri_serviced_system_time);
}

@Opaque public static class rusage_info_current extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public rusage_info_current() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public rusage_info_current(Pointer p) { super(p); }
}

// #endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */



/*****
 * RESOURCE LIMITS
 */

/*
 * Symbolic constants for resource limits; since all limits are representable
 * as a type rlim_t, we are permitted to define RLIM_SAVED_* in terms of
 * RLIM_INFINITY.
 */
public static native @MemberGetter long RLIM_INFINITY();
public static final long RLIM_INFINITY = RLIM_INFINITY();	/* no limit */
public static native @MemberGetter long RLIM_SAVED_MAX();
public static final long RLIM_SAVED_MAX = RLIM_SAVED_MAX();	/* Unrepresentable hard limit */
public static native @MemberGetter long RLIM_SAVED_CUR();
public static final long RLIM_SAVED_CUR = RLIM_SAVED_CUR();	/* Unrepresentable soft limit */

/*
 * Possible values of the first parameter to getrlimit()/setrlimit(), to
 * indicate for which resource the operation is being performed.
 */
public static final int RLIMIT_CPU =	0;		/* cpu time per process */
public static final int RLIMIT_FSIZE =	1;		/* file size */
public static final int RLIMIT_DATA =	2;		/* data segment size */
public static final int RLIMIT_STACK =	3;		/* stack size */
public static final int RLIMIT_CORE =	4;		/* core file size */
public static final int RLIMIT_AS =	5;		/* address space (resident set size) */
// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static final int RLIMIT_RSS =	RLIMIT_AS;	/* source compatibility alias */
public static final int RLIMIT_MEMLOCK =	6;		/* locked-in-memory address space */
public static final int RLIMIT_NPROC =	7;		/* number of processes */
// #endif	/* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */
public static final int RLIMIT_NOFILE =	8;		/* number of open files */
// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static final int RLIM_NLIMITS =	9;		/* total number of resource limits */
// #endif	/* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */
public static final int _RLIMIT_POSIX_FLAG =	0x1000;	/* Set bit for strict POSIX */

/*
 * A structure representing a resource limit.  The address of an instance
 * of this structure is the second parameter to getrlimit()/setrlimit().
 */
public static class rlimit extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public rlimit() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public rlimit(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public rlimit(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public rlimit position(long position) {
        return (rlimit)super.position(position);
    }

	public native @Cast("rlim_t") long rlim_cur(); public native rlimit rlim_cur(long rlim_cur);		/* current (soft) limit */
	public native @Cast("rlim_t") long rlim_max(); public native rlimit rlim_max(long rlim_max);		/* maximum value for rlim_cur */
}

// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
/*
 * proc_rlimit_control()
 *
 * Resource limit flavors
 */
public static final int RLIMIT_WAKEUPS_MONITOR =		0x1; /* Configure the wakeups monitor. */
public static final int RLIMIT_CPU_USAGE_MONITOR =	0x2; /* Configure the CPU usage monitor. */
public static final int RLIMIT_THREAD_CPULIMITS =		0x3; /* Configure a blocking, per-thread, CPU limits. */

/*
 * Flags for wakeups monitor control.
 */
public static final int WAKEMON_ENABLE =			0x01;
public static final int WAKEMON_DISABLE =			0x02;
public static final int WAKEMON_GET_PARAMS =		0x04;
public static final int WAKEMON_SET_DEFAULTS =		0x08;
public static final int WAKEMON_MAKE_FATAL =		0x10; /* Configure the task so that violations are fatal. */
/*
 * Flags for CPU usage monitor control.
 */
public static final int CPUMON_MAKE_FATAL =		0x1000;

public static class proc_rlimit_control_wakeupmon extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public proc_rlimit_control_wakeupmon() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public proc_rlimit_control_wakeupmon(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public proc_rlimit_control_wakeupmon(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public proc_rlimit_control_wakeupmon position(long position) {
        return (proc_rlimit_control_wakeupmon)super.position(position);
    }

	public native @Cast("uint32_t") int wm_flags(); public native proc_rlimit_control_wakeupmon wm_flags(int wm_flags);
	public native int wm_rate(); public native proc_rlimit_control_wakeupmon wm_rate(int wm_rate);
}

/* I/O type */
public static final int IOPOL_TYPE_DISK =	0;

/* scope */
public static final int IOPOL_SCOPE_PROCESS =   0;
public static final int IOPOL_SCOPE_THREAD =    1;
public static final int IOPOL_SCOPE_DARWIN_BG = 2;

/* I/O Priority */
public static final int IOPOL_DEFAULT =		0;
public static final int IOPOL_IMPORTANT =		1;
public static final int IOPOL_PASSIVE =		2;
public static final int IOPOL_THROTTLE =		3;
public static final int IOPOL_UTILITY =		4;
public static final int IOPOL_STANDARD =		5;

/* compatibility with older names */
public static final int IOPOL_APPLICATION =       IOPOL_STANDARD;
public static final int IOPOL_NORMAL =            IOPOL_IMPORTANT;


// #endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */


public static native int getpriority(int arg0, @Cast("id_t") int arg1);
// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static native int getiopolicy_np(int arg0, int arg1);
// #endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */
public static native int getrlimit(int arg0, rlimit arg1);
public static native int getrusage(int arg0, rusage arg1);
public static native int setpriority(int arg0, @Cast("id_t") int arg1, int arg2);
// #if __DARWIN_C_LEVEL >= __DARWIN_C_FULL
public static native int setiopolicy_np(int arg0, int arg1, int arg2);
// #endif /* __DARWIN_C_LEVEL >= __DARWIN_C_FULL */
public static native int setrlimit(int arg0, @Const rlimit arg1);
// #endif	/* !_SYS_RESOURCE_H_ */


// Parsed from sys/sysctl.h

/*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Mike Karels at Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)sysctl.h	8.1 (Berkeley) 6/2/93
 */
/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */

// #ifndef _SYS_SYSCTL_H_
// #define	_SYS_SYSCTL_H_

/*
 * These are for the eproc structure defined below.
 */
// #include <sys/cdefs.h>

// #include <sys/appleapiopts.h>
// #include <sys/time.h>
// #include <sys/ucred.h>
// #include <sys/proc.h>
// #include <sys/vm.h>


/*
 * Definitions for sysctl call.  The sysctl call uses a hierarchical name
 * for objects that can be examined or modified.  The name is expressed as
 * a sequence of integers.  Like a file path name, the meaning of each
 * component depends on its place in the hierarchy.  The top-level and kern
 * identifiers are defined here, and other identifiers are defined in the
 * respective subsystem header files.
 */

public static final int CTL_MAXNAME =	12;	/* largest number of components supported */

/*
 * Each subsystem defined by sysctl defines a list of variables
 * for that subsystem. Each name is either a node with further 
 * levels defined below it, or it is a leaf of some particular
 * type given below. Each sysctl level defines a set of name/type
 * pairs to be used by sysctl(1) in manipulating the subsystem.
 *
 * When declaring new sysctl names, use the CTLFLAG_LOCKED flag in the
 * type to indicate that all necessary locking will be handled
 * within the sysctl.
 *
 * Any sysctl defined without CTLFLAG_LOCKED is considered legacy
 * and will be protected by a global mutex.
 *
 * Note:	This is not optimal, so it is best to handle locking
 *		yourself, if you are able to do so.  A simple design
 *		pattern for use to avoid in a single function known
 *		to potentially be in the paging path ot doing a DMA
 *		to physical memory in a user space process is:
 *
 *			lock
 *			perform operation vs. local buffer
 *			unlock
 *			SYSCTL_OUT(rey, local buffer, length)
 *
 *		...this assumes you are not using a deep call graph
 *		or are unable to pass a local buffer address as a
 *		parameter into your deep call graph.
 *
 *		Note that very large user buffers can fail the wire
 *		if to do so would require more physical pages than
 *		are available (the caller will get an ENOMEM error,
 *		see sysctl_mem_hold() for details).
 */
public static class ctlname extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public ctlname() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ctlname(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ctlname(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public ctlname position(long position) {
        return (ctlname)super.position(position);
    }

	public native @Cast("char*") BytePointer ctl_name(); public native ctlname ctl_name(BytePointer ctl_name);	/* subsystem name */
	public native int ctl_type(); public native ctlname ctl_type(int ctl_type);	/* type of name */
}

public static final int CTLTYPE =		0xf;	/* Mask for the type */
public static final int CTLTYPE_NODE =	1;	/* name is a node */
public static final int CTLTYPE_INT =	2;	/* name describes an integer */
public static final int CTLTYPE_STRING =	3;	/* name describes a string */
public static final int CTLTYPE_QUAD =	4;	/* name describes a 64-bit number */
public static final int CTLTYPE_OPAQUE =	5;	/* name describes a structure */
public static final int CTLTYPE_STRUCT =	CTLTYPE_OPAQUE;	/* name describes a structure */

public static final int CTLFLAG_RD =	0x80000000;	/* Allow reads of variable */
public static final int CTLFLAG_WR =	0x40000000;	/* Allow writes to the variable */
public static final int CTLFLAG_RW =	(CTLFLAG_RD|CTLFLAG_WR);
public static final int CTLFLAG_NOLOCK =	0x20000000;	/* XXX Don't Lock */
public static final int CTLFLAG_ANYBODY =	0x10000000;	/* All users can set this var */
public static final int CTLFLAG_SECURE =	0x08000000;	/* Permit set only if securelevel<=0 */
public static final int CTLFLAG_MASKED =	0x04000000;	/* deprecated variable, do not display */
public static final int CTLFLAG_NOAUTO =	0x02000000;	/* do not auto-register */
public static final int CTLFLAG_KERN =	0x01000000;	/* valid inside the kernel */
public static final int CTLFLAG_LOCKED =	0x00800000;	/* node will handle locking itself */
public static final int CTLFLAG_OID2 =	0x00400000;	/* struct sysctl_oid has version info */

/*
 * USE THIS instead of a hardwired number from the categories below
 * to get dynamically assigned sysctl entries using the linker-set
 * technology. This is the way nearly all new sysctl variables should
 * be implemented.
 *
 * e.g. SYSCTL_INT(_parent, OID_AUTO, name, CTLFLAG_RW, &variable, 0, "");
 *
 * Note that linker set technology will automatically register all nodes
 * declared like this on kernel initialization, UNLESS they are defined
 * in I/O-Kit. In this case, you have to call sysctl_register_oid()
 * manually - just like in a KEXT.
 */
public static final int OID_AUTO =	(-1);
public static final int OID_AUTO_START = 100; /* conventional */


// #define SYSCTL_DEF_ENABLED

// #ifdef SYSCTL_DEF_ENABLED



// #endif /* SYSCTL_DEF_ENABLED */


// #endif	/* !_SYS_SYSCTL_H_ */


// Parsed from sys/wait.h

/*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */
/*
 * Copyright (c) 1982, 1986, 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)wait.h	8.2 (Berkeley) 7/10/94
 */
 
// #ifndef _SYS_WAIT_H_
// #define	_SYS_WAIT_H_

// #include <sys/cdefs.h>
// #include <sys/_types.h>

/*
 * This file holds definitions relevent to the wait4 system call
 * and the alternate interfaces that use it (wait, wait3, waitpid).
 */

/*
 * [XSI] The type idtype_t shall be defined as an enumeration type whose
 * possible values shall include at least P_ALL, P_PID, and P_PGID.
 */
/** enum idtype_t */
public static final int
	P_ALL = 0,
	P_PID = 1,
	P_PGID = 2;

/*
 * [XSI] The id_t and pid_t types shall be defined as described
 * in <sys/types.h>
 */
// #include <sys/_types/_pid_t.h>
// #include <sys/_types/_id_t.h>

/*
 * [XSI] The siginfo_t type shall be defined as described in <signal.h>
 * [XSI] The rusage structure shall be defined as described in <sys/resource.h>
 * [XSI] Inclusion of the <sys/wait.h> header may also make visible all
 * symbols from <signal.h> and <sys/resource.h>
 *
 * NOTE:	This requirement is currently being satisfied by the direct
 *		inclusion of <sys/signal.h> and <sys/resource.h>, below.
 *
 *		Software should not depend on the exposure of anything other
 *		than the types siginfo_t and struct rusage as a result of
 *		this inclusion.  If you depend on any types or manifest
 *		values othe than siginfo_t and struct rusage from either of
 *		those files, you should explicitly include them yourself, as
 *		well, or in future releases your stware may not compile
 *		without modification.
 */
// #include <sys/signal.h>		/* [XSI] for siginfo_t */
// #include <sys/resource.h>	/* [XSI] for struct rusage */

/*
 * Option bits for the third argument of wait4.  WNOHANG causes the
 * wait to not hang if there are no stopped or terminated processes, rather
 * returning an error indication in this case (pid==0).  WUNTRACED
 * indicates that the caller should receive status about untraced children
 * which stop due to signals.  If children are stopped and a wait without
 * this option is done, it is as though they were still running... nothing
 * about them is returned.
 */
public static final int WNOHANG =		0x00000001;  /* [XSI] no hang in wait/no child to reap */
public static final int WUNTRACED =	0x00000002;  /* [XSI] notify on stop, untraced child */

/*
 * Macros to test the exit status returned by wait
 * and extract the relevant values.
 */
// #if defined(_POSIX_C_SOURCE) && !defined(_DARWIN_C_SOURCE)
// #define	_W_INT(i)	(i)
// #else
// #define	_W_INT(w)	(*(int *)&(w))	/* convert union wait to int */
public static native @MemberGetter int WCOREFLAG();
public static final int WCOREFLAG = WCOREFLAG();
// #endif /* (_POSIX_C_SOURCE && !_DARWIN_C_SOURCE) */

/* These macros are permited, as they are in the implementation namespace */
// #define	_WSTATUS(x)	(_W_INT(x) & 0177)
public static final int _WSTOPPED =	0177;		/* _WSTATUS if process is stopped */

/*
 * [XSI] The <sys/wait.h> header shall define the following macros for
 * analysis of process status values
 */
// #if __DARWIN_UNIX03
// #define WEXITSTATUS(x)	((_W_INT(x) >> 8) & 0x000000ff)
// #else /* !__DARWIN_UNIX03 */
// #endif /* !__DARWIN_UNIX03 */
/* 0x13 == SIGCONT */
// #define WSTOPSIG(x)	(_W_INT(x) >> 8)
// #define WIFCONTINUED(x) (_WSTATUS(x) == _WSTOPPED && WSTOPSIG(x) == 0x13)
// #define WIFSTOPPED(x)	(_WSTATUS(x) == _WSTOPPED && WSTOPSIG(x) != 0x13)
// #define WIFEXITED(x)	(_WSTATUS(x) == 0)
// #define WIFSIGNALED(x)	(_WSTATUS(x) != _WSTOPPED && _WSTATUS(x) != 0)
// #define WTERMSIG(x)	(_WSTATUS(x))
// #if (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
// #define WCOREDUMP(x)	(_W_INT(x) & WCOREFLAG)

// #define	W_EXITCODE(ret, sig)	((ret) << 8 | (sig))
// #define	W_STOPCODE(sig)		((sig) << 8 | _WSTOPPED)
// #endif /* (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)) */

/*
 * [XSI] The following symbolic constants shall be defined as possible
 * values for the fourth argument to waitid().
 */
/* WNOHANG already defined for wait4() */
/* WUNTRACED defined for wait4() but not for waitid() */
public static final int WEXITED =		0x00000004;  /* [XSI] Processes which have exitted */
// #if __DARWIN_UNIX03
/* waitid() parameter */
public static final int WSTOPPED =	0x00000008;  /* [XSI] Any child stopped by signal */
// #endif
public static final int WCONTINUED =	0x00000010;  /* [XSI] Any child stopped then continued */
public static final int WNOWAIT =		0x00000020;  /* [XSI] Leave process returned waitable */


// #if (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
/* POSIX extensions and 4.2/4.3 compatability: */

/*
 * Tokens for special values of the "pid" parameter to wait4.
 */
public static final int WAIT_ANY =	(-1);	/* any process */
public static final int WAIT_MYPGRP =	0;	/* any process in my process group */

// #include <machine/endian.h>

/*
 * Deprecated:
 * Structure of the information in the status word returned by wait4.
 * If w_stopval==_WSTOPPED, then the second structure describes
 * the information returned, else the first.
 */
@Name("union wait") public static class wait extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public wait() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public wait(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public wait(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public wait position(long position) {
        return (wait)super.position(position);
    }

	public native int w_status(); public native wait w_status(int w_status);		/* used in syscall */
	/*
	 * Terminated process status.
	 */
// #if __DARWIN_BYTE_ORDER == __DARWIN_LITTLE_ENDIAN 
		@Name("w_T.w_Termsig") public native @Cast("unsigned int") @NoOffset int w_T_w_Termsig(); public native wait w_T_w_Termsig(int w_T_w_Termsig);
		@Name("w_T.w_Coredump") public native @Cast("unsigned int") @NoOffset int w_T_w_Coredump(); public native wait w_T_w_Coredump(int w_T_w_Coredump);
		@Name("w_T.w_Retcode") public native @Cast("unsigned int") @NoOffset int w_T_w_Retcode(); public native wait w_T_w_Retcode(int w_T_w_Retcode);
		@Name("w_T.w_Filler") public native @Cast("unsigned int") @NoOffset int w_T_w_Filler(); public native wait w_T_w_Filler(int w_T_w_Filler);	/* upper bits filler */
// #endif
// #if __DARWIN_BYTE_ORDER == __DARWIN_BIG_ENDIAN	/* termination signal */
// #endif
	/*
	 * Stopped process status.  Returned
	 * only for traced children unless requested
	 * with the WUNTRACED option bit.
	 */
// #if __DARWIN_BYTE_ORDER == __DARWIN_LITTLE_ENDIAN 
		@Name("w_S.w_Stopval") public native @Cast("unsigned int") @NoOffset int w_S_w_Stopval(); public native wait w_S_w_Stopval(int w_S_w_Stopval);
		@Name("w_S.w_Stopsig") public native @Cast("unsigned int") @NoOffset int w_S_w_Stopsig(); public native wait w_S_w_Stopsig(int w_S_w_Stopsig);
		@Name("w_S.w_Filler") public native @Cast("unsigned int") @NoOffset int w_S_w_Filler(); public native wait w_S_w_Filler(int w_S_w_Filler);	/* upper bits filler */
// #endif
// #if __DARWIN_BYTE_ORDER == __DARWIN_BIG_ENDIAN	/* == W_STOPPED if stopped */
// #endif
}

// #endif /* (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)) */

// #if !(__DARWIN_UNIX03 - 0)
/*
 * Stopped state value; cannot use waitid() parameter of the same name
 * in the same scope
 */
// #endif /* !__DARWIN_UNIX03 */

public static native @Cast("pid_t") int wait(IntPointer arg0);
public static native @Cast("pid_t") int wait(IntBuffer arg0);
public static native @Cast("pid_t") int wait(int[] arg0);
public static native @Cast("pid_t") int waitpid(@Cast("pid_t") int arg0, IntPointer arg1, int arg2);
public static native @Cast("pid_t") int waitpid(@Cast("pid_t") int arg0, IntBuffer arg1, int arg2);
public static native @Cast("pid_t") int waitpid(@Cast("pid_t") int arg0, int[] arg1, int arg2);
// #ifndef _ANSI_SOURCE
public static native int waitid(@Cast("idtype_t") int arg0, @Cast("id_t") int arg1, siginfo_t arg2, int arg3);
// #endif /* !_ANSI_SOURCE */
// #if  (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
public static native @Cast("pid_t") int wait3(IntPointer arg0, int arg1, rusage arg2);
public static native @Cast("pid_t") int wait3(IntBuffer arg0, int arg1, rusage arg2);
public static native @Cast("pid_t") int wait3(int[] arg0, int arg1, rusage arg2);
public static native @Cast("pid_t") int wait4(@Cast("pid_t") int arg0, IntPointer arg1, int arg2, rusage arg3);
public static native @Cast("pid_t") int wait4(@Cast("pid_t") int arg0, IntBuffer arg1, int arg2, rusage arg3);
public static native @Cast("pid_t") int wait4(@Cast("pid_t") int arg0, int[] arg1, int arg2, rusage arg3);
// #endif /* (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)) */
// #endif /* !_SYS_WAIT_H_ */


}
