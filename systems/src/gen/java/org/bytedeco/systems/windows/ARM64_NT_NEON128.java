// Targeted by JavaCPP version 1.5.13-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.systems.windows;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

import static org.bytedeco.systems.global.windows.*;


//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) it is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//
// The flags field within this record controls the contents of a CONTEXT
// record.
//
// If the context record is used as an input parameter, then for each
// portion of the context record controlled by a flag whose value is
// set, it is assumed that that portion of the context record contains
// valid context. If the context record is being used to modify a threads
// context, then only that portion of the threads context is modified.
//
// If the context record is used as an output parameter to capture the
// context of a thread, then only those portions of the thread's context
// corresponding to set flags will be returned.
//
// CONTEXT_CONTROL specifies FP, LR, SP, PC, and CPSR
//
// CONTEXT_INTEGER specifies X0-X28
//
// CONTEXT_FLOATING_POINT specifies Fpcr, Fpsr and Q0-Q31 / D0-D31 / S0-S31
//
// CONTEXT_DEBUG_REGISTERS specifies up to 16 of DBGBVR, DBGBCR, DBGWVR,
//      DBGWCR.
//

@Properties(inherit = org.bytedeco.systems.presets.windows.class)
public class ARM64_NT_NEON128 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public ARM64_NT_NEON128() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ARM64_NT_NEON128(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ARM64_NT_NEON128(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public ARM64_NT_NEON128 position(long position) {
        return (ARM64_NT_NEON128)super.position(position);
    }
    @Override public ARM64_NT_NEON128 getPointer(long i) {
        return new ARM64_NT_NEON128((Pointer)this).offsetAddress(i);
    }

        public native @Cast("ULONGLONG") long Low(); public native ARM64_NT_NEON128 Low(long setter);
        public native @Cast("LONGLONG") long High(); public native ARM64_NT_NEON128 High(long setter); 
    public native double D(int i); public native ARM64_NT_NEON128 D(int i, double setter);
    @MemberGetter public native DoublePointer D();
    public native float S(int i); public native ARM64_NT_NEON128 S(int i, float setter);
    @MemberGetter public native FloatPointer S();
    public native @Cast("WORD") short H(int i); public native ARM64_NT_NEON128 H(int i, short setter);
    @MemberGetter public native @Cast("WORD*") ShortPointer H();
    public native @Cast("BYTE") byte B(int i); public native ARM64_NT_NEON128 B(int i, byte setter);
    @MemberGetter public native @Cast("BYTE*") BytePointer B();
}
