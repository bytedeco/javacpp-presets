// Targeted by JavaCPP version 1.5-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.systems.global;

import org.bytedeco.systems.linux.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class linux extends org.bytedeco.systems.presets.linux {
    static { Loader.load(); }

// Parsed from cpuid.h

/*
 * Copyright (C) 2007-2016 Free Software Foundation, Inc.
 *
 * This file is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 3, or (at your option) any
 * later version.
 * 
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * Under Section 7 of GPL version 3, you are granted additional
 * permissions described in the GCC Runtime Library Exception, version
 * 3.1, as published by the Free Software Foundation.
 * 
 * You should have received a copy of the GNU General Public License and
 * a copy of the GCC Runtime Library Exception along with this program;
 * see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 * <http://www.gnu.org/licenses/>.
 */

/* %ecx */
public static final int bit_SSE3 =	(1 << 0);
public static final int bit_PCLMUL =	(1 << 1);
public static final int bit_LZCNT =	(1 << 5);
public static final int bit_SSSE3 =	(1 << 9);
public static final int bit_FMA =		(1 << 12);
public static final int bit_CMPXCHG16B =	(1 << 13);
public static final int bit_SSE4_1 =	(1 << 19);
public static final int bit_SSE4_2 =	(1 << 20);
public static final int bit_MOVBE =	(1 << 22);
public static final int bit_POPCNT =	(1 << 23);
public static final int bit_AES =		(1 << 25);
public static final int bit_XSAVE =	(1 << 26);
public static final int bit_OSXSAVE =	(1 << 27);
public static final int bit_AVX =		(1 << 28);
public static final int bit_F16C =	(1 << 29);
public static final int bit_RDRND =	(1 << 30);

/* %edx */
public static final int bit_CMPXCHG8B =	(1 << 8);
public static final int bit_CMOV =	(1 << 15);
public static final int bit_MMX =		(1 << 23);
public static final int bit_FXSAVE =	(1 << 24);
public static final int bit_SSE =		(1 << 25);
public static final int bit_SSE2 =	(1 << 26);

/* Extended Features */
/* %ecx */
public static final int bit_LAHF_LM =	(1 << 0);
public static final int bit_ABM =		(1 << 5);
public static final int bit_SSE4a =	(1 << 6);
public static final int bit_PRFCHW =	(1 << 8);
public static final int bit_XOP =         (1 << 11);
public static final int bit_LWP = 	(1 << 15);
public static final int bit_FMA4 =        (1 << 16);
public static final int bit_TBM =         (1 << 21);
public static final int bit_MWAITX =      (1 << 29);

/* %edx */
public static final int bit_MMXEXT =	(1 << 22);
public static final int bit_LM =		(1 << 29);
public static final int bit_3DNOWP =	(1 << 30);
public static final int bit_3DNOW =	(1 << 31);

/* %ebx.  */
public static final int bit_CLZERO =	(1 << 0);

/* Extended Features (%eax == 7) */
/* %ebx */
public static final int bit_FSGSBASE =	(1 << 0);
public static final int bit_BMI =	(1 << 3);
public static final int bit_HLE =	(1 << 4);
public static final int bit_AVX2 =	(1 << 5);
public static final int bit_BMI2 =	(1 << 8);
public static final int bit_RTM =	(1 << 11);
public static final int bit_MPX =	(1 << 14);
public static final int bit_AVX512F =	(1 << 16);
public static final int bit_AVX512DQ =	(1 << 17);
public static final int bit_RDSEED =	(1 << 18);
public static final int bit_ADX =	(1 << 19);
public static final int bit_AVX512IFMA =	(1 << 21);
public static final int bit_CLFLUSHOPT =	(1 << 23);
public static final int bit_CLWB =	(1 << 24);
public static final int bit_AVX512PF =	(1 << 26);
public static final int bit_AVX512ER =	(1 << 27);
public static final int bit_AVX512CD =	(1 << 28);
public static final int bit_SHA =		(1 << 29);
public static final int bit_AVX512BW =	(1 << 30);
public static final long bit_AVX512VL =	(1L << 31);

/* %ecx */
public static final int bit_PREFETCHWT1 =	  (1 << 0);
public static final int bit_AVX512VBMI =	(1 << 1);
public static final int bit_PKU =	(1 << 3);
public static final int bit_OSPKE =	(1 << 4);

/* XFEATURE_ENABLED_MASK register bits (%eax == 13, %ecx == 0) */
public static final int bit_BNDREGS =     (1 << 3);
public static final int bit_BNDCSR =      (1 << 4);

/* Extended State Enumeration Sub-leaf (%eax == 13, %ecx == 1) */
public static final int bit_XSAVEOPT =	(1 << 0);
public static final int bit_XSAVEC =	(1 << 1);
public static final int bit_XSAVES =	(1 << 3);

/* Signatures for different CPU implementations as returned in uses
   of cpuid with level 0.  */
public static final int signature_AMD_ebx =	0x68747541;
public static final int signature_AMD_ecx =	0x444d4163;
public static final int signature_AMD_edx =	0x69746e65;

public static final int signature_CENTAUR_ebx =	0x746e6543;
public static final int signature_CENTAUR_ecx =	0x736c7561;
public static final int signature_CENTAUR_edx =	0x48727561;

public static final int signature_CYRIX_ebx =	0x69727943;
public static final int signature_CYRIX_ecx =	0x64616574;
public static final int signature_CYRIX_edx =	0x736e4978;

public static final int signature_INTEL_ebx =	0x756e6547;
public static final int signature_INTEL_ecx =	0x6c65746e;
public static final int signature_INTEL_edx =	0x49656e69;

public static final int signature_TM1_ebx =	0x6e617254;
public static final int signature_TM1_ecx =	0x55504361;
public static final int signature_TM1_edx =	0x74656d73;

public static final int signature_TM2_ebx =	0x756e6547;
public static final int signature_TM2_ecx =	0x3638784d;
public static final int signature_TM2_edx =	0x54656e69;

public static final int signature_NSC_ebx =	0x646f6547;
public static final int signature_NSC_ecx =	0x43534e20;
public static final int signature_NSC_edx =	0x79622065;

public static final int signature_NEXGEN_ebx =	0x4778654e;
public static final int signature_NEXGEN_ecx =	0x6e657669;
public static final int signature_NEXGEN_edx =	0x72446e65;

public static final int signature_RISE_ebx =	0x65736952;
public static final int signature_RISE_ecx =	0x65736952;
public static final int signature_RISE_edx =	0x65736952;

public static final int signature_SIS_ebx =	0x20536953;
public static final int signature_SIS_ecx =	0x20536953;
public static final int signature_SIS_edx =	0x20536953;

public static final int signature_UMC_ebx =	0x20434d55;
public static final int signature_UMC_ecx =	0x20434d55;
public static final int signature_UMC_edx =	0x20434d55;

public static final int signature_VIA_ebx =	0x20414956;
public static final int signature_VIA_ecx =	0x20414956;
public static final int signature_VIA_edx =	0x20414956;

public static final int signature_VORTEX_ebx =	0x74726f56;
public static final int signature_VORTEX_ecx =	0x436f5320;
public static final int signature_VORTEX_edx =	0x36387865;

public static native void __cpuid(int level, @ByRef IntPointer a, @ByRef IntPointer b, @ByRef IntPointer c, @ByRef IntPointer d);
public static native void __cpuid(int level, @ByRef IntBuffer a, @ByRef IntBuffer b, @ByRef IntBuffer c, @ByRef IntBuffer d);
public static native void __cpuid(int level, @ByRef int[] a, @ByRef int[] b, @ByRef int[] c, @ByRef int[] d);

public static native void __cpuid_count(int level, int count, @ByRef IntPointer a, @ByRef IntPointer b, @ByRef IntPointer c, @ByRef IntPointer d);
public static native void __cpuid_count(int level, int count, @ByRef IntBuffer a, @ByRef IntBuffer b, @ByRef IntBuffer c, @ByRef IntBuffer d);
public static native void __cpuid_count(int level, int count, @ByRef int[] a, @ByRef int[] b, @ByRef int[] c, @ByRef int[] d);


/* Return highest supported input value for cpuid instruction.  ext can
   be either 0x0 or 0x8000000 to return highest supported value for
   basic or extended cpuid information.  Function returns 0 if cpuid
   is not supported or whatever cpuid returns in eax register.  If sig
   pointer is non-null, then first four bytes of the signature
   (as found in ebx register) are returned in location pointed by sig.  */

public static native @Cast("unsigned int") int __get_cpuid_max(@Cast("unsigned int") int arg0, @Cast("unsigned int*") IntPointer __sig);
public static native @Cast("unsigned int") int __get_cpuid_max(@Cast("unsigned int") int arg0, @Cast("unsigned int*") IntBuffer __sig);
public static native @Cast("unsigned int") int __get_cpuid_max(@Cast("unsigned int") int arg0, @Cast("unsigned int*") int[] __sig);

/* Return cpuid data for requested cpuid leaf, as found in returned
   eax, ebx, ecx and edx registers.  The function checks if cpuid is
   supported and returns 1 for valid cpuid information or 0 for
   unsupported cpuid leaf.  All pointers are required to be non-null.  */

public static native int __get_cpuid(@Cast("unsigned int") int __leaf,
	     @Cast("unsigned int*") IntPointer __eax, @Cast("unsigned int*") IntPointer __ebx,
	     @Cast("unsigned int*") IntPointer __ecx, @Cast("unsigned int*") IntPointer __edx);
public static native int __get_cpuid(@Cast("unsigned int") int __leaf,
	     @Cast("unsigned int*") IntBuffer __eax, @Cast("unsigned int*") IntBuffer __ebx,
	     @Cast("unsigned int*") IntBuffer __ecx, @Cast("unsigned int*") IntBuffer __edx);
public static native int __get_cpuid(@Cast("unsigned int") int __leaf,
	     @Cast("unsigned int*") int[] __eax, @Cast("unsigned int*") int[] __ebx,
	     @Cast("unsigned int*") int[] __ecx, @Cast("unsigned int*") int[] __edx);

/* Same as above, but sub-leaf can be specified.  */

public static native int __get_cpuid_count(@Cast("unsigned int") int __leaf, @Cast("unsigned int") int __subleaf,
		   @Cast("unsigned int*") IntPointer __eax, @Cast("unsigned int*") IntPointer __ebx,
		   @Cast("unsigned int*") IntPointer __ecx, @Cast("unsigned int*") IntPointer __edx);
public static native int __get_cpuid_count(@Cast("unsigned int") int __leaf, @Cast("unsigned int") int __subleaf,
		   @Cast("unsigned int*") IntBuffer __eax, @Cast("unsigned int*") IntBuffer __ebx,
		   @Cast("unsigned int*") IntBuffer __ecx, @Cast("unsigned int*") IntBuffer __edx);
public static native int __get_cpuid_count(@Cast("unsigned int") int __leaf, @Cast("unsigned int") int __subleaf,
		   @Cast("unsigned int*") int[] __eax, @Cast("unsigned int*") int[] __ebx,
		   @Cast("unsigned int*") int[] __ecx, @Cast("unsigned int*") int[] __edx);


// Parsed from dlfcn.h

/* User functions for run-time dynamic loading.
   Copyright (C) 1995-2001,2003,2004,2006,2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef	_DLFCN_H
public static final int _DLFCN_H = 1;

// #include <features.h>
// #define __need_size_t
// #include <stddef.h>

/* Collect various system dependent definitions and declarations.  */
// #include <bits/dlfcn.h>


// #ifdef __USE_GNU
/* If the first argument of `dlsym' or `dlvsym' is set to RTLD_NEXT
   the run-time address of the symbol called NAME in the next shared
   object is returned.  The "next" relation is defined by the order
   the shared objects were loaded.  */
public static native @MemberGetter Pointer RTLD_NEXT();
public static final Pointer RTLD_NEXT = RTLD_NEXT();

/* If the first argument to `dlsym' or `dlvsym' is set to RTLD_DEFAULT
   the run-time address of the symbol called NAME in the global scope
   is returned.  */
public static native @MemberGetter Pointer RTLD_DEFAULT();
public static final Pointer RTLD_DEFAULT = RTLD_DEFAULT();


/* Type for namespace indeces.  */

/* Special namespace ID values.  */
public static final int LM_ID_BASE =	0;	/* Initial namespace.  */
public static final int LM_ID_NEWLM =	-1;	/* For dlmopen: request new namespace.  */
// #endif


/* Open the shared object FILE and map it in; return a handle that can be
   passed to `dlsym' to get symbol values from it.  */
public static native Pointer dlopen(@Cast("const char*") BytePointer __file, int __mode);
public static native Pointer dlopen(String __file, int __mode);

/* Unmap and close a shared object opened by `dlopen'.
   The handle cannot be used again after calling `dlclose'.  */
public static native int dlclose(Pointer __handle);

/* Find the run-time address in the shared object HANDLE refers to
   of the symbol called NAME.  */
public static native Pointer dlsym(Pointer __handle,
		    @Cast("const char*") BytePointer __name);
public static native Pointer dlsym(Pointer __handle,
		    String __name);

// #ifdef __USE_GNU
/* Like `dlopen', but request object to be allocated in a new namespace.  */
public static native Pointer dlmopen(@Cast("Lmid_t") long __nsid, @Cast("const char*") BytePointer __file, int __mode);
public static native Pointer dlmopen(@Cast("Lmid_t") long __nsid, String __file, int __mode);

/* Find the run-time address in the shared object HANDLE refers to
   of the symbol called NAME with VERSION.  */
public static native Pointer dlvsym(Pointer __handle,
		     @Cast("const char*") BytePointer __name,
		     @Cast("const char*") BytePointer __version);
public static native Pointer dlvsym(Pointer __handle,
		     String __name,
		     String __version);
// #endif

/* When any of the above functions fails, call this function
   to return a string describing the error.  Each call resets
   the error string so that a following call returns null.  */
public static native @Cast("char*") BytePointer dlerror();
// Targeting ../linux/Dl_info.java



/* Fill in *INFO with the following information about ADDRESS.
   Returns 0 iff no shared object's segments contain that address.  */
public static native int dladdr(@Const Pointer __address, Dl_info __info);

/* Same as `dladdr', but additionally sets *EXTRA_INFO according to FLAGS.  */
public static native int dladdr1(@Const Pointer __address, Dl_info __info,
		    @Cast("void**") PointerPointer __extra_info, int __flags);
public static native int dladdr1(@Const Pointer __address, Dl_info __info,
		    @Cast("void**") @ByPtrPtr Pointer __extra_info, int __flags);

/* These are the possible values for the FLAGS argument to `dladdr1'.
   This indicates what extra information is stored at *EXTRA_INFO.
   It may also be zero, in which case the EXTRA_INFO argument is not used.  */
/** enum  */
public static final int
    /* Matching symbol table entry (const ElfNN_Sym *).  */
    RTLD_DL_SYMENT = 1,

    /* The object containing the address (struct link_map *).  */
    RTLD_DL_LINKMAP = 2;


/* Get information about the shared object HANDLE refers to.
   REQUEST is from among the values below, and determines the use of ARG.

   On success, returns zero.  On failure, returns -1 and records an error
   message to be fetched with `dlerror'.  */
public static native int dlinfo(Pointer __handle,
		   int __request, Pointer __arg);

/* These are the possible values for the REQUEST argument to `dlinfo'.  */
/** enum  */
public static final int
    /* Treat ARG as `lmid_t *'; store namespace ID for HANDLE there.  */
    RTLD_DI_LMID = 1,

    /* Treat ARG as `struct link_map **';
       store the `struct link_map *' for HANDLE there.  */
    RTLD_DI_LINKMAP = 2,

    RTLD_DI_CONFIGADDR = 3,	/* Unsupported, defined by Solaris.  */

    /* Treat ARG as `Dl_serinfo *' (see below), and fill in to describe the
       directories that will be searched for dependencies of this object.
       RTLD_DI_SERINFOSIZE fills in just the `dls_cnt' and `dls_size'
       entries to indicate the size of the buffer that must be passed to
       RTLD_DI_SERINFO to fill in the full information.  */
    RTLD_DI_SERINFO = 4,
    RTLD_DI_SERINFOSIZE = 5,

    /* Treat ARG as `char *', and store there the directory name used to
       expand $ORIGIN in this shared object's dependency file names.  */
    RTLD_DI_ORIGIN = 6,

    RTLD_DI_PROFILENAME = 7,	/* Unsupported, defined by Solaris.  */
    RTLD_DI_PROFILEOUT = 8,	/* Unsupported, defined by Solaris.  */

    /* Treat ARG as `size_t *', and store there the TLS module ID
       of this object's PT_TLS segment, as used in TLS relocations;
       store zero if this object does not define a PT_TLS segment.  */
    RTLD_DI_TLS_MODID = 9,

    /* Treat ARG as `void **', and store there a pointer to the calling
       thread's TLS block corresponding to this object's PT_TLS segment.
       Store a null pointer if this object does not define a PT_TLS
       segment, or if the calling thread has not allocated a block for it.  */
    RTLD_DI_TLS_DATA = 10,

    RTLD_DI_MAX = 10;
// Targeting ../linux/Dl_serpath.java


// Targeting ../linux/Dl_serinfo.java


// #endif /* __USE_GNU */


// #endif	/* dlfcn.h */


// Parsed from nl_types.h

/* Copyright (C) 1996, 1997, 1999, 2003, 2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef _NL_TYPES_H
public static final int _NL_TYPES_H = 1;

// #include <features.h>

/* The default message set used by the gencat program.  */
public static final int NL_SETD = 1;

/* Value for FLAG parameter of `catgets' to say we want XPG4 compliance.  */
public static final int NL_CAT_LOCALE = 1;
// Targeting ../linux/nl_catd.java



/* Type used by `nl_langinfo'.  */

/* Open message catalog for later use, returning descriptor.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
public static native nl_catd catopen(@Cast("const char*") BytePointer __cat_name, int __flag);
public static native nl_catd catopen(String __cat_name, int __flag);

/* Return translation with NUMBER in SET of CATALOG; if not found
   return STRING.  */
public static native @Cast("char*") BytePointer catgets(nl_catd __catalog, int __set, int __number,
		      @Cast("const char*") BytePointer __string);
public static native @Cast("char*") ByteBuffer catgets(nl_catd __catalog, int __set, int __number,
		      String __string);

/* Close message CATALOG.  */
public static native int catclose(nl_catd __catalog);

// #endif /* nl_types.h  */


// Parsed from xlocale.h

/* Definition of locale datatype.
   Copyright (C) 1997,2000,2002,2009,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.
   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef _XLOCALE_H
public static final int _XLOCALE_H =	1;
// Targeting ../linux/locale_t.java



/* POSIX 2008 makes locale_t official.  */

// #endif /* xlocale.h */


// Parsed from bits/locale.h

/* Definition of locale category symbol values.
   Copyright (C) 2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #if !defined _LOCALE_H && !defined _LANGINFO_H
// # error "Never use <bits/locale.h> directly; include <locale.h> instead."
// #endif

// #ifndef _BITS_LOCALE_H
public static final int _BITS_LOCALE_H =	1;

/** enum  */
public static final int
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12;

// #endif	/* bits/locale.h */


// Parsed from langinfo.h

/* Access to locale-dependent parameters.
   Copyright (C) 1995-2002,2003,2004,2005,2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef _LANGINFO_H
public static final int _LANGINFO_H = 1;

/* Get the type definition.  */
// #include <nl_types.h>

// #include <bits/locale.h>	/* Define the __LC_* category names.  */


/* Construct an `nl_item' value for `nl_langinfo' from a locale category
   (LC_*) and an item index within the category.  Some code may depend on
   the item values within a category increasing monotonically with the
   indices.  */
// #define _NL_ITEM(category, index)	(((category) << 16) | (index))

/* Extract the category and item index from a constructed `nl_item' value.  */
// #define _NL_ITEM_CATEGORY(item)		((int) (item) >> 16)
// #define _NL_ITEM_INDEX(item)		((int) (item) & 0xffff)

/* Enumeration of locale items that can be queried with `nl_langinfo'.  */
/** enum  */
public static final int
  /* LC_TIME category: date and time formatting.  */

  /* Abbreviated days of the week. */
  ABDAY_1 = (((__LC_TIME) << 16) | ( 0)), /* Sun */
// #define ABDAY_1			ABDAY_1
  ABDAY_2 = (((__LC_TIME) << 16) | ( 0)) + 1,
// #define ABDAY_2			ABDAY_2
  ABDAY_3 = (((__LC_TIME) << 16) | ( 0)) + 2,
// #define ABDAY_3			ABDAY_3
  ABDAY_4 = (((__LC_TIME) << 16) | ( 0)) + 3,
// #define ABDAY_4			ABDAY_4
  ABDAY_5 = (((__LC_TIME) << 16) | ( 0)) + 4,
// #define ABDAY_5			ABDAY_5
  ABDAY_6 = (((__LC_TIME) << 16) | ( 0)) + 5,
// #define ABDAY_6			ABDAY_6
  ABDAY_7 = (((__LC_TIME) << 16) | ( 0)) + 6,
// #define ABDAY_7			ABDAY_7

  /* Long-named days of the week. */
  DAY_1 = (((__LC_TIME) << 16) | ( 0)) + 7,			/* Sunday */
// #define DAY_1			DAY_1
  DAY_2 = (((__LC_TIME) << 16) | ( 0)) + 8,			/* Monday */
// #define DAY_2			DAY_2
  DAY_3 = (((__LC_TIME) << 16) | ( 0)) + 9,			/* Tuesday */
// #define DAY_3			DAY_3
  DAY_4 = (((__LC_TIME) << 16) | ( 0)) + 10,			/* Wednesday */
// #define DAY_4			DAY_4
  DAY_5 = (((__LC_TIME) << 16) | ( 0)) + 11,			/* Thursday */
// #define DAY_5			DAY_5
  DAY_6 = (((__LC_TIME) << 16) | ( 0)) + 12,			/* Friday */
// #define DAY_6			DAY_6
  DAY_7 = (((__LC_TIME) << 16) | ( 0)) + 13,			/* Saturday */
// #define DAY_7			DAY_7

  /* Abbreviated month names.  */
  ABMON_1 = (((__LC_TIME) << 16) | ( 0)) + 14,			/* Jan */
// #define ABMON_1			ABMON_1
  ABMON_2 = (((__LC_TIME) << 16) | ( 0)) + 15,
// #define ABMON_2			ABMON_2
  ABMON_3 = (((__LC_TIME) << 16) | ( 0)) + 16,
// #define ABMON_3			ABMON_3
  ABMON_4 = (((__LC_TIME) << 16) | ( 0)) + 17,
// #define ABMON_4			ABMON_4
  ABMON_5 = (((__LC_TIME) << 16) | ( 0)) + 18,
// #define ABMON_5			ABMON_5
  ABMON_6 = (((__LC_TIME) << 16) | ( 0)) + 19,
// #define ABMON_6			ABMON_6
  ABMON_7 = (((__LC_TIME) << 16) | ( 0)) + 20,
// #define ABMON_7			ABMON_7
  ABMON_8 = (((__LC_TIME) << 16) | ( 0)) + 21,
// #define ABMON_8			ABMON_8
  ABMON_9 = (((__LC_TIME) << 16) | ( 0)) + 22,
// #define ABMON_9			ABMON_9
  ABMON_10 = (((__LC_TIME) << 16) | ( 0)) + 23,
// #define ABMON_10		ABMON_10
  ABMON_11 = (((__LC_TIME) << 16) | ( 0)) + 24,
// #define ABMON_11		ABMON_11
  ABMON_12 = (((__LC_TIME) << 16) | ( 0)) + 25,
// #define ABMON_12		ABMON_12

  /* Long month names.  */
  MON_1 = (((__LC_TIME) << 16) | ( 0)) + 26,			/* January */
// #define MON_1			MON_1
  MON_2 = (((__LC_TIME) << 16) | ( 0)) + 27,
// #define MON_2			MON_2
  MON_3 = (((__LC_TIME) << 16) | ( 0)) + 28,
// #define MON_3			MON_3
  MON_4 = (((__LC_TIME) << 16) | ( 0)) + 29,
// #define MON_4			MON_4
  MON_5 = (((__LC_TIME) << 16) | ( 0)) + 30,
// #define MON_5			MON_5
  MON_6 = (((__LC_TIME) << 16) | ( 0)) + 31,
// #define MON_6			MON_6
  MON_7 = (((__LC_TIME) << 16) | ( 0)) + 32,
// #define MON_7			MON_7
  MON_8 = (((__LC_TIME) << 16) | ( 0)) + 33,
// #define MON_8			MON_8
  MON_9 = (((__LC_TIME) << 16) | ( 0)) + 34,
// #define MON_9			MON_9
  MON_10 = (((__LC_TIME) << 16) | ( 0)) + 35,
// #define MON_10			MON_10
  MON_11 = (((__LC_TIME) << 16) | ( 0)) + 36,
// #define MON_11			MON_11
  MON_12 = (((__LC_TIME) << 16) | ( 0)) + 37,
// #define MON_12			MON_12

  AM_STR = (((__LC_TIME) << 16) | ( 0)) + 38,			/* Ante meridiem string.  */
// #define AM_STR			AM_STR
  PM_STR = (((__LC_TIME) << 16) | ( 0)) + 39,			/* Post meridiem string.  */
// #define PM_STR			PM_STR

  D_T_FMT = (((__LC_TIME) << 16) | ( 0)) + 40,			/* Date and time format for strftime.  */
// #define D_T_FMT			D_T_FMT
  D_FMT = (((__LC_TIME) << 16) | ( 0)) + 41,			/* Date format for strftime.  */
// #define D_FMT			D_FMT
  T_FMT = (((__LC_TIME) << 16) | ( 0)) + 42,			/* Time format for strftime.  */
// #define T_FMT			T_FMT
  T_FMT_AMPM = (((__LC_TIME) << 16) | ( 0)) + 43,			/* 12-hour time format for strftime.  */
// #define T_FMT_AMPM		T_FMT_AMPM

  ERA = (((__LC_TIME) << 16) | ( 0)) + 44,				/* Alternate era.  */
// #define ERA			ERA
  __ERA_YEAR = (((__LC_TIME) << 16) | ( 0)) + 45;			/* Year in alternate era format.  */
// #ifdef __USE_GNU
public static final int ERA_YEAR =		__ERA_YEAR;
// #endif
public static final int
  ERA_D_FMT = (((__LC_TIME) << 16) | ( 0)) + 46,			/* Date in alternate era format.  */
// #define ERA_D_FMT		ERA_D_FMT
  ALT_DIGITS = (((__LC_TIME) << 16) | ( 0)) + 47,			/* Alternate symbols for digits.  */
// #define ALT_DIGITS		ALT_DIGITS
  ERA_D_T_FMT = (((__LC_TIME) << 16) | ( 0)) + 48,			/* Date and time in alternate era format.  */
// #define ERA_D_T_FMT		ERA_D_T_FMT
  ERA_T_FMT = (((__LC_TIME) << 16) | ( 0)) + 49,			/* Time in alternate era format.  */
// #define ERA_T_FMT		ERA_T_FMT

  _NL_TIME_ERA_NUM_ENTRIES = (((__LC_TIME) << 16) | ( 0)) + 50,	/* Number entries in the era arrays.  */
  _NL_TIME_ERA_ENTRIES = (((__LC_TIME) << 16) | ( 0)) + 51,		/* Structure with era entries in usable form.*/

  _NL_WABDAY_1 = (((__LC_TIME) << 16) | ( 0)) + 52,		/* Sun */
  _NL_WABDAY_2 = (((__LC_TIME) << 16) | ( 0)) + 53,
  _NL_WABDAY_3 = (((__LC_TIME) << 16) | ( 0)) + 54,
  _NL_WABDAY_4 = (((__LC_TIME) << 16) | ( 0)) + 55,
  _NL_WABDAY_5 = (((__LC_TIME) << 16) | ( 0)) + 56,
  _NL_WABDAY_6 = (((__LC_TIME) << 16) | ( 0)) + 57,
  _NL_WABDAY_7 = (((__LC_TIME) << 16) | ( 0)) + 58,

  /* Long-named days of the week. */
  _NL_WDAY_1 = (((__LC_TIME) << 16) | ( 0)) + 59,		/* Sunday */
  _NL_WDAY_2 = (((__LC_TIME) << 16) | ( 0)) + 60,		/* Monday */
  _NL_WDAY_3 = (((__LC_TIME) << 16) | ( 0)) + 61,		/* Tuesday */
  _NL_WDAY_4 = (((__LC_TIME) << 16) | ( 0)) + 62,		/* Wednesday */
  _NL_WDAY_5 = (((__LC_TIME) << 16) | ( 0)) + 63,		/* Thursday */
  _NL_WDAY_6 = (((__LC_TIME) << 16) | ( 0)) + 64,		/* Friday */
  _NL_WDAY_7 = (((__LC_TIME) << 16) | ( 0)) + 65,		/* Saturday */

  /* Abbreviated month names.  */
  _NL_WABMON_1 = (((__LC_TIME) << 16) | ( 0)) + 66,		/* Jan */
  _NL_WABMON_2 = (((__LC_TIME) << 16) | ( 0)) + 67,
  _NL_WABMON_3 = (((__LC_TIME) << 16) | ( 0)) + 68,
  _NL_WABMON_4 = (((__LC_TIME) << 16) | ( 0)) + 69,
  _NL_WABMON_5 = (((__LC_TIME) << 16) | ( 0)) + 70,
  _NL_WABMON_6 = (((__LC_TIME) << 16) | ( 0)) + 71,
  _NL_WABMON_7 = (((__LC_TIME) << 16) | ( 0)) + 72,
  _NL_WABMON_8 = (((__LC_TIME) << 16) | ( 0)) + 73,
  _NL_WABMON_9 = (((__LC_TIME) << 16) | ( 0)) + 74,
  _NL_WABMON_10 = (((__LC_TIME) << 16) | ( 0)) + 75,
  _NL_WABMON_11 = (((__LC_TIME) << 16) | ( 0)) + 76,
  _NL_WABMON_12 = (((__LC_TIME) << 16) | ( 0)) + 77,

  /* Long month names.  */
  _NL_WMON_1 = (((__LC_TIME) << 16) | ( 0)) + 78,		/* January */
  _NL_WMON_2 = (((__LC_TIME) << 16) | ( 0)) + 79,
  _NL_WMON_3 = (((__LC_TIME) << 16) | ( 0)) + 80,
  _NL_WMON_4 = (((__LC_TIME) << 16) | ( 0)) + 81,
  _NL_WMON_5 = (((__LC_TIME) << 16) | ( 0)) + 82,
  _NL_WMON_6 = (((__LC_TIME) << 16) | ( 0)) + 83,
  _NL_WMON_7 = (((__LC_TIME) << 16) | ( 0)) + 84,
  _NL_WMON_8 = (((__LC_TIME) << 16) | ( 0)) + 85,
  _NL_WMON_9 = (((__LC_TIME) << 16) | ( 0)) + 86,
  _NL_WMON_10 = (((__LC_TIME) << 16) | ( 0)) + 87,
  _NL_WMON_11 = (((__LC_TIME) << 16) | ( 0)) + 88,
  _NL_WMON_12 = (((__LC_TIME) << 16) | ( 0)) + 89,

  _NL_WAM_STR = (((__LC_TIME) << 16) | ( 0)) + 90,		/* Ante meridiem string.  */
  _NL_WPM_STR = (((__LC_TIME) << 16) | ( 0)) + 91,		/* Post meridiem string.  */

  _NL_WD_T_FMT = (((__LC_TIME) << 16) | ( 0)) + 92,		/* Date and time format for strftime.  */
  _NL_WD_FMT = (((__LC_TIME) << 16) | ( 0)) + 93,		/* Date format for strftime.  */
  _NL_WT_FMT = (((__LC_TIME) << 16) | ( 0)) + 94,		/* Time format for strftime.  */
  _NL_WT_FMT_AMPM = (((__LC_TIME) << 16) | ( 0)) + 95,	/* 12-hour time format for strftime.  */

  _NL_WERA_YEAR = (((__LC_TIME) << 16) | ( 0)) + 96,	/* Year in alternate era format.  */
  _NL_WERA_D_FMT = (((__LC_TIME) << 16) | ( 0)) + 97,	/* Date in alternate era format.  */
  _NL_WALT_DIGITS = (((__LC_TIME) << 16) | ( 0)) + 98,	/* Alternate symbols for digits.  */
  _NL_WERA_D_T_FMT = (((__LC_TIME) << 16) | ( 0)) + 99,	/* Date and time in alternate era format.  */
  _NL_WERA_T_FMT = (((__LC_TIME) << 16) | ( 0)) + 100,	/* Time in alternate era format.  */

  _NL_TIME_WEEK_NDAYS = (((__LC_TIME) << 16) | ( 0)) + 101,
  _NL_TIME_WEEK_1STDAY = (((__LC_TIME) << 16) | ( 0)) + 102,
  _NL_TIME_WEEK_1STWEEK = (((__LC_TIME) << 16) | ( 0)) + 103,
  _NL_TIME_FIRST_WEEKDAY = (((__LC_TIME) << 16) | ( 0)) + 104,
  _NL_TIME_FIRST_WORKDAY = (((__LC_TIME) << 16) | ( 0)) + 105,
  _NL_TIME_CAL_DIRECTION = (((__LC_TIME) << 16) | ( 0)) + 106,
  _NL_TIME_TIMEZONE = (((__LC_TIME) << 16) | ( 0)) + 107,

  _DATE_FMT = (((__LC_TIME) << 16) | ( 0)) + 108,		/* strftime format for date.  */
// #define _DATE_FMT	_DATE_FMT
  _NL_W_DATE_FMT = (((__LC_TIME) << 16) | ( 0)) + 109,

  _NL_TIME_CODESET = (((__LC_TIME) << 16) | ( 0)) + 110,

  _NL_NUM_LC_TIME = (((__LC_TIME) << 16) | ( 0)) + 111,	/* Number of indices in LC_TIME category.  */

  /* LC_COLLATE category: text sorting.
     This information is accessed by the strcoll and strxfrm functions.
     These `nl_langinfo' names are used only internally.  */
  _NL_COLLATE_NRULES = (((__LC_COLLATE) << 16) | ( 0)),
  _NL_COLLATE_RULESETS = (((__LC_COLLATE) << 16) | ( 0)) + 1,
  _NL_COLLATE_TABLEMB = (((__LC_COLLATE) << 16) | ( 0)) + 2,
  _NL_COLLATE_WEIGHTMB = (((__LC_COLLATE) << 16) | ( 0)) + 3,
  _NL_COLLATE_EXTRAMB = (((__LC_COLLATE) << 16) | ( 0)) + 4,
  _NL_COLLATE_INDIRECTMB = (((__LC_COLLATE) << 16) | ( 0)) + 5,
  _NL_COLLATE_GAP1 = (((__LC_COLLATE) << 16) | ( 0)) + 6,
  _NL_COLLATE_GAP2 = (((__LC_COLLATE) << 16) | ( 0)) + 7,
  _NL_COLLATE_GAP3 = (((__LC_COLLATE) << 16) | ( 0)) + 8,
  _NL_COLLATE_TABLEWC = (((__LC_COLLATE) << 16) | ( 0)) + 9,
  _NL_COLLATE_WEIGHTWC = (((__LC_COLLATE) << 16) | ( 0)) + 10,
  _NL_COLLATE_EXTRAWC = (((__LC_COLLATE) << 16) | ( 0)) + 11,
  _NL_COLLATE_INDIRECTWC = (((__LC_COLLATE) << 16) | ( 0)) + 12,
  _NL_COLLATE_SYMB_HASH_SIZEMB = (((__LC_COLLATE) << 16) | ( 0)) + 13,
  _NL_COLLATE_SYMB_TABLEMB = (((__LC_COLLATE) << 16) | ( 0)) + 14,
  _NL_COLLATE_SYMB_EXTRAMB = (((__LC_COLLATE) << 16) | ( 0)) + 15,
  _NL_COLLATE_COLLSEQMB = (((__LC_COLLATE) << 16) | ( 0)) + 16,
  _NL_COLLATE_COLLSEQWC = (((__LC_COLLATE) << 16) | ( 0)) + 17,
  _NL_COLLATE_CODESET = (((__LC_COLLATE) << 16) | ( 0)) + 18,
  _NL_NUM_LC_COLLATE = (((__LC_COLLATE) << 16) | ( 0)) + 19,

  /* LC_CTYPE category: character classification.
     This information is accessed by the functions in <ctype.h>.
     These `nl_langinfo' names are used only internally.  */
  _NL_CTYPE_CLASS = (((__LC_CTYPE) << 16) | ( 0)),
  _NL_CTYPE_TOUPPER = (((__LC_CTYPE) << 16) | ( 0)) + 1,
  _NL_CTYPE_GAP1 = (((__LC_CTYPE) << 16) | ( 0)) + 2,
  _NL_CTYPE_TOLOWER = (((__LC_CTYPE) << 16) | ( 0)) + 3,
  _NL_CTYPE_GAP2 = (((__LC_CTYPE) << 16) | ( 0)) + 4,
  _NL_CTYPE_CLASS32 = (((__LC_CTYPE) << 16) | ( 0)) + 5,
  _NL_CTYPE_GAP3 = (((__LC_CTYPE) << 16) | ( 0)) + 6,
  _NL_CTYPE_GAP4 = (((__LC_CTYPE) << 16) | ( 0)) + 7,
  _NL_CTYPE_GAP5 = (((__LC_CTYPE) << 16) | ( 0)) + 8,
  _NL_CTYPE_GAP6 = (((__LC_CTYPE) << 16) | ( 0)) + 9,
  _NL_CTYPE_CLASS_NAMES = (((__LC_CTYPE) << 16) | ( 0)) + 10,
  _NL_CTYPE_MAP_NAMES = (((__LC_CTYPE) << 16) | ( 0)) + 11,
  _NL_CTYPE_WIDTH = (((__LC_CTYPE) << 16) | ( 0)) + 12,
  _NL_CTYPE_MB_CUR_MAX = (((__LC_CTYPE) << 16) | ( 0)) + 13,
  _NL_CTYPE_CODESET_NAME = (((__LC_CTYPE) << 16) | ( 0)) + 14,
  CODESET = _NL_CTYPE_CODESET_NAME,
// #define CODESET			CODESET
  _NL_CTYPE_TOUPPER32 = _NL_CTYPE_CODESET_NAME + 1,
  _NL_CTYPE_TOLOWER32 = _NL_CTYPE_CODESET_NAME + 2,
  _NL_CTYPE_CLASS_OFFSET = _NL_CTYPE_CODESET_NAME + 3,
  _NL_CTYPE_MAP_OFFSET = _NL_CTYPE_CODESET_NAME + 4,
  _NL_CTYPE_INDIGITS_MB_LEN = _NL_CTYPE_CODESET_NAME + 5,
  _NL_CTYPE_INDIGITS0_MB = _NL_CTYPE_CODESET_NAME + 6,
  _NL_CTYPE_INDIGITS1_MB = _NL_CTYPE_CODESET_NAME + 7,
  _NL_CTYPE_INDIGITS2_MB = _NL_CTYPE_CODESET_NAME + 8,
  _NL_CTYPE_INDIGITS3_MB = _NL_CTYPE_CODESET_NAME + 9,
  _NL_CTYPE_INDIGITS4_MB = _NL_CTYPE_CODESET_NAME + 10,
  _NL_CTYPE_INDIGITS5_MB = _NL_CTYPE_CODESET_NAME + 11,
  _NL_CTYPE_INDIGITS6_MB = _NL_CTYPE_CODESET_NAME + 12,
  _NL_CTYPE_INDIGITS7_MB = _NL_CTYPE_CODESET_NAME + 13,
  _NL_CTYPE_INDIGITS8_MB = _NL_CTYPE_CODESET_NAME + 14,
  _NL_CTYPE_INDIGITS9_MB = _NL_CTYPE_CODESET_NAME + 15,
  _NL_CTYPE_INDIGITS_WC_LEN = _NL_CTYPE_CODESET_NAME + 16,
  _NL_CTYPE_INDIGITS0_WC = _NL_CTYPE_CODESET_NAME + 17,
  _NL_CTYPE_INDIGITS1_WC = _NL_CTYPE_CODESET_NAME + 18,
  _NL_CTYPE_INDIGITS2_WC = _NL_CTYPE_CODESET_NAME + 19,
  _NL_CTYPE_INDIGITS3_WC = _NL_CTYPE_CODESET_NAME + 20,
  _NL_CTYPE_INDIGITS4_WC = _NL_CTYPE_CODESET_NAME + 21,
  _NL_CTYPE_INDIGITS5_WC = _NL_CTYPE_CODESET_NAME + 22,
  _NL_CTYPE_INDIGITS6_WC = _NL_CTYPE_CODESET_NAME + 23,
  _NL_CTYPE_INDIGITS7_WC = _NL_CTYPE_CODESET_NAME + 24,
  _NL_CTYPE_INDIGITS8_WC = _NL_CTYPE_CODESET_NAME + 25,
  _NL_CTYPE_INDIGITS9_WC = _NL_CTYPE_CODESET_NAME + 26,
  _NL_CTYPE_OUTDIGIT0_MB = _NL_CTYPE_CODESET_NAME + 27,
  _NL_CTYPE_OUTDIGIT1_MB = _NL_CTYPE_CODESET_NAME + 28,
  _NL_CTYPE_OUTDIGIT2_MB = _NL_CTYPE_CODESET_NAME + 29,
  _NL_CTYPE_OUTDIGIT3_MB = _NL_CTYPE_CODESET_NAME + 30,
  _NL_CTYPE_OUTDIGIT4_MB = _NL_CTYPE_CODESET_NAME + 31,
  _NL_CTYPE_OUTDIGIT5_MB = _NL_CTYPE_CODESET_NAME + 32,
  _NL_CTYPE_OUTDIGIT6_MB = _NL_CTYPE_CODESET_NAME + 33,
  _NL_CTYPE_OUTDIGIT7_MB = _NL_CTYPE_CODESET_NAME + 34,
  _NL_CTYPE_OUTDIGIT8_MB = _NL_CTYPE_CODESET_NAME + 35,
  _NL_CTYPE_OUTDIGIT9_MB = _NL_CTYPE_CODESET_NAME + 36,
  _NL_CTYPE_OUTDIGIT0_WC = _NL_CTYPE_CODESET_NAME + 37,
  _NL_CTYPE_OUTDIGIT1_WC = _NL_CTYPE_CODESET_NAME + 38,
  _NL_CTYPE_OUTDIGIT2_WC = _NL_CTYPE_CODESET_NAME + 39,
  _NL_CTYPE_OUTDIGIT3_WC = _NL_CTYPE_CODESET_NAME + 40,
  _NL_CTYPE_OUTDIGIT4_WC = _NL_CTYPE_CODESET_NAME + 41,
  _NL_CTYPE_OUTDIGIT5_WC = _NL_CTYPE_CODESET_NAME + 42,
  _NL_CTYPE_OUTDIGIT6_WC = _NL_CTYPE_CODESET_NAME + 43,
  _NL_CTYPE_OUTDIGIT7_WC = _NL_CTYPE_CODESET_NAME + 44,
  _NL_CTYPE_OUTDIGIT8_WC = _NL_CTYPE_CODESET_NAME + 45,
  _NL_CTYPE_OUTDIGIT9_WC = _NL_CTYPE_CODESET_NAME + 46,
  _NL_CTYPE_TRANSLIT_TAB_SIZE = _NL_CTYPE_CODESET_NAME + 47,
  _NL_CTYPE_TRANSLIT_FROM_IDX = _NL_CTYPE_CODESET_NAME + 48,
  _NL_CTYPE_TRANSLIT_FROM_TBL = _NL_CTYPE_CODESET_NAME + 49,
  _NL_CTYPE_TRANSLIT_TO_IDX = _NL_CTYPE_CODESET_NAME + 50,
  _NL_CTYPE_TRANSLIT_TO_TBL = _NL_CTYPE_CODESET_NAME + 51,
  _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN = _NL_CTYPE_CODESET_NAME + 52,
  _NL_CTYPE_TRANSLIT_DEFAULT_MISSING = _NL_CTYPE_CODESET_NAME + 53,
  _NL_CTYPE_TRANSLIT_IGNORE_LEN = _NL_CTYPE_CODESET_NAME + 54,
  _NL_CTYPE_TRANSLIT_IGNORE = _NL_CTYPE_CODESET_NAME + 55,
  _NL_CTYPE_MAP_TO_NONASCII = _NL_CTYPE_CODESET_NAME + 56,
  _NL_CTYPE_NONASCII_CASE = _NL_CTYPE_CODESET_NAME + 57,
  _NL_CTYPE_EXTRA_MAP_1 = _NL_CTYPE_CODESET_NAME + 58,
  _NL_CTYPE_EXTRA_MAP_2 = _NL_CTYPE_CODESET_NAME + 59,
  _NL_CTYPE_EXTRA_MAP_3 = _NL_CTYPE_CODESET_NAME + 60,
  _NL_CTYPE_EXTRA_MAP_4 = _NL_CTYPE_CODESET_NAME + 61,
  _NL_CTYPE_EXTRA_MAP_5 = _NL_CTYPE_CODESET_NAME + 62,
  _NL_CTYPE_EXTRA_MAP_6 = _NL_CTYPE_CODESET_NAME + 63,
  _NL_CTYPE_EXTRA_MAP_7 = _NL_CTYPE_CODESET_NAME + 64,
  _NL_CTYPE_EXTRA_MAP_8 = _NL_CTYPE_CODESET_NAME + 65,
  _NL_CTYPE_EXTRA_MAP_9 = _NL_CTYPE_CODESET_NAME + 66,
  _NL_CTYPE_EXTRA_MAP_10 = _NL_CTYPE_CODESET_NAME + 67,
  _NL_CTYPE_EXTRA_MAP_11 = _NL_CTYPE_CODESET_NAME + 68,
  _NL_CTYPE_EXTRA_MAP_12 = _NL_CTYPE_CODESET_NAME + 69,
  _NL_CTYPE_EXTRA_MAP_13 = _NL_CTYPE_CODESET_NAME + 70,
  _NL_CTYPE_EXTRA_MAP_14 = _NL_CTYPE_CODESET_NAME + 71,
  _NL_NUM_LC_CTYPE = _NL_CTYPE_CODESET_NAME + 72,

  /* LC_MONETARY category: formatting of monetary quantities.
     These items each correspond to a member of `struct lconv',
     defined in <locale.h>.  */
  __INT_CURR_SYMBOL = (((__LC_MONETARY) << 16) | ( 0));
// #ifdef __USE_GNU
public static final int INT_CURR_SYMBOL =	__INT_CURR_SYMBOL;
// #endif
public static final int
  __CURRENCY_SYMBOL = (((__LC_MONETARY) << 16) | ( 0)) + 1;
// #ifdef __USE_GNU
public static final int CURRENCY_SYMBOL =	__CURRENCY_SYMBOL;
// #endif
public static final int
  __MON_DECIMAL_POINT = (((__LC_MONETARY) << 16) | ( 0)) + 2;
// #ifdef __USE_GNU
public static final int MON_DECIMAL_POINT =	__MON_DECIMAL_POINT;
// #endif
public static final int
  __MON_THOUSANDS_SEP = (((__LC_MONETARY) << 16) | ( 0)) + 3;
// #ifdef __USE_GNU
public static final int MON_THOUSANDS_SEP =	__MON_THOUSANDS_SEP;
// #endif
public static final int
  __MON_GROUPING = (((__LC_MONETARY) << 16) | ( 0)) + 4;
// #ifdef __USE_GNU
public static final int MON_GROUPING =		__MON_GROUPING;
// #endif
public static final int
  __POSITIVE_SIGN = (((__LC_MONETARY) << 16) | ( 0)) + 5;
// #ifdef __USE_GNU
public static final int POSITIVE_SIGN =		__POSITIVE_SIGN;
// #endif
public static final int
  __NEGATIVE_SIGN = (((__LC_MONETARY) << 16) | ( 0)) + 6;
// #ifdef __USE_GNU
public static final int NEGATIVE_SIGN =		__NEGATIVE_SIGN;
// #endif
public static final int
  __INT_FRAC_DIGITS = (((__LC_MONETARY) << 16) | ( 0)) + 7;
// #ifdef __USE_GNU
public static final int INT_FRAC_DIGITS =	__INT_FRAC_DIGITS;
// #endif
public static final int
  __FRAC_DIGITS = (((__LC_MONETARY) << 16) | ( 0)) + 8;
// #ifdef __USE_GNU
public static final int FRAC_DIGITS =		__FRAC_DIGITS;
// #endif
public static final int
  __P_CS_PRECEDES = (((__LC_MONETARY) << 16) | ( 0)) + 9;
// #ifdef __USE_GNU
public static final int P_CS_PRECEDES =		__P_CS_PRECEDES;
// #endif
public static final int
  __P_SEP_BY_SPACE = (((__LC_MONETARY) << 16) | ( 0)) + 10;
// #ifdef __USE_GNU
public static final int P_SEP_BY_SPACE =		__P_SEP_BY_SPACE;
// #endif
public static final int
  __N_CS_PRECEDES = (((__LC_MONETARY) << 16) | ( 0)) + 11;
// #ifdef __USE_GNU
public static final int N_CS_PRECEDES =		__N_CS_PRECEDES;
// #endif
public static final int
  __N_SEP_BY_SPACE = (((__LC_MONETARY) << 16) | ( 0)) + 12;
// #ifdef __USE_GNU
public static final int N_SEP_BY_SPACE =		__N_SEP_BY_SPACE;
// #endif
public static final int
  __P_SIGN_POSN = (((__LC_MONETARY) << 16) | ( 0)) + 13;
// #ifdef __USE_GNU
public static final int P_SIGN_POSN =		__P_SIGN_POSN;
// #endif
public static final int
  __N_SIGN_POSN = (((__LC_MONETARY) << 16) | ( 0)) + 14;
// #ifdef __USE_GNU
public static final int N_SIGN_POSN =		__N_SIGN_POSN;
// #endif
public static final int
  _NL_MONETARY_CRNCYSTR = (((__LC_MONETARY) << 16) | ( 0)) + 15;
public static final int CRNCYSTR =		_NL_MONETARY_CRNCYSTR;
public static final int
  __INT_P_CS_PRECEDES = (((__LC_MONETARY) << 16) | ( 0)) + 16;
// #ifdef __USE_GNU
public static final int INT_P_CS_PRECEDES =	__INT_P_CS_PRECEDES;
// #endif
public static final int
  __INT_P_SEP_BY_SPACE = (((__LC_MONETARY) << 16) | ( 0)) + 17;
// #ifdef __USE_GNU
public static final int INT_P_SEP_BY_SPACE =	__INT_P_SEP_BY_SPACE;
// #endif
public static final int
  __INT_N_CS_PRECEDES = (((__LC_MONETARY) << 16) | ( 0)) + 18;
// #ifdef __USE_GNU
public static final int INT_N_CS_PRECEDES =	__INT_N_CS_PRECEDES;
// #endif
public static final int
  __INT_N_SEP_BY_SPACE = (((__LC_MONETARY) << 16) | ( 0)) + 19;
// #ifdef __USE_GNU
public static final int INT_N_SEP_BY_SPACE =	__INT_N_SEP_BY_SPACE;
// #endif
public static final int
  __INT_P_SIGN_POSN = (((__LC_MONETARY) << 16) | ( 0)) + 20;
// #ifdef __USE_GNU
public static final int INT_P_SIGN_POSN =	__INT_P_SIGN_POSN;
// #endif
public static final int
  __INT_N_SIGN_POSN = (((__LC_MONETARY) << 16) | ( 0)) + 21;
// #ifdef __USE_GNU
public static final int INT_N_SIGN_POSN =	__INT_N_SIGN_POSN;
// #endif
public static final int
  _NL_MONETARY_DUO_INT_CURR_SYMBOL = (((__LC_MONETARY) << 16) | ( 0)) + 22,
  _NL_MONETARY_DUO_CURRENCY_SYMBOL = (((__LC_MONETARY) << 16) | ( 0)) + 23,
  _NL_MONETARY_DUO_INT_FRAC_DIGITS = (((__LC_MONETARY) << 16) | ( 0)) + 24,
  _NL_MONETARY_DUO_FRAC_DIGITS = (((__LC_MONETARY) << 16) | ( 0)) + 25,
  _NL_MONETARY_DUO_P_CS_PRECEDES = (((__LC_MONETARY) << 16) | ( 0)) + 26,
  _NL_MONETARY_DUO_P_SEP_BY_SPACE = (((__LC_MONETARY) << 16) | ( 0)) + 27,
  _NL_MONETARY_DUO_N_CS_PRECEDES = (((__LC_MONETARY) << 16) | ( 0)) + 28,
  _NL_MONETARY_DUO_N_SEP_BY_SPACE = (((__LC_MONETARY) << 16) | ( 0)) + 29,
  _NL_MONETARY_DUO_INT_P_CS_PRECEDES = (((__LC_MONETARY) << 16) | ( 0)) + 30,
  _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE = (((__LC_MONETARY) << 16) | ( 0)) + 31,
  _NL_MONETARY_DUO_INT_N_CS_PRECEDES = (((__LC_MONETARY) << 16) | ( 0)) + 32,
  _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE = (((__LC_MONETARY) << 16) | ( 0)) + 33,
  _NL_MONETARY_DUO_P_SIGN_POSN = (((__LC_MONETARY) << 16) | ( 0)) + 34,
  _NL_MONETARY_DUO_N_SIGN_POSN = (((__LC_MONETARY) << 16) | ( 0)) + 35,
  _NL_MONETARY_DUO_INT_P_SIGN_POSN = (((__LC_MONETARY) << 16) | ( 0)) + 36,
  _NL_MONETARY_DUO_INT_N_SIGN_POSN = (((__LC_MONETARY) << 16) | ( 0)) + 37,
  _NL_MONETARY_UNO_VALID_FROM = (((__LC_MONETARY) << 16) | ( 0)) + 38,
  _NL_MONETARY_UNO_VALID_TO = (((__LC_MONETARY) << 16) | ( 0)) + 39,
  _NL_MONETARY_DUO_VALID_FROM = (((__LC_MONETARY) << 16) | ( 0)) + 40,
  _NL_MONETARY_DUO_VALID_TO = (((__LC_MONETARY) << 16) | ( 0)) + 41,
  _NL_MONETARY_CONVERSION_RATE = (((__LC_MONETARY) << 16) | ( 0)) + 42,
  _NL_MONETARY_DECIMAL_POINT_WC = (((__LC_MONETARY) << 16) | ( 0)) + 43,
  _NL_MONETARY_THOUSANDS_SEP_WC = (((__LC_MONETARY) << 16) | ( 0)) + 44,
  _NL_MONETARY_CODESET = (((__LC_MONETARY) << 16) | ( 0)) + 45,
  _NL_NUM_LC_MONETARY = (((__LC_MONETARY) << 16) | ( 0)) + 46,

  /* LC_NUMERIC category: formatting of numbers.
     These also correspond to members of `struct lconv'; see <locale.h>.  */
  __DECIMAL_POINT = (((__LC_NUMERIC) << 16) | ( 0));
// #ifdef __USE_GNU
public static final int DECIMAL_POINT =		__DECIMAL_POINT;
// #endif
public static final int
  RADIXCHAR = __DECIMAL_POINT,
// #define RADIXCHAR		RADIXCHAR
  __THOUSANDS_SEP = __DECIMAL_POINT + 1;
// #ifdef __USE_GNU
public static final int THOUSANDS_SEP =		__THOUSANDS_SEP;
// #endif
public static final int
  THOUSEP = __THOUSANDS_SEP,
// #define THOUSEP			THOUSEP
  __GROUPING = __THOUSANDS_SEP + 1;
// #ifdef __USE_GNU
public static final int GROUPING =		__GROUPING;
// #endif
public static final int
  _NL_NUMERIC_DECIMAL_POINT_WC = __THOUSANDS_SEP + 2,
  _NL_NUMERIC_THOUSANDS_SEP_WC = __THOUSANDS_SEP + 3,
  _NL_NUMERIC_CODESET = __THOUSANDS_SEP + 4,
  _NL_NUM_LC_NUMERIC = __THOUSANDS_SEP + 5,

  __YESEXPR = (((__LC_MESSAGES) << 16) | ( 0)); /* Regex matching ``yes'' input.  */
public static final int YESEXPR =			__YESEXPR;
public static final int
  __NOEXPR = (((__LC_MESSAGES) << 16) | ( 0)) + 1;			/* Regex matching ``no'' input.  */
public static final int NOEXPR =			__NOEXPR;
public static final int
  __YESSTR = (((__LC_MESSAGES) << 16) | ( 0)) + 2;			/* Output string for ``yes''.  */
// #if defined __USE_GNU || (defined __USE_XOPEN && !defined __USE_XOPEN2K)
public static final int YESSTR =			__YESSTR;
// #endif
public static final int
  __NOSTR = (((__LC_MESSAGES) << 16) | ( 0)) + 3;			/* Output string for ``no''.  */
// #if defined __USE_GNU || (defined __USE_XOPEN && !defined __USE_XOPEN2K)
public static final int NOSTR =			__NOSTR;
// #endif
public static final int
  _NL_MESSAGES_CODESET = (((__LC_MESSAGES) << 16) | ( 0)) + 4,
  _NL_NUM_LC_MESSAGES = (((__LC_MESSAGES) << 16) | ( 0)) + 5,

  _NL_PAPER_HEIGHT = (((__LC_PAPER) << 16) | ( 0)),
  _NL_PAPER_WIDTH = (((__LC_PAPER) << 16) | ( 0)) + 1,
  _NL_PAPER_CODESET = (((__LC_PAPER) << 16) | ( 0)) + 2,
  _NL_NUM_LC_PAPER = (((__LC_PAPER) << 16) | ( 0)) + 3,

  _NL_NAME_NAME_FMT = (((__LC_NAME) << 16) | ( 0)),
  _NL_NAME_NAME_GEN = (((__LC_NAME) << 16) | ( 0)) + 1,
  _NL_NAME_NAME_MR = (((__LC_NAME) << 16) | ( 0)) + 2,
  _NL_NAME_NAME_MRS = (((__LC_NAME) << 16) | ( 0)) + 3,
  _NL_NAME_NAME_MISS = (((__LC_NAME) << 16) | ( 0)) + 4,
  _NL_NAME_NAME_MS = (((__LC_NAME) << 16) | ( 0)) + 5,
  _NL_NAME_CODESET = (((__LC_NAME) << 16) | ( 0)) + 6,
  _NL_NUM_LC_NAME = (((__LC_NAME) << 16) | ( 0)) + 7,

  _NL_ADDRESS_POSTAL_FMT = (((__LC_ADDRESS) << 16) | ( 0)),
  _NL_ADDRESS_COUNTRY_NAME = (((__LC_ADDRESS) << 16) | ( 0)) + 1,
  _NL_ADDRESS_COUNTRY_POST = (((__LC_ADDRESS) << 16) | ( 0)) + 2,
  _NL_ADDRESS_COUNTRY_AB2 = (((__LC_ADDRESS) << 16) | ( 0)) + 3,
  _NL_ADDRESS_COUNTRY_AB3 = (((__LC_ADDRESS) << 16) | ( 0)) + 4,
  _NL_ADDRESS_COUNTRY_CAR = (((__LC_ADDRESS) << 16) | ( 0)) + 5,
  _NL_ADDRESS_COUNTRY_NUM = (((__LC_ADDRESS) << 16) | ( 0)) + 6,
  _NL_ADDRESS_COUNTRY_ISBN = (((__LC_ADDRESS) << 16) | ( 0)) + 7,
  _NL_ADDRESS_LANG_NAME = (((__LC_ADDRESS) << 16) | ( 0)) + 8,
  _NL_ADDRESS_LANG_AB = (((__LC_ADDRESS) << 16) | ( 0)) + 9,
  _NL_ADDRESS_LANG_TERM = (((__LC_ADDRESS) << 16) | ( 0)) + 10,
  _NL_ADDRESS_LANG_LIB = (((__LC_ADDRESS) << 16) | ( 0)) + 11,
  _NL_ADDRESS_CODESET = (((__LC_ADDRESS) << 16) | ( 0)) + 12,
  _NL_NUM_LC_ADDRESS = (((__LC_ADDRESS) << 16) | ( 0)) + 13,

  _NL_TELEPHONE_TEL_INT_FMT = (((__LC_TELEPHONE) << 16) | ( 0)),
  _NL_TELEPHONE_TEL_DOM_FMT = (((__LC_TELEPHONE) << 16) | ( 0)) + 1,
  _NL_TELEPHONE_INT_SELECT = (((__LC_TELEPHONE) << 16) | ( 0)) + 2,
  _NL_TELEPHONE_INT_PREFIX = (((__LC_TELEPHONE) << 16) | ( 0)) + 3,
  _NL_TELEPHONE_CODESET = (((__LC_TELEPHONE) << 16) | ( 0)) + 4,
  _NL_NUM_LC_TELEPHONE = (((__LC_TELEPHONE) << 16) | ( 0)) + 5,

  _NL_MEASUREMENT_MEASUREMENT = (((__LC_MEASUREMENT) << 16) | ( 0)),
  _NL_MEASUREMENT_CODESET = (((__LC_MEASUREMENT) << 16) | ( 0)) + 1,
  _NL_NUM_LC_MEASUREMENT = (((__LC_MEASUREMENT) << 16) | ( 0)) + 2,

  _NL_IDENTIFICATION_TITLE = (((__LC_IDENTIFICATION) << 16) | ( 0)),
  _NL_IDENTIFICATION_SOURCE = (((__LC_IDENTIFICATION) << 16) | ( 0)) + 1,
  _NL_IDENTIFICATION_ADDRESS = (((__LC_IDENTIFICATION) << 16) | ( 0)) + 2,
  _NL_IDENTIFICATION_CONTACT = (((__LC_IDENTIFICATION) << 16) | ( 0)) + 3,
  _NL_IDENTIFICATION_EMAIL = (((__LC_IDENTIFICATION) << 16) | ( 0)) + 4,
  _NL_IDENTIFICATION_TEL = (((__LC_IDENTIFICATION) << 16) | ( 0)) + 5,
  _NL_IDENTIFICATION_FAX = (((__LC_IDENTIFICATION) << 16) | ( 0)) + 6,
  _NL_IDENTIFICATION_LANGUAGE = (((__LC_IDENTIFICATION) << 16) | ( 0)) + 7,
  _NL_IDENTIFICATION_TERRITORY = (((__LC_IDENTIFICATION) << 16) | ( 0)) + 8,
  _NL_IDENTIFICATION_AUDIENCE = (((__LC_IDENTIFICATION) << 16) | ( 0)) + 9,
  _NL_IDENTIFICATION_APPLICATION = (((__LC_IDENTIFICATION) << 16) | ( 0)) + 10,
  _NL_IDENTIFICATION_ABBREVIATION = (((__LC_IDENTIFICATION) << 16) | ( 0)) + 11,
  _NL_IDENTIFICATION_REVISION = (((__LC_IDENTIFICATION) << 16) | ( 0)) + 12,
  _NL_IDENTIFICATION_DATE = (((__LC_IDENTIFICATION) << 16) | ( 0)) + 13,
  _NL_IDENTIFICATION_CATEGORY = (((__LC_IDENTIFICATION) << 16) | ( 0)) + 14,
  _NL_IDENTIFICATION_CODESET = (((__LC_IDENTIFICATION) << 16) | ( 0)) + 15,
  _NL_NUM_LC_IDENTIFICATION = (((__LC_IDENTIFICATION) << 16) | ( 0)) + 16,

  /* This marks the highest value used.  */
  _NL_NUM = (((__LC_IDENTIFICATION) << 16) | ( 0)) + 17;

/* This macro produces an item you can pass to `nl_langinfo' or
   `nl_langinfo_l' to get the name of the locale in use for CATEGORY.  */
// #define _NL_LOCALE_NAME(category)	_NL_ITEM ((category),
// 						  _NL_ITEM_INDEX (-1))
// #ifdef __USE_GNU
// # define NL_LOCALE_NAME(category)	_NL_LOCALE_NAME (category)
// #endif


/* Return the current locale's value for ITEM.
   If ITEM is invalid, an empty string is returned.

   The string returned will not change until `setlocale' is called;
   it is usually in read-only memory and cannot be modified.  */

public static native @Cast("char*") BytePointer nl_langinfo(@Cast("nl_item") int __item);


// #ifdef	__USE_XOPEN2K
/* This interface is for the extended locale model.  See <locale.h> for
   more information.  */

/* Get locale datatype definition.  */
// # include <xlocale.h>

/* Just like nl_langinfo but get the information from the locale object L.  */
public static native @Cast("char*") BytePointer nl_langinfo_l(@Cast("nl_item") int __item, locale_t __l);
// #endif

// #endif	/* langinfo.h */


// Parsed from locale.h

/* Copyright (C) 1991,1992,1995-2002,2007,2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.11 Localization	<locale.h>
 */

// #ifndef	_LOCALE_H
public static final int _LOCALE_H =	1;

// #include <features.h>

// #define __need_NULL
// #include <stddef.h>
// #include <bits/locale.h>

/* These are the possibilities for the first argument to setlocale.
   The code assumes that the lowest LC_* symbol has the value zero.  */
public static final int LC_CTYPE =          __LC_CTYPE;
public static final int LC_NUMERIC =        __LC_NUMERIC;
public static final int LC_TIME =           __LC_TIME;
public static final int LC_COLLATE =        __LC_COLLATE;
public static final int LC_MONETARY =       __LC_MONETARY;
public static final int LC_MESSAGES =       __LC_MESSAGES;
public static final int LC_ALL =		  __LC_ALL;
public static final int LC_PAPER =	  __LC_PAPER;
public static final int LC_NAME =		  __LC_NAME;
public static final int LC_ADDRESS =	  __LC_ADDRESS;
public static final int LC_TELEPHONE =	  __LC_TELEPHONE;
public static final int LC_MEASUREMENT =	  __LC_MEASUREMENT;
public static final int LC_IDENTIFICATION = __LC_IDENTIFICATION;
// Targeting ../linux/lconv.java




/* Set and/or return the current locale.  */
public static native @Cast("char*") BytePointer setlocale(int __category, @Cast("const char*") BytePointer __locale);
public static native @Cast("char*") ByteBuffer setlocale(int __category, String __locale);

/* Return the numeric/monetary information for the current locale.  */
public static native lconv localeconv();

// #ifdef	__USE_XOPEN2K8
/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another application is
   the implementation of the internationalization handling in the
   upcoming ISO C++ standard library.  To support this another set of
   the functions using locale data exist which have an additional
   argument.

   Attention: all these functions are *not* standardized in any form.
   This is a proof-of-concept implementation.  */

/* Get locale datatype definition.  */
// # include <xlocale.h>

/* Return a reference to a data structure representing a set of locale
   datasets.  Unlike for the CATEGORY parameter for `setlocale' the
   CATEGORY_MASK parameter here uses a single bit for each category,
   made by OR'ing together LC_*_MASK bits above.  */
public static native locale_t newlocale(int __category_mask, @Cast("const char*") BytePointer __locale,
			     locale_t __base);
public static native locale_t newlocale(int __category_mask, String __locale,
			     locale_t __base);

/* These are the bits that can be set in the CATEGORY_MASK argument to
   `newlocale'.  In the GNU implementation, LC_FOO_MASK has the value
   of (1 << LC_FOO), but this is not a part of the interface that
   callers can assume will be true.  */
public static final int LC_CTYPE_MASK =		(1 << __LC_CTYPE);
public static final int LC_NUMERIC_MASK =	(1 << __LC_NUMERIC);
public static final int LC_TIME_MASK =		(1 << __LC_TIME);
public static final int LC_COLLATE_MASK =	(1 << __LC_COLLATE);
public static final int LC_MONETARY_MASK =	(1 << __LC_MONETARY);
public static final int LC_MESSAGES_MASK =	(1 << __LC_MESSAGES);
public static final int LC_PAPER_MASK =		(1 << __LC_PAPER);
public static final int LC_NAME_MASK =		(1 << __LC_NAME);
public static final int LC_ADDRESS_MASK =	(1 << __LC_ADDRESS);
public static final int LC_TELEPHONE_MASK =	(1 << __LC_TELEPHONE);
public static final int LC_MEASUREMENT_MASK =	(1 << __LC_MEASUREMENT);
public static final int LC_IDENTIFICATION_MASK =	(1 << __LC_IDENTIFICATION);
public static final int LC_ALL_MASK =		(LC_CTYPE_MASK 
				 | LC_NUMERIC_MASK 
				 | LC_TIME_MASK 
				 | LC_COLLATE_MASK 
				 | LC_MONETARY_MASK 
				 | LC_MESSAGES_MASK 
				 | LC_PAPER_MASK 
				 | LC_NAME_MASK 
				 | LC_ADDRESS_MASK 
				 | LC_TELEPHONE_MASK 
				 | LC_MEASUREMENT_MASK 
				 | LC_IDENTIFICATION_MASK 
				 );

/* Return a duplicate of the set of locale in DATASET.  All usage
   counters are increased if necessary.  */
public static native locale_t duplocale(locale_t __dataset);

/* Free the data associated with a locale dataset previously returned
   by a call to `setlocale_r'.  */
public static native void freelocale(locale_t __dataset);

/* Switch the current thread's locale to DATASET.
   If DATASET is null, instead just return the current setting.
   The special value LC_GLOBAL_LOCALE is the initial setting
   for all threads and can also be installed any time, meaning
   the thread uses the global settings controlled by `setlocale'.  */
public static native locale_t uselocale(locale_t __dataset);

/* This value can be passed to `uselocale' and may be returned by it.
   Passing this value to any other function has undefined behavior.  */
public static native @MemberGetter locale_t LC_GLOBAL_LOCALE();
public static final locale_t LC_GLOBAL_LOCALE = LC_GLOBAL_LOCALE();

// #endif

// #endif /* locale.h  */


// Parsed from bits/uio.h

/* Copyright (C) 1996, 1997, 2006 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #if !defined _SYS_UIO_H && !defined _FCNTL_H
// # error "Never include <bits/uio.h> directly; use <sys/uio.h> instead."
// #endif

// #ifndef _BITS_UIO_H
public static final int _BITS_UIO_H =	1;

// #include <sys/types.h>


/* We should normally use the Linux kernel header file to define this
   type and macros but this calls for trouble because of the header
   includes other kernel headers.  */

/* Size of object which can be written atomically.

   This macro has different values in different kernel versions.  The
   latest versions of the kernel use 1024 and this is good choice.  Since
   the C library implementation of readv/writev is able to emulate the
   functionality even if the currently running kernel does not support
   this large value the readv/writev call will not fail because of this.  */
public static final int UIO_MAXIOV =	1024;
// Targeting ../linux/iovec.java



// #endif


// Parsed from sys/uio.h

/* Copyright (C) 1991,1992,1996-1999,2003,2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef _SYS_UIO_H
public static final int _SYS_UIO_H =	1;

// #include <features.h>

// #include <sys/types.h>

/* This file defines `struct iovec'.  */
// #include <bits/uio.h>


/* Read data from file descriptor FD, and put the result in the
   buffers described by IOVEC, which is a vector of COUNT 'struct iovec's.
   The buffers are filled in the order specified.
   Operates just like 'read' (see <unistd.h>) except that data are
   put in IOVEC instead of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long readv(int __fd, @Const iovec __iovec, int __count);

/* Write data pointed by the buffers described by IOVEC, which
   is a vector of COUNT 'struct iovec's, to file descriptor FD.
   The data is written in the order specified.
   Operates just like 'write' (see <unistd.h>) except that the data
   are taken from IOVEC instead of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long writev(int __fd, @Const iovec __iovec, int __count);


// #ifdef __USE_BSD
// # ifndef __USE_FILE_OFFSET64
/* Read data from file descriptor FD at the given position OFFSET
   without change the file pointer, and put the result in the buffers
   described by IOVEC, which is a vector of COUNT 'struct iovec's.
   The buffers are filled in the order specified.  Operates just like
   'pread' (see <unistd.h>) except that data are put in IOVEC instead
   of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long preadv(int __fd, @Const iovec __iovec, int __count,
		       @Cast("__off_t") long __offset);

/* Write data pointed by the buffers described by IOVEC, which is a
   vector of COUNT 'struct iovec's, to file descriptor FD at the given
   position OFFSET without change the file pointer.  The data is
   written in the order specified.  Operates just like 'pwrite' (see
   <unistd.h>) except that the data are taken from IOVEC instead of a
   contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long pwritev(int __fd, @Const iovec __iovec, int __count,
			@Cast("__off_t") long __offset);
// # else
// # endif

// # ifdef __USE_LARGEFILE64
/* Read data from file descriptor FD at the given position OFFSET
   without change the file pointer, and put the result in the buffers
   described by IOVEC, which is a vector of COUNT 'struct iovec's.
   The buffers are filled in the order specified.  Operates just like
   'pread' (see <unistd.h>) except that data are put in IOVEC instead
   of a contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long preadv64(int __fd, @Const iovec __iovec, int __count,
			 @Cast("__off64_t") long __offset);

/* Write data pointed by the buffers described by IOVEC, which is a
   vector of COUNT 'struct iovec's, to file descriptor FD at the given
   position OFFSET without change the file pointer.  The data is
   written in the order specified.  Operates just like 'pwrite' (see
   <unistd.h>) except that the data are taken from IOVEC instead of a
   contiguous buffer.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long pwritev64(int __fd, @Const iovec __iovec, int __count,
			  @Cast("__off64_t") long __offset);
// # endif
// #endif	/* Use BSD */

// #endif /* sys/uio.h */


// Parsed from bits/sockaddr.h

/* Definition of `struct sockaddr_*' common members.  Generic/4.2 BSD version.
   Copyright (C) 1995,1996,1997,1998,2000,2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 * Never include this file directly; use <sys/socket.h> instead.
 */

// #ifndef _BITS_SOCKADDR_H
public static final int _BITS_SOCKADDR_H =	1;


/* POSIX.1g specifies this type name for the `sa_family' member.  */

/* This macro is used to declare the initial common members
   of the data types used for socket addresses, `struct sockaddr',
   `struct sockaddr_in', `struct sockaddr_un', etc.  */

// #define	__SOCKADDR_COMMON(sa_prefix)
//   sa_family_t sa_prefix##family

public static native @MemberGetter int __SOCKADDR_COMMON_SIZE();
public static final int __SOCKADDR_COMMON_SIZE = __SOCKADDR_COMMON_SIZE();

/* Size of struct sockaddr_storage.  */
public static final int _SS_SIZE = 128;

// #endif	/* bits/sockaddr.h */


// Parsed from bits/socket.h

/* System-specific socket constants and types.  Linux version.
   Copyright (C) 1991, 1992, 1994-2001, 2004, 2006, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef __BITS_SOCKET_H
// #define __BITS_SOCKET_H

// #ifndef _SYS_SOCKET_H
// # error "Never include <bits/socket.h> directly; use <sys/socket.h> instead."
// #endif

// #define	__need_size_t
// #include <stddef.h>

// #include <sys/types.h>

/* Type for length arguments in socket calls.  */
// #ifndef __socklen_t_defined
// # define __socklen_t_defined
// #endif

/* Types of sockets.  */
/** enum __socket_type */
public static final int
  SOCK_STREAM = 1,		/* Sequenced, reliable, connection-based
				   byte streams.  */
// #define SOCK_STREAM SOCK_STREAM
  SOCK_DGRAM = 2,		/* Connectionless, unreliable datagrams
				   of fixed maximum length.  */
// #define SOCK_DGRAM SOCK_DGRAM
  SOCK_RAW = 3,			/* Raw protocol interface.  */
// #define SOCK_RAW SOCK_RAW
  SOCK_RDM = 4,			/* Reliably-delivered messages.  */
// #define SOCK_RDM SOCK_RDM
  SOCK_SEQPACKET = 5,		/* Sequenced, reliable, connection-based,
				   datagrams of fixed maximum length.  */
// #define SOCK_SEQPACKET SOCK_SEQPACKET
  SOCK_DCCP = 6,		/* Datagram Congestion Control Protocol.  */
// #define SOCK_DCCP SOCK_DCCP
  SOCK_PACKET = 10,		/* Linux specific way of getting packets
				   at the dev level.  For writing rarp and
				   other similar things on the user level. */
// #define SOCK_PACKET SOCK_PACKET

  /* Flags to be ORed into the type parameter of socket and socketpair and
     used for the flags parameter of paccept.  */

  SOCK_CLOEXEC = 2000000,	/* Atomically set close-on-exec flag for the
				   new descriptor(s).  */
// #define SOCK_CLOEXEC SOCK_CLOEXEC
  SOCK_NONBLOCK = 4000;		/* Atomically mark descriptor(s) as
				   non-blocking.  */
// #define SOCK_NONBLOCK SOCK_NONBLOCK

/* Protocol families.  */
public static final int PF_UNSPEC =	0;	/* Unspecified.  */
public static final int PF_LOCAL =	1;	/* Local to host (pipes and file-domain).  */
public static final int PF_UNIX =		PF_LOCAL; /* POSIX name for PF_LOCAL.  */
public static final int PF_FILE =		PF_LOCAL; /* Another non-standard name for PF_LOCAL.  */
public static final int PF_INET =		2;	/* IP protocol family.  */
public static final int PF_AX25 =		3;	/* Amateur Radio AX.25.  */
public static final int PF_IPX =		4;	/* Novell Internet Protocol.  */
public static final int PF_APPLETALK =	5;	/* Appletalk DDP.  */
public static final int PF_NETROM =	6;	/* Amateur radio NetROM.  */
public static final int PF_BRIDGE =	7;	/* Multiprotocol bridge.  */
public static final int PF_ATMPVC =	8;	/* ATM PVCs.  */
public static final int PF_X25 =		9;	/* Reserved for X.25 project.  */
public static final int PF_INET6 =	10;	/* IP version 6.  */
public static final int PF_ROSE =		11;	/* Amateur Radio X.25 PLP.  */
public static final int PF_DECnet =	12;	/* Reserved for DECnet project.  */
public static final int PF_NETBEUI =	13;	/* Reserved for 802.2LLC project.  */
public static final int PF_SECURITY =	14;	/* Security callback pseudo AF.  */
public static final int PF_KEY =		15;	/* PF_KEY key management API.  */
public static final int PF_NETLINK =	16;
public static final int PF_ROUTE =	PF_NETLINK; /* Alias to emulate 4.4BSD.  */
public static final int PF_PACKET =	17;	/* Packet family.  */
public static final int PF_ASH =		18;	/* Ash.  */
public static final int PF_ECONET =	19;	/* Acorn Econet.  */
public static final int PF_ATMSVC =	20;	/* ATM SVCs.  */
public static final int PF_RDS =		21;	/* RDS sockets.  */
public static final int PF_SNA =		22;	/* Linux SNA Project */
public static final int PF_IRDA =		23;	/* IRDA sockets.  */
public static final int PF_PPPOX =	24;	/* PPPoX sockets.  */
public static final int PF_WANPIPE =	25;	/* Wanpipe API sockets.  */
public static final int PF_LLC =		26;	/* Linux LLC.  */
public static final int PF_CAN =		29;	/* Controller Area Network.  */
public static final int PF_TIPC =		30;	/* TIPC sockets.  */
public static final int PF_BLUETOOTH =	31;	/* Bluetooth sockets.  */
public static final int PF_IUCV =		32;	/* IUCV sockets.  */
public static final int PF_RXRPC =	33;	/* RxRPC sockets.  */
public static final int PF_ISDN =		34;	/* mISDN sockets.  */
public static final int PF_PHONET =	35;	/* Phonet sockets.  */
public static final int PF_IEEE802154 =	36;	/* IEEE 802.15.4 sockets.  */
public static final int PF_MAX =		37;	/* For now..  */

/* Address families.  */
public static final int AF_UNSPEC =	PF_UNSPEC;
public static final int AF_LOCAL =	PF_LOCAL;
public static final int AF_UNIX =		PF_UNIX;
public static final int AF_FILE =		PF_FILE;
public static final int AF_INET =		PF_INET;
public static final int AF_AX25 =		PF_AX25;
public static final int AF_IPX =		PF_IPX;
public static final int AF_APPLETALK =	PF_APPLETALK;
public static final int AF_NETROM =	PF_NETROM;
public static final int AF_BRIDGE =	PF_BRIDGE;
public static final int AF_ATMPVC =	PF_ATMPVC;
public static final int AF_X25 =		PF_X25;
public static final int AF_INET6 =	PF_INET6;
public static final int AF_ROSE =		PF_ROSE;
public static final int AF_DECnet =	PF_DECnet;
public static final int AF_NETBEUI =	PF_NETBEUI;
public static final int AF_SECURITY =	PF_SECURITY;
public static final int AF_KEY =		PF_KEY;
public static final int AF_NETLINK =	PF_NETLINK;
public static final int AF_ROUTE =	PF_ROUTE;
public static final int AF_PACKET =	PF_PACKET;
public static final int AF_ASH =		PF_ASH;
public static final int AF_ECONET =	PF_ECONET;
public static final int AF_ATMSVC =	PF_ATMSVC;
public static final int AF_RDS =		PF_RDS;
public static final int AF_SNA =		PF_SNA;
public static final int AF_IRDA =		PF_IRDA;
public static final int AF_PPPOX =	PF_PPPOX;
public static final int AF_WANPIPE =	PF_WANPIPE;
public static final int AF_LLC =		PF_LLC;
public static final int AF_CAN =		PF_CAN;
public static final int AF_TIPC =		PF_TIPC;
public static final int AF_BLUETOOTH =	PF_BLUETOOTH;
public static final int AF_IUCV =		PF_IUCV;
public static final int AF_RXRPC =	PF_RXRPC;
public static final int AF_ISDN =		PF_ISDN;
public static final int AF_PHONET =	PF_PHONET;
public static final int AF_IEEE802154 =	PF_IEEE802154;
public static final int AF_MAX =		PF_MAX;

/* Socket level values.  Others are defined in the appropriate headers.

   XXX These definitions also should go into the appropriate headers as
   far as they are available.  */
public static final int SOL_RAW =		255;
public static final int SOL_DECNET =      261;
public static final int SOL_X25 =         262;
public static final int SOL_PACKET =	263;
public static final int SOL_ATM =		264;	/* ATM layer (cell level).  */
public static final int SOL_AAL =		265;	/* ATM Adaption Layer (packet level).  */
public static final int SOL_IRDA =	266;

/* Maximum queue length specifiable by listen.  */
public static final int SOMAXCONN =	128;

/* Get the definition of the macro to define the common sockaddr members.  */
// #include <bits/sockaddr.h>
// Targeting ../linux/sockaddr.java




/* Structure large enough to hold any socket address (with the historical
   exception of AF_UNIX).  We reserve 128 bytes.  */
// #define __ss_aligntype	unsigned long int
public static native @MemberGetter int _SS_PADSIZE();
public static final int _SS_PADSIZE = _SS_PADSIZE();
// Targeting ../linux/sockaddr_storage.java




/* Bits in the FLAGS argument to `send', `recv', et al.  */
/** enum  */
public static final int
    MSG_OOB		 = 0x01,	/* Process out-of-band data.  */
// #define MSG_OOB		MSG_OOB
    MSG_PEEK		 = 0x02,	/* Peek at incoming messages.  */
// #define MSG_PEEK	MSG_PEEK
    MSG_DONTROUTE	 = 0x04,	/* Don't use local routing.  */
// #define MSG_DONTROUTE	MSG_DONTROUTE
// #ifdef __USE_GNU
    /* DECnet uses a different name.  */
    MSG_TRYHARD		 = MSG_DONTROUTE,
// # define MSG_TRYHARD	MSG_DONTROUTE
// #endif
    MSG_CTRUNC		 = 0x08,	/* Control data lost before delivery.  */
// #define MSG_CTRUNC	MSG_CTRUNC
    MSG_PROXY		 = 0x10,	/* Supply or ask second address.  */
// #define MSG_PROXY	MSG_PROXY
    MSG_TRUNC		 = 0x20,
// #define	MSG_TRUNC	MSG_TRUNC
    MSG_DONTWAIT	 = 0x40, /* Nonblocking IO.  */
// #define	MSG_DONTWAIT	MSG_DONTWAIT
    MSG_EOR		 = 0x80, /* End of record.  */
// #define	MSG_EOR		MSG_EOR
    MSG_WAITALL		 = 0x100, /* Wait for a full request.  */
// #define	MSG_WAITALL	MSG_WAITALL
    MSG_FIN		 = 0x200,
// #define	MSG_FIN		MSG_FIN
    MSG_SYN		 = 0x400,
// #define	MSG_SYN		MSG_SYN
    MSG_CONFIRM		 = 0x800, /* Confirm path validity.  */
// #define	MSG_CONFIRM	MSG_CONFIRM
    MSG_RST		 = 0x1000,
// #define	MSG_RST		MSG_RST
    MSG_ERRQUEUE	 = 0x2000, /* Fetch message from error queue.  */
// #define	MSG_ERRQUEUE	MSG_ERRQUEUE
    MSG_NOSIGNAL	 = 0x4000, /* Do not generate SIGPIPE.  */
// #define	MSG_NOSIGNAL	MSG_NOSIGNAL
    MSG_MORE		 = 0x8000,  /* Sender will send more.  */
// #define	MSG_MORE	MSG_MORE
    MSG_WAITFORONE	 = 0x10000, /* Wait for at least one packet to return.*/
// #define MSG_WAITFORONE	MSG_WAITFORONE

    MSG_CMSG_CLOEXEC	 = 0x40000000;	/* Set close_on_exit for file
					   descriptor received through
					   SCM_RIGHTS.  */
// #define MSG_CMSG_CLOEXEC MSG_CMSG_CLOEXEC
// Targeting ../linux/msghdr.java


// Targeting ../linux/mmsghdr.java


// Targeting ../linux/cmsghdr.java



/* Ancillary data object manipulation macros.  */
// #if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
// # define CMSG_DATA(cmsg) ((cmsg)->__cmsg_data)
// #else
// # define CMSG_DATA(cmsg) ((unsigned char *) ((struct cmsghdr *) (cmsg) + 1))
// #endif
// #define CMSG_NXTHDR(mhdr, cmsg) __cmsg_nxthdr (mhdr, cmsg)
// #define CMSG_FIRSTHDR(mhdr)
//   ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr)
//    ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) 0)
// #define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1)
// 			 & (size_t) ~(sizeof (size_t) - 1))
// #define CMSG_SPACE(len) (CMSG_ALIGN (len)
// 			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
// #define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))

public static native cmsghdr __cmsg_nxthdr(msghdr __mhdr,
				      cmsghdr __cmsg);
// #ifdef __USE_EXTERN_INLINES
// #endif	/* Use `extern inline'.  */

/* Socket level message types.  This must match the definitions in
   <linux/socket.h>.  */
/** enum  */
public static final int
    SCM_RIGHTS = 0x01,		/* Transfer file descriptors.  */
// #define SCM_RIGHTS SCM_RIGHTS
    SCM_CREDENTIALS = 0x02;	/* Credentials passing.  */
// # define SCM_CREDENTIALS SCM_CREDENTIALS
// #endif
// Targeting ../linux/ucred.java


// #endif

/* Ugly workaround for unclean kernel headers.  */
// #if !defined __USE_MISC && !defined __USE_GNU
// # ifndef FIOGETOWN
// #  define __SYS_SOCKET_H_undef_FIOGETOWN
// # endif
// # ifndef FIOSETOWN
// #  define __SYS_SOCKET_H_undef_FIOSETOWN
// # endif
// # ifndef SIOCATMARK
// #  define __SYS_SOCKET_H_undef_SIOCATMARK
// # endif
// # ifndef SIOCGPGRP
// #  define __SYS_SOCKET_H_undef_SIOCGPGRP
// # endif
// # ifndef SIOCGSTAMP
// #  define __SYS_SOCKET_H_undef_SIOCGSTAMP
// # endif
// # ifndef SIOCGSTAMPNS
// #  define __SYS_SOCKET_H_undef_SIOCGSTAMPNS
// # endif
// # ifndef SIOCSPGRP
// #  define __SYS_SOCKET_H_undef_SIOCSPGRP
// # endif
// #endif

/* Get socket manipulation related informations from kernel headers.  */
// #include <asm/socket.h>
// Targeting ../linux/linger.java




/* Receive a message as described by MESSAGE from socket FD.
   Returns the number of bytes read or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native int recvmmsg(int __fd, mmsghdr __vmessages,
		     @Cast("unsigned int") int __vlen, int __flags,
		     @Const timespec __tmo);

// #endif	/* bits/socket.h */


// Parsed from sys/socket.h

/* Declarations of socket constants, types, and functions.
   Copyright (C) 1991,92,1994-2001,2003,2005,2007,2008
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef	_SYS_SOCKET_H
public static final int _SYS_SOCKET_H =	1;

// #include <features.h>

// #include <sys/uio.h>
// #define	__need_size_t
// #include <stddef.h>
// #ifdef __USE_GNU
/* Get the __sigset_t definition.  */
// # include <bits/sigset.h>
// #endif


/* This operating system-specific header file defines the SOCK_*, PF_*,
   AF_*, MSG_*, SOL_*, and SO_* constants, and the `struct sockaddr',
   `struct msghdr', and `struct linger' types.  */
// #include <bits/socket.h>
// Targeting ../linux/osockaddr.java


// #endif

/* The following constants should be used for the second parameter of
   `shutdown'.  */
/** enum  */
public static final int
  SHUT_RD = 0,		/* No more receptions.  */
// #define SHUT_RD		SHUT_RD
  SHUT_WR = 1,		/* No more transmissions.  */
// #define SHUT_WR		SHUT_WR
  SHUT_RDWR = 2;		/* No more receptions or transmissions.  */
// #define SHUT_RDWR	SHUT_RDWR

/* This is the type we use for generic socket address arguments.

   With GCC 2.7 and later, the funky union causes redeclarations or
   uses with any of the listed types to be allowed without complaint.
   G++ 2.7 does not support transparent unions so there we want the
   old-style declaration, too.  */
// #if defined __cplusplus || !__GNUC_PREREQ (2, 7) || !defined __USE_GNU
// # define __SOCKADDR_ARG		struct sockaddr *__restrict
// # define __CONST_SOCKADDR_ARG	__const struct sockaddr *
// #else
// #endif


/* Create a new socket of type TYPE in domain DOMAIN, using
   protocol PROTOCOL.  If PROTOCOL is zero, one is chosen automatically.
   Returns a file descriptor for the new socket, or -1 for errors.  */
public static native int socket(int __domain, int __type, int __protocol);

/* Create two new sockets, of type TYPE in domain DOMAIN and using
   protocol PROTOCOL, which are connected to each other, and put file
   descriptors for them in FDS[0] and FDS[1].  If PROTOCOL is zero,
   one will be chosen automatically.  Returns 0 on success, -1 for errors.  */
public static native int socketpair(int __domain, int __type, int __protocol,
		       IntPointer __fds);
public static native int socketpair(int __domain, int __type, int __protocol,
		       IntBuffer __fds);
public static native int socketpair(int __domain, int __type, int __protocol,
		       int[] __fds);

/* Give the socket FD the local address ADDR (which is LEN bytes long).  */
public static native int bind(int __fd, @Const sockaddr __addr, @Cast("socklen_t") int __len);

/* Put the local address of FD into *ADDR and its length in *LEN.  */
public static native int getsockname(int __fd, sockaddr __addr,
			@Cast("socklen_t*") IntPointer __len);
public static native int getsockname(int __fd, sockaddr __addr,
			@Cast("socklen_t*") IntBuffer __len);
public static native int getsockname(int __fd, sockaddr __addr,
			@Cast("socklen_t*") int[] __len);

/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).
   For connectionless socket types, just set the default address to send to
   and the only address from which to accept transmissions.
   Return 0 on success, -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native int connect(int __fd, @Const sockaddr __addr, @Cast("socklen_t") int __len);

/* Put the address of the peer connected to socket FD into *ADDR
   (which is *LEN bytes long), and its actual length into *LEN.  */
public static native int getpeername(int __fd, sockaddr __addr,
			@Cast("socklen_t*") IntPointer __len);
public static native int getpeername(int __fd, sockaddr __addr,
			@Cast("socklen_t*") IntBuffer __len);
public static native int getpeername(int __fd, sockaddr __addr,
			@Cast("socklen_t*") int[] __len);


/* Send N bytes of BUF to socket FD.  Returns the number sent or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long send(int __fd, @Const Pointer __buf, @Cast("size_t") long __n, int __flags);

/* Read N bytes into BUF from socket FD.
   Returns the number read or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long recv(int __fd, Pointer __buf, @Cast("size_t") long __n, int __flags);

/* Send N bytes of BUF on socket FD to peer at address ADDR (which is
   ADDR_LEN bytes long).  Returns the number sent, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long sendto(int __fd, @Const Pointer __buf, @Cast("size_t") long __n,
		       int __flags, @Const sockaddr __addr,
		       @Cast("socklen_t") int __addr_len);

/* Read N bytes into BUF through socket FD.
   If ADDR is not NULL, fill in *ADDR_LEN bytes of it with tha address of
   the sender, and store the actual size of the address in *ADDR_LEN.
   Returns the number of bytes read or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long recvfrom(int __fd, Pointer __buf, @Cast("size_t") long __n,
			 int __flags, sockaddr __addr,
			 @Cast("socklen_t*") IntPointer __addr_len);
public static native @Cast("ssize_t") long recvfrom(int __fd, Pointer __buf, @Cast("size_t") long __n,
			 int __flags, sockaddr __addr,
			 @Cast("socklen_t*") IntBuffer __addr_len);
public static native @Cast("ssize_t") long recvfrom(int __fd, Pointer __buf, @Cast("size_t") long __n,
			 int __flags, sockaddr __addr,
			 @Cast("socklen_t*") int[] __addr_len);


/* Send a message described MESSAGE on socket FD.
   Returns the number of bytes sent, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long sendmsg(int __fd, @Const msghdr __message,
			int __flags);

/* Receive a message as described by MESSAGE from socket FD.
   Returns the number of bytes read or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long recvmsg(int __fd, msghdr __message, int __flags);


/* Put the current value for socket FD's option OPTNAME at protocol level LEVEL
   into OPTVAL (which is *OPTLEN bytes long), and set *OPTLEN to the value's
   actual length.  Returns 0 on success, -1 for errors.  */
public static native int getsockopt(int __fd, int __level, int __optname,
		       Pointer __optval,
		       @Cast("socklen_t*") IntPointer __optlen);
public static native int getsockopt(int __fd, int __level, int __optname,
		       Pointer __optval,
		       @Cast("socklen_t*") IntBuffer __optlen);
public static native int getsockopt(int __fd, int __level, int __optname,
		       Pointer __optval,
		       @Cast("socklen_t*") int[] __optlen);

/* Set socket FD's option OPTNAME at protocol level LEVEL
   to *OPTVAL (which is OPTLEN bytes long).
   Returns 0 on success, -1 for errors.  */
public static native int setsockopt(int __fd, int __level, int __optname,
		       @Const Pointer __optval, @Cast("socklen_t") int __optlen);


/* Prepare to accept connections on socket FD.
   N connection requests will be queued before further requests are refused.
   Returns 0 on success, -1 for errors.  */
public static native int listen(int __fd, int __n);

/* Await a connection on socket FD.
   When a connection arrives, open a new socket to communicate with it,
   set *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting
   peer and *ADDR_LEN to the address's actual length, and return the
   new socket's descriptor, or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native int accept(int __fd, sockaddr __addr,
		   @Cast("socklen_t*") IntPointer __addr_len);
public static native int accept(int __fd, sockaddr __addr,
		   @Cast("socklen_t*") IntBuffer __addr_len);
public static native int accept(int __fd, sockaddr __addr,
		   @Cast("socklen_t*") int[] __addr_len);

// #ifdef __USE_GNU
/* Similar to 'accept' but takes an additional parameter to specify flags.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native int accept4(int __fd, sockaddr __addr,
		    @Cast("socklen_t*") IntPointer __addr_len, int __flags);
public static native int accept4(int __fd, sockaddr __addr,
		    @Cast("socklen_t*") IntBuffer __addr_len, int __flags);
public static native int accept4(int __fd, sockaddr __addr,
		    @Cast("socklen_t*") int[] __addr_len, int __flags);
// #endif

/* Shut down all or part of the connection open on socket FD.
   HOW determines what to shut down:
     SHUT_RD   = No more receptions;
     SHUT_WR   = No more transmissions;
     SHUT_RDWR = No more receptions or transmissions.
   Returns 0 on success, -1 for errors.  */
public static native int shutdown(int __fd, int __how);


// #ifdef __USE_XOPEN2K
/* Determine wheter socket is at a out-of-band mark.  */
public static native int sockatmark(int __fd);
// #endif


// #ifdef __USE_MISC
/* FDTYPE is S_IFSOCK or another S_IF* macro defined in <sys/stat.h>;
   returns 1 if FD is open on an object of the indicated type, 0 if not,
   or -1 for errors (setting errno).  */
public static native int isfdtype(int __fd, int __fdtype);
// #endif


/* Define some macros helping to catch buffer overflows.  */
// #if __USE_FORTIFY_LEVEL > 0 && defined __extern_always_inline
// # include <bits/socket2.h>
// #endif

// #endif /* sys/socket.h */


// Parsed from asm-generic/errno-base.h

// #ifndef _ASM_GENERIC_ERRNO_BASE_H
// #define _ASM_GENERIC_ERRNO_BASE_H

public static final int EPERM =		 1;	/* Operation not permitted */
public static final int ENOENT =		 2;	/* No such file or directory */
public static final int ESRCH =		 3;	/* No such process */
public static final int EINTR =		 4;	/* Interrupted system call */
public static final int EIO =		 5;	/* I/O error */
public static final int ENXIO =		 6;	/* No such device or address */
public static final int E2BIG =		 7;	/* Argument list too long */
public static final int ENOEXEC =		 8;	/* Exec format error */
public static final int EBADF =		 9;	/* Bad file number */
public static final int ECHILD =		10;	/* No child processes */
public static final int EAGAIN =		11;	/* Try again */
public static final int ENOMEM =		12;	/* Out of memory */
public static final int EACCES =		13;	/* Permission denied */
public static final int EFAULT =		14;	/* Bad address */
public static final int ENOTBLK =		15;	/* Block device required */
public static final int EBUSY =		16;	/* Device or resource busy */
public static final int EEXIST =		17;	/* File exists */
public static final int EXDEV =		18;	/* Cross-device link */
public static final int ENODEV =		19;	/* No such device */
public static final int ENOTDIR =		20;	/* Not a directory */
public static final int EISDIR =		21;	/* Is a directory */
public static final int EINVAL =		22;	/* Invalid argument */
public static final int ENFILE =		23;	/* File table overflow */
public static final int EMFILE =		24;	/* Too many open files */
public static final int ENOTTY =		25;	/* Not a typewriter */
public static final int ETXTBSY =		26;	/* Text file busy */
public static final int EFBIG =		27;	/* File too large */
public static final int ENOSPC =		28;	/* No space left on device */
public static final int ESPIPE =		29;	/* Illegal seek */
public static final int EROFS =		30;	/* Read-only file system */
public static final int EMLINK =		31;	/* Too many links */
public static final int EPIPE =		32;	/* Broken pipe */
public static final int EDOM =		33;	/* Math argument out of domain of func */
public static final int ERANGE =		34;	/* Math result not representable */

// #endif


// Parsed from asm-generic/errno.h

// #ifndef _ASM_GENERIC_ERRNO_H
// #define _ASM_GENERIC_ERRNO_H

// #include <asm-generic/errno-base.h>

public static final int EDEADLK =		35;	/* Resource deadlock would occur */
public static final int ENAMETOOLONG =	36;	/* File name too long */
public static final int ENOLCK =		37;	/* No record locks available */
public static final int ENOSYS =		38;	/* Function not implemented */
public static final int ENOTEMPTY =	39;	/* Directory not empty */
public static final int ELOOP =		40;	/* Too many symbolic links encountered */
public static final int EWOULDBLOCK =	EAGAIN;	/* Operation would block */
public static final int ENOMSG =		42;	/* No message of desired type */
public static final int EIDRM =		43;	/* Identifier removed */
public static final int ECHRNG =		44;	/* Channel number out of range */
public static final int EL2NSYNC =	45;	/* Level 2 not synchronized */
public static final int EL3HLT =		46;	/* Level 3 halted */
public static final int EL3RST =		47;	/* Level 3 reset */
public static final int ELNRNG =		48;	/* Link number out of range */
public static final int EUNATCH =		49;	/* Protocol driver not attached */
public static final int ENOCSI =		50;	/* No CSI structure available */
public static final int EL2HLT =		51;	/* Level 2 halted */
public static final int EBADE =		52;	/* Invalid exchange */
public static final int EBADR =		53;	/* Invalid request descriptor */
public static final int EXFULL =		54;	/* Exchange full */
public static final int ENOANO =		55;	/* No anode */
public static final int EBADRQC =		56;	/* Invalid request code */
public static final int EBADSLT =		57;	/* Invalid slot */

public static final int EDEADLOCK =	EDEADLK;

public static final int EBFONT =		59;	/* Bad font file format */
public static final int ENOSTR =		60;	/* Device not a stream */
public static final int ENODATA =		61;	/* No data available */
public static final int ETIME =		62;	/* Timer expired */
public static final int ENOSR =		63;	/* Out of streams resources */
public static final int ENONET =		64;	/* Machine is not on the network */
public static final int ENOPKG =		65;	/* Package not installed */
public static final int EREMOTE =		66;	/* Object is remote */
public static final int ENOLINK =		67;	/* Link has been severed */
public static final int EADV =		68;	/* Advertise error */
public static final int ESRMNT =		69;	/* Srmount error */
public static final int ECOMM =		70;	/* Communication error on send */
public static final int EPROTO =		71;	/* Protocol error */
public static final int EMULTIHOP =	72;	/* Multihop attempted */
public static final int EDOTDOT =		73;	/* RFS specific error */
public static final int EBADMSG =		74;	/* Not a data message */
public static final int EOVERFLOW =	75;	/* Value too large for defined data type */
public static final int ENOTUNIQ =	76;	/* Name not unique on network */
public static final int EBADFD =		77;	/* File descriptor in bad state */
public static final int EREMCHG =		78;	/* Remote address changed */
public static final int ELIBACC =		79;	/* Can not access a needed shared library */
public static final int ELIBBAD =		80;	/* Accessing a corrupted shared library */
public static final int ELIBSCN =		81;	/* .lib section in a.out corrupted */
public static final int ELIBMAX =		82;	/* Attempting to link in too many shared libraries */
public static final int ELIBEXEC =	83;	/* Cannot exec a shared library directly */
public static final int EILSEQ =		84;	/* Illegal byte sequence */
public static final int ERESTART =	85;	/* Interrupted system call should be restarted */
public static final int ESTRPIPE =	86;	/* Streams pipe error */
public static final int EUSERS =		87;	/* Too many users */
public static final int ENOTSOCK =	88;	/* Socket operation on non-socket */
public static final int EDESTADDRREQ =	89;	/* Destination address required */
public static final int EMSGSIZE =	90;	/* Message too long */
public static final int EPROTOTYPE =	91;	/* Protocol wrong type for socket */
public static final int ENOPROTOOPT =	92;	/* Protocol not available */
public static final int EPROTONOSUPPORT =	93;	/* Protocol not supported */
public static final int ESOCKTNOSUPPORT =	94;	/* Socket type not supported */
public static final int EOPNOTSUPP =	95;	/* Operation not supported on transport endpoint */
public static final int EPFNOSUPPORT =	96;	/* Protocol family not supported */
public static final int EAFNOSUPPORT =	97;	/* Address family not supported by protocol */
public static final int EADDRINUSE =	98;	/* Address already in use */
public static final int EADDRNOTAVAIL =	99;	/* Cannot assign requested address */
public static final int ENETDOWN =	100;	/* Network is down */
public static final int ENETUNREACH =	101;	/* Network is unreachable */
public static final int ENETRESET =	102;	/* Network dropped connection because of reset */
public static final int ECONNABORTED =	103;	/* Software caused connection abort */
public static final int ECONNRESET =	104;	/* Connection reset by peer */
public static final int ENOBUFS =		105;	/* No buffer space available */
public static final int EISCONN =		106;	/* Transport endpoint is already connected */
public static final int ENOTCONN =	107;	/* Transport endpoint is not connected */
public static final int ESHUTDOWN =	108;	/* Cannot send after transport endpoint shutdown */
public static final int ETOOMANYREFS =	109;	/* Too many references: cannot splice */
public static final int ETIMEDOUT =	110;	/* Connection timed out */
public static final int ECONNREFUSED =	111;	/* Connection refused */
public static final int EHOSTDOWN =	112;	/* Host is down */
public static final int EHOSTUNREACH =	113;	/* No route to host */
public static final int EALREADY =	114;	/* Operation already in progress */
public static final int EINPROGRESS =	115;	/* Operation now in progress */
public static final int ESTALE =		116;	/* Stale file handle */
public static final int EUCLEAN =		117;	/* Structure needs cleaning */
public static final int ENOTNAM =		118;	/* Not a XENIX named type file */
public static final int ENAVAIL =		119;	/* No XENIX semaphores available */
public static final int EISNAM =		120;	/* Is a named type file */
public static final int EREMOTEIO =	121;	/* Remote I/O error */
public static final int EDQUOT =		122;	/* Quota exceeded */

public static final int ENOMEDIUM =	123;	/* No medium found */
public static final int EMEDIUMTYPE =	124;	/* Wrong medium type */
public static final int ECANCELED =	125;	/* Operation Canceled */
public static final int ENOKEY =		126;	/* Required key not available */
public static final int EKEYEXPIRED =	127;	/* Key has expired */
public static final int EKEYREVOKED =	128;	/* Key has been revoked */
public static final int EKEYREJECTED =	129;	/* Key was rejected by service */

/* for robust mutexes */
public static final int EOWNERDEAD =	130;	/* Owner died */
public static final int ENOTRECOVERABLE =	131;	/* State not recoverable */

public static final int ERFKILL =		132;	/* Operation not possible due to RF-kill */

public static final int EHWPOISON =	133;	/* Memory page has hardware error */

// #endif


// Parsed from bits/errno.h

/* Error constants.  Linux specific version.
   Copyright (C) 1996-1999, 2005, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifdef _ERRNO_H

// # undef EDOM
// # undef EILSEQ
// # undef ERANGE
// # include <linux/errno.h>

/* Linux has no ENOTSUP error code.  */
public static final int ENOTSUP = EOPNOTSUPP;

/* Older Linux versions also had no ECANCELED error code.  */
// # ifndef ECANCELED
// # endif

/* Support for error codes to support robust mutexes was added later, too.  */
// # ifndef EOWNERDEAD
// # endif

// # ifndef ERFKILL
// # endif

// # ifndef __ASSEMBLER__
/* Function to get address of global `errno' variable.  */
public static native IntPointer __errno_location();

// #  if !defined _LIBC || defined _LIBC_REENTRANT
/* When using threads, errno is a per-thread value.  */
public static native @MemberGetter int errno();
public static final int errno = errno();
// #  endif
// # endif /* !__ASSEMBLER__ */
// #endif /* _ERRNO_H */

// #if !defined _ERRNO_H && defined __need_Emath
/* This is ugly but the kernel header is not clean enough.  We must
   define only the values EDOM, EILSEQ and ERANGE in case __need_Emath is
   defined.  */	/* Math argument out of domain of function.  */	/* Illegal byte sequence.  */	/* Math result not representable.  */
// #endif /* !_ERRNO_H && __need_Emath */


// Parsed from errno.h

/* Copyright (C) 1991,92,93,94,95,96,97,2002 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.5 Errors	<errno.h>
 */

// #ifndef	_ERRNO_H

/* The includer defined __need_Emath if he wants only the definitions
   of EDOM and ERANGE, and not everything else.  */
// #ifndef	__need_Emath
public static final int _ERRNO_H =	1;
// # include <features.h>
// #endif

/* Get the error number constants from the system-specific file.
   This file will test __need_Emath and _ERRNO_H.  */
// #include <bits/errno.h>
// #undef	__need_Emath

// #ifdef	_ERRNO_H

/* Declare the `errno' variable, unless it's defined as a macro by
   bits/errno.h.  This is the case in GNU, where it is a per-thread
   variable.  This redeclaration using the macro still works, but it
   will be a function declaration without a prototype and may trigger
   a -Wstrict-prototypes warning.  */
// #ifndef	errno
// #endif

// #ifdef __USE_GNU

/* The full and simple forms of the name with which the program was
   invoked.  These variables are set up automatically at startup based on
   the value of ARGV[0] (this works only if you use GNU ld).  */
public static native @Cast("char*") BytePointer program_invocation_name(); public static native void program_invocation_name(BytePointer program_invocation_name);
public static native @Cast("char*") BytePointer program_invocation_short_name(); public static native void program_invocation_short_name(BytePointer program_invocation_short_name);
// #endif /* __USE_GNU */
// #endif /* _ERRNO_H */

// #endif /* _ERRNO_H */

/* The Hurd <bits/errno.h> defines `error_t' as an enumerated type so
   that printing `error_t' values in the debugger shows the names.  We
   might need this definition sometimes even if this file was included
   before.  */
// #if defined __USE_GNU || defined __need_error_t
// # ifndef __error_t_defined
public static final int __error_t_defined =	1;
// # endif
// # undef __need_error_t
// #endif


// Parsed from string.h

/* Copyright (C) 1991-1993,1995-2004,2007,2009,2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.21 String handling	<string.h>
 */

// #ifndef	_STRING_H
public static final int _STRING_H =	1;

// #include <features.h>

/* Get size_t and NULL from <stddef.h>.  */
// #define	__need_size_t
// #define	__need_NULL
// #include <stddef.h>

/* Tell the caller that we provide correct C++ prototypes.  */
// #if defined __cplusplus && __GNUC_PREREQ (4, 4)
// # define __CORRECT_ISO_CPP_STRING_H_PROTO
// #endif


/* Copy N bytes of SRC to DEST.  */
public static native Pointer memcpy(Pointer __dest,
		     @Const Pointer __src, @Cast("size_t") long __n);
/* Copy N bytes of SRC to DEST, guaranteeing
   correct behavior for overlapping strings.  */
public static native Pointer memmove(Pointer __dest, @Const Pointer __src, @Cast("size_t") long __n);
/* Copy no more than N bytes of SRC to DEST, stopping when C is found.
   Return the position in DEST one byte past where C was copied,
   or NULL if C was not found in the first N bytes of SRC.  */
// #if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN
public static native Pointer memccpy(Pointer __dest, @Const Pointer __src,
		      int __c, @Cast("size_t") long __n);
// #endif /* SVID.  */


/* Set N bytes of S to C.  */
public static native Pointer memset(Pointer __s, int __c, @Cast("size_t") long __n);

/* Compare N bytes of S1 and S2.  */
public static native int memcmp(@Const Pointer __s1, @Const Pointer __s2, @Cast("size_t") long __n);

/* Search N bytes of S for C.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
public static native Pointer memchr(Pointer __s, int __c, @Cast("size_t") long __n);

// # ifdef __OPTIMIZE__
// # endif
// #else
// #endif
// #ifdef __USE_GNU
/* Search in S for C.  This is similar to `memchr' but there is no
   length limit.  */
// # ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
public static native Pointer rawmemchr(Pointer __s, int __c);
// # else
// # endif

/* Search N bytes of S for the final occurrence of C.  */
// # ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
public static native Pointer memrchr(Pointer __s, int __c, @Cast("size_t") long __n);
// # else
// # endif
// #endif


/* Copy SRC to DEST.  */
public static native @Cast("char*") BytePointer strcpy(@Cast("char*") BytePointer __dest, @Cast("const char*") BytePointer __src);
public static native @Cast("char*") ByteBuffer strcpy(@Cast("char*") ByteBuffer __dest, String __src);
public static native @Cast("char*") byte[] strcpy(@Cast("char*") byte[] __dest, @Cast("const char*") BytePointer __src);
public static native @Cast("char*") BytePointer strcpy(@Cast("char*") BytePointer __dest, String __src);
public static native @Cast("char*") ByteBuffer strcpy(@Cast("char*") ByteBuffer __dest, @Cast("const char*") BytePointer __src);
public static native @Cast("char*") byte[] strcpy(@Cast("char*") byte[] __dest, String __src);
/* Copy no more than N characters of SRC to DEST.  */
public static native @Cast("char*") BytePointer strncpy(@Cast("char*") BytePointer __dest,
		      @Cast("const char*") BytePointer __src, @Cast("size_t") long __n);
public static native @Cast("char*") ByteBuffer strncpy(@Cast("char*") ByteBuffer __dest,
		      String __src, @Cast("size_t") long __n);
public static native @Cast("char*") byte[] strncpy(@Cast("char*") byte[] __dest,
		      @Cast("const char*") BytePointer __src, @Cast("size_t") long __n);
public static native @Cast("char*") BytePointer strncpy(@Cast("char*") BytePointer __dest,
		      String __src, @Cast("size_t") long __n);
public static native @Cast("char*") ByteBuffer strncpy(@Cast("char*") ByteBuffer __dest,
		      @Cast("const char*") BytePointer __src, @Cast("size_t") long __n);
public static native @Cast("char*") byte[] strncpy(@Cast("char*") byte[] __dest,
		      String __src, @Cast("size_t") long __n);

/* Append SRC onto DEST.  */
public static native @Cast("char*") BytePointer strcat(@Cast("char*") BytePointer __dest, @Cast("const char*") BytePointer __src);
public static native @Cast("char*") ByteBuffer strcat(@Cast("char*") ByteBuffer __dest, String __src);
public static native @Cast("char*") byte[] strcat(@Cast("char*") byte[] __dest, @Cast("const char*") BytePointer __src);
public static native @Cast("char*") BytePointer strcat(@Cast("char*") BytePointer __dest, String __src);
public static native @Cast("char*") ByteBuffer strcat(@Cast("char*") ByteBuffer __dest, @Cast("const char*") BytePointer __src);
public static native @Cast("char*") byte[] strcat(@Cast("char*") byte[] __dest, String __src);
/* Append no more than N characters from SRC onto DEST.  */
public static native @Cast("char*") BytePointer strncat(@Cast("char*") BytePointer __dest, @Cast("const char*") BytePointer __src,
		      @Cast("size_t") long __n);
public static native @Cast("char*") ByteBuffer strncat(@Cast("char*") ByteBuffer __dest, String __src,
		      @Cast("size_t") long __n);
public static native @Cast("char*") byte[] strncat(@Cast("char*") byte[] __dest, @Cast("const char*") BytePointer __src,
		      @Cast("size_t") long __n);
public static native @Cast("char*") BytePointer strncat(@Cast("char*") BytePointer __dest, String __src,
		      @Cast("size_t") long __n);
public static native @Cast("char*") ByteBuffer strncat(@Cast("char*") ByteBuffer __dest, @Cast("const char*") BytePointer __src,
		      @Cast("size_t") long __n);
public static native @Cast("char*") byte[] strncat(@Cast("char*") byte[] __dest, String __src,
		      @Cast("size_t") long __n);

/* Compare S1 and S2.  */
public static native int strcmp(@Cast("const char*") BytePointer __s1, @Cast("const char*") BytePointer __s2);
public static native int strcmp(String __s1, String __s2);
/* Compare N characters of S1 and S2.  */
public static native int strncmp(@Cast("const char*") BytePointer __s1, @Cast("const char*") BytePointer __s2, @Cast("size_t") long __n);
public static native int strncmp(String __s1, String __s2, @Cast("size_t") long __n);

/* Compare the collated forms of S1 and S2.  */
public static native int strcoll(@Cast("const char*") BytePointer __s1, @Cast("const char*") BytePointer __s2);
public static native int strcoll(String __s1, String __s2);
/* Put a transformation of SRC into no more than N bytes of DEST.  */
public static native @Cast("size_t") long strxfrm(@Cast("char*") BytePointer __dest,
		       @Cast("const char*") BytePointer __src, @Cast("size_t") long __n);
public static native @Cast("size_t") long strxfrm(@Cast("char*") ByteBuffer __dest,
		       String __src, @Cast("size_t") long __n);
public static native @Cast("size_t") long strxfrm(@Cast("char*") byte[] __dest,
		       @Cast("const char*") BytePointer __src, @Cast("size_t") long __n);
public static native @Cast("size_t") long strxfrm(@Cast("char*") BytePointer __dest,
		       String __src, @Cast("size_t") long __n);
public static native @Cast("size_t") long strxfrm(@Cast("char*") ByteBuffer __dest,
		       @Cast("const char*") BytePointer __src, @Cast("size_t") long __n);
public static native @Cast("size_t") long strxfrm(@Cast("char*") byte[] __dest,
		       String __src, @Cast("size_t") long __n);
// #ifdef __USE_XOPEN2K8
/* The following functions are equivalent to the both above but they
   take the locale they use for the collation as an extra argument.
   This is not standardsized but something like will come.  */
// # include <xlocale.h>

/* Compare the collated forms of S1 and S2 using rules from L.  */
public static native int strcoll_l(@Cast("const char*") BytePointer __s1, @Cast("const char*") BytePointer __s2, locale_t __l);
public static native int strcoll_l(String __s1, String __s2, locale_t __l);
/* Put a transformation of SRC into no more than N bytes of DEST.  */
public static native @Cast("size_t") long strxfrm_l(@Cast("char*") BytePointer __dest, @Cast("const char*") BytePointer __src, @Cast("size_t") long __n,
			 locale_t __l);
public static native @Cast("size_t") long strxfrm_l(@Cast("char*") ByteBuffer __dest, String __src, @Cast("size_t") long __n,
			 locale_t __l);
public static native @Cast("size_t") long strxfrm_l(@Cast("char*") byte[] __dest, @Cast("const char*") BytePointer __src, @Cast("size_t") long __n,
			 locale_t __l);
public static native @Cast("size_t") long strxfrm_l(@Cast("char*") BytePointer __dest, String __src, @Cast("size_t") long __n,
			 locale_t __l);
public static native @Cast("size_t") long strxfrm_l(@Cast("char*") ByteBuffer __dest, @Cast("const char*") BytePointer __src, @Cast("size_t") long __n,
			 locale_t __l);
public static native @Cast("size_t") long strxfrm_l(@Cast("char*") byte[] __dest, String __src, @Cast("size_t") long __n,
			 locale_t __l);
// #endif

// #if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN_EXTENDED
//     || defined __USE_XOPEN2K8
/* Duplicate S, returning an identical malloc'd string.  */
public static native @Cast("char*") BytePointer strdup(@Cast("const char*") BytePointer __s);
public static native @Cast("char*") ByteBuffer strdup(String __s);
// #endif

/* Return a malloc'd copy of at most N bytes of STRING.  The
   resultant string is terminated even if no null terminator
   appears before STRING[N].  */
// #if defined __USE_XOPEN2K8
public static native @Cast("char*") BytePointer strndup(@Cast("const char*") BytePointer __string, @Cast("size_t") long __n);
public static native @Cast("char*") ByteBuffer strndup(String __string, @Cast("size_t") long __n);
// #endif

// #if defined __USE_GNU && defined __GNUC__
/* Duplicate S, returning an identical alloca'd string.  */
// # define strdupa(s)
//   (__extension__
//     ({
//       __const char *__old = (s);
//       size_t __len = strlen (__old) + 1;
//       char *__new = (char *) __builtin_alloca (__len);
//       (char *) memcpy (__new, __old, __len);
//     }))

/* Return an alloca'd copy of at most N bytes of string.  */
// # define strndupa(s, n)
//   (__extension__
//     ({
//       __const char *__old = (s);
//       size_t __len = strnlen (__old, (n));
//       char *__new = (char *) __builtin_alloca (__len + 1);
//       __new[__len] = '\0';
//       (char *) memcpy (__new, __old, __len);
//     }))
// #endif

/* Find the first occurrence of C in S.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
public static native @Cast("char*") BytePointer strchr(@Cast("char*") BytePointer __s, int __c);
public static native @Cast("char*") ByteBuffer strchr(@Cast("char*") ByteBuffer __s, int __c);
public static native @Cast("char*") byte[] strchr(@Cast("char*") byte[] __s, int __c);
public static native String strchr(String __s, int __c);

// # ifdef __OPTIMIZE__
// # endif
// #else
// #endif
/* Find the last occurrence of C in S.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
public static native @Cast("char*") BytePointer strrchr(@Cast("char*") BytePointer __s, int __c);
public static native @Cast("char*") ByteBuffer strrchr(@Cast("char*") ByteBuffer __s, int __c);
public static native @Cast("char*") byte[] strrchr(@Cast("char*") byte[] __s, int __c);
public static native String strrchr(String __s, int __c);

// # ifdef __OPTIMIZE__
// # endif
// #else
// #endif
// #ifdef __USE_GNU
/* This function is similar to `strchr'.  But it returns a pointer to
   the closing NUL byte in case C is not found in S.  */
// # ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
public static native @Cast("char*") BytePointer strchrnul(@Cast("char*") BytePointer __s, int __c);
public static native @Cast("char*") ByteBuffer strchrnul(@Cast("char*") ByteBuffer __s, int __c);
public static native @Cast("char*") byte[] strchrnul(@Cast("char*") byte[] __s, int __c);
public static native String strchrnul(String __s, int __c);
// # else
// # endif
// #endif

/* Return the length of the initial segment of S which
   consists entirely of characters not in REJECT.  */
public static native @Cast("size_t") long strcspn(@Cast("const char*") BytePointer __s, @Cast("const char*") BytePointer __reject);
public static native @Cast("size_t") long strcspn(String __s, String __reject);
/* Return the length of the initial segment of S which
   consists entirely of characters in ACCEPT.  */
public static native @Cast("size_t") long strspn(@Cast("const char*") BytePointer __s, @Cast("const char*") BytePointer __accept);
public static native @Cast("size_t") long strspn(String __s, String __accept);
/* Find the first occurrence in S of any character in ACCEPT.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
public static native @Cast("char*") BytePointer strpbrk(@Cast("char*") BytePointer __s, @Cast("const char*") BytePointer __accept);
public static native @Cast("char*") ByteBuffer strpbrk(@Cast("char*") ByteBuffer __s, String __accept);
public static native @Cast("char*") byte[] strpbrk(@Cast("char*") byte[] __s, @Cast("const char*") BytePointer __accept);
public static native @Cast("char*") BytePointer strpbrk(@Cast("char*") BytePointer __s, String __accept);
public static native @Cast("char*") ByteBuffer strpbrk(@Cast("char*") ByteBuffer __s, @Cast("const char*") BytePointer __accept);
public static native @Cast("char*") byte[] strpbrk(@Cast("char*") byte[] __s, String __accept);
public static native String strpbrk(String __s, String __accept);

// # ifdef __OPTIMIZE__
// # endif
// #else
// #endif
/* Find the first occurrence of NEEDLE in HAYSTACK.  */
// #ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
public static native @Cast("char*") BytePointer strstr(@Cast("char*") BytePointer __haystack, @Cast("const char*") BytePointer __needle);
public static native @Cast("char*") ByteBuffer strstr(@Cast("char*") ByteBuffer __haystack, String __needle);
public static native @Cast("char*") byte[] strstr(@Cast("char*") byte[] __haystack, @Cast("const char*") BytePointer __needle);
public static native @Cast("char*") BytePointer strstr(@Cast("char*") BytePointer __haystack, String __needle);
public static native @Cast("char*") ByteBuffer strstr(@Cast("char*") ByteBuffer __haystack, @Cast("const char*") BytePointer __needle);
public static native @Cast("char*") byte[] strstr(@Cast("char*") byte[] __haystack, String __needle);
public static native String strstr(String __haystack,
			     String __needle);

// # ifdef __OPTIMIZE__
// # endif
// #else
// #endif


/* Divide S into tokens separated by characters in DELIM.  */
public static native @Cast("char*") BytePointer strtok(@Cast("char*") BytePointer __s, @Cast("const char*") BytePointer __delim);
public static native @Cast("char*") ByteBuffer strtok(@Cast("char*") ByteBuffer __s, String __delim);
public static native @Cast("char*") byte[] strtok(@Cast("char*") byte[] __s, @Cast("const char*") BytePointer __delim);
public static native @Cast("char*") BytePointer strtok(@Cast("char*") BytePointer __s, String __delim);
public static native @Cast("char*") ByteBuffer strtok(@Cast("char*") ByteBuffer __s, @Cast("const char*") BytePointer __delim);
public static native @Cast("char*") byte[] strtok(@Cast("char*") byte[] __s, String __delim);
/* Divide S into tokens separated by characters in DELIM.  Information
   passed between calls are stored in SAVE_PTR.  */
public static native @Cast("char*") BytePointer __strtok_r(@Cast("char*") BytePointer __s,
			 @Cast("const char*") BytePointer __delim,
			 @Cast("char**") PointerPointer __save_ptr);
public static native @Cast("char*") BytePointer __strtok_r(@Cast("char*") BytePointer __s,
			 @Cast("const char*") BytePointer __delim,
			 @Cast("char**") @ByPtrPtr BytePointer __save_ptr);
public static native @Cast("char*") ByteBuffer __strtok_r(@Cast("char*") ByteBuffer __s,
			 String __delim,
			 @Cast("char**") @ByPtrPtr ByteBuffer __save_ptr);
public static native @Cast("char*") byte[] __strtok_r(@Cast("char*") byte[] __s,
			 @Cast("const char*") BytePointer __delim,
			 @Cast("char**") @ByPtrPtr byte[] __save_ptr);
public static native @Cast("char*") BytePointer __strtok_r(@Cast("char*") BytePointer __s,
			 String __delim,
			 @Cast("char**") @ByPtrPtr BytePointer __save_ptr);
public static native @Cast("char*") ByteBuffer __strtok_r(@Cast("char*") ByteBuffer __s,
			 @Cast("const char*") BytePointer __delim,
			 @Cast("char**") @ByPtrPtr ByteBuffer __save_ptr);
public static native @Cast("char*") byte[] __strtok_r(@Cast("char*") byte[] __s,
			 String __delim,
			 @Cast("char**") @ByPtrPtr byte[] __save_ptr);
// #if defined __USE_POSIX || defined __USE_MISC
public static native @Cast("char*") BytePointer strtok_r(@Cast("char*") BytePointer __s, @Cast("const char*") BytePointer __delim,
		       @Cast("char**") PointerPointer __save_ptr);
public static native @Cast("char*") BytePointer strtok_r(@Cast("char*") BytePointer __s, @Cast("const char*") BytePointer __delim,
		       @Cast("char**") @ByPtrPtr BytePointer __save_ptr);
public static native @Cast("char*") ByteBuffer strtok_r(@Cast("char*") ByteBuffer __s, String __delim,
		       @Cast("char**") @ByPtrPtr ByteBuffer __save_ptr);
public static native @Cast("char*") byte[] strtok_r(@Cast("char*") byte[] __s, @Cast("const char*") BytePointer __delim,
		       @Cast("char**") @ByPtrPtr byte[] __save_ptr);
public static native @Cast("char*") BytePointer strtok_r(@Cast("char*") BytePointer __s, String __delim,
		       @Cast("char**") @ByPtrPtr BytePointer __save_ptr);
public static native @Cast("char*") ByteBuffer strtok_r(@Cast("char*") ByteBuffer __s, @Cast("const char*") BytePointer __delim,
		       @Cast("char**") @ByPtrPtr ByteBuffer __save_ptr);
public static native @Cast("char*") byte[] strtok_r(@Cast("char*") byte[] __s, String __delim,
		       @Cast("char**") @ByPtrPtr byte[] __save_ptr);
// #endif

// #ifdef __USE_GNU
/* Similar to `strstr' but this function ignores the case of both strings.  */
// # ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
public static native @Cast("char*") BytePointer strcasestr(@Cast("char*") BytePointer __haystack, @Cast("const char*") BytePointer __needle);
public static native @Cast("char*") ByteBuffer strcasestr(@Cast("char*") ByteBuffer __haystack, String __needle);
public static native @Cast("char*") byte[] strcasestr(@Cast("char*") byte[] __haystack, @Cast("const char*") BytePointer __needle);
public static native @Cast("char*") BytePointer strcasestr(@Cast("char*") BytePointer __haystack, String __needle);
public static native @Cast("char*") ByteBuffer strcasestr(@Cast("char*") ByteBuffer __haystack, @Cast("const char*") BytePointer __needle);
public static native @Cast("char*") byte[] strcasestr(@Cast("char*") byte[] __haystack, String __needle);
public static native String strcasestr(String __haystack,
				       String __needle);
// # else
// # endif
// #endif

// #ifdef __USE_GNU
/* Find the first occurrence of NEEDLE in HAYSTACK.
   NEEDLE is NEEDLELEN bytes long;
   HAYSTACK is HAYSTACKLEN bytes long.  */
public static native Pointer memmem(@Const Pointer __haystack, @Cast("size_t") long __haystacklen,
		     @Const Pointer __needle, @Cast("size_t") long __needlelen);

/* Copy N bytes of SRC to DEST, return pointer to bytes after the
   last written byte.  */
public static native Pointer __mempcpy(Pointer __dest,
			@Const Pointer __src, @Cast("size_t") long __n);
public static native Pointer mempcpy(Pointer __dest,
		      @Const Pointer __src, @Cast("size_t") long __n);
// #endif


/* Return the length of S.  */
public static native @Cast("size_t") long strlen(@Cast("const char*") BytePointer __s);
public static native @Cast("size_t") long strlen(String __s);
// #ifdef	__USE_XOPEN2K8
/* Find the length of STRING, but scan at most MAXLEN characters.
   If no '\0' terminator is found in that many characters, return MAXLEN.  */
public static native @Cast("size_t") long strnlen(@Cast("const char*") BytePointer __string, @Cast("size_t") long __maxlen);
public static native @Cast("size_t") long strnlen(String __string, @Cast("size_t") long __maxlen);
// #endif


/* Return a string describing the meaning of the `errno' code in ERRNUM.  */
public static native @Cast("char*") BytePointer strerror(int __errnum);
// #if defined __USE_XOPEN2K || defined __USE_MISC
/* Reentrant version of `strerror'.
   There are 2 flavors of `strerror_r', GNU which returns the string
   and may or may not use the supplied temporary buffer and POSIX one
   which fills the string into the buffer.
   To use the POSIX version, -D_XOPEN_SOURCE=600 or -D_POSIX_C_SOURCE=200112L
   without -D_GNU_SOURCE is needed, otherwise the GNU version is
   preferred.  */
// # if defined __USE_XOPEN2K && !defined __USE_GNU
// # else
/* If a temporary buffer is required, at most BUFLEN bytes of BUF will be
   used.  */
public static native @Cast("char*") BytePointer strerror_r(int __errnum, @Cast("char*") BytePointer __buf, @Cast("size_t") long __buflen);
public static native @Cast("char*") ByteBuffer strerror_r(int __errnum, @Cast("char*") ByteBuffer __buf, @Cast("size_t") long __buflen);
public static native @Cast("char*") byte[] strerror_r(int __errnum, @Cast("char*") byte[] __buf, @Cast("size_t") long __buflen);
// # endif
// #endif

// #ifdef __USE_XOPEN2K8
/* Translate error number to string according to the locale L.  */
public static native @Cast("char*") BytePointer strerror_l(int __errnum, locale_t __l);
// #endif


/* We define this function always since `bzero' is sometimes needed when
   the namespace rules does not allow this.  */
public static native void __bzero(Pointer __s, @Cast("size_t") long __n);

// #ifdef __USE_BSD
/* Copy N bytes of SRC to DEST (like memmove, but args reversed).  */
public static native void bcopy(@Const Pointer __src, Pointer __dest, @Cast("size_t") long __n);

/* Set N bytes of S to 0.  */
public static native void bzero(Pointer __s, @Cast("size_t") long __n);

/* Compare N bytes of S1 and S2 (same as memcmp).  */
public static native int bcmp(@Const Pointer __s1, @Const Pointer __s2, @Cast("size_t") long __n);

/* Find the first occurrence of C in S (same as strchr).  */
// # ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
public static native @Cast("char*") BytePointer index(@Cast("char*") BytePointer __s, int __c);
public static native @Cast("char*") ByteBuffer index(@Cast("char*") ByteBuffer __s, int __c);
public static native @Cast("char*") byte[] index(@Cast("char*") byte[] __s, int __c);
public static native String index(String __s, int __c);

// #  if defined __OPTIMIZE__ && !defined __CORRECT_ISO_CPP_STRINGS_H_PROTO
// #  endif
// # else
// # endif

/* Find the last occurrence of C in S (same as strrchr).  */
// # ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
public static native @Cast("char*") BytePointer rindex(@Cast("char*") BytePointer __s, int __c);
public static native @Cast("char*") ByteBuffer rindex(@Cast("char*") ByteBuffer __s, int __c);
public static native @Cast("char*") byte[] rindex(@Cast("char*") byte[] __s, int __c);
public static native String rindex(String __s, int __c);

// #  if defined __OPTIMIZE__ && !defined __CORRECT_ISO_CPP_STRINGS_H_PROTO
// #endif
// # else
// # endif

/* Return the position of the first bit set in I, or 0 if none are set.
   The least-significant bit is position 1, the most-significant 32.  */
public static native int ffs(int __i);

/* The following two functions are non-standard but necessary for non-32 bit
   platforms.  */
// # ifdef	__USE_GNU
public static native int ffsl(long __l);
// #  ifdef __GNUC__
public static native int ffsll(long __ll);
// #  endif
// # endif

/* Compare S1 and S2, ignoring case.  */
public static native int strcasecmp(@Cast("const char*") BytePointer __s1, @Cast("const char*") BytePointer __s2);
public static native int strcasecmp(String __s1, String __s2);

/* Compare no more than N chars of S1 and S2, ignoring case.  */
public static native int strncasecmp(@Cast("const char*") BytePointer __s1, @Cast("const char*") BytePointer __s2, @Cast("size_t") long __n);
public static native int strncasecmp(String __s1, String __s2, @Cast("size_t") long __n);
// #endif /* Use BSD.  */

// #ifdef	__USE_GNU
/* Again versions of a few functions which use the given locale instead
   of the global one.  */
public static native int strcasecmp_l(@Cast("const char*") BytePointer __s1, @Cast("const char*") BytePointer __s2,
			 locale_t __loc);
public static native int strcasecmp_l(String __s1, String __s2,
			 locale_t __loc);

public static native int strncasecmp_l(@Cast("const char*") BytePointer __s1, @Cast("const char*") BytePointer __s2,
			  @Cast("size_t") long __n, locale_t __loc);
public static native int strncasecmp_l(String __s1, String __s2,
			  @Cast("size_t") long __n, locale_t __loc);
// #endif

// #ifdef	__USE_BSD
/* Return the next DELIM-delimited token from *STRINGP,
   terminating it with a '\0', and update *STRINGP to point past it.  */
public static native @Cast("char*") BytePointer strsep(@Cast("char**") PointerPointer __stringp,
		     @Cast("const char*") BytePointer __delim);
public static native @Cast("char*") BytePointer strsep(@Cast("char**") @ByPtrPtr BytePointer __stringp,
		     @Cast("const char*") BytePointer __delim);
public static native @Cast("char*") ByteBuffer strsep(@Cast("char**") @ByPtrPtr ByteBuffer __stringp,
		     String __delim);
public static native @Cast("char*") byte[] strsep(@Cast("char**") @ByPtrPtr byte[] __stringp,
		     @Cast("const char*") BytePointer __delim);
public static native @Cast("char*") BytePointer strsep(@Cast("char**") @ByPtrPtr BytePointer __stringp,
		     String __delim);
public static native @Cast("char*") ByteBuffer strsep(@Cast("char**") @ByPtrPtr ByteBuffer __stringp,
		     @Cast("const char*") BytePointer __delim);
public static native @Cast("char*") byte[] strsep(@Cast("char**") @ByPtrPtr byte[] __stringp,
		     String __delim);
// #endif

// #ifdef	__USE_XOPEN2K8
/* Return a string describing the meaning of the signal number in SIG.  */
public static native @Cast("char*") BytePointer strsignal(int __sig);

/* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  */
public static native @Cast("char*") BytePointer __stpcpy(@Cast("char*") BytePointer __dest, @Cast("const char*") BytePointer __src);
public static native @Cast("char*") ByteBuffer __stpcpy(@Cast("char*") ByteBuffer __dest, String __src);
public static native @Cast("char*") byte[] __stpcpy(@Cast("char*") byte[] __dest, @Cast("const char*") BytePointer __src);
public static native @Cast("char*") BytePointer __stpcpy(@Cast("char*") BytePointer __dest, String __src);
public static native @Cast("char*") ByteBuffer __stpcpy(@Cast("char*") ByteBuffer __dest, @Cast("const char*") BytePointer __src);
public static native @Cast("char*") byte[] __stpcpy(@Cast("char*") byte[] __dest, String __src);
public static native @Cast("char*") BytePointer stpcpy(@Cast("char*") BytePointer __dest, @Cast("const char*") BytePointer __src);
public static native @Cast("char*") ByteBuffer stpcpy(@Cast("char*") ByteBuffer __dest, String __src);
public static native @Cast("char*") byte[] stpcpy(@Cast("char*") byte[] __dest, @Cast("const char*") BytePointer __src);
public static native @Cast("char*") BytePointer stpcpy(@Cast("char*") BytePointer __dest, String __src);
public static native @Cast("char*") ByteBuffer stpcpy(@Cast("char*") ByteBuffer __dest, @Cast("const char*") BytePointer __src);
public static native @Cast("char*") byte[] stpcpy(@Cast("char*") byte[] __dest, String __src);

/* Copy no more than N characters of SRC to DEST, returning the address of
   the last character written into DEST.  */
public static native @Cast("char*") BytePointer __stpncpy(@Cast("char*") BytePointer __dest,
			@Cast("const char*") BytePointer __src, @Cast("size_t") long __n);
public static native @Cast("char*") ByteBuffer __stpncpy(@Cast("char*") ByteBuffer __dest,
			String __src, @Cast("size_t") long __n);
public static native @Cast("char*") byte[] __stpncpy(@Cast("char*") byte[] __dest,
			@Cast("const char*") BytePointer __src, @Cast("size_t") long __n);
public static native @Cast("char*") BytePointer __stpncpy(@Cast("char*") BytePointer __dest,
			String __src, @Cast("size_t") long __n);
public static native @Cast("char*") ByteBuffer __stpncpy(@Cast("char*") ByteBuffer __dest,
			@Cast("const char*") BytePointer __src, @Cast("size_t") long __n);
public static native @Cast("char*") byte[] __stpncpy(@Cast("char*") byte[] __dest,
			String __src, @Cast("size_t") long __n);
public static native @Cast("char*") BytePointer stpncpy(@Cast("char*") BytePointer __dest,
		      @Cast("const char*") BytePointer __src, @Cast("size_t") long __n);
public static native @Cast("char*") ByteBuffer stpncpy(@Cast("char*") ByteBuffer __dest,
		      String __src, @Cast("size_t") long __n);
public static native @Cast("char*") byte[] stpncpy(@Cast("char*") byte[] __dest,
		      @Cast("const char*") BytePointer __src, @Cast("size_t") long __n);
public static native @Cast("char*") BytePointer stpncpy(@Cast("char*") BytePointer __dest,
		      String __src, @Cast("size_t") long __n);
public static native @Cast("char*") ByteBuffer stpncpy(@Cast("char*") ByteBuffer __dest,
		      @Cast("const char*") BytePointer __src, @Cast("size_t") long __n);
public static native @Cast("char*") byte[] stpncpy(@Cast("char*") byte[] __dest,
		      String __src, @Cast("size_t") long __n);
// #endif

// #ifdef	__USE_GNU
/* Compare S1 and S2 as strings holding name & indices/version numbers.  */
public static native int strverscmp(@Cast("const char*") BytePointer __s1, @Cast("const char*") BytePointer __s2);
public static native int strverscmp(String __s1, String __s2);

/* Sautee STRING briskly.  */
public static native @Cast("char*") BytePointer strfry(@Cast("char*") BytePointer __string);
public static native @Cast("char*") ByteBuffer strfry(@Cast("char*") ByteBuffer __string);
public static native @Cast("char*") byte[] strfry(@Cast("char*") byte[] __string);

/* Frobnicate N bytes of S.  */
public static native Pointer memfrob(Pointer __s, @Cast("size_t") long __n);

// # ifndef basename
/* Return the file name within directory of FILENAME.  We don't
   declare the function if the `basename' macro is available (defined
   in <libgen.h>) which makes the XPG version of this function
   available.  */
// #  ifdef __CORRECT_ISO_CPP_STRING_H_PROTO
public static native @Cast("char*") BytePointer basename(@Cast("char*") BytePointer __filename);
public static native @Cast("char*") ByteBuffer basename(@Cast("char*") ByteBuffer __filename);
public static native @Cast("char*") byte[] basename(@Cast("char*") byte[] __filename);
public static native String basename(String __filename);
// #  else
// #  endif
// # endif
// #endif


// #if defined __GNUC__ && __GNUC__ >= 2
// # if defined __OPTIMIZE__ && !defined __OPTIMIZE_SIZE__
//      && !defined __NO_INLINE__ && !defined __cplusplus
/* When using GNU CC we provide some optimized versions of selected
   functions from this header.  There are two kinds of optimizations:

   - machine-dependent optimizations, most probably using inline
     assembler code; these might be quite expensive since the code
     size can increase significantly.
     These optimizations are not used unless the symbol
	__USE_STRING_INLINES
     is defined before including this header.

   - machine-independent optimizations which do not increase the
     code size significantly and which optimize mainly situations
     where one or more arguments are compile-time constants.
     These optimizations are used always when the compiler is
     taught to optimize.

   One can inhibit all optimizations by defining __NO_STRING_INLINES.  */

/* Get the machine-dependent optimizations (if any).  */
// #  include <bits/string.h>

/* These are generic optimizations which do not add too much inline code.  */
// #  include <bits/string2.h>
// # endif

// # if __USE_FORTIFY_LEVEL > 0 && defined __extern_always_inline
/* Functions with security checks.  */
// #  include <bits/string3.h>
// # endif
// #endif

// #endif /* string.h  */


// Parsed from stdlib.h

/* Copyright (C) 1991-2007, 2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.20 General utilities	<stdlib.h>
 */

// #ifndef	_STDLIB_H

// #include <features.h>

/* Get size_t, wchar_t and NULL from <stddef.h>.  */
// #define		__need_size_t
// #ifndef __need_malloc_and_calloc
// # define	__need_wchar_t
// # define	__need_NULL
// #endif
// #include <stddef.h>

// #ifndef __need_malloc_and_calloc
public static final int _STDLIB_H =	1;

// #if (defined __USE_XOPEN || defined __USE_XOPEN2K8) && !defined _SYS_WAIT_H
/* XPG requires a few symbols from <sys/wait.h> being defined.  */
// # include <bits/waitflags.h>
// # include <bits/waitstatus.h>

// # ifdef __USE_BSD

/* Lots of hair to allow traditional BSD use of `union wait'
   as well as POSIX.1 use of `int' for the status word.  */

// #  if defined __GNUC__ && !defined __cplusplus
// #   define __WAIT_INT(status)
//   (__extension__ (((union { __typeof(status) __in; int __i; })
// 		   { .__in = (status) }).__i))
// #  else
// #   define __WAIT_INT(status)	(*(int *) &(status))
// #  endif

/* This is the type of the argument to `wait'.  The funky union
   causes redeclarations with either `int *' or `union wait *' to be
   allowed without complaint.  __WAIT_STATUS_DEFN is the type used in
   the actual function definitions.  */

// #  if !defined __GNUC__ || __GNUC__ < 2 || defined __cplusplus
// #   define __WAIT_STATUS	void *
// #   define __WAIT_STATUS_DEFN	void *
// #  else
// #  endif

// # else /* Don't use BSD.  */

// # endif /* Use BSD.  */

/* Define the macros <sys/wait.h> also would define this way.  */
// # define WEXITSTATUS(status)	__WEXITSTATUS (__WAIT_INT (status))
// # define WTERMSIG(status)	__WTERMSIG (__WAIT_INT (status))
// # define WSTOPSIG(status)	__WSTOPSIG (__WAIT_INT (status))
// # define WIFEXITED(status)	__WIFEXITED (__WAIT_INT (status))
// # define WIFSIGNALED(status)	__WIFSIGNALED (__WAIT_INT (status))
// # define WIFSTOPPED(status)	__WIFSTOPPED (__WAIT_INT (status))
// # ifdef __WIFCONTINUED
// #  define WIFCONTINUED(status)	__WIFCONTINUED (__WAIT_INT (status))
// Targeting ../linux/div_t.java


// Targeting ../linux/ldiv_t.java


public static final int __ldiv_t_defined =	1;
// Targeting ../linux/lldiv_t.java


public static final int __lldiv_t_defined =	1;
// #endif


/* The largest number rand will return (same as INT_MAX).  */
public static final int RAND_MAX =	2147483647;


/* We define these the same for all machines.
   Changes from this to the outside world should be done in `_exit'.  */
public static final int EXIT_FAILURE =	1;	/* Failing exit status.  */
public static final int EXIT_SUCCESS =	0;	/* Successful exit status.  */


/* Maximum length of a multibyte character in the current locale.  */
public static native @MemberGetter int MB_CUR_MAX();
public static final int MB_CUR_MAX = MB_CUR_MAX();
public static native @Cast("size_t") long __ctype_get_mb_cur_max();


/* Convert a string to a floating-point number.  */
public static native double atof(@Cast("const char*") BytePointer __nptr);
public static native double atof(String __nptr);
/* Convert a string to an integer.  */
public static native int atoi(@Cast("const char*") BytePointer __nptr);
public static native int atoi(String __nptr);
/* Convert a string to a long integer.  */
public static native long atol(@Cast("const char*") BytePointer __nptr);
public static native long atol(String __nptr);
// #if defined __USE_ISOC99 || (defined __GLIBC_HAVE_LONG_LONG && defined __USE_MISC)
/* Convert a string to a long long integer.  */
public static native long atoll(@Cast("const char*") BytePointer __nptr);
public static native long atoll(String __nptr);
// #endif

/* Convert a string to a floating-point number.  */
public static native double strtod(@Cast("const char*") BytePointer __nptr,
		      @Cast("char**") PointerPointer __endptr);
public static native double strtod(@Cast("const char*") BytePointer __nptr,
		      @Cast("char**") @ByPtrPtr BytePointer __endptr);
public static native double strtod(String __nptr,
		      @Cast("char**") @ByPtrPtr ByteBuffer __endptr);
public static native double strtod(@Cast("const char*") BytePointer __nptr,
		      @Cast("char**") @ByPtrPtr byte[] __endptr);
public static native double strtod(String __nptr,
		      @Cast("char**") @ByPtrPtr BytePointer __endptr);
public static native double strtod(@Cast("const char*") BytePointer __nptr,
		      @Cast("char**") @ByPtrPtr ByteBuffer __endptr);
public static native double strtod(String __nptr,
		      @Cast("char**") @ByPtrPtr byte[] __endptr);
// #ifdef	__USE_ISOC99
/* Likewise for `float' and `long double' sizes of floating-point numbers.  */
public static native float strtof(@Cast("const char*") BytePointer __nptr,
		     @Cast("char**") PointerPointer __endptr);
public static native float strtof(@Cast("const char*") BytePointer __nptr,
		     @Cast("char**") @ByPtrPtr BytePointer __endptr);
public static native float strtof(String __nptr,
		     @Cast("char**") @ByPtrPtr ByteBuffer __endptr);
public static native float strtof(@Cast("const char*") BytePointer __nptr,
		     @Cast("char**") @ByPtrPtr byte[] __endptr);
public static native float strtof(String __nptr,
		     @Cast("char**") @ByPtrPtr BytePointer __endptr);
public static native float strtof(@Cast("const char*") BytePointer __nptr,
		     @Cast("char**") @ByPtrPtr ByteBuffer __endptr);
public static native float strtof(String __nptr,
		     @Cast("char**") @ByPtrPtr byte[] __endptr);

public static native @Cast("long double") double strtold(@Cast("const char*") BytePointer __nptr,
			    @Cast("char**") PointerPointer __endptr);
public static native @Cast("long double") double strtold(@Cast("const char*") BytePointer __nptr,
			    @Cast("char**") @ByPtrPtr BytePointer __endptr);
public static native @Cast("long double") double strtold(String __nptr,
			    @Cast("char**") @ByPtrPtr ByteBuffer __endptr);
public static native @Cast("long double") double strtold(@Cast("const char*") BytePointer __nptr,
			    @Cast("char**") @ByPtrPtr byte[] __endptr);
public static native @Cast("long double") double strtold(String __nptr,
			    @Cast("char**") @ByPtrPtr BytePointer __endptr);
public static native @Cast("long double") double strtold(@Cast("const char*") BytePointer __nptr,
			    @Cast("char**") @ByPtrPtr ByteBuffer __endptr);
public static native @Cast("long double") double strtold(String __nptr,
			    @Cast("char**") @ByPtrPtr byte[] __endptr);
// #endif

/* Convert a string to a long integer.  */
public static native long strtol(@Cast("const char*") BytePointer __nptr,
			@Cast("char**") PointerPointer __endptr, int __base);
public static native long strtol(@Cast("const char*") BytePointer __nptr,
			@Cast("char**") @ByPtrPtr BytePointer __endptr, int __base);
public static native long strtol(String __nptr,
			@Cast("char**") @ByPtrPtr ByteBuffer __endptr, int __base);
public static native long strtol(@Cast("const char*") BytePointer __nptr,
			@Cast("char**") @ByPtrPtr byte[] __endptr, int __base);
public static native long strtol(String __nptr,
			@Cast("char**") @ByPtrPtr BytePointer __endptr, int __base);
public static native long strtol(@Cast("const char*") BytePointer __nptr,
			@Cast("char**") @ByPtrPtr ByteBuffer __endptr, int __base);
public static native long strtol(String __nptr,
			@Cast("char**") @ByPtrPtr byte[] __endptr, int __base);
/* Convert a string to an unsigned long integer.  */
public static native @Cast("unsigned long int") long strtoul(@Cast("const char*") BytePointer __nptr,
				  @Cast("char**") PointerPointer __endptr, int __base);
public static native @Cast("unsigned long int") long strtoul(@Cast("const char*") BytePointer __nptr,
				  @Cast("char**") @ByPtrPtr BytePointer __endptr, int __base);
public static native @Cast("unsigned long int") long strtoul(String __nptr,
				  @Cast("char**") @ByPtrPtr ByteBuffer __endptr, int __base);
public static native @Cast("unsigned long int") long strtoul(@Cast("const char*") BytePointer __nptr,
				  @Cast("char**") @ByPtrPtr byte[] __endptr, int __base);
public static native @Cast("unsigned long int") long strtoul(String __nptr,
				  @Cast("char**") @ByPtrPtr BytePointer __endptr, int __base);
public static native @Cast("unsigned long int") long strtoul(@Cast("const char*") BytePointer __nptr,
				  @Cast("char**") @ByPtrPtr ByteBuffer __endptr, int __base);
public static native @Cast("unsigned long int") long strtoul(String __nptr,
				  @Cast("char**") @ByPtrPtr byte[] __endptr, int __base);
// #if defined __GLIBC_HAVE_LONG_LONG && defined __USE_BSD
/* Convert a string to a quadword integer.  */
public static native long strtoq(@Cast("const char*") BytePointer __nptr,
			     @Cast("char**") PointerPointer __endptr, int __base);
public static native long strtoq(@Cast("const char*") BytePointer __nptr,
			     @Cast("char**") @ByPtrPtr BytePointer __endptr, int __base);
public static native long strtoq(String __nptr,
			     @Cast("char**") @ByPtrPtr ByteBuffer __endptr, int __base);
public static native long strtoq(@Cast("const char*") BytePointer __nptr,
			     @Cast("char**") @ByPtrPtr byte[] __endptr, int __base);
public static native long strtoq(String __nptr,
			     @Cast("char**") @ByPtrPtr BytePointer __endptr, int __base);
public static native long strtoq(@Cast("const char*") BytePointer __nptr,
			     @Cast("char**") @ByPtrPtr ByteBuffer __endptr, int __base);
public static native long strtoq(String __nptr,
			     @Cast("char**") @ByPtrPtr byte[] __endptr, int __base);
/* Convert a string to an unsigned quadword integer.  */
public static native @Cast("unsigned long long int") long strtouq(@Cast("const char*") BytePointer __nptr,
				       @Cast("char**") PointerPointer __endptr, int __base);
public static native @Cast("unsigned long long int") long strtouq(@Cast("const char*") BytePointer __nptr,
				       @Cast("char**") @ByPtrPtr BytePointer __endptr, int __base);
public static native @Cast("unsigned long long int") long strtouq(String __nptr,
				       @Cast("char**") @ByPtrPtr ByteBuffer __endptr, int __base);
public static native @Cast("unsigned long long int") long strtouq(@Cast("const char*") BytePointer __nptr,
				       @Cast("char**") @ByPtrPtr byte[] __endptr, int __base);
public static native @Cast("unsigned long long int") long strtouq(String __nptr,
				       @Cast("char**") @ByPtrPtr BytePointer __endptr, int __base);
public static native @Cast("unsigned long long int") long strtouq(@Cast("const char*") BytePointer __nptr,
				       @Cast("char**") @ByPtrPtr ByteBuffer __endptr, int __base);
public static native @Cast("unsigned long long int") long strtouq(String __nptr,
				       @Cast("char**") @ByPtrPtr byte[] __endptr, int __base);
// #endif /* GCC and use BSD.  */

// #if defined __USE_ISOC99 || (defined __GLIBC_HAVE_LONG_LONG && defined __USE_MISC)
/* Convert a string to a quadword integer.  */
public static native long strtoll(@Cast("const char*") BytePointer __nptr,
			      @Cast("char**") PointerPointer __endptr, int __base);
public static native long strtoll(@Cast("const char*") BytePointer __nptr,
			      @Cast("char**") @ByPtrPtr BytePointer __endptr, int __base);
public static native long strtoll(String __nptr,
			      @Cast("char**") @ByPtrPtr ByteBuffer __endptr, int __base);
public static native long strtoll(@Cast("const char*") BytePointer __nptr,
			      @Cast("char**") @ByPtrPtr byte[] __endptr, int __base);
public static native long strtoll(String __nptr,
			      @Cast("char**") @ByPtrPtr BytePointer __endptr, int __base);
public static native long strtoll(@Cast("const char*") BytePointer __nptr,
			      @Cast("char**") @ByPtrPtr ByteBuffer __endptr, int __base);
public static native long strtoll(String __nptr,
			      @Cast("char**") @ByPtrPtr byte[] __endptr, int __base);
/* Convert a string to an unsigned quadword integer.  */
public static native @Cast("unsigned long long int") long strtoull(@Cast("const char*") BytePointer __nptr,
					@Cast("char**") PointerPointer __endptr, int __base);
public static native @Cast("unsigned long long int") long strtoull(@Cast("const char*") BytePointer __nptr,
					@Cast("char**") @ByPtrPtr BytePointer __endptr, int __base);
public static native @Cast("unsigned long long int") long strtoull(String __nptr,
					@Cast("char**") @ByPtrPtr ByteBuffer __endptr, int __base);
public static native @Cast("unsigned long long int") long strtoull(@Cast("const char*") BytePointer __nptr,
					@Cast("char**") @ByPtrPtr byte[] __endptr, int __base);
public static native @Cast("unsigned long long int") long strtoull(String __nptr,
					@Cast("char**") @ByPtrPtr BytePointer __endptr, int __base);
public static native @Cast("unsigned long long int") long strtoull(@Cast("const char*") BytePointer __nptr,
					@Cast("char**") @ByPtrPtr ByteBuffer __endptr, int __base);
public static native @Cast("unsigned long long int") long strtoull(String __nptr,
					@Cast("char**") @ByPtrPtr byte[] __endptr, int __base);
// #endif /* ISO C99 or GCC and use MISC.  */


// #ifdef __USE_GNU
/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another problem is
   the implementation of the internationalization handling in the
   ISO C++ standard library.  To support this another set of
   the functions using locale data exist which take an additional
   argument.

   Attention: even though several *_l interfaces are part of POSIX:2008,
   these are not.  */

/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  */
// # include <xlocale.h>

/* Special versions of the functions above which take the locale to
   use as an additional parameter.  */
public static native long strtol_l(@Cast("const char*") BytePointer __nptr,
			  @Cast("char**") PointerPointer __endptr, int __base,
			  locale_t __loc);
public static native long strtol_l(@Cast("const char*") BytePointer __nptr,
			  @Cast("char**") @ByPtrPtr BytePointer __endptr, int __base,
			  locale_t __loc);
public static native long strtol_l(String __nptr,
			  @Cast("char**") @ByPtrPtr ByteBuffer __endptr, int __base,
			  locale_t __loc);
public static native long strtol_l(@Cast("const char*") BytePointer __nptr,
			  @Cast("char**") @ByPtrPtr byte[] __endptr, int __base,
			  locale_t __loc);
public static native long strtol_l(String __nptr,
			  @Cast("char**") @ByPtrPtr BytePointer __endptr, int __base,
			  locale_t __loc);
public static native long strtol_l(@Cast("const char*") BytePointer __nptr,
			  @Cast("char**") @ByPtrPtr ByteBuffer __endptr, int __base,
			  locale_t __loc);
public static native long strtol_l(String __nptr,
			  @Cast("char**") @ByPtrPtr byte[] __endptr, int __base,
			  locale_t __loc);

public static native @Cast("unsigned long int") long strtoul_l(@Cast("const char*") BytePointer __nptr,
				    @Cast("char**") PointerPointer __endptr,
				    int __base, locale_t __loc);
public static native @Cast("unsigned long int") long strtoul_l(@Cast("const char*") BytePointer __nptr,
				    @Cast("char**") @ByPtrPtr BytePointer __endptr,
				    int __base, locale_t __loc);
public static native @Cast("unsigned long int") long strtoul_l(String __nptr,
				    @Cast("char**") @ByPtrPtr ByteBuffer __endptr,
				    int __base, locale_t __loc);
public static native @Cast("unsigned long int") long strtoul_l(@Cast("const char*") BytePointer __nptr,
				    @Cast("char**") @ByPtrPtr byte[] __endptr,
				    int __base, locale_t __loc);
public static native @Cast("unsigned long int") long strtoul_l(String __nptr,
				    @Cast("char**") @ByPtrPtr BytePointer __endptr,
				    int __base, locale_t __loc);
public static native @Cast("unsigned long int") long strtoul_l(@Cast("const char*") BytePointer __nptr,
				    @Cast("char**") @ByPtrPtr ByteBuffer __endptr,
				    int __base, locale_t __loc);
public static native @Cast("unsigned long int") long strtoul_l(String __nptr,
				    @Cast("char**") @ByPtrPtr byte[] __endptr,
				    int __base, locale_t __loc);

public static native long strtoll_l(@Cast("const char*") BytePointer __nptr,
				@Cast("char**") PointerPointer __endptr, int __base,
				locale_t __loc);
public static native long strtoll_l(@Cast("const char*") BytePointer __nptr,
				@Cast("char**") @ByPtrPtr BytePointer __endptr, int __base,
				locale_t __loc);
public static native long strtoll_l(String __nptr,
				@Cast("char**") @ByPtrPtr ByteBuffer __endptr, int __base,
				locale_t __loc);
public static native long strtoll_l(@Cast("const char*") BytePointer __nptr,
				@Cast("char**") @ByPtrPtr byte[] __endptr, int __base,
				locale_t __loc);
public static native long strtoll_l(String __nptr,
				@Cast("char**") @ByPtrPtr BytePointer __endptr, int __base,
				locale_t __loc);
public static native long strtoll_l(@Cast("const char*") BytePointer __nptr,
				@Cast("char**") @ByPtrPtr ByteBuffer __endptr, int __base,
				locale_t __loc);
public static native long strtoll_l(String __nptr,
				@Cast("char**") @ByPtrPtr byte[] __endptr, int __base,
				locale_t __loc);

public static native @Cast("unsigned long long int") long strtoull_l(@Cast("const char*") BytePointer __nptr,
					  @Cast("char**") PointerPointer __endptr,
					  int __base, locale_t __loc);
public static native @Cast("unsigned long long int") long strtoull_l(@Cast("const char*") BytePointer __nptr,
					  @Cast("char**") @ByPtrPtr BytePointer __endptr,
					  int __base, locale_t __loc);
public static native @Cast("unsigned long long int") long strtoull_l(String __nptr,
					  @Cast("char**") @ByPtrPtr ByteBuffer __endptr,
					  int __base, locale_t __loc);
public static native @Cast("unsigned long long int") long strtoull_l(@Cast("const char*") BytePointer __nptr,
					  @Cast("char**") @ByPtrPtr byte[] __endptr,
					  int __base, locale_t __loc);
public static native @Cast("unsigned long long int") long strtoull_l(String __nptr,
					  @Cast("char**") @ByPtrPtr BytePointer __endptr,
					  int __base, locale_t __loc);
public static native @Cast("unsigned long long int") long strtoull_l(@Cast("const char*") BytePointer __nptr,
					  @Cast("char**") @ByPtrPtr ByteBuffer __endptr,
					  int __base, locale_t __loc);
public static native @Cast("unsigned long long int") long strtoull_l(String __nptr,
					  @Cast("char**") @ByPtrPtr byte[] __endptr,
					  int __base, locale_t __loc);

public static native double strtod_l(@Cast("const char*") BytePointer __nptr,
			@Cast("char**") PointerPointer __endptr, locale_t __loc);
public static native double strtod_l(@Cast("const char*") BytePointer __nptr,
			@Cast("char**") @ByPtrPtr BytePointer __endptr, locale_t __loc);
public static native double strtod_l(String __nptr,
			@Cast("char**") @ByPtrPtr ByteBuffer __endptr, locale_t __loc);
public static native double strtod_l(@Cast("const char*") BytePointer __nptr,
			@Cast("char**") @ByPtrPtr byte[] __endptr, locale_t __loc);
public static native double strtod_l(String __nptr,
			@Cast("char**") @ByPtrPtr BytePointer __endptr, locale_t __loc);
public static native double strtod_l(@Cast("const char*") BytePointer __nptr,
			@Cast("char**") @ByPtrPtr ByteBuffer __endptr, locale_t __loc);
public static native double strtod_l(String __nptr,
			@Cast("char**") @ByPtrPtr byte[] __endptr, locale_t __loc);

public static native float strtof_l(@Cast("const char*") BytePointer __nptr,
		       @Cast("char**") PointerPointer __endptr, locale_t __loc);
public static native float strtof_l(@Cast("const char*") BytePointer __nptr,
		       @Cast("char**") @ByPtrPtr BytePointer __endptr, locale_t __loc);
public static native float strtof_l(String __nptr,
		       @Cast("char**") @ByPtrPtr ByteBuffer __endptr, locale_t __loc);
public static native float strtof_l(@Cast("const char*") BytePointer __nptr,
		       @Cast("char**") @ByPtrPtr byte[] __endptr, locale_t __loc);
public static native float strtof_l(String __nptr,
		       @Cast("char**") @ByPtrPtr BytePointer __endptr, locale_t __loc);
public static native float strtof_l(@Cast("const char*") BytePointer __nptr,
		       @Cast("char**") @ByPtrPtr ByteBuffer __endptr, locale_t __loc);
public static native float strtof_l(String __nptr,
		       @Cast("char**") @ByPtrPtr byte[] __endptr, locale_t __loc);

public static native @Cast("long double") double strtold_l(@Cast("const char*") BytePointer __nptr,
			      @Cast("char**") PointerPointer __endptr,
			      locale_t __loc);
public static native @Cast("long double") double strtold_l(@Cast("const char*") BytePointer __nptr,
			      @Cast("char**") @ByPtrPtr BytePointer __endptr,
			      locale_t __loc);
public static native @Cast("long double") double strtold_l(String __nptr,
			      @Cast("char**") @ByPtrPtr ByteBuffer __endptr,
			      locale_t __loc);
public static native @Cast("long double") double strtold_l(@Cast("const char*") BytePointer __nptr,
			      @Cast("char**") @ByPtrPtr byte[] __endptr,
			      locale_t __loc);
public static native @Cast("long double") double strtold_l(String __nptr,
			      @Cast("char**") @ByPtrPtr BytePointer __endptr,
			      locale_t __loc);
public static native @Cast("long double") double strtold_l(@Cast("const char*") BytePointer __nptr,
			      @Cast("char**") @ByPtrPtr ByteBuffer __endptr,
			      locale_t __loc);
public static native @Cast("long double") double strtold_l(String __nptr,
			      @Cast("char**") @ByPtrPtr byte[] __endptr,
			      locale_t __loc);
// #endif /* GNU */


// #ifdef __USE_EXTERN_INLINES
// #endif /* Optimizing and Inlining.  */


// #if defined __USE_SVID || defined __USE_XOPEN_EXTENDED
/* Convert N to base 64 using the digits "./0-9A-Za-z", least-significant
   digit first.  Returns a pointer to static storage overwritten by the
   next call.  */
public static native @Cast("char*") BytePointer l64a(long __n);

/* Read a number from a string S in base 64 as above.  */
public static native long a64l(@Cast("const char*") BytePointer __s);
public static native long a64l(String __s);

// #endif	/* Use SVID || extended X/Open.  */

// #if defined __USE_SVID || defined __USE_XOPEN_EXTENDED || defined __USE_BSD
// # include <sys/types.h>	/* we need int32_t... */

/* These are the functions that actually do things.  The `random', `srandom',
   `initstate' and `setstate' functions are those from BSD Unices.
   The `rand' and `srand' functions are required by the ANSI standard.
   We provide both interfaces to the same random number generator.  */
/* Return a random long integer between 0 and RAND_MAX inclusive.  */
public static native long random();

/* Seed the random number generator with the given number.  */
public static native void srandom(@Cast("unsigned int") int __seed);

/* Initialize the random number generator to use state buffer STATEBUF,
   of length STATELEN, and seed it with SEED.  Optimal lengths are 8, 16,
   32, 64, 128 and 256, the bigger the better; values less than 8 will
   cause an error and values greater than 256 will be rounded down.  */
public static native @Cast("char*") BytePointer initstate(@Cast("unsigned int") int __seed, @Cast("char*") BytePointer __statebuf,
			@Cast("size_t") long __statelen);
public static native @Cast("char*") ByteBuffer initstate(@Cast("unsigned int") int __seed, @Cast("char*") ByteBuffer __statebuf,
			@Cast("size_t") long __statelen);
public static native @Cast("char*") byte[] initstate(@Cast("unsigned int") int __seed, @Cast("char*") byte[] __statebuf,
			@Cast("size_t") long __statelen);

/* Switch the random number generator to state buffer STATEBUF,
   which should have been previously initialized by `initstate'.  */
public static native @Cast("char*") BytePointer setstate(@Cast("char*") BytePointer __statebuf);
public static native @Cast("char*") ByteBuffer setstate(@Cast("char*") ByteBuffer __statebuf);
public static native @Cast("char*") byte[] setstate(@Cast("char*") byte[] __statebuf);
// Targeting ../linux/random_data.java



public static native int random_r(random_data __buf,
		     IntPointer __result);
public static native int random_r(random_data __buf,
		     IntBuffer __result);
public static native int random_r(random_data __buf,
		     int[] __result);

public static native int srandom_r(@Cast("unsigned int") int __seed, random_data __buf);

public static native int initstate_r(@Cast("unsigned int") int __seed, @Cast("char*") BytePointer __statebuf,
			@Cast("size_t") long __statelen,
			random_data __buf);
public static native int initstate_r(@Cast("unsigned int") int __seed, @Cast("char*") ByteBuffer __statebuf,
			@Cast("size_t") long __statelen,
			random_data __buf);
public static native int initstate_r(@Cast("unsigned int") int __seed, @Cast("char*") byte[] __statebuf,
			@Cast("size_t") long __statelen,
			random_data __buf);

public static native int setstate_r(@Cast("char*") BytePointer __statebuf,
		       random_data __buf);
public static native int setstate_r(@Cast("char*") ByteBuffer __statebuf,
		       random_data __buf);
public static native int setstate_r(@Cast("char*") byte[] __statebuf,
		       random_data __buf);
// # endif	/* Use misc.  */
// #endif	/* Use SVID || extended X/Open || BSD. */


/* Return a random integer between 0 and RAND_MAX inclusive.  */
public static native int rand();
/* Seed the random number generator with the given number.  */
public static native void srand(@Cast("unsigned int") int __seed);
// #ifdef __USE_POSIX
/* Reentrant interface according to POSIX.1.  */
public static native int rand_r(@Cast("unsigned int*") IntPointer __seed);
public static native int rand_r(@Cast("unsigned int*") IntBuffer __seed);
public static native int rand_r(@Cast("unsigned int*") int[] __seed);
// #endif


// #if defined __USE_SVID || defined __USE_XOPEN
/* System V style 48-bit random number generator functions.  */

/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
public static native double drand48();
public static native double erand48(@Cast("unsigned short int*") ShortPointer __xsubi);
public static native double erand48(@Cast("unsigned short int*") ShortBuffer __xsubi);
public static native double erand48(@Cast("unsigned short int*") short[] __xsubi);

/* Return non-negative, long integer in [0,2^31).  */
public static native long lrand48();
public static native long nrand48(@Cast("unsigned short int*") ShortPointer __xsubi);
public static native long nrand48(@Cast("unsigned short int*") ShortBuffer __xsubi);
public static native long nrand48(@Cast("unsigned short int*") short[] __xsubi);

/* Return signed, long integers in [-2^31,2^31).  */
public static native long mrand48();
public static native long jrand48(@Cast("unsigned short int*") ShortPointer __xsubi);
public static native long jrand48(@Cast("unsigned short int*") ShortBuffer __xsubi);
public static native long jrand48(@Cast("unsigned short int*") short[] __xsubi);

/* Seed random number generator.  */
public static native void srand48(long __seedval);
public static native @Cast("unsigned short int*") ShortPointer seed48(@Cast("unsigned short int*") ShortPointer __seed16v);
public static native @Cast("unsigned short int*") ShortBuffer seed48(@Cast("unsigned short int*") ShortBuffer __seed16v);
public static native @Cast("unsigned short int*") short[] seed48(@Cast("unsigned short int*") short[] __seed16v);
public static native void lcong48(@Cast("unsigned short int*") ShortPointer __param);
public static native void lcong48(@Cast("unsigned short int*") ShortBuffer __param);
public static native void lcong48(@Cast("unsigned short int*") short[] __param);
// Targeting ../linux/drand48_data.java



/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */
public static native int drand48_r(drand48_data __buffer,
		      DoublePointer __result);
public static native int drand48_r(drand48_data __buffer,
		      DoubleBuffer __result);
public static native int drand48_r(drand48_data __buffer,
		      double[] __result);
public static native int erand48_r(@Cast("unsigned short int*") ShortPointer __xsubi,
		      drand48_data __buffer,
		      DoublePointer __result);
public static native int erand48_r(@Cast("unsigned short int*") ShortBuffer __xsubi,
		      drand48_data __buffer,
		      DoubleBuffer __result);
public static native int erand48_r(@Cast("unsigned short int*") short[] __xsubi,
		      drand48_data __buffer,
		      double[] __result);

/* Return non-negative, long integer in [0,2^31).  */
public static native int lrand48_r(drand48_data __buffer,
		      CLongPointer __result);
public static native int nrand48_r(@Cast("unsigned short int*") ShortPointer __xsubi,
		      drand48_data __buffer,
		      CLongPointer __result);
public static native int nrand48_r(@Cast("unsigned short int*") ShortBuffer __xsubi,
		      drand48_data __buffer,
		      CLongPointer __result);
public static native int nrand48_r(@Cast("unsigned short int*") short[] __xsubi,
		      drand48_data __buffer,
		      CLongPointer __result);

/* Return signed, long integers in [-2^31,2^31).  */
public static native int mrand48_r(drand48_data __buffer,
		      CLongPointer __result);
public static native int jrand48_r(@Cast("unsigned short int*") ShortPointer __xsubi,
		      drand48_data __buffer,
		      CLongPointer __result);
public static native int jrand48_r(@Cast("unsigned short int*") ShortBuffer __xsubi,
		      drand48_data __buffer,
		      CLongPointer __result);
public static native int jrand48_r(@Cast("unsigned short int*") short[] __xsubi,
		      drand48_data __buffer,
		      CLongPointer __result);

/* Seed random number generator.  */
public static native int srand48_r(long __seedval, drand48_data __buffer);

public static native int seed48_r(@Cast("unsigned short int*") ShortPointer __seed16v,
		     drand48_data __buffer);
public static native int seed48_r(@Cast("unsigned short int*") ShortBuffer __seed16v,
		     drand48_data __buffer);
public static native int seed48_r(@Cast("unsigned short int*") short[] __seed16v,
		     drand48_data __buffer);

public static native int lcong48_r(@Cast("unsigned short int*") ShortPointer __param,
		      drand48_data __buffer);
public static native int lcong48_r(@Cast("unsigned short int*") ShortBuffer __param,
		      drand48_data __buffer);
public static native int lcong48_r(@Cast("unsigned short int*") short[] __param,
		      drand48_data __buffer);
// # endif	/* Use misc.  */
// #endif	/* Use SVID or X/Open.  */

// #endif /* don't just need malloc and calloc */

// #ifndef __malloc_and_calloc_defined
// # define __malloc_and_calloc_defined
/* Allocate SIZE bytes of memory.  */
public static native Pointer malloc(@Cast("size_t") long __size);
/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */
public static native Pointer calloc(@Cast("size_t") long __nmemb, @Cast("size_t") long __size);
// #endif

// #ifndef __need_malloc_and_calloc
/* Re-allocate the previously allocated block
   in PTR, making the new block SIZE bytes long.  */
/* __attribute_malloc__ is not used, because if realloc returns
   the same pointer that was passed to it, aliasing needs to be allowed
   between objects pointed by the old and new pointers.  */
public static native Pointer realloc(Pointer __ptr, @Cast("size_t") long __size);
/* Free a block allocated by `malloc', `realloc' or `calloc'.  */
public static native void free(Pointer __ptr);
// #ifdef	__USE_MISC
/* Free a block.  An alias for `free'.	(Sun Unices).  */
public static native void cfree(Pointer __ptr);
// #endif /* Use misc.  */

// #if defined __USE_GNU || defined __USE_BSD || defined __USE_MISC
// # include <alloca.h>
// #endif /* Use GNU, BSD, or misc.  */

// #if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K)
//     || defined __USE_BSD
/* Allocate SIZE bytes on a page boundary.  The storage cannot be freed.  */
public static native Pointer valloc(@Cast("size_t") long __size);
// #endif

// #ifdef __USE_XOPEN2K
/* Allocate memory of SIZE bytes with an alignment of ALIGNMENT.  */
public static native int posix_memalign(@Cast("void**") PointerPointer __memptr, @Cast("size_t") long __alignment, @Cast("size_t") long __size);
public static native int posix_memalign(@Cast("void**") @ByPtrPtr Pointer __memptr, @Cast("size_t") long __alignment, @Cast("size_t") long __size);
// #endif

/* Abort execution and generate a core-dump.  */
public static native void abort();
// Targeting ../linux/__func.java


public static native int atexit(__func __func);

// #ifdef __USE_GNU
// XXX There should be a macro to signal with C++ revision is used.
// XXX This function is in the C++1x revision.
/* Register a function to be called when `quick_exit' is called.  */
// # ifdef __cplusplus
public static native int at_quick_exit(__func __func);
// # else
// Targeting ../linux/__func_int_Pointer.java


public static native int on_exit(__func_int_Pointer __func, Pointer __arg);
// #endif

/* Call all functions registered with `atexit' and `on_exit',
   in the reverse of the order in which they were registered,
   perform stdio cleanup, and terminate program execution with STATUS.  */
public static native void exit(int __status);

// #ifdef __USE_GNU
// XXX There should be a macro to signal with C++ revision is used.
// XXX This function is in the C++1x revision.
/* Call all functions registered with `at_quick_exit' in the reverse
   of the order in which they were registered and terminate program
   execution with STATUS.  */
public static native void quick_exit(int __status);
// #endif
// #ifdef __USE_ISOC99
/* Terminate the program with STATUS without calling any of the
   functions registered with `atexit' or `on_exit'.  */
public static native void _Exit(int __status);
// #endif


/* Return the value of envariable NAME, or NULL if it doesn't exist.  */
public static native @Cast("char*") BytePointer getenv(@Cast("const char*") BytePointer __name);
public static native @Cast("char*") ByteBuffer getenv(String __name);
/* This function is similar to the above but returns NULL if the
   programs is running with SUID or SGID enabled.  */
public static native @Cast("char*") BytePointer __secure_getenv(@Cast("const char*") BytePointer __name);
public static native @Cast("char*") ByteBuffer __secure_getenv(String __name);

// #if defined __USE_SVID || defined __USE_XOPEN
/* The SVID says this is in <stdio.h>, but this seems a better place.	*/
/* Put STRING, which is of the form "NAME=VALUE", in the environment.
   If there is no `=', remove NAME from the environment.  */
public static native int putenv(@Cast("char*") BytePointer __string);
public static native int putenv(@Cast("char*") ByteBuffer __string);
public static native int putenv(@Cast("char*") byte[] __string);
// #endif

// #if defined __USE_BSD || defined __USE_XOPEN2K
/* Set NAME to VALUE in the environment.
   If REPLACE is nonzero, overwrite an existing value.  */
public static native int setenv(@Cast("const char*") BytePointer __name, @Cast("const char*") BytePointer __value, int __replace);
public static native int setenv(String __name, String __value, int __replace);

/* Remove the variable NAME from the environment.  */
public static native int unsetenv(@Cast("const char*") BytePointer __name);
public static native int unsetenv(String __name);
// #endif

// #ifdef	__USE_MISC
/* The `clearenv' was planned to be added to POSIX.1 but probably
   never made it.  Nevertheless the POSIX.9 standard (POSIX bindings
   for Fortran 77) requires this function.  */
public static native int clearenv();
// #endif


// #if defined __USE_MISC
//     || (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K)
/* Generate a unique temporary file name from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the file name unique.
   Returns TEMPLATE, or a null pointer if it cannot get a unique file name.  */

// #endif

// #if defined __USE_MISC || defined __USE_XOPEN_EXTENDED
//     || defined __USE_XOPEN2K8
/* Generate a unique temporary file name from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the filename unique.
   Returns a file descriptor open on the file for reading and writing,
   or -1 if it cannot create a uniquely-named file.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
// # ifndef __USE_FILE_OFFSET64
public static native int mkstemp(@Cast("char*") BytePointer __template);
public static native int mkstemp(@Cast("char*") ByteBuffer __template);
public static native int mkstemp(@Cast("char*") byte[] __template);
// # else
// # endif
// # ifdef __USE_LARGEFILE64
public static native int mkstemp64(@Cast("char*") BytePointer __template);
public static native int mkstemp64(@Cast("char*") ByteBuffer __template);
public static native int mkstemp64(@Cast("char*") byte[] __template);
// # endif
// #endif

// #ifdef __USE_MISC
/* Similar to mkstemp, but the template can have a suffix after the
   XXXXXX.  The length of the suffix is specified in the second
   parameter.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
// # ifndef __USE_FILE_OFFSET64
public static native int mkstemps(@Cast("char*") BytePointer __template, int __suffixlen);
public static native int mkstemps(@Cast("char*") ByteBuffer __template, int __suffixlen);
public static native int mkstemps(@Cast("char*") byte[] __template, int __suffixlen);
// # else
// # endif
// # ifdef __USE_LARGEFILE64
public static native int mkstemps64(@Cast("char*") BytePointer __template, int __suffixlen);
public static native int mkstemps64(@Cast("char*") ByteBuffer __template, int __suffixlen);
public static native int mkstemps64(@Cast("char*") byte[] __template, int __suffixlen);
// # endif
// #endif

// #if defined __USE_BSD || defined __USE_XOPEN2K8
/* Create a unique temporary directory from TEMPLATE.
   The last six characters of TEMPLATE must be "XXXXXX";
   they are replaced with a string that makes the directory name unique.
   Returns TEMPLATE, or a null pointer if it cannot get a unique name.
   The directory is created mode 700.  */
public static native @Cast("char*") BytePointer mkdtemp(@Cast("char*") BytePointer __template);
public static native @Cast("char*") ByteBuffer mkdtemp(@Cast("char*") ByteBuffer __template);
public static native @Cast("char*") byte[] mkdtemp(@Cast("char*") byte[] __template);
// #endif

// #ifdef __USE_GNU
/* Generate a unique temporary file name from TEMPLATE similar to
   mkstemp.  But allow the caller to pass additional flags which are
   used in the open call to create the file..

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
// # ifndef __USE_FILE_OFFSET64
public static native int mkostemp(@Cast("char*") BytePointer __template, int __flags);
public static native int mkostemp(@Cast("char*") ByteBuffer __template, int __flags);
public static native int mkostemp(@Cast("char*") byte[] __template, int __flags);
// # else
// # endif
// # ifdef __USE_LARGEFILE64
public static native int mkostemp64(@Cast("char*") BytePointer __template, int __flags);
public static native int mkostemp64(@Cast("char*") ByteBuffer __template, int __flags);
public static native int mkostemp64(@Cast("char*") byte[] __template, int __flags);
// # endif

/* Similar to mkostemp, but the template can have a suffix after the
   XXXXXX.  The length of the suffix is specified in the second
   parameter.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
// # ifndef __USE_FILE_OFFSET64
public static native int mkostemps(@Cast("char*") BytePointer __template, int __suffixlen, int __flags);
public static native int mkostemps(@Cast("char*") ByteBuffer __template, int __suffixlen, int __flags);
public static native int mkostemps(@Cast("char*") byte[] __template, int __suffixlen, int __flags);
// # else
// # endif
// # ifdef __USE_LARGEFILE64
public static native int mkostemps64(@Cast("char*") BytePointer __template, int __suffixlen, int __flags);
public static native int mkostemps64(@Cast("char*") ByteBuffer __template, int __suffixlen, int __flags);
public static native int mkostemps64(@Cast("char*") byte[] __template, int __suffixlen, int __flags);
// # endif
// #endif


/* Execute the given line as a shell command.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native int system(@Cast("const char*") BytePointer __command);
public static native int system(String __command);
// #ifdef	__USE_GNU
/* Return a malloc'd string containing the canonical absolute name of the
   existing named file.  */
public static native @Cast("char*") BytePointer canonicalize_file_name(@Cast("const char*") BytePointer __name);
public static native @Cast("char*") ByteBuffer canonicalize_file_name(String __name);
// #endif

// #if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
/* Return the canonical absolute name of file NAME.  If RESOLVED is
   null, the result is malloc'd; otherwise, if the canonical name is
   PATH_MAX chars or more, returns null with `errno' set to
   ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,
   returns the name in RESOLVED.  */
public static native @Cast("char*") BytePointer realpath(@Cast("const char*") BytePointer __name,
		       @Cast("char*") BytePointer __resolved);
public static native @Cast("char*") ByteBuffer realpath(String __name,
		       @Cast("char*") ByteBuffer __resolved);
public static native @Cast("char*") byte[] realpath(@Cast("const char*") BytePointer __name,
		       @Cast("char*") byte[] __resolved);
public static native @Cast("char*") BytePointer realpath(String __name,
		       @Cast("char*") BytePointer __resolved);
public static native @Cast("char*") ByteBuffer realpath(@Cast("const char*") BytePointer __name,
		       @Cast("char*") ByteBuffer __resolved);
public static native @Cast("char*") byte[] realpath(String __name,
		       @Cast("char*") byte[] __resolved);
// #endif


/* Shorthand for type of comparison functions.  */
// #ifndef __COMPAR_FN_T
// # define __COMPAR_FN_T
// Targeting ../linux/__compar_fn_t.java



// # ifdef	__USE_GNU
// Targeting ../linux/__compar_d_fn_t.java


// #endif

/* Do a binary search for KEY in BASE, which consists of NMEMB elements
   of SIZE bytes each, using COMPAR to perform the comparisons.  */
public static native Pointer bsearch(@Const Pointer __key, @Const Pointer __base,
		      @Cast("size_t") long __nmemb, @Cast("size_t") long __size, __compar_fn_t __compar);

/* Sort NMEMB elements of BASE, of SIZE bytes each,
   using COMPAR to perform the comparisons.  */
public static native void qsort(Pointer __base, @Cast("size_t") long __nmemb, @Cast("size_t") long __size,
		   __compar_fn_t __compar);
// #ifdef __USE_GNU
public static native void qsort_r(Pointer __base, @Cast("size_t") long __nmemb, @Cast("size_t") long __size,
		     __compar_d_fn_t __compar, Pointer __arg);
// #endif


/* Return the absolute value of X.  */
public static native int abs(int __x);
public static native long labs(long __x);
// #ifdef __USE_ISOC99
public static native long llabs(long __x);
// #endif


/* Return the `div_t', `ldiv_t' or `lldiv_t' representation
   of the value of NUMER over DENOM. */
/* GCC may have built-ins for these someday.  */
public static native @ByVal div_t div(int __numer, int __denom);
public static native @ByVal ldiv_t ldiv(long __numer, long __denom);
// #ifdef __USE_ISOC99
public static native @ByVal lldiv_t lldiv(long __numer,
				    long __denom);
// #endif


// #if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K)
//     || defined __USE_SVID
/* Convert floating point numbers to strings.  The returned values are
   valid only until another call to the same function.  */

/* Convert VALUE to a string with NDIGIT digits and return a pointer to
   this.  Set *DECPT with the position of the decimal character and *SIGN
   with the sign of the number.  */
public static native @Cast("char*") BytePointer ecvt(double __value, int __ndigit, @Cast("int*") IntPointer __decpt,
		   @Cast("int*") IntPointer __sign);
public static native @Cast("char*") ByteBuffer ecvt(double __value, int __ndigit, @Cast("int*") IntBuffer __decpt,
		   @Cast("int*") IntBuffer __sign);
public static native @Cast("char*") byte[] ecvt(double __value, int __ndigit, @Cast("int*") int[] __decpt,
		   @Cast("int*") int[] __sign);

/* Convert VALUE to a string rounded to NDIGIT decimal digits.  Set *DECPT
   with the position of the decimal character and *SIGN with the sign of
   the number.  */
public static native @Cast("char*") BytePointer fcvt(double __value, int __ndigit, @Cast("int*") IntPointer __decpt,
		   @Cast("int*") IntPointer __sign);
public static native @Cast("char*") ByteBuffer fcvt(double __value, int __ndigit, @Cast("int*") IntBuffer __decpt,
		   @Cast("int*") IntBuffer __sign);
public static native @Cast("char*") byte[] fcvt(double __value, int __ndigit, @Cast("int*") int[] __decpt,
		   @Cast("int*") int[] __sign);

/* If possible convert VALUE to a string with NDIGIT significant digits.
   Otherwise use exponential representation.  The resulting string will
   be written to BUF.  */
public static native @Cast("char*") BytePointer gcvt(double __value, int __ndigit, @Cast("char*") BytePointer __buf);
public static native @Cast("char*") ByteBuffer gcvt(double __value, int __ndigit, @Cast("char*") ByteBuffer __buf);
public static native @Cast("char*") byte[] gcvt(double __value, int __ndigit, @Cast("char*") byte[] __buf);


// # ifdef __USE_MISC
/* Long double versions of above functions.  */
public static native @Cast("char*") BytePointer qecvt(@Cast("long double") double __value, int __ndigit,
		    @Cast("int*") IntPointer __decpt, @Cast("int*") IntPointer __sign);
public static native @Cast("char*") ByteBuffer qecvt(@Cast("long double") double __value, int __ndigit,
		    @Cast("int*") IntBuffer __decpt, @Cast("int*") IntBuffer __sign);
public static native @Cast("char*") byte[] qecvt(@Cast("long double") double __value, int __ndigit,
		    @Cast("int*") int[] __decpt, @Cast("int*") int[] __sign);
public static native @Cast("char*") BytePointer qfcvt(@Cast("long double") double __value, int __ndigit,
		    @Cast("int*") IntPointer __decpt, @Cast("int*") IntPointer __sign);
public static native @Cast("char*") ByteBuffer qfcvt(@Cast("long double") double __value, int __ndigit,
		    @Cast("int*") IntBuffer __decpt, @Cast("int*") IntBuffer __sign);
public static native @Cast("char*") byte[] qfcvt(@Cast("long double") double __value, int __ndigit,
		    @Cast("int*") int[] __decpt, @Cast("int*") int[] __sign);
public static native @Cast("char*") BytePointer qgcvt(@Cast("long double") double __value, int __ndigit, @Cast("char*") BytePointer __buf);
public static native @Cast("char*") ByteBuffer qgcvt(@Cast("long double") double __value, int __ndigit, @Cast("char*") ByteBuffer __buf);
public static native @Cast("char*") byte[] qgcvt(@Cast("long double") double __value, int __ndigit, @Cast("char*") byte[] __buf);


/* Reentrant version of the functions above which provide their own
   buffers.  */
public static native int ecvt_r(double __value, int __ndigit, @Cast("int*") IntPointer __decpt,
		   @Cast("int*") IntPointer __sign, @Cast("char*") BytePointer __buf,
		   @Cast("size_t") long __len);
public static native int ecvt_r(double __value, int __ndigit, @Cast("int*") IntBuffer __decpt,
		   @Cast("int*") IntBuffer __sign, @Cast("char*") ByteBuffer __buf,
		   @Cast("size_t") long __len);
public static native int ecvt_r(double __value, int __ndigit, @Cast("int*") int[] __decpt,
		   @Cast("int*") int[] __sign, @Cast("char*") byte[] __buf,
		   @Cast("size_t") long __len);
public static native int fcvt_r(double __value, int __ndigit, @Cast("int*") IntPointer __decpt,
		   @Cast("int*") IntPointer __sign, @Cast("char*") BytePointer __buf,
		   @Cast("size_t") long __len);
public static native int fcvt_r(double __value, int __ndigit, @Cast("int*") IntBuffer __decpt,
		   @Cast("int*") IntBuffer __sign, @Cast("char*") ByteBuffer __buf,
		   @Cast("size_t") long __len);
public static native int fcvt_r(double __value, int __ndigit, @Cast("int*") int[] __decpt,
		   @Cast("int*") int[] __sign, @Cast("char*") byte[] __buf,
		   @Cast("size_t") long __len);

public static native int qecvt_r(@Cast("long double") double __value, int __ndigit,
		    @Cast("int*") IntPointer __decpt, @Cast("int*") IntPointer __sign,
		    @Cast("char*") BytePointer __buf, @Cast("size_t") long __len);
public static native int qecvt_r(@Cast("long double") double __value, int __ndigit,
		    @Cast("int*") IntBuffer __decpt, @Cast("int*") IntBuffer __sign,
		    @Cast("char*") ByteBuffer __buf, @Cast("size_t") long __len);
public static native int qecvt_r(@Cast("long double") double __value, int __ndigit,
		    @Cast("int*") int[] __decpt, @Cast("int*") int[] __sign,
		    @Cast("char*") byte[] __buf, @Cast("size_t") long __len);
public static native int qfcvt_r(@Cast("long double") double __value, int __ndigit,
		    @Cast("int*") IntPointer __decpt, @Cast("int*") IntPointer __sign,
		    @Cast("char*") BytePointer __buf, @Cast("size_t") long __len);
public static native int qfcvt_r(@Cast("long double") double __value, int __ndigit,
		    @Cast("int*") IntBuffer __decpt, @Cast("int*") IntBuffer __sign,
		    @Cast("char*") ByteBuffer __buf, @Cast("size_t") long __len);
public static native int qfcvt_r(@Cast("long double") double __value, int __ndigit,
		    @Cast("int*") int[] __decpt, @Cast("int*") int[] __sign,
		    @Cast("char*") byte[] __buf, @Cast("size_t") long __len);
// # endif	/* misc */
// #endif	/* use MISC || use X/Open Unix */


/* Return the length of the multibyte character
   in S, which is no longer than N.  */
public static native int mblen(@Cast("const char*") BytePointer __s, @Cast("size_t") long __n);
public static native int mblen(String __s, @Cast("size_t") long __n);
/* Return the length of the given multibyte character,
   putting its `wchar_t' representation in *PWC.  */
public static native int mbtowc(@Cast("wchar_t*") CharPointer __pwc,
		   @Cast("const char*") BytePointer __s, @Cast("size_t") long __n);
public static native int mbtowc(@Cast("wchar_t*") IntPointer __pwc,
		   String __s, @Cast("size_t") long __n);
/* Put the multibyte character represented
   by WCHAR in S, returning its length.  */
public static native int wctomb(@Cast("char*") BytePointer __s, @Cast("wchar_t") char __wchar);
public static native int wctomb(@Cast("char*") ByteBuffer __s, @Cast("wchar_t") int __wchar);
public static native int wctomb(@Cast("char*") byte[] __s, @Cast("wchar_t") char __wchar);
public static native int wctomb(@Cast("char*") BytePointer __s, @Cast("wchar_t") int __wchar);
public static native int wctomb(@Cast("char*") ByteBuffer __s, @Cast("wchar_t") char __wchar);
public static native int wctomb(@Cast("char*") byte[] __s, @Cast("wchar_t") int __wchar);


/* Convert a multibyte string to a wide char string.  */
public static native @Cast("size_t") long mbstowcs(@Cast("wchar_t*") CharPointer __pwcs,
			@Cast("const char*") BytePointer __s, @Cast("size_t") long __n);
public static native @Cast("size_t") long mbstowcs(@Cast("wchar_t*") IntPointer __pwcs,
			String __s, @Cast("size_t") long __n);
/* Convert a wide char string to multibyte string.  */
public static native @Cast("size_t") long wcstombs(@Cast("char*") BytePointer __s,
			@Cast("const wchar_t*") CharPointer __pwcs, @Cast("size_t") long __n);
public static native @Cast("size_t") long wcstombs(@Cast("char*") ByteBuffer __s,
			@Cast("const wchar_t*") IntPointer __pwcs, @Cast("size_t") long __n);
public static native @Cast("size_t") long wcstombs(@Cast("char*") byte[] __s,
			@Cast("const wchar_t*") CharPointer __pwcs, @Cast("size_t") long __n);
public static native @Cast("size_t") long wcstombs(@Cast("char*") BytePointer __s,
			@Cast("const wchar_t*") IntPointer __pwcs, @Cast("size_t") long __n);
public static native @Cast("size_t") long wcstombs(@Cast("char*") ByteBuffer __s,
			@Cast("const wchar_t*") CharPointer __pwcs, @Cast("size_t") long __n);
public static native @Cast("size_t") long wcstombs(@Cast("char*") byte[] __s,
			@Cast("const wchar_t*") IntPointer __pwcs, @Cast("size_t") long __n);
// #ifdef __USE_SVID
/* Determine whether the string value of RESPONSE matches the affirmation
   or negative response expression as specified by the LC_MESSAGES category
   in the program's current locale.  Returns 1 if affirmative, 0 if
   negative, and -1 if not matching.  */
public static native int rpmatch(@Cast("const char*") BytePointer __response);
public static native int rpmatch(String __response);
// #endif


// #if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
/* Parse comma separated suboption from *OPTIONP and match against
   strings in TOKENS.  If found return index and set *VALUEP to
   optional value introduced by an equal sign.  If the suboption is
   not part of TOKENS return in *VALUEP beginning of unknown
   suboption.  On exit *OPTIONP is set to the beginning of the next
   token or at the terminating NUL character.  */
public static native int getsubopt(@Cast("char**") PointerPointer __optionp,
		      @Cast("char*__const*") PointerPointer __tokens,
		      @Cast("char**") PointerPointer __valuep);
public static native int getsubopt(@Cast("char**") @ByPtrPtr BytePointer __optionp,
		      @Cast("char*__const*") @ByPtrPtr BytePointer __tokens,
		      @Cast("char**") @ByPtrPtr BytePointer __valuep);
public static native int getsubopt(@Cast("char**") @ByPtrPtr ByteBuffer __optionp,
		      @Cast("char*__const*") @ByPtrPtr ByteBuffer __tokens,
		      @Cast("char**") @ByPtrPtr ByteBuffer __valuep);
public static native int getsubopt(@Cast("char**") @ByPtrPtr byte[] __optionp,
		      @Cast("char*__const*") @ByPtrPtr byte[] __tokens,
		      @Cast("char**") @ByPtrPtr byte[] __valuep);
// #endif


// #ifdef __USE_XOPEN
/* Setup DES tables according KEY.  */
public static native void setkey(@Cast("const char*") BytePointer __key);
public static native void setkey(String __key);
// #endif


/* X/Open pseudo terminal handling.  */

// #ifdef __USE_XOPEN2KXSI
/* Return a master pseudo-terminal handle.  */
public static native int posix_openpt(int __oflag);
// #endif

// #ifdef __USE_XOPEN
/* The next four functions all take a master pseudo-tty fd and
   perform an operation on the associated slave:  */

/* Chown the slave to the calling user.  */
public static native int grantpt(int __fd);

/* Release an internal lock so the slave can be opened.
   Call after grantpt().  */
public static native int unlockpt(int __fd);

/* Return the pathname of the pseudo terminal slave assoicated with
   the master FD is open on, or NULL on errors.
   The returned storage is good until the next call to this function.  */
public static native @Cast("char*") BytePointer ptsname(int __fd);
// #endif

// #ifdef __USE_GNU
/* Store at most BUFLEN characters of the pathname of the slave pseudo
   terminal associated with the master FD is open on in BUF.
   Return 0 on success, otherwise an error number.  */
public static native int ptsname_r(int __fd, @Cast("char*") BytePointer __buf, @Cast("size_t") long __buflen);
public static native int ptsname_r(int __fd, @Cast("char*") ByteBuffer __buf, @Cast("size_t") long __buflen);
public static native int ptsname_r(int __fd, @Cast("char*") byte[] __buf, @Cast("size_t") long __buflen);

/* Open a master pseudo terminal and return its file descriptor.  */
public static native int getpt();
// #endif

// #ifdef __USE_BSD
/* Put the 1 minute, 5 minute and 15 minute load averages into the first
   NELEM elements of LOADAVG.  Return the number written (never more than
   three, but may be less than NELEM), or -1 if an error occurred.  */
public static native int getloadavg(DoublePointer __loadavg, int __nelem);
public static native int getloadavg(DoubleBuffer __loadavg, int __nelem);
public static native int getloadavg(double[] __loadavg, int __nelem);
// #endif


/* Define some macros helping to catch buffer overflows.  */
// #if __USE_FORTIFY_LEVEL > 0 && defined __extern_always_inline
// # include <bits/stdlib.h>
// #endif
// #ifdef __LDBL_COMPAT
// # include <bits/stdlib-db.h>
// #endif

// #endif /* don't just need malloc and calloc */
// #undef __need_malloc_and_calloc

// #endif /* stdlib.h  */


// Parsed from bits/time.h

/* System-dependent timing definitions.  Generic version.
   Copyright (C) 1996,1997,1999-2002,2003,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 * Never include this file directly; use <time.h> instead.
 */

// #ifndef __need_timeval
// # ifndef _BITS_TIME_H
public static final int _BITS_TIME_H =	1;

/* ISO/IEC 9899:1990 7.12.1: <time.h>
   The macro `CLOCKS_PER_SEC' is the number per second of the value
   returned by the `clock' function. */
/* CAE XSH, Issue 4, Version 2: <time.h>
   The value of CLOCKS_PER_SEC is required to be 1 million on all
   XSI-conformant systems. */
public static native @MemberGetter long CLOCKS_PER_SEC();
public static final long CLOCKS_PER_SEC = CLOCKS_PER_SEC();

// #  if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
   presents the real value for clock ticks per second for the system.  */
// #   include <bits/types.h>
// #   define CLK_TCK ((__clock_t) __sysconf (2))	/* 2 is _SC_CLK_TCK */
// #  endif

// #  ifdef __USE_POSIX199309
// #  endif

// # endif	/* bits/time.h */
// #endif

// #ifdef __need_timeval
// # undef __need_timeval
// # ifndef _STRUCT_TIMEVAL
public static final int _STRUCT_TIMEVAL =	1;
// #  include <bits/types.h>
// Targeting ../linux/timeval.java


// # endif	/* struct timeval */
// #endif	/* need timeval */


// Parsed from sys/time.h

/* Copyright (C) 1991-1994,1996-2003,2005,2006,2009
	Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef _SYS_TIME_H
public static final int _SYS_TIME_H =	1;

// #include <features.h>

// #include <bits/types.h>
// #define __need_time_t
// #include <time.h>
// #define __need_timeval
// #include <bits/time.h>

// #include <sys/select.h>

// #ifndef __suseconds_t_defined
// # define __suseconds_t_defined
// #endif


// #ifdef __USE_GNU
/* Macros for converting between `struct timeval' and `struct timespec'.  */
// # define TIMEVAL_TO_TIMESPEC(tv, ts) {
//         (ts)->tv_sec = (tv)->tv_sec;
//         (ts)->tv_nsec = (tv)->tv_usec * 1000;
// }
// # define TIMESPEC_TO_TIMEVAL(tv, ts) {
//         (tv)->tv_sec = (ts)->tv_sec;
//         (tv)->tv_usec = (ts)->tv_nsec / 1000;
// }
// Targeting ../linux/timezone.java


// #else
// #endif

/* Get the current time of day and timezone information,
   putting it into *TV and *TZ.  If TZ is NULL, *TZ is not filled.
   Returns 0 on success, -1 on errors.
   NOTE: This form of timezone information is obsolete.
   Use the functions and variables declared in <time.h> instead.  */
public static native int gettimeofday(timeval __tv,
			 @ByVal @Cast("__timezone_ptr_t*") timezone __tz);

// #ifdef __USE_BSD
/* Set the current time of day and timezone information.
   This call is restricted to the super-user.  */
public static native int settimeofday(@Const timeval __tv,
			 @Const timezone __tz);

/* Adjust the current time of day by the amount in DELTA.
   If OLDDELTA is not NULL, it is filled in with the amount
   of time adjustment remaining to be done from the last `adjtime' call.
   This call is restricted to the super-user.  */
public static native int adjtime(@Const timeval __delta,
		    timeval __olddelta);
// #endif


/* Values for the first argument to `getitimer' and `setitimer'.  */
/** enum __itimer_which */
public static final int
    /* Timers run in real time.  */
    ITIMER_REAL = 0,
// #define ITIMER_REAL ITIMER_REAL
    /* Timers run only when the process is executing.  */
    ITIMER_VIRTUAL = 1,
// #define ITIMER_VIRTUAL ITIMER_VIRTUAL
    /* Timers run when the process is executing and when
       the system is executing on behalf of the process.  */
    ITIMER_PROF = 2;
// #define ITIMER_PROF ITIMER_PROF
// Targeting ../linux/itimerval.java



// #if defined __USE_GNU && !defined __cplusplus
/* Use the nicer parameter type only in GNU mode and not for C++ since the
   strict C++ rules prevent the automatic promotion.  */
// #else
// #endif

/* Set *VALUE to the current setting of timer WHICH.
   Return 0 on success, -1 on errors.  */
public static native int getitimer(@Cast("__itimer_which_t") int __which,
		      itimerval __value);

/* Set the timer WHICH to *NEW.  If OLD is not NULL,
   set *OLD to the old value of timer WHICH.
   Returns 0 on success, -1 on errors.  */
public static native int setitimer(@Cast("__itimer_which_t") int __which,
		      @Const itimerval __new,
		      itimerval __old);

/* Change the access time of FILE to TVP[0] and the modification time of
   FILE to TVP[1].  If TVP is a null pointer, use the current time instead.
   Returns 0 on success, -1 on errors.  */
public static native int utimes(@Cast("const char*") BytePointer __file, @Const timeval __tvp);
public static native int utimes(String __file, @Const timeval __tvp);

// #ifdef __USE_BSD
/* Same as `utimes', but does not follow symbolic links.  */
public static native int lutimes(@Cast("const char*") BytePointer __file, @Const timeval __tvp);
public static native int lutimes(String __file, @Const timeval __tvp);

/* Same as `utimes', but takes an open file descriptor instead of a name.  */
public static native int futimes(int __fd, @Const timeval __tvp);
// #endif

// #ifdef __USE_GNU
/* Change the access time of FILE relative to FD to TVP[0] and the
   modification time of FILE to TVP[1].  If TVP is a null pointer, use
   the current time instead.  Returns 0 on success, -1 on errors.  */
public static native int futimesat(int __fd, @Cast("const char*") BytePointer __file,
		      @Const timeval __tvp);
public static native int futimesat(int __fd, String __file,
		      @Const timeval __tvp);
// #endif


// #ifdef __USE_BSD
/* Convenience macros for operations on timevals.
   NOTE: `timercmp' does not work for >= or <=.  */
// # define timerisset(tvp)	((tvp)->tv_sec || (tvp)->tv_usec)
// # define timerclear(tvp)	((tvp)->tv_sec = (tvp)->tv_usec = 0)
// # define timercmp(a, b, CMP)
//   (((a)->tv_sec == (b)->tv_sec) ?
//    ((a)->tv_usec CMP (b)->tv_usec) :
//    ((a)->tv_sec CMP (b)->tv_sec))
// # define timeradd(a, b, result)
//   do {
//     (result)->tv_sec = (a)->tv_sec + (b)->tv_sec;
//     (result)->tv_usec = (a)->tv_usec + (b)->tv_usec;
//     if ((result)->tv_usec >= 1000000)
//       {
// 	++(result)->tv_sec;
// 	(result)->tv_usec -= 1000000;
//       }
//   } while (0)
// # define timersub(a, b, result)
//   do {
//     (result)->tv_sec = (a)->tv_sec - (b)->tv_sec;
//     (result)->tv_usec = (a)->tv_usec - (b)->tv_usec;
//     if ((result)->tv_usec < 0) {
//       --(result)->tv_sec;
//       (result)->tv_usec += 1000000;
//     }
//   } while (0)
// #endif	/* BSD */

// #endif /* sys/time.h */


// Parsed from time.h

/* Copyright (C) 1991-2003,2006,2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.23 Date and time	<time.h>
 */

// #ifndef	_TIME_H

// #if (! defined __need_time_t && !defined __need_clock_t &&
//      ! defined __need_timespec)
public static final int _TIME_H =	1;
// # include <features.h>

// #endif

// #ifdef	_TIME_H
/* Get size_t and NULL from <stddef.h>.  */
// # define __need_size_t
// # define __need_NULL
// # include <stddef.h>

/* This defines CLOCKS_PER_SEC, which is the number of processor clock
   ticks per second.  */
// # include <bits/time.h>

/* This is the obsolete POSIX.1-1988 name for the same constant.  */
// # if !defined __STRICT_ANSI__ && !defined __USE_XOPEN2K
// #  ifndef CLK_TCK
// #   define CLK_TCK	CLOCKS_PER_SEC
// #  endif
// # endif

// #endif /* <time.h> included.  */

// #if !defined __clock_t_defined && (defined _TIME_H || defined __need_clock_t)
public static final int __clock_t_defined =	1;

// # include <bits/types.h>

/* Returned by `clock'.  */
// #if defined __USE_XOPEN || defined __USE_POSIX || defined __USE_MISC
// #endif

// #endif /* clock_t not defined and <time.h> or need clock_t.  */
// #undef	__need_clock_t

// #if !defined __time_t_defined && (defined _TIME_H || defined __need_time_t)
public static final int __time_t_defined =	1;

// # include <bits/types.h>

/* Returned by `time'.  */
// #if defined __USE_POSIX || defined __USE_MISC || defined __USE_SVID
// #endif

// #endif /* time_t not defined and <time.h> or need time_t.  */
// #undef	__need_time_t

// #if !defined __clockid_t_defined &&
//    ((defined _TIME_H && defined __USE_POSIX199309) || defined __need_clockid_t)
public static final int __clockid_t_defined =	1;

// # include <bits/types.h>

/* Clock ID used in clock and timer functions.  */

// #endif /* clockid_t not defined and <time.h> or need clockid_t.  */
// #undef	__clockid_time_t

// #if !defined __timer_t_defined &&
//     ((defined _TIME_H && defined __USE_POSIX199309) || defined __need_timer_t)
public static final int __timer_t_defined =	1;

// # include <bits/types.h>

/* Timer ID returned by `timer_create'.  */

// #endif /* timer_t not defined and <time.h> or need timer_t.  */
// #undef	__need_timer_t


// #if !defined __timespec_defined &&
//     ((defined _TIME_H &&
//       (defined __USE_POSIX199309 || defined __USE_MISC)) ||
//       defined __need_timespec)
public static final int __timespec_defined =	1;

// # include <bits/types.h>
// Targeting ../linux/timespec.java



// #endif /* timespec not defined and <time.h> or need timespec.  */
// #undef	__need_timespec
// Targeting ../linux/tm.java


// #if defined __USE_XOPEN || defined __USE_POSIX || defined __USE_MISC
// #endif


// #ifdef __USE_POSIX199309

// #endif	/* POSIX.1b */

// #ifdef __USE_XOPEN2K
// # ifndef __pid_t_defined
// #  define __pid_t_defined
// # endif
// #endif


/* Time used by the program so far (user time + system time).
   The result / CLOCKS_PER_SECOND is program time in seconds.  */
public static native @Cast("clock_t") long clock();

/* Return the current time and put it in *TIMER if TIMER is not NULL.  */
public static native @Cast("time_t") long time(@Cast("time_t*") SizeTPointer __timer);

/* Return the difference between TIME1 and TIME0.  */
public static native double difftime(@Cast("time_t") long __time1, @Cast("time_t") long __time0);

/* Return the `time_t' representation of TP and normalize TP.  */
public static native @Cast("time_t") long mktime(tm __tp);


/* Format TP into S according to FORMAT.
   Write no more than MAXSIZE characters and return the number
   of characters written, or 0 if it would exceed MAXSIZE.  */
public static native @Cast("size_t") long strftime(@Cast("char*") BytePointer __s, @Cast("size_t") long __maxsize,
			@Cast("const char*") BytePointer __format,
			@Const tm __tp);
public static native @Cast("size_t") long strftime(@Cast("char*") ByteBuffer __s, @Cast("size_t") long __maxsize,
			String __format,
			@Const tm __tp);
public static native @Cast("size_t") long strftime(@Cast("char*") byte[] __s, @Cast("size_t") long __maxsize,
			@Cast("const char*") BytePointer __format,
			@Const tm __tp);
public static native @Cast("size_t") long strftime(@Cast("char*") BytePointer __s, @Cast("size_t") long __maxsize,
			String __format,
			@Const tm __tp);
public static native @Cast("size_t") long strftime(@Cast("char*") ByteBuffer __s, @Cast("size_t") long __maxsize,
			@Cast("const char*") BytePointer __format,
			@Const tm __tp);
public static native @Cast("size_t") long strftime(@Cast("char*") byte[] __s, @Cast("size_t") long __maxsize,
			String __format,
			@Const tm __tp);
// # ifdef __USE_XOPEN
/* Parse S according to FORMAT and store binary time information in TP.
   The return value is a pointer to the first unparsed character in S.  */
public static native @Cast("char*") BytePointer strptime(@Cast("const char*") BytePointer __s,
		       @Cast("const char*") BytePointer __fmt, tm __tp);
public static native @Cast("char*") ByteBuffer strptime(String __s,
		       String __fmt, tm __tp);
// # endif

// # ifdef __USE_XOPEN2K8
/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */
// # include <xlocale.h>

public static native @Cast("size_t") long strftime_l(@Cast("char*") BytePointer __s, @Cast("size_t") long __maxsize,
			  @Cast("const char*") BytePointer __format,
			  @Const tm __tp,
			  locale_t __loc);
public static native @Cast("size_t") long strftime_l(@Cast("char*") ByteBuffer __s, @Cast("size_t") long __maxsize,
			  String __format,
			  @Const tm __tp,
			  locale_t __loc);
public static native @Cast("size_t") long strftime_l(@Cast("char*") byte[] __s, @Cast("size_t") long __maxsize,
			  @Cast("const char*") BytePointer __format,
			  @Const tm __tp,
			  locale_t __loc);
public static native @Cast("size_t") long strftime_l(@Cast("char*") BytePointer __s, @Cast("size_t") long __maxsize,
			  String __format,
			  @Const tm __tp,
			  locale_t __loc);
public static native @Cast("size_t") long strftime_l(@Cast("char*") ByteBuffer __s, @Cast("size_t") long __maxsize,
			  @Cast("const char*") BytePointer __format,
			  @Const tm __tp,
			  locale_t __loc);
public static native @Cast("size_t") long strftime_l(@Cast("char*") byte[] __s, @Cast("size_t") long __maxsize,
			  String __format,
			  @Const tm __tp,
			  locale_t __loc);
// # endif

// # ifdef __USE_GNU
public static native @Cast("char*") BytePointer strptime_l(@Cast("const char*") BytePointer __s,
			 @Cast("const char*") BytePointer __fmt, tm __tp,
			 locale_t __loc);
public static native @Cast("char*") ByteBuffer strptime_l(String __s,
			 String __fmt, tm __tp,
			 locale_t __loc);
// # endif


/* Return the `struct tm' representation of *TIMER
   in Universal Coordinated Time (aka Greenwich Mean Time).  */
public static native tm gmtime(@Cast("const time_t*") SizeTPointer __timer);

/* Return the `struct tm' representation
   of *TIMER in the local timezone.  */
public static native tm localtime(@Cast("const time_t*") SizeTPointer __timer);
// # if defined __USE_POSIX || defined __USE_MISC
/* Return the `struct tm' representation of *TIMER in UTC,
   using *TP to store the result.  */
public static native tm gmtime_r(@Cast("const time_t*") SizeTPointer __timer,
			    tm __tp);

/* Return the `struct tm' representation of *TIMER in local time,
   using *TP to store the result.  */
public static native tm localtime_r(@Cast("const time_t*") SizeTPointer __timer,
			       tm __tp);
// # endif	/* POSIX or misc */

/* Return a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  */
public static native @Cast("char*") BytePointer asctime(@Const tm __tp);

/* Equivalent to `asctime (localtime (timer))'.  */
public static native @Cast("char*") BytePointer ctime(@Cast("const time_t*") SizeTPointer __timer);
// # if defined __USE_POSIX || defined __USE_MISC
/* Reentrant versions of the above functions.  */

/* Return in BUF a string of the form "Day Mon dd hh:mm:ss yyyy\n"
   that is the representation of TP in this format.  */
public static native @Cast("char*") BytePointer asctime_r(@Const tm __tp,
			@Cast("char*") BytePointer __buf);
public static native @Cast("char*") ByteBuffer asctime_r(@Const tm __tp,
			@Cast("char*") ByteBuffer __buf);
public static native @Cast("char*") byte[] asctime_r(@Const tm __tp,
			@Cast("char*") byte[] __buf);

/* Equivalent to `asctime_r (localtime_r (timer, *TMP*), buf)'.  */
public static native @Cast("char*") BytePointer ctime_r(@Cast("const time_t*") SizeTPointer __timer,
		      @Cast("char*") BytePointer __buf);
public static native @Cast("char*") ByteBuffer ctime_r(@Cast("const time_t*") SizeTPointer __timer,
		      @Cast("char*") ByteBuffer __buf);
public static native @Cast("char*") byte[] ctime_r(@Cast("const time_t*") SizeTPointer __timer,
		      @Cast("char*") byte[] __buf);
// # endif	/* POSIX or misc */


/* Defined in localtime.c.  */
public static native @Cast("char*") BytePointer __tzname(int i); public static native void __tzname(int i, BytePointer __tzname);
@MemberGetter public static native @Cast("char**") PointerPointer __tzname();	/* Current timezone names.  */
public static native int __daylight(); public static native void __daylight(int __daylight);		/* If daylight-saving time is ever in use.  */
public static native long __timezone(); public static native void __timezone(long __timezone);	/* Seconds west of UTC.  */


// # ifdef	__USE_POSIX
/* Same as above.  */
public static native @Cast("char*") BytePointer tzname(int i); public static native void tzname(int i, BytePointer tzname);
@MemberGetter public static native @Cast("char**") PointerPointer tzname();

/* Set time conversion information from the TZ environment variable.
   If TZ is not defined, a locale-dependent default is used.  */
public static native void tzset();
// # endif

// # if defined __USE_SVID || defined __USE_XOPEN
public static native int daylight(); public static native void daylight(int daylight);
// # endif

// # ifdef __USE_SVID
/* Set the system time to *WHEN.
   This call is restricted to the superuser.  */
public static native int stime(@Cast("const time_t*") SizeTPointer __when);
// # endif


/* Nonzero if YEAR is a leap year (every 4 years,
   except every 100th isn't, and every 400th is).  */
// # define __isleap(year)
//   ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))


// # ifdef __USE_MISC
/* Miscellaneous functions many Unices inherited from the public domain
   localtime package.  These are included only for compatibility.  */

/* Like `mktime', but for TP represents Universal Time, not local time.  */
public static native @Cast("time_t") long timegm(tm __tp);

/* Another name for `mktime'.  */
public static native @Cast("time_t") long timelocal(tm __tp);

/* Return the number of days in YEAR.  */
public static native int dysize(int __year);
// # endif


// # ifdef __USE_POSIX199309
// # endif


// # ifdef __USE_XOPEN_EXTENDED
/* Set to one of the following values to indicate an error.
     1  the DATEMSK environment variable is null or undefined,
     2  the template file cannot be opened for reading,
     3  failed to get file status information,
     4  the template file is not a regular file,
     5  an error is encountered while reading the template file,
     6  memory allication failed (not enough memory available),
     7  there is no line in the template that matches the input,
     8  invalid input specification Example: February 31 or a time is
        specified that can not be represented in a time_t (representing
	the time in seconds since 00:00:00 UTC, January 1, 1970) */
public static native int getdate_err(); public static native void getdate_err(int getdate_err);

/* Parse the given string as a date specification and return a value
   representing the value.  The templates from the file identified by
   the environment variable DATEMSK are used.  In case of an error
   `getdate_err' is set.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
public static native tm getdate(@Cast("const char*") BytePointer __string);
public static native tm getdate(String __string);
// # endif

// # ifdef __USE_GNU
/* Since `getdate' is not reentrant because of the use of `getdate_err'
   and the static buffer to return the result in, we provide a thread-safe
   variant.  The functionality is the same.  The result is returned in
   the buffer pointed to by RESBUFP and in case of an error the return
   value is != 0 with the same values as given above for `getdate_err'.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
public static native int getdate_r(@Cast("const char*") BytePointer __string,
		      tm __resbufp);
public static native int getdate_r(String __string,
		      tm __resbufp);
// # endif

// #endif /* <time.h> included.  */

// #endif /* <time.h> not already included.  */


// Parsed from utime.h

/* Copyright (C) 1991, 92, 96, 97, 98, 99, 2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	POSIX Standard: 5.6.6 Set File Access and Modification Times  <utime.h>
 */

// #ifndef	_UTIME_H
public static final int _UTIME_H =	1;

// #include <features.h>

// #include <bits/types.h>

// #if defined __USE_XOPEN || defined __USE_XOPEN2K
// # define __need_time_t
// # include <time.h>
// Targeting ../linux/utimbuf.java



/* Set the access and modification times of FILE to those given in
   *FILE_TIMES.  If FILE_TIMES is NULL, set them to the current time.  */
public static native int utime(@Cast("const char*") BytePointer __file,
		  @Const utimbuf __file_times);
public static native int utime(String __file,
		  @Const utimbuf __file_times);

// #endif /* utime.h */


// Parsed from bits/stat.h

/* Copyright (C) 1999-2003,2009,2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #if !defined _SYS_STAT_H && !defined _FCNTL_H
// # error "Never include <bits/stat.h> directly; use <sys/stat.h> instead."
// #endif

// #ifndef _BITS_STAT_H
public static final int _BITS_STAT_H =	1;

/* Versions of the `struct stat' data structure.  */
public static final int _STAT_VER_KERNEL =	0;

// #if __WORDSIZE == 32
// #else
public static final int _STAT_VER_LINUX =	1;

/* x86-64 versions of the `xmknod' interface.  */
public static final int _MKNOD_VER_LINUX =	0;
// #endif

public static final int _STAT_VER =		_STAT_VER_LINUX;
// Targeting ../linux/stat.java


// Targeting ../linux/stat64.java


// #endif

/* Tell code we have these members.  */
// #define	_STATBUF_ST_BLKSIZE
// #define _STATBUF_ST_RDEV
/* Nanosecond resolution time values are supported.  */
// #define _STATBUF_ST_NSEC

/* Encoding of the file mode.  */

public static final int __S_IFMT =	0170000;	/* These bits determine file type.  */

/* File types.  */
public static final int __S_IFDIR =	0040000;	/* Directory.  */
public static final int __S_IFCHR =	0020000;	/* Character device.  */
public static final int __S_IFBLK =	0060000;	/* Block device.  */
public static final int __S_IFREG =	0100000;	/* Regular file.  */
public static final int __S_IFIFO =	0010000;	/* FIFO.  */
public static final int __S_IFLNK =	0120000;	/* Symbolic link.  */
public static final int __S_IFSOCK =	0140000;	/* Socket.  */

/* POSIX.1b objects.  Note that these macros always evaluate to zero.  But
   they do it by enforcing the correct use of the macros.  */
// #define __S_TYPEISMQ(buf)  ((buf)->st_mode - (buf)->st_mode)
// #define __S_TYPEISSEM(buf) ((buf)->st_mode - (buf)->st_mode)
// #define __S_TYPEISSHM(buf) ((buf)->st_mode - (buf)->st_mode)

/* Protection bits.  */

public static final int __S_ISUID =	04000;	/* Set user ID on execution.  */
public static final int __S_ISGID =	02000;	/* Set group ID on execution.  */
public static final int __S_ISVTX =	01000;	/* Save swapped text after use (sticky).  */
public static final int __S_IREAD =	0400;	/* Read by owner.  */
public static final int __S_IWRITE =	0200;	/* Write by owner.  */
public static final int __S_IEXEC =	0100;	/* Execute by owner.  */

// #ifdef __USE_ATFILE
public static final long UTIME_NOW =	((1L << 30) - 1L);
public static final long UTIME_OMIT =	((1L << 30) - 2L);
// #endif

// #endif	/* bits/stat.h */


// Parsed from sys/stat.h

/* Copyright (C) 1991, 1992, 1995-2004, 2005, 2006, 2007, 2009, 2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	POSIX Standard: 5.6 File Characteristics	<sys/stat.h>
 */

// #ifndef	_SYS_STAT_H
public static final int _SYS_STAT_H =	1;

// #include <features.h>

// #include <bits/types.h>		/* For __mode_t and __dev_t.  */

// #if defined __USE_XOPEN || defined __USE_XOPEN2K || defined __USE_MISC
// 	 || defined __USE_ATFILE
// # if defined __USE_XOPEN || defined __USE_XOPEN2K
// #  define __need_time_t
// # endif
// # if defined __USE_MISC || defined __USE_ATFILE
// #  define __need_timespec
// # endif
// # include <time.h>		/* For time_t resp. timespec.  */
// #endif

// #if defined __USE_XOPEN || defined __USE_XOPEN2K
/* The Single Unix specification says that some more types are
   available here.  */
// # ifndef __dev_t_defined
// #  define __dev_t_defined
// # endif

// # ifndef __gid_t_defined
// #  define __gid_t_defined
// # endif

// # ifndef __ino_t_defined
// #  ifndef __USE_FILE_OFFSET64
// #  else
// #  endif
// #  define __ino_t_defined
// # endif

// # ifndef __mode_t_defined
// #  define __mode_t_defined
// # endif

// # ifndef __nlink_t_defined
// #  define __nlink_t_defined
// # endif

// # ifndef __off_t_defined
// #  ifndef __USE_FILE_OFFSET64
// #  else
// #  endif
// #  define __off_t_defined
// # endif

// # ifndef __uid_t_defined
// #  define __uid_t_defined
// # endif
// #endif	/* X/Open */

// #ifdef __USE_UNIX98
// # ifndef __blkcnt_t_defined
// #  ifndef __USE_FILE_OFFSET64
// #  else
// #  endif
// #  define __blkcnt_t_defined
// # endif

// # ifndef __blksize_t_defined
// #  define __blksize_t_defined
// # endif
// #endif	/* Unix98 */

// #include <bits/stat.h>

// #if defined __USE_BSD || defined __USE_MISC || defined __USE_XOPEN
public static final int S_IFMT =		__S_IFMT;
public static final int S_IFDIR =	__S_IFDIR;
public static final int S_IFCHR =	__S_IFCHR;
public static final int S_IFBLK =	__S_IFBLK;
public static final int S_IFREG =	__S_IFREG;
// # ifdef __S_IFIFO
public static final int S_IFIFO =	__S_IFIFO;
// # endif
// # ifdef __S_IFLNK
public static final int S_IFLNK =	__S_IFLNK;
// # endif
// # if (defined __USE_BSD || defined __USE_MISC || defined __USE_UNIX98)
//      && defined __S_IFSOCK
public static final int S_IFSOCK =	__S_IFSOCK;
// # endif
// #endif

/* Test macros for file types.	*/

// #define	__S_ISTYPE(mode, mask)	(((mode) & __S_IFMT) == (mask))

// #define	S_ISDIR(mode)	 __S_ISTYPE((mode), __S_IFDIR)
// #define	S_ISCHR(mode)	 __S_ISTYPE((mode), __S_IFCHR)
// #define	S_ISBLK(mode)	 __S_ISTYPE((mode), __S_IFBLK)
// #define	S_ISREG(mode)	 __S_ISTYPE((mode), __S_IFREG)
// #ifdef __S_IFIFO
// # define S_ISFIFO(mode)	 __S_ISTYPE((mode), __S_IFIFO)
// #endif
// #ifdef __S_IFLNK
// # define S_ISLNK(mode)	 __S_ISTYPE((mode), __S_IFLNK)
// #endif

// #if defined __USE_BSD && !defined __S_IFLNK
// # define S_ISLNK(mode)  0
// #endif

// #if (defined __USE_BSD || defined __USE_UNIX98 || defined __USE_XOPEN2K)
//     && defined __S_IFSOCK
// # define S_ISSOCK(mode) __S_ISTYPE((mode), __S_IFSOCK)
// #elif defined __USE_XOPEN2K
// # define S_ISSOCK(mode) 0
// #endif

/* These are from POSIX.1b.  If the objects are not implemented using separate
   distinct file types, the macros always will evaluate to zero.  Unlike the
   other S_* macros the following three take a pointer to a `struct stat'
   object as the argument.  */
// #ifdef	__USE_POSIX199309
// #endif


/* Protection bits.  */

public static final int S_ISUID = __S_ISUID;	/* Set user ID on execution.  */
public static final int S_ISGID =	__S_ISGID;	/* Set group ID on execution.  */

// #if defined __USE_BSD || defined __USE_MISC || defined __USE_XOPEN
/* Save swapped text after use (sticky bit).  This is pretty well obsolete.  */
public static final int S_ISVTX =	__S_ISVTX;
// #endif

public static final int S_IRUSR =	__S_IREAD;	/* Read by owner.  */
public static final int S_IWUSR =	__S_IWRITE;	/* Write by owner.  */
public static final int S_IXUSR =	__S_IEXEC;	/* Execute by owner.  */
/* Read, write, and execute by owner.  */
public static final int S_IRWXU =	(__S_IREAD|__S_IWRITE|__S_IEXEC);

// #if defined __USE_MISC && defined __USE_BSD
public static final int S_IREAD =	S_IRUSR;
public static final int S_IWRITE =	S_IWUSR;
public static final int S_IEXEC =	S_IXUSR;
// #endif

public static final int S_IRGRP =	(S_IRUSR >> 3);	/* Read by group.  */
public static final int S_IWGRP =	(S_IWUSR >> 3);	/* Write by group.  */
public static final int S_IXGRP =	(S_IXUSR >> 3);	/* Execute by group.  */
/* Read, write, and execute by group.  */
public static final int S_IRWXG =	(S_IRWXU >> 3);

public static final int S_IROTH =	(S_IRGRP >> 3);	/* Read by others.  */
public static final int S_IWOTH =	(S_IWGRP >> 3);	/* Write by others.  */
public static final int S_IXOTH =	(S_IXGRP >> 3);	/* Execute by others.  */
/* Read, write, and execute by others.  */
public static final int S_IRWXO =	(S_IRWXG >> 3);


// #ifdef	__USE_BSD
/* Macros for common mode bit masks.  */
public static final int ACCESSPERMS = (S_IRWXU|S_IRWXG|S_IRWXO); /* 0777 */
public static final int ALLPERMS = (S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO);/* 07777 */
public static final int DEFFILEMODE = (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);/* 0666*/

public static final int S_BLKSIZE =	512;	/* Block size for `st_blocks'.  */
// #endif


// #ifndef __USE_FILE_OFFSET64
/* Get file attributes for FILE and put them in BUF.  */
public static native int stat(@Cast("const char*") BytePointer __file,
		 stat __buf);
public static native int stat(String __file,
		 stat __buf);

/* Get file attributes for the file, device, pipe, or socket
   that file descriptor FD is open on and put them in BUF.  */
public static native int fstat(int __fd, stat __buf);
// #else
// #endif
// #ifdef __USE_LARGEFILE64
public static native int stat64(@Cast("const char*") BytePointer __file,
		   stat64 __buf);
public static native int stat64(String __file,
		   stat64 __buf);
public static native int fstat64(int __fd, stat64 __buf);
// #endif

// #ifdef __USE_ATFILE
/* Similar to stat, get the attributes for FILE and put them in BUF.
   Relative path names are interpreted relative to FD unless FD is
   AT_FDCWD.  */
// # ifndef __USE_FILE_OFFSET64
public static native int fstatat(int __fd, @Cast("const char*") BytePointer __file,
		    stat __buf, int __flag);
public static native int fstatat(int __fd, String __file,
		    stat __buf, int __flag);
// # else
// # endif

// # ifdef __USE_LARGEFILE64
public static native int fstatat64(int __fd, @Cast("const char*") BytePointer __file,
		      stat64 __buf, int __flag);
public static native int fstatat64(int __fd, String __file,
		      stat64 __buf, int __flag);
// # endif
// #endif

// #if defined __USE_BSD || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K
// # ifndef __USE_FILE_OFFSET64
/* Get file attributes about FILE and put them in BUF.
   If FILE is a symbolic link, do not follow it.  */
public static native int lstat(@Cast("const char*") BytePointer __file,
		  stat __buf);
public static native int lstat(String __file,
		  stat __buf);
// # else
// # endif
// # ifdef __USE_LARGEFILE64
public static native int lstat64(@Cast("const char*") BytePointer __file,
		    stat64 __buf);
public static native int lstat64(String __file,
		    stat64 __buf);
// # endif
// #endif

/* Set file access permissions for FILE to MODE.
   If FILE is a symbolic link, this affects its target instead.  */
public static native int chmod(@Cast("const char*") BytePointer __file, @Cast("__mode_t") int __mode);
public static native int chmod(String __file, @Cast("__mode_t") int __mode);

// #ifdef __USE_BSD
/* Set file access permissions for FILE to MODE.
   If FILE is a symbolic link, this affects the link itself
   rather than its target.  */

// #endif

/* Set file access permissions of the file FD is open on to MODE.  */
// #if defined __USE_BSD || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
public static native int fchmod(int __fd, @Cast("__mode_t") int __mode);
// #endif

// #ifdef __USE_ATFILE
/* Set file access permissions of FILE relative to
   the directory FD is open on.  */
public static native int fchmodat(int __fd, @Cast("const char*") BytePointer __file, @Cast("__mode_t") int __mode,
		     int __flag);
public static native int fchmodat(int __fd, String __file, @Cast("__mode_t") int __mode,
		     int __flag);
// #endif /* Use ATFILE.  */



/* Set the file creation mask of the current process to MASK,
   and return the old creation mask.  */
public static native @Cast("__mode_t") int umask(@Cast("__mode_t") int __mask);

// #ifdef	__USE_GNU
/* Get the current `umask' value without changing it.
   This function is only available under the GNU Hurd.  */
public static native @Cast("__mode_t") int getumask();
// #endif

/* Create a new directory named PATH, with permission bits MODE.  */
public static native int mkdir(@Cast("const char*") BytePointer __path, @Cast("__mode_t") int __mode);
public static native int mkdir(String __path, @Cast("__mode_t") int __mode);

// #ifdef __USE_ATFILE
/* Like mkdir, create a new directory with permission bits MODE.  But
   interpret relative PATH names relative to the directory associated
   with FD.  */
public static native int mkdirat(int __fd, @Cast("const char*") BytePointer __path, @Cast("__mode_t") int __mode);
public static native int mkdirat(int __fd, String __path, @Cast("__mode_t") int __mode);
// #endif

/* Create a device file named PATH, with permission and special bits MODE
   and device number DEV (which can be constructed from major and minor
   device numbers with the `makedev' macro above).  */
// #if defined __USE_MISC || defined __USE_BSD || defined __USE_XOPEN_EXTENDED
public static native int mknod(@Cast("const char*") BytePointer __path, @Cast("__mode_t") int __mode, @Cast("__dev_t") long __dev);
public static native int mknod(String __path, @Cast("__mode_t") int __mode, @Cast("__dev_t") long __dev);

// # ifdef __USE_ATFILE
/* Like mknod, create a new device file with permission bits MODE and
   device number DEV.  But interpret relative PATH names relative to
   the directory associated with FD.  */
public static native int mknodat(int __fd, @Cast("const char*") BytePointer __path, @Cast("__mode_t") int __mode,
		    @Cast("__dev_t") long __dev);
public static native int mknodat(int __fd, String __path, @Cast("__mode_t") int __mode,
		    @Cast("__dev_t") long __dev);
// # endif
// #endif


/* Create a new FIFO named PATH, with permission bits MODE.  */
public static native int mkfifo(@Cast("const char*") BytePointer __path, @Cast("__mode_t") int __mode);
public static native int mkfifo(String __path, @Cast("__mode_t") int __mode);

// #ifdef __USE_ATFILE
/* Like mkfifo, create a new FIFO with permission bits MODE.  But
   interpret relative PATH names relative to the directory associated
   with FD.  */
public static native int mkfifoat(int __fd, @Cast("const char*") BytePointer __path, @Cast("__mode_t") int __mode);
public static native int mkfifoat(int __fd, String __path, @Cast("__mode_t") int __mode);
// #endif

// #ifdef __USE_ATFILE
/* Set file access and modification times relative to directory file
   descriptor.  */
public static native int utimensat(int __fd, @Cast("const char*") BytePointer __path,
		      @Const timespec __times,
		      int __flags);
public static native int utimensat(int __fd, String __path,
		      @Const timespec __times,
		      int __flags);
// #endif

// #ifdef __USE_XOPEN2K8
/* Set file access and modification times of the file associated with FD.  */
public static native int futimens(int __fd, @Const timespec __times);
// #endif

/* To allow the `struct stat' structure and the file type `mode_t'
   bits to vary without changing shared library major version number,
   the `stat' family of functions and `mknod' are in fact inline
   wrappers around calls to `xstat', `fxstat', `lxstat', and `xmknod',
   which all take a leading version-number argument designating the
   data structure and bits used.  <bits/stat.h> defines _STAT_VER with
   the version number corresponding to `struct stat' as defined in
   that file; and _MKNOD_VER with the version number corresponding to
   the S_IF* macros defined therein.  It is arranged that when not
   inlined these function are always statically linked; that way a
   dynamically-linked executable always encodes the version number
   corresponding to the data structures it uses, so the `x' functions
   in the shared library can adapt without needing to recompile all
   callers.  */

// #ifndef _STAT_VER
// #endif
// #ifndef _MKNOD_VER
public static final int _MKNOD_VER =	0;
// #endif

/* Wrappers for stat and mknod system calls.  */
// #ifndef __USE_FILE_OFFSET64
public static native int __fxstat(int __ver, int __fildes, stat __stat_buf);
public static native int __xstat(int __ver, @Cast("const char*") BytePointer __filename,
		    stat __stat_buf);
public static native int __xstat(int __ver, String __filename,
		    stat __stat_buf);
public static native int __lxstat(int __ver, @Cast("const char*") BytePointer __filename,
		     stat __stat_buf);
public static native int __lxstat(int __ver, String __filename,
		     stat __stat_buf);
public static native int __fxstatat(int __ver, int __fildes, @Cast("const char*") BytePointer __filename,
		       stat __stat_buf, int __flag);
public static native int __fxstatat(int __ver, int __fildes, String __filename,
		       stat __stat_buf, int __flag);
// #else
// #endif

// #ifdef __USE_LARGEFILE64
public static native int __fxstat64(int __ver, int __fildes, stat64 __stat_buf);
public static native int __xstat64(int __ver, @Cast("const char*") BytePointer __filename,
		      stat64 __stat_buf);
public static native int __xstat64(int __ver, String __filename,
		      stat64 __stat_buf);
public static native int __lxstat64(int __ver, @Cast("const char*") BytePointer __filename,
		       stat64 __stat_buf);
public static native int __lxstat64(int __ver, String __filename,
		       stat64 __stat_buf);
public static native int __fxstatat64(int __ver, int __fildes, @Cast("const char*") BytePointer __filename,
			 stat64 __stat_buf, int __flag);
public static native int __fxstatat64(int __ver, int __fildes, String __filename,
			 stat64 __stat_buf, int __flag);
// #endif
public static native int __xmknod(int __ver, @Cast("const char*") BytePointer __path, @Cast("__mode_t") int __mode,
		     @Cast("__dev_t*") SizeTPointer __dev);
public static native int __xmknod(int __ver, String __path, @Cast("__mode_t") int __mode,
		     @Cast("__dev_t*") SizeTPointer __dev);

public static native int __xmknodat(int __ver, int __fd, @Cast("const char*") BytePointer __path,
		       @Cast("__mode_t") int __mode, @Cast("__dev_t*") SizeTPointer __dev);
public static native int __xmknodat(int __ver, int __fd, String __path,
		       @Cast("__mode_t") int __mode, @Cast("__dev_t*") SizeTPointer __dev);

// #if defined __GNUC__ && __GNUC__ >= 2 && defined __USE_EXTERN_INLINES

// #endif

// #endif /* sys/stat.h  */


// Parsed from fcntl.h

/* Copyright (C) 1991,1992,1994-2001,2003,2004,2005,2006,2007,2009,2010
	Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	POSIX Standard: 6.5 File Control Operations	<fcntl.h>
 */

// #ifndef	_FCNTL_H
public static final int _FCNTL_H =	1;

// #include <features.h>

/* This must be early so <bits/fcntl.h> can define types winningly.  */
/* Get the definitions of O_*, F_*, FD_*: all the
   numbers and flag bits for `open', `fcntl', et al.  */
// #include <bits/fcntl.h>

/* For XPG all symbols from <sys/stat.h> should also be available.  */
// #if defined __USE_XOPEN || defined __USE_XOPEN2K8
// # include <bits/types.h>         /* For __mode_t and __dev_t.  */
// # define __need_timespec
// # include <time.h>
// # include <bits/stat.h>
// # ifdef __S_IFIFO
// # endif
// # ifdef __S_IFLNK
// # endif
// # if (defined __USE_UNIX98 || defined __USE_XOPEN2K8) && defined __S_IFSOCK
// # endif

/* Protection bits.  */       /* Set user ID on execution.  */       /* Set group ID on execution.  */

// # if defined __USE_BSD || defined __USE_MISC || defined __USE_XOPEN
/* Save swapped text after use (sticky bit).  This is pretty well obsolete.  */
// # endif       /* Read by owner.  */      /* Write by owner.  */       /* Execute by owner.  */
/* Read, write, and execute by owner.  */  /* Read by group.  */  /* Write by group.  */  /* Execute by group.  */
/* Read, write, and execute by group.  */  /* Read by others.  */  /* Write by others.  */  /* Execute by others.  */
/* Read, write, and execute by others.  */
// #endif

// #ifdef	__USE_MISC
// # ifndef R_OK			/* Verbatim from <unistd.h>.  Ugh.  */
/* Values for the second argument to access.
   These may be OR'd together.  */
public static final int R_OK =	4;		/* Test for read permission.  */
public static final int W_OK =	2;		/* Test for write permission.  */
public static final int X_OK =	1;		/* Test for execute permission.  */
public static final int F_OK =	0;		/* Test for existence.  */
// # endif
// #endif /* Use misc.  */

/* XPG wants the following symbols.   <stdio.h> has the same definitions.  */
// #if defined __USE_XOPEN || defined __USE_XOPEN2K8
public static final int SEEK_SET =	0;	/* Seek from beginning of file.  */
public static final int SEEK_CUR =	1;	/* Seek from current position.  */
public static final int SEEK_END =	2;	/* Seek from end of file.  */
// #endif	/* XPG */

// #ifdef __USE_ATFILE
public static final int AT_FDCWD =		-100;	/* Special value used to indicate
					   the *at functions should use the
					   current working directory. */
public static final int AT_SYMLINK_NOFOLLOW =	0x100;	/* Do not follow symbolic links.  */
public static final int AT_REMOVEDIR =		0x200;	/* Remove directory instead of
					   unlinking file.  */
public static final int AT_SYMLINK_FOLLOW =	0x400;	/* Follow symbolic links.  */
public static final int AT_EACCESS =		0x200;	/* Test access permitted for
					   effective IDs, not real IDs.  */
// #endif

/* Do the file control operation described by CMD on FD.
   The remaining arguments are interpreted depending on CMD.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native int fcntl(int __fd, int __cmd);

/* Open FILE and return a new file descriptor for it, or -1 on error.
   OFLAG determines the type of access used.  If O_CREAT is on OFLAG,
   the third argument is taken as a `mode_t', the mode of the created file.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
// #ifndef __USE_FILE_OFFSET64
public static native int open(@Cast("const char*") BytePointer __file, int __oflag);
public static native int open(String __file, int __oflag);
// #else
// #endif
// #ifdef __USE_LARGEFILE64
public static native int open64(@Cast("const char*") BytePointer __file, int __oflag);
public static native int open64(String __file, int __oflag);
// #endif

// #ifdef __USE_ATFILE
/* Similar to `open' but a relative path name is interpreted relative to
   the directory for which FD is a descriptor.

   NOTE: some other `openat' implementation support additional functionality
   through this interface, especially using the O_XATTR flag.  This is not
   yet supported here.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
// # ifndef __USE_FILE_OFFSET64
public static native int openat(int __fd, @Cast("const char*") BytePointer __file, int __oflag);
public static native int openat(int __fd, String __file, int __oflag);
// # else
// # endif
// # ifdef __USE_LARGEFILE64
public static native int openat64(int __fd, @Cast("const char*") BytePointer __file, int __oflag);
public static native int openat64(int __fd, String __file, int __oflag);
// # endif
// #endif

/* Create and open FILE, with mode MODE.  This takes an `int' MODE
   argument because that is what `mode_t' will be widened to.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
// #ifndef __USE_FILE_OFFSET64
public static native int creat(@Cast("const char*") BytePointer __file, @Cast("__mode_t") int __mode);
public static native int creat(String __file, @Cast("__mode_t") int __mode);
// #else
// #endif
// #ifdef __USE_LARGEFILE64
public static native int creat64(@Cast("const char*") BytePointer __file, @Cast("__mode_t") int __mode);
public static native int creat64(String __file, @Cast("__mode_t") int __mode);
// #endif

// #if !defined F_LOCK && (defined __USE_MISC || (defined __USE_XOPEN_EXTENDED
// 					       && !defined __USE_POSIX))
/* NOTE: These declarations also appear in <unistd.h>; be sure to keep both
   files consistent.  Some systems have them there and some here, and some
   software depends on the macros being defined without including both.  */

/* `lockf' is a simpler interface to the locking facilities of `fcntl'.
   LEN is always relative to the current file position.
   The CMD argument is one of the following.  */

public static final int F_ULOCK = 0;	/* Unlock a previously locked region.  */
public static final int F_LOCK =  1;	/* Lock a region for exclusive use.  */
public static final int F_TLOCK = 2;	/* Test and lock a region for exclusive use.  */
public static final int F_TEST =  3;	/* Test a region for other processes locks.  */

// # ifndef __USE_FILE_OFFSET64
public static native int lockf(int __fd, int __cmd, @Cast("__off_t") long __len);
// # else
// # endif
// # ifdef __USE_LARGEFILE64
public static native int lockf64(int __fd, int __cmd, @Cast("__off64_t") long __len);
// # endif
// #endif

// #ifdef __USE_XOPEN2K
/* Advice the system about the expected behaviour of the application with
   respect to the file associated with FD.  */
// # ifndef __USE_FILE_OFFSET64
public static native int posix_fadvise(int __fd, @Cast("__off_t") long __offset, @Cast("__off_t") long __len,
			  int __advise);
// # else
// # endif
// # ifdef __USE_LARGEFILE64
public static native int posix_fadvise64(int __fd, @Cast("__off64_t") long __offset, @Cast("__off64_t") long __len,
			    int __advise);
// # endif


/* Reserve storage for the data of the file associated with FD.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
// # ifndef __USE_FILE_OFFSET64
public static native int posix_fallocate(int __fd, @Cast("__off_t") long __offset, @Cast("__off_t") long __len);
// # else
// # endif
// # ifdef __USE_LARGEFILE64
public static native int posix_fallocate64(int __fd, @Cast("__off64_t") long __offset, @Cast("__off64_t") long __len);
// # endif
// #endif


/* Define some inlines helping to catch common problems.  */
// #if __USE_FORTIFY_LEVEL > 0 && defined __extern_always_inline
//     && defined __va_arg_pack_len
// # include <bits/fcntl2.h>
// #endif

// #endif /* fcntl.h  */


// Parsed from sys/file.h

/* Copyright (C) 1991, 92, 96, 97, 98, 99 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef	_SYS_FILE_H
public static final int _SYS_FILE_H =	1;

// #include <features.h>

// #ifndef	_FCNTL_H
// #endif

/* Alternate names for values for the WHENCE argument to `lseek'.
   These are the same as SEEK_SET, SEEK_CUR, and SEEK_END, respectively.  */
// #ifndef L_SET
public static final int L_SET =	0;	/* Seek from beginning of file.  */
public static final int L_INCR =	1;	/* Seek from current position.  */
public static final int L_XTND =	2;	/* Seek from end of file.  */
// #endif


/* Operations for the `flock' call.  */
public static final int LOCK_SH =	1;	/* Shared lock.  */
public static final int LOCK_EX =	2; 	/* Exclusive lock.  */
public static final int LOCK_UN =	8;	/* Unlock.  */

/* Can be OR'd in to one of the above.  */
public static final int LOCK_NB =	4;	/* Don't block when locking.  */


/* Apply or remove an advisory lock, according to OPERATION,
   on the file FD refers to.  */
public static native int flock(int __fd, int __operation);


// #endif /* sys/file.h  */


// Parsed from grp.h

/* Copyright (C) 1991,1992,1995-2001,2003,2004,2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	POSIX Standard: 9.2.1 Group Database Access	<grp.h>
 */

// #ifndef	_GRP_H
public static final int _GRP_H =	1;

// #include <features.h>

// #include <bits/types.h>

// #define __need_size_t
// #include <stddef.h>


/* For the Single Unix specification we must define this type here.  */
// #if (defined __USE_XOPEN || defined __USE_XOPEN2K) && !defined __gid_t_defined
// # define __gid_t_defined
// Targeting ../linux/group.java




// #if defined __USE_SVID || defined __USE_GNU
// # define __need_FILE
// # include <stdio.h>
// #endif


// #if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN_EXTENDED
/* Rewind the group-file stream.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
public static native void setgrent();
// #endif

// #if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN_EXTENDED
//     || defined __USE_XOPEN2K8
/* Close the group-file stream.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
public static native void endgrent();

/* Read an entry from the group-file stream, opening it if necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
public static native group getgrent();
// #endif

// #ifdef	__USE_SVID
/* Read a group entry from STREAM.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
public static native group fgetgrent(@Cast("FILE*") Pointer __stream);
// #endif

// #ifdef __USE_GNU
/* Write the given entry onto the given stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
public static native int putgrent(@Const group __p,
		     @Cast("FILE*") Pointer __f);
// #endif

/* Search for an entry with a matching group ID.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
public static native group getgrgid(@Cast("__gid_t") int __gid);

/* Search for an entry with a matching group name.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
public static native group getgrnam(@Cast("const char*") BytePointer __name);
public static native group getgrnam(String __name);

// #if defined __USE_POSIX || defined __USE_MISC

// # ifdef __USE_MISC
/* Reasonable value for the buffer sized used in the reentrant
   functions below.  But better use `sysconf'.  */
public static final int NSS_BUFLEN_GROUP =	1024;
// # endif

/* Reentrant versions of some of the functions above.

   PLEASE NOTE: the `getgrent_r' function is not (yet) standardized.
   The interface may change in later versions of this library.  But
   the interface is designed following the principals used for the
   other reentrant functions so the chances are good this is what the
   POSIX people would choose.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */

// # ifdef __USE_GNU
public static native int getgrent_r(group __resultbuf,
		       @Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
		       @Cast("group**") PointerPointer __result);
public static native int getgrent_r(group __resultbuf,
		       @Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr group __result);
public static native int getgrent_r(group __resultbuf,
		       @Cast("char*") ByteBuffer __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr group __result);
public static native int getgrent_r(group __resultbuf,
		       @Cast("char*") byte[] __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr group __result);
// # endif

/* Search for an entry with a matching group ID.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
public static native int getgrgid_r(@Cast("__gid_t") int __gid, group __resultbuf,
		       @Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
		       @Cast("group**") PointerPointer __result);
public static native int getgrgid_r(@Cast("__gid_t") int __gid, group __resultbuf,
		       @Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr group __result);
public static native int getgrgid_r(@Cast("__gid_t") int __gid, group __resultbuf,
		       @Cast("char*") ByteBuffer __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr group __result);
public static native int getgrgid_r(@Cast("__gid_t") int __gid, group __resultbuf,
		       @Cast("char*") byte[] __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr group __result);

/* Search for an entry with a matching group name.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
public static native int getgrnam_r(@Cast("const char*") BytePointer __name,
		       group __resultbuf,
		       @Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
		       @Cast("group**") PointerPointer __result);
public static native int getgrnam_r(@Cast("const char*") BytePointer __name,
		       group __resultbuf,
		       @Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr group __result);
public static native int getgrnam_r(String __name,
		       group __resultbuf,
		       @Cast("char*") ByteBuffer __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr group __result);
public static native int getgrnam_r(@Cast("const char*") BytePointer __name,
		       group __resultbuf,
		       @Cast("char*") byte[] __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr group __result);
public static native int getgrnam_r(String __name,
		       group __resultbuf,
		       @Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr group __result);
public static native int getgrnam_r(@Cast("const char*") BytePointer __name,
		       group __resultbuf,
		       @Cast("char*") ByteBuffer __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr group __result);
public static native int getgrnam_r(String __name,
		       group __resultbuf,
		       @Cast("char*") byte[] __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr group __result);

// # ifdef	__USE_SVID
/* Read a group entry from STREAM.  This function is not standardized
   an probably never will.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
public static native int fgetgrent_r(@Cast("FILE*") Pointer __stream,
			group __resultbuf,
			@Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
			@Cast("group**") PointerPointer __result);
public static native int fgetgrent_r(@Cast("FILE*") Pointer __stream,
			group __resultbuf,
			@Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
			@ByPtrPtr group __result);
public static native int fgetgrent_r(@Cast("FILE*") Pointer __stream,
			group __resultbuf,
			@Cast("char*") ByteBuffer __buffer, @Cast("size_t") long __buflen,
			@ByPtrPtr group __result);
public static native int fgetgrent_r(@Cast("FILE*") Pointer __stream,
			group __resultbuf,
			@Cast("char*") byte[] __buffer, @Cast("size_t") long __buflen,
			@ByPtrPtr group __result);
// # endif

// #endif	/* POSIX or reentrant */


// #ifdef	__USE_BSD

// # define __need_size_t
// # include <stddef.h>

/* Set the group set for the current user to GROUPS (N of them).  */
public static native int setgroups(@Cast("size_t") long __n, @Cast("const __gid_t*") IntPointer __groups);
public static native int setgroups(@Cast("size_t") long __n, @Cast("const __gid_t*") IntBuffer __groups);
public static native int setgroups(@Cast("size_t") long __n, @Cast("const __gid_t*") int[] __groups);

/* Store at most *NGROUPS members of the group set for USER into
   *GROUPS.  Also include GROUP.  The actual number of groups found is
   returned in *NGROUPS.  Return -1 if the if *NGROUPS is too small.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
public static native int getgrouplist(@Cast("const char*") BytePointer __user, @Cast("__gid_t") int __group,
			 @Cast("__gid_t*") IntPointer __groups, @Cast("int*") IntPointer __ngroups);
public static native int getgrouplist(String __user, @Cast("__gid_t") int __group,
			 @Cast("__gid_t*") IntBuffer __groups, @Cast("int*") IntBuffer __ngroups);
public static native int getgrouplist(@Cast("const char*") BytePointer __user, @Cast("__gid_t") int __group,
			 @Cast("__gid_t*") int[] __groups, @Cast("int*") int[] __ngroups);
public static native int getgrouplist(String __user, @Cast("__gid_t") int __group,
			 @Cast("__gid_t*") IntPointer __groups, @Cast("int*") IntPointer __ngroups);
public static native int getgrouplist(@Cast("const char*") BytePointer __user, @Cast("__gid_t") int __group,
			 @Cast("__gid_t*") IntBuffer __groups, @Cast("int*") IntBuffer __ngroups);
public static native int getgrouplist(String __user, @Cast("__gid_t") int __group,
			 @Cast("__gid_t*") int[] __groups, @Cast("int*") int[] __ngroups);

/* Initialize the group set for the current user
   by reading the group database and using all groups
   of which USER is a member.  Also include GROUP.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
public static native int initgroups(@Cast("const char*") BytePointer __user, @Cast("__gid_t") int __group);
public static native int initgroups(String __user, @Cast("__gid_t") int __group);

// #endif /* Use BSD.  */

// #endif /* grp.h  */


// Parsed from pwd.h

/* Copyright (C) 1991,1992,1995-2001,2003,2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	POSIX Standard: 9.2.2 User Database Access	<pwd.h>
 */

// #ifndef	_PWD_H
public static final int _PWD_H =	1;

// #include <features.h>

// #include <bits/types.h>

// #define __need_size_t
// #include <stddef.h>

// #if defined __USE_XOPEN || defined __USE_XOPEN2K
/* The Single Unix specification says that some more types are
   available here.  */
// # ifndef __gid_t_defined
// #  define __gid_t_defined
// # endif

// # ifndef __uid_t_defined
// #  define __uid_t_defined
// Targeting ../linux/passwd.java




// #if defined __USE_SVID || defined __USE_GNU
// # define __need_FILE
// # include <stdio.h>
// #endif


// #if defined __USE_SVID || defined __USE_MISC || defined __USE_XOPEN_EXTENDED
/* Rewind the password-file stream.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
public static native void setpwent();

/* Close the password-file stream.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
public static native void endpwent();

/* Read an entry from the password-file stream, opening it if necessary.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
public static native passwd getpwent();
// #endif

// #ifdef	__USE_SVID
/* Read an entry from STREAM.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
public static native passwd fgetpwent(@Cast("FILE*") Pointer __stream);

/* Write the given entry onto the given stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
public static native int putpwent(@Const passwd __p,
		     @Cast("FILE*") Pointer __f);
// #endif

/* Search for an entry with a matching user ID.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
public static native passwd getpwuid(@Cast("__uid_t") int __uid);

/* Search for an entry with a matching username.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
public static native passwd getpwnam(@Cast("const char*") BytePointer __name);
public static native passwd getpwnam(String __name);

// #if defined __USE_POSIX || defined __USE_MISC

// # ifdef __USE_MISC
/* Reasonable value for the buffer sized used in the reentrant
   functions below.  But better use `sysconf'.  */
public static final int NSS_BUFLEN_PASSWD =	1024;
// # endif

/* Reentrant versions of some of the functions above.

   PLEASE NOTE: the `getpwent_r' function is not (yet) standardized.
   The interface may change in later versions of this library.  But
   the interface is designed following the principals used for the
   other reentrant functions so the chances are good this is what the
   POSIX people would choose.  */

// # if defined __USE_SVID || defined __USE_MISC
/* This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
public static native int getpwent_r(passwd __resultbuf,
		       @Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
		       @Cast("passwd**") PointerPointer __result);
public static native int getpwent_r(passwd __resultbuf,
		       @Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr passwd __result);
public static native int getpwent_r(passwd __resultbuf,
		       @Cast("char*") ByteBuffer __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr passwd __result);
public static native int getpwent_r(passwd __resultbuf,
		       @Cast("char*") byte[] __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr passwd __result);
// # endif

public static native int getpwuid_r(@Cast("__uid_t") int __uid,
		       passwd __resultbuf,
		       @Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
		       @Cast("passwd**") PointerPointer __result);
public static native int getpwuid_r(@Cast("__uid_t") int __uid,
		       passwd __resultbuf,
		       @Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr passwd __result);
public static native int getpwuid_r(@Cast("__uid_t") int __uid,
		       passwd __resultbuf,
		       @Cast("char*") ByteBuffer __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr passwd __result);
public static native int getpwuid_r(@Cast("__uid_t") int __uid,
		       passwd __resultbuf,
		       @Cast("char*") byte[] __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr passwd __result);

public static native int getpwnam_r(@Cast("const char*") BytePointer __name,
		       passwd __resultbuf,
		       @Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
		       @Cast("passwd**") PointerPointer __result);
public static native int getpwnam_r(@Cast("const char*") BytePointer __name,
		       passwd __resultbuf,
		       @Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr passwd __result);
public static native int getpwnam_r(String __name,
		       passwd __resultbuf,
		       @Cast("char*") ByteBuffer __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr passwd __result);
public static native int getpwnam_r(@Cast("const char*") BytePointer __name,
		       passwd __resultbuf,
		       @Cast("char*") byte[] __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr passwd __result);
public static native int getpwnam_r(String __name,
		       passwd __resultbuf,
		       @Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr passwd __result);
public static native int getpwnam_r(@Cast("const char*") BytePointer __name,
		       passwd __resultbuf,
		       @Cast("char*") ByteBuffer __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr passwd __result);
public static native int getpwnam_r(String __name,
		       passwd __resultbuf,
		       @Cast("char*") byte[] __buffer, @Cast("size_t") long __buflen,
		       @ByPtrPtr passwd __result);


// # ifdef	__USE_SVID
/* Read an entry from STREAM.  This function is not standardized and
   probably never will.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */
public static native int fgetpwent_r(@Cast("FILE*") Pointer __stream,
			passwd __resultbuf,
			@Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
			@Cast("passwd**") PointerPointer __result);
public static native int fgetpwent_r(@Cast("FILE*") Pointer __stream,
			passwd __resultbuf,
			@Cast("char*") BytePointer __buffer, @Cast("size_t") long __buflen,
			@ByPtrPtr passwd __result);
public static native int fgetpwent_r(@Cast("FILE*") Pointer __stream,
			passwd __resultbuf,
			@Cast("char*") ByteBuffer __buffer, @Cast("size_t") long __buflen,
			@ByPtrPtr passwd __result);
public static native int fgetpwent_r(@Cast("FILE*") Pointer __stream,
			passwd __resultbuf,
			@Cast("char*") byte[] __buffer, @Cast("size_t") long __buflen,
			@ByPtrPtr passwd __result);
// # endif

// #endif	/* POSIX or reentrant */

// #ifdef __USE_GNU
/* Re-construct the password-file line for the given uid
   in the given buffer.  This knows the format that the caller
   will expect, but this need not be the format of the password file.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */

// #endif

// #endif /* pwd.h  */


// Parsed from bits/siginfo.h

/* siginfo_t, sigevent and constants.  Linux version.
   Copyright (C) 1997-2002, 2003 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #if !defined _SIGNAL_H && !defined __need_siginfo_t
//     && !defined __need_sigevent_t
// # error "Never include this file directly.  Use <signal.h> instead"
// #endif

// #include <bits/wordsize.h>

// #if (!defined __have_sigval_t
//      && (defined _SIGNAL_H || defined __need_siginfo_t
// 	 || defined __need_sigevent_t))
public static final int __have_sigval_t =	1;
// Targeting ../linux/sigval.java


// #endif

// #if (!defined __have_siginfo_t
//      && (defined _SIGNAL_H || defined __need_siginfo_t))
public static final int __have_siginfo_t =	1;

public static final int __SI_MAX_SIZE =     128;
// # if __WORDSIZE == 64
public static native @MemberGetter int __SI_PAD_SIZE();
public static final int __SI_PAD_SIZE = __SI_PAD_SIZE();
// Targeting ../linux/siginfo_t.java




/* X/Open requires some more fields with fixed names.  */


/* Values for `si_code'.  Positive values are reserved for kernel-generated
   signals.  */
/** enum  */
public static final int
  SI_ASYNCNL = -60,		/* Sent by asynch name lookup completion.  */
// # define SI_ASYNCNL	SI_ASYNCNL
  SI_TKILL = -6,		/* Sent by tkill.  */
// # define SI_TKILL	SI_TKILL
  SI_SIGIO = -5,			/* Sent by queued SIGIO. */
// # define SI_SIGIO	SI_SIGIO
  SI_ASYNCIO = -4,			/* Sent by AIO completion.  */
// # define SI_ASYNCIO	SI_ASYNCIO
  SI_MESGQ = -3,			/* Sent by real time mesq state change.  */
// # define SI_MESGQ	SI_MESGQ
  SI_TIMER = -2,			/* Sent by timer expiration.  */
// # define SI_TIMER	SI_TIMER
  SI_QUEUE = -1,			/* Sent by sigqueue.  */
// # define SI_QUEUE	SI_QUEUE
  SI_USER = 0,			/* Sent by kill, sigsend, raise.  */
// # define SI_USER	SI_USER
  SI_KERNEL = 0x80;		/* Send by kernel.  */
// #define SI_KERNEL	SI_KERNEL


/* `si_code' values for SIGILL signal.  */
/** enum  */
public static final int
  ILL_ILLOPC = 1,		/* Illegal opcode.  */
// # define ILL_ILLOPC	ILL_ILLOPC
  ILL_ILLOPN = 2,			/* Illegal operand.  */
// # define ILL_ILLOPN	ILL_ILLOPN
  ILL_ILLADR = 3,			/* Illegal addressing mode.  */
// # define ILL_ILLADR	ILL_ILLADR
  ILL_ILLTRP = 4,			/* Illegal trap. */
// # define ILL_ILLTRP	ILL_ILLTRP
  ILL_PRVOPC = 5,			/* Privileged opcode.  */
// # define ILL_PRVOPC	ILL_PRVOPC
  ILL_PRVREG = 6,			/* Privileged register.  */
// # define ILL_PRVREG	ILL_PRVREG
  ILL_COPROC = 7,			/* Coprocessor error.  */
// # define ILL_COPROC	ILL_COPROC
  ILL_BADSTK = 8;			/* Internal stack error.  */
// # define ILL_BADSTK	ILL_BADSTK

/* `si_code' values for SIGFPE signal.  */
/** enum  */
public static final int
  FPE_INTDIV = 1,		/* Integer divide by zero.  */
// # define FPE_INTDIV	FPE_INTDIV
  FPE_INTOVF = 2,			/* Integer overflow.  */
// # define FPE_INTOVF	FPE_INTOVF
  FPE_FLTDIV = 3,			/* Floating point divide by zero.  */
// # define FPE_FLTDIV	FPE_FLTDIV
  FPE_FLTOVF = 4,			/* Floating point overflow.  */
// # define FPE_FLTOVF	FPE_FLTOVF
  FPE_FLTUND = 5,			/* Floating point underflow.  */
// # define FPE_FLTUND	FPE_FLTUND
  FPE_FLTRES = 6,			/* Floating point inexact result.  */
// # define FPE_FLTRES	FPE_FLTRES
  FPE_FLTINV = 7,			/* Floating point invalid operation.  */
// # define FPE_FLTINV	FPE_FLTINV
  FPE_FLTSUB = 8;			/* Subscript out of range.  */
// # define FPE_FLTSUB	FPE_FLTSUB

/* `si_code' values for SIGSEGV signal.  */
/** enum  */
public static final int
  SEGV_MAPERR = 1,		/* Address not mapped to object.  */
// # define SEGV_MAPERR	SEGV_MAPERR
  SEGV_ACCERR = 2;			/* Invalid permissions for mapped object.  */
// # define SEGV_ACCERR	SEGV_ACCERR

/* `si_code' values for SIGBUS signal.  */
/** enum  */
public static final int
  BUS_ADRALN = 1,		/* Invalid address alignment.  */
// # define BUS_ADRALN	BUS_ADRALN
  BUS_ADRERR = 2,			/* Non-existant physical address.  */
// # define BUS_ADRERR	BUS_ADRERR
  BUS_OBJERR = 3;			/* Object specific hardware error.  */
// # define BUS_OBJERR	BUS_OBJERR

/* `si_code' values for SIGTRAP signal.  */
/** enum  */
public static final int
  TRAP_BRKPT = 1,		/* Process breakpoint.  */
// # define TRAP_BRKPT	TRAP_BRKPT
  TRAP_TRACE = 2;			/* Process trace trap.  */
// # define TRAP_TRACE	TRAP_TRACE

/* `si_code' values for SIGCHLD signal.  */
/** enum  */
public static final int
  CLD_EXITED = 1,		/* Child has exited.  */
// # define CLD_EXITED	CLD_EXITED
  CLD_KILLED = 2,			/* Child was killed.  */
// # define CLD_KILLED	CLD_KILLED
  CLD_DUMPED = 3,			/* Child terminated abnormally.  */
// # define CLD_DUMPED	CLD_DUMPED
  CLD_TRAPPED = 4,			/* Traced child has trapped.  */
// # define CLD_TRAPPED	CLD_TRAPPED
  CLD_STOPPED = 5,			/* Child has stopped.  */
// # define CLD_STOPPED	CLD_STOPPED
  CLD_CONTINUED = 6;			/* Stopped child has continued.  */
// # define CLD_CONTINUED	CLD_CONTINUED

/* `si_code' values for SIGPOLL signal.  */
/** enum  */
public static final int
  POLL_IN = 1,			/* Data input available.  */
// # define POLL_IN	POLL_IN
  POLL_OUT = 2,			/* Output buffers available.  */
// # define POLL_OUT	POLL_OUT
  POLL_MSG = 3,			/* Input message available.   */
// # define POLL_MSG	POLL_MSG
  POLL_ERR = 4,			/* I/O error.  */
// # define POLL_ERR	POLL_ERR
  POLL_PRI = 5,			/* High priority input available.  */
// # define POLL_PRI	POLL_PRI
  POLL_HUP = 6;			/* Device disconnected.  */
// # define POLL_HUP	POLL_HUP

// # undef __need_siginfo_t
// #endif	/* !have siginfo_t && (have _SIGNAL_H || need siginfo_t).  */


// #if (defined _SIGNAL_H || defined __need_sigevent_t)
//     && !defined __have_sigevent_t
public static final int __have_sigevent_t =	1;

/* Structure to transport application-defined values with signals.  */
public static final int __SIGEV_MAX_SIZE =	64;
// # if __WORDSIZE == 64
public static native @MemberGetter int __SIGEV_PAD_SIZE();
public static final int __SIGEV_PAD_SIZE = __SIGEV_PAD_SIZE();
// Targeting ../linux/sigevent_t.java



/* POSIX names to access some of the members.  */
// # define sigev_notify_function   _sigev_un._sigev_thread._function
// # define sigev_notify_attributes _sigev_un._sigev_thread._attribute

/* `sigev_notify' values.  */
/** enum  */
public static final int
  SIGEV_SIGNAL = 0,		/* Notify via signal.  */
// # define SIGEV_SIGNAL	SIGEV_SIGNAL
  SIGEV_NONE = 1,			/* Other notification: meaningless.  */
// # define SIGEV_NONE	SIGEV_NONE
  SIGEV_THREAD = 2,			/* Deliver via thread creation.  */
// # define SIGEV_THREAD	SIGEV_THREAD

  SIGEV_THREAD_ID = 4;		/* Send signal to specific thread.  */
// #define SIGEV_THREAD_ID	SIGEV_THREAD_ID

// #endif	/* have _SIGNAL_H.  */


// Parsed from bits/sigset.h

/* __sig_atomic_t, __sigset_t, and related definitions.  Linux version.
   Copyright (C) 1991, 1992, 1994, 1996, 1997, 2007
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef	_SIGSET_H_types
public static final int _SIGSET_H_types =	1;

/* A `sigset_t' has a bit for each signal.  */

public static native @MemberGetter int _SIGSET_NWORDS();
public static final int _SIGSET_NWORDS = _SIGSET_NWORDS();
// Targeting ../linux/sigset_t.java



// #endif


/* We only want to define these functions if <signal.h> was actually
   included; otherwise we were included just to define the types.  Since we
   are namespace-clean, it wouldn't hurt to define extra macros.  But
   trouble can be caused by functions being defined (e.g., any global
   register vars declared later will cause compilation errors).  */

// #if !defined _SIGSET_H_fns && defined _SIGNAL_H
public static final int _SIGSET_H_fns = 1;

// # ifndef _EXTERN_INLINE
// #  define _EXTERN_INLINE __extern_inline
// # endif

/* Return a mask that includes the bit for SIG only.  */
// # define __sigmask(sig)
//   (((unsigned long int) 1) << (((sig) - 1) % (8 * sizeof (unsigned long int))))

/* Return the word index for SIG.  */
// # define __sigword(sig)	(((sig) - 1) / (8 * sizeof (unsigned long int)))

// # if defined __GNUC__ && __GNUC__ >= 2
// #  define __sigemptyset(set)
//   (__extension__ ({ int __cnt = _SIGSET_NWORDS;
// 		    sigset_t *__set = (set);
// 		    while (--__cnt >= 0) __set->__val[__cnt] = 0;
// 		    0; }))
// #  define __sigfillset(set)
//   (__extension__ ({ int __cnt = _SIGSET_NWORDS;
// 		    sigset_t *__set = (set);
// 		    while (--__cnt >= 0) __set->__val[__cnt] = ~0L;
// 		    0; }))

// #  ifdef __USE_GNU
/* The POSIX does not specify for handling the whole signal set in one
   command.  This is often wanted and so we define three more functions
   here.  */
// #   define __sigisemptyset(set)
//   (__extension__ ({ int __cnt = _SIGSET_NWORDS;
// 		    const sigset_t *__set = (set);
// 		    int __ret = __set->__val[--__cnt];
// 		    while (!__ret && --__cnt >= 0)
// 			__ret = __set->__val[__cnt];
// 		    __ret == 0; }))
// #   define __sigandset(dest, left, right)
//   (__extension__ ({ int __cnt = _SIGSET_NWORDS;
// 		    sigset_t *__dest = (dest);
// 		    const sigset_t *__left = (left);
// 		    const sigset_t *__right = (right);
// 		    while (--__cnt >= 0)
// 		      __dest->__val[__cnt] = (__left->__val[__cnt]
// 					      & __right->__val[__cnt]);
// 		    0; }))
// #   define __sigorset(dest, left, right)
//   (__extension__ ({ int __cnt = _SIGSET_NWORDS;
// 		    sigset_t *__dest = (dest);
// 		    const sigset_t *__left = (left);
// 		    const sigset_t *__right = (right);
// 		    while (--__cnt >= 0)
// 		      __dest->__val[__cnt] = (__left->__val[__cnt]
// 					      | __right->__val[__cnt]);
// 		    0; }))
// #  endif
// # endif

/* These functions needn't check for a bogus signal number -- error
   checking is done in the non __ versions.  */

public static native int __sigismember(@Const sigset_t arg0, int arg1);
public static native int __sigaddset(sigset_t arg0, int arg1);
public static native int __sigdelset(sigset_t arg0, int arg1);

// # ifdef __USE_EXTERN_INLINES
// # endif


// #endif /* ! _SIGSET_H_fns.  */


// Parsed from bits/signum.h

/* Signal number definitions.  Linux version.
   Copyright (C) 1995,1996,1997,1998,1999,2003 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifdef	_SIGNAL_H

/* Fake signal functions.  */
public static native @MemberGetter __sighandler_t SIG_ERR();
public static final __sighandler_t SIG_ERR = SIG_ERR();		/* Error return.  */
public static native @MemberGetter __sighandler_t SIG_DFL();
public static final __sighandler_t SIG_DFL = SIG_DFL();		/* Default action.  */
public static native @MemberGetter __sighandler_t SIG_IGN();
public static final __sighandler_t SIG_IGN = SIG_IGN();		/* Ignore signal.  */

// #ifdef __USE_UNIX98
public static native @MemberGetter __sighandler_t SIG_HOLD();
public static final __sighandler_t SIG_HOLD = SIG_HOLD();	/* Add signal to hold mask.  */
// #endif


/* Signals.  */
public static final int SIGHUP =		1;	/* Hangup (POSIX).  */
public static final int SIGINT =		2;	/* Interrupt (ANSI).  */
public static final int SIGQUIT =		3;	/* Quit (POSIX).  */
public static final int SIGILL =		4;	/* Illegal instruction (ANSI).  */
public static final int SIGTRAP =		5;	/* Trace trap (POSIX).  */
public static final int SIGABRT =		6;	/* Abort (ANSI).  */
public static final int SIGIOT =		6;	/* IOT trap (4.2 BSD).  */
public static final int SIGBUS =		7;	/* BUS error (4.2 BSD).  */
public static final int SIGFPE =		8;	/* Floating-point exception (ANSI).  */
public static final int SIGKILL =		9;	/* Kill, unblockable (POSIX).  */
public static final int SIGUSR1 =		10;	/* User-defined signal 1 (POSIX).  */
public static final int SIGSEGV =		11;	/* Segmentation violation (ANSI).  */
public static final int SIGUSR2 =		12;	/* User-defined signal 2 (POSIX).  */
public static final int SIGPIPE =		13;	/* Broken pipe (POSIX).  */
public static final int SIGALRM =		14;	/* Alarm clock (POSIX).  */
public static final int SIGTERM =		15;	/* Termination (ANSI).  */
public static final int SIGSTKFLT =	16;	/* Stack fault.  */
public static native @MemberGetter int SIGCLD();
public static final int SIGCLD = SIGCLD();	/* Same as SIGCHLD (System V).  */
public static final int SIGCHLD =		17;	/* Child status has changed (POSIX).  */
public static final int SIGCONT =		18;	/* Continue (POSIX).  */
public static final int SIGSTOP =		19;	/* Stop, unblockable (POSIX).  */
public static final int SIGTSTP =		20;	/* Keyboard stop (POSIX).  */
public static final int SIGTTIN =		21;	/* Background read from tty (POSIX).  */
public static final int SIGTTOU =		22;	/* Background write to tty (POSIX).  */
public static final int SIGURG =		23;	/* Urgent condition on socket (4.2 BSD).  */
public static final int SIGXCPU =		24;	/* CPU limit exceeded (4.2 BSD).  */
public static final int SIGXFSZ =		25;	/* File size limit exceeded (4.2 BSD).  */
public static final int SIGVTALRM =	26;	/* Virtual alarm clock (4.2 BSD).  */
public static final int SIGPROF =		27;	/* Profiling alarm clock (4.2 BSD).  */
public static final int SIGWINCH =	28;	/* Window size change (4.3 BSD, Sun).  */
public static native @MemberGetter int SIGPOLL();
public static final int SIGPOLL = SIGPOLL();	/* Pollable event occurred (System V).  */
public static final int SIGIO =		29;	/* I/O now possible (4.2 BSD).  */
public static final int SIGPWR =		30;	/* Power failure restart (System V).  */
public static final int SIGSYS =		31;	/* Bad system call.  */
public static final int SIGUNUSED =	31;

public static final int _NSIG =		65;	/* Biggest signal number + 1
				   (including real-time signals).  */

public static native @MemberGetter int SIGRTMIN();
public static final int SIGRTMIN = SIGRTMIN();
public static native @MemberGetter int SIGRTMAX();
public static final int SIGRTMAX = SIGRTMAX();

/* These are the hard limits of the kernel.  These values should not be
   used directly at user level.  */
public static final int __SIGRTMIN =	32;
public static final int __SIGRTMAX =	(_NSIG - 1);

// #endif	/* <signal.h> included.  */


// Parsed from bits/sigaction.h

/* The proper definitions for Linux's sigaction.
   Copyright (C) 1993-1999, 2000, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef _SIGNAL_H
// # error "Never include <bits/sigaction.h> directly; use <signal.h> instead."
// Targeting ../linux/sigaction.java



/* Bits in `sa_flags'.  */
public static final int SA_NOCLDSTOP =  1;		 /* Don't send SIGCHLD when children stop.  */
public static final int SA_NOCLDWAIT =  2;		 /* Don't create zombie on child death.  */
public static final int SA_SIGINFO =    4;		 /* Invoke signal-catching function with
				    three arguments instead of one.  */
// #if defined __USE_UNIX98 || defined __USE_MISC
public static final int SA_ONSTACK =   0x08000000; /* Use signal stack by using `sa_restorer'. */
// #endif
// #if defined __USE_UNIX98 || defined __USE_MISC || defined __USE_XOPEN2K8
public static final int SA_RESTART =   0x10000000; /* Restart syscall on signal return.  */
public static final int SA_NODEFER =   0x40000000; /* Don't automatically block the signal when
				    its handler is being executed.  */
public static final int SA_RESETHAND = 0x80000000; /* Reset to SIG_DFL on entry to handler.  */
// #endif
// #ifdef __USE_MISC
public static final int SA_INTERRUPT = 0x20000000; /* Historical no-op.  */

/* Some aliases for the SA_ constants.  */
public static final int SA_NOMASK =    SA_NODEFER;
public static final int SA_ONESHOT =   SA_RESETHAND;
public static final int SA_STACK =     SA_ONSTACK;
// #endif

/* Values for the HOW argument to `sigprocmask'.  */
public static final int SIG_BLOCK =     0;		 /* Block signals.  */
public static final int SIG_UNBLOCK =   1;		 /* Unblock signals.  */
public static final int SIG_SETMASK =   2;		 /* Set the set of blocked signals.  */


// Parsed from bits/sigcontext.h

/* Copyright (C) 2002 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef _BITS_SIGCONTEXT_H
public static final int _BITS_SIGCONTEXT_H =  1;

// #if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
// # error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
// #endif

// #include <bits/wordsize.h>



// #if __WORDSIZE == 32

// #else /* __WORDSIZE == 64 */

// #endif /* __WORDSIZE == 64 */

// #endif /* _BITS_SIGCONTEXT_H */


// Parsed from bits/sigstack.h

/* sigstack, sigaltstack definitions.
   Copyright (C) 1998, 1999 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef _SIGNAL_H
// # error "Never include this file directly.  Use <signal.h> instead"
// Targeting ../linux/sigstack.java




/* Possible values for `ss_flags.'.  */
/** enum  */
public static final int
  SS_ONSTACK = 1,
// #define SS_ONSTACK	SS_ONSTACK
  SS_DISABLE = 2;
// #define SS_DISABLE	SS_DISABLE

/* Minimum stack size for a signal handler.  */
public static final int MINSIGSTKSZ =	2048;

/* System default stack size.  */
public static final int SIGSTKSZ =	8192;
// Targeting ../linux/stack_t.java




// Parsed from signal.h

/* Copyright (C) 1991-2004, 2007, 2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	ISO C99 Standard: 7.14 Signal handling <signal.h>
 */


// #include <features.h>

// #include <bits/sigset.h>		/* __sigset_t, __sig_atomic_t.  */

/* An integral type that can be modified atomically, without the
   possibility of a signal arriving in the middle of the operation.  */
// #if defined __need_sig_atomic_t || defined _SIGNAL_H
// # ifndef __sig_atomic_t_defined
// #  define __sig_atomic_t_defined
// # endif
// # undef __need_sig_atomic_t
// #endif

// #if defined __need_sigset_t || (defined _SIGNAL_H && defined __USE_POSIX)
// # ifndef __sigset_t_defined
// #  define __sigset_t_defined
// # endif
// # undef __need_sigset_t
// #endif

// #ifdef _SIGNAL_H

// #include <bits/types.h>
// #include <bits/signum.h>

// #if defined __USE_XOPEN || defined __USE_XOPEN2K
// # ifndef __pid_t_defined
// #  define __pid_t_defined
// #endif
// #ifdef __USE_XOPEN
// # endif
// # ifndef __uid_t_defined
// #  define __uid_t_defined
// Targeting ../linux/__sighandler_t.java



/* The X/Open definition of `signal' specifies the SVID semantic.  Use
   the additional function `sysv_signal' when X/Open compatibility is
   requested.  */
public static native __sighandler_t __sysv_signal(int __sig, __sighandler_t __handler);
// #ifdef __USE_GNU
public static native __sighandler_t sysv_signal(int __sig, __sighandler_t __handler);
// #endif

/* Set the handler for the signal SIG to HANDLER, returning the old
   handler, or SIG_ERR on error.
   By default `signal' has the BSD semantic.  */
// #ifdef __USE_BSD
public static native __sighandler_t signal(int __sig, __sighandler_t __handler);
// #else
// #endif
// #ifdef __USE_XOPEN
/* The X/Open definition of `signal' conflicts with the BSD version.
   So they defined another function `bsd_signal'.  */
public static native __sighandler_t bsd_signal(int __sig, __sighandler_t __handler);
// #endif

/* Send signal SIG to process number PID.  If PID is zero,
   send SIG to all processes in the current process's process group.
   If PID is < -1, send SIG to all processes in process group - PID.  */
// #ifdef __USE_POSIX
public static native int kill(@Cast("__pid_t") int __pid, int __sig);
// #endif /* Use POSIX.  */

// #if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
/* Send SIG to all processes in process group PGRP.
   If PGRP is zero, send SIG to all processes in
   the current process's process group.  */
public static native int killpg(@Cast("__pid_t") int __pgrp, int __sig);
// #endif /* Use BSD || X/Open Unix.  */

/* Raise signal SIG, i.e., send SIG to yourself.  */
public static native int raise(int __sig);
// #ifdef __USE_SVID
/* SVID names for the same things.  */
public static native __sighandler_t ssignal(int __sig, __sighandler_t __handler);
public static native int gsignal(int __sig);
// #endif /* Use SVID.  */

// #if defined __USE_MISC || defined __USE_XOPEN2K
/* Print a message describing the meaning of the given signal number.  */
public static native void psignal(int __sig, @Cast("const char*") BytePointer __s);
public static native void psignal(int __sig, String __s);
// #endif /* Use misc or POSIX 2008.  */

// #ifdef __USE_XOPEN2K
/* Print a message describing the meaning of the given signal information.  */
public static native void psiginfo(@Const siginfo_t __pinfo, @Cast("const char*") BytePointer __s);
public static native void psiginfo(@Const siginfo_t __pinfo, String __s);
// #endif /* POSIX 2008.  */



/* The `sigpause' function has two different interfaces.  The original
   BSD definition defines the argument as a mask of the signal, while
   the more modern interface in X/Open defines it as the signal
   number.  We go with the BSD version unless the user explicitly
   selects the X/Open version.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native int __sigpause(int __sig_or_mask, int __is_sig);

// #ifdef __FAVOR_BSD
/* Set the mask of blocked signals to MASK,
   wait for a signal to arrive, and then restore the mask.  */
public static native int sigpause(int __mask);
// #else
// # ifdef __USE_XOPEN
// #  ifdef __GNUC__
// #  else
// #  endif
// # endif
// #endif


// #ifdef __USE_BSD
/* None of the following functions should be used anymore.  They are here
   only for compatibility.  A single word (`int') is not guaranteed to be
   enough to hold a complete signal mask and therefore these functions
   simply do not work in many situations.  Use `sigprocmask' instead.  */

/* Compute mask for signal SIG.  */
// # define sigmask(sig)	__sigmask(sig)

/* Block signals in MASK, returning the old mask.  */


/* Set the mask of blocked signals to MASK, returning the old mask.  */


/* Return currently selected signal mask.  */

// #endif /* Use BSD.  */


// #ifdef __USE_MISC
public static native @MemberGetter long NSIG();
public static final long NSIG = NSIG();
// #endif

// #ifdef __USE_GNU
// #endif

/* 4.4 BSD uses the name `sig_t' for this.  */
// #ifdef __USE_BSD
// #endif

// #ifdef __USE_POSIX

/* Clear all signals from SET.  */
public static native int sigemptyset(sigset_t __set);

/* Set all signals in SET.  */
public static native int sigfillset(sigset_t __set);

/* Add SIGNO to SET.  */
public static native int sigaddset(sigset_t __set, int __signo);

/* Remove SIGNO from SET.  */
public static native int sigdelset(sigset_t __set, int __signo);

/* Return 1 if SIGNO is in SET, 0 if not.  */
public static native int sigismember(@Const sigset_t __set, int __signo);

// # ifdef __USE_GNU
/* Return non-empty value is SET is not empty.  */
public static native int sigisemptyset(@Const sigset_t __set);

/* Build new signal set by combining the two inputs set using logical AND.  */
public static native int sigandset(sigset_t __set, @Const sigset_t __left,
		      @Const sigset_t __right);

/* Build new signal set by combining the two inputs set using logical OR.  */
public static native int sigorset(sigset_t __set, @Const sigset_t __left,
		     @Const sigset_t __right);
// # endif /* GNU */

/* Get the system-specific definitions of `struct sigaction'
   and the `SA_*' and `SIG_*'. constants.  */
// # include <bits/sigaction.h>

/* Get and/or change the set of blocked signals.  */
public static native int sigprocmask(int __how, @Const sigset_t __set,
			sigset_t __oset);

/* Change the set of blocked signals to SET,
   wait until a signal arrives, and restore the set of blocked signals.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native int sigsuspend(@Const sigset_t __set);

/* Get and/or set the action for signal SIG.  */
public static native int sigaction(int __sig, @Const sigaction __act,
		      sigaction __oact);

/* Put in SET all signals that are blocked and waiting to be delivered.  */
public static native int sigpending(sigset_t __set);


/* Select any of pending signals from SET or wait for any to arrive.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native int sigwait(@Const sigset_t __set, @Cast("int*") IntPointer __sig);
public static native int sigwait(@Const sigset_t __set, @Cast("int*") IntBuffer __sig);
public static native int sigwait(@Const sigset_t __set, @Cast("int*") int[] __sig);

// # ifdef __USE_POSIX199309
// # endif	/* Use POSIX 199306.  */

// #endif /* Use POSIX.  */

// #ifdef __USE_BSD

/* Names of the signals.  This variable exists only for compatibility.
   Use `strsignal' instead (see <string.h>).  */
@MemberGetter public static native @Cast("const char*") BytePointer _sys_siglist(int i);
@MemberGetter public static native @Cast("const char*__const*") PointerPointer _sys_siglist();
@MemberGetter public static native @Cast("const char*") BytePointer sys_siglist(int i);
@MemberGetter public static native @Cast("const char*__const*") PointerPointer sys_siglist();
// Targeting ../linux/sigvec.java



/* Bits in `sv_flags'.  */
public static final int SV_ONSTACK =	(1 << 0);/* Take the signal on the signal stack.  */
public static final int SV_INTERRUPT =	(1 << 1);/* Do not restart system calls.  */
public static final int SV_RESETHAND =	(1 << 2);/* Reset handler to SIG_DFL on receipt.  */


/* If VEC is non-NULL, set the handler for SIG to the `sv_handler' member
   of VEC.  The signals in `sv_mask' will be blocked while the handler runs.
   If the SV_RESETHAND bit is set in `sv_flags', the handler for SIG will be
   reset to SIG_DFL before `sv_handler' is entered.  If OVEC is non-NULL,
   it is filled in with the old information for SIG.  */
public static native int sigvec(int __sig, @Const sigvec __vec,
		   sigvec __ovec);


/* Get machine-dependent `struct sigcontext' and signal subcodes.  */
// # include <bits/sigcontext.h>

/* Restore the state saved in SCP.  */


// #endif /*  use BSD.  */


// #if defined __USE_BSD || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
// # define __need_size_t
// # include <stddef.h>

/* If INTERRUPT is nonzero, make signal SIG interrupt system calls
   (causing them to fail with EINTR); if INTERRUPT is zero, make system
   calls be restarted after signal SIG.  */
public static native int siginterrupt(int __sig, int __interrupt);

// # include <bits/sigstack.h>
// # if defined __USE_XOPEN || defined __USE_XOPEN2K8
/* This will define `ucontext_t' and `mcontext_t'.  */
// #  include <sys/ucontext.h>
// # endif

/* Run signals handlers on the stack specified by SS (if not NULL).
   If OSS is not NULL, it is filled in with the old signal stack status.
   This interface is obsolete and on many platform not implemented.  */


/* Alternate signal handler stack interface.
   This interface should always be preferred over `sigstack'.  */
public static native int sigaltstack(@Const stack_t __ss,
			stack_t __oss);

// #endif /* use BSD or X/Open Unix.  */

// #ifdef __USE_XOPEN_EXTENDED
/* Simplified interface for signal management.  */

/* Add SIG to the calling process' signal mask.  */
public static native int sighold(int __sig);

/* Remove SIG from the calling process' signal mask.  */
public static native int sigrelse(int __sig);

/* Set the disposition of SIG to SIG_IGN.  */
public static native int sigignore(int __sig);

/* Set the disposition of SIG.  */
public static native __sighandler_t sigset(int __sig, __sighandler_t __disp);
// #endif

// #if defined __USE_POSIX199506 || defined __USE_UNIX98
/* Some of the functions for handling signals in threaded programs must
   be defined here.  */
// # include <bits/pthreadtypes.h>
// # include <bits/sigthread.h>
// #endif /* use Unix98 */

/* The following functions are used internally in the C library and in
   other code which need deep insights.  */

/* Return number of available real-time signal with highest priority.  */
public static native int __libc_current_sigrtmin();
/* Return number of available real-time signal with lowest priority.  */
public static native int __libc_current_sigrtmax();

// #endif /* signal.h  */

// #endif /* not signal.h */


// Parsed from sys/ucontext.h

/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef _SYS_UCONTEXT_H
public static final int _SYS_UCONTEXT_H =	1;

// #include <features.h>
// #include <signal.h>
// #include <bits/wordsize.h>

/* We need the signal context definitions even if they are not used
   included in <signal.h>.  */
// #include <bits/sigcontext.h>

// #if __WORDSIZE == 64

/* Type for general register.  */

/* Number of general registers.  */
public static final int NGREG =	23;

/* Container for all general registers.  */

// #ifdef __USE_GNU
/* Number of each register in the `gregset_t' array.  */
/** enum  */
public static final int
  REG_R8 = 0,
// # define REG_R8		REG_R8
  REG_R9 = 1,
// # define REG_R9		REG_R9
  REG_R10 = 2,
// # define REG_R10	REG_R10
  REG_R11 = 3,
// # define REG_R11	REG_R11
  REG_R12 = 4,
// # define REG_R12	REG_R12
  REG_R13 = 5,
// # define REG_R13	REG_R13
  REG_R14 = 6,
// # define REG_R14	REG_R14
  REG_R15 = 7,
// # define REG_R15	REG_R15
  REG_RDI = 8,
// # define REG_RDI	REG_RDI
  REG_RSI = 9,
// # define REG_RSI	REG_RSI
  REG_RBP = 10,
// # define REG_RBP	REG_RBP
  REG_RBX = 11,
// # define REG_RBX	REG_RBX
  REG_RDX = 12,
// # define REG_RDX	REG_RDX
  REG_RAX = 13,
// # define REG_RAX	REG_RAX
  REG_RCX = 14,
// # define REG_RCX	REG_RCX
  REG_RSP = 15,
// # define REG_RSP	REG_RSP
  REG_RIP = 16,
// # define REG_RIP	REG_RIP
  REG_EFL = 17,
// # define REG_EFL	REG_EFL
  REG_CSGSFS = 18,		/* Actually short cs, gs, fs, __pad0.  */
// # define REG_CSGSFS	REG_CSGSFS
  REG_ERR = 19,
// # define REG_ERR	REG_ERR
  REG_TRAPNO = 20,
// # define REG_TRAPNO	REG_TRAPNO
  REG_OLDMASK = 21,
// # define REG_OLDMASK	REG_OLDMASK
  REG_CR2 = 22;
// # define REG_CR2	REG_CR2
// #endif

/* Structure to describe FPU registers.  */
// Targeting ../linux/mcontext_t.java


// Targeting ../linux/ucontext_t.java



// #else /* __WORDSIZE == 32 */

// #endif /* __WORDSIZE == 32 */

// #endif /* sys/ucontext.h */


// Parsed from ucontext.h

/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/* System V ABI compliant user-level context switching support.  */

// #ifndef _UCONTEXT_H
public static final int _UCONTEXT_H =	1;

// #include <features.h>

/* Get machine dependent definition of data structures.  */
// #include <sys/ucontext.h>

/* Get user context and store it in variable pointed to by UCP.  */
public static native int getcontext(ucontext_t __ucp);

/* Set user context from information of variable pointed to by UCP.  */
public static native int setcontext(@Const ucontext_t __ucp);

/* Save current context in context variable pointed to by OUCP and set
   context from variable pointed to by UCP.  */
public static native int swapcontext(ucontext_t __oucp,
			@Const ucontext_t __ucp);

/* Manipulate user context UCP to continue with calling functions FUNC
   and the ARGC-1 parameters following ARGC when the context is used
   the next time in `setcontext' or `swapcontext'.

   We cannot say anything about the parameters FUNC takes; `void'
   is as good as any other choice.  */
public static native void makecontext(ucontext_t __ucp, __func __func,
			 int __argc);

// #endif /* ucontext.h */


// Parsed from bits/sched.h

/* Definitions of constants and data structure for POSIX 1003.1b-1993
   scheduling interface.
   Copyright (C) 1996-1999,2001-2003,2005,2006,2007,2008,2009
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef __need_schedparam

// #ifndef _SCHED_H
// # error "Never include <bits/sched.h> directly; use <sched.h> instead."
// #endif


/* Scheduling algorithms.  */
public static final int SCHED_OTHER =		0;
public static final int SCHED_FIFO =		1;
public static final int SCHED_RR =		2;
// #ifdef __USE_GNU
public static final int SCHED_BATCH =		3;
public static final int SCHED_IDLE =		5;

public static final int SCHED_RESET_ON_FORK =	0x40000000;
// #endif

// #ifdef __USE_MISC
/* Cloning flags.  */
public static final int CSIGNAL =       0x000000ff; /* Signal mask to be sent at exit.  */
public static final int CLONE_VM =      0x00000100; /* Set if VM shared between processes.  */
public static final int CLONE_FS =      0x00000200; /* Set if fs info shared between processes.  */
public static final int CLONE_FILES =   0x00000400; /* Set if open files shared between processes.  */
public static final int CLONE_SIGHAND = 0x00000800; /* Set if signal handlers shared.  */
public static final int CLONE_PTRACE =  0x00002000; /* Set if tracing continues on the child.  */
public static final int CLONE_VFORK =   0x00004000; /* Set if the parent wants the child to
				     wake it up on mm_release.  */
public static final int CLONE_PARENT =  0x00008000; /* Set if we want to have the same
				     parent as the cloner.  */
public static final int CLONE_THREAD =  0x00010000; /* Set to add to same thread group.  */
public static final int CLONE_NEWNS =   0x00020000; /* Set to create new namespace.  */
public static final int CLONE_SYSVSEM = 0x00040000; /* Set to shared SVID SEM_UNDO semantics.  */
public static final int CLONE_SETTLS =  0x00080000; /* Set TLS info.  */
public static final int CLONE_PARENT_SETTID = 0x00100000; /* Store TID in userlevel buffer
					   before MM copy.  */
public static final int CLONE_CHILD_CLEARTID = 0x00200000; /* Register exit futex and memory
					    location to clear.  */
public static final int CLONE_DETACHED = 0x00400000; /* Create clone detached.  */
public static final int CLONE_UNTRACED = 0x00800000; /* Set if the tracing process can't
				      force CLONE_PTRACE on this clone.  */
public static final int CLONE_CHILD_SETTID = 0x01000000; /* Store TID in userlevel buffer in
					  the child.  */
public static final int CLONE_NEWUTS =	0x04000000;	/* New utsname group.  */
public static final int CLONE_NEWIPC =	0x08000000;	/* New ipcs.  */
public static final int CLONE_NEWUSER =	0x10000000;	/* New user namespace.  */
public static final int CLONE_NEWPID =	0x20000000;	/* New pid namespace.  */
public static final int CLONE_NEWNET =	0x40000000;	/* New network namespace.  */
public static final int CLONE_IO =	0x80000000;
// Targeting ../linux/sched_param.java


// Targeting ../linux/__fn_Pointer.java


public static native int clone(__fn_Pointer __fn, Pointer __child_stack,
		  int __flags, Pointer __arg);

/* Unshare the specified resources.  */
public static native int unshare(int __flags);

/* Get index of currently used CPU.  */
public static native int sched_getcpu();
// #endif

// #endif	/* need schedparam */

// #if !defined __defined_schedparam
//     && (defined __need_schedparam || defined _SCHED_H)
public static final int __defined_schedparam =	1;
// Targeting ../linux/__sched_param.java


// # undef __need_schedparam
// #endif


// #if defined _SCHED_H && !defined __cpu_set_t_defined
// # define __cpu_set_t_defined
/* Size definition for CPU sets.  */
public static final int __CPU_SETSIZE =	1024;
public static native @MemberGetter int __NCPUBITS();
public static final int __NCPUBITS = __NCPUBITS();

/* Type for array elements in 'cpu_set_t'.  */

/* Basic access functions.  */
// # define __CPUELT(cpu)	((cpu) / __NCPUBITS)
// # define __CPUMASK(cpu)	((__cpu_mask) 1 << ((cpu) % __NCPUBITS))
// Targeting ../linux/cpu_set_t.java



/* Access functions for CPU masks.  */
// # if __GNUC_PREREQ (2, 91)
// #  define __CPU_ZERO_S(setsize, cpusetp)
//   do __builtin_memset (cpusetp, '\0', setsize); while (0)
// # else
// #  define __CPU_ZERO_S(setsize, cpusetp)
//   do {
//     size_t __i;
//     size_t __imax = (setsize) / sizeof (__cpu_mask);
//     __cpu_mask *__bits = (cpusetp)->__bits;
//     for (__i = 0; __i < __imax; ++__i)
//       __bits[__i] = 0;
//   } while (0)
// # endif
// # define __CPU_SET_S(cpu, setsize, cpusetp)
//   (__extension__
//    ({ size_t __cpu = (cpu);
//       __cpu < 8 * (setsize)
//       ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]
// 	 |= __CPUMASK (__cpu))
//       : 0; }))
// # define __CPU_CLR_S(cpu, setsize, cpusetp)
//   (__extension__
//    ({ size_t __cpu = (cpu);
//       __cpu < 8 * (setsize)
//       ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]
// 	 &= ~__CPUMASK (__cpu))
//       : 0; }))
// # define __CPU_ISSET_S(cpu, setsize, cpusetp)
//   (__extension__
//    ({ size_t __cpu = (cpu);
//       __cpu < 8 * (setsize)
//       ? ((((__const __cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]
// 	  & __CPUMASK (__cpu))) != 0
//       : 0; }))

// # define __CPU_COUNT_S(setsize, cpusetp)
//   __sched_cpucount (setsize, cpusetp)

// # if __GNUC_PREREQ (2, 91)
// #  define __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2)
//   (__builtin_memcmp (cpusetp1, cpusetp2, setsize) == 0)
// # else
// #  define __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2)
//   (__extension__
//    ({ __const __cpu_mask *__arr1 = (cpusetp1)->__bits;
//       __const __cpu_mask *__arr2 = (cpusetp2)->__bits;
//       size_t __imax = (setsize) / sizeof (__cpu_mask);
//       size_t __i;
//       for (__i = 0; __i < __imax; ++__i)
// 	if (__bits[__i] != __bits[__i])
// 	  break;
//       __i == __imax; }))
// # endif

// # define __CPU_OP_S(setsize, destset, srcset1, srcset2, op)
//   (__extension__
//    ({ cpu_set_t *__dest = (destset);
//       __const __cpu_mask *__arr1 = (srcset1)->__bits;
//       __const __cpu_mask *__arr2 = (srcset2)->__bits;
//       size_t __imax = (setsize) / sizeof (__cpu_mask);
//       size_t __i;
//       for (__i = 0; __i < __imax; ++__i)
// 	((__cpu_mask *) __dest->__bits)[__i] = __arr1[__i] op __arr2[__i];
//       __dest; }))

// # define __CPU_ALLOC_SIZE(count)
//   ((((count) + __NCPUBITS - 1) / __NCPUBITS) * sizeof (__cpu_mask))
// # define __CPU_ALLOC(count) __sched_cpualloc (count)
// # define __CPU_FREE(cpuset) __sched_cpufree (cpuset)

public static native int __sched_cpucount(@Cast("size_t") long __setsize, @Const cpu_set_t __setp);
public static native cpu_set_t __sched_cpualloc(@Cast("size_t") long __count);
public static native void __sched_cpufree(cpu_set_t __set);

// #endif


// Parsed from sched.h

/* Definitions for POSIX 1003.1b-1993 (aka POSIX.4) scheduling interface.
   Copyright (C) 1996,1997,1999,2001-2004,2007,2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef	_SCHED_H
public static final int _SCHED_H =	1;

// #include <features.h>

/* Get type definitions.  */
// #include <bits/types.h>

// #define __need_size_t
// #include <stddef.h>

// #define __need_time_t
// #define __need_timespec
// #include <time.h>

// #ifndef __pid_t_defined
// # define __pid_t_defined
// #endif


/* Get system specific constant and data structure definitions.  */
// #include <bits/sched.h>
/* Define the real names for the elements of `struct sched_param'.  */
// #define sched_priority	__sched_priority


/* Set scheduling parameters for a process.  */
public static native int sched_setparam(@Cast("__pid_t") int __pid, @Const sched_param __param);

/* Retrieve scheduling parameters for a particular process.  */
public static native int sched_getparam(@Cast("__pid_t") int __pid, sched_param __param);

/* Set scheduling algorithm and/or parameters for a process.  */
public static native int sched_setscheduler(@Cast("__pid_t") int __pid, int __policy,
			       @Const sched_param __param);

/* Retrieve scheduling algorithm for a particular purpose.  */
public static native int sched_getscheduler(@Cast("__pid_t") int __pid);

/* Yield the processor.  */
public static native int sched_yield();

/* Get maximum priority value for a scheduler.  */
public static native int sched_get_priority_max(int __algorithm);

/* Get minimum priority value for a scheduler.  */
public static native int sched_get_priority_min(int __algorithm);

/* Get the SCHED_RR interval for the named process.  */
public static native int sched_rr_get_interval(@Cast("__pid_t") int __pid, timespec __t);


// #ifdef __USE_GNU
/* Access macros for `cpu_set'.  */
public static final int CPU_SETSIZE = __CPU_SETSIZE;
// # define CPU_SET(cpu, cpusetp)	 __CPU_SET_S (cpu, sizeof (cpu_set_t), cpusetp)
// # define CPU_CLR(cpu, cpusetp)	 __CPU_CLR_S (cpu, sizeof (cpu_set_t), cpusetp)
// # define CPU_ISSET(cpu, cpusetp) __CPU_ISSET_S (cpu, sizeof (cpu_set_t),
// 						cpusetp)
// # define CPU_ZERO(cpusetp)	 __CPU_ZERO_S (sizeof (cpu_set_t), cpusetp)
// # define CPU_COUNT(cpusetp)	 __CPU_COUNT_S (sizeof (cpu_set_t), cpusetp)

// # define CPU_SET_S(cpu, setsize, cpusetp)   __CPU_SET_S (cpu, setsize, cpusetp)
// # define CPU_CLR_S(cpu, setsize, cpusetp)   __CPU_CLR_S (cpu, setsize, cpusetp)
// # define CPU_ISSET_S(cpu, setsize, cpusetp) __CPU_ISSET_S (cpu, setsize,
// 							   cpusetp)
// # define CPU_ZERO_S(setsize, cpusetp)	    __CPU_ZERO_S (setsize, cpusetp)
// # define CPU_COUNT_S(setsize, cpusetp)	    __CPU_COUNT_S (setsize, cpusetp)

// # define CPU_EQUAL(cpusetp1, cpusetp2)
//   __CPU_EQUAL_S (sizeof (cpu_set_t), cpusetp1, cpusetp2)
// # define CPU_EQUAL_S(setsize, cpusetp1, cpusetp2)
//   __CPU_EQUAL_S (setsize, cpusetp1, cpusetp2)

// # define CPU_AND(destset, srcset1, srcset2)
//   __CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, &)
// # define CPU_OR(destset, srcset1, srcset2)
//   __CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, |)
// # define CPU_XOR(destset, srcset1, srcset2)
//   __CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, ^)
// # define CPU_AND_S(setsize, destset, srcset1, srcset2)
//   __CPU_OP_S (setsize, destset, srcset1, srcset2, &)
// # define CPU_OR_S(setsize, destset, srcset1, srcset2)
//   __CPU_OP_S (setsize, destset, srcset1, srcset2, |)
// # define CPU_XOR_S(setsize, destset, srcset1, srcset2)
//   __CPU_OP_S (setsize, destset, srcset1, srcset2, ^)

// # define CPU_ALLOC_SIZE(count) __CPU_ALLOC_SIZE (count)
// # define CPU_ALLOC(count) __CPU_ALLOC (count)
// # define CPU_FREE(cpuset) __CPU_FREE (cpuset)


/* Set the CPU affinity for a task */
public static native int sched_setaffinity(@Cast("__pid_t") int __pid, @Cast("size_t") long __cpusetsize,
			      @Const cpu_set_t __cpuset);

/* Get the CPU affinity for a task */
public static native int sched_getaffinity(@Cast("__pid_t") int __pid, @Cast("size_t") long __cpusetsize,
			      cpu_set_t __cpuset);
// #endif

// #endif /* sched.h */


// Parsed from spawn.h

/* Definitions for POSIX spawn interface.
   Copyright (C) 2000, 2003, 2004, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef	_SPAWN_H
public static final int _SPAWN_H =	1;

// #include <features.h>
// #include <sched.h>
// #include <signal.h>
// #include <sys/types.h>
// Targeting ../linux/posix_spawnattr_t.java


// Targeting ../linux/posix_spawn_file_actions_t.java




/* Flags to be set in the `posix_spawnattr_t'.  */
public static final int POSIX_SPAWN_RESETIDS =		0x01;
public static final int POSIX_SPAWN_SETPGROUP =		0x02;
public static final int POSIX_SPAWN_SETSIGDEF =		0x04;
public static final int POSIX_SPAWN_SETSIGMASK =		0x08;
public static final int POSIX_SPAWN_SETSCHEDPARAM =	0x10;
public static final int POSIX_SPAWN_SETSCHEDULER =	0x20;
// #ifdef __USE_GNU
public static final int POSIX_SPAWN_USEVFORK =		0x40;
// #endif


/* Spawn a new process executing PATH with the attributes describes in *ATTRP.
   Before running the process perform the actions described in FILE-ACTIONS.

   This function is a possible cancellation points and therefore not
   marked with __THROW. */
public static native int posix_spawn(@Cast("pid_t*") IntPointer __pid,
			@Cast("const char*") BytePointer __path,
			@Const posix_spawn_file_actions_t __file_actions,
			@Const posix_spawnattr_t __attrp,
			@Cast("char*__const*") PointerPointer __argv,
			@Cast("char*__const*") PointerPointer __envp);
public static native int posix_spawn(@Cast("pid_t*") IntPointer __pid,
			@Cast("const char*") BytePointer __path,
			@Const posix_spawn_file_actions_t __file_actions,
			@Const posix_spawnattr_t __attrp,
			@Cast("char*__const*") @ByPtrPtr BytePointer __argv,
			@Cast("char*__const*") @ByPtrPtr BytePointer __envp);
public static native int posix_spawn(@Cast("pid_t*") IntBuffer __pid,
			String __path,
			@Const posix_spawn_file_actions_t __file_actions,
			@Const posix_spawnattr_t __attrp,
			@Cast("char*__const*") @ByPtrPtr ByteBuffer __argv,
			@Cast("char*__const*") @ByPtrPtr ByteBuffer __envp);
public static native int posix_spawn(@Cast("pid_t*") int[] __pid,
			@Cast("const char*") BytePointer __path,
			@Const posix_spawn_file_actions_t __file_actions,
			@Const posix_spawnattr_t __attrp,
			@Cast("char*__const*") @ByPtrPtr byte[] __argv,
			@Cast("char*__const*") @ByPtrPtr byte[] __envp);
public static native int posix_spawn(@Cast("pid_t*") IntPointer __pid,
			String __path,
			@Const posix_spawn_file_actions_t __file_actions,
			@Const posix_spawnattr_t __attrp,
			@Cast("char*__const*") @ByPtrPtr BytePointer __argv,
			@Cast("char*__const*") @ByPtrPtr BytePointer __envp);
public static native int posix_spawn(@Cast("pid_t*") IntBuffer __pid,
			@Cast("const char*") BytePointer __path,
			@Const posix_spawn_file_actions_t __file_actions,
			@Const posix_spawnattr_t __attrp,
			@Cast("char*__const*") @ByPtrPtr ByteBuffer __argv,
			@Cast("char*__const*") @ByPtrPtr ByteBuffer __envp);
public static native int posix_spawn(@Cast("pid_t*") int[] __pid,
			String __path,
			@Const posix_spawn_file_actions_t __file_actions,
			@Const posix_spawnattr_t __attrp,
			@Cast("char*__const*") @ByPtrPtr byte[] __argv,
			@Cast("char*__const*") @ByPtrPtr byte[] __envp);

/* Similar to `posix_spawn' but search for FILE in the PATH.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
public static native int posix_spawnp(@Cast("pid_t*") IntPointer __pid, @Cast("const char*") BytePointer __file,
			 @Const posix_spawn_file_actions_t __file_actions,
			 @Const posix_spawnattr_t __attrp,
			 @Cast("char*__const*") PointerPointer __argv, @Cast("char*__const*") PointerPointer __envp);
public static native int posix_spawnp(@Cast("pid_t*") IntPointer __pid, @Cast("const char*") BytePointer __file,
			 @Const posix_spawn_file_actions_t __file_actions,
			 @Const posix_spawnattr_t __attrp,
			 @Cast("char*__const*") @ByPtrPtr BytePointer __argv, @Cast("char*__const*") @ByPtrPtr BytePointer __envp);
public static native int posix_spawnp(@Cast("pid_t*") IntBuffer __pid, String __file,
			 @Const posix_spawn_file_actions_t __file_actions,
			 @Const posix_spawnattr_t __attrp,
			 @Cast("char*__const*") @ByPtrPtr ByteBuffer __argv, @Cast("char*__const*") @ByPtrPtr ByteBuffer __envp);
public static native int posix_spawnp(@Cast("pid_t*") int[] __pid, @Cast("const char*") BytePointer __file,
			 @Const posix_spawn_file_actions_t __file_actions,
			 @Const posix_spawnattr_t __attrp,
			 @Cast("char*__const*") @ByPtrPtr byte[] __argv, @Cast("char*__const*") @ByPtrPtr byte[] __envp);
public static native int posix_spawnp(@Cast("pid_t*") IntPointer __pid, String __file,
			 @Const posix_spawn_file_actions_t __file_actions,
			 @Const posix_spawnattr_t __attrp,
			 @Cast("char*__const*") @ByPtrPtr BytePointer __argv, @Cast("char*__const*") @ByPtrPtr BytePointer __envp);
public static native int posix_spawnp(@Cast("pid_t*") IntBuffer __pid, @Cast("const char*") BytePointer __file,
			 @Const posix_spawn_file_actions_t __file_actions,
			 @Const posix_spawnattr_t __attrp,
			 @Cast("char*__const*") @ByPtrPtr ByteBuffer __argv, @Cast("char*__const*") @ByPtrPtr ByteBuffer __envp);
public static native int posix_spawnp(@Cast("pid_t*") int[] __pid, String __file,
			 @Const posix_spawn_file_actions_t __file_actions,
			 @Const posix_spawnattr_t __attrp,
			 @Cast("char*__const*") @ByPtrPtr byte[] __argv, @Cast("char*__const*") @ByPtrPtr byte[] __envp);


/* Initialize data structure with attributes for `spawn' to default values.  */
public static native int posix_spawnattr_init(posix_spawnattr_t __attr);

/* Free resources associated with ATTR.  */
public static native int posix_spawnattr_destroy(posix_spawnattr_t __attr);

/* Store signal mask for signals with default handling from ATTR in
   SIGDEFAULT.  */
public static native int posix_spawnattr_getsigdefault(@Const posix_spawnattr_t __attr,
					  sigset_t __sigdefault);

/* Set signal mask for signals with default handling in ATTR to SIGDEFAULT.  */
public static native int posix_spawnattr_setsigdefault(posix_spawnattr_t __attr,
					  @Const sigset_t __sigdefault);

/* Store signal mask for the new process from ATTR in SIGMASK.  */
public static native int posix_spawnattr_getsigmask(@Const posix_spawnattr_t __attr,
				       sigset_t __sigmask);

/* Set signal mask for the new process in ATTR to SIGMASK.  */
public static native int posix_spawnattr_setsigmask(posix_spawnattr_t __attr,
				       @Const sigset_t __sigmask);

/* Get flag word from the attribute structure.  */
public static native int posix_spawnattr_getflags(@Const posix_spawnattr_t __attr,
				     ShortPointer __flags);
public static native int posix_spawnattr_getflags(@Const posix_spawnattr_t __attr,
				     ShortBuffer __flags);
public static native int posix_spawnattr_getflags(@Const posix_spawnattr_t __attr,
				     short[] __flags);

/* Store flags in the attribute structure.  */
public static native int posix_spawnattr_setflags(posix_spawnattr_t _attr,
				     short __flags);

/* Get process group ID from the attribute structure.  */
public static native int posix_spawnattr_getpgroup(@Const posix_spawnattr_t __attr, @Cast("pid_t*") IntPointer __pgroup);
public static native int posix_spawnattr_getpgroup(@Const posix_spawnattr_t __attr, @Cast("pid_t*") IntBuffer __pgroup);
public static native int posix_spawnattr_getpgroup(@Const posix_spawnattr_t __attr, @Cast("pid_t*") int[] __pgroup);

/* Store process group ID in the attribute structure.  */
public static native int posix_spawnattr_setpgroup(posix_spawnattr_t __attr,
				      @Cast("pid_t") int __pgroup);

/* Get scheduling policy from the attribute structure.  */
public static native int posix_spawnattr_getschedpolicy(@Const posix_spawnattr_t __attr,
					   @Cast("int*") IntPointer __schedpolicy);
public static native int posix_spawnattr_getschedpolicy(@Const posix_spawnattr_t __attr,
					   @Cast("int*") IntBuffer __schedpolicy);
public static native int posix_spawnattr_getschedpolicy(@Const posix_spawnattr_t __attr,
					   @Cast("int*") int[] __schedpolicy);

/* Store scheduling policy in the attribute structure.  */
public static native int posix_spawnattr_setschedpolicy(posix_spawnattr_t __attr,
					   int __schedpolicy);

/* Get scheduling parameters from the attribute structure.  */
public static native int posix_spawnattr_getschedparam(@Const posix_spawnattr_t __attr,
					  sched_param __schedparam);

/* Store scheduling parameters in the attribute structure.  */
public static native int posix_spawnattr_setschedparam(posix_spawnattr_t __attr,
					  @Const sched_param __schedparam);


/* Initialize data structure for file attribute for `spawn' call.  */
public static native int posix_spawn_file_actions_init(posix_spawn_file_actions_t __file_actions);

/* Free resources associated with FILE-ACTIONS.  */
public static native int posix_spawn_file_actions_destroy(posix_spawn_file_actions_t __file_actions);

/* Add an action to FILE-ACTIONS which tells the implementation to call
   `open' for the given file during the `spawn' call.  */
public static native int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t __file_actions,
					     int __fd,
					     @Cast("const char*") BytePointer __path,
					     int __oflag, @Cast("mode_t") int __mode);
public static native int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t __file_actions,
					     int __fd,
					     String __path,
					     int __oflag, @Cast("mode_t") int __mode);

/* Add an action to FILE-ACTIONS which tells the implementation to call
   `close' for the given file descriptor during the `spawn' call.  */
public static native int posix_spawn_file_actions_addclose(posix_spawn_file_actions_t __file_actions, int __fd);

/* Add an action to FILE-ACTIONS which tells the implementation to call
   `dup2' for the given file descriptors during the `spawn' call.  */
public static native int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t __file_actions,
					     int __fd, int __newfd);

// #endif /* spawn.h */


// Parsed from bits/posix_opt.h

/* Define POSIX options for Linux.
   Copyright (C) 1996-2004, 2006, 2008, 2009 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public License as
   published by the Free Software Foundation; either version 2.1 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

// #ifndef	_BITS_POSIX_OPT_H
public static final int _BITS_POSIX_OPT_H =	1;

/* Job control is supported.  */
public static final int _POSIX_JOB_CONTROL =	1;

/* Processes have a saved set-user-ID and a saved set-group-ID.  */
public static final int _POSIX_SAVED_IDS =	1;

/* Priority scheduling is supported.  */
public static final long _POSIX_PRIORITY_SCHEDULING =	200809L;

/* Synchronizing file data is supported.  */
public static final long _POSIX_SYNCHRONIZED_IO =	200809L;

/* The fsync function is present.  */
public static final long _POSIX_FSYNC =	200809L;

/* Mapping of files to memory is supported.  */
public static final long _POSIX_MAPPED_FILES =	200809L;

/* Locking of all memory is supported.  */
public static final long _POSIX_MEMLOCK =	200809L;

/* Locking of ranges of memory is supported.  */
public static final long _POSIX_MEMLOCK_RANGE =	200809L;

/* Setting of memory protections is supported.  */
public static final long _POSIX_MEMORY_PROTECTION =	200809L;

/* Some filesystems allow all users to change file ownership.  */
public static final int _POSIX_CHOWN_RESTRICTED =	0;

/* `c_cc' member of 'struct termios' structure can be disabled by
   using the value _POSIX_VDISABLE.  */
public static final int _POSIX_VDISABLE =	'\0';

/* Filenames are not silently truncated.  */
public static final int _POSIX_NO_TRUNC =	1;

/* X/Open realtime support is available.  */
public static final int _XOPEN_REALTIME =	1;

/* X/Open thread realtime support is available.  */
public static final int _XOPEN_REALTIME_THREADS =	1;

/* XPG4.2 shared memory is supported.  */
public static final int _XOPEN_SHM =	1;

/* Tell we have POSIX threads.  */
public static final long _POSIX_THREADS =	200809L;

/* We have the reentrant functions described in POSIX.  */
public static final int _POSIX_REENTRANT_FUNCTIONS =      1;
public static final long _POSIX_THREAD_SAFE_FUNCTIONS =	200809L;

/* We provide priority scheduling for threads.  */
public static final long _POSIX_THREAD_PRIORITY_SCHEDULING =	200809L;

/* We support user-defined stack sizes.  */
public static final long _POSIX_THREAD_ATTR_STACKSIZE =	200809L;

/* We support user-defined stacks.  */
public static final long _POSIX_THREAD_ATTR_STACKADDR =	200809L;

/* We support priority inheritence.  */
public static final long _POSIX_THREAD_PRIO_INHERIT =	200809L;

/* We support priority protection, though only for non-robust
   mutexes.  */
public static final long _POSIX_THREAD_PRIO_PROTECT =	200809L;

// #ifdef __USE_XOPEN2K8
/* We support priority inheritence for robust mutexes.  */
public static final long _POSIX_THREAD_ROBUST_PRIO_INHERIT =	200809L;

/* We do not support priority protection for robust mutexes.  */
public static final int _POSIX_THREAD_ROBUST_PRIO_PROTECT =	-1;
// #endif

/* We support POSIX.1b semaphores.  */
public static final long _POSIX_SEMAPHORES =	200809L;

/* Real-time signals are supported.  */
public static final long _POSIX_REALTIME_SIGNALS =	200809L;

/* We support asynchronous I/O.  */
public static final long _POSIX_ASYNCHRONOUS_IO =	200809L;
public static final int _POSIX_ASYNC_IO =		1;
/* Alternative name for Unix98.  */
public static final int _LFS_ASYNCHRONOUS_IO =	1;
/* Support for prioritization is also available.  */
public static final long _POSIX_PRIORITIZED_IO =	200809L;

/* The LFS support in asynchronous I/O is also available.  */
public static final int _LFS64_ASYNCHRONOUS_IO =	1;

/* The rest of the LFS is also available.  */
public static final int _LFS_LARGEFILE =		1;
public static final int _LFS64_LARGEFILE =	1;
public static final int _LFS64_STDIO =		1;

/* POSIX shared memory objects are implemented.  */
public static final long _POSIX_SHARED_MEMORY_OBJECTS =	200809L;

/* CPU-time clocks support needs to be checked at runtime.  */
public static final int _POSIX_CPUTIME =	0;

/* Clock support in threads must be also checked at runtime.  */
public static final int _POSIX_THREAD_CPUTIME =	0;

/* GNU libc provides regular expression handling.  */
public static final int _POSIX_REGEXP =	1;

/* Reader/Writer locks are available.  */
public static final long _POSIX_READER_WRITER_LOCKS =	200809L;

/* We have a POSIX shell.  */
public static final int _POSIX_SHELL =	1;

/* We support the Timeouts option.  */
public static final long _POSIX_TIMEOUTS =	200809L;

/* We support spinlocks.  */
public static final long _POSIX_SPIN_LOCKS =	200809L;

/* The `spawn' function family is supported.  */
public static final long _POSIX_SPAWN =	200809L;

/* We have POSIX timers.  */
public static final long _POSIX_TIMERS =	200809L;

/* The barrier functions are available.  */
public static final long _POSIX_BARRIERS =	200809L;

/* POSIX message queues are available.  */
public static final long _POSIX_MESSAGE_PASSING =	200809L;

/* Thread process-shared synchronization is supported.  */
public static final long _POSIX_THREAD_PROCESS_SHARED =	200809L;

/* The monotonic clock might be available.  */
public static final int _POSIX_MONOTONIC_CLOCK =	0;

/* The clock selection interfaces are available.  */
public static final long _POSIX_CLOCK_SELECTION =	200809L;

/* Advisory information interfaces are available.  */
public static final long _POSIX_ADVISORY_INFO =	200809L;

/* IPv6 support is available.  */
public static final long _POSIX_IPV6 =	200809L;

/* Raw socket support is available.  */
public static final long _POSIX_RAW_SOCKETS =	200809L;

/* We have at least one terminal.  */
public static final long _POSIX2_CHAR_TERM =	200809L;

/* Neither process nor thread sporadic server interfaces is available.  */
public static final int _POSIX_SPORADIC_SERVER =	-1;
public static final int _POSIX_THREAD_SPORADIC_SERVER =	-1;

/* trace.h is not available.  */
public static final int _POSIX_TRACE =	-1;
public static final int _POSIX_TRACE_EVENT_FILTER =	-1;
public static final int _POSIX_TRACE_INHERIT =	-1;
public static final int _POSIX_TRACE_LOG =	-1;

/* Typed memory objects are not available.  */
public static final int _POSIX_TYPED_MEMORY_OBJECTS =	-1;

/* Streams are not available.  */
public static final int _XOPEN_STREAMS =	-1;

// #endif /* bits/posix_opt.h */


// Parsed from bits/confname.h

/* `sysconf', `pathconf', and `confstr' NAME values.  Generic version.
   Copyright (C) 1993,1995-1998,2000,2001,2003,2004,2007,2009,2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef _UNISTD_H
// # error "Never use <bits/confname.h> directly; include <unistd.h> instead."
// #endif

/* Values for the NAME argument to `pathconf' and `fpathconf'.  */
/** enum  */
public static final int
    _PC_LINK_MAX = 0,
// #define	_PC_LINK_MAX			_PC_LINK_MAX
    _PC_MAX_CANON = 1,
// #define	_PC_MAX_CANON			_PC_MAX_CANON
    _PC_MAX_INPUT = 2,
// #define	_PC_MAX_INPUT			_PC_MAX_INPUT
    _PC_NAME_MAX = 3,
// #define	_PC_NAME_MAX			_PC_NAME_MAX
    _PC_PATH_MAX = 4,
// #define	_PC_PATH_MAX			_PC_PATH_MAX
    _PC_PIPE_BUF = 5,
// #define	_PC_PIPE_BUF			_PC_PIPE_BUF
    _PC_CHOWN_RESTRICTED = 6,
// #define	_PC_CHOWN_RESTRICTED		_PC_CHOWN_RESTRICTED
    _PC_NO_TRUNC = 7,
// #define	_PC_NO_TRUNC			_PC_NO_TRUNC
    _PC_VDISABLE = 8,
// #define _PC_VDISABLE			_PC_VDISABLE
    _PC_SYNC_IO = 9,
// #define	_PC_SYNC_IO			_PC_SYNC_IO
    _PC_ASYNC_IO = 10,
// #define	_PC_ASYNC_IO			_PC_ASYNC_IO
    _PC_PRIO_IO = 11,
// #define	_PC_PRIO_IO			_PC_PRIO_IO
    _PC_SOCK_MAXBUF = 12,
// #define	_PC_SOCK_MAXBUF			_PC_SOCK_MAXBUF
    _PC_FILESIZEBITS = 13,
// #define _PC_FILESIZEBITS		_PC_FILESIZEBITS
    _PC_REC_INCR_XFER_SIZE = 14,
// #define _PC_REC_INCR_XFER_SIZE		_PC_REC_INCR_XFER_SIZE
    _PC_REC_MAX_XFER_SIZE = 15,
// #define _PC_REC_MAX_XFER_SIZE		_PC_REC_MAX_XFER_SIZE
    _PC_REC_MIN_XFER_SIZE = 16,
// #define _PC_REC_MIN_XFER_SIZE		_PC_REC_MIN_XFER_SIZE
    _PC_REC_XFER_ALIGN = 17,
// #define _PC_REC_XFER_ALIGN		_PC_REC_XFER_ALIGN
    _PC_ALLOC_SIZE_MIN = 18,
// #define _PC_ALLOC_SIZE_MIN		_PC_ALLOC_SIZE_MIN
    _PC_SYMLINK_MAX = 19,
// #define _PC_SYMLINK_MAX			_PC_SYMLINK_MAX
    _PC_2_SYMLINKS = 20;
// #define _PC_2_SYMLINKS			_PC_2_SYMLINKS

/* Values for the argument to `sysconf'.  */
/** enum  */
public static final int
    _SC_ARG_MAX = 0,
// #define	_SC_ARG_MAX			_SC_ARG_MAX
    _SC_CHILD_MAX = 1,
// #define	_SC_CHILD_MAX			_SC_CHILD_MAX
    _SC_CLK_TCK = 2,
// #define	_SC_CLK_TCK			_SC_CLK_TCK
    _SC_NGROUPS_MAX = 3,
// #define	_SC_NGROUPS_MAX			_SC_NGROUPS_MAX
    _SC_OPEN_MAX = 4,
// #define	_SC_OPEN_MAX			_SC_OPEN_MAX
    _SC_STREAM_MAX = 5,
// #define	_SC_STREAM_MAX			_SC_STREAM_MAX
    _SC_TZNAME_MAX = 6,
// #define	_SC_TZNAME_MAX			_SC_TZNAME_MAX
    _SC_JOB_CONTROL = 7,
// #define	_SC_JOB_CONTROL			_SC_JOB_CONTROL
    _SC_SAVED_IDS = 8,
// #define	_SC_SAVED_IDS			_SC_SAVED_IDS
    _SC_REALTIME_SIGNALS = 9,
// #define	_SC_REALTIME_SIGNALS		_SC_REALTIME_SIGNALS
    _SC_PRIORITY_SCHEDULING = 10,
// #define	_SC_PRIORITY_SCHEDULING		_SC_PRIORITY_SCHEDULING
    _SC_TIMERS = 11,
// #define	_SC_TIMERS			_SC_TIMERS
    _SC_ASYNCHRONOUS_IO = 12,
// #define	_SC_ASYNCHRONOUS_IO		_SC_ASYNCHRONOUS_IO
    _SC_PRIORITIZED_IO = 13,
// #define	_SC_PRIORITIZED_IO		_SC_PRIORITIZED_IO
    _SC_SYNCHRONIZED_IO = 14,
// #define	_SC_SYNCHRONIZED_IO		_SC_SYNCHRONIZED_IO
    _SC_FSYNC = 15,
// #define	_SC_FSYNC			_SC_FSYNC
    _SC_MAPPED_FILES = 16,
// #define	_SC_MAPPED_FILES		_SC_MAPPED_FILES
    _SC_MEMLOCK = 17,
// #define	_SC_MEMLOCK			_SC_MEMLOCK
    _SC_MEMLOCK_RANGE = 18,
// #define	_SC_MEMLOCK_RANGE		_SC_MEMLOCK_RANGE
    _SC_MEMORY_PROTECTION = 19,
// #define	_SC_MEMORY_PROTECTION		_SC_MEMORY_PROTECTION
    _SC_MESSAGE_PASSING = 20,
// #define	_SC_MESSAGE_PASSING		_SC_MESSAGE_PASSING
    _SC_SEMAPHORES = 21,
// #define	_SC_SEMAPHORES			_SC_SEMAPHORES
    _SC_SHARED_MEMORY_OBJECTS = 22,
// #define	_SC_SHARED_MEMORY_OBJECTS	_SC_SHARED_MEMORY_OBJECTS
    _SC_AIO_LISTIO_MAX = 23,
// #define	_SC_AIO_LISTIO_MAX		_SC_AIO_LISTIO_MAX
    _SC_AIO_MAX = 24,
// #define	_SC_AIO_MAX			_SC_AIO_MAX
    _SC_AIO_PRIO_DELTA_MAX = 25,
// #define	_SC_AIO_PRIO_DELTA_MAX		_SC_AIO_PRIO_DELTA_MAX
    _SC_DELAYTIMER_MAX = 26,
// #define	_SC_DELAYTIMER_MAX		_SC_DELAYTIMER_MAX
    _SC_MQ_OPEN_MAX = 27,
// #define	_SC_MQ_OPEN_MAX			_SC_MQ_OPEN_MAX
    _SC_MQ_PRIO_MAX = 28,
// #define	_SC_MQ_PRIO_MAX			_SC_MQ_PRIO_MAX
    _SC_VERSION = 29,
// #define	_SC_VERSION			_SC_VERSION
    _SC_PAGESIZE = 30;
// #define	_SC_PAGESIZE			_SC_PAGESIZE
public static final int _SC_PAGE_SIZE =			_SC_PAGESIZE;
public static final int
    _SC_RTSIG_MAX = 31,
// #define	_SC_RTSIG_MAX			_SC_RTSIG_MAX
    _SC_SEM_NSEMS_MAX = 32,
// #define	_SC_SEM_NSEMS_MAX		_SC_SEM_NSEMS_MAX
    _SC_SEM_VALUE_MAX = 33,
// #define	_SC_SEM_VALUE_MAX		_SC_SEM_VALUE_MAX
    _SC_SIGQUEUE_MAX = 34,
// #define	_SC_SIGQUEUE_MAX		_SC_SIGQUEUE_MAX
    _SC_TIMER_MAX = 35,
// #define	_SC_TIMER_MAX			_SC_TIMER_MAX

    /* Values for the argument to `sysconf'
       corresponding to _POSIX2_* symbols.  */
    _SC_BC_BASE_MAX = 36,
// #define	_SC_BC_BASE_MAX			_SC_BC_BASE_MAX
    _SC_BC_DIM_MAX = 37,
// #define	_SC_BC_DIM_MAX			_SC_BC_DIM_MAX
    _SC_BC_SCALE_MAX = 38,
// #define	_SC_BC_SCALE_MAX		_SC_BC_SCALE_MAX
    _SC_BC_STRING_MAX = 39,
// #define	_SC_BC_STRING_MAX		_SC_BC_STRING_MAX
    _SC_COLL_WEIGHTS_MAX = 40,
// #define	_SC_COLL_WEIGHTS_MAX		_SC_COLL_WEIGHTS_MAX
    _SC_EQUIV_CLASS_MAX = 41,
// #define	_SC_EQUIV_CLASS_MAX		_SC_EQUIV_CLASS_MAX
    _SC_EXPR_NEST_MAX = 42,
// #define	_SC_EXPR_NEST_MAX		_SC_EXPR_NEST_MAX
    _SC_LINE_MAX = 43,
// #define	_SC_LINE_MAX			_SC_LINE_MAX
    _SC_RE_DUP_MAX = 44,
// #define	_SC_RE_DUP_MAX			_SC_RE_DUP_MAX
    _SC_CHARCLASS_NAME_MAX = 45,
// #define	_SC_CHARCLASS_NAME_MAX		_SC_CHARCLASS_NAME_MAX

    _SC_2_VERSION = 46,
// #define	_SC_2_VERSION			_SC_2_VERSION
    _SC_2_C_BIND = 47,
// #define	_SC_2_C_BIND			_SC_2_C_BIND
    _SC_2_C_DEV = 48,
// #define	_SC_2_C_DEV			_SC_2_C_DEV
    _SC_2_FORT_DEV = 49,
// #define	_SC_2_FORT_DEV			_SC_2_FORT_DEV
    _SC_2_FORT_RUN = 50,
// #define	_SC_2_FORT_RUN			_SC_2_FORT_RUN
    _SC_2_SW_DEV = 51,
// #define	_SC_2_SW_DEV			_SC_2_SW_DEV
    _SC_2_LOCALEDEF = 52,
// #define	_SC_2_LOCALEDEF			_SC_2_LOCALEDEF

    _SC_PII = 53,
// #define	_SC_PII				_SC_PII
    _SC_PII_XTI = 54,
// #define	_SC_PII_XTI			_SC_PII_XTI
    _SC_PII_SOCKET = 55,
// #define	_SC_PII_SOCKET			_SC_PII_SOCKET
    _SC_PII_INTERNET = 56,
// #define	_SC_PII_INTERNET		_SC_PII_INTERNET
    _SC_PII_OSI = 57,
// #define	_SC_PII_OSI			_SC_PII_OSI
    _SC_POLL = 58,
// #define	_SC_POLL			_SC_POLL
    _SC_SELECT = 59,
// #define	_SC_SELECT			_SC_SELECT
    _SC_UIO_MAXIOV = 60,
// #define	_SC_UIO_MAXIOV			_SC_UIO_MAXIOV
    _SC_IOV_MAX = _SC_UIO_MAXIOV,
// #define _SC_IOV_MAX			_SC_IOV_MAX
    _SC_PII_INTERNET_STREAM = _SC_UIO_MAXIOV + 1,
// #define	_SC_PII_INTERNET_STREAM		_SC_PII_INTERNET_STREAM
    _SC_PII_INTERNET_DGRAM = _SC_UIO_MAXIOV + 2,
// #define	_SC_PII_INTERNET_DGRAM		_SC_PII_INTERNET_DGRAM
    _SC_PII_OSI_COTS = _SC_UIO_MAXIOV + 3,
// #define	_SC_PII_OSI_COTS		_SC_PII_OSI_COTS
    _SC_PII_OSI_CLTS = _SC_UIO_MAXIOV + 4,
// #define	_SC_PII_OSI_CLTS		_SC_PII_OSI_CLTS
    _SC_PII_OSI_M = _SC_UIO_MAXIOV + 5,
// #define	_SC_PII_OSI_M			_SC_PII_OSI_M
    _SC_T_IOV_MAX = _SC_UIO_MAXIOV + 6,
// #define	_SC_T_IOV_MAX			_SC_T_IOV_MAX

    /* Values according to POSIX 1003.1c (POSIX threads).  */
    _SC_THREADS = _SC_UIO_MAXIOV + 7,
// #define	_SC_THREADS			_SC_THREADS
    _SC_THREAD_SAFE_FUNCTIONS = _SC_UIO_MAXIOV + 8,
// #define _SC_THREAD_SAFE_FUNCTIONS	_SC_THREAD_SAFE_FUNCTIONS
    _SC_GETGR_R_SIZE_MAX = _SC_UIO_MAXIOV + 9,
// #define	_SC_GETGR_R_SIZE_MAX		_SC_GETGR_R_SIZE_MAX
    _SC_GETPW_R_SIZE_MAX = _SC_UIO_MAXIOV + 10,
// #define	_SC_GETPW_R_SIZE_MAX		_SC_GETPW_R_SIZE_MAX
    _SC_LOGIN_NAME_MAX = _SC_UIO_MAXIOV + 11,
// #define	_SC_LOGIN_NAME_MAX		_SC_LOGIN_NAME_MAX
    _SC_TTY_NAME_MAX = _SC_UIO_MAXIOV + 12,
// #define	_SC_TTY_NAME_MAX		_SC_TTY_NAME_MAX
    _SC_THREAD_DESTRUCTOR_ITERATIONS = _SC_UIO_MAXIOV + 13,
// #define	_SC_THREAD_DESTRUCTOR_ITERATIONS _SC_THREAD_DESTRUCTOR_ITERATIONS
    _SC_THREAD_KEYS_MAX = _SC_UIO_MAXIOV + 14,
// #define	_SC_THREAD_KEYS_MAX		_SC_THREAD_KEYS_MAX
    _SC_THREAD_STACK_MIN = _SC_UIO_MAXIOV + 15,
// #define	_SC_THREAD_STACK_MIN		_SC_THREAD_STACK_MIN
    _SC_THREAD_THREADS_MAX = _SC_UIO_MAXIOV + 16,
// #define	_SC_THREAD_THREADS_MAX		_SC_THREAD_THREADS_MAX
    _SC_THREAD_ATTR_STACKADDR = _SC_UIO_MAXIOV + 17,
// #define	_SC_THREAD_ATTR_STACKADDR	_SC_THREAD_ATTR_STACKADDR
    _SC_THREAD_ATTR_STACKSIZE = _SC_UIO_MAXIOV + 18,
// #define	_SC_THREAD_ATTR_STACKSIZE	_SC_THREAD_ATTR_STACKSIZE
    _SC_THREAD_PRIORITY_SCHEDULING = _SC_UIO_MAXIOV + 19,
// #define	_SC_THREAD_PRIORITY_SCHEDULING	_SC_THREAD_PRIORITY_SCHEDULING
    _SC_THREAD_PRIO_INHERIT = _SC_UIO_MAXIOV + 20,
// #define	_SC_THREAD_PRIO_INHERIT		_SC_THREAD_PRIO_INHERIT
    _SC_THREAD_PRIO_PROTECT = _SC_UIO_MAXIOV + 21,
// #define	_SC_THREAD_PRIO_PROTECT		_SC_THREAD_PRIO_PROTECT
    _SC_THREAD_PROCESS_SHARED = _SC_UIO_MAXIOV + 22,
// #define	_SC_THREAD_PROCESS_SHARED	_SC_THREAD_PROCESS_SHARED

    _SC_NPROCESSORS_CONF = _SC_UIO_MAXIOV + 23,
// #define _SC_NPROCESSORS_CONF		_SC_NPROCESSORS_CONF
    _SC_NPROCESSORS_ONLN = _SC_UIO_MAXIOV + 24,
// #define _SC_NPROCESSORS_ONLN		_SC_NPROCESSORS_ONLN
    _SC_PHYS_PAGES = _SC_UIO_MAXIOV + 25,
// #define _SC_PHYS_PAGES			_SC_PHYS_PAGES
    _SC_AVPHYS_PAGES = _SC_UIO_MAXIOV + 26,
// #define _SC_AVPHYS_PAGES		_SC_AVPHYS_PAGES
    _SC_ATEXIT_MAX = _SC_UIO_MAXIOV + 27,
// #define _SC_ATEXIT_MAX			_SC_ATEXIT_MAX
    _SC_PASS_MAX = _SC_UIO_MAXIOV + 28,
// #define _SC_PASS_MAX			_SC_PASS_MAX

    _SC_XOPEN_VERSION = _SC_UIO_MAXIOV + 29,
// #define _SC_XOPEN_VERSION		_SC_XOPEN_VERSION
    _SC_XOPEN_XCU_VERSION = _SC_UIO_MAXIOV + 30,
// #define _SC_XOPEN_XCU_VERSION		_SC_XOPEN_XCU_VERSION
    _SC_XOPEN_UNIX = _SC_UIO_MAXIOV + 31,
// #define _SC_XOPEN_UNIX			_SC_XOPEN_UNIX
    _SC_XOPEN_CRYPT = _SC_UIO_MAXIOV + 32,
// #define _SC_XOPEN_CRYPT			_SC_XOPEN_CRYPT
    _SC_XOPEN_ENH_I18N = _SC_UIO_MAXIOV + 33,
// #define _SC_XOPEN_ENH_I18N		_SC_XOPEN_ENH_I18N
    _SC_XOPEN_SHM = _SC_UIO_MAXIOV + 34,
// #define _SC_XOPEN_SHM			_SC_XOPEN_SHM

    _SC_2_CHAR_TERM = _SC_UIO_MAXIOV + 35,
// #define _SC_2_CHAR_TERM			_SC_2_CHAR_TERM
    _SC_2_C_VERSION = _SC_UIO_MAXIOV + 36,
// #define _SC_2_C_VERSION			_SC_2_C_VERSION
    _SC_2_UPE = _SC_UIO_MAXIOV + 37,
// #define _SC_2_UPE			_SC_2_UPE

    _SC_XOPEN_XPG2 = _SC_UIO_MAXIOV + 38,
// #define _SC_XOPEN_XPG2			_SC_XOPEN_XPG2
    _SC_XOPEN_XPG3 = _SC_UIO_MAXIOV + 39,
// #define _SC_XOPEN_XPG3			_SC_XOPEN_XPG3
    _SC_XOPEN_XPG4 = _SC_UIO_MAXIOV + 40,
// #define _SC_XOPEN_XPG4			_SC_XOPEN_XPG4

    _SC_CHAR_BIT = _SC_UIO_MAXIOV + 41,
// #define	_SC_CHAR_BIT			_SC_CHAR_BIT
    _SC_CHAR_MAX = _SC_UIO_MAXIOV + 42,
// #define	_SC_CHAR_MAX			_SC_CHAR_MAX
    _SC_CHAR_MIN = _SC_UIO_MAXIOV + 43,
// #define	_SC_CHAR_MIN			_SC_CHAR_MIN
    _SC_INT_MAX = _SC_UIO_MAXIOV + 44,
// #define	_SC_INT_MAX			_SC_INT_MAX
    _SC_INT_MIN = _SC_UIO_MAXIOV + 45,
// #define	_SC_INT_MIN			_SC_INT_MIN
    _SC_LONG_BIT = _SC_UIO_MAXIOV + 46,
// #define	_SC_LONG_BIT			_SC_LONG_BIT
    _SC_WORD_BIT = _SC_UIO_MAXIOV + 47,
// #define	_SC_WORD_BIT			_SC_WORD_BIT
    _SC_MB_LEN_MAX = _SC_UIO_MAXIOV + 48,
// #define	_SC_MB_LEN_MAX			_SC_MB_LEN_MAX
    _SC_NZERO = _SC_UIO_MAXIOV + 49,
// #define	_SC_NZERO			_SC_NZERO
    _SC_SSIZE_MAX = _SC_UIO_MAXIOV + 50,
// #define	_SC_SSIZE_MAX			_SC_SSIZE_MAX
    _SC_SCHAR_MAX = _SC_UIO_MAXIOV + 51,
// #define	_SC_SCHAR_MAX			_SC_SCHAR_MAX
    _SC_SCHAR_MIN = _SC_UIO_MAXIOV + 52,
// #define	_SC_SCHAR_MIN			_SC_SCHAR_MIN
    _SC_SHRT_MAX = _SC_UIO_MAXIOV + 53,
// #define	_SC_SHRT_MAX			_SC_SHRT_MAX
    _SC_SHRT_MIN = _SC_UIO_MAXIOV + 54,
// #define	_SC_SHRT_MIN			_SC_SHRT_MIN
    _SC_UCHAR_MAX = _SC_UIO_MAXIOV + 55,
// #define	_SC_UCHAR_MAX			_SC_UCHAR_MAX
    _SC_UINT_MAX = _SC_UIO_MAXIOV + 56,
// #define	_SC_UINT_MAX			_SC_UINT_MAX
    _SC_ULONG_MAX = _SC_UIO_MAXIOV + 57,
// #define	_SC_ULONG_MAX			_SC_ULONG_MAX
    _SC_USHRT_MAX = _SC_UIO_MAXIOV + 58,
// #define	_SC_USHRT_MAX			_SC_USHRT_MAX

    _SC_NL_ARGMAX = _SC_UIO_MAXIOV + 59,
// #define	_SC_NL_ARGMAX			_SC_NL_ARGMAX
    _SC_NL_LANGMAX = _SC_UIO_MAXIOV + 60,
// #define	_SC_NL_LANGMAX			_SC_NL_LANGMAX
    _SC_NL_MSGMAX = _SC_UIO_MAXIOV + 61,
// #define	_SC_NL_MSGMAX			_SC_NL_MSGMAX
    _SC_NL_NMAX = _SC_UIO_MAXIOV + 62,
// #define	_SC_NL_NMAX			_SC_NL_NMAX
    _SC_NL_SETMAX = _SC_UIO_MAXIOV + 63,
// #define	_SC_NL_SETMAX			_SC_NL_SETMAX
    _SC_NL_TEXTMAX = _SC_UIO_MAXIOV + 64,
// #define	_SC_NL_TEXTMAX			_SC_NL_TEXTMAX

    _SC_XBS5_ILP32_OFF32 = _SC_UIO_MAXIOV + 65,
// #define _SC_XBS5_ILP32_OFF32		_SC_XBS5_ILP32_OFF32
    _SC_XBS5_ILP32_OFFBIG = _SC_UIO_MAXIOV + 66,
// #define _SC_XBS5_ILP32_OFFBIG		_SC_XBS5_ILP32_OFFBIG
    _SC_XBS5_LP64_OFF64 = _SC_UIO_MAXIOV + 67,
// #define _SC_XBS5_LP64_OFF64		_SC_XBS5_LP64_OFF64
    _SC_XBS5_LPBIG_OFFBIG = _SC_UIO_MAXIOV + 68,
// #define _SC_XBS5_LPBIG_OFFBIG		_SC_XBS5_LPBIG_OFFBIG

    _SC_XOPEN_LEGACY = _SC_UIO_MAXIOV + 69,
// #define _SC_XOPEN_LEGACY		_SC_XOPEN_LEGACY
    _SC_XOPEN_REALTIME = _SC_UIO_MAXIOV + 70,
// #define _SC_XOPEN_REALTIME		_SC_XOPEN_REALTIME
    _SC_XOPEN_REALTIME_THREADS = _SC_UIO_MAXIOV + 71,
// #define _SC_XOPEN_REALTIME_THREADS	_SC_XOPEN_REALTIME_THREADS

    _SC_ADVISORY_INFO = _SC_UIO_MAXIOV + 72,
// #define _SC_ADVISORY_INFO		_SC_ADVISORY_INFO
    _SC_BARRIERS = _SC_UIO_MAXIOV + 73,
// #define _SC_BARRIERS			_SC_BARRIERS
    _SC_BASE = _SC_UIO_MAXIOV + 74,
// #define _SC_BASE			_SC_BASE
    _SC_C_LANG_SUPPORT = _SC_UIO_MAXIOV + 75,
// #define _SC_C_LANG_SUPPORT		_SC_C_LANG_SUPPORT
    _SC_C_LANG_SUPPORT_R = _SC_UIO_MAXIOV + 76,
// #define _SC_C_LANG_SUPPORT_R		_SC_C_LANG_SUPPORT_R
    _SC_CLOCK_SELECTION = _SC_UIO_MAXIOV + 77,
// #define _SC_CLOCK_SELECTION		_SC_CLOCK_SELECTION
    _SC_CPUTIME = _SC_UIO_MAXIOV + 78,
// #define _SC_CPUTIME			_SC_CPUTIME
    _SC_THREAD_CPUTIME = _SC_UIO_MAXIOV + 79,
// #define _SC_THREAD_CPUTIME		_SC_THREAD_CPUTIME
    _SC_DEVICE_IO = _SC_UIO_MAXIOV + 80,
// #define _SC_DEVICE_IO			_SC_DEVICE_IO
    _SC_DEVICE_SPECIFIC = _SC_UIO_MAXIOV + 81,
// #define _SC_DEVICE_SPECIFIC		_SC_DEVICE_SPECIFIC
    _SC_DEVICE_SPECIFIC_R = _SC_UIO_MAXIOV + 82,
// #define _SC_DEVICE_SPECIFIC_R		_SC_DEVICE_SPECIFIC_R
    _SC_FD_MGMT = _SC_UIO_MAXIOV + 83,
// #define _SC_FD_MGMT			_SC_FD_MGMT
    _SC_FIFO = _SC_UIO_MAXIOV + 84,
// #define _SC_FIFO			_SC_FIFO
    _SC_PIPE = _SC_UIO_MAXIOV + 85,
// #define _SC_PIPE			_SC_PIPE
    _SC_FILE_ATTRIBUTES = _SC_UIO_MAXIOV + 86,
// #define _SC_FILE_ATTRIBUTES		_SC_FILE_ATTRIBUTES
    _SC_FILE_LOCKING = _SC_UIO_MAXIOV + 87,
// #define _SC_FILE_LOCKING		_SC_FILE_LOCKING
    _SC_FILE_SYSTEM = _SC_UIO_MAXIOV + 88,
// #define _SC_FILE_SYSTEM			_SC_FILE_SYSTEM
    _SC_MONOTONIC_CLOCK = _SC_UIO_MAXIOV + 89,
// #define _SC_MONOTONIC_CLOCK		_SC_MONOTONIC_CLOCK
    _SC_MULTI_PROCESS = _SC_UIO_MAXIOV + 90,
// #define _SC_MULTI_PROCESS		_SC_MULTI_PROCESS
    _SC_SINGLE_PROCESS = _SC_UIO_MAXIOV + 91,
// #define _SC_SINGLE_PROCESS		_SC_SINGLE_PROCESS
    _SC_NETWORKING = _SC_UIO_MAXIOV + 92,
// #define _SC_NETWORKING			_SC_NETWORKING
    _SC_READER_WRITER_LOCKS = _SC_UIO_MAXIOV + 93,
// #define _SC_READER_WRITER_LOCKS		_SC_READER_WRITER_LOCKS
    _SC_SPIN_LOCKS = _SC_UIO_MAXIOV + 94,
// #define _SC_SPIN_LOCKS			_SC_SPIN_LOCKS
    _SC_REGEXP = _SC_UIO_MAXIOV + 95,
// #define _SC_REGEXP			_SC_REGEXP
    _SC_REGEX_VERSION = _SC_UIO_MAXIOV + 96,
// #define _SC_REGEX_VERSION		_SC_REGEX_VERSION
    _SC_SHELL = _SC_UIO_MAXIOV + 97,
// #define _SC_SHELL			_SC_SHELL
    _SC_SIGNALS = _SC_UIO_MAXIOV + 98,
// #define _SC_SIGNALS			_SC_SIGNALS
    _SC_SPAWN = _SC_UIO_MAXIOV + 99,
// #define _SC_SPAWN			_SC_SPAWN
    _SC_SPORADIC_SERVER = _SC_UIO_MAXIOV + 100,
// #define _SC_SPORADIC_SERVER		_SC_SPORADIC_SERVER
    _SC_THREAD_SPORADIC_SERVER = _SC_UIO_MAXIOV + 101,
// #define _SC_THREAD_SPORADIC_SERVER	_SC_THREAD_SPORADIC_SERVER
    _SC_SYSTEM_DATABASE = _SC_UIO_MAXIOV + 102,
// #define _SC_SYSTEM_DATABASE		_SC_SYSTEM_DATABASE
    _SC_SYSTEM_DATABASE_R = _SC_UIO_MAXIOV + 103,
// #define _SC_SYSTEM_DATABASE_R		_SC_SYSTEM_DATABASE_R
    _SC_TIMEOUTS = _SC_UIO_MAXIOV + 104,
// #define _SC_TIMEOUTS			_SC_TIMEOUTS
    _SC_TYPED_MEMORY_OBJECTS = _SC_UIO_MAXIOV + 105,
// #define _SC_TYPED_MEMORY_OBJECTS	_SC_TYPED_MEMORY_OBJECTS
    _SC_USER_GROUPS = _SC_UIO_MAXIOV + 106,
// #define _SC_USER_GROUPS			_SC_USER_GROUPS
    _SC_USER_GROUPS_R = _SC_UIO_MAXIOV + 107,
// #define _SC_USER_GROUPS_R		_SC_USER_GROUPS_R
    _SC_2_PBS = _SC_UIO_MAXIOV + 108,
// #define _SC_2_PBS			_SC_2_PBS
    _SC_2_PBS_ACCOUNTING = _SC_UIO_MAXIOV + 109,
// #define _SC_2_PBS_ACCOUNTING		_SC_2_PBS_ACCOUNTING
    _SC_2_PBS_LOCATE = _SC_UIO_MAXIOV + 110,
// #define _SC_2_PBS_LOCATE		_SC_2_PBS_LOCATE
    _SC_2_PBS_MESSAGE = _SC_UIO_MAXIOV + 111,
// #define _SC_2_PBS_MESSAGE		_SC_2_PBS_MESSAGE
    _SC_2_PBS_TRACK = _SC_UIO_MAXIOV + 112,
// #define _SC_2_PBS_TRACK			_SC_2_PBS_TRACK
    _SC_SYMLOOP_MAX = _SC_UIO_MAXIOV + 113,
// #define _SC_SYMLOOP_MAX			_SC_SYMLOOP_MAX
    _SC_STREAMS = _SC_UIO_MAXIOV + 114,
// #define _SC_STREAMS			_SC_STREAMS
    _SC_2_PBS_CHECKPOINT = _SC_UIO_MAXIOV + 115,
// #define _SC_2_PBS_CHECKPOINT		_SC_2_PBS_CHECKPOINT

    _SC_V6_ILP32_OFF32 = _SC_UIO_MAXIOV + 116,
// #define _SC_V6_ILP32_OFF32		_SC_V6_ILP32_OFF32
    _SC_V6_ILP32_OFFBIG = _SC_UIO_MAXIOV + 117,
// #define _SC_V6_ILP32_OFFBIG		_SC_V6_ILP32_OFFBIG
    _SC_V6_LP64_OFF64 = _SC_UIO_MAXIOV + 118,
// #define _SC_V6_LP64_OFF64		_SC_V6_LP64_OFF64
    _SC_V6_LPBIG_OFFBIG = _SC_UIO_MAXIOV + 119,
// #define _SC_V6_LPBIG_OFFBIG		_SC_V6_LPBIG_OFFBIG

    _SC_HOST_NAME_MAX = _SC_UIO_MAXIOV + 120,
// #define _SC_HOST_NAME_MAX		_SC_HOST_NAME_MAX
    _SC_TRACE = _SC_UIO_MAXIOV + 121,
// #define _SC_TRACE			_SC_TRACE
    _SC_TRACE_EVENT_FILTER = _SC_UIO_MAXIOV + 122,
// #define _SC_TRACE_EVENT_FILTER		_SC_TRACE_EVENT_FILTER
    _SC_TRACE_INHERIT = _SC_UIO_MAXIOV + 123,
// #define _SC_TRACE_INHERIT		_SC_TRACE_INHERIT
    _SC_TRACE_LOG = _SC_UIO_MAXIOV + 124,
// #define _SC_TRACE_LOG			_SC_TRACE_LOG

    _SC_LEVEL1_ICACHE_SIZE = _SC_UIO_MAXIOV + 125,
// #define _SC_LEVEL1_ICACHE_SIZE		_SC_LEVEL1_ICACHE_SIZE
    _SC_LEVEL1_ICACHE_ASSOC = _SC_UIO_MAXIOV + 126,
// #define _SC_LEVEL1_ICACHE_ASSOC		_SC_LEVEL1_ICACHE_ASSOC
    _SC_LEVEL1_ICACHE_LINESIZE = _SC_UIO_MAXIOV + 127,
// #define _SC_LEVEL1_ICACHE_LINESIZE	_SC_LEVEL1_ICACHE_LINESIZE
    _SC_LEVEL1_DCACHE_SIZE = _SC_UIO_MAXIOV + 128,
// #define _SC_LEVEL1_DCACHE_SIZE		_SC_LEVEL1_DCACHE_SIZE
    _SC_LEVEL1_DCACHE_ASSOC = _SC_UIO_MAXIOV + 129,
// #define _SC_LEVEL1_DCACHE_ASSOC		_SC_LEVEL1_DCACHE_ASSOC
    _SC_LEVEL1_DCACHE_LINESIZE = _SC_UIO_MAXIOV + 130,
// #define _SC_LEVEL1_DCACHE_LINESIZE	_SC_LEVEL1_DCACHE_LINESIZE
    _SC_LEVEL2_CACHE_SIZE = _SC_UIO_MAXIOV + 131,
// #define _SC_LEVEL2_CACHE_SIZE		_SC_LEVEL2_CACHE_SIZE
    _SC_LEVEL2_CACHE_ASSOC = _SC_UIO_MAXIOV + 132,
// #define _SC_LEVEL2_CACHE_ASSOC		_SC_LEVEL2_CACHE_ASSOC
    _SC_LEVEL2_CACHE_LINESIZE = _SC_UIO_MAXIOV + 133,
// #define _SC_LEVEL2_CACHE_LINESIZE	_SC_LEVEL2_CACHE_LINESIZE
    _SC_LEVEL3_CACHE_SIZE = _SC_UIO_MAXIOV + 134,
// #define _SC_LEVEL3_CACHE_SIZE		_SC_LEVEL3_CACHE_SIZE
    _SC_LEVEL3_CACHE_ASSOC = _SC_UIO_MAXIOV + 135,
// #define _SC_LEVEL3_CACHE_ASSOC		_SC_LEVEL3_CACHE_ASSOC
    _SC_LEVEL3_CACHE_LINESIZE = _SC_UIO_MAXIOV + 136,
// #define _SC_LEVEL3_CACHE_LINESIZE	_SC_LEVEL3_CACHE_LINESIZE
    _SC_LEVEL4_CACHE_SIZE = _SC_UIO_MAXIOV + 137,
// #define _SC_LEVEL4_CACHE_SIZE		_SC_LEVEL4_CACHE_SIZE
    _SC_LEVEL4_CACHE_ASSOC = _SC_UIO_MAXIOV + 138,
// #define _SC_LEVEL4_CACHE_ASSOC		_SC_LEVEL4_CACHE_ASSOC
    _SC_LEVEL4_CACHE_LINESIZE = _SC_UIO_MAXIOV + 139,
// #define _SC_LEVEL4_CACHE_LINESIZE	_SC_LEVEL4_CACHE_LINESIZE
    /* Leave room here, maybe we need a few more cache levels some day.  */

    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,
// #define _SC_IPV6			_SC_IPV6
    _SC_RAW_SOCKETS = _SC_LEVEL1_ICACHE_SIZE + 50 + 1,
// #define _SC_RAW_SOCKETS			_SC_RAW_SOCKETS

    _SC_V7_ILP32_OFF32 = _SC_LEVEL1_ICACHE_SIZE + 50 + 2,
// #define _SC_V7_ILP32_OFF32		_SC_V7_ILP32_OFF32
    _SC_V7_ILP32_OFFBIG = _SC_LEVEL1_ICACHE_SIZE + 50 + 3,
// #define _SC_V7_ILP32_OFFBIG		_SC_V7_ILP32_OFFBIG
    _SC_V7_LP64_OFF64 = _SC_LEVEL1_ICACHE_SIZE + 50 + 4,
// #define _SC_V7_LP64_OFF64		_SC_V7_LP64_OFF64
    _SC_V7_LPBIG_OFFBIG = _SC_LEVEL1_ICACHE_SIZE + 50 + 5,
// #define _SC_V7_LPBIG_OFFBIG		_SC_V7_LPBIG_OFFBIG

    _SC_SS_REPL_MAX = _SC_LEVEL1_ICACHE_SIZE + 50 + 6,
// #define _SC_SS_REPL_MAX			_SC_SS_REPL_MAX

    _SC_TRACE_EVENT_NAME_MAX = _SC_LEVEL1_ICACHE_SIZE + 50 + 7,
// #define _SC_TRACE_EVENT_NAME_MAX	_SC_TRACE_EVENT_NAME_MAX
    _SC_TRACE_NAME_MAX = _SC_LEVEL1_ICACHE_SIZE + 50 + 8,
// #define _SC_TRACE_NAME_MAX		_SC_TRACE_NAME_MAX
    _SC_TRACE_SYS_MAX = _SC_LEVEL1_ICACHE_SIZE + 50 + 9,
// #define _SC_TRACE_SYS_MAX		_SC_TRACE_SYS_MAX
    _SC_TRACE_USER_EVENT_MAX = _SC_LEVEL1_ICACHE_SIZE + 50 + 10,
// #define _SC_TRACE_USER_EVENT_MAX	_SC_TRACE_USER_EVENT_MAX

    _SC_XOPEN_STREAMS = _SC_LEVEL1_ICACHE_SIZE + 50 + 11,
// #define _SC_XOPEN_STREAMS		_SC_XOPEN_STREAMS

    _SC_THREAD_ROBUST_PRIO_INHERIT = _SC_LEVEL1_ICACHE_SIZE + 50 + 12,
// #define _SC_THREAD_ROBUST_PRIO_INHERIT	_SC_THREAD_ROBUST_PRIO_INHERIT
    _SC_THREAD_ROBUST_PRIO_PROTECT = _SC_LEVEL1_ICACHE_SIZE + 50 + 13;
// #define _SC_THREAD_ROBUST_PRIO_PROTECT	_SC_THREAD_ROBUST_PRIO_PROTECT

/* Values for the NAME argument to `confstr'.  */
/** enum  */
public static final int
    _CS_PATH = 0,			/* The default search path.  */
// #define _CS_PATH		_CS_PATH

    _CS_V6_WIDTH_RESTRICTED_ENVS = 1;
// #define _CS_V6_WIDTH_RESTRICTED_ENVS	_CS_V6_WIDTH_RESTRICTED_ENVS
public static final int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS =	_CS_V6_WIDTH_RESTRICTED_ENVS;
public static final int

    _CS_GNU_LIBC_VERSION = 2,
// #define _CS_GNU_LIBC_VERSION	_CS_GNU_LIBC_VERSION
    _CS_GNU_LIBPTHREAD_VERSION = 3,
// #define _CS_GNU_LIBPTHREAD_VERSION	_CS_GNU_LIBPTHREAD_VERSION

    _CS_V5_WIDTH_RESTRICTED_ENVS = 4;
// #define _CS_V5_WIDTH_RESTRICTED_ENVS	_CS_V5_WIDTH_RESTRICTED_ENVS
public static final int _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS =	_CS_V5_WIDTH_RESTRICTED_ENVS;
public static final int

    _CS_V7_WIDTH_RESTRICTED_ENVS = 5;
// #define _CS_V7_WIDTH_RESTRICTED_ENVS	_CS_V7_WIDTH_RESTRICTED_ENVS
public static final int _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS =	_CS_V7_WIDTH_RESTRICTED_ENVS;
public static final int

    _CS_LFS_CFLAGS = 1000,
// #define _CS_LFS_CFLAGS	_CS_LFS_CFLAGS
    _CS_LFS_LDFLAGS = 1001,
// #define _CS_LFS_LDFLAGS	_CS_LFS_LDFLAGS
    _CS_LFS_LIBS = 1002,
// #define _CS_LFS_LIBS		_CS_LFS_LIBS
    _CS_LFS_LINTFLAGS = 1003,
// #define _CS_LFS_LINTFLAGS	_CS_LFS_LINTFLAGS
    _CS_LFS64_CFLAGS = 1004,
// #define _CS_LFS64_CFLAGS	_CS_LFS64_CFLAGS
    _CS_LFS64_LDFLAGS = 1005,
// #define _CS_LFS64_LDFLAGS	_CS_LFS64_LDFLAGS
    _CS_LFS64_LIBS = 1006,
// #define _CS_LFS64_LIBS	_CS_LFS64_LIBS
    _CS_LFS64_LINTFLAGS = 1007,
// #define _CS_LFS64_LINTFLAGS	_CS_LFS64_LINTFLAGS

    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
// #define _CS_XBS5_ILP32_OFF32_CFLAGS _CS_XBS5_ILP32_OFF32_CFLAGS
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
// #define _CS_XBS5_ILP32_OFF32_LDFLAGS _CS_XBS5_ILP32_OFF32_LDFLAGS
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
// #define _CS_XBS5_ILP32_OFF32_LIBS _CS_XBS5_ILP32_OFF32_LIBS
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
// #define _CS_XBS5_ILP32_OFF32_LINTFLAGS _CS_XBS5_ILP32_OFF32_LINTFLAGS
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
// #define _CS_XBS5_ILP32_OFFBIG_CFLAGS _CS_XBS5_ILP32_OFFBIG_CFLAGS
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
// #define _CS_XBS5_ILP32_OFFBIG_LDFLAGS _CS_XBS5_ILP32_OFFBIG_LDFLAGS
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
// #define _CS_XBS5_ILP32_OFFBIG_LIBS _CS_XBS5_ILP32_OFFBIG_LIBS
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
// #define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS _CS_XBS5_ILP32_OFFBIG_LINTFLAGS
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
// #define _CS_XBS5_LP64_OFF64_CFLAGS _CS_XBS5_LP64_OFF64_CFLAGS
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
// #define _CS_XBS5_LP64_OFF64_LDFLAGS _CS_XBS5_LP64_OFF64_LDFLAGS
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
// #define _CS_XBS5_LP64_OFF64_LIBS _CS_XBS5_LP64_OFF64_LIBS
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
// #define _CS_XBS5_LP64_OFF64_LINTFLAGS _CS_XBS5_LP64_OFF64_LINTFLAGS
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
// #define _CS_XBS5_LPBIG_OFFBIG_CFLAGS _CS_XBS5_LPBIG_OFFBIG_CFLAGS
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
// #define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS _CS_XBS5_LPBIG_OFFBIG_LDFLAGS
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
// #define _CS_XBS5_LPBIG_OFFBIG_LIBS _CS_XBS5_LPBIG_OFFBIG_LIBS
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
// #define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS

    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
// #define _CS_POSIX_V6_ILP32_OFF32_CFLAGS _CS_POSIX_V6_ILP32_OFF32_CFLAGS
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
// #define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS _CS_POSIX_V6_ILP32_OFF32_LDFLAGS
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
// #define _CS_POSIX_V6_ILP32_OFF32_LIBS _CS_POSIX_V6_ILP32_OFF32_LIBS
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
// #define _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
// #define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
// #define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
// #define _CS_POSIX_V6_ILP32_OFFBIG_LIBS _CS_POSIX_V6_ILP32_OFFBIG_LIBS
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
// #define _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
// #define _CS_POSIX_V6_LP64_OFF64_CFLAGS _CS_POSIX_V6_LP64_OFF64_CFLAGS
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
// #define _CS_POSIX_V6_LP64_OFF64_LDFLAGS _CS_POSIX_V6_LP64_OFF64_LDFLAGS
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
// #define _CS_POSIX_V6_LP64_OFF64_LIBS _CS_POSIX_V6_LP64_OFF64_LIBS
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
// #define _CS_POSIX_V6_LP64_OFF64_LINTFLAGS _CS_POSIX_V6_LP64_OFF64_LINTFLAGS
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
// #define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
// #define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
// #define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS _CS_POSIX_V6_LPBIG_OFFBIG_LIBS
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131,
// #define _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS

    _CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132,
// #define _CS_POSIX_V7_ILP32_OFF32_CFLAGS _CS_POSIX_V7_ILP32_OFF32_CFLAGS
    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133,
// #define _CS_POSIX_V7_ILP32_OFF32_LDFLAGS _CS_POSIX_V7_ILP32_OFF32_LDFLAGS
    _CS_POSIX_V7_ILP32_OFF32_LIBS = 1134,
// #define _CS_POSIX_V7_ILP32_OFF32_LIBS _CS_POSIX_V7_ILP32_OFF32_LIBS
    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135,
// #define _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS
    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136,
// #define _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS
    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137,
// #define _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS
    _CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138,
// #define _CS_POSIX_V7_ILP32_OFFBIG_LIBS _CS_POSIX_V7_ILP32_OFFBIG_LIBS
    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139,
// #define _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS
    _CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140,
// #define _CS_POSIX_V7_LP64_OFF64_CFLAGS _CS_POSIX_V7_LP64_OFF64_CFLAGS
    _CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141,
// #define _CS_POSIX_V7_LP64_OFF64_LDFLAGS _CS_POSIX_V7_LP64_OFF64_LDFLAGS
    _CS_POSIX_V7_LP64_OFF64_LIBS = 1142,
// #define _CS_POSIX_V7_LP64_OFF64_LIBS _CS_POSIX_V7_LP64_OFF64_LIBS
    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143,
// #define _CS_POSIX_V7_LP64_OFF64_LINTFLAGS _CS_POSIX_V7_LP64_OFF64_LINTFLAGS
    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144,
// #define _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS
    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145,
// #define _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS
    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146,
// #define _CS_POSIX_V7_LPBIG_OFFBIG_LIBS _CS_POSIX_V7_LPBIG_OFFBIG_LIBS
    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147,
// #define _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS

    _CS_V6_ENV = 1148,
// #define _CS_V6_ENV			_CS_V6_ENV
    _CS_V7_ENV = 1149;
// #define _CS_V7_ENV			_CS_V7_ENV


// Parsed from unistd.h

/* Copyright (C) 1991-2009, 2010 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	POSIX Standard: 2.10 Symbolic Constants		<unistd.h>
 */

// #ifndef	_UNISTD_H
public static final int _UNISTD_H =	1;

// #include <features.h>

/* These may be used to determine what facilities are present at compile time.
   Their values can be obtained at run time from `sysconf'.  */

// #ifdef __USE_XOPEN2K8
/* POSIX Standard approved as ISO/IEC 9945-1 as of September 2008.  */
public static final long _POSIX_VERSION =	200809L;
// #elif defined __USE_XOPEN2K
// #elif defined __USE_POSIX199506
/* POSIX Standard approved as ISO/IEC 9945-1 as of June 1995.  */
// #elif defined __USE_POSIX199309
/* POSIX Standard approved as ISO/IEC 9945-1 as of September 1993.  */
// #else
/* POSIX Standard approved as ISO/IEC 9945-1 as of September 1990.  */
// #endif

/* These are not #ifdef __USE_POSIX2 because they are
   in the theoretically application-owned namespace.  */

// #ifdef __USE_XOPEN2K8
public static final long __POSIX2_THIS_VERSION =	200809L;
/* The utilities on GNU systems also correspond to this version.  */
// #elif defined __USE_XOPEN2K
// #elif defined __USE_POSIX199506
/* The utilities on GNU systems also correspond to this version.  */
// #else
/* The utilities on GNU systems also correspond to this version.  */
// #endif

/* The utilities on GNU systems also correspond to this version.  */
public static native @MemberGetter long _POSIX2_VERSION();
public static final long _POSIX2_VERSION = _POSIX2_VERSION();

/* If defined, the implementation supports the
   C Language Bindings Option.  */
public static native @MemberGetter long _POSIX2_C_BIND();
public static final long _POSIX2_C_BIND = _POSIX2_C_BIND();

/* If defined, the implementation supports the
   C Language Development Utilities Option.  */
public static native @MemberGetter long _POSIX2_C_DEV();
public static final long _POSIX2_C_DEV = _POSIX2_C_DEV();

/* If defined, the implementation supports the
   Software Development Utilities Option.  */
public static native @MemberGetter long _POSIX2_SW_DEV();
public static final long _POSIX2_SW_DEV = _POSIX2_SW_DEV();

/* If defined, the implementation supports the
   creation of locales with the localedef utility.  */
public static native @MemberGetter long _POSIX2_LOCALEDEF();
public static final long _POSIX2_LOCALEDEF = _POSIX2_LOCALEDEF();

/* X/Open version number to which the library conforms.  It is selectable.  */
// #ifdef __USE_XOPEN2K8
public static final int _XOPEN_VERSION =	700;
// #elif defined __USE_XOPEN2K
// #elif defined __USE_UNIX98
// #else
// #endif

/* Commands and utilities from XPG4 are available.  */
public static final int _XOPEN_XCU_VERSION =	4;

/* We are compatible with the old published standards as well.  */
public static final int _XOPEN_XPG2 =	1;
public static final int _XOPEN_XPG3 =	1;
public static final int _XOPEN_XPG4 =	1;

/* The X/Open Unix extensions are available.  */
public static final int _XOPEN_UNIX =	1;

/* Encryption is present.  */
public static final int _XOPEN_CRYPT =	1;

/* The enhanced internationalization capabilities according to XPG4.2
   are present.  */
public static final int _XOPEN_ENH_I18N =	1;

/* The legacy interfaces are also available.  */
public static final int _XOPEN_LEGACY =	1;


/* Get values of POSIX options:

   If these symbols are defined, the corresponding features are
   always available.  If not, they may be available sometimes.
   The current values can be obtained with `sysconf'.

   _POSIX_JOB_CONTROL		Job control is supported.
   _POSIX_SAVED_IDS		Processes have a saved set-user-ID
				and a saved set-group-ID.
   _POSIX_REALTIME_SIGNALS	Real-time, queued signals are supported.
   _POSIX_PRIORITY_SCHEDULING	Priority scheduling is supported.
   _POSIX_TIMERS		POSIX.4 clocks and timers are supported.
   _POSIX_ASYNCHRONOUS_IO	Asynchronous I/O is supported.
   _POSIX_PRIORITIZED_IO	Prioritized asynchronous I/O is supported.
   _POSIX_SYNCHRONIZED_IO	Synchronizing file data is supported.
   _POSIX_FSYNC			The fsync function is present.
   _POSIX_MAPPED_FILES		Mapping of files to memory is supported.
   _POSIX_MEMLOCK		Locking of all memory is supported.
   _POSIX_MEMLOCK_RANGE		Locking of ranges of memory is supported.
   _POSIX_MEMORY_PROTECTION	Setting of memory protections is supported.
   _POSIX_MESSAGE_PASSING	POSIX.4 message queues are supported.
   _POSIX_SEMAPHORES		POSIX.4 counting semaphores are supported.
   _POSIX_SHARED_MEMORY_OBJECTS	POSIX.4 shared memory objects are supported.
   _POSIX_THREADS		POSIX.1c pthreads are supported.
   _POSIX_THREAD_ATTR_STACKADDR	Thread stack address attribute option supported.
   _POSIX_THREAD_ATTR_STACKSIZE	Thread stack size attribute option supported.
   _POSIX_THREAD_SAFE_FUNCTIONS	Thread-safe functions are supported.
   _POSIX_THREAD_PRIORITY_SCHEDULING
				POSIX.1c thread execution scheduling supported.
   _POSIX_THREAD_PRIO_INHERIT	Thread priority inheritance option supported.
   _POSIX_THREAD_PRIO_PROTECT	Thread priority protection option supported.
   _POSIX_THREAD_PROCESS_SHARED	Process-shared synchronization supported.
   _POSIX_PII			Protocol-independent interfaces are supported.
   _POSIX_PII_XTI		XTI protocol-indep. interfaces are supported.
   _POSIX_PII_SOCKET		Socket protocol-indep. interfaces are supported.
   _POSIX_PII_INTERNET		Internet family of protocols supported.
   _POSIX_PII_INTERNET_STREAM	Connection-mode Internet protocol supported.
   _POSIX_PII_INTERNET_DGRAM	Connectionless Internet protocol supported.
   _POSIX_PII_OSI		ISO/OSI family of protocols supported.
   _POSIX_PII_OSI_COTS		Connection-mode ISO/OSI service supported.
   _POSIX_PII_OSI_CLTS		Connectionless ISO/OSI service supported.
   _POSIX_POLL			Implementation supports `poll' function.
   _POSIX_SELECT		Implementation supports `select' and `pselect'.

   _XOPEN_REALTIME		X/Open realtime support is available.
   _XOPEN_REALTIME_THREADS	X/Open realtime thread support is available.
   _XOPEN_SHM			Shared memory interface according to XPG4.2.

   _XBS5_ILP32_OFF32		Implementation provides environment with 32-bit
				int, long, pointer, and off_t types.
   _XBS5_ILP32_OFFBIG		Implementation provides environment with 32-bit
				int, long, and pointer and off_t with at least
				64 bits.
   _XBS5_LP64_OFF64		Implementation provides environment with 32-bit
				int, and 64-bit long, pointer, and off_t types.
   _XBS5_LPBIG_OFFBIG		Implementation provides environment with at
				least 32 bits int and long, pointer, and off_t
				with at least 64 bits.

   If any of these symbols is defined as -1, the corresponding option is not
   true for any file.  If any is defined as other than -1, the corresponding
   option is true for all files.  If a symbol is not defined at all, the value
   for a specific file can be obtained from `pathconf' and `fpathconf'.

   _POSIX_CHOWN_RESTRICTED	Only the super user can use `chown' to change
				the owner of a file.  `chown' can only be used
				to change the group ID of a file to a group of
				which the calling process is a member.
   _POSIX_NO_TRUNC		Pathname components longer than
				NAME_MAX generate an error.
   _POSIX_VDISABLE		If defined, if the value of an element of the
				`c_cc' member of `struct termios' is
				_POSIX_VDISABLE, no character will have the
				effect associated with that element.
   _POSIX_SYNC_IO		Synchronous I/O may be performed.
   _POSIX_ASYNC_IO		Asynchronous I/O may be performed.
   _POSIX_PRIO_IO		Prioritized Asynchronous I/O may be performed.

   Support for the Large File Support interface is not generally available.
   If it is available the following constants are defined to one.
   _LFS64_LARGEFILE		Low-level I/O supports large files.
   _LFS64_STDIO			Standard I/O supports large files.
   */

// #include <bits/posix_opt.h>

/* Get the environment definitions from Unix98.  */
// #if defined __USE_UNIX98 || defined __USE_XOPEN2K
// # include <bits/environments.h>
// #endif

/* Standard file descriptors.  */
public static final int STDIN_FILENO =	0;	/* Standard input.  */
public static final int STDOUT_FILENO =	1;	/* Standard output.  */
public static final int STDERR_FILENO =	2;	/* Standard error output.  */


/* All functions that are not declared anywhere else.  */

// #include <bits/types.h>

// #ifndef	__ssize_t_defined
// # define __ssize_t_defined
// #endif

// #define	__need_size_t
// #define __need_NULL
// #include <stddef.h>

// #if defined __USE_XOPEN || defined __USE_XOPEN2K
/* The Single Unix specification says that some more types are
   available here.  */
// # ifndef __gid_t_defined
// #  define __gid_t_defined
// # endif

// # ifndef __uid_t_defined
// #  define __uid_t_defined
// # endif

// # ifndef __off_t_defined
// #  ifndef __USE_FILE_OFFSET64
// #  else
// #  endif
// #  define __off_t_defined
// # endif
// # if defined __USE_LARGEFILE64 && !defined __off64_t_defined
// #  define __off64_t_defined
// # endif

// # ifndef __useconds_t_defined
// #  define __useconds_t_defined
// # endif

// # ifndef __pid_t_defined
// #  define __pid_t_defined
// # endif
// #endif	/* X/Open */

// #if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K
// # ifndef __intptr_t_defined
// #  define __intptr_t_defined
// # endif
// #endif

// #if defined __USE_BSD || defined __USE_XOPEN
// # ifndef __socklen_t_defined
// #  define __socklen_t_defined
// # endif
// #endif

/* Values for the second argument to access.
   These may be OR'd together.  */		/* Test for read permission.  */		/* Test for write permission.  */		/* Test for execute permission.  */		/* Test for existence.  */

/* Test for access to NAME using the real UID and real GID.  */
public static native int access(@Cast("const char*") BytePointer __name, int __type);
public static native int access(String __name, int __type);

// #ifdef __USE_GNU
/* Test for access to NAME using the effective UID and GID
   (as normal file operations use).  */
public static native int euidaccess(@Cast("const char*") BytePointer __name, int __type);
public static native int euidaccess(String __name, int __type);

/* An alias for `euidaccess', used by some other systems.  */
public static native int eaccess(@Cast("const char*") BytePointer __name, int __type);
public static native int eaccess(String __name, int __type);
// #endif

// #ifdef __USE_ATFILE
/* Test for access to FILE relative to the directory FD is open on.
   If AT_EACCESS is set in FLAG, then use effective IDs like `eaccess',
   otherwise use real IDs like `access'.  */
public static native int faccessat(int __fd, @Cast("const char*") BytePointer __file, int __type, int __flag);
public static native int faccessat(int __fd, String __file, int __type, int __flag);
// #endif /* Use GNU.  */


/* Values for the WHENCE argument to lseek.  */
// #ifndef	_STDIO_H		/* <stdio.h> has the same definitions.  */	/* Seek from beginning of file.  */	/* Seek from current position.  */	/* Seek from end of file.  */
// #endif

// #if defined __USE_BSD && !defined L_SET
/* Old BSD names for the same constants; just for compatibility.  */
// #endif


/* Move FD's file position to OFFSET bytes from the
   beginning of the file (if WHENCE is SEEK_SET),
   the current position (if WHENCE is SEEK_CUR),
   or the end of the file (if WHENCE is SEEK_END).
   Return the new file position.  */
// #ifndef __USE_FILE_OFFSET64
public static native @Cast("__off_t") long lseek(int __fd, @Cast("__off_t") long __offset, int __whence);
// #else
// #endif
// #ifdef __USE_LARGEFILE64
public static native @Cast("__off64_t") long lseek64(int __fd, @Cast("__off64_t") long __offset, int __whence);
// #endif

/* Close the file descriptor FD.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Name("close") int _close(int __fd);

/* Read NBYTES into BUF from FD.  Return the
   number read, -1 for errors or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long read(int __fd, Pointer __buf, @Cast("size_t") long __nbytes);

/* Write N bytes of BUF to FD.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long write(int __fd, @Const Pointer __buf, @Cast("size_t") long __n);

// #if defined __USE_UNIX98 || defined __USE_XOPEN2K8
// # ifndef __USE_FILE_OFFSET64
/* Read NBYTES into BUF from FD at the given position OFFSET without
   changing the file pointer.  Return the number read, -1 for errors
   or 0 for EOF.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long pread(int __fd, Pointer __buf, @Cast("size_t") long __nbytes,
		      @Cast("__off_t") long __offset);

/* Write N bytes of BUF to FD at the given position OFFSET without
   changing the file pointer.  Return the number written, or -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("ssize_t") long pwrite(int __fd, @Const Pointer __buf, @Cast("size_t") long __n,
		       @Cast("__off_t") long __offset);
// # else
// # endif

// # ifdef __USE_LARGEFILE64
/* Read NBYTES into BUF from FD at the given position OFFSET without
   changing the file pointer.  Return the number read, -1 for errors
   or 0 for EOF.  */
public static native @Cast("ssize_t") long pread64(int __fd, Pointer __buf, @Cast("size_t") long __nbytes,
			@Cast("__off64_t") long __offset);
/* Write N bytes of BUF to FD at the given position OFFSET without
   changing the file pointer.  Return the number written, or -1.  */
public static native @Cast("ssize_t") long pwrite64(int __fd, @Const Pointer __buf, @Cast("size_t") long __n,
			 @Cast("__off64_t") long __offset);
// # endif
// #endif

/* Create a one-way communication channel (pipe).
   If successful, two file descriptors are stored in PIPEDES;
   bytes written on PIPEDES[1] can be read from PIPEDES[0].
   Returns 0 if successful, -1 if not.  */
public static native int pipe(@Cast("int*") IntPointer __pipedes);
public static native int pipe(@Cast("int*") IntBuffer __pipedes);
public static native int pipe(@Cast("int*") int[] __pipedes);

// #ifdef __USE_GNU
/* Same as pipe but apply flags passed in FLAGS to the new file
   descriptors.  */
public static native int pipe2(@Cast("int*") IntPointer __pipedes, int __flags);
public static native int pipe2(@Cast("int*") IntBuffer __pipedes, int __flags);
public static native int pipe2(@Cast("int*") int[] __pipedes, int __flags);
// #endif

/* Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.
   If SECONDS is zero, any currently scheduled alarm will be cancelled.
   The function returns the number of seconds remaining until the last
   alarm scheduled would have signaled, or zero if there wasn't one.
   There is no return value to indicate an error, but you can set `errno'
   to 0 and check its value after calling `alarm', and this might tell you.
   The signal may come late due to processor scheduling.  */
public static native @Cast("unsigned int") int alarm(@Cast("unsigned int") int __seconds);

/* Make the process sleep for SECONDS seconds, or until a signal arrives
   and is not ignored.  The function returns the number of seconds less
   than SECONDS which it actually slept (thus zero if it slept the full time).
   If a signal handler does a `longjmp' or modifies the handling of the
   SIGALRM signal while inside `sleep' call, the handling of the SIGALRM
   signal afterwards is undefined.  There is no return value to indicate
   error, but if `sleep' returns SECONDS, it probably didn't work.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("unsigned int") int sleep(@Cast("unsigned int") int __seconds);

// #if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8)
//     || defined __USE_BSD
/* Set an alarm to go off (generating a SIGALRM signal) in VALUE
   microseconds.  If INTERVAL is nonzero, when the alarm goes off, the
   timer is reset to go off every INTERVAL microseconds thereafter.
   Returns the number of microseconds remaining before the alarm.  */
public static native @Cast("__useconds_t") int ualarm(@Cast("__useconds_t") int __value, @Cast("__useconds_t") int __interval);

/* Sleep USECONDS microseconds, or until a signal arrives that is not blocked
   or ignored.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native int usleep(@Cast("__useconds_t") int __useconds);
// #endif


/* Suspend the process until a signal arrives.
   This always returns -1 and sets `errno' to EINTR.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native int pause();


/* Change the owner and group of FILE.  */
public static native int chown(@Cast("const char*") BytePointer __file, @Cast("__uid_t") int __owner, @Cast("__gid_t") int __group);
public static native int chown(String __file, @Cast("__uid_t") int __owner, @Cast("__gid_t") int __group);

// #if defined __USE_BSD || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
/* Change the owner and group of the file that FD is open on.  */
public static native int fchown(int __fd, @Cast("__uid_t") int __owner, @Cast("__gid_t") int __group);


/* Change owner and group of FILE, if it is a symbolic
   link the ownership of the symbolic link is changed.  */
public static native int lchown(@Cast("const char*") BytePointer __file, @Cast("__uid_t") int __owner, @Cast("__gid_t") int __group);
public static native int lchown(String __file, @Cast("__uid_t") int __owner, @Cast("__gid_t") int __group);

// #endif /* Use BSD || X/Open Unix.  */

// #ifdef __USE_ATFILE
/* Change the owner and group of FILE relative to the directory FD is open
   on.  */
public static native int fchownat(int __fd, @Cast("const char*") BytePointer __file, @Cast("__uid_t") int __owner,
		     @Cast("__gid_t") int __group, int __flag);
public static native int fchownat(int __fd, String __file, @Cast("__uid_t") int __owner,
		     @Cast("__gid_t") int __group, int __flag);
// #endif /* Use GNU.  */

/* Change the process's working directory to PATH.  */
public static native int chdir(@Cast("const char*") BytePointer __path);
public static native int chdir(String __path);

// #if defined __USE_BSD || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
/* Change the process's working directory to the one FD is open on.  */
public static native int fchdir(int __fd);
// #endif

/* Get the pathname of the current working directory,
   and put it in SIZE bytes of BUF.  Returns NULL if the
   directory couldn't be determined or SIZE was too small.
   If successful, returns BUF.  In GNU, if BUF is NULL,
   an array is allocated with `malloc'; the array is SIZE
   bytes long, unless SIZE == 0, in which case it is as
   big as necessary.  */
public static native @Cast("char*") BytePointer getcwd(@Cast("char*") BytePointer __buf, @Cast("size_t") long __size);
public static native @Cast("char*") ByteBuffer getcwd(@Cast("char*") ByteBuffer __buf, @Cast("size_t") long __size);
public static native @Cast("char*") byte[] getcwd(@Cast("char*") byte[] __buf, @Cast("size_t") long __size);

// #ifdef	__USE_GNU
/* Return a malloc'd string containing the current directory name.
   If the environment variable `PWD' is set, and its value is correct,
   that value is used.  */
public static native @Cast("char*") BytePointer get_current_dir_name();
// #endif

// #if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8)
//     || defined __USE_BSD
/* Put the absolute pathname of the current working directory in BUF.
   If successful, return BUF.  If not, put an error message in
   BUF and return NULL.  BUF should be at least PATH_MAX bytes long.  */

// #endif


/* Duplicate FD, returning a new file descriptor on the same file.  */
public static native int dup(int __fd);

/* Duplicate FD to FD2, closing FD2 and making it open on the same file.  */
public static native int dup2(int __fd, int __fd2);

// #ifdef __USE_GNU
/* Duplicate FD to FD2, closing FD2 and making it open on the same
   file while setting flags according to FLAGS.  */
public static native int dup3(int __fd, int __fd2, int __flags);
// #endif

/* NULL-terminated array of "NAME=VALUE" environment variables.  */
public static native @Cast("char*") BytePointer __environ(int i); public static native void __environ(int i, BytePointer __environ);
public static native @Cast("char**") PointerPointer __environ(); public static native void __environ(PointerPointer __environ);
// #ifdef __USE_GNU
public static native @Cast("char*") BytePointer environ(int i); public static native void environ(int i, BytePointer environ);
public static native @Cast("char**") PointerPointer environ(); public static native void environ(PointerPointer environ);
// #endif


/* Replace the current process, executing PATH with arguments ARGV and
   environment ENVP.  ARGV and ENVP are terminated by NULL pointers.  */
public static native int execve(@Cast("const char*") BytePointer __path, @Cast("char*__const*") PointerPointer __argv,
		   @Cast("char*__const*") PointerPointer __envp);
public static native int execve(@Cast("const char*") BytePointer __path, @Cast("char*__const*") @ByPtrPtr BytePointer __argv,
		   @Cast("char*__const*") @ByPtrPtr BytePointer __envp);
public static native int execve(String __path, @Cast("char*__const*") @ByPtrPtr ByteBuffer __argv,
		   @Cast("char*__const*") @ByPtrPtr ByteBuffer __envp);
public static native int execve(@Cast("const char*") BytePointer __path, @Cast("char*__const*") @ByPtrPtr byte[] __argv,
		   @Cast("char*__const*") @ByPtrPtr byte[] __envp);
public static native int execve(String __path, @Cast("char*__const*") @ByPtrPtr BytePointer __argv,
		   @Cast("char*__const*") @ByPtrPtr BytePointer __envp);
public static native int execve(@Cast("const char*") BytePointer __path, @Cast("char*__const*") @ByPtrPtr ByteBuffer __argv,
		   @Cast("char*__const*") @ByPtrPtr ByteBuffer __envp);
public static native int execve(String __path, @Cast("char*__const*") @ByPtrPtr byte[] __argv,
		   @Cast("char*__const*") @ByPtrPtr byte[] __envp);

// #ifdef __USE_XOPEN2K8
/* Execute the file FD refers to, overlaying the running program image.
   ARGV and ENVP are passed to the new program, as for `execve'.  */
public static native int fexecve(int __fd, @Cast("char*__const*") PointerPointer __argv, @Cast("char*__const*") PointerPointer __envp);
public static native int fexecve(int __fd, @Cast("char*__const*") @ByPtrPtr BytePointer __argv, @Cast("char*__const*") @ByPtrPtr BytePointer __envp);
public static native int fexecve(int __fd, @Cast("char*__const*") @ByPtrPtr ByteBuffer __argv, @Cast("char*__const*") @ByPtrPtr ByteBuffer __envp);
public static native int fexecve(int __fd, @Cast("char*__const*") @ByPtrPtr byte[] __argv, @Cast("char*__const*") @ByPtrPtr byte[] __envp);
// #endif


/* Execute PATH with arguments ARGV and environment from `environ'.  */
public static native int execv(@Cast("const char*") BytePointer __path, @Cast("char*__const*") PointerPointer __argv);
public static native int execv(@Cast("const char*") BytePointer __path, @Cast("char*__const*") @ByPtrPtr BytePointer __argv);
public static native int execv(String __path, @Cast("char*__const*") @ByPtrPtr ByteBuffer __argv);
public static native int execv(@Cast("const char*") BytePointer __path, @Cast("char*__const*") @ByPtrPtr byte[] __argv);
public static native int execv(String __path, @Cast("char*__const*") @ByPtrPtr BytePointer __argv);
public static native int execv(@Cast("const char*") BytePointer __path, @Cast("char*__const*") @ByPtrPtr ByteBuffer __argv);
public static native int execv(String __path, @Cast("char*__const*") @ByPtrPtr byte[] __argv);

/* Execute PATH with all arguments after PATH until a NULL pointer,
   and the argument after that for environment.  */
public static native int execle(@Cast("const char*") BytePointer __path, @Cast("const char*") BytePointer __arg);
public static native int execle(String __path, String __arg);

/* Execute PATH with all arguments after PATH until
   a NULL pointer and environment from `environ'.  */
public static native int execl(@Cast("const char*") BytePointer __path, @Cast("const char*") BytePointer __arg);
public static native int execl(String __path, String __arg);

/* Execute FILE, searching in the `PATH' environment variable if it contains
   no slashes, with arguments ARGV and environment from `environ'.  */
public static native int execvp(@Cast("const char*") BytePointer __file, @Cast("char*__const*") PointerPointer __argv);
public static native int execvp(@Cast("const char*") BytePointer __file, @Cast("char*__const*") @ByPtrPtr BytePointer __argv);
public static native int execvp(String __file, @Cast("char*__const*") @ByPtrPtr ByteBuffer __argv);
public static native int execvp(@Cast("const char*") BytePointer __file, @Cast("char*__const*") @ByPtrPtr byte[] __argv);
public static native int execvp(String __file, @Cast("char*__const*") @ByPtrPtr BytePointer __argv);
public static native int execvp(@Cast("const char*") BytePointer __file, @Cast("char*__const*") @ByPtrPtr ByteBuffer __argv);
public static native int execvp(String __file, @Cast("char*__const*") @ByPtrPtr byte[] __argv);

/* Execute FILE, searching in the `PATH' environment variable if
   it contains no slashes, with all arguments after FILE until a
   NULL pointer and environment from `environ'.  */
public static native int execlp(@Cast("const char*") BytePointer __file, @Cast("const char*") BytePointer __arg);
public static native int execlp(String __file, String __arg);

// #ifdef __USE_GNU
/* Execute FILE, searching in the `PATH' environment variable if it contains
   no slashes, with arguments ARGV and environment from `environ'.  */
public static native int execvpe(@Cast("const char*") BytePointer __file, @Cast("char*__const*") PointerPointer __argv,
		    @Cast("char*__const*") PointerPointer __envp);
public static native int execvpe(@Cast("const char*") BytePointer __file, @Cast("char*__const*") @ByPtrPtr BytePointer __argv,
		    @Cast("char*__const*") @ByPtrPtr BytePointer __envp);
public static native int execvpe(String __file, @Cast("char*__const*") @ByPtrPtr ByteBuffer __argv,
		    @Cast("char*__const*") @ByPtrPtr ByteBuffer __envp);
public static native int execvpe(@Cast("const char*") BytePointer __file, @Cast("char*__const*") @ByPtrPtr byte[] __argv,
		    @Cast("char*__const*") @ByPtrPtr byte[] __envp);
public static native int execvpe(String __file, @Cast("char*__const*") @ByPtrPtr BytePointer __argv,
		    @Cast("char*__const*") @ByPtrPtr BytePointer __envp);
public static native int execvpe(@Cast("const char*") BytePointer __file, @Cast("char*__const*") @ByPtrPtr ByteBuffer __argv,
		    @Cast("char*__const*") @ByPtrPtr ByteBuffer __envp);
public static native int execvpe(String __file, @Cast("char*__const*") @ByPtrPtr byte[] __argv,
		    @Cast("char*__const*") @ByPtrPtr byte[] __envp);
// #endif


// #if defined __USE_MISC || defined __USE_XOPEN
/* Add INC to priority of the current process.  */
public static native int nice(int __inc);
// #endif


/* Terminate program execution with the low-order 8 bits of STATUS.  */
public static native void _exit(int __status);


/* Get the `_PC_*' symbols for the NAME argument to `pathconf' and `fpathconf';
   the `_SC_*' symbols for the NAME argument to `sysconf';
   and the `_CS_*' symbols for the NAME argument to `confstr'.  */
// #include <bits/confname.h>

/* Get file-specific configuration information about PATH.  */
public static native long pathconf(@Cast("const char*") BytePointer __path, int __name);
public static native long pathconf(String __path, int __name);

/* Get file-specific configuration about descriptor FD.  */
public static native long fpathconf(int __fd, int __name);

/* Get the value of the system variable NAME.  */
public static native long sysconf(int __name);

// #ifdef	__USE_POSIX2
/* Get the value of the string-valued system variable NAME.  */
public static native @Cast("size_t") long confstr(int __name, @Cast("char*") BytePointer __buf, @Cast("size_t") long __len);
public static native @Cast("size_t") long confstr(int __name, @Cast("char*") ByteBuffer __buf, @Cast("size_t") long __len);
public static native @Cast("size_t") long confstr(int __name, @Cast("char*") byte[] __buf, @Cast("size_t") long __len);
// #endif


/* Get the process ID of the calling process.  */
public static native @Cast("__pid_t") int getpid();

/* Get the process ID of the calling process's parent.  */
public static native @Cast("__pid_t") int getppid();

/* Get the process group ID of the calling process.
   This function is different on old BSD. */
// #ifndef __FAVOR_BSD
public static native @Cast("__pid_t") int getpgrp();
// #else
// # ifdef __REDIRECT_NTH
// # else
// # endif
// #endif

/* Get the process group ID of process PID.  */
public static native @Cast("__pid_t") int __getpgid(@Cast("__pid_t") int __pid);
// #if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
public static native @Cast("__pid_t") int getpgid(@Cast("__pid_t") int __pid);
// #endif


/* Set the process group ID of the process matching PID to PGID.
   If PID is zero, the current process's process group ID is set.
   If PGID is zero, the process ID of the process is used.  */
public static native int setpgid(@Cast("__pid_t") int __pid, @Cast("__pid_t") int __pgid);

// #if defined __USE_SVID || defined __USE_BSD || defined __USE_XOPEN_EXTENDED
/* Both System V and BSD have `setpgrp' functions, but with different
   calling conventions.  The BSD function is the same as POSIX.1 `setpgid'
   (above).  The System V function takes no arguments and puts the calling
   process in its on group like `setpgid (0, 0)'.

   New programs should always use `setpgid' instead.

   The default in GNU is to provide the System V function.  The BSD
   function is available under -D_BSD_SOURCE.  */

// # ifndef __FAVOR_BSD

/* Set the process group ID of the calling process to its own PID.
   This is exactly the same as `setpgid (0, 0)'.  */
public static native int setpgrp();

// # else

/* Another name for `setpgid' (above).  */
// #  ifdef __REDIRECT_NTH
// #  else
// #  endif

// # endif	/* Favor BSD.  */
// #endif	/* Use SVID or BSD.  */

/* Create a new session with the calling process as its leader.
   The process group IDs of the session and the calling process
   are set to the process ID of the calling process, which is returned.  */
public static native @Cast("__pid_t") int setsid();

// #if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
/* Return the session ID of the given process.  */
public static native @Cast("__pid_t") int getsid(@Cast("__pid_t") int __pid);
// #endif

/* Get the real user ID of the calling process.  */
public static native @Cast("__uid_t") int getuid();

/* Get the effective user ID of the calling process.  */
public static native @Cast("__uid_t") int geteuid();

/* Get the real group ID of the calling process.  */
public static native @Cast("__gid_t") int getgid();

/* Get the effective group ID of the calling process.  */
public static native @Cast("__gid_t") int getegid();

/* If SIZE is zero, return the number of supplementary groups
   the calling process is in.  Otherwise, fill in the group IDs
   of its supplementary groups in LIST and return the number written.  */
public static native int getgroups(int __size, @Cast("__gid_t*") IntPointer __list);
public static native int getgroups(int __size, @Cast("__gid_t*") IntBuffer __list);
public static native int getgroups(int __size, @Cast("__gid_t*") int[] __list);

// #ifdef	__USE_GNU
/* Return nonzero iff the calling process is in group GID.  */
public static native int group_member(@Cast("__gid_t") int __gid);
// #endif

/* Set the user ID of the calling process to UID.
   If the calling process is the super-user, set the real
   and effective user IDs, and the saved set-user-ID to UID;
   if not, the effective user ID is set to UID.  */
public static native int setuid(@Cast("__uid_t") int __uid);

// #if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
/* Set the real user ID of the calling process to RUID,
   and the effective user ID of the calling process to EUID.  */
public static native int setreuid(@Cast("__uid_t") int __ruid, @Cast("__uid_t") int __euid);
// #endif

// #if defined __USE_BSD || defined __USE_XOPEN2K
/* Set the effective user ID of the calling process to UID.  */
public static native int seteuid(@Cast("__uid_t") int __uid);
// #endif /* Use BSD.  */

/* Set the group ID of the calling process to GID.
   If the calling process is the super-user, set the real
   and effective group IDs, and the saved set-group-ID to GID;
   if not, the effective group ID is set to GID.  */
public static native int setgid(@Cast("__gid_t") int __gid);

// #if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
/* Set the real group ID of the calling process to RGID,
   and the effective group ID of the calling process to EGID.  */
public static native int setregid(@Cast("__gid_t") int __rgid, @Cast("__gid_t") int __egid);
// #endif

// #if defined __USE_BSD || defined __USE_XOPEN2K
/* Set the effective group ID of the calling process to GID.  */
public static native int setegid(@Cast("__gid_t") int __gid);
// #endif /* Use BSD.  */

// #ifdef __USE_GNU
/* Fetch the real user ID, effective user ID, and saved-set user ID,
   of the calling process.  */
public static native int getresuid(@Cast("__uid_t*") IntPointer __ruid, @Cast("__uid_t*") IntPointer __euid, @Cast("__uid_t*") IntPointer __suid);
public static native int getresuid(@Cast("__uid_t*") IntBuffer __ruid, @Cast("__uid_t*") IntBuffer __euid, @Cast("__uid_t*") IntBuffer __suid);
public static native int getresuid(@Cast("__uid_t*") int[] __ruid, @Cast("__uid_t*") int[] __euid, @Cast("__uid_t*") int[] __suid);

/* Fetch the real group ID, effective group ID, and saved-set group ID,
   of the calling process.  */
public static native int getresgid(@Cast("__gid_t*") IntPointer __rgid, @Cast("__gid_t*") IntPointer __egid, @Cast("__gid_t*") IntPointer __sgid);
public static native int getresgid(@Cast("__gid_t*") IntBuffer __rgid, @Cast("__gid_t*") IntBuffer __egid, @Cast("__gid_t*") IntBuffer __sgid);
public static native int getresgid(@Cast("__gid_t*") int[] __rgid, @Cast("__gid_t*") int[] __egid, @Cast("__gid_t*") int[] __sgid);

/* Set the real user ID, effective user ID, and saved-set user ID,
   of the calling process to RUID, EUID, and SUID, respectively.  */
public static native int setresuid(@Cast("__uid_t") int __ruid, @Cast("__uid_t") int __euid, @Cast("__uid_t") int __suid);

/* Set the real group ID, effective group ID, and saved-set group ID,
   of the calling process to RGID, EGID, and SGID, respectively.  */
public static native int setresgid(@Cast("__gid_t") int __rgid, @Cast("__gid_t") int __egid, @Cast("__gid_t") int __sgid);
// #endif


/* Clone the calling process, creating an exact copy.
   Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  */
public static native @Cast("__pid_t") int fork();

// #if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8)
//     || defined __USE_BSD
/* Clone the calling process, but without copying the whole address space.
   The calling process is suspended until the new process exits or is
   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
   and the process ID of the new process to the old process.  */
public static native @Cast("__pid_t") int vfork();
// #endif /* Use BSD or XPG < 7. */


/* Return the pathname of the terminal FD is open on, or NULL on errors.
   The returned storage is good only until the next call to this function.  */
public static native @Cast("char*") BytePointer ttyname(int __fd);

/* Store at most BUFLEN characters of the pathname of the terminal FD is
   open on in BUF.  Return 0 on success, otherwise an error number.  */
public static native int ttyname_r(int __fd, @Cast("char*") BytePointer __buf, @Cast("size_t") long __buflen);
public static native int ttyname_r(int __fd, @Cast("char*") ByteBuffer __buf, @Cast("size_t") long __buflen);
public static native int ttyname_r(int __fd, @Cast("char*") byte[] __buf, @Cast("size_t") long __buflen);

/* Return 1 if FD is a valid descriptor associated
   with a terminal, zero if not.  */
public static native int isatty(int __fd);

// #if defined __USE_BSD
//     || (defined __USE_XOPEN_EXTENDED && !defined __USE_UNIX98)
/* Return the index into the active-logins file (utmp) for
   the controlling terminal.  */
public static native int ttyslot();
// #endif


/* Make a link to FROM named TO.  */
public static native int link(@Cast("const char*") BytePointer __from, @Cast("const char*") BytePointer __to);
public static native int link(String __from, String __to);

// #ifdef __USE_ATFILE
/* Like link but relative paths in TO and FROM are interpreted relative
   to FROMFD and TOFD respectively.  */
public static native int linkat(int __fromfd, @Cast("const char*") BytePointer __from, int __tofd,
		   @Cast("const char*") BytePointer __to, int __flags);
public static native int linkat(int __fromfd, String __from, int __tofd,
		   String __to, int __flags);
// #endif

// #if defined __USE_BSD || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K
/* Make a symbolic link to FROM named TO.  */
public static native int symlink(@Cast("const char*") BytePointer __from, @Cast("const char*") BytePointer __to);
public static native int symlink(String __from, String __to);

/* Read the contents of the symbolic link PATH into no more than
   LEN bytes of BUF.  The contents are not null-terminated.
   Returns the number of characters read, or -1 for errors.  */
public static native @Cast("ssize_t") long readlink(@Cast("const char*") BytePointer __path,
			 @Cast("char*") BytePointer __buf, @Cast("size_t") long __len);
public static native @Cast("ssize_t") long readlink(String __path,
			 @Cast("char*") ByteBuffer __buf, @Cast("size_t") long __len);
public static native @Cast("ssize_t") long readlink(@Cast("const char*") BytePointer __path,
			 @Cast("char*") byte[] __buf, @Cast("size_t") long __len);
public static native @Cast("ssize_t") long readlink(String __path,
			 @Cast("char*") BytePointer __buf, @Cast("size_t") long __len);
public static native @Cast("ssize_t") long readlink(@Cast("const char*") BytePointer __path,
			 @Cast("char*") ByteBuffer __buf, @Cast("size_t") long __len);
public static native @Cast("ssize_t") long readlink(String __path,
			 @Cast("char*") byte[] __buf, @Cast("size_t") long __len);
// #endif /* Use BSD.  */

// #ifdef __USE_ATFILE
/* Like symlink but a relative path in TO is interpreted relative to TOFD.  */
public static native int symlinkat(@Cast("const char*") BytePointer __from, int __tofd,
		      @Cast("const char*") BytePointer __to);
public static native int symlinkat(String __from, int __tofd,
		      String __to);

/* Like readlink but a relative PATH is interpreted relative to FD.  */
public static native @Cast("ssize_t") long readlinkat(int __fd, @Cast("const char*") BytePointer __path,
			   @Cast("char*") BytePointer __buf, @Cast("size_t") long __len);
public static native @Cast("ssize_t") long readlinkat(int __fd, String __path,
			   @Cast("char*") ByteBuffer __buf, @Cast("size_t") long __len);
public static native @Cast("ssize_t") long readlinkat(int __fd, @Cast("const char*") BytePointer __path,
			   @Cast("char*") byte[] __buf, @Cast("size_t") long __len);
public static native @Cast("ssize_t") long readlinkat(int __fd, String __path,
			   @Cast("char*") BytePointer __buf, @Cast("size_t") long __len);
public static native @Cast("ssize_t") long readlinkat(int __fd, @Cast("const char*") BytePointer __path,
			   @Cast("char*") ByteBuffer __buf, @Cast("size_t") long __len);
public static native @Cast("ssize_t") long readlinkat(int __fd, String __path,
			   @Cast("char*") byte[] __buf, @Cast("size_t") long __len);
// #endif

/* Remove the link NAME.  */
public static native int unlink(@Cast("const char*") BytePointer __name);
public static native int unlink(String __name);

// #ifdef __USE_ATFILE
/* Remove the link NAME relative to FD.  */
public static native int unlinkat(int __fd, @Cast("const char*") BytePointer __name, int __flag);
public static native int unlinkat(int __fd, String __name, int __flag);
// #endif

/* Remove the directory PATH.  */
public static native int rmdir(@Cast("const char*") BytePointer __path);
public static native int rmdir(String __path);


/* Return the foreground process group ID of FD.  */
public static native @Cast("__pid_t") int tcgetpgrp(int __fd);

/* Set the foreground process group ID of FD set PGRP_ID.  */
public static native int tcsetpgrp(int __fd, @Cast("__pid_t") int __pgrp_id);


/* Return the login name of the user.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
public static native @Cast("char*") BytePointer getlogin();
// #if defined __USE_REENTRANT || defined __USE_POSIX199506
/* Return at most NAME_LEN characters of the login name of the user in NAME.
   If it cannot be determined or some other error occurred, return the error
   code.  Otherwise return 0.

   This function is a possible cancellation points and therefore not
   marked with __THROW.  */
public static native int getlogin_r(@Cast("char*") BytePointer __name, @Cast("size_t") long __name_len);
public static native int getlogin_r(@Cast("char*") ByteBuffer __name, @Cast("size_t") long __name_len);
public static native int getlogin_r(@Cast("char*") byte[] __name, @Cast("size_t") long __name_len);
// #endif

// #ifdef	__USE_BSD
/* Set the login name returned by `getlogin'.  */

// #endif


// #ifdef	__USE_POSIX2
/* Get definitions and prototypes for functions to process the
   arguments in ARGV (ARGC of them, minus the program name) for
   options given in OPTS.  */
// # define __need_getopt
// # include <getopt.h>
// #endif


// #if defined __USE_BSD || defined __USE_UNIX98 || defined __USE_XOPEN2K
/* Put the name of the current host in no more than LEN bytes of NAME.
   The result is null-terminated if LEN is large enough for the full
   name and the terminator.  */
public static native int gethostname(@Cast("char*") BytePointer __name, @Cast("size_t") long __len);
public static native int gethostname(@Cast("char*") ByteBuffer __name, @Cast("size_t") long __len);
public static native int gethostname(@Cast("char*") byte[] __name, @Cast("size_t") long __len);
// #endif


// #if defined __USE_BSD || (defined __USE_XOPEN && !defined __USE_UNIX98)
/* Set the name of the current host to NAME, which is LEN bytes long.
   This call is restricted to the super-user.  */
public static native int sethostname(@Cast("const char*") BytePointer __name, @Cast("size_t") long __len);
public static native int sethostname(String __name, @Cast("size_t") long __len);

/* Set the current machine's Internet number to ID.
   This call is restricted to the super-user.  */
public static native int sethostid(long __id);


/* Get and set the NIS (aka YP) domain name, if any.
   Called just like `gethostname' and `sethostname'.
   The NIS domain name is usually the empty string when not using NIS.  */
public static native int getdomainname(@Cast("char*") BytePointer __name, @Cast("size_t") long __len);
public static native int getdomainname(@Cast("char*") ByteBuffer __name, @Cast("size_t") long __len);
public static native int getdomainname(@Cast("char*") byte[] __name, @Cast("size_t") long __len);
public static native int setdomainname(@Cast("const char*") BytePointer __name, @Cast("size_t") long __len);
public static native int setdomainname(String __name, @Cast("size_t") long __len);


/* Revoke access permissions to all processes currently communicating
   with the control terminal, and then send a SIGHUP signal to the process
   group of the control terminal.  */
public static native int vhangup();

/* Revoke the access of all descriptors currently open on FILE.  */



/* Enable statistical profiling, writing samples of the PC into at most
   SIZE bytes of SAMPLE_BUFFER; every processor clock tick while profiling
   is enabled, the system examines the user PC and increments
   SAMPLE_BUFFER[((PC - OFFSET) / 2) * SCALE / 65536].  If SCALE is zero,
   disable profiling.  Returns zero on success, -1 on error.  */
public static native int profil(@Cast("unsigned short int*") ShortPointer __sample_buffer, @Cast("size_t") long __size,
		   @Cast("size_t") long __offset, @Cast("unsigned int") int __scale);
public static native int profil(@Cast("unsigned short int*") ShortBuffer __sample_buffer, @Cast("size_t") long __size,
		   @Cast("size_t") long __offset, @Cast("unsigned int") int __scale);
public static native int profil(@Cast("unsigned short int*") short[] __sample_buffer, @Cast("size_t") long __size,
		   @Cast("size_t") long __offset, @Cast("unsigned int") int __scale);


/* Turn accounting on if NAME is an existing file.  The system will then write
   a record for each process as it terminates, to this file.  If NAME is NULL,
   turn accounting off.  This call is restricted to the super-user.  */
public static native int acct(@Cast("const char*") BytePointer __name);
public static native int acct(String __name);


/* Successive calls return the shells listed in `/etc/shells'.  */
public static native @Cast("char*") BytePointer getusershell();
public static native void endusershell(); /* Discard cached info.  */
public static native void setusershell(); /* Rewind and re-read the file.  */


/* Put the program in the background, and dissociate from the controlling
   terminal.  If NOCHDIR is zero, do `chdir ("/")'.  If NOCLOSE is zero,
   redirects stdin, stdout, and stderr to /dev/null.  */
public static native int daemon(int __nochdir, int __noclose);
// #endif /* Use BSD || X/Open.  */


// #if defined __USE_BSD || (defined __USE_XOPEN && !defined __USE_XOPEN2K)
/* Make PATH be the root directory (the starting point for absolute paths).
   This call is restricted to the super-user.  */
public static native int chroot(@Cast("const char*") BytePointer __path);
public static native int chroot(String __path);

/* Prompt with PROMPT and read a string from the terminal without echoing.
   Uses /dev/tty if possible; otherwise stderr and stdin.  */
public static native @Cast("char*") BytePointer getpass(@Cast("const char*") BytePointer __prompt);
public static native @Cast("char*") ByteBuffer getpass(String __prompt);
// #endif /* Use BSD || X/Open.  */


// #if defined __USE_BSD || defined __USE_XOPEN || defined __USE_XOPEN2K
/* Make all changes done to FD actually appear on disk.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native int fsync(int __fd);
// #endif /* Use BSD || X/Open || Unix98.  */


// #if defined __USE_BSD || defined __USE_XOPEN_EXTENDED

/* Return identifier for the current host.  */
public static native long gethostid();

/* Make all changes done to all files actually appear on disk.  */
public static native void sync();


// # if defined __USE_BSD || !defined __USE_XOPEN2K
/* Return the number of bytes in a page.  This is the system's page size,
   which is not necessarily the same as the hardware page size.  */
public static native int getpagesize();


/* Return the maximum number of file descriptors
   the current process could possibly have.  */
public static native int getdtablesize();
// # endif

// #endif /* Use BSD || X/Open Unix.  */


// #if defined __USE_BSD || defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8

/* Truncate FILE to LENGTH bytes.  */
// # ifndef __USE_FILE_OFFSET64
public static native int truncate(@Cast("const char*") BytePointer __file, @Cast("__off_t") long __length);
public static native int truncate(String __file, @Cast("__off_t") long __length);
// # else
// # endif
// # ifdef __USE_LARGEFILE64
public static native int truncate64(@Cast("const char*") BytePointer __file, @Cast("__off64_t") long __length);
public static native int truncate64(String __file, @Cast("__off64_t") long __length);
// # endif


/* Truncate the file FD is open on to LENGTH bytes.  */
// # ifndef __USE_FILE_OFFSET64
public static native int ftruncate(int __fd, @Cast("__off_t") long __length);
// # else
// # endif
// # ifdef __USE_LARGEFILE64
public static native int ftruncate64(int __fd, @Cast("__off64_t") long __length);
// # endif

// #endif /* Use BSD || X/Open Unix || POSIX 2003.  */


// #if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K)
//     || defined __USE_MISC

/* Set the end of accessible data space (aka "the break") to ADDR.
   Returns zero on success and -1 for errors (with errno set).  */
public static native int brk(Pointer __addr);

/* Increase or decrease the end of accessible data space by DELTA bytes.
   If successful, returns the address the previous end of data space
   (i.e. the beginning of the new space, if DELTA > 0);
   returns (void *) -1 for errors (with errno set).  */
public static native Pointer sbrk(@Cast("intptr_t") long __delta);
// #endif


// #ifdef __USE_MISC
/* Invoke `system call' number SYSNO, passing it the remaining arguments.
   This is completely system-dependent, and not often useful.

   In Unix, `syscall' sets `errno' for all errors and most calls return -1
   for errors; in many systems you cannot pass arguments or get return
   values for all system calls (`pipe', `fork', and `getppid' typically
   among them).

   In Mach, all system calls take normal arguments and always return an
   error code (zero for success).  */
public static native long syscall(long __sysno);

// #endif	/* Use misc.  */


// #if (defined __USE_MISC || defined __USE_XOPEN_EXTENDED) && !defined F_LOCK
/* NOTE: These declarations also appear in <fcntl.h>; be sure to keep both
   files consistent.  Some systems have them there and some here, and some
   software depends on the macros being defined without including both.  */

/* `lockf' is a simpler interface to the locking facilities of `fcntl'.
   LEN is always relative to the current file position.
   The CMD argument is one of the following.

   This function is a cancellation point and therefore not marked with
   __THROW.  */	/* Unlock a previously locked region.  */	/* Lock a region for exclusive use.  */	/* Test and lock a region for exclusive use.  */	/* Test a region for other processes locks.  */

// # ifndef __USE_FILE_OFFSET64
// # else
// # endif
// # ifdef __USE_LARGEFILE64
// # endif
// #endif /* Use misc and F_LOCK not already defined.  */


// #ifdef __USE_GNU

/* Evaluate EXPRESSION, and repeat as long as it returns -1 with `errno'
   set to EINTR.  */

// # define TEMP_FAILURE_RETRY(expression)
//   (__extension__
//     ({ long int __result;
//        do __result = (long int) (expression);
//        while (__result == -1L && errno == EINTR);
//        __result; }))
// #endif

// #if defined __USE_POSIX199309 || defined __USE_UNIX98
/* Synchronize at least the data part of a file with the underlying
   media.  */
public static native int fdatasync(int __fildes);
// #endif /* Use POSIX199309 */


/* XPG4.2 specifies that prototypes for the encryption functions must
   be defined here.  */
// #ifdef	__USE_XOPEN
/* Encrypt at most 8 characters from KEY using salt to perturb DES.  */
public static native @Cast("char*") BytePointer crypt(@Cast("const char*") BytePointer __key, @Cast("const char*") BytePointer __salt);
public static native @Cast("char*") ByteBuffer crypt(String __key, String __salt);

/* Encrypt data in BLOCK in place if EDFLAG is zero; otherwise decrypt
   block in place.  */
public static native void encrypt(@Cast("char*") BytePointer __block, int __edflag);
public static native void encrypt(@Cast("char*") ByteBuffer __block, int __edflag);
public static native void encrypt(@Cast("char*") byte[] __block, int __edflag);


/* Swab pairs bytes in the first N bytes of the area pointed to by
   FROM and copy the result to TO.  The value of TO must not be in the
   range [FROM - N + 1, FROM - 1].  If N is odd the first byte in FROM
   is without partner.  */
public static native void swab(@Const Pointer __from, Pointer __to,
		  @Cast("ssize_t") long __n);
// #endif


/* The Single Unix specification demands this prototype to be here.
   It is also found in <stdio.h>.  */
// #if defined __USE_XOPEN || defined __USE_XOPEN2K8
/* Return the name of the controlling terminal.  */
public static native @Cast("char*") BytePointer ctermid(@Cast("char*") BytePointer __s);
public static native @Cast("char*") ByteBuffer ctermid(@Cast("char*") ByteBuffer __s);
public static native @Cast("char*") byte[] ctermid(@Cast("char*") byte[] __s);
// #endif


/* Define some macros helping to catch buffer overflows.  */
// #if __USE_FORTIFY_LEVEL > 0 && defined __extern_always_inline
// # include <bits/unistd.h>
// #endif

// #endif /* unistd.h  */


// Parsed from sys/poll.h

/* Compatibility definitions for System V `poll' interface.
   Copyright (C) 1994,1996-2001,2004,2005,2006 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef	_SYS_POLL_H
public static final int _SYS_POLL_H =	1;

// #include <features.h>

/* Get the platform dependent bits of `poll'.  */
// #include <bits/poll.h>
// #ifdef __USE_GNU
/* Get the __sigset_t definition.  */
// # include <bits/sigset.h>
/* Get the timespec definition.  */
// # define __need_timespec
// # include <time.h>
// #endif


/* Type used for the number of file descriptors.  */
// Targeting ../linux/pollfd.java




/* Poll the file descriptors described by the NFDS structures starting at
   FDS.  If TIMEOUT is nonzero and not -1, allow TIMEOUT milliseconds for
   an event to occur; if TIMEOUT is -1, block until an event occurs.
   Returns the number of file descriptors with events, zero if timed out,
   or -1 for errors.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native int poll(pollfd __fds, @Cast("nfds_t") long __nfds, int __timeout);

// #ifdef __USE_GNU
/* Like poll, but before waiting the threads signal mask is replaced
   with that specified in the fourth parameter.  For better usability,
   the timeout value is specified using a TIMESPEC object.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native int ppoll(pollfd __fds, @Cast("nfds_t") long __nfds,
		  @Const timespec __timeout,
		  @Const sigset_t __ss);
// #endif

// #endif	/* sys/poll.h */


// Parsed from sys/reboot.h

/* Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/* This file should define RB_* macros to be used as flag
   bits in the argument to the `reboot' system call.  */

// #ifndef _SYS_REBOOT_H
public static final int _SYS_REBOOT_H =	1;

// #include <features.h>

/* Perform a hard reset now.  */
public static final int RB_AUTOBOOT =	0x01234567;

/* Halt the system.  */
public static final int RB_HALT_SYSTEM =	0xcdef0123;

/* Enable reboot using Ctrl-Alt-Delete keystroke.  */
public static final int RB_ENABLE_CAD =	0x89abcdef;

/* Disable reboot using Ctrl-Alt-Delete keystroke.  */
public static final int RB_DISABLE_CAD =	0;

/* Stop system and switch power off if possible.  */
public static final int RB_POWER_OFF =	0x4321fedc;

/* Reboot or halt the system.  */
public static native int reboot(int __howto);

// #endif	/* _SYS_REBOOT_H */


// Parsed from bits/resource.h

/* Bit values & structures for resource limits.  Linux version.
   Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2004, 2005, 2008, 2009
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef _SYS_RESOURCE_H
// # error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
// #endif

// #include <bits/types.h>

/* Transmute defines to enumerations.  The macro re-definitions are
   necessary because some programs want to test for operating system
   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
   definition is a no-op.  */

/* Kinds of resource limit.  */
/** enum __rlimit_resource */
public static final int
  /* Per-process CPU limit, in seconds.  */
  RLIMIT_CPU = 0,
// #define RLIMIT_CPU RLIMIT_CPU

  /* Largest file that can be created, in bytes.  */
  RLIMIT_FSIZE = 1,
// #define	RLIMIT_FSIZE RLIMIT_FSIZE

  /* Maximum size of data segment, in bytes.  */
  RLIMIT_DATA = 2,
// #define	RLIMIT_DATA RLIMIT_DATA

  /* Maximum size of stack segment, in bytes.  */
  RLIMIT_STACK = 3,
// #define	RLIMIT_STACK RLIMIT_STACK

  /* Largest core file that can be created, in bytes.  */
  RLIMIT_CORE = 4,
// #define	RLIMIT_CORE RLIMIT_CORE

  /* Largest resident set size, in bytes.
     This affects swapping; processes that are exceeding their
     resident set size will be more likely to have physical memory
     taken from them.  */
  __RLIMIT_RSS = 5;
public static final int RLIMIT_RSS = __RLIMIT_RSS;

  /* Number of open files.  */
public static final int
  RLIMIT_NOFILE = 7,
  __RLIMIT_OFILE = RLIMIT_NOFILE; /* BSD name for same.  */
// #define RLIMIT_NOFILE RLIMIT_NOFILE
public static final int RLIMIT_OFILE = __RLIMIT_OFILE;

  /* Address space limit.  */
public static final int
  RLIMIT_AS = 9,
// #define RLIMIT_AS RLIMIT_AS

  /* Number of processes.  */
  __RLIMIT_NPROC = 6;
public static final int RLIMIT_NPROC = __RLIMIT_NPROC;

  /* Locked-in-memory address space.  */
public static final int
  __RLIMIT_MEMLOCK = 8;
public static final int RLIMIT_MEMLOCK = __RLIMIT_MEMLOCK;

  /* Maximum number of file locks.  */
public static final int
  __RLIMIT_LOCKS = 10;
public static final int RLIMIT_LOCKS = __RLIMIT_LOCKS;

  /* Maximum number of pending signals.  */
public static final int
  __RLIMIT_SIGPENDING = 11;
public static final int RLIMIT_SIGPENDING = __RLIMIT_SIGPENDING;

  /* Maximum bytes in POSIX message queues.  */
public static final int
  __RLIMIT_MSGQUEUE = 12;
public static final int RLIMIT_MSGQUEUE = __RLIMIT_MSGQUEUE;

  /* Maximum nice priority allowed to raise to.
     Nice levels 19 .. -20 correspond to 0 .. 39
     values of this resource limit.  */
public static final int
  __RLIMIT_NICE = 13;
public static final int RLIMIT_NICE = __RLIMIT_NICE;

  /* Maximum realtime priority allowed for non-priviledged
     processes.  */
public static final int
  __RLIMIT_RTPRIO = 14;
public static final int RLIMIT_RTPRIO = __RLIMIT_RTPRIO;
public static final int

  __RLIMIT_NLIMITS = 15,
  __RLIM_NLIMITS = __RLIMIT_NLIMITS;
public static final int RLIMIT_NLIMITS = __RLIMIT_NLIMITS;
public static final int RLIM_NLIMITS = __RLIM_NLIMITS;

/* Value to indicate that there is no limit.  */
// #ifndef __USE_FILE_OFFSET64
public static native @MemberGetter long RLIM_INFINITY();
public static final long RLIM_INFINITY = RLIM_INFINITY();
// #else
// #endif

// #ifdef __USE_LARGEFILE64
public static final long RLIM64_INFINITY = 0xffffffffffffffffL;
// #endif

/* We can represent all limits.  */
public static native @MemberGetter long RLIM_SAVED_MAX();
public static final long RLIM_SAVED_MAX = RLIM_SAVED_MAX();
public static native @MemberGetter long RLIM_SAVED_CUR();
public static final long RLIM_SAVED_CUR = RLIM_SAVED_CUR();


/* Type for resource quantity measurement.  */
// #ifndef __USE_FILE_OFFSET64
// #else
// #endif
// #ifdef __USE_LARGEFILE64
// Targeting ../linux/rlimit.java


// Targeting ../linux/rlimit64.java


// #endif

/* Whose usage statistics do you want?  */
/** enum __rusage_who */
public static final int
  /* The calling process.  */
  RUSAGE_SELF = 0,
// #define RUSAGE_SELF RUSAGE_SELF

  /* All of its terminated child processes.  */
  RUSAGE_CHILDREN = -1,
// #define RUSAGE_CHILDREN RUSAGE_CHILDREN
  /* The calling thread.  */
  RUSAGE_THREAD = 1;
// # define RUSAGE_THREAD RUSAGE_THREAD
  /* Name for the same functionality on Solaris.  */
public static final int RUSAGE_LWP = RUSAGE_THREAD;
// #endif

// #define __need_timeval
// #include <bits/time.h>
// Targeting ../linux/rusage.java



/* Priority limits.  */
public static final int PRIO_MIN =	-20;	/* Minimum priority a process can have.  */
public static final int PRIO_MAX =	20;	/* Maximum priority a process can have.  */

/* The type of the WHICH argument to `getpriority' and `setpriority',
   indicating what flavor of entity the WHO argument specifies.  */
/** enum __priority_which */
public static final int
  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
// #define PRIO_PROCESS PRIO_PROCESS
  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
// #define PRIO_PGRP PRIO_PGRP
  PRIO_USER = 2;			/* WHO is a user ID.  */
// #define PRIO_USER PRIO_USER


// Parsed from sys/resource.h

/* Copyright (C) 1992,94,1996-2000,2002,2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef	_SYS_RESOURCE_H
public static final int _SYS_RESOURCE_H =	1;

// #include <features.h>

/* Get the system-dependent definitions of structures and bit values.  */
// #include <bits/resource.h>

// #ifndef __id_t_defined
// # define __id_t_defined
// #endif

/* The X/Open standard defines that all the functions below must use
   `int' as the type for the first argument.  When we are compiling with
   GNU extensions we change this slightly to provide better error
   checking.  */
// #if defined __USE_GNU && !defined __cplusplus
// #else
// #endif

/* Put the soft and hard limits for RESOURCE in *RLIMITS.
   Returns 0 if successful, -1 if not (and sets errno).  */
// #ifndef __USE_FILE_OFFSET64
public static native int getrlimit(@Cast("__rlimit_resource_t") int __resource,
		      rlimit __rlimits);
// #else
// #endif
// #ifdef __USE_LARGEFILE64
public static native int getrlimit64(@Cast("__rlimit_resource_t") int __resource,
			rlimit64 __rlimits);
// #endif

/* Set the soft and hard limits for RESOURCE to *RLIMITS.
   Only the super-user can increase hard limits.
   Return 0 if successful, -1 if not (and sets errno).  */
// #ifndef __USE_FILE_OFFSET64
public static native int setrlimit(@Cast("__rlimit_resource_t") int __resource,
		      @Const rlimit __rlimits);
// #else
// #endif
// #ifdef __USE_LARGEFILE64
public static native int setrlimit64(@Cast("__rlimit_resource_t") int __resource,
			@Const rlimit64 __rlimits);
// #endif

/* Return resource usage information on process indicated by WHO
   and put it in *USAGE.  Returns 0 for success, -1 for failure.  */
public static native int getrusage(@Cast("__rusage_who_t") int __who, rusage __usage);

/* Return the highest priority of any process specified by WHICH and WHO
   (see above); if WHO is zero, the current process, process group, or user
   (as specified by WHO) is used.  A lower priority number means higher
   priority.  Priorities range from PRIO_MIN to PRIO_MAX (above).  */
public static native int getpriority(@Cast("__priority_which_t") int __which, @Cast("id_t") int __who);

/* Set the priority of all processes specified by WHICH and WHO (see above)
   to PRIO.  Returns 0 on success, -1 on errors.  */
public static native int setpriority(@Cast("__priority_which_t") int __which, @Cast("id_t") int __who, int __prio);

// #endif	/* sys/resource.h  */


// Parsed from sys/sysctl.h

/* Copyright (C) 1996, 1999, 2002, 2003, 2004 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef	_SYS_SYSCTL_H
public static final int _SYS_SYSCTL_H =	1;

// #include <features.h>
// #define __need_size_t
// #include <stddef.h>
/* Prevent more kernel headers than necessary to be included.  */
// #ifndef _LINUX_KERNEL_H
// # define _LINUX_KERNEL_H	1
// # define __undef_LINUX_KERNEL_H
// #endif
// #ifndef _LINUX_TYPES_H
public static final int _LINUX_TYPES_H =		1;
// # define __undef_LINUX_TYPES_H
// #endif
// #ifndef _LINUX_LIST_H
public static final int _LINUX_LIST_H =		1;
// # define __undef_LINUX_LIST_H
// #endif
// #ifndef __LINUX_COMPILER_H
public static final int __LINUX_COMPILER_H =	1;
// # define __user
// # define __undef__LINUX_COMPILER_H
// #endif

// #include <linux/sysctl.h>

// #ifdef __undef_LINUX_KERNEL_H
// #endif
// #ifdef __undef_LINUX_TYPES_H
// #endif
// #ifdef __undef_LINUX_LIST_H
// #endif
// #ifdef __undef__LINUX_COMPILER_H
// #endif

/* Read or write system parameters.  */
public static native int sysctl(@Cast("int*") IntPointer __name, int __nlen, Pointer __oldval,
		   @Cast("size_t*") SizeTPointer __oldlenp, Pointer __newval, @Cast("size_t") long __newlen);
public static native int sysctl(@Cast("int*") IntBuffer __name, int __nlen, Pointer __oldval,
		   @Cast("size_t*") SizeTPointer __oldlenp, Pointer __newval, @Cast("size_t") long __newlen);
public static native int sysctl(@Cast("int*") int[] __name, int __nlen, Pointer __oldval,
		   @Cast("size_t*") SizeTPointer __oldlenp, Pointer __newval, @Cast("size_t") long __newlen);

// #endif	/* _SYS_SYSCTL_H */


// Parsed from bits/waitflags.h

/* Definitions of flag bits for `waitpid' et al.
   Copyright (C) 1992,1996,1997,2000,2004,2005 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #if !defined _SYS_WAIT_H && !defined _STDLIB_H
// # error "Never include <bits/waitflags.h> directly; use <sys/wait.h> instead."
// #endif


/* Bits in the third argument to `waitpid'.  */
public static final int WNOHANG =		1;	/* Don't block waiting.  */
public static final int WUNTRACED =	2;	/* Report status of stopped children.  */

/* Bits in the fourth argument to `waitid'.  */
public static final int WSTOPPED =	2;	/* Report stopped child (same as WUNTRACED). */
public static final int WEXITED =		4;	/* Report dead child.  */
public static final int WCONTINUED =	8;	/* Report continued child.  */
public static final int WNOWAIT =		0x01000000; /* Don't reap, just poll status.  */

public static final int __WNOTHREAD =     0x20000000; /* Don't wait on children of other threads
				      in this group */
public static final int __WALL =		0x40000000; /* Wait for any child.  */
public static final int __WCLONE =	0x80000000; /* Wait for cloned process.  */


// Parsed from sys/wait.h

/* Copyright (C) 1991-1994,1996-2001,2003,2004,2005,2007,2009,2010
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

/*
 *	POSIX Standard: 3.2.1 Wait for Process Termination	<sys/wait.h>
 */

// #ifndef	_SYS_WAIT_H
public static final int _SYS_WAIT_H =	1;

// #include <features.h>

// #include <signal.h>
// #include <sys/resource.h>

/* These macros could also be defined in <stdlib.h>.  */
// #if !defined _STDLIB_H || (!defined __USE_XOPEN && !defined __USE_XOPEN2K8)
/* This will define the `W*' macros for the flag
   bits to `waitpid', `wait3', and `wait4'.  */
// # include <bits/waitflags.h>

// # ifdef	__USE_BSD

/* Lots of hair to allow traditional BSD use of `union wait'
   as well as POSIX.1 use of `int' for the status word.  */

// #  if defined __GNUC__ && !defined __cplusplus
// #   define __WAIT_INT(status)
//   (__extension__ (((union { __typeof(status) __in; int __i; })
// 		   { .__in = (status) }).__i))
// #  else
// #   define __WAIT_INT(status)	(*(__const int *) &(status))
// #  endif

/* This is the type of the argument to `wait'.  The funky union
   causes redeclarations with either `int *' or `union wait *' to be
   allowed without complaint.  __WAIT_STATUS_DEFN is the type used in
   the actual function definitions.  */

// #  if !defined __GNUC__ || __GNUC__ < 2 || defined __cplusplus
// #   define __WAIT_STATUS	void *
// #   define __WAIT_STATUS_DEFN	void *
// #  else
// #  endif

// # else /* Don't use BSD.  */

// # endif /* Use BSD.  */

/* This will define all the `__W*' macros.  */
// # include <bits/waitstatus.h>

// # define WEXITSTATUS(status)	__WEXITSTATUS (__WAIT_INT (status))
// # define WTERMSIG(status)	__WTERMSIG (__WAIT_INT (status))
// # define WSTOPSIG(status)	__WSTOPSIG (__WAIT_INT (status))
// # define WIFEXITED(status)	__WIFEXITED (__WAIT_INT (status))
// # define WIFSIGNALED(status)	__WIFSIGNALED (__WAIT_INT (status))
// # define WIFSTOPPED(status)	__WIFSTOPPED (__WAIT_INT (status))
// # ifdef __WIFCONTINUED
// #  define WIFCONTINUED(status)	__WIFCONTINUED (__WAIT_INT (status))
// # endif
// #endif	/* <stdlib.h> not included.  */

// #ifdef	__USE_BSD
public static native @MemberGetter int WCOREFLAG();
public static final int WCOREFLAG = WCOREFLAG();
// # define WCOREDUMP(status)	__WCOREDUMP (__WAIT_INT (status))
// # define W_EXITCODE(ret, sig)	__W_EXITCODE (ret, sig)
// # define W_STOPCODE(sig)	__W_STOPCODE (sig)
// #endif

/* The following values are used by the `waitid' function.  */
// #if defined __USE_SVID || defined __USE_XOPEN || defined __USE_XOPEN2K8
/** enum idtype_t */
public static final int
  P_ALL = 0,		/* Wait for any child.  */
  P_PID = 1,		/* Wait for specified process.  */
  P_PGID = 2;		/* Wait for members of process group.  */
// #endif


/* Wait for a child to die.  When one does, put its status in *STAT_LOC
   and return its process ID.  For errors, return (pid_t) -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("__pid_t") @Name("wait") int _wait(Pointer __stat_loc);

// #ifdef	__USE_BSD
/* Special values for the PID argument to `waitpid' and `wait4'.  */
public static final int WAIT_ANY =	(-1);	/* Any process.  */
public static final int WAIT_MYPGRP =	0;	/* Any process in my process group.  */
// #endif

/* Wait for a child matching PID to die.
   If PID is greater than 0, match any process whose process ID is PID.
   If PID is (pid_t) -1, match any process.
   If PID is (pid_t) 0, match any process with the
   same process group as the current process.
   If PID is less than -1, match any process whose
   process group is the absolute value of PID.
   If the WNOHANG bit is set in OPTIONS, and that child
   is not already dead, return (pid_t) 0.  If successful,
   return PID and store the dead child's status in STAT_LOC.
   Return (pid_t) -1 for errors.  If the WUNTRACED bit is
   set in OPTIONS, return status for stopped children; otherwise don't.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native @Cast("__pid_t") int waitpid(@Cast("__pid_t") int __pid, @Cast("int*") IntPointer __stat_loc, int __options);
public static native @Cast("__pid_t") int waitpid(@Cast("__pid_t") int __pid, @Cast("int*") IntBuffer __stat_loc, int __options);
public static native @Cast("__pid_t") int waitpid(@Cast("__pid_t") int __pid, @Cast("int*") int[] __stat_loc, int __options);

// #if defined __USE_SVID || defined __USE_XOPEN || defined __USE_XOPEN2K8
// # define __need_siginfo_t
// # include <bits/siginfo.h>
/* Wait for a childing matching IDTYPE and ID to change the status and
   place appropriate information in *INFOP.
   If IDTYPE is P_PID, match any process whose process ID is ID.
   If IDTYPE is P_PGID, match any process whose process group is ID.
   If IDTYPE is P_ALL, match any process.
   If the WNOHANG bit is set in OPTIONS, and that child
   is not already dead, clear *INFOP and return 0.  If successful, store
   exit code and status in *INFOP.

   This function is a cancellation point and therefore not marked with
   __THROW.  */
public static native int waitid(@Cast("idtype_t") int __idtype, @Cast("__id_t") int __id, siginfo_t __infop,
		   int __options);
// #endif

// #if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
/* This being here makes the prototypes valid whether or not
   we have already included <sys/resource.h> to define `struct rusage'.  */

/* Wait for a child to exit.  When one does, put its status in *STAT_LOC and
   return its process ID.  For errors return (pid_t) -1.  If USAGE is not
   nil, store information about the child's resource usage there.  If the
   WUNTRACED bit is set in OPTIONS, return status for stopped children;
   otherwise don't.  */
public static native @Cast("__pid_t") int wait3(Pointer __stat_loc, int __options,
		      rusage __usage);
// #endif

// #ifdef __USE_BSD
/* PID is like waitpid.  Other args are like wait3.  */
public static native @Cast("__pid_t") int wait4(@Cast("__pid_t") int __pid, Pointer __stat_loc, int __options,
		      rusage __usage);
// #endif /* Use BSD.  */


// #endif /* sys/wait.h  */


// Parsed from linux/kernel.h

// #ifndef _LINUX_KERNEL_H
// #define _LINUX_KERNEL_H

/*
 * 'kernel.h' contains some often-used function prototypes etc
 */



public static final int SI_LOAD_SHIFT =	16;
// Targeting ../linux/sysinfo.java



/* Force a compilation error if condition is true */
// #define BUILD_BUG_ON(condition) ((void)BUILD_BUG_ON_ZERO(condition))

/* Force a compilation error if condition is constant and true */
// #define MAYBE_BUILD_BUG_ON(cond) ((void)sizeof(char[1 - 2 * !!(cond)]))

/* Force a compilation error if a constant expression is not a power of 2 */
// #define BUILD_BUG_ON_NOT_POWER_OF_2(n)
// 	BUILD_BUG_ON((n) == 0 || (((n) & ((n) - 1)) != 0))

/* Force a compilation error if condition is true, but also produce a
   result (of value 0 and type size_t), so the expression can be used
   e.g. in a structure initializer (or where-ever else comma expressions
   aren't permitted). */
// #define BUILD_BUG_ON_ZERO(e) (sizeof(struct { int:-!!(e); }))
// #define BUILD_BUG_ON_NULL(e) ((void *)sizeof(struct { int:-!!(e); }))

/* Trap pasters of __FUNCTION__ at compile-time */
// #define __FUNCTION__ (__func__)

/* This helps us to avoid #ifdef CONFIG_NUMA */
// #ifdef CONFIG_NUMA
public static final int NUMA_BUILD = 1;
// #else
// #endif

/* This helps us avoid #ifdef CONFIG_COMPACTION */
// #ifdef CONFIG_COMPACTION
public static final int COMPACTION_BUILD = 1;
// #else
// #endif

/* Rebuild everything on CONFIG_FTRACE_MCOUNT_RECORD */
// #ifdef CONFIG_FTRACE_MCOUNT_RECORD
// # define REBUILD_DUE_TO_FTRACE_MCOUNT_RECORD
// #endif

public static native void mark_hardware_unsupported(@Cast("const char*") BytePointer msg);
public static native void mark_hardware_unsupported(String msg);
public static native void mark_tech_preview(@Cast("const char*") BytePointer msg, @Cast("module*") Pointer mod);
public static native void mark_tech_preview(String msg, @Cast("module*") Pointer mod);
// #else
// #endif


// Parsed from sys/sysinfo.h

/* Copyright (C) 1996, 1999, 2001 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

// #ifndef _SYS_SYSINFO_H
public static final int _SYS_SYSINFO_H =	1;

// #include <features.h>

/* Get sysinfo structure from kernel header.  */
// #include <linux/kernel.h>

/* Returns information on overall system statistics.  */
public static native int sysinfo(sysinfo __info);


/* Return number of configured processors.  */
public static native int get_nprocs_conf();

/* Return number of available processors.  */
public static native int get_nprocs();


/* Return number of physical pages of memory in the system.  */
public static native long get_phys_pages();

/* Return number of available physical pages of memory in the system.  */
public static native long get_avphys_pages();

// #endif	/* sys/sysinfo.h */


}
