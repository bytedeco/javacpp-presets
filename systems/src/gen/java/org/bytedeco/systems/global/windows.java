// Targeted by JavaCPP version 1.5.7: DO NOT EDIT THIS FILE

package org.bytedeco.systems.global;

import org.bytedeco.systems.windows.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

public class windows extends org.bytedeco.systems.presets.windows {
    static { Loader.load(); }

// Parsed from minwindef.h

/****************************************************************************
*                                                                           *
* minwindef.h -- Basic Windows Type Definitions for minwin partition        *
*                                                                           *
* Copyright (c) Microsoft Corporation. All rights reserved.                 *
*                                                                           *
****************************************************************************/


// #ifndef _MINWINDEF_
// #define _MINWINDEF_
// #pragma once

// #include <specstrings.h>

// #include <winapifamily.h>

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

// #ifndef NO_STRICT
// #ifndef STRICT
public static final int STRICT = 1;
// #endif
// #endif /* NO_STRICT */

// Win32 defines _WIN32 automatically,
// but Macintosh doesn't, so if we are using
// Win32 Functions, we must do it here

// #ifdef _MAC
// #endif //_MAC

// #ifndef WIN32
// #define WIN32
// #endif

// #ifdef __cplusplus
// #endif

/*
 * BASETYPES is defined in ntdef.h if these types are already defined
 */

// #ifndef BASETYPES
// #define BASETYPES
// #endif  /* !BASETYPES */

public static final int MAX_PATH =          260;

// #ifndef NULL
// #ifdef __cplusplus
public static final int NULL =    0;
// #else
// #endif
// #endif

// #ifndef FALSE
public static final int FALSE =               0;
// #endif

// #ifndef TRUE
public static final int TRUE =                1;
// #endif

// #ifndef IN
// #define IN
// #endif

// #ifndef OUT
// #define OUT
// #endif

// #ifndef OPTIONAL
// #define OPTIONAL
// #endif

// #undef far
// #undef near
// #undef pascal

// #define far
// #define near

// #if (!defined(_MAC)) && ((_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED))
// #define pascal __stdcall
// #else
// #define pascal
// #endif

// #if defined(DOSWIN32) || defined(_MAC)
// #define cdecl _cdecl
// #ifndef CDECL
// #define CDECL _cdecl
// #endif
// #else
// #define cdecl
// #ifndef CDECL
// #define CDECL
// #endif
// #endif

// #ifdef _MAC
// #elif (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
// #define CALLBACK    __stdcall
// #define WINAPI      __stdcall
// #define WINAPIV     __cdecl
// #define APIENTRY    WINAPI
// #define APIPRIVATE  __stdcall
// #define PASCAL      __stdcall
// #else
// #endif

// #ifndef _M_CEE_PURE
// #ifndef WINAPI_INLINE
// #define WINAPI_INLINE  WINAPI
// #endif
// #endif

// #undef FAR
// #undef  NEAR
// #define FAR                 far
// #define NEAR                near
// #ifndef CONST
// #define CONST               const
// #endif
// Targeting ..\windows\LPVOID.java


// Targeting ..\windows\LPCVOID.java




// #ifndef NT_INCLUDED
// #include <winnt.h>
// #endif /* NT_INCLUDED */

/* Types use for passing & returning polymorphic values */

// #ifndef NOMINMAX

// #ifndef max
// #define max(a,b)            (((a) > (b)) ? (a) : (b))
// #endif

// #ifndef min
// #define min(a,b)            (((a) < (b)) ? (a) : (b))
// #endif

// #endif  /* NOMINMAX */

// #define MAKEWORD(a, b)      ((WORD)(((BYTE)(((DWORD_PTR)(a)) & 0xff)) | ((WORD)((BYTE)(((DWORD_PTR)(b)) & 0xff))) << 8))
// #define MAKELONG(a, b)      ((LONG)(((WORD)(((DWORD_PTR)(a)) & 0xffff)) | ((DWORD)((WORD)(((DWORD_PTR)(b)) & 0xffff))) << 16))
// #define LOWORD(l)           ((WORD)(((DWORD_PTR)(l)) & 0xffff))
// #define HIWORD(l)           ((WORD)((((DWORD_PTR)(l)) >> 16) & 0xffff))
// #define LOBYTE(w)           ((BYTE)(((DWORD_PTR)(w)) & 0xff))
// #define HIBYTE(w)           ((BYTE)((((DWORD_PTR)(w)) >> 8) & 0xff))
// Targeting ..\windows\FARPROC.java


// Targeting ..\windows\NEARPROC.java


// Targeting ..\windows\PROC.java


// #else
// #endif  // _WIN64
// #else
// #endif
// #else
// #endif   //BUGBUG - might want to remove this from minwin



      /* HMODULEs can be used in place of HINSTANCEs */









// #ifndef _MAC
// Targeting ..\windows\FILETIME.java


// #define _FILETIME_

// #ifdef __cplusplus
// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #endif // _MINWINDEF_



// Parsed from guiddef.h

//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       guiddef.h
//
//  Contents:   GUID definition
//
//----------------------------------------------------------------------------

// #ifndef GUID_DEFINED
// #define GUID_DEFINED
// Targeting ..\windows\GUID.java


// #endif
// #endif

// #ifndef FAR
// #ifdef _WIN32
// #define FAR
// #else
// #define FAR _far
// #endif
// #endif

// #ifndef DECLSPEC_SELECTANY
// #if (_MSC_VER >= 1100)
// #define DECLSPEC_SELECTANY  __declspec(selectany)
// #else
// #define DECLSPEC_SELECTANY
// #endif
// #endif

// #ifndef EXTERN_C
// #ifdef __cplusplus
// #define EXTERN_C    extern "C"
// #else
// #endif
// #endif

// #ifdef DEFINE_GUID
// #undef DEFINE_GUID
// #endif

// #ifdef INITGUID
// #define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)
//         EXTERN_C const GUID DECLSPEC_SELECTANY name
//                 = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
// #else
// #define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)
//     EXTERN_C const GUID FAR name
// #endif // INITGUID

// #define DEFINE_OLEGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

// #ifndef _GUIDDEF_H_
// #define _GUIDDEF_H_

// #ifndef __LPGUID_DEFINED__
// #define __LPGUID_DEFINED__
// #endif

// #ifndef __LPCGUID_DEFINED__
// #define __LPCGUID_DEFINED__
// #endif

// #ifndef __IID_DEFINED__
// #define __IID_DEFINED__
public static native @MemberGetter @ByVal GUID IID_NULL();
public static final GUID IID_NULL = IID_NULL();
// #define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
public static native @MemberGetter @ByVal GUID CLSID_NULL();
public static final GUID CLSID_NULL = CLSID_NULL();
// #define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)
public static native @MemberGetter @ByVal GUID FMTID_NULL();
public static final GUID FMTID_NULL = FMTID_NULL();
// #define IsEqualFMTID(rfmtid1, rfmtid2) IsEqualGUID(rfmtid1, rfmtid2)

// #ifdef __midl_proxy
// #define __MIDL_CONST
// #else
// #define __MIDL_CONST const
// #endif

// #ifndef _REFGUID_DEFINED
// #define _REFGUID_DEFINED
// #ifdef __cplusplus
// #define REFGUID const GUID &
// #else
// #endif
// #endif

// #ifndef _REFIID_DEFINED
// #define _REFIID_DEFINED
// #ifdef __cplusplus
// #define REFIID const IID &
// #else
// #endif
// #endif

// #ifndef _REFCLSID_DEFINED
// #define _REFCLSID_DEFINED
// #ifdef __cplusplus
// #define REFCLSID const IID &
// #else
// #endif
// #endif

// #ifndef _REFFMTID_DEFINED
// #define _REFFMTID_DEFINED
// #ifdef __cplusplus
// #define REFFMTID const IID &
// #else
// #endif
// #endif

// #endif // !__IID_DEFINED__

// #if !defined (__midl)
// #if !defined (_SYS_GUID_OPERATORS_)
// #define _SYS_GUID_OPERATORS_
// #include <string.h>

// Faster (but makes code fatter) inline version...use sparingly
// #ifdef __cplusplus
public static native int InlineIsEqualGUID(@Const @ByRef GUID rguid1, @Const @ByRef GUID rguid2);

public static native int IsEqualGUID(@Const @ByRef GUID rguid1, @Const @ByRef GUID rguid2);

// #else   // ! __cplusplus

// #endif  // __cplusplus

// #ifdef __INLINE_ISEQUAL_GUID
// #undef IsEqualGUID
// #define IsEqualGUID(rguid1, rguid2) InlineIsEqualGUID(rguid1, rguid2)
// #endif

// Same type, different name

// #define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
// #define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)


// #if !defined _SYS_GUID_OPERATOR_EQ_ && !defined _NO_SYS_GUID_OPERATOR_EQ_
// #define _SYS_GUID_OPERATOR_EQ_
// A couple of C++ helpers

// #ifdef __cplusplus
public static native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef GUID guidOne, @Const @ByRef GUID guidOther);

public static native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef GUID guidOne, @Const @ByRef GUID guidOther);
// #endif
// #endif  // _SYS_GUID_OPERATOR_EQ_
// #endif  // _SYS_GUID_OPERATORS_
// #endif  // __midl
// #endif  // _GUIDDEF_H_


// Parsed from winnt.h

/*++ BUILD Version: 0073     Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    winnt.h

Abstract:

    This module defines the 32-Bit Windows types and constants that are
    defined by NT, but exposed through the Win32 API.

Revision History:

--*/

// #ifndef _WINNT_
// #define _WINNT_

// #if _MSC_VER >= 1200
// #pragma warning(push)
// #endif
// #pragma warning(disable:4201) // named type definition in parentheses
// #pragma warning(disable:4214) // bit field types other than int

// #ifdef __cplusplus
// #endif

// #include <ctype.h>  
// #include <winapifamily.h>  
public static final int ANYSIZE_ARRAY = 1;       

//
// For compilers that don't support nameless unions/structs
//
// #ifndef DUMMYUNIONNAME
// #if defined(NONAMELESSUNION) || !defined(_MSC_EXTENSIONS)
// #else
// #define DUMMYUNIONNAME
// #define DUMMYUNIONNAME2
// #define DUMMYUNIONNAME3
// #define DUMMYUNIONNAME4
// #define DUMMYUNIONNAME5
// #define DUMMYUNIONNAME6
// #define DUMMYUNIONNAME7
// #define DUMMYUNIONNAME8
// #define DUMMYUNIONNAME9
// #endif
// #endif // DUMMYUNIONNAME

// #ifndef DUMMYSTRUCTNAME
// #if defined(NONAMELESSUNION) || !defined(_MSC_EXTENSIONS)
// #else
// #define DUMMYSTRUCTNAME
// #define DUMMYSTRUCTNAME2
// #define DUMMYSTRUCTNAME3
// #define DUMMYSTRUCTNAME4
// #define DUMMYSTRUCTNAME5
// #define DUMMYSTRUCTNAME6
// #endif
// #endif // DUMMYSTRUCTNAME

// end_ntoshvp

// #include <specstrings.h>
// #include <kernelspecs.h>

// #if defined(STRICT_GS_ENABLED)
// #pragma strict_gs_check(push, on)
// #endif

// begin_ntoshvp

// #if defined(_M_MRX000) && !(defined(MIDL_PASS) || defined(RC_INVOKED)) && defined(ENABLE_RESTRICTED)
// #define RESTRICTED_POINTER __restrict
// #else
// #define RESTRICTED_POINTER
// #endif

// #if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) || defined(_M_AMD64) || defined(_M_ARM)
// #define ALIGNMENT_MACHINE
// #if defined(_WIN64)
// #else
// #endif
// #else
// #undef ALIGNMENT_MACHINE
// #define UNALIGNED
// #define UNALIGNED64
// #endif

// end_ntoshvp


// #if defined(_WIN64) || defined(_M_ALPHA)
public static native @MemberGetter int MAX_NATURAL_ALIGNMENT();
public static final int MAX_NATURAL_ALIGNMENT = MAX_NATURAL_ALIGNMENT();
public static final int MEMORY_ALLOCATION_ALIGNMENT = 16;
// #else
// #endif

//
// TYPE_ALIGNMENT will return the alignment requirements of a given type for
// the current platform.
//

// #ifdef __cplusplus
// #if _MSC_VER >= 1300
// #define TYPE_ALIGNMENT( t ) __alignof(t)
// #endif
// #else
// #endif

//
// Note: RC_INVOKED is checked in PROBE_ALIGNMENT to maintain compatibility with previous
//       versions of the SDK which did not block inclusion in an .RC file.
//

// #if defined(_AMD64_) || defined(_X86_)
// #define PROBE_ALIGNMENT( _s ) TYPE_ALIGNMENT( DWORD )
// #elif defined(_IA64_) || defined(_ARM_)
// #define PROBE_ALIGNMENT( _s ) (TYPE_ALIGNMENT( _s ) > TYPE_ALIGNMENT( DWORD ) ?
//                               TYPE_ALIGNMENT( _s ) : TYPE_ALIGNMENT( DWORD ))
// #elif !defined(RC_INVOKED)
// #error "No Target Architecture"
// #endif

// #if defined(_WIN64)

// #define PROBE_ALIGNMENT32( _s ) TYPE_ALIGNMENT( DWORD )

// #endif

// begin_ntoshvp

//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

// #ifndef SORTPP_PASS
// #define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
// #else
// #define C_ASSERT(e) /* nothing */
// #endif

// #include <basetsd.h>


// #if (defined(_M_IX86) || defined(_M_IA64) || defined(_M_AMD64) || defined(_M_ARM)) && !defined(MIDL_PASS)
// #define DECLSPEC_IMPORT __declspec(dllimport)
// #else
// #define DECLSPEC_IMPORT
// #endif

// #ifndef DECLSPEC_NORETURN
// #if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
// #define DECLSPEC_NORETURN   __declspec(noreturn)
// #else
// #define DECLSPEC_NORETURN
// #endif
// #endif

// #ifndef DECLSPEC_NOTHROW
// #if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
// #define DECLSPEC_NOTHROW   __declspec(nothrow)
// #else
// #define DECLSPEC_NOTHROW
// #endif
// #endif

// #ifndef DECLSPEC_ALIGN
// #if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
// #define DECLSPEC_ALIGN(x)   __declspec(align(x))
// #else
// #define DECLSPEC_ALIGN(x)
// #endif
// #endif

// end_ntoshvp

// #ifndef SYSTEM_CACHE_ALIGNMENT_SIZE
// #if defined(_AMD64_) || defined(_X86_)
public static final int SYSTEM_CACHE_ALIGNMENT_SIZE = 64;
// #else
// #endif
// #endif

// #ifndef DECLSPEC_CACHEALIGN
// #define DECLSPEC_CACHEALIGN DECLSPEC_ALIGN(SYSTEM_CACHE_ALIGNMENT_SIZE)
// #endif

// #ifndef DECLSPEC_UUID
// #if (_MSC_VER >= 1100) && defined (__cplusplus)
// #define DECLSPEC_UUID(x)    __declspec(uuid(x))
// #else
// #define DECLSPEC_UUID(x)
// #endif
// #endif

// #ifndef DECLSPEC_NOVTABLE
// #if (_MSC_VER >= 1100) && defined(__cplusplus)
// #define DECLSPEC_NOVTABLE   __declspec(novtable)
// #else
// #define DECLSPEC_NOVTABLE
// #endif
// #endif

// #ifndef DECLSPEC_SELECTANY
// #if (_MSC_VER >= 1100)
// #define DECLSPEC_SELECTANY  __declspec(selectany)
// #else
// #define DECLSPEC_SELECTANY
// #endif
// #endif

// #ifndef NOP_FUNCTION
// #if (_MSC_VER >= 1210)
// #define NOP_FUNCTION __noop
// #else
// #define NOP_FUNCTION (void)0
// #endif
// #endif

// #ifndef DECLSPEC_ADDRSAFE
// #if (_MSC_VER >= 1200) && (defined(_M_ALPHA) || defined(_M_AXP64))
// #define DECLSPEC_ADDRSAFE  __declspec(address_safe)
// #else
// #define DECLSPEC_ADDRSAFE
// #endif
// #endif

// #ifndef DECLSPEC_NOINLINE
// #if (_MSC_VER >= 1300)
// #define DECLSPEC_NOINLINE  __declspec(noinline)
// #else
// #define DECLSPEC_NOINLINE
// #endif
// #endif

// #ifndef DECLSPEC_SAFEBUFFERS
// #if (_MSC_VER >= 1300)
// #define DECLSPEC_SAFEBUFFERS  __declspec(safebuffers)
// #else
// #define DECLSPEC_SAFEBUFFERS
// #endif
// #endif


// #ifndef DECLSPEC_GUARDNOCF
// #if (_MSC_FULL_VER >= 170065501)
// #define DECLSPEC_GUARDNOCF  __declspec(guard(nocf))
// #else
// #define DECLSPEC_GUARDNOCF
// #endif
// #endif

// begin_ntoshvp

// #ifndef FORCEINLINE
// #if (_MSC_VER >= 1200)
// #else
// #endif
// #endif

//
// CFORCEINLINE: __forceinline required for correctness.
//

// #define CFORCEINLINE FORCEINLINE

//
// STKFORCEINLINE: __forceinline required for correctness due to counting stack
//                 frames for a stack trace being captured.
//

// #define STKFORCEINLINE FORCEINLINE

// #define ICEFORCEINLINE FORCEINLINE

// end_ntoshvp

// #ifndef DECLSPEC_DEPRECATED
// #if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
// #define DECLSPEC_DEPRECATED   __declspec(deprecated)
// #define DEPRECATE_SUPPORTED
// #else
// #define DECLSPEC_DEPRECATED
// #undef  DEPRECATE_SUPPORTED
// #endif
// #endif

// #ifdef DEPRECATE_DDK_FUNCTIONS
// #ifdef _NTDDK_
// #define DECLSPEC_DEPRECATED_DDK DECLSPEC_DEPRECATED
// #ifdef DEPRECATE_SUPPORTED
public static final int PRAGMA_DEPRECATED_DDK = 1;
// #endif
// #else
// #define DECLSPEC_DEPRECATED_DDK
// #endif
// #else
// #define DECLSPEC_DEPRECATED_DDK
// Targeting ..\windows\PVOID.java


// Targeting ..\windows\POINTER_64.java




// #if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
// #else
// #endif

// #if !defined(_M_CEE_PURE)
// #define NTAPI_INLINE    NTAPI
// #else
// #define NTAPI_INLINE
// #endif

//
// Define API decoration for direct importing system DLL references.
//

// #if !defined(_NTSYSTEM_)
// #define NTSYSAPI     DECLSPEC_IMPORT
// #define NTSYSCALLAPI DECLSPEC_IMPORT
// #else
// #define NTSYSAPI
// #if defined(_NTDLLBUILD_)
// #define NTSYSCALLAPI
// #else
// #define NTSYSCALLAPI DECLSPEC_ADDRSAFE
// #endif

// #endif


//
// Basics
//

// #ifndef VOID
// #define VOID void
// #if !defined(MIDL_PASS)
// #endif
// #endif

//
// UNICODE (Wide Character) types
//

// #ifndef _MAC    // wc,   16-bit UNICODE character
// #else
// #endif

// #if _WIN32_WINNT >= 0x0600 || (defined(__cplusplus) && defined(WINDOWS_ENABLE_CPLUSPLUS))

//
//  UCS (Universal Character Set) types
//

//
//  Even pre-Unicode agreement, UCS values are always in the
//  range U+00000000 to U+7FFFFFFF, so we'll pick an obvious
//  value.

public static final int UCSCHAR_INVALID_CHARACTER = (0xffffffff);

public static final int MIN_UCSCHAR = (0);

//
//  We'll assume here that the ISO-10646 / Unicode agreement
//  not to assign code points after U+0010FFFF holds so that
//  we do not have to have separate "UCSCHAR" and "UNICODECHAR"
//  types.
//

public static final int MAX_UCSCHAR = (0x0010FFFF);

// #endif // _WIN32_WINNT >= 0x0600


//
// ANSI (Multi-byte Character) types
//

//
// Neutral ANSI/UNICODE types and macros
//
// #ifdef  UNICODE                     // r_winnt

// #ifndef _TCHAR_DEFINED
// #define _TCHAR_DEFINED
// #endif /* !_TCHAR_DEFINED */
// #define __TEXT(quote) L##quote      // r_winnt

// #else   /* UNICODE */               // r_winnt

// #endif /* UNICODE */                // r_winnt
// #define TEXT(quote) __TEXT(quote)   // r_winnt    

public static final int ALL_PROCESSOR_GROUPS =        0xffff;
// Targeting ..\windows\PROCESSOR_NUMBER.java


// Targeting ..\windows\GROUP_AFFINITY.java


// Targeting ..\windows\HANDLE.java


// #if 0 && (_MSC_VER > 1000)
// #define DECLARE_HANDLE(name) struct name##__; typedef struct name##__ *name
// #else
// #define DECLARE_HANDLE(name) struct name##__{int unused;}; typedef struct name##__ *name
// #endif
// #else
// #endif

// end_ntoshvp

//
// Flag (bit) fields
//

// begin_ntoshvp

// Component Object Model defines, and macros

// #ifndef _HRESULT_DEFINED
// #define _HRESULT_DEFINED
// #ifdef __midl
// #else
// #endif // __midl
// #endif // !_HRESULT_DEFINED

// end_ntoshvp

// #ifdef __cplusplus
//     #define EXTERN_C    extern "C"
// #else
// #endif

// #if defined(_WIN32) || defined(_MPPC_)

// Win32 doesn't support __export

// #ifdef _68K_
// #else
// #endif


// #else

// #define STDMETHODCALLTYPE       __export __stdcall
// #define STDMETHODVCALLTYPE      __export __cdecl

// #define STDAPICALLTYPE          __export __stdcall
// #define STDAPIVCALLTYPE         __export __cdecl

// #endif


// #define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
// #define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

// #define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
// #define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

// #define STDOVERRIDEMETHODIMP        __override STDMETHODIMP
// #define STDOVERRIDEMETHODIMP_(type) __override STDMETHODIMP_(type)

// #define IFACEMETHODIMP          __override STDMETHODIMP
// #define IFACEMETHODIMP_(type)   __override STDMETHODIMP_(type)

// The 'V' versions allow Variable Argument lists.

// #define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
// #define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

// #define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
// #define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

// #define STDOVERRIDEMETHODIMPV        __override STDMETHODIMPV
// #define STDOVERRIDEMETHODIMPV_(type) __override STDMETHODIMPV_(type)

// #define IFACEMETHODIMPV          __override STDMETHODIMPV
// #define IFACEMETHODIMPV_(type)   __override STDMETHODIMPV_(type)      

// #ifndef __COMPARTMENT_ID_DEFINED__
// #define __COMPARTMENT_ID_DEFINED__ 

//
// Compartment identifier
//

/** enum COMPARTMENT_ID */
public static final int
    UNSPECIFIED_COMPARTMENT_ID = 0,
    DEFAULT_COMPARTMENT_ID = 1;

// #endif // __COMPARTMENT_ID_DEFINED__

public static final int APPLICATION_ERROR_MASK =       0x20000000;
public static final int ERROR_SEVERITY_SUCCESS =       0x00000000;
public static final int ERROR_SEVERITY_INFORMATIONAL = 0x40000000;
public static final int ERROR_SEVERITY_WARNING =       0x80000000;
public static final int ERROR_SEVERITY_ERROR =         0xC0000000;
// begin_ntoshvp

//
// _M_IX86 included so that EM CONTEXT structure compiles with
// x86 programs. *** TBD should this be for all architectures?
//

//
// 16 byte aligned type for 128 bit floats
//

//
// For we define a 128 bit structure and use __declspec(align(16)) pragma to
// align to 128 bits.
//

// #if defined(_M_IA64) && !defined(MIDL_PASS)
// Targeting ..\windows\FLOAT128.java




//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

// #define _ULONGLONG_
// #if (!defined (_MAC) && (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64)))

public static final long MAXLONGLONG =                         (0x7fffffffffffffffL);


// #else

// #if defined(_MAC) && defined(_MAC_INT_64)


// #else
// #endif //_MAC and int64

// #endif

// Update Sequence Number
// Targeting ..\windows\LARGE_INTEGER.java


// Targeting ..\windows\ULARGE_INTEGER.java



//
// Reference count.
//
// Targeting ..\windows\LUID.java



// #define _DWORDLONG_


//
// Define operations to logically shift an int64 by 0..31 bits and to multiply
// 32-bits by 32-bits to form a 64-bit product.
//

// #if defined(MIDL_PASS) || defined(RC_INVOKED) || defined(_M_CEE_PURE)
//     || defined(_68K_) || defined(_MPPC_)
//     || defined(_M_IA64) || defined(_M_AMD64) || defined(_M_ARM)

//
// Midl does not understand inline assembler. Therefore, the Rtl functions
// are used for shifts by 0..31 and multiplies of 32-bits times 32-bits to
// form a 64-bit product.
//
//
// IA64 and AMD64 have native 64-bit operations that are just as fast as their
// 32-bit counter parts. Therefore, the int64 data type is used directly to form
// shifts of 0..31 and multiplies of 32-bits times 32-bits to form a 64-bit
// product.
//

public static native long Int32x32To64(int a, int b);
public static native long UInt32x32To64(int a, int b);

public static native long Int64ShllMod32(long a, int b);
public static native long Int64ShraMod32(long a, int b);
public static native long Int64ShrlMod32(long a, int b);


// #elif defined(_M_IX86)

// #else

// #error Must define a target architecture.

// #endif

//
// Define rotate intrinsics.
//

// #ifdef __cplusplus
// #endif

// #if defined(_M_AMD64)


public static native @Cast("unsigned char") byte _rotl8(
    @Cast("unsigned char") byte Value,
    @Cast("unsigned char") byte Shift
    );

public static native @Cast("unsigned short") short _rotl16(
    @Cast("unsigned short") short Value,
    @Cast("unsigned char") byte Shift
    );

public static native @Cast("unsigned char") byte _rotr8(
    @Cast("unsigned char") byte Value,
    @Cast("unsigned char") byte Shift
    );

public static native @Cast("unsigned short") short _rotr16(
    @Cast("unsigned short") short Value,
    @Cast("unsigned char") byte Shift
    );

// #pragma intrinsic(_rotl8)
// #pragma intrinsic(_rotl16)
// #pragma intrinsic(_rotr8)
// #pragma intrinsic(_rotr16)

// #endif /* _M_AMD64 */

// #if _MSC_VER >= 1300


public static native @Cast("unsigned int") int _rotl(
    @Cast("unsigned int") int Value,
    int Shift
    );

public static native @Cast("__int64") long _rotl64(
    @Cast("unsigned") int Value,
    int Shift
    );

public static native @Cast("unsigned int") int _rotr(
    @Cast("unsigned int") int Value,
    int Shift
    );

public static native @Cast("__int64") long _rotr64(
    @Cast("unsigned") int Value,
    int Shift
    );

// #pragma intrinsic(_rotl)
// #pragma intrinsic(_rotl64)
// #pragma intrinsic(_rotr)
// #pragma intrinsic(_rotr64)

// #endif  /* _MSC_VER >= 1300 */

// #ifdef __cplusplus
// #endif

public static final int ANSI_NULL = ((byte)0);     
public static final int UNICODE_NULL = ((char)0); 
public static final int UNICODE_STRING_MAX_BYTES = ((short) 65534); 
public static final int UNICODE_STRING_MAX_CHARS = (32767);
// Targeting ..\windows\LIST_ENTRY.java


// Targeting ..\windows\SINGLE_LIST_ENTRY.java


// Targeting ..\windows\LIST_ENTRY32.java


// Targeting ..\windows\LIST_ENTRY64.java




// #include <guiddef.h>

// #ifndef __OBJECTID_DEFINED
// #define __OBJECTID_DEFINED
// Targeting ..\windows\OBJECTID.java


// #endif // !_OBJECTID_DEFINED

public static final int MINCHAR =     0x80;        
public static final int MAXCHAR =     0x7f;        
public static final int MINSHORT =    0x8000;      
public static final int MAXSHORT =    0x7fff;      
public static final int MINLONG =     0x80000000;  
public static final int MAXLONG =     0x7fffffff;  
public static final int MAXBYTE =     0xff;        
public static final int MAXWORD =     0xffff;      
public static final int MAXDWORD =    0xffffffff;  
// begin_ntoshvp
//
// Calculate the byte offset of a field in a structure of type type.
//

// #define FIELD_OFFSET(type, field)    ((LONG)(LONG_PTR)&(((type *)0)->field))

//
// Calculate the size of a field in a structure of type type, without
// knowing or stating the type of the field.
//
// #define RTL_FIELD_SIZE(type, field) (sizeof(((type *)0)->field))

//
// Calculate the size of a structure of type type up through and
// including a field.
//
// #define RTL_SIZEOF_THROUGH_FIELD(type, field)
//     (FIELD_OFFSET(type, field) + RTL_FIELD_SIZE(type, field))

// end_ntoshvp

//
//  RTL_CONTAINS_FIELD usage:
//
//      if (RTL_CONTAINS_FIELD(pBlock, pBlock->cbSize, dwMumble)) { // safe to use pBlock->dwMumble
//
// #define RTL_CONTAINS_FIELD(Struct, Size, Field)
//     ( (((PCHAR)(&(Struct)->Field)) + sizeof((Struct)->Field)) <= (((PCHAR)(Struct))+(Size)) )

//
// Return the number of elements in a statically sized array.
//   DWORD Buffer[100];
//   RTL_NUMBER_OF(Buffer) == 100
// This is also popularly known as: NUMBER_OF, ARRSIZE, _countof, NELEM, etc.
//
// #define RTL_NUMBER_OF_V1(A) (sizeof(A)/sizeof((A)[0]))

// #if defined(__cplusplus) &&
//     !defined(MIDL_PASS) &&
//     !defined(RC_INVOKED) &&
//     !defined(_PREFAST_) &&
//     (_MSC_FULL_VER >= 13009466) &&
//     !defined(SORTPP_PASS)
//
// RtlpNumberOf is a function that takes a reference to an array of N Ts.
//
// typedef T array_of_T[N];
// typedef array_of_T &reference_to_array_of_T;
//
// RtlpNumberOf returns a pointer to an array of N chars.
// We could return a reference instead of a pointer but older compilers do not accept that.
//
// typedef char array_of_char[N];
// typedef array_of_char *pointer_to_array_of_char;
//
// sizeof(array_of_char) == N
// sizeof(*pointer_to_array_of_char) == N
//
// pointer_to_array_of_char RtlpNumberOf(reference_to_array_of_T);
//
// We never even call RtlpNumberOf, we just take the size of dereferencing its return type.
// We do not even implement RtlpNumberOf, we just decare it.
//
// Attempts to pass pointers instead of arrays to this macro result in compile time errors.
// That is the point.
//

// end_ntndis end_ntminiport

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

// begin_ntndis begin_ntminiport // templates cannot be declared to have 'C' linkage



// end_ntndis end_ntminiport

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// begin_ntndis begin_ntminiport

// #define RTL_NUMBER_OF_V2(A) (sizeof(*RtlpNumberOf(A)))

//
// This does not work with:
//
// void Foo()
// {
//    struct { int x; } y[2];
//    RTL_NUMBER_OF_V2(y); // illegal use of anonymous local type in template instantiation
// }
//
// You must instead do:
//
// struct Foo1 { int x; };
//
// void Foo()
// {
//    Foo1 y[2];
//    RTL_NUMBER_OF_V2(y); // ok
// }
//
// OR
//
// void Foo()
// {
//    struct { int x; } y[2];
//    RTL_NUMBER_OF_V1(y); // ok
// }
//
// OR
//
// void Foo()
// {
//    struct { int x; } y[2];
//    _ARRAYSIZE(y); // ok
// }
//

// #else
// #define RTL_NUMBER_OF_V2(A) RTL_NUMBER_OF_V1(A)
// #endif

// #ifdef ENABLE_RTL_NUMBER_OF_V2
// #define RTL_NUMBER_OF(A) RTL_NUMBER_OF_V2(A)
// #else
// #define RTL_NUMBER_OF(A) RTL_NUMBER_OF_V1(A)
// #endif

//
// ARRAYSIZE is more readable version of RTL_NUMBER_OF_V2, and uses
// it regardless of ENABLE_RTL_NUMBER_OF_V2
//
// _ARRAYSIZE is a version useful for anonymous types
//
// #define ARRAYSIZE(A)    RTL_NUMBER_OF_V2(A)
// #define _ARRAYSIZE(A)   RTL_NUMBER_OF_V1(A)

//
// An expression that yields the type of a field in a struct.
//
// #define RTL_FIELD_TYPE(type, field) (((type*)0)->field)

// RTL_ to avoid collisions in the global namespace.
//
// Given typedef struct _FOO { BYTE Bar[123]; } FOO;
// RTL_NUMBER_OF_FIELD(FOO, Bar) == 123
//
// #define RTL_NUMBER_OF_FIELD(type, field) (RTL_NUMBER_OF(RTL_FIELD_TYPE(type, field)))

//
// eg:
// typedef struct FOO {
//   DWORD Integer;
//   PVOID Pointer;
// } FOO;
//
// RTL_PADDING_BETWEEN_FIELDS(FOO, Integer, Pointer) == 0 for Win32, 4 for Win64
//
// #define RTL_PADDING_BETWEEN_FIELDS(T, F1, F2)
//     ((FIELD_OFFSET(T, F2) > FIELD_OFFSET(T, F1))
//         ? (FIELD_OFFSET(T, F2) - FIELD_OFFSET(T, F1) - RTL_FIELD_SIZE(T, F1))
//         : (FIELD_OFFSET(T, F1) - FIELD_OFFSET(T, F2) - RTL_FIELD_SIZE(T, F2)))

// RTL_ to avoid collisions in the global namespace.
// #if defined(__cplusplus)
// #define RTL_CONST_CAST(type) const_cast<type>
// #else
// #define RTL_CONST_CAST(type) (type)
// #endif


// like sizeof
// usually this would be * CHAR_BIT, but we don't necessarily have #include <limits.h>
// #define RTL_BITS_OF(sizeOfArg) (sizeof(sizeOfArg) * 8)

// #define RTL_BITS_OF_FIELD(type, field) (RTL_BITS_OF(RTL_FIELD_TYPE(type, field)))

// begin_ntoshvp

//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

// #define CONTAINING_RECORD(address, type, field) ((type *)(
//                                                   (PCHAR)(address) -
//                                                   (ULONG_PTR)(&((type *)0)->field)))

// end_ntoshvp
// end_ntminiport end_ntndis

//
// Exception handler routine definition.
//

// #include <excpt.h>
// Targeting ..\windows\EXCEPTION_ROUTINE.java




public static final int VER_SERVER_NT =                       0x80000000;
public static final int VER_WORKSTATION_NT =                  0x40000000;
public static final int VER_SUITE_SMALLBUSINESS =             0x00000001;
public static final int VER_SUITE_ENTERPRISE =                0x00000002;
public static final int VER_SUITE_BACKOFFICE =                0x00000004;
public static final int VER_SUITE_COMMUNICATIONS =            0x00000008;
public static final int VER_SUITE_TERMINAL =                  0x00000010;
public static final int VER_SUITE_SMALLBUSINESS_RESTRICTED =  0x00000020;
public static final int VER_SUITE_EMBEDDEDNT =                0x00000040;
public static final int VER_SUITE_DATACENTER =                0x00000080;
public static final int VER_SUITE_SINGLEUSERTS =              0x00000100;
public static final int VER_SUITE_PERSONAL =                  0x00000200;
public static final int VER_SUITE_BLADE =                     0x00000400;
public static final int VER_SUITE_EMBEDDED_RESTRICTED =       0x00000800;
public static final int VER_SUITE_SECURITY_APPLIANCE =        0x00001000;
public static final int VER_SUITE_STORAGE_SERVER =            0x00002000;
public static final int VER_SUITE_COMPUTE_SERVER =            0x00004000;
public static final int VER_SUITE_WH_SERVER =                 0x00008000;


//
// Product types
// This list grows with each OS release.
//
// There is no ordering of values to ensure callers
// do an equality test i.e. greater-than and less-than
// comparisons are not useful.
//
// NOTE: Values in this list should never be deleted.
//       When a product-type 'X' gets dropped from a
//       OS release onwards, the value of 'X' continues
//       to be used in the mapping table of GetProductInfo.
//

public static final int PRODUCT_UNDEFINED =                           0x00000000;

public static final int PRODUCT_ULTIMATE =                            0x00000001;
public static final int PRODUCT_HOME_BASIC =                          0x00000002;
public static final int PRODUCT_HOME_PREMIUM =                        0x00000003;
public static final int PRODUCT_ENTERPRISE =                          0x00000004;
public static final int PRODUCT_HOME_BASIC_N =                        0x00000005;
public static final int PRODUCT_BUSINESS =                            0x00000006;
public static final int PRODUCT_STANDARD_SERVER =                     0x00000007;
public static final int PRODUCT_DATACENTER_SERVER =                   0x00000008;
public static final int PRODUCT_SMALLBUSINESS_SERVER =                0x00000009;
public static final int PRODUCT_ENTERPRISE_SERVER =                   0x0000000A;
public static final int PRODUCT_STARTER =                             0x0000000B;
public static final int PRODUCT_DATACENTER_SERVER_CORE =              0x0000000C;
public static final int PRODUCT_STANDARD_SERVER_CORE =                0x0000000D;
public static final int PRODUCT_ENTERPRISE_SERVER_CORE =              0x0000000E;
public static final int PRODUCT_ENTERPRISE_SERVER_IA64 =              0x0000000F;
public static final int PRODUCT_BUSINESS_N =                          0x00000010;
public static final int PRODUCT_WEB_SERVER =                          0x00000011;
public static final int PRODUCT_CLUSTER_SERVER =                      0x00000012;
public static final int PRODUCT_HOME_SERVER =                         0x00000013;
public static final int PRODUCT_STORAGE_EXPRESS_SERVER =              0x00000014;
public static final int PRODUCT_STORAGE_STANDARD_SERVER =             0x00000015;
public static final int PRODUCT_STORAGE_WORKGROUP_SERVER =            0x00000016;
public static final int PRODUCT_STORAGE_ENTERPRISE_SERVER =           0x00000017;
public static final int PRODUCT_SERVER_FOR_SMALLBUSINESS =            0x00000018;
public static final int PRODUCT_SMALLBUSINESS_SERVER_PREMIUM =        0x00000019;
public static final int PRODUCT_HOME_PREMIUM_N =                      0x0000001A;
public static final int PRODUCT_ENTERPRISE_N =                        0x0000001B;
public static final int PRODUCT_ULTIMATE_N =                          0x0000001C;
public static final int PRODUCT_WEB_SERVER_CORE =                     0x0000001D;
public static final int PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT =    0x0000001E;
public static final int PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY =      0x0000001F;
public static final int PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING =     0x00000020;
public static final int PRODUCT_SERVER_FOUNDATION =                   0x00000021;
public static final int PRODUCT_HOME_PREMIUM_SERVER =                 0x00000022;
public static final int PRODUCT_SERVER_FOR_SMALLBUSINESS_V =          0x00000023;
public static final int PRODUCT_STANDARD_SERVER_V =                   0x00000024;
public static final int PRODUCT_DATACENTER_SERVER_V =                 0x00000025;
public static final int PRODUCT_ENTERPRISE_SERVER_V =                 0x00000026;
public static final int PRODUCT_DATACENTER_SERVER_CORE_V =            0x00000027;
public static final int PRODUCT_STANDARD_SERVER_CORE_V =              0x00000028;
public static final int PRODUCT_ENTERPRISE_SERVER_CORE_V =            0x00000029;
public static final int PRODUCT_HYPERV =                              0x0000002A;
public static final int PRODUCT_STORAGE_EXPRESS_SERVER_CORE =         0x0000002B;
public static final int PRODUCT_STORAGE_STANDARD_SERVER_CORE =        0x0000002C;
public static final int PRODUCT_STORAGE_WORKGROUP_SERVER_CORE =       0x0000002D;
public static final int PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE =      0x0000002E;
public static final int PRODUCT_STARTER_N =                           0x0000002F;
public static final int PRODUCT_PROFESSIONAL =                        0x00000030;
public static final int PRODUCT_PROFESSIONAL_N =                      0x00000031;
public static final int PRODUCT_SB_SOLUTION_SERVER =                  0x00000032;
public static final int PRODUCT_SERVER_FOR_SB_SOLUTIONS =             0x00000033;
public static final int PRODUCT_STANDARD_SERVER_SOLUTIONS =           0x00000034;
public static final int PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE =      0x00000035;
public static final int PRODUCT_SB_SOLUTION_SERVER_EM =               0x00000036;
public static final int PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM =          0x00000037;
public static final int PRODUCT_SOLUTION_EMBEDDEDSERVER =             0x00000038;
public static final int PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE =        0x00000039;
public static final int PRODUCT_PROFESSIONAL_EMBEDDED =               0x0000003A;
public static final int PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT =       0x0000003B;
public static final int PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL =       0x0000003C;
public static final int PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC =    0x0000003D;
public static final int PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC =    0x0000003E;
public static final int PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE =   0x0000003F;
public static final int PRODUCT_CLUSTER_SERVER_V =                    0x00000040;
public static final int PRODUCT_EMBEDDED =                            0x00000041;
public static final int PRODUCT_STARTER_E =                           0x00000042;
public static final int PRODUCT_HOME_BASIC_E =                        0x00000043;
public static final int PRODUCT_HOME_PREMIUM_E =                      0x00000044;
public static final int PRODUCT_PROFESSIONAL_E =                      0x00000045;
public static final int PRODUCT_ENTERPRISE_E =                        0x00000046;
public static final int PRODUCT_ULTIMATE_E =                          0x00000047;
public static final int PRODUCT_ENTERPRISE_EVALUATION =               0x00000048;
public static final int PRODUCT_MULTIPOINT_STANDARD_SERVER =          0x0000004C;
public static final int PRODUCT_MULTIPOINT_PREMIUM_SERVER =           0x0000004D;
public static final int PRODUCT_STANDARD_EVALUATION_SERVER =          0x0000004F;
public static final int PRODUCT_DATACENTER_EVALUATION_SERVER =        0x00000050;
public static final int PRODUCT_ENTERPRISE_N_EVALUATION =             0x00000054;
public static final int PRODUCT_EMBEDDED_AUTOMOTIVE =                 0x00000055;
public static final int PRODUCT_EMBEDDED_INDUSTRY_A =                 0x00000056;
public static final int PRODUCT_THINPC =                              0x00000057;
public static final int PRODUCT_EMBEDDED_A =                          0x00000058;
public static final int PRODUCT_EMBEDDED_INDUSTRY =                   0x00000059;
public static final int PRODUCT_EMBEDDED_E =                          0x0000005A;
public static final int PRODUCT_EMBEDDED_INDUSTRY_E =                 0x0000005B;
public static final int PRODUCT_EMBEDDED_INDUSTRY_A_E =               0x0000005C;
public static final int PRODUCT_STORAGE_WORKGROUP_EVALUATION_SERVER = 0x0000005F;
public static final int PRODUCT_STORAGE_STANDARD_EVALUATION_SERVER =  0x00000060;
public static final int PRODUCT_CORE_ARM =                            0x00000061;
public static final int PRODUCT_CORE_N =                              0x00000062;
public static final int PRODUCT_CORE_COUNTRYSPECIFIC =                0x00000063;
public static final int PRODUCT_CORE_SINGLELANGUAGE =                 0x00000064;
public static final int PRODUCT_CORE =                                0x00000065;
public static final int PRODUCT_PROFESSIONAL_WMC =                    0x00000067;
public static final int PRODUCT_MOBILE_CORE =                         0x00000068;
public static final int PRODUCT_EMBEDDED_INDUSTRY_EVAL =              0x00000069;
public static final int PRODUCT_EMBEDDED_INDUSTRY_E_EVAL =            0x0000006A;
public static final int PRODUCT_EMBEDDED_EVAL =                       0x0000006B;
public static final int PRODUCT_EMBEDDED_E_EVAL =                     0x0000006C;
public static final int PRODUCT_CORE_SERVER =                         0x0000006D;
public static final int PRODUCT_CLOUD_STORAGE_SERVER =                0x0000006E;
public static final int PRODUCT_CORE_CONNECTED =                      0x0000006F;
public static final int PRODUCT_PROFESSIONAL_STUDENT =                0x00000070;
public static final int PRODUCT_CORE_CONNECTED_N =                    0x00000071;
public static final int PRODUCT_PROFESSIONAL_STUDENT_N =              0x00000072;
public static final int PRODUCT_CORE_CONNECTED_SINGLELANGUAGE =       0x00000073;
public static final int PRODUCT_CORE_CONNECTED_COUNTRYSPECIFIC =      0x00000074;

public static final int PRODUCT_UNLICENSED =                          0xABCDABCD;

// #include <sdkddkver.h>

//
//  Language IDs.
//
//  Note that the named locale APIs (eg GetLocaleInfoEx) are preferred.
//
//  Not all locales have unique Language IDs
//
//  The following two combinations of primary language ID and
//  sublanguage ID have special semantics:
//
//    Primary Language ID   Sublanguage ID      Result
//    -------------------   ---------------     ------------------------
//    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
//    LANG_NEUTRAL          SUBLANG_DEFAULT     User default language
//    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language
//    LANG_INVARIANT        SUBLANG_NEUTRAL     Invariant locale
//
//  It is recommended that applications test for locale names instead of
//  Language IDs / LCIDs.

//
//  Primary language IDs.
//
//  WARNING: These aren't always unique.  Bosnian, Serbian & Croation for example.
//
//  It is recommended that applications test for locale names or actual LCIDs.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//
public static final int LANG_NEUTRAL =                     0x00;
public static final int LANG_INVARIANT =                   0x7f;

public static final int LANG_AFRIKAANS =                   0x36;
public static final int LANG_ALBANIAN =                    0x1c;
public static final int LANG_ALSATIAN =                    0x84;
public static final int LANG_AMHARIC =                     0x5e;
public static final int LANG_ARABIC =                      0x01;
public static final int LANG_ARMENIAN =                    0x2b;
public static final int LANG_ASSAMESE =                    0x4d;
public static final int LANG_AZERI =                       0x2c;   // for Azerbaijani, LANG_AZERBAIJANI is preferred
public static final int LANG_AZERBAIJANI =                 0x2c;
public static final int LANG_BANGLA =                      0x45;
public static final int LANG_BASHKIR =                     0x6d;
public static final int LANG_BASQUE =                      0x2d;
public static final int LANG_BELARUSIAN =                  0x23;
public static final int LANG_BENGALI =                     0x45;   // Some prefer to use LANG_BANGLA
public static final int LANG_BRETON =                      0x7e;
public static final int LANG_BOSNIAN =                     0x1a;   // Use with SUBLANG_BOSNIAN_* Sublanguage IDs
public static final int LANG_BOSNIAN_NEUTRAL =           0x781a;   // Use with the ConvertDefaultLocale function
public static final int LANG_BULGARIAN =                   0x02;
public static final int LANG_CATALAN =                     0x03;
public static final int LANG_CENTRAL_KURDISH =             0x92;
public static final int LANG_CHEROKEE =                    0x5c;
public static final int LANG_CHINESE =                     0x04;   // Use with SUBLANG_CHINESE_* Sublanguage IDs
public static final int LANG_CHINESE_SIMPLIFIED =          0x04;   // Use with the ConvertDefaultLocale function
public static final int LANG_CHINESE_TRADITIONAL =       0x7c04;   // Use with the ConvertDefaultLocale function
public static final int LANG_CORSICAN =                    0x83;
public static final int LANG_CROATIAN =                    0x1a;
public static final int LANG_CZECH =                       0x05;
public static final int LANG_DANISH =                      0x06;
public static final int LANG_DARI =                        0x8c;
public static final int LANG_DIVEHI =                      0x65;
public static final int LANG_DUTCH =                       0x13;
public static final int LANG_ENGLISH =                     0x09;
public static final int LANG_ESTONIAN =                    0x25;
public static final int LANG_FAEROESE =                    0x38;
public static final int LANG_FARSI =                       0x29;   // Deprecated: use LANG_PERSIAN instead
public static final int LANG_FILIPINO =                    0x64;
public static final int LANG_FINNISH =                     0x0b;
public static final int LANG_FRENCH =                      0x0c;
public static final int LANG_FRISIAN =                     0x62;
public static final int LANG_FULAH =                       0x67;
public static final int LANG_GALICIAN =                    0x56;
public static final int LANG_GEORGIAN =                    0x37;
public static final int LANG_GERMAN =                      0x07;
public static final int LANG_GREEK =                       0x08;
public static final int LANG_GREENLANDIC =                 0x6f;
public static final int LANG_GUJARATI =                    0x47;
public static final int LANG_HAUSA =                       0x68;
public static final int LANG_HAWAIIAN =                    0x75;
public static final int LANG_HEBREW =                      0x0d;
public static final int LANG_HINDI =                       0x39;
public static final int LANG_HUNGARIAN =                   0x0e;
public static final int LANG_ICELANDIC =                   0x0f;
public static final int LANG_IGBO =                        0x70;
public static final int LANG_INDONESIAN =                  0x21;
public static final int LANG_INUKTITUT =                   0x5d;
public static final int LANG_IRISH =                       0x3c;   // Use with the SUBLANG_IRISH_IRELAND Sublanguage ID
public static final int LANG_ITALIAN =                     0x10;
public static final int LANG_JAPANESE =                    0x11;
public static final int LANG_KANNADA =                     0x4b;
public static final int LANG_KASHMIRI =                    0x60;
public static final int LANG_KAZAK =                       0x3f;
public static final int LANG_KHMER =                       0x53;
public static final int LANG_KICHE =                       0x86;
public static final int LANG_KINYARWANDA =                 0x87;
public static final int LANG_KONKANI =                     0x57;
public static final int LANG_KOREAN =                      0x12;
public static final int LANG_KYRGYZ =                      0x40;
public static final int LANG_LAO =                         0x54;
public static final int LANG_LATVIAN =                     0x26;
public static final int LANG_LITHUANIAN =                  0x27;
public static final int LANG_LOWER_SORBIAN =               0x2e;
public static final int LANG_LUXEMBOURGISH =               0x6e;
public static final int LANG_MACEDONIAN =                  0x2f;   // the Former Yugoslav Republic of Macedonia
public static final int LANG_MALAY =                       0x3e;
public static final int LANG_MALAYALAM =                   0x4c;
public static final int LANG_MALTESE =                     0x3a;
public static final int LANG_MANIPURI =                    0x58;
public static final int LANG_MAORI =                       0x81;
public static final int LANG_MAPUDUNGUN =                  0x7a;
public static final int LANG_MARATHI =                     0x4e;
public static final int LANG_MOHAWK =                      0x7c;
public static final int LANG_MONGOLIAN =                   0x50;
public static final int LANG_NEPALI =                      0x61;
public static final int LANG_NORWEGIAN =                   0x14;
public static final int LANG_OCCITAN =                     0x82;
public static final int LANG_ODIA =                        0x48;
public static final int LANG_ORIYA =                       0x48;   // Deprecated: use LANG_ODIA, instead.
public static final int LANG_PASHTO =                      0x63;
public static final int LANG_PERSIAN =                     0x29;
public static final int LANG_POLISH =                      0x15;
public static final int LANG_PORTUGUESE =                  0x16;
public static final int LANG_PULAR =                       0x67;   // Deprecated: use LANG_FULAH instead
public static final int LANG_PUNJABI =                     0x46;
public static final int LANG_QUECHUA =                     0x6b;
public static final int LANG_ROMANIAN =                    0x18;
public static final int LANG_ROMANSH =                     0x17;
public static final int LANG_RUSSIAN =                     0x19;
public static final int LANG_SAKHA =                       0x85;
public static final int LANG_SAMI =                        0x3b;
public static final int LANG_SANSKRIT =                    0x4f;
public static final int LANG_SCOTTISH_GAELIC =             0x91;
public static final int LANG_SERBIAN =                     0x1a;   // Use with the SUBLANG_SERBIAN_* Sublanguage IDs
public static final int LANG_SERBIAN_NEUTRAL =           0x7c1a;   // Use with the ConvertDefaultLocale function
public static final int LANG_SINDHI =                      0x59;
public static final int LANG_SINHALESE =                   0x5b;
public static final int LANG_SLOVAK =                      0x1b;
public static final int LANG_SLOVENIAN =                   0x24;
public static final int LANG_SOTHO =                       0x6c;
public static final int LANG_SPANISH =                     0x0a;
public static final int LANG_SWAHILI =                     0x41;
public static final int LANG_SWEDISH =                     0x1d;
public static final int LANG_SYRIAC =                      0x5a;
public static final int LANG_TAJIK =                       0x28;
public static final int LANG_TAMAZIGHT =                   0x5f;
public static final int LANG_TAMIL =                       0x49;
public static final int LANG_TATAR =                       0x44;
public static final int LANG_TELUGU =                      0x4a;
public static final int LANG_THAI =                        0x1e;
public static final int LANG_TIBETAN =                     0x51;
public static final int LANG_TIGRIGNA =                    0x73;
public static final int LANG_TIGRINYA =                    0x73;   // Preferred spelling in locale
public static final int LANG_TSWANA =                      0x32;
public static final int LANG_TURKISH =                     0x1f;
public static final int LANG_TURKMEN =                     0x42;
public static final int LANG_UIGHUR =                      0x80;
public static final int LANG_UKRAINIAN =                   0x22;
public static final int LANG_UPPER_SORBIAN =               0x2e;
public static final int LANG_URDU =                        0x20;
public static final int LANG_UZBEK =                       0x43;
public static final int LANG_VALENCIAN =                   0x03;
public static final int LANG_VIETNAMESE =                  0x2a;
public static final int LANG_WELSH =                       0x52;
public static final int LANG_WOLOF =                       0x88;
public static final int LANG_XHOSA =                       0x34;
public static final int LANG_YAKUT =                       0x85;   // Deprecated: use LANG_SAKHA,instead
public static final int LANG_YI =                          0x78;
public static final int LANG_YORUBA =                      0x6a;
public static final int LANG_ZULU =                        0x35;

//
//  Sublanguage IDs.
//
//  The name immediately following SUBLANG_ dictates which primary
//  language ID that sublanguage ID can be combined with to form a
//  valid language ID.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//

public static final int SUBLANG_NEUTRAL =                             0x00;    // language neutral
public static final int SUBLANG_DEFAULT =                             0x01;    // user default
public static final int SUBLANG_SYS_DEFAULT =                         0x02;    // system default
public static final int SUBLANG_CUSTOM_DEFAULT =                      0x03;    // default custom language/locale
public static final int SUBLANG_CUSTOM_UNSPECIFIED =                  0x04;    // custom language/locale
public static final int SUBLANG_UI_CUSTOM_DEFAULT =                   0x05;    // Default custom MUI language/locale


public static final int SUBLANG_AFRIKAANS_SOUTH_AFRICA =              0x01;    // Afrikaans (South Africa) 0x0436 af-ZA
public static final int SUBLANG_ALBANIAN_ALBANIA =                    0x01;    // Albanian (Albania) 0x041c sq-AL
public static final int SUBLANG_ALSATIAN_FRANCE =                     0x01;    // Alsatian (France) 0x0484
public static final int SUBLANG_AMHARIC_ETHIOPIA =                    0x01;    // Amharic (Ethiopia) 0x045e
public static final int SUBLANG_ARABIC_SAUDI_ARABIA =                 0x01;    // Arabic (Saudi Arabia)
public static final int SUBLANG_ARABIC_IRAQ =                         0x02;    // Arabic (Iraq)
public static final int SUBLANG_ARABIC_EGYPT =                        0x03;    // Arabic (Egypt)
public static final int SUBLANG_ARABIC_LIBYA =                        0x04;    // Arabic (Libya)
public static final int SUBLANG_ARABIC_ALGERIA =                      0x05;    // Arabic (Algeria)
public static final int SUBLANG_ARABIC_MOROCCO =                      0x06;    // Arabic (Morocco)
public static final int SUBLANG_ARABIC_TUNISIA =                      0x07;    // Arabic (Tunisia)
public static final int SUBLANG_ARABIC_OMAN =                         0x08;    // Arabic (Oman)
public static final int SUBLANG_ARABIC_YEMEN =                        0x09;    // Arabic (Yemen)
public static final int SUBLANG_ARABIC_SYRIA =                        0x0a;    // Arabic (Syria)
public static final int SUBLANG_ARABIC_JORDAN =                       0x0b;    // Arabic (Jordan)
public static final int SUBLANG_ARABIC_LEBANON =                      0x0c;    // Arabic (Lebanon)
public static final int SUBLANG_ARABIC_KUWAIT =                       0x0d;    // Arabic (Kuwait)
public static final int SUBLANG_ARABIC_UAE =                          0x0e;    // Arabic (U.A.E)
public static final int SUBLANG_ARABIC_BAHRAIN =                      0x0f;    // Arabic (Bahrain)
public static final int SUBLANG_ARABIC_QATAR =                        0x10;    // Arabic (Qatar)
public static final int SUBLANG_ARMENIAN_ARMENIA =                    0x01;    // Armenian (Armenia) 0x042b hy-AM
public static final int SUBLANG_ASSAMESE_INDIA =                      0x01;    // Assamese (India) 0x044d
public static final int SUBLANG_AZERI_LATIN =                         0x01;    // Azeri (Latin) - for Azerbaijani, SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN preferred
public static final int SUBLANG_AZERI_CYRILLIC =                      0x02;    // Azeri (Cyrillic) - for Azerbaijani, SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC preferred
public static final int SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN =        0x01;    // Azerbaijani (Azerbaijan, Latin)
public static final int SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC =     0x02;    // Azerbaijani (Azerbaijan, Cyrillic)
public static final int SUBLANG_BANGLA_INDIA =                        0x01;    // Bangla (India)
public static final int SUBLANG_BANGLA_BANGLADESH =                   0x02;    // Bangla (Bangladesh)
public static final int SUBLANG_BASHKIR_RUSSIA =                      0x01;    // Bashkir (Russia) 0x046d ba-RU
public static final int SUBLANG_BASQUE_BASQUE =                       0x01;    // Basque (Basque) 0x042d eu-ES
public static final int SUBLANG_BELARUSIAN_BELARUS =                  0x01;    // Belarusian (Belarus) 0x0423 be-BY
public static final int SUBLANG_BENGALI_INDIA =                       0x01;    // Bengali (India) - Note some prefer SUBLANG_BANGLA_INDIA
public static final int SUBLANG_BENGALI_BANGLADESH =                  0x02;    // Bengali (Bangladesh) - Note some prefer SUBLANG_BANGLA_BANGLADESH
public static final int SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN =    0x05;    // Bosnian (Bosnia and Herzegovina - Latin) 0x141a bs-BA-Latn
public static final int SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC = 0x08;    // Bosnian (Bosnia and Herzegovina - Cyrillic) 0x201a bs-BA-Cyrl
public static final int SUBLANG_BRETON_FRANCE =                       0x01;    // Breton (France) 0x047e
public static final int SUBLANG_BULGARIAN_BULGARIA =                  0x01;    // Bulgarian (Bulgaria) 0x0402
public static final int SUBLANG_CATALAN_CATALAN =                     0x01;    // Catalan (Catalan) 0x0403
public static final int SUBLANG_CENTRAL_KURDISH_IRAQ =                0x01;    // Central Kurdish (Iraq) 0x0492 ku-Arab-IQ
public static final int SUBLANG_CHEROKEE_CHEROKEE =                   0x01;    // Cherokee (Cherokee) 0x045c chr-Cher-US
public static final int SUBLANG_CHINESE_TRADITIONAL =                 0x01;    // Chinese (Taiwan) 0x0404 zh-TW
public static final int SUBLANG_CHINESE_SIMPLIFIED =                  0x02;    // Chinese (PR China) 0x0804 zh-CN
public static final int SUBLANG_CHINESE_HONGKONG =                    0x03;    // Chinese (Hong Kong S.A.R., P.R.C.) 0x0c04 zh-HK
public static final int SUBLANG_CHINESE_SINGAPORE =                   0x04;    // Chinese (Singapore) 0x1004 zh-SG
public static final int SUBLANG_CHINESE_MACAU =                       0x05;    // Chinese (Macau S.A.R.) 0x1404 zh-MO
public static final int SUBLANG_CORSICAN_FRANCE =                     0x01;    // Corsican (France) 0x0483
public static final int SUBLANG_CZECH_CZECH_REPUBLIC =                0x01;    // Czech (Czech Republic) 0x0405
public static final int SUBLANG_CROATIAN_CROATIA =                    0x01;    // Croatian (Croatia)
public static final int SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN =   0x04;    // Croatian (Bosnia and Herzegovina - Latin) 0x101a hr-BA
public static final int SUBLANG_DANISH_DENMARK =                      0x01;    // Danish (Denmark) 0x0406
public static final int SUBLANG_DARI_AFGHANISTAN =                    0x01;    // Dari (Afghanistan)
public static final int SUBLANG_DIVEHI_MALDIVES =                     0x01;    // Divehi (Maldives) 0x0465 div-MV
public static final int SUBLANG_DUTCH =                               0x01;    // Dutch
public static final int SUBLANG_DUTCH_BELGIAN =                       0x02;    // Dutch (Belgian)
public static final int SUBLANG_ENGLISH_US =                          0x01;    // English (USA)
public static final int SUBLANG_ENGLISH_UK =                          0x02;    // English (UK)
public static final int SUBLANG_ENGLISH_AUS =                         0x03;    // English (Australian)
public static final int SUBLANG_ENGLISH_CAN =                         0x04;    // English (Canadian)
public static final int SUBLANG_ENGLISH_NZ =                          0x05;    // English (New Zealand)
public static final int SUBLANG_ENGLISH_EIRE =                        0x06;    // English (Irish)
public static final int SUBLANG_ENGLISH_SOUTH_AFRICA =                0x07;    // English (South Africa)
public static final int SUBLANG_ENGLISH_JAMAICA =                     0x08;    // English (Jamaica)
public static final int SUBLANG_ENGLISH_CARIBBEAN =                   0x09;    // English (Caribbean)
public static final int SUBLANG_ENGLISH_BELIZE =                      0x0a;    // English (Belize)
public static final int SUBLANG_ENGLISH_TRINIDAD =                    0x0b;    // English (Trinidad)
public static final int SUBLANG_ENGLISH_ZIMBABWE =                    0x0c;    // English (Zimbabwe)
public static final int SUBLANG_ENGLISH_PHILIPPINES =                 0x0d;    // English (Philippines)
public static final int SUBLANG_ENGLISH_INDIA =                       0x10;    // English (India)
public static final int SUBLANG_ENGLISH_MALAYSIA =                    0x11;    // English (Malaysia)
public static final int SUBLANG_ENGLISH_SINGAPORE =                   0x12;    // English (Singapore)
public static final int SUBLANG_ESTONIAN_ESTONIA =                    0x01;    // Estonian (Estonia) 0x0425 et-EE
public static final int SUBLANG_FAEROESE_FAROE_ISLANDS =              0x01;    // Faroese (Faroe Islands) 0x0438 fo-FO
public static final int SUBLANG_FILIPINO_PHILIPPINES =                0x01;    // Filipino (Philippines) 0x0464 fil-PH
public static final int SUBLANG_FINNISH_FINLAND =                     0x01;    // Finnish (Finland) 0x040b
public static final int SUBLANG_FRENCH =                              0x01;    // French
public static final int SUBLANG_FRENCH_BELGIAN =                      0x02;    // French (Belgian)
public static final int SUBLANG_FRENCH_CANADIAN =                     0x03;    // French (Canadian)
public static final int SUBLANG_FRENCH_SWISS =                        0x04;    // French (Swiss)
public static final int SUBLANG_FRENCH_LUXEMBOURG =                   0x05;    // French (Luxembourg)
public static final int SUBLANG_FRENCH_MONACO =                       0x06;    // French (Monaco)
public static final int SUBLANG_FRISIAN_NETHERLANDS =                 0x01;    // Frisian (Netherlands) 0x0462 fy-NL
public static final int SUBLANG_FULAH_SENEGAL =                       0x02;    // Fulah (Senegal) 0x0867 ff-SN
public static final int SUBLANG_GALICIAN_GALICIAN =                   0x01;    // Galician (Galician) 0x0456 gl-ES
public static final int SUBLANG_GEORGIAN_GEORGIA =                    0x01;    // Georgian (Georgia) 0x0437 ka-GE
public static final int SUBLANG_GERMAN =                              0x01;    // German
public static final int SUBLANG_GERMAN_SWISS =                        0x02;    // German (Swiss)
public static final int SUBLANG_GERMAN_AUSTRIAN =                     0x03;    // German (Austrian)
public static final int SUBLANG_GERMAN_LUXEMBOURG =                   0x04;    // German (Luxembourg)
public static final int SUBLANG_GERMAN_LIECHTENSTEIN =                0x05;    // German (Liechtenstein)
public static final int SUBLANG_GREEK_GREECE =                        0x01;    // Greek (Greece)
public static final int SUBLANG_GREENLANDIC_GREENLAND =               0x01;    // Greenlandic (Greenland) 0x046f kl-GL
public static final int SUBLANG_GUJARATI_INDIA =                      0x01;    // Gujarati (India (Gujarati Script)) 0x0447 gu-IN
public static final int SUBLANG_HAUSA_NIGERIA_LATIN =                 0x01;    // Hausa (Latin, Nigeria) 0x0468 ha-NG-Latn
public static final int SUBLANG_HAWAIIAN_US =                         0x01;    // Hawiian (US) 0x0475 haw-US
public static final int SUBLANG_HEBREW_ISRAEL =                       0x01;    // Hebrew (Israel) 0x040d
public static final int SUBLANG_HINDI_INDIA =                         0x01;    // Hindi (India) 0x0439 hi-IN
public static final int SUBLANG_HUNGARIAN_HUNGARY =                   0x01;    // Hungarian (Hungary) 0x040e
public static final int SUBLANG_ICELANDIC_ICELAND =                   0x01;    // Icelandic (Iceland) 0x040f
public static final int SUBLANG_IGBO_NIGERIA =                        0x01;    // Igbo (Nigeria) 0x0470 ig-NG
public static final int SUBLANG_INDONESIAN_INDONESIA =                0x01;    // Indonesian (Indonesia) 0x0421 id-ID
public static final int SUBLANG_INUKTITUT_CANADA =                    0x01;    // Inuktitut (Syllabics) (Canada) 0x045d iu-CA-Cans
public static final int SUBLANG_INUKTITUT_CANADA_LATIN =              0x02;    // Inuktitut (Canada - Latin)
public static final int SUBLANG_IRISH_IRELAND =                       0x02;    // Irish (Ireland)
public static final int SUBLANG_ITALIAN =                             0x01;    // Italian
public static final int SUBLANG_ITALIAN_SWISS =                       0x02;    // Italian (Swiss)
public static final int SUBLANG_JAPANESE_JAPAN =                      0x01;    // Japanese (Japan) 0x0411
public static final int SUBLANG_KANNADA_INDIA =                       0x01;    // Kannada (India (Kannada Script)) 0x044b kn-IN
public static final int SUBLANG_KASHMIRI_SASIA =                      0x02;    // Kashmiri (South Asia)
public static final int SUBLANG_KASHMIRI_INDIA =                      0x02;    // For app compatibility only
public static final int SUBLANG_KAZAK_KAZAKHSTAN =                    0x01;    // Kazakh (Kazakhstan) 0x043f kk-KZ
public static final int SUBLANG_KHMER_CAMBODIA =                      0x01;    // Khmer (Cambodia) 0x0453 kh-KH
public static final int SUBLANG_KICHE_GUATEMALA =                     0x01;    // K'iche (Guatemala)
public static final int SUBLANG_KINYARWANDA_RWANDA =                  0x01;    // Kinyarwanda (Rwanda) 0x0487 rw-RW
public static final int SUBLANG_KONKANI_INDIA =                       0x01;    // Konkani (India) 0x0457 kok-IN
public static final int SUBLANG_KOREAN =                              0x01;    // Korean (Extended Wansung)
public static final int SUBLANG_KYRGYZ_KYRGYZSTAN =                   0x01;    // Kyrgyz (Kyrgyzstan) 0x0440 ky-KG
public static final int SUBLANG_LAO_LAO =                             0x01;    // Lao (Lao PDR) 0x0454 lo-LA
public static final int SUBLANG_LATVIAN_LATVIA =                      0x01;    // Latvian (Latvia) 0x0426 lv-LV
public static final int SUBLANG_LITHUANIAN =                          0x01;    // Lithuanian
public static final int SUBLANG_LOWER_SORBIAN_GERMANY =               0x02;    // Lower Sorbian (Germany) 0x082e wee-DE
public static final int SUBLANG_LUXEMBOURGISH_LUXEMBOURG =            0x01;    // Luxembourgish (Luxembourg) 0x046e lb-LU
public static final int SUBLANG_MACEDONIAN_MACEDONIA =                0x01;    // Macedonian (Macedonia (FYROM)) 0x042f mk-MK
public static final int SUBLANG_MALAY_MALAYSIA =                      0x01;    // Malay (Malaysia)
public static final int SUBLANG_MALAY_BRUNEI_DARUSSALAM =             0x02;    // Malay (Brunei Darussalam)
public static final int SUBLANG_MALAYALAM_INDIA =                     0x01;    // Malayalam (India (Malayalam Script) ) 0x044c ml-IN
public static final int SUBLANG_MALTESE_MALTA =                       0x01;    // Maltese (Malta) 0x043a mt-MT
public static final int SUBLANG_MAORI_NEW_ZEALAND =                   0x01;    // Maori (New Zealand) 0x0481 mi-NZ
public static final int SUBLANG_MAPUDUNGUN_CHILE =                    0x01;    // Mapudungun (Chile) 0x047a arn-CL
public static final int SUBLANG_MARATHI_INDIA =                       0x01;    // Marathi (India) 0x044e mr-IN
public static final int SUBLANG_MOHAWK_MOHAWK =                       0x01;    // Mohawk (Mohawk) 0x047c moh-CA
public static final int SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA =         0x01;    // Mongolian (Cyrillic, Mongolia)
public static final int SUBLANG_MONGOLIAN_PRC =                       0x02;    // Mongolian (PRC)
public static final int SUBLANG_NEPALI_INDIA =                        0x02;    // Nepali (India)
public static final int SUBLANG_NEPALI_NEPAL =                        0x01;    // Nepali (Nepal) 0x0461 ne-NP
public static final int SUBLANG_NORWEGIAN_BOKMAL =                    0x01;    // Norwegian (Bokmal)
public static final int SUBLANG_NORWEGIAN_NYNORSK =                   0x02;    // Norwegian (Nynorsk)
public static final int SUBLANG_OCCITAN_FRANCE =                      0x01;    // Occitan (France) 0x0482 oc-FR
public static final int SUBLANG_ODIA_INDIA =                          0x01;    // Odia (India (Odia Script)) 0x0448 or-IN
public static final int SUBLANG_ORIYA_INDIA =                         0x01;    // Deprecated: use SUBLANG_ODIA_INDIA instead
public static final int SUBLANG_PASHTO_AFGHANISTAN =                  0x01;    // Pashto (Afghanistan)
public static final int SUBLANG_PERSIAN_IRAN =                        0x01;    // Persian (Iran) 0x0429 fa-IR
public static final int SUBLANG_POLISH_POLAND =                       0x01;    // Polish (Poland) 0x0415
public static final int SUBLANG_PORTUGUESE =                          0x02;    // Portuguese
public static final int SUBLANG_PORTUGUESE_BRAZILIAN =                0x01;    // Portuguese (Brazil)
public static final int SUBLANG_PULAR_SENEGAL =                       0x02;    // Deprecated: Use SUBLANG_FULAH_SENEGAL instead
public static final int SUBLANG_PUNJABI_INDIA =                       0x01;    // Punjabi (India (Gurmukhi Script)) 0x0446 pa-IN
public static final int SUBLANG_PUNJABI_PAKISTAN =                    0x02;    // Punjabi (Pakistan (Arabic Script)) 0x0846 pa-Arab-PK
public static final int SUBLANG_QUECHUA_BOLIVIA =                     0x01;    // Quechua (Bolivia)
public static final int SUBLANG_QUECHUA_ECUADOR =                     0x02;    // Quechua (Ecuador)
public static final int SUBLANG_QUECHUA_PERU =                        0x03;    // Quechua (Peru)
public static final int SUBLANG_ROMANIAN_ROMANIA =                    0x01;    // Romanian (Romania) 0x0418
public static final int SUBLANG_ROMANSH_SWITZERLAND =                 0x01;    // Romansh (Switzerland) 0x0417 rm-CH
public static final int SUBLANG_RUSSIAN_RUSSIA =                      0x01;    // Russian (Russia) 0x0419
public static final int SUBLANG_SAKHA_RUSSIA =                        0x01;    // Sakha (Russia) 0x0485 sah-RU
public static final int SUBLANG_SAMI_NORTHERN_NORWAY =                0x01;    // Northern Sami (Norway)
public static final int SUBLANG_SAMI_NORTHERN_SWEDEN =                0x02;    // Northern Sami (Sweden)
public static final int SUBLANG_SAMI_NORTHERN_FINLAND =               0x03;    // Northern Sami (Finland)
public static final int SUBLANG_SAMI_LULE_NORWAY =                    0x04;    // Lule Sami (Norway)
public static final int SUBLANG_SAMI_LULE_SWEDEN =                    0x05;    // Lule Sami (Sweden)
public static final int SUBLANG_SAMI_SOUTHERN_NORWAY =                0x06;    // Southern Sami (Norway)
public static final int SUBLANG_SAMI_SOUTHERN_SWEDEN =                0x07;    // Southern Sami (Sweden)
public static final int SUBLANG_SAMI_SKOLT_FINLAND =                  0x08;    // Skolt Sami (Finland)
public static final int SUBLANG_SAMI_INARI_FINLAND =                  0x09;    // Inari Sami (Finland)
public static final int SUBLANG_SANSKRIT_INDIA =                      0x01;    // Sanskrit (India) 0x044f sa-IN
public static final int SUBLANG_SCOTTISH_GAELIC =                     0x01;    // Scottish Gaelic (United Kingdom) 0x0491 gd-GB
public static final int SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN =    0x06;    // Serbian (Bosnia and Herzegovina - Latin)
public static final int SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC = 0x07;    // Serbian (Bosnia and Herzegovina - Cyrillic)
public static final int SUBLANG_SERBIAN_MONTENEGRO_LATIN =            0x0b;    // Serbian (Montenegro - Latn)
public static final int SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC =         0x0c;    // Serbian (Montenegro - Cyrillic)
public static final int SUBLANG_SERBIAN_SERBIA_LATIN =                0x09;    // Serbian (Serbia - Latin)
public static final int SUBLANG_SERBIAN_SERBIA_CYRILLIC =             0x0a;    // Serbian (Serbia - Cyrillic)
public static final int SUBLANG_SERBIAN_CROATIA =                     0x01;    // Croatian (Croatia) 0x041a hr-HR
public static final int SUBLANG_SERBIAN_LATIN =                       0x02;    // Serbian (Latin)
public static final int SUBLANG_SERBIAN_CYRILLIC =                    0x03;    // Serbian (Cyrillic)
public static final int SUBLANG_SINDHI_INDIA =                        0x01;    // Sindhi (India) reserved 0x0459
public static final int SUBLANG_SINDHI_PAKISTAN =                     0x02;    // Sindhi (Pakistan) 0x0859 sd-Arab-PK
public static final int SUBLANG_SINDHI_AFGHANISTAN =                  0x02;    // For app compatibility only
public static final int SUBLANG_SINHALESE_SRI_LANKA =                 0x01;    // Sinhalese (Sri Lanka)
public static final int SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA =         0x01;    // Northern Sotho (South Africa)
public static final int SUBLANG_SLOVAK_SLOVAKIA =                     0x01;    // Slovak (Slovakia) 0x041b sk-SK
public static final int SUBLANG_SLOVENIAN_SLOVENIA =                  0x01;    // Slovenian (Slovenia) 0x0424 sl-SI
public static final int SUBLANG_SPANISH =                             0x01;    // Spanish (Castilian)
public static final int SUBLANG_SPANISH_MEXICAN =                     0x02;    // Spanish (Mexico)
public static final int SUBLANG_SPANISH_MODERN =                      0x03;    // Spanish (Modern)
public static final int SUBLANG_SPANISH_GUATEMALA =                   0x04;    // Spanish (Guatemala)
public static final int SUBLANG_SPANISH_COSTA_RICA =                  0x05;    // Spanish (Costa Rica)
public static final int SUBLANG_SPANISH_PANAMA =                      0x06;    // Spanish (Panama)
public static final int SUBLANG_SPANISH_DOMINICAN_REPUBLIC =          0x07;    // Spanish (Dominican Republic)
public static final int SUBLANG_SPANISH_VENEZUELA =                   0x08;    // Spanish (Venezuela)
public static final int SUBLANG_SPANISH_COLOMBIA =                    0x09;    // Spanish (Colombia)
public static final int SUBLANG_SPANISH_PERU =                        0x0a;    // Spanish (Peru)
public static final int SUBLANG_SPANISH_ARGENTINA =                   0x0b;    // Spanish (Argentina)
public static final int SUBLANG_SPANISH_ECUADOR =                     0x0c;    // Spanish (Ecuador)
public static final int SUBLANG_SPANISH_CHILE =                       0x0d;    // Spanish (Chile)
public static final int SUBLANG_SPANISH_URUGUAY =                     0x0e;    // Spanish (Uruguay)
public static final int SUBLANG_SPANISH_PARAGUAY =                    0x0f;    // Spanish (Paraguay)
public static final int SUBLANG_SPANISH_BOLIVIA =                     0x10;    // Spanish (Bolivia)
public static final int SUBLANG_SPANISH_EL_SALVADOR =                 0x11;    // Spanish (El Salvador)
public static final int SUBLANG_SPANISH_HONDURAS =                    0x12;    // Spanish (Honduras)
public static final int SUBLANG_SPANISH_NICARAGUA =                   0x13;    // Spanish (Nicaragua)
public static final int SUBLANG_SPANISH_PUERTO_RICO =                 0x14;    // Spanish (Puerto Rico)
public static final int SUBLANG_SPANISH_US =                          0x15;    // Spanish (United States)
public static final int SUBLANG_SWAHILI_KENYA =                       0x01;    // Swahili (Kenya) 0x0441 sw-KE
public static final int SUBLANG_SWEDISH =                             0x01;    // Swedish
public static final int SUBLANG_SWEDISH_FINLAND =                     0x02;    // Swedish (Finland)
public static final int SUBLANG_SYRIAC_SYRIA =                        0x01;    // Syriac (Syria) 0x045a syr-SY
public static final int SUBLANG_TAJIK_TAJIKISTAN =                    0x01;    // Tajik (Tajikistan) 0x0428 tg-TJ-Cyrl
public static final int SUBLANG_TAMAZIGHT_ALGERIA_LATIN =             0x02;    // Tamazight (Latin, Algeria) 0x085f tzm-Latn-DZ
public static final int SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH =          0x04;    // Tamazight (Tifinagh) 0x105f tzm-Tfng-MA
public static final int SUBLANG_TAMIL_INDIA =                         0x01;    // Tamil (India)
public static final int SUBLANG_TAMIL_SRI_LANKA =                     0x02;    // Tamil (Sri Lanka) 0x0849 ta-LK
public static final int SUBLANG_TATAR_RUSSIA =                        0x01;    // Tatar (Russia) 0x0444 tt-RU
public static final int SUBLANG_TELUGU_INDIA =                        0x01;    // Telugu (India (Telugu Script)) 0x044a te-IN
public static final int SUBLANG_THAI_THAILAND =                       0x01;    // Thai (Thailand) 0x041e th-TH
public static final int SUBLANG_TIBETAN_PRC =                         0x01;    // Tibetan (PRC)
public static final int SUBLANG_TIGRIGNA_ERITREA =                    0x02;    // Tigrigna (Eritrea)
public static final int SUBLANG_TIGRINYA_ERITREA =                    0x02;    // Tigrinya (Eritrea) 0x0873 ti-ER (preferred spelling)
public static final int SUBLANG_TIGRINYA_ETHIOPIA =                   0x01;    // Tigrinya (Ethiopia) 0x0473 ti-ET
public static final int SUBLANG_TSWANA_BOTSWANA =                     0x02;    // Setswana / Tswana (Botswana) 0x0832 tn-BW
public static final int SUBLANG_TSWANA_SOUTH_AFRICA =                 0x01;    // Setswana / Tswana (South Africa) 0x0432 tn-ZA
public static final int SUBLANG_TURKISH_TURKEY =                      0x01;    // Turkish (Turkey) 0x041f tr-TR
public static final int SUBLANG_TURKMEN_TURKMENISTAN =                0x01;    // Turkmen (Turkmenistan) 0x0442 tk-TM
public static final int SUBLANG_UIGHUR_PRC =                          0x01;    // Uighur (PRC) 0x0480 ug-CN
public static final int SUBLANG_UKRAINIAN_UKRAINE =                   0x01;    // Ukrainian (Ukraine) 0x0422 uk-UA
public static final int SUBLANG_UPPER_SORBIAN_GERMANY =               0x01;    // Upper Sorbian (Germany) 0x042e wen-DE
public static final int SUBLANG_URDU_PAKISTAN =                       0x01;    // Urdu (Pakistan)
public static final int SUBLANG_URDU_INDIA =                          0x02;    // Urdu (India)
public static final int SUBLANG_UZBEK_LATIN =                         0x01;    // Uzbek (Latin)
public static final int SUBLANG_UZBEK_CYRILLIC =                      0x02;    // Uzbek (Cyrillic)
public static final int SUBLANG_VALENCIAN_VALENCIA =                  0x02;    // Valencian (Valencia) 0x0803 ca-ES-Valencia
public static final int SUBLANG_VIETNAMESE_VIETNAM =                  0x01;    // Vietnamese (Vietnam) 0x042a vi-VN
public static final int SUBLANG_WELSH_UNITED_KINGDOM =                0x01;    // Welsh (United Kingdom) 0x0452 cy-GB
public static final int SUBLANG_WOLOF_SENEGAL =                       0x01;    // Wolof (Senegal)
public static final int SUBLANG_XHOSA_SOUTH_AFRICA =                  0x01;    // isiXhosa / Xhosa (South Africa) 0x0434 xh-ZA
public static final int SUBLANG_YAKUT_RUSSIA =                        0x01;    // Deprecated: use SUBLANG_SAKHA_RUSSIA instead
public static final int SUBLANG_YI_PRC =                              0x01;    // Yi (PRC)) 0x0478
public static final int SUBLANG_YORUBA_NIGERIA =                      0x01;    // Yoruba (Nigeria) 046a yo-NG
public static final int SUBLANG_ZULU_SOUTH_AFRICA =                   0x01;    // isiZulu / Zulu (South Africa) 0x0435 zu-ZA




//
//  Sorting IDs.
//
//  Note that the named locale APIs (eg CompareStringExEx) are recommended.
//

public static final int SORT_DEFAULT =                     0x0;     // sorting default

public static final int SORT_INVARIANT_MATH =              0x1;     // Invariant (Mathematical Symbols)

public static final int SORT_JAPANESE_XJIS =               0x0;     // Japanese XJIS order
public static final int SORT_JAPANESE_UNICODE =            0x1;     // Japanese Unicode order (no longer supported)
public static final int SORT_JAPANESE_RADICALSTROKE =      0x4;     // Japanese radical/stroke order

public static final int SORT_CHINESE_BIG5 =                0x0;     // Chinese BIG5 order
public static final int SORT_CHINESE_PRCP =                0x0;     // PRC Chinese Phonetic order
public static final int SORT_CHINESE_UNICODE =             0x1;     // Chinese Unicode order (no longer supported)
public static final int SORT_CHINESE_PRC =                 0x2;     // PRC Chinese Stroke Count order
public static final int SORT_CHINESE_BOPOMOFO =            0x3;     // Traditional Chinese Bopomofo order
public static final int SORT_CHINESE_RADICALSTROKE =       0x4;     // Traditional Chinese radical/stroke order.

public static final int SORT_KOREAN_KSC =                  0x0;     // Korean KSC order
public static final int SORT_KOREAN_UNICODE =              0x1;     // Korean Unicode order (no longer supported)

public static final int SORT_GERMAN_PHONE_BOOK =           0x1;     // German Phone Book order

public static final int SORT_HUNGARIAN_DEFAULT =           0x0;     // Hungarian Default order
public static final int SORT_HUNGARIAN_TECHNICAL =         0x1;     // Hungarian Technical order

public static final int SORT_GEORGIAN_TRADITIONAL =        0x0;     // Georgian Traditional order
public static final int SORT_GEORGIAN_MODERN =             0x1;     // Georgian Modern order

// end_r_winnt

//
//  A language ID is a 16 bit value which is the combination of a
//  primary language ID and a secondary language ID.  The bits are
//  allocated as follows:
//
//       +-----------------------+-------------------------+
//       |     Sublanguage ID    |   Primary Language ID   |
//       +-----------------------+-------------------------+
//        15                   10 9                       0   bit
//
//  WARNING:  This pattern isn't always follows, Serbina, Bosnian & Croation
//            for example.
//
//  It is recommended that applications test for locale names or actual LCIDs.
//
//  Language ID creation/extraction macros:
//
//    MAKELANGID    - construct language id from a primary language id and
//                    a sublanguage id.
//    PRIMARYLANGID - extract primary language id from a language id.
//    SUBLANGID     - extract sublanguage id from a language id.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//
//  Language IDs do not exist for all locales
//
public static native int MAKELANGID(int p, int s);
public static native int PRIMARYLANGID(int lgid);
public static native int SUBLANGID(int lgid);


//
//  A locale ID is a 32 bit value which is the combination of a
//  language ID, a sort ID, and a reserved area.  The bits are
//  allocated as follows:
//
//       +-------------+---------+-------------------------+
//       |   Reserved  | Sort ID |      Language ID        |
//       +-------------+---------+-------------------------+
//        31         20 19     16 15                      0   bit
//
//  WARNING: This pattern isn't always followed (es-ES_tradnl vs es-ES for example)
//
//  It is recommended that applications test for locale names or actual LCIDs.
//
//  Locale ID creation/extraction macros:
//
//    MAKELCID            - construct the locale id from a language id and a sort id.
//    MAKESORTLCID        - construct the locale id from a language id, sort id, and sort version.
//    LANGIDFROMLCID      - extract the language id from a locale id.
//    SORTIDFROMLCID      - extract the sort id from a locale id.
//    SORTVERSIONFROMLCID - extract the sort version from a locale id.
//
//  Note that the LANG, SUBLANG construction is not always consistent.
//  The named locale APIs (eg GetLocaleInfoEx) are recommended.
//
//  LCIDs do not exist for all locales.
//
public static final int NLS_VALID_LOCALE_MASK =  0x000fffff;

public static native int MAKELCID(int lgid, int srtid);
public static native int MAKESORTLCID(int lgid, int srtid, int ver);
public static native int LANGIDFROMLCID(int lcid);
public static native int SORTIDFROMLCID(int lcid);
public static native int SORTVERSIONFROMLCID(int lcid);

// 8 characters for language
// 8 characters for region
// 64 characters for suffix (script)
// 2 characters for '-' separators
// 2 characters for prefix like "i-" or "x-"
// 1 null termination
public static final int LOCALE_NAME_MAX_LENGTH =   85;

//
//  Default System and User IDs for language and locale.
//  Locale names such as LOCALE_NAME_SYSTEM_DEFAULT, LOCALE_NAME_USER_DEFAULT,
//  and LOCALE_NAME_INVARIANT are preferred.
//

public static native @MemberGetter int LANG_SYSTEM_DEFAULT();
public static final int LANG_SYSTEM_DEFAULT = LANG_SYSTEM_DEFAULT();
public static native @MemberGetter int LANG_USER_DEFAULT();
public static final int LANG_USER_DEFAULT = LANG_USER_DEFAULT();

public static native @MemberGetter int LOCALE_SYSTEM_DEFAULT();
public static final int LOCALE_SYSTEM_DEFAULT = LOCALE_SYSTEM_DEFAULT();
public static native @MemberGetter int LOCALE_USER_DEFAULT();
public static final int LOCALE_USER_DEFAULT = LOCALE_USER_DEFAULT();

//
//  Other special IDs for language and locale.
//
public static native @MemberGetter int LOCALE_CUSTOM_DEFAULT();
public static final int LOCALE_CUSTOM_DEFAULT = LOCALE_CUSTOM_DEFAULT();

public static native @MemberGetter int LOCALE_CUSTOM_UNSPECIFIED();
public static final int LOCALE_CUSTOM_UNSPECIFIED = LOCALE_CUSTOM_UNSPECIFIED();

public static native @MemberGetter int LOCALE_CUSTOM_UI_DEFAULT();
public static final int LOCALE_CUSTOM_UI_DEFAULT = LOCALE_CUSTOM_UI_DEFAULT();

public static native @MemberGetter int LOCALE_NEUTRAL();
public static final int LOCALE_NEUTRAL = LOCALE_NEUTRAL();

public static native @MemberGetter int LOCALE_INVARIANT();
public static final int LOCALE_INVARIANT = LOCALE_INVARIANT();

//
// Transient keyboard Locale IDs (LCIDs)
// Should only be used for keyboard layout identification 
//
public static final int LOCALE_TRANSIENT_KEYBOARD1 =  0x2000;
public static final int LOCALE_TRANSIENT_KEYBOARD2 =  0x2400;
public static final int LOCALE_TRANSIENT_KEYBOARD3 =  0x2800;
public static final int LOCALE_TRANSIENT_KEYBOARD4 =  0x2c00;

//
// Locale with an unassigned LCID
// These locales cannot be queried by LCID
// Currently same as LOCALE_CUSTOM_UNSPECIFIED
// 
public static native @MemberGetter int LOCALE_UNASSIGNED_LCID();
public static final int LOCALE_UNASSIGNED_LCID = LOCALE_UNASSIGNED_LCID();

// begin_ntminiport begin_ntndis begin_ntminitape

//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

// begin_ntoshvp

// #if ! defined(lint)
// #define UNREFERENCED_PARAMETER(P)          (P)
// #define DBG_UNREFERENCED_PARAMETER(P)      (P)
// #define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

// #else // lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this varible.  Error 527 has to do with unreachable code.
// -restore restores checking to the -save state

// #define UNREFERENCED_PARAMETER(P)
//     /*lint -save -e527 -e530 */
//     {
//         (P) = (P);
//     } 
    /*lint -restore */
// #define DBG_UNREFERENCED_PARAMETER(P)
//     /*lint -save -e527 -e530 */
//     {
//         (P) = (P);
//     } 
    /*lint -restore */
// #define DBG_UNREFERENCED_LOCAL_VARIABLE(V)
//     /*lint -save -e527 -e530 */
//     {
//         (V) = (V);
//     } 
    /*lint -restore */

// #endif // lint

// end_ntoshvp

//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//

// #if (_MSC_VER > 1200)
// #define DEFAULT_UNREACHABLE default: __assume(0)
// #else

//
// Older compilers do not support __assume(), and there is no other free
// method of eliminating the warning.
//

// #define DEFAULT_UNREACHABLE
// Targeting ..\windows\_ENUM_FLAG_INTEGER_FOR_SIZE.java



    // used as an approximation of std::underlying_type<T>

// #define DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE)
// extern "C++" {
// inline ENUMTYPE operator | (ENUMTYPE a, ENUMTYPE b) { return ENUMTYPE(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); }
// inline ENUMTYPE &operator |= (ENUMTYPE &a, ENUMTYPE b) { return (ENUMTYPE &)(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); }
// inline ENUMTYPE operator & (ENUMTYPE a, ENUMTYPE b) { return ENUMTYPE(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); }
// inline ENUMTYPE &operator &= (ENUMTYPE &a, ENUMTYPE b) { return (ENUMTYPE &)(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); }
// inline ENUMTYPE operator ~ (ENUMTYPE a) { return ENUMTYPE(~((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a)); }
// inline ENUMTYPE operator ^ (ENUMTYPE a, ENUMTYPE b) { return ENUMTYPE(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); }
// inline ENUMTYPE &operator ^= (ENUMTYPE &a, ENUMTYPE b) { return (ENUMTYPE &)(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); }
// }
// #else
// #endif

// Compile-time macros for initializing flag values in const data.
// 
// When using DEFINE_ENUM_FLAG_OPERATORS for enum values you should use the macros below
// when you need to initialize global const data.  Without these macros the inline operators 
// from DEFINE_ENUM_FLAG_OPERATORS force a runtime initialization rather than a
// compile time initialization.  This applies even if you have declared the data as const.
// #define COMPILETIME_OR_2FLAGS(a,b)          ((UINT)(a)|(UINT)(b))
// #define COMPILETIME_OR_3FLAGS(a,b,c)        ((UINT)(a)|(UINT)(b)|(UINT)(c))
// #define COMPILETIME_OR_4FLAGS(a,b,c,d)      ((UINT)(a)|(UINT)(b)|(UINT)(c)|(UINT)(d))
// #define COMPILETIME_OR_5FLAGS(a,b,c,d,e)    ((UINT)(a)|(UINT)(b)|(UINT)(c)|(UINT)(d)|(UINT)(e))


// #ifndef UMDF_USING_NTSTATUS 
// #ifndef WIN32_NO_STATUS 
/*lint -save -e767 */  
public static final long STATUS_WAIT_0 =                           ((int)0x00000000L); 
public static final long STATUS_ABANDONED_WAIT_0 =          ((int)0x00000080L);    
public static final long STATUS_USER_APC =                  ((int)0x000000C0L);    
public static final long STATUS_TIMEOUT =                   ((int)0x00000102L);    
public static final long STATUS_PENDING =                   ((int)0x00000103L);    
public static final long DBG_EXCEPTION_HANDLED =            ((int)0x00010001L);    
public static final long DBG_CONTINUE =                     ((int)0x00010002L);    
public static final long STATUS_SEGMENT_NOTIFICATION =      ((int)0x40000005L);    
public static final long STATUS_FATAL_APP_EXIT =            ((int)0x40000015L);    
public static final long DBG_TERMINATE_THREAD =             ((int)0x40010003L);    
public static final long DBG_TERMINATE_PROCESS =            ((int)0x40010004L);    
public static final long DBG_CONTROL_C =                    ((int)0x40010005L);    
public static final long DBG_PRINTEXCEPTION_C =             ((int)0x40010006L);    
public static final long DBG_RIPEXCEPTION =                 ((int)0x40010007L);    
public static final long DBG_CONTROL_BREAK =                ((int)0x40010008L);    
public static final long DBG_COMMAND_EXCEPTION =            ((int)0x40010009L);    
public static final long STATUS_GUARD_PAGE_VIOLATION =      ((int)0x80000001L);    
public static final long STATUS_DATATYPE_MISALIGNMENT =     ((int)0x80000002L);    
public static final long STATUS_BREAKPOINT =                ((int)0x80000003L);    
public static final long STATUS_SINGLE_STEP =               ((int)0x80000004L);    
public static final long STATUS_LONGJUMP =                  ((int)0x80000026L);    
public static final long STATUS_UNWIND_CONSOLIDATE =        ((int)0x80000029L);    
public static final long DBG_EXCEPTION_NOT_HANDLED =        ((int)0x80010001L);    
public static final long STATUS_ACCESS_VIOLATION =          ((int)0xC0000005L);    
public static final long STATUS_IN_PAGE_ERROR =             ((int)0xC0000006L);    
public static final long STATUS_INVALID_HANDLE =            ((int)0xC0000008L);    
public static final long STATUS_INVALID_PARAMETER =         ((int)0xC000000DL);    
public static final long STATUS_NO_MEMORY =                 ((int)0xC0000017L);    
public static final long STATUS_ILLEGAL_INSTRUCTION =       ((int)0xC000001DL);    
public static final long STATUS_NONCONTINUABLE_EXCEPTION =  ((int)0xC0000025L);    
public static final long STATUS_INVALID_DISPOSITION =       ((int)0xC0000026L);    
public static final long STATUS_ARRAY_BOUNDS_EXCEEDED =     ((int)0xC000008CL);    
public static final long STATUS_FLOAT_DENORMAL_OPERAND =    ((int)0xC000008DL);    
public static final long STATUS_FLOAT_DIVIDE_BY_ZERO =      ((int)0xC000008EL);    
public static final long STATUS_FLOAT_INEXACT_RESULT =      ((int)0xC000008FL);    
public static final long STATUS_FLOAT_INVALID_OPERATION =   ((int)0xC0000090L);    
public static final long STATUS_FLOAT_OVERFLOW =            ((int)0xC0000091L);    
public static final long STATUS_FLOAT_STACK_CHECK =         ((int)0xC0000092L);    
public static final long STATUS_FLOAT_UNDERFLOW =           ((int)0xC0000093L);    
public static final long STATUS_INTEGER_DIVIDE_BY_ZERO =    ((int)0xC0000094L);    
public static final long STATUS_INTEGER_OVERFLOW =          ((int)0xC0000095L);    
public static final long STATUS_PRIVILEGED_INSTRUCTION =    ((int)0xC0000096L);    
public static final long STATUS_STACK_OVERFLOW =            ((int)0xC00000FDL);    
public static final long STATUS_DLL_NOT_FOUND =             ((int)0xC0000135L);    
public static final long STATUS_ORDINAL_NOT_FOUND =         ((int)0xC0000138L);    
public static final long STATUS_ENTRYPOINT_NOT_FOUND =      ((int)0xC0000139L);    
public static final long STATUS_CONTROL_C_EXIT =            ((int)0xC000013AL);    
public static final long STATUS_DLL_INIT_FAILED =           ((int)0xC0000142L);    
public static final long STATUS_FLOAT_MULTIPLE_FAULTS =     ((int)0xC00002B4L);    
public static final long STATUS_FLOAT_MULTIPLE_TRAPS =      ((int)0xC00002B5L);    
public static final long STATUS_REG_NAT_CONSUMPTION =       ((int)0xC00002C9L);    
public static final long STATUS_HEAP_CORRUPTION =           ((int)0xC0000374L);    
public static final long STATUS_STACK_BUFFER_OVERRUN =      ((int)0xC0000409L);    
public static final long STATUS_INVALID_CRUNTIME_PARAMETER = ((int)0xC0000417L);    
public static final long STATUS_ASSERTION_FAILURE =         ((int)0xC0000420L);    
// #if defined(STATUS_SUCCESS) || (_WIN32_WINNT > 0x0500) || (_WIN32_FUSION >= 0x0100) 
public static final long STATUS_SXS_EARLY_DEACTIVATION =    ((int)0xC015000FL);    
public static final long STATUS_SXS_INVALID_DEACTIVATION =  ((int)0xC0150010L);    
// #endif 
/*lint -restore */  
// #endif 
// #endif /* UMDF_USING_NTSTATUS */

public static final int MAXIMUM_WAIT_OBJECTS = 64;     // Maximum number of wait objects

public static final int MAXIMUM_SUSPEND_COUNT = MAXCHAR; // Maximum times thread can be suspended
// Targeting ..\windows\M128A.java


// Targeting ..\windows\XSAVE_FORMAT.java


// Targeting ..\windows\XSAVE_AREA_HEADER.java


// Targeting ..\windows\XSAVE_AREA.java


// Targeting ..\windows\XSTATE_CONTEXT.java


// Targeting ..\windows\SCOPE_TABLE_AMD64.java



// begin_ntoshvp

// #ifdef _AMD64_


// #if defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

//
// Define bit test intrinsics.
//

// #ifdef __cplusplus
// #endif



public static native @Cast("BOOLEAN") boolean _bittest(
    @Cast("const LONG*") IntPointer Base,
    @Cast("LONG") int Offset
    );
public static native @Cast("BOOLEAN") boolean _bittest(
    @Cast("const LONG*") IntBuffer Base,
    @Cast("LONG") int Offset
    );
public static native @Cast("BOOLEAN") boolean _bittest(
    @Cast("const LONG*") int[] Base,
    @Cast("LONG") int Offset
    );

public static native @Cast("BOOLEAN") boolean _bittestandcomplement(
    @Cast("LONG*") IntPointer Base,
    @Cast("LONG") int Offset
    );
public static native @Cast("BOOLEAN") boolean _bittestandcomplement(
    @Cast("LONG*") IntBuffer Base,
    @Cast("LONG") int Offset
    );
public static native @Cast("BOOLEAN") boolean _bittestandcomplement(
    @Cast("LONG*") int[] Base,
    @Cast("LONG") int Offset
    );

public static native @Cast("BOOLEAN") boolean _bittestandset(
    @Cast("LONG*") IntPointer Base,
    @Cast("LONG") int Offset
    );
public static native @Cast("BOOLEAN") boolean _bittestandset(
    @Cast("LONG*") IntBuffer Base,
    @Cast("LONG") int Offset
    );
public static native @Cast("BOOLEAN") boolean _bittestandset(
    @Cast("LONG*") int[] Base,
    @Cast("LONG") int Offset
    );

public static native @Cast("BOOLEAN") boolean _bittestandreset(
    @Cast("LONG*") IntPointer Base,
    @Cast("LONG") int Offset
    );
public static native @Cast("BOOLEAN") boolean _bittestandreset(
    @Cast("LONG*") IntBuffer Base,
    @Cast("LONG") int Offset
    );
public static native @Cast("BOOLEAN") boolean _bittestandreset(
    @Cast("LONG*") int[] Base,
    @Cast("LONG") int Offset
    );

public static native @Cast("BOOLEAN") boolean _interlockedbittestandset(
    @Cast("LONG*") IntPointer Base,
    @Cast("LONG") int Offset
    );
public static native @Cast("BOOLEAN") boolean _interlockedbittestandset(
    @Cast("LONG*") IntBuffer Base,
    @Cast("LONG") int Offset
    );
public static native @Cast("BOOLEAN") boolean _interlockedbittestandset(
    @Cast("LONG*") int[] Base,
    @Cast("LONG") int Offset
    );

public static native @Cast("BOOLEAN") boolean _interlockedbittestandreset(
    @Cast("LONG*") IntPointer Base,
    @Cast("LONG") int Offset
    );
public static native @Cast("BOOLEAN") boolean _interlockedbittestandreset(
    @Cast("LONG*") IntBuffer Base,
    @Cast("LONG") int Offset
    );
public static native @Cast("BOOLEAN") boolean _interlockedbittestandreset(
    @Cast("LONG*") int[] Base,
    @Cast("LONG") int Offset
    );

public static native @Cast("BOOLEAN") boolean _bittest64(
    @Cast("const LONG64*") LongPointer Base,
    @Cast("LONG64") long Offset
    );
public static native @Cast("BOOLEAN") boolean _bittest64(
    @Cast("const LONG64*") LongBuffer Base,
    @Cast("LONG64") long Offset
    );
public static native @Cast("BOOLEAN") boolean _bittest64(
    @Cast("const LONG64*") long[] Base,
    @Cast("LONG64") long Offset
    );

public static native @Cast("BOOLEAN") boolean _bittestandcomplement64(
    @Cast("LONG64*") LongPointer Base,
    @Cast("LONG64") long Offset
    );
public static native @Cast("BOOLEAN") boolean _bittestandcomplement64(
    @Cast("LONG64*") LongBuffer Base,
    @Cast("LONG64") long Offset
    );
public static native @Cast("BOOLEAN") boolean _bittestandcomplement64(
    @Cast("LONG64*") long[] Base,
    @Cast("LONG64") long Offset
    );

public static native @Cast("BOOLEAN") boolean _bittestandset64(
    @Cast("LONG64*") LongPointer Base,
    @Cast("LONG64") long Offset
    );
public static native @Cast("BOOLEAN") boolean _bittestandset64(
    @Cast("LONG64*") LongBuffer Base,
    @Cast("LONG64") long Offset
    );
public static native @Cast("BOOLEAN") boolean _bittestandset64(
    @Cast("LONG64*") long[] Base,
    @Cast("LONG64") long Offset
    );

public static native @Cast("BOOLEAN") boolean _bittestandreset64(
    @Cast("LONG64*") LongPointer Base,
    @Cast("LONG64") long Offset
    );
public static native @Cast("BOOLEAN") boolean _bittestandreset64(
    @Cast("LONG64*") LongBuffer Base,
    @Cast("LONG64") long Offset
    );
public static native @Cast("BOOLEAN") boolean _bittestandreset64(
    @Cast("LONG64*") long[] Base,
    @Cast("LONG64") long Offset
    );

public static native @Cast("BOOLEAN") boolean _interlockedbittestandset64(
    @Cast("LONG64*") LongPointer Base,
    @Cast("LONG64") long Offset
    );
public static native @Cast("BOOLEAN") boolean _interlockedbittestandset64(
    @Cast("LONG64*") LongBuffer Base,
    @Cast("LONG64") long Offset
    );
public static native @Cast("BOOLEAN") boolean _interlockedbittestandset64(
    @Cast("LONG64*") long[] Base,
    @Cast("LONG64") long Offset
    );

public static native @Cast("BOOLEAN") boolean _interlockedbittestandreset64(
    @Cast("LONG64*") LongPointer Base,
    @Cast("LONG64") long Offset
    );
public static native @Cast("BOOLEAN") boolean _interlockedbittestandreset64(
    @Cast("LONG64*") LongBuffer Base,
    @Cast("LONG64") long Offset
    );
public static native @Cast("BOOLEAN") boolean _interlockedbittestandreset64(
    @Cast("LONG64*") long[] Base,
    @Cast("LONG64") long Offset
    );

// #pragma intrinsic(_bittest)
// #pragma intrinsic(_bittestandcomplement)
// #pragma intrinsic(_bittestandset)
// #pragma intrinsic(_bittestandreset)
// #pragma intrinsic(_interlockedbittestandset)
// #pragma intrinsic(_interlockedbittestandreset)

// #pragma intrinsic(_bittest64)
// #pragma intrinsic(_bittestandcomplement64)
// #pragma intrinsic(_bittestandset64)
// #pragma intrinsic(_bittestandreset64)
// #pragma intrinsic(_interlockedbittestandset64)
// #pragma intrinsic(_interlockedbittestandreset64)

//
// Define bit scan intrinsics.
//


public static native @Cast("BOOLEAN") boolean _BitScanForward(
    @Cast("DWORD*") IntPointer Index,
    @Cast("DWORD") int Mask
    );
public static native @Cast("BOOLEAN") boolean _BitScanForward(
    @Cast("DWORD*") IntBuffer Index,
    @Cast("DWORD") int Mask
    );
public static native @Cast("BOOLEAN") boolean _BitScanForward(
    @Cast("DWORD*") int[] Index,
    @Cast("DWORD") int Mask
    );

public static native @Cast("BOOLEAN") boolean _BitScanReverse(
    @Cast("DWORD*") IntPointer Index,
    @Cast("DWORD") int Mask
    );
public static native @Cast("BOOLEAN") boolean _BitScanReverse(
    @Cast("DWORD*") IntBuffer Index,
    @Cast("DWORD") int Mask
    );
public static native @Cast("BOOLEAN") boolean _BitScanReverse(
    @Cast("DWORD*") int[] Index,
    @Cast("DWORD") int Mask
    );

public static native @Cast("BOOLEAN") boolean _BitScanForward64(
    @Cast("DWORD*") IntPointer Index,
    @Cast("DWORD64") long Mask
    );
public static native @Cast("BOOLEAN") boolean _BitScanForward64(
    @Cast("DWORD*") IntBuffer Index,
    @Cast("DWORD64") long Mask
    );
public static native @Cast("BOOLEAN") boolean _BitScanForward64(
    @Cast("DWORD*") int[] Index,
    @Cast("DWORD64") long Mask
    );

public static native @Cast("BOOLEAN") boolean _BitScanReverse64(
    @Cast("DWORD*") IntPointer Index,
    @Cast("DWORD64") long Mask
    );
public static native @Cast("BOOLEAN") boolean _BitScanReverse64(
    @Cast("DWORD*") IntBuffer Index,
    @Cast("DWORD64") long Mask
    );
public static native @Cast("BOOLEAN") boolean _BitScanReverse64(
    @Cast("DWORD*") int[] Index,
    @Cast("DWORD64") long Mask
    );

// #pragma intrinsic(_BitScanForward)
// #pragma intrinsic(_BitScanReverse)
// #pragma intrinsic(_BitScanForward64)
// #pragma intrinsic(_BitScanReverse64)

//
// Interlocked intrinsic functions.
//



// #define InterlockedAndAffinity InterlockedAnd64
// #define InterlockedOrAffinity InterlockedOr64
// #define InterlockedExchangeAcquire64 InterlockedExchange64
// #define InterlockedExchangeNoFence64 InterlockedExchange64
// #define InterlockedCompareExchangeAcquire64 InterlockedCompareExchange64
// #define InterlockedCompareExchangeRelease64 InterlockedCompareExchange64
// #define InterlockedCompareExchangeNoFence64 InterlockedCompareExchange64


// #define InterlockedExchangeAddSizeT(a, b) InterlockedExchangeAdd64((LONG64 *)a, b)
// #define InterlockedExchangeAddSizeTAcquire(a, b) InterlockedExchangeAdd64((LONG64 *)a, b)
// #define InterlockedExchangeAddSizeTNoFence(a, b) InterlockedExchangeAdd64((LONG64 *)a, b)
// #define InterlockedIncrementSizeT(a) InterlockedIncrement64((LONG64 *)a)
// #define InterlockedIncrementSizeTNoFence(a) InterlockedIncrement64((LONG64 *)a)
// #define InterlockedDecrementSizeT(a) InterlockedDecrement64((LONG64 *)a)
// #define InterlockedDecrementSizeTNoFence(a) InterlockedDecrement64((LONG64 *)a)

public static native @Cast("SHORT") short InterlockedIncrement16(
    @Cast("SHORT*") ShortPointer Addend
    );
public static native @Cast("SHORT") short InterlockedIncrement16(
    @Cast("SHORT*") ShortBuffer Addend
    );
public static native @Cast("SHORT") short InterlockedIncrement16(
    @Cast("SHORT*") short[] Addend
    );

public static native @Cast("SHORT") short InterlockedDecrement16(
    @Cast("SHORT*") ShortPointer Addend
    );
public static native @Cast("SHORT") short InterlockedDecrement16(
    @Cast("SHORT*") ShortBuffer Addend
    );
public static native @Cast("SHORT") short InterlockedDecrement16(
    @Cast("SHORT*") short[] Addend
    );

public static native @Cast("SHORT") short InterlockedCompareExchange16(
    @Cast("SHORT*") ShortPointer Destination,
    @Cast("SHORT") short ExChange,
    @Cast("SHORT") short Comperand
    );
public static native @Cast("SHORT") short InterlockedCompareExchange16(
    @Cast("SHORT*") ShortBuffer Destination,
    @Cast("SHORT") short ExChange,
    @Cast("SHORT") short Comperand
    );
public static native @Cast("SHORT") short InterlockedCompareExchange16(
    @Cast("SHORT*") short[] Destination,
    @Cast("SHORT") short ExChange,
    @Cast("SHORT") short Comperand
    );

public static native @Cast("LONG") int InterlockedAnd(
    @Cast("LONG*") IntPointer Destination,
    @Cast("LONG") int Value
    );
public static native @Cast("LONG") int InterlockedAnd(
    @Cast("LONG*") IntBuffer Destination,
    @Cast("LONG") int Value
    );
public static native @Cast("LONG") int InterlockedAnd(
    @Cast("LONG*") int[] Destination,
    @Cast("LONG") int Value
    );

public static native @Cast("LONG") int InterlockedOr(
    @Cast("LONG*") IntPointer Destination,
    @Cast("LONG") int Value
    );
public static native @Cast("LONG") int InterlockedOr(
    @Cast("LONG*") IntBuffer Destination,
    @Cast("LONG") int Value
    );
public static native @Cast("LONG") int InterlockedOr(
    @Cast("LONG*") int[] Destination,
    @Cast("LONG") int Value
    );

public static native @Cast("LONG") int InterlockedXor(
    @Cast("LONG*") IntPointer Destination,
    @Cast("LONG") int Value
    );
public static native @Cast("LONG") int InterlockedXor(
    @Cast("LONG*") IntBuffer Destination,
    @Cast("LONG") int Value
    );
public static native @Cast("LONG") int InterlockedXor(
    @Cast("LONG*") int[] Destination,
    @Cast("LONG") int Value
    );

public static native @Cast("LONG64") long InterlockedAnd64(
    @Cast("LONG64*") LongPointer Destination,
    @Cast("LONG64") long Value
    );
public static native @Cast("LONG64") long InterlockedAnd64(
    @Cast("LONG64*") LongBuffer Destination,
    @Cast("LONG64") long Value
    );
public static native @Cast("LONG64") long InterlockedAnd64(
    @Cast("LONG64*") long[] Destination,
    @Cast("LONG64") long Value
    );

public static native @Cast("LONG64") long InterlockedXor64(
    @Cast("LONG64*") LongPointer Destination,
    @Cast("LONG64") long Value
    );
public static native @Cast("LONG64") long InterlockedXor64(
    @Cast("LONG64*") LongBuffer Destination,
    @Cast("LONG64") long Value
    );
public static native @Cast("LONG64") long InterlockedXor64(
    @Cast("LONG64*") long[] Destination,
    @Cast("LONG64") long Value
    );

public static native @Cast("LONG") int InterlockedIncrement(
    @Cast("LONG*") IntPointer Addend
    );
public static native @Cast("LONG") int InterlockedIncrement(
    @Cast("LONG*") IntBuffer Addend
    );
public static native @Cast("LONG") int InterlockedIncrement(
    @Cast("LONG*") int[] Addend
    );

public static native @Cast("LONG") int InterlockedDecrement(
    @Cast("LONG*") IntPointer Addend
    );
public static native @Cast("LONG") int InterlockedDecrement(
    @Cast("LONG*") IntBuffer Addend
    );
public static native @Cast("LONG") int InterlockedDecrement(
    @Cast("LONG*") int[] Addend
    );

public static native @Cast("LONG") int InterlockedExchange(
    @Cast("LONG*") IntPointer Target,
    @Cast("LONG") int Value
    );
public static native @Cast("LONG") int InterlockedExchange(
    @Cast("LONG*") IntBuffer Target,
    @Cast("LONG") int Value
    );
public static native @Cast("LONG") int InterlockedExchange(
    @Cast("LONG*") int[] Target,
    @Cast("LONG") int Value
    );

public static native @Cast("LONG") int InterlockedExchangeAdd(
    @Cast("LONG*") IntPointer Addend,
    @Cast("LONG") int Value
    );
public static native @Cast("LONG") int InterlockedExchangeAdd(
    @Cast("LONG*") IntBuffer Addend,
    @Cast("LONG") int Value
    );
public static native @Cast("LONG") int InterlockedExchangeAdd(
    @Cast("LONG*") int[] Addend,
    @Cast("LONG") int Value
    );

// #if !defined(_X86AMD64_)

public static native @Cast("LONG") int InterlockedAdd(
    @Cast("LONG*") IntPointer Addend,
    @Cast("LONG") int Value
    );
public static native @Cast("LONG") int InterlockedAdd(
    @Cast("LONG*") IntBuffer Addend,
    @Cast("LONG") int Value
    );
public static native @Cast("LONG") int InterlockedAdd(
    @Cast("LONG*") int[] Addend,
    @Cast("LONG") int Value
    );

// #endif

public static native @Cast("LONG") int InterlockedCompareExchange(
    @Cast("LONG*") IntPointer Destination,
    @Cast("LONG") int ExChange,
    @Cast("LONG") int Comperand
    );
public static native @Cast("LONG") int InterlockedCompareExchange(
    @Cast("LONG*") IntBuffer Destination,
    @Cast("LONG") int ExChange,
    @Cast("LONG") int Comperand
    );
public static native @Cast("LONG") int InterlockedCompareExchange(
    @Cast("LONG*") int[] Destination,
    @Cast("LONG") int ExChange,
    @Cast("LONG") int Comperand
    );

public static native @Cast("LONG64") long InterlockedIncrement64(
    @Cast("LONG64*") LongPointer Addend
    );
public static native @Cast("LONG64") long InterlockedIncrement64(
    @Cast("LONG64*") LongBuffer Addend
    );
public static native @Cast("LONG64") long InterlockedIncrement64(
    @Cast("LONG64*") long[] Addend
    );

public static native @Cast("LONG64") long InterlockedDecrement64(
    @Cast("LONG64*") LongPointer Addend
    );
public static native @Cast("LONG64") long InterlockedDecrement64(
    @Cast("LONG64*") LongBuffer Addend
    );
public static native @Cast("LONG64") long InterlockedDecrement64(
    @Cast("LONG64*") long[] Addend
    );

public static native @Cast("LONG64") long InterlockedExchange64(
    @Cast("LONG64*") LongPointer Target,
    @Cast("LONG64") long Value
    );
public static native @Cast("LONG64") long InterlockedExchange64(
    @Cast("LONG64*") LongBuffer Target,
    @Cast("LONG64") long Value
    );
public static native @Cast("LONG64") long InterlockedExchange64(
    @Cast("LONG64*") long[] Target,
    @Cast("LONG64") long Value
    );

public static native @Cast("LONG64") long InterlockedExchangeAdd64(
    @Cast("LONG64*") LongPointer Addend,
    @Cast("LONG64") long Value
    );
public static native @Cast("LONG64") long InterlockedExchangeAdd64(
    @Cast("LONG64*") LongBuffer Addend,
    @Cast("LONG64") long Value
    );
public static native @Cast("LONG64") long InterlockedExchangeAdd64(
    @Cast("LONG64*") long[] Addend,
    @Cast("LONG64") long Value
    );

// #if !defined(_X86AMD64_)

public static native @Cast("LONG64") long InterlockedAdd64(
    @Cast("LONG64*") LongPointer Addend,
    @Cast("LONG64") long Value
    );
public static native @Cast("LONG64") long InterlockedAdd64(
    @Cast("LONG64*") LongBuffer Addend,
    @Cast("LONG64") long Value
    );
public static native @Cast("LONG64") long InterlockedAdd64(
    @Cast("LONG64*") long[] Addend,
    @Cast("LONG64") long Value
    );

// #endif

public static native @Cast("LONG64") long InterlockedCompareExchange64(
    @Cast("LONG64*") LongPointer Destination,
    @Cast("LONG64") long ExChange,
    @Cast("LONG64") long Comperand
    );
public static native @Cast("LONG64") long InterlockedCompareExchange64(
    @Cast("LONG64*") LongBuffer Destination,
    @Cast("LONG64") long ExChange,
    @Cast("LONG64") long Comperand
    );
public static native @Cast("LONG64") long InterlockedCompareExchange64(
    @Cast("LONG64*") long[] Destination,
    @Cast("LONG64") long ExChange,
    @Cast("LONG64") long Comperand
    );

public static native @Cast("BOOLEAN") boolean InterlockedCompareExchange128(
    @Cast("LONG64*") LongPointer Destination,
    @Cast("LONG64") long ExchangeHigh,
    @Cast("LONG64") long ExchangeLow,
    @Cast("LONG64*") LongPointer ComparandResult
    );
public static native @Cast("BOOLEAN") boolean InterlockedCompareExchange128(
    @Cast("LONG64*") LongBuffer Destination,
    @Cast("LONG64") long ExchangeHigh,
    @Cast("LONG64") long ExchangeLow,
    @Cast("LONG64*") LongBuffer ComparandResult
    );
public static native @Cast("BOOLEAN") boolean InterlockedCompareExchange128(
    @Cast("LONG64*") long[] Destination,
    @Cast("LONG64") long ExchangeHigh,
    @Cast("LONG64") long ExchangeLow,
    @Cast("LONG64*") long[] ComparandResult
    );

public static native @Cast("PVOID") Pointer InterlockedExchangePointer(
    @Cast("PVOID*") PointerPointer Target,
    @Cast("PVOID") Pointer Value
    );

// #pragma intrinsic(_InterlockedIncrement16)
// #pragma intrinsic(_InterlockedDecrement16)
// #pragma intrinsic(_InterlockedCompareExchange16)
// #pragma intrinsic(_InterlockedAnd)
// #pragma intrinsic(_InterlockedOr)
// #pragma intrinsic(_InterlockedXor)
// #pragma intrinsic(_InterlockedIncrement)
// #pragma intrinsic(_InterlockedDecrement)
// #pragma intrinsic(_InterlockedExchange)
// #pragma intrinsic(_InterlockedExchangeAdd)
// #pragma intrinsic(_InterlockedCompareExchange)
// #pragma intrinsic(_InterlockedAnd64)
// #pragma intrinsic(_InterlockedOr64)
// #pragma intrinsic(_InterlockedXor64)
// #pragma intrinsic(_InterlockedIncrement64)
// #pragma intrinsic(_InterlockedDecrement64)
// #pragma intrinsic(_InterlockedExchange64)
// #pragma intrinsic(_InterlockedExchangeAdd64)
// #pragma intrinsic(_InterlockedCompareExchange64)

// #if _MSC_VER >= 1500

// #pragma intrinsic(_InterlockedCompareExchange128)

// #endif

// #pragma intrinsic(_InterlockedExchangePointer)
// #pragma intrinsic(_InterlockedCompareExchangePointer)

// #if (_MSC_VER >= 1600)


public static native @Cast("CHAR") byte InterlockedExchange8(
    @Cast("CHAR*") BytePointer Target,
    @Cast("CHAR") byte Value
    );
public static native @Cast("CHAR") byte InterlockedExchange8(
    @Cast("CHAR*") ByteBuffer Target,
    @Cast("CHAR") byte Value
    );
public static native @Cast("CHAR") byte InterlockedExchange8(
    @Cast("CHAR*") byte[] Target,
    @Cast("CHAR") byte Value
    );

public static native @Cast("SHORT") short InterlockedExchange16(
    @Cast("SHORT*") ShortPointer Destination,
    @Cast("SHORT") short ExChange
    );
public static native @Cast("SHORT") short InterlockedExchange16(
    @Cast("SHORT*") ShortBuffer Destination,
    @Cast("SHORT") short ExChange
    );
public static native @Cast("SHORT") short InterlockedExchange16(
    @Cast("SHORT*") short[] Destination,
    @Cast("SHORT") short ExChange
    );

// #pragma intrinsic(_InterlockedExchange8)
// #pragma intrinsic(_InterlockedExchange16)

// #endif /* _MSC_VER >= 1600 */

// #if _MSC_FULL_VER >= 140041204


public static native @Cast("char") byte InterlockedAnd8(
    @Cast("char*") BytePointer Destination,
    @Cast("char") byte Value
    );
public static native @Cast("char") byte InterlockedAnd8(
    @Cast("char*") ByteBuffer Destination,
    @Cast("char") byte Value
    );
public static native @Cast("char") byte InterlockedAnd8(
    @Cast("char*") byte[] Destination,
    @Cast("char") byte Value
    );

public static native @Cast("char") byte InterlockedOr8(
    @Cast("char*") BytePointer Destination,
    @Cast("char") byte Value
    );
public static native @Cast("char") byte InterlockedOr8(
    @Cast("char*") ByteBuffer Destination,
    @Cast("char") byte Value
    );
public static native @Cast("char") byte InterlockedOr8(
    @Cast("char*") byte[] Destination,
    @Cast("char") byte Value
    );

public static native @Cast("char") byte InterlockedXor8(
    @Cast("char*") BytePointer Destination,
    @Cast("char") byte Value
    );
public static native @Cast("char") byte InterlockedXor8(
    @Cast("char*") ByteBuffer Destination,
    @Cast("char") byte Value
    );
public static native @Cast("char") byte InterlockedXor8(
    @Cast("char*") byte[] Destination,
    @Cast("char") byte Value
    );

public static native @Cast("SHORT") short InterlockedAnd16(
    @Cast("SHORT*") ShortPointer Destination,
    @Cast("SHORT") short Value
    );
public static native @Cast("SHORT") short InterlockedAnd16(
    @Cast("SHORT*") ShortBuffer Destination,
    @Cast("SHORT") short Value
    );
public static native @Cast("SHORT") short InterlockedAnd16(
    @Cast("SHORT*") short[] Destination,
    @Cast("SHORT") short Value
    );

public static native @Cast("SHORT") short InterlockedOr16(
    @Cast("SHORT*") ShortPointer Destination,
    @Cast("SHORT") short Value
    );
public static native @Cast("SHORT") short InterlockedOr16(
    @Cast("SHORT*") ShortBuffer Destination,
    @Cast("SHORT") short Value
    );
public static native @Cast("SHORT") short InterlockedOr16(
    @Cast("SHORT*") short[] Destination,
    @Cast("SHORT") short Value
    );

public static native @Cast("SHORT") short InterlockedXor16(
    @Cast("SHORT*") ShortPointer Destination,
    @Cast("SHORT") short Value
    );
public static native @Cast("SHORT") short InterlockedXor16(
    @Cast("SHORT*") ShortBuffer Destination,
    @Cast("SHORT") short Value
    );
public static native @Cast("SHORT") short InterlockedXor16(
    @Cast("SHORT*") short[] Destination,
    @Cast("SHORT") short Value
    );

// #pragma intrinsic (_InterlockedAnd8)
// #pragma intrinsic (_InterlockedOr8)
// #pragma intrinsic (_InterlockedXor8)
// #pragma intrinsic (_InterlockedAnd16)
// #pragma intrinsic (_InterlockedOr16)
// #pragma intrinsic (_InterlockedXor16)

// #endif

// end_ntoshvp

//
// Define extended CPUID intrinsic.
//


public static native void __cpuidex(
    IntPointer CPUInfo,
    int Function,
    int SubLeaf
    );
public static native void __cpuidex(
    IntBuffer CPUInfo,
    int Function,
    int SubLeaf
    );
public static native void __cpuidex(
    int[] CPUInfo,
    int Function,
    int SubLeaf
    );

// #pragma intrinsic(__cpuidex)

// begin_ntoshvp

//
// Define function to flush a cache line.
//

// #define CacheLineFlush(Address) _mm_clflush(Address)

public static native void _mm_clflush(
    @Const Pointer Address
    );

// #pragma intrinsic(_mm_clflush)

// begin_wudfpwdm

public static native void _ReadWriteBarrier(
    );

// #pragma intrinsic(_ReadWriteBarrier)

//
// Define memory fence intrinsics
//


// end_wudfpwdm


// begin_wudfpwdm

public static native void __faststorefence(
    );

// end_wudfpwdm

public static native void _mm_lfence(
    );

public static native void _mm_mfence(
    );

public static native void _mm_sfence(
    );

public static native void _mm_pause(
    );



public static native void _m_prefetchw(
    @Const Pointer Source
    );

//
// Define constants for use with _mm_prefetch.
//

public static final int _MM_HINT_T0 =     1;
public static final int _MM_HINT_T1 =     2;
public static final int _MM_HINT_T2 =     3;
public static final int _MM_HINT_NTA =    0;

// begin_wudfpwdm

// #pragma intrinsic(__faststorefence)

// end_wudfpwdm

// #pragma intrinsic(_mm_pause)
// #pragma intrinsic(_mm_prefetch)
// #pragma intrinsic(_mm_lfence)
// #pragma intrinsic(_mm_mfence)
// #pragma intrinsic(_mm_sfence)
// #pragma intrinsic(_m_prefetchw)

// #define PreFetchCacheLine(l, a)  _mm_prefetch((CHAR CONST *) a, l)
// #define PrefetchForWrite(p) _m_prefetchw(p)
// #define ReadForWriteAccess(p) (_m_prefetchw(p), *(p))

//
// PreFetchCacheLine level defines.
//

public static final int PF_TEMPORAL_LEVEL_1 = _MM_HINT_T0;
public static final int PF_TEMPORAL_LEVEL_2 = _MM_HINT_T1;
public static final int PF_TEMPORAL_LEVEL_3 = _MM_HINT_T2;
public static final int PF_NON_TEMPORAL_LEVEL_ALL = _MM_HINT_NTA;

//
// Define get/set MXCSR intrinsics.
//


public static native @Cast("unsigned int") int _mm_getcsr(
    );

public static native void _mm_setcsr(
    @Cast("unsigned int") int MxCsr
    );

// #pragma intrinsic(_mm_getcsr)
// #pragma intrinsic(_mm_setcsr)

//
// Define function to get the caller's EFLAGs value.
//

// #define GetCallersEflags() __getcallerseflags()

public static native @Cast("unsigned") int __getcallerseflags(
    );

// #pragma intrinsic(__getcallerseflags)

//
// Define function to get segment limit.
//


public static native @Cast("DWORD") int __segmentlimit(
    @Cast("DWORD") int Selector
    );

// #pragma intrinsic(__segmentlimit)

//
// Define function to read the value of a performance counter.
//


public static native @Cast("DWORD64") long __readpmc(
    @Cast("DWORD") int Counter
    );

// #pragma intrinsic(__readpmc)

//
// Define function to read the value of the time stamp counter
//

// #define ReadTimeStampCounter() __rdtsc()

public static native @Cast("DWORD64") long __rdtsc(
    );

// #pragma intrinsic(__rdtsc)

//
// Define functions to move strings as bytes, words, dwords, and qwords.
//

public static native void __movsb(
    @Cast("PBYTE") BytePointer Destination,
    @Cast("const BYTE*") BytePointer Source,
    @Cast("SIZE_T") long Count
    );
public static native void __movsb(
    @Cast("PBYTE") ByteBuffer Destination,
    @Cast("const BYTE*") ByteBuffer Source,
    @Cast("SIZE_T") long Count
    );
public static native void __movsb(
    @Cast("PBYTE") byte[] Destination,
    @Cast("const BYTE*") byte[] Source,
    @Cast("SIZE_T") long Count
    );

public static native void __movsw(
    @Cast("PWORD") short Destination,
    @Cast("const WORD*") ShortPointer Source,
    @Cast("SIZE_T") long Count
    );
public static native void __movsw(
    @Cast("PWORD") short Destination,
    @Cast("const WORD*") ShortBuffer Source,
    @Cast("SIZE_T") long Count
    );
public static native void __movsw(
    @Cast("PWORD") short Destination,
    @Cast("const WORD*") short[] Source,
    @Cast("SIZE_T") long Count
    );

public static native void __movsd(
    @Cast("PDWORD") IntPointer Destination,
    @Cast("const DWORD*") IntPointer Source,
    @Cast("SIZE_T") long Count
    );
public static native void __movsd(
    @Cast("PDWORD") IntBuffer Destination,
    @Cast("const DWORD*") IntBuffer Source,
    @Cast("SIZE_T") long Count
    );
public static native void __movsd(
    @Cast("PDWORD") int[] Destination,
    @Cast("const DWORD*") int[] Source,
    @Cast("SIZE_T") long Count
    );

public static native void __movsq(
    @Cast("PDWORD64") LongPointer Destination,
    @Cast("const DWORD64*") LongPointer Source,
    @Cast("SIZE_T") long Count
    );
public static native void __movsq(
    @Cast("PDWORD64") LongBuffer Destination,
    @Cast("const DWORD64*") LongBuffer Source,
    @Cast("SIZE_T") long Count
    );
public static native void __movsq(
    @Cast("PDWORD64") long[] Destination,
    @Cast("const DWORD64*") long[] Source,
    @Cast("SIZE_T") long Count
    );

// #pragma intrinsic(__movsb)
// #pragma intrinsic(__movsw)
// #pragma intrinsic(__movsd)
// #pragma intrinsic(__movsq)

//
// Define functions to store strings as bytes, words, dwords, and qwords.
//

public static native void __stosb(
    @Cast("PBYTE") BytePointer Destination,
    @Cast("BYTE") byte Value,
    @Cast("SIZE_T") long Count
    );
public static native void __stosb(
    @Cast("PBYTE") ByteBuffer Destination,
    @Cast("BYTE") byte Value,
    @Cast("SIZE_T") long Count
    );
public static native void __stosb(
    @Cast("PBYTE") byte[] Destination,
    @Cast("BYTE") byte Value,
    @Cast("SIZE_T") long Count
    );

public static native void __stosw(
    @Cast("PWORD") short Destination,
    @Cast("WORD") short Value,
    @Cast("SIZE_T") long Count
    );

public static native void __stosd(
    @Cast("PDWORD") IntPointer Destination,
    @Cast("DWORD") int Value,
    @Cast("SIZE_T") long Count
    );
public static native void __stosd(
    @Cast("PDWORD") IntBuffer Destination,
    @Cast("DWORD") int Value,
    @Cast("SIZE_T") long Count
    );
public static native void __stosd(
    @Cast("PDWORD") int[] Destination,
    @Cast("DWORD") int Value,
    @Cast("SIZE_T") long Count
    );

public static native void __stosq(
    @Cast("PDWORD64") LongPointer Destination,
    @Cast("DWORD64") long Value,
    @Cast("SIZE_T") long Count
    );
public static native void __stosq(
    @Cast("PDWORD64") LongBuffer Destination,
    @Cast("DWORD64") long Value,
    @Cast("SIZE_T") long Count
    );
public static native void __stosq(
    @Cast("PDWORD64") long[] Destination,
    @Cast("DWORD64") long Value,
    @Cast("SIZE_T") long Count
    );

// #pragma intrinsic(__stosb)
// #pragma intrinsic(__stosw)
// #pragma intrinsic(__stosd)
// #pragma intrinsic(__stosq)

//
// Define functions to capture the high 64-bits of a 128-bit multiply.
//


public static native @Cast("LONGLONG") long MultiplyHigh(
    @Cast("LONG64") long Multiplier,
    @Cast("LONG64") long Multiplicand
    );

public static native @Cast("ULONGLONG") long UnsignedMultiplyHigh(
    @Cast("DWORD64") long Multiplier,
    @Cast("DWORD64") long Multiplicand
    );

// #pragma intrinsic(__mulh)
// #pragma intrinsic(__umulh)

//
// Define population count intrinsic.
//


public static native @Cast("DWORD64") long PopulationCount64(
    @Cast("DWORD64") long operand
    );

// #if _MSC_VER >= 1500

// #pragma intrinsic(__popcnt64)

// #endif

//
// Define functions to perform 128-bit shifts
//


public static native @Cast("DWORD64") long ShiftLeft128(
    @Cast("DWORD64") long LowPart,
    @Cast("DWORD64") long HighPart,
    @Cast("BYTE") byte Shift
    );

public static native @Cast("DWORD64") long ShiftRight128(
    @Cast("DWORD64") long LowPart,
    @Cast("DWORD64") long HighPart,
    @Cast("BYTE") byte Shift
    );

// #pragma intrinsic(__shiftleft128)
// #pragma intrinsic(__shiftright128)

//
// Define functions to perform 128-bit multiplies.
//


public static native @Cast("LONG64") long Multiply128(
    @Cast("LONG64") long Multiplier,
    @Cast("LONG64") long Multiplicand,
    @Cast("LONG64*") LongPointer HighProduct
    );
public static native @Cast("LONG64") long Multiply128(
    @Cast("LONG64") long Multiplier,
    @Cast("LONG64") long Multiplicand,
    @Cast("LONG64*") LongBuffer HighProduct
    );
public static native @Cast("LONG64") long Multiply128(
    @Cast("LONG64") long Multiplier,
    @Cast("LONG64") long Multiplicand,
    @Cast("LONG64*") long[] HighProduct
    );

// #pragma intrinsic(_mul128)

// #ifndef UnsignedMultiply128


public static native @Cast("DWORD64") long UnsignedMultiply128(
    @Cast("DWORD64") long Multiplier,
    @Cast("DWORD64") long Multiplicand,
    @Cast("DWORD64*") LongPointer HighProduct
    );
public static native @Cast("DWORD64") long UnsignedMultiply128(
    @Cast("DWORD64") long Multiplier,
    @Cast("DWORD64") long Multiplicand,
    @Cast("DWORD64*") LongBuffer HighProduct
    );
public static native @Cast("DWORD64") long UnsignedMultiply128(
    @Cast("DWORD64") long Multiplier,
    @Cast("DWORD64") long Multiplicand,
    @Cast("DWORD64*") long[] HighProduct
    );

// #pragma intrinsic(_umul128)

// #endif

public static native @Cast("LONG64") long MultiplyExtract128(
    @Cast("LONG64") long Multiplier,
    @Cast("LONG64") long Multiplicand,
    @Cast("BYTE") byte Shift
    );

public static native @Cast("DWORD64") long UnsignedMultiplyExtract128(
    @Cast("DWORD64") long Multiplier,
    @Cast("DWORD64") long Multiplicand,
    @Cast("BYTE") byte Shift
    );

//
// Define functions to read and write the uer TEB and the system PCR/PRCB.
//

public static native @Cast("BYTE") byte __readgsbyte(
    @Cast("DWORD") int Offset
    );

public static native @Cast("WORD") short __readgsword(
    @Cast("DWORD") int Offset
    );

public static native @Cast("DWORD") int __readgsdword(
    @Cast("DWORD") int Offset
    );

public static native @Cast("DWORD64") long __readgsqword(
    @Cast("DWORD") int Offset
    );

public static native void __writegsbyte(
    @Cast("DWORD") int Offset,
    @Cast("BYTE") byte Data
    );

public static native void __writegsword(
    @Cast("DWORD") int Offset,
    @Cast("WORD") short Data
    );

public static native void __writegsdword(
    @Cast("DWORD") int Offset,
    @Cast("DWORD") int Data
    );

public static native void __writegsqword(
    @Cast("DWORD") int Offset,
    @Cast("DWORD64") long Data
    );

// #pragma intrinsic(__readgsbyte)
// #pragma intrinsic(__readgsword)
// #pragma intrinsic(__readgsdword)
// #pragma intrinsic(__readgsqword)
// #pragma intrinsic(__writegsbyte)
// #pragma intrinsic(__writegsword)
// #pragma intrinsic(__writegsdword)
// #pragma intrinsic(__writegsqword)

// #if !defined(_MANAGED)

public static native void __incgsbyte(
    @Cast("DWORD") int Offset
    );

public static native void __addgsbyte(
    @Cast("DWORD") int Offset,
    @Cast("BYTE") byte Value
    );

public static native void __incgsword(
    @Cast("DWORD") int Offset
    );

public static native void __addgsword(
    @Cast("DWORD") int Offset,
    @Cast("WORD") short Value
    );

public static native void __incgsdword(
    @Cast("DWORD") int Offset
    );

public static native void __addgsdword(
    @Cast("DWORD") int Offset,
    @Cast("DWORD") int Value
    );

public static native void __incgsqword(
    @Cast("DWORD") int Offset
    );

public static native void __addgsqword(
    @Cast("DWORD") int Offset,
    @Cast("DWORD64") long Value
    );

// #if 0
// #endif

// #endif // !defined(_MANAGED)


// #ifdef __cplusplus
// #endif

// #endif // defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

// end_ntoshvp
//
// The following values specify the type of access in the first parameter
// of the exception record whan the exception code specifies an access
// violation.
//

public static final int EXCEPTION_READ_FAULT = 0;          // exception caused by a read
public static final int EXCEPTION_WRITE_FAULT = 1;         // exception caused by a write
public static final int EXCEPTION_EXECUTE_FAULT = 8;       // exception caused by an instruction fetch

// begin_wx86
//
// The following flags control the contents of the CONTEXT structure.
//

// #if !defined(RC_INVOKED)

public static final long CONTEXT_AMD64 =   0x00100000L;

// end_wx86

public static final long CONTEXT_CONTROL =         (CONTEXT_AMD64 | 0x00000001L);
public static final long CONTEXT_INTEGER =         (CONTEXT_AMD64 | 0x00000002L);
public static final long CONTEXT_SEGMENTS =        (CONTEXT_AMD64 | 0x00000004L);
public static final long CONTEXT_FLOATING_POINT =  (CONTEXT_AMD64 | 0x00000008L);
public static final long CONTEXT_DEBUG_REGISTERS = (CONTEXT_AMD64 | 0x00000010L);

public static final long CONTEXT_FULL =            (CONTEXT_CONTROL | CONTEXT_INTEGER | 
                                 CONTEXT_FLOATING_POINT);

public static final long CONTEXT_ALL =             (CONTEXT_CONTROL | CONTEXT_INTEGER | 
                                 CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT | 
                                 CONTEXT_DEBUG_REGISTERS);

public static final long CONTEXT_XSTATE =          (CONTEXT_AMD64 | 0x00000040L);

public static final long CONTEXT_EXCEPTION_ACTIVE =    0x08000000L;
public static final long CONTEXT_SERVICE_ACTIVE =      0x10000000L;
public static final long CONTEXT_EXCEPTION_REQUEST =   0x40000000L;
public static final long CONTEXT_EXCEPTION_REPORTING = 0x80000000L;

// begin_wx86

// #endif // !defined(RC_INVOKED)

//
// Define initial MxCsr and FpCsr control.
//

public static final int INITIAL_MXCSR = 0x1f80;            // initial MXCSR value
public static final int INITIAL_FPCSR = 0x027f;            // initial FPCSR value

// end_ntddk
// begin_wdm begin_ntosp
// begin_ntoshvp
// Targeting ..\windows\CONTEXT.java



// end_ntoshvp
//
// Select platform-specific definitions
//

public static final int RUNTIME_FUNCTION_INDIRECT = 0x1;

//
// Define unwind information flags.
//

public static final int UNW_FLAG_NHANDLER =       0x0;
public static final int UNW_FLAG_EHANDLER =       0x1;
public static final int UNW_FLAG_UHANDLER =       0x2;
public static final int UNW_FLAG_CHAININFO =      0x4;

public static final long UNW_FLAG_NO_EPILOGUE =    0x80000000L;    // Software only flag

//
// Define unwind history table structure.
//

public static final int UNWIND_HISTORY_TABLE_SIZE = 12;

//
// Define dynamic function table entry.
//

public static final String OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME = 
    "OutOfProcessFunctionTableCallback";

//
// Define exception dispatch context structure.
//

//
// Define exception filter and termination handler function types.
//


//
// Nonvolatile context pointer record.
//
// Targeting ..\windows\SCOPE_TABLE_ARM.java




// #ifdef _ARM_

// #endif // _ARM_


// #ifdef __cplusplus
// #endif

//
// Assert exception.
//

// #if !defined(_DBGRAISEASSERTIONFAILURE_) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

// #define _DBGRAISEASSERTIONFAILURE_

// #if defined(_PREFAST_)

public static native void DbgRaiseAssertionFailure(
    );

// #endif

// #if defined(_AMD64_)

// #if defined(_M_AMD64)

public static native void __int2c(
    );

// #pragma intrinsic(__int2c)

// #if !defined(_PREFAST_)

// #define DbgRaiseAssertionFailure() __int2c()

// #endif // !defined(_PREFAST_)

// #endif // defined(_M_AMD64)

// #elif defined(_X86_)

// #elif defined(_IA64_)

// #elif defined(_ARM_)

// #endif // _AMD64_, _X86_, _IA64_, _ARM_
// #endif // !defined(_DBGRAISEASSERTIONFAILURE_) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

// #ifdef __cplusplus
// #endif

// begin_ntoshvp

// #ifdef _X86_
// #endif //_X86_


// #ifndef _LDT_ENTRY_DEFINED
// #define _LDT_ENTRY_DEFINED
// Targeting ..\windows\LDT_ENTRY.java



// #endif


// #if defined(_M_IA64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

// #endif /* defined(_M_IA64) && !defined(RC_INVOKED) && !defined(MIDL_PASS) */


// #if !defined(__midl) && !defined(GENUTIL) && !defined(_GENIA64_) && defined(_IA64_)

// #endif  // !defined(__midl) && !defined(GENUTIL) && !defined(_GENIA64_) && defined(_M_IA64)

// #ifdef _IA64_

// #endif // _IA64_

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// begin_wdm begin_ntminiport

// #if !defined(RC_INVOKED) && !defined(MIDL_PASS)
// #if defined(_M_AMD64) || defined(_M_IX86) || defined(_M_CEE_PURE)

// #ifdef __cplusplus
// #endif

public static native @Cast("CHAR") byte ReadAcquire8(
    @Cast("const CHAR*") BytePointer Source
    );
public static native @Cast("CHAR") byte ReadAcquire8(
    @Cast("const CHAR*") ByteBuffer Source
    );
public static native @Cast("CHAR") byte ReadAcquire8(
    @Cast("const CHAR*") byte[] Source
    );

public static native @Cast("CHAR") byte ReadNoFence8(
    @Cast("const CHAR*") BytePointer Source
    );
public static native @Cast("CHAR") byte ReadNoFence8(
    @Cast("const CHAR*") ByteBuffer Source
    );
public static native @Cast("CHAR") byte ReadNoFence8(
    @Cast("const CHAR*") byte[] Source
    );

public static native void WriteRelease8(
    @Cast("CHAR*") BytePointer Destination,
    @Cast("CHAR") byte Value
    );
public static native void WriteRelease8(
    @Cast("CHAR*") ByteBuffer Destination,
    @Cast("CHAR") byte Value
    );
public static native void WriteRelease8(
    @Cast("CHAR*") byte[] Destination,
    @Cast("CHAR") byte Value
    );

public static native void WriteNoFence8(
    @Cast("CHAR*") BytePointer Destination,
    @Cast("CHAR") byte Value
    );
public static native void WriteNoFence8(
    @Cast("CHAR*") ByteBuffer Destination,
    @Cast("CHAR") byte Value
    );
public static native void WriteNoFence8(
    @Cast("CHAR*") byte[] Destination,
    @Cast("CHAR") byte Value
    );

public static native @Cast("SHORT") short ReadAcquire16(
    @Cast("const SHORT*") ShortPointer Source
    );
public static native @Cast("SHORT") short ReadAcquire16(
    @Cast("const SHORT*") ShortBuffer Source
    );
public static native @Cast("SHORT") short ReadAcquire16(
    @Cast("const SHORT*") short[] Source
    );

public static native @Cast("SHORT") short ReadNoFence16(
    @Cast("const SHORT*") ShortPointer Source
    );
public static native @Cast("SHORT") short ReadNoFence16(
    @Cast("const SHORT*") ShortBuffer Source
    );
public static native @Cast("SHORT") short ReadNoFence16(
    @Cast("const SHORT*") short[] Source
    );

public static native void WriteRelease16(
    @Cast("SHORT*") ShortPointer Destination,
    @Cast("SHORT") short Value
    );
public static native void WriteRelease16(
    @Cast("SHORT*") ShortBuffer Destination,
    @Cast("SHORT") short Value
    );
public static native void WriteRelease16(
    @Cast("SHORT*") short[] Destination,
    @Cast("SHORT") short Value
    );

public static native void WriteNoFence16(
    @Cast("SHORT*") ShortPointer Destination,
    @Cast("SHORT") short Value
    );
public static native void WriteNoFence16(
    @Cast("SHORT*") ShortBuffer Destination,
    @Cast("SHORT") short Value
    );
public static native void WriteNoFence16(
    @Cast("SHORT*") short[] Destination,
    @Cast("SHORT") short Value
    );

public static native @Cast("LONG") int ReadAcquire(
    @Cast("const LONG*") IntPointer Source
    );
public static native @Cast("LONG") int ReadAcquire(
    @Cast("const LONG*") IntBuffer Source
    );
public static native @Cast("LONG") int ReadAcquire(
    @Cast("const LONG*") int[] Source
    );

public static native @Cast("LONG") int ReadNoFence(
    @Cast("const LONG*") IntPointer Source
    );
public static native @Cast("LONG") int ReadNoFence(
    @Cast("const LONG*") IntBuffer Source
    );
public static native @Cast("LONG") int ReadNoFence(
    @Cast("const LONG*") int[] Source
    );

public static native void WriteRelease(
    @Cast("LONG*") IntPointer Destination,
    @Cast("LONG") int Value
    );
public static native void WriteRelease(
    @Cast("LONG*") IntBuffer Destination,
    @Cast("LONG") int Value
    );
public static native void WriteRelease(
    @Cast("LONG*") int[] Destination,
    @Cast("LONG") int Value
    );

public static native void WriteNoFence(
    @Cast("LONG*") IntPointer Destination,
    @Cast("LONG") int Value
    );
public static native void WriteNoFence(
    @Cast("LONG*") IntBuffer Destination,
    @Cast("LONG") int Value
    );
public static native void WriteNoFence(
    @Cast("LONG*") int[] Destination,
    @Cast("LONG") int Value
    );

public static native @Cast("LONG64") long ReadAcquire64(
    @Cast("const LONG64*") LongPointer Source
    );
public static native @Cast("LONG64") long ReadAcquire64(
    @Cast("const LONG64*") LongBuffer Source
    );
public static native @Cast("LONG64") long ReadAcquire64(
    @Cast("const LONG64*") long[] Source
    );

public static native @Cast("LONG64") long ReadNoFence64(
    @Cast("const LONG64*") LongPointer Source
    );
public static native @Cast("LONG64") long ReadNoFence64(
    @Cast("const LONG64*") LongBuffer Source
    );
public static native @Cast("LONG64") long ReadNoFence64(
    @Cast("const LONG64*") long[] Source
    );

public static native void WriteRelease64(
    @Cast("LONG64*") LongPointer Destination,
    @Cast("LONG64") long Value
    );
public static native void WriteRelease64(
    @Cast("LONG64*") LongBuffer Destination,
    @Cast("LONG64") long Value
    );
public static native void WriteRelease64(
    @Cast("LONG64*") long[] Destination,
    @Cast("LONG64") long Value
    );

public static native void WriteNoFence64(
    @Cast("LONG64*") LongPointer Destination,
    @Cast("LONG64") long Value
    );
public static native void WriteNoFence64(
    @Cast("LONG64*") LongBuffer Destination,
    @Cast("LONG64") long Value
    );
public static native void WriteNoFence64(
    @Cast("LONG64*") long[] Destination,
    @Cast("LONG64") long Value
    );

// #ifdef __cplusplus
// #endif

// #endif // defined(_M_AMD64) || defined(_M_IX86) || defined(_M_CEE_PURE)

//
// Define "raw" operations which have no ordering or atomicity semantics.
//

public static native @Cast("CHAR") byte ReadRaw8(
    @Cast("const CHAR*") BytePointer Source
    );
public static native @Cast("CHAR") byte ReadRaw8(
    @Cast("const CHAR*") ByteBuffer Source
    );
public static native @Cast("CHAR") byte ReadRaw8(
    @Cast("const CHAR*") byte[] Source
    );

public static native void WriteRaw8(
    @Cast("CHAR*") BytePointer Destination,
    @Cast("CHAR") byte Value
    );
public static native void WriteRaw8(
    @Cast("CHAR*") ByteBuffer Destination,
    @Cast("CHAR") byte Value
    );
public static native void WriteRaw8(
    @Cast("CHAR*") byte[] Destination,
    @Cast("CHAR") byte Value
    );

public static native @Cast("SHORT") short ReadRaw16(
    @Cast("const SHORT*") ShortPointer Source
    );
public static native @Cast("SHORT") short ReadRaw16(
    @Cast("const SHORT*") ShortBuffer Source
    );
public static native @Cast("SHORT") short ReadRaw16(
    @Cast("const SHORT*") short[] Source
    );

public static native void WriteRaw16(
    @Cast("SHORT*") ShortPointer Destination,
    @Cast("SHORT") short Value
    );
public static native void WriteRaw16(
    @Cast("SHORT*") ShortBuffer Destination,
    @Cast("SHORT") short Value
    );
public static native void WriteRaw16(
    @Cast("SHORT*") short[] Destination,
    @Cast("SHORT") short Value
    );

public static native @Cast("LONG") int ReadRaw(
    @Cast("const LONG*") IntPointer Source
    );
public static native @Cast("LONG") int ReadRaw(
    @Cast("const LONG*") IntBuffer Source
    );
public static native @Cast("LONG") int ReadRaw(
    @Cast("const LONG*") int[] Source
    );

public static native void WriteRaw(
    @Cast("LONG*") IntPointer Destination,
    @Cast("LONG") int Value
    );
public static native void WriteRaw(
    @Cast("LONG*") IntBuffer Destination,
    @Cast("LONG") int Value
    );
public static native void WriteRaw(
    @Cast("LONG*") int[] Destination,
    @Cast("LONG") int Value
    );

public static native @Cast("LONG64") long ReadRaw64(
    @Cast("const LONG64*") LongPointer Source
    );
public static native @Cast("LONG64") long ReadRaw64(
    @Cast("const LONG64*") LongBuffer Source
    );
public static native @Cast("LONG64") long ReadRaw64(
    @Cast("const LONG64*") long[] Source
    );

public static native void WriteRaw64(
    @Cast("LONG64*") LongPointer Destination,
    @Cast("LONG64") long Value
    );
public static native void WriteRaw64(
    @Cast("LONG64*") LongBuffer Destination,
    @Cast("LONG64") long Value
    );
public static native void WriteRaw64(
    @Cast("LONG64*") long[] Destination,
    @Cast("LONG64") long Value
    );

//
// Define explicit read and write operations for derived types.
//

public static native @Cast("BYTE") byte ReadUCharAcquire(
    @Cast("const BYTE*") BytePointer Source
    );
public static native @Cast("BYTE") byte ReadUCharAcquire(
    @Cast("const BYTE*") ByteBuffer Source
    );
public static native @Cast("BYTE") byte ReadUCharAcquire(
    @Cast("const BYTE*") byte[] Source
    );

public static native @Cast("BYTE") byte ReadUCharNoFence(
    @Cast("const BYTE*") BytePointer Source
    );
public static native @Cast("BYTE") byte ReadUCharNoFence(
    @Cast("const BYTE*") ByteBuffer Source
    );
public static native @Cast("BYTE") byte ReadUCharNoFence(
    @Cast("const BYTE*") byte[] Source
    );

public static native @Cast("BYTE") byte ReadUCharRaw(
    @Cast("const BYTE*") BytePointer Source
    );
public static native @Cast("BYTE") byte ReadUCharRaw(
    @Cast("const BYTE*") ByteBuffer Source
    );
public static native @Cast("BYTE") byte ReadUCharRaw(
    @Cast("const BYTE*") byte[] Source
    );

public static native void WriteUCharRelease(
    @Cast("BYTE*") BytePointer Destination,
    @Cast("BYTE") byte Value
    );
public static native void WriteUCharRelease(
    @Cast("BYTE*") ByteBuffer Destination,
    @Cast("BYTE") byte Value
    );
public static native void WriteUCharRelease(
    @Cast("BYTE*") byte[] Destination,
    @Cast("BYTE") byte Value
    );

public static native void WriteUCharNoFence(
    @Cast("BYTE*") BytePointer Destination,
    @Cast("BYTE") byte Value
    );
public static native void WriteUCharNoFence(
    @Cast("BYTE*") ByteBuffer Destination,
    @Cast("BYTE") byte Value
    );
public static native void WriteUCharNoFence(
    @Cast("BYTE*") byte[] Destination,
    @Cast("BYTE") byte Value
    );

public static native void WriteUCharRaw(
    @Cast("BYTE*") BytePointer Destination,
    @Cast("BYTE") byte Value
    );
public static native void WriteUCharRaw(
    @Cast("BYTE*") ByteBuffer Destination,
    @Cast("BYTE") byte Value
    );
public static native void WriteUCharRaw(
    @Cast("BYTE*") byte[] Destination,
    @Cast("BYTE") byte Value
    );

public static native @Cast("WORD") short ReadUShortAcquire(
    @Cast("const WORD*") ShortPointer Source
    );
public static native @Cast("WORD") short ReadUShortAcquire(
    @Cast("const WORD*") ShortBuffer Source
    );
public static native @Cast("WORD") short ReadUShortAcquire(
    @Cast("const WORD*") short[] Source
    );

public static native @Cast("WORD") short ReadUShortNoFence(
    @Cast("const WORD*") ShortPointer Source
    );
public static native @Cast("WORD") short ReadUShortNoFence(
    @Cast("const WORD*") ShortBuffer Source
    );
public static native @Cast("WORD") short ReadUShortNoFence(
    @Cast("const WORD*") short[] Source
    );

public static native @Cast("WORD") short ReadUShortRaw(
    @Cast("const WORD*") ShortPointer Source
    );
public static native @Cast("WORD") short ReadUShortRaw(
    @Cast("const WORD*") ShortBuffer Source
    );
public static native @Cast("WORD") short ReadUShortRaw(
    @Cast("const WORD*") short[] Source
    );

public static native void WriteUShortRelease(
    @Cast("WORD*") ShortPointer Destination,
    @Cast("WORD") short Value
    );
public static native void WriteUShortRelease(
    @Cast("WORD*") ShortBuffer Destination,
    @Cast("WORD") short Value
    );
public static native void WriteUShortRelease(
    @Cast("WORD*") short[] Destination,
    @Cast("WORD") short Value
    );

public static native void WriteUShortNoFence(
    @Cast("WORD*") ShortPointer Destination,
    @Cast("WORD") short Value
    );
public static native void WriteUShortNoFence(
    @Cast("WORD*") ShortBuffer Destination,
    @Cast("WORD") short Value
    );
public static native void WriteUShortNoFence(
    @Cast("WORD*") short[] Destination,
    @Cast("WORD") short Value
    );

public static native void WriteUShortRaw(
    @Cast("WORD*") ShortPointer Destination,
    @Cast("WORD") short Value
    );
public static native void WriteUShortRaw(
    @Cast("WORD*") ShortBuffer Destination,
    @Cast("WORD") short Value
    );
public static native void WriteUShortRaw(
    @Cast("WORD*") short[] Destination,
    @Cast("WORD") short Value
    );

public static native @Cast("DWORD") int ReadULongAcquire(
    @Cast("const DWORD*") IntPointer Source
    );
public static native @Cast("DWORD") int ReadULongAcquire(
    @Cast("const DWORD*") IntBuffer Source
    );
public static native @Cast("DWORD") int ReadULongAcquire(
    @Cast("const DWORD*") int[] Source
    );

public static native @Cast("DWORD") int ReadULongNoFence(
    @Cast("const DWORD*") IntPointer Source
    );
public static native @Cast("DWORD") int ReadULongNoFence(
    @Cast("const DWORD*") IntBuffer Source
    );
public static native @Cast("DWORD") int ReadULongNoFence(
    @Cast("const DWORD*") int[] Source
    );

public static native @Cast("DWORD") int ReadULongRaw(
    @Cast("const DWORD*") IntPointer Source
    );
public static native @Cast("DWORD") int ReadULongRaw(
    @Cast("const DWORD*") IntBuffer Source
    );
public static native @Cast("DWORD") int ReadULongRaw(
    @Cast("const DWORD*") int[] Source
    );

public static native void WriteULongRelease(
    @Cast("DWORD*") IntPointer Destination,
    @Cast("DWORD") int Value
    );
public static native void WriteULongRelease(
    @Cast("DWORD*") IntBuffer Destination,
    @Cast("DWORD") int Value
    );
public static native void WriteULongRelease(
    @Cast("DWORD*") int[] Destination,
    @Cast("DWORD") int Value
    );

public static native void WriteULongNoFence(
    @Cast("DWORD*") IntPointer Destination,
    @Cast("DWORD") int Value
    );
public static native void WriteULongNoFence(
    @Cast("DWORD*") IntBuffer Destination,
    @Cast("DWORD") int Value
    );
public static native void WriteULongNoFence(
    @Cast("DWORD*") int[] Destination,
    @Cast("DWORD") int Value
    );

public static native void WriteULongRaw(
    @Cast("DWORD*") IntPointer Destination,
    @Cast("DWORD") int Value
    );
public static native void WriteULongRaw(
    @Cast("DWORD*") IntBuffer Destination,
    @Cast("DWORD") int Value
    );
public static native void WriteULongRaw(
    @Cast("DWORD*") int[] Destination,
    @Cast("DWORD") int Value
    );

public static native @Cast("DWORD64") long ReadULong64Acquire(
    @Cast("const DWORD64*") LongPointer Source
    );
public static native @Cast("DWORD64") long ReadULong64Acquire(
    @Cast("const DWORD64*") LongBuffer Source
    );
public static native @Cast("DWORD64") long ReadULong64Acquire(
    @Cast("const DWORD64*") long[] Source
    );

public static native @Cast("DWORD64") long ReadULong64NoFence(
    @Cast("const DWORD64*") LongPointer Source
    );
public static native @Cast("DWORD64") long ReadULong64NoFence(
    @Cast("const DWORD64*") LongBuffer Source
    );
public static native @Cast("DWORD64") long ReadULong64NoFence(
    @Cast("const DWORD64*") long[] Source
    );

public static native @Cast("DWORD64") long ReadULong64Raw(
    @Cast("const DWORD64*") LongPointer Source
    );
public static native @Cast("DWORD64") long ReadULong64Raw(
    @Cast("const DWORD64*") LongBuffer Source
    );
public static native @Cast("DWORD64") long ReadULong64Raw(
    @Cast("const DWORD64*") long[] Source
    );

public static native void WriteULong64Release(
    @Cast("DWORD64*") LongPointer Destination,
    @Cast("DWORD64") long Value
    );
public static native void WriteULong64Release(
    @Cast("DWORD64*") LongBuffer Destination,
    @Cast("DWORD64") long Value
    );
public static native void WriteULong64Release(
    @Cast("DWORD64*") long[] Destination,
    @Cast("DWORD64") long Value
    );

public static native void WriteULong64NoFence(
    @Cast("DWORD64*") LongPointer Destination,
    @Cast("DWORD64") long Value
    );
public static native void WriteULong64NoFence(
    @Cast("DWORD64*") LongBuffer Destination,
    @Cast("DWORD64") long Value
    );
public static native void WriteULong64NoFence(
    @Cast("DWORD64*") long[] Destination,
    @Cast("DWORD64") long Value
    );

public static native void WriteULong64Raw(
    @Cast("DWORD64*") LongPointer Destination,
    @Cast("DWORD64") long Value
    );
public static native void WriteULong64Raw(
    @Cast("DWORD64*") LongBuffer Destination,
    @Cast("DWORD64") long Value
    );
public static native void WriteULong64Raw(
    @Cast("DWORD64*") long[] Destination,
    @Cast("DWORD64") long Value
    );

// #define ReadSizeTAcquire ReadULongPtrAcquire

// #define ReadSizeTNoFence ReadULongPtrNoFence

// #define ReadSizeTRaw ReadULongPtrRaw

// #define WriteSizeTRelease WriteULongPtrRelease

// #define WriteSizeTNoFence WriteULongPtrNoFence

// #define WriteSizeTRaw WriteULongPtrRaw

// #if !defined(_WIN64)

public static native @Cast("PVOID") Pointer ReadPointerAcquire(
    @Cast("const PVOID*") PointerPointer Source
    );

public static native @Cast("PVOID") Pointer ReadPointerNoFence(
    @Cast("const PVOID*") PointerPointer Source
    );

public static native @Cast("PVOID") Pointer ReadPointerRaw(
    @Cast("const PVOID*") PointerPointer Source
    );

public static native void WritePointerRelease(
    @Cast("PVOID*") PointerPointer Destination,
    @Cast("PVOID") Pointer Value
    );

public static native void WritePointerNoFence(
    @Cast("PVOID*") PointerPointer Destination,
    @Cast("PVOID") Pointer Value
    );

public static native void WritePointerRaw(
    @Cast("PVOID*") PointerPointer Destination,
    @Cast("PVOID") Pointer Value
    );

// #define ReadLongPtrAcquire ReadAcquire

// #define ReadLongPtrNoFence ReadNoFence

// #define ReadLongPtrRaw ReadRaw

// #define WriteLongPtrRelease WriteRelease

// #define WriteLongPtrNoFence WriteNoFence

// #define WriteLongPtrRaw WriteRaw

// #define ReadULongPtrAcquire ReadULongAcquire

// #define ReadULongPtrNoFence ReadULongNoFence

// #define ReadULongPtrRaw ReadULongRaw

// #define WriteULongPtrRelease WriteULongRelease

// #define WriteULongPtrNoFence WriteULongNoFence

// #define WriteULongPtrRaw WriteULongRaw

// #else // !defined(_WIN64)

// #define ReadLongPtrAcquire ReadAcquire64

// #define ReadLongPtrNoFence ReadNoFence64

// #define ReadLongPtrRaw ReadRaw64

// #define WriteLongPtrRelease WriteRelease64

// #define WriteLongPtrNoFence WriteNoFence64

// #define WriteLongPtrRaw WriteRaw64

// #define ReadULongPtrAcquire ReadULong64Acquire

// #define ReadULongPtrNoFence ReadULong64NoFence

// #define ReadULongPtrRaw ReadULong64Raw

// #define WriteULongPtrRelease WriteULong64Release

// #define WriteULongPtrNoFence WriteULong64NoFence

// #define WriteULongPtrRaw WriteULong64Raw

// #endif // !defined(_WIN64)

// #endif // !defined(RC_INVOKED) && !defined(MIDL_PASS)

// end_ntddk end_wdm end_ntminiport
// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// #if !defined(RC_INVOKED)

public static final int WOW64_CONTEXT_i386 =      0x00010000;    // this assumes that i386 and
public static final int WOW64_CONTEXT_i486 =      0x00010000;    // i486 have identical context records

public static final long WOW64_CONTEXT_CONTROL =               (WOW64_CONTEXT_i386 | 0x00000001L); // SS:SP, CS:IP, FLAGS, BP
public static final long WOW64_CONTEXT_INTEGER =               (WOW64_CONTEXT_i386 | 0x00000002L); // AX, BX, CX, DX, SI, DI
public static final long WOW64_CONTEXT_SEGMENTS =              (WOW64_CONTEXT_i386 | 0x00000004L); // DS, ES, FS, GS
public static final long WOW64_CONTEXT_FLOATING_POINT =        (WOW64_CONTEXT_i386 | 0x00000008L); // 387 state
public static final long WOW64_CONTEXT_DEBUG_REGISTERS =       (WOW64_CONTEXT_i386 | 0x00000010L); // DB 0-3,6,7
public static final long WOW64_CONTEXT_EXTENDED_REGISTERS =    (WOW64_CONTEXT_i386 | 0x00000020L); // cpu specific extensions

public static final long WOW64_CONTEXT_FULL =      (WOW64_CONTEXT_CONTROL | WOW64_CONTEXT_INTEGER | WOW64_CONTEXT_SEGMENTS);

public static final long WOW64_CONTEXT_ALL =       (WOW64_CONTEXT_CONTROL | WOW64_CONTEXT_INTEGER | WOW64_CONTEXT_SEGMENTS | 
                                 WOW64_CONTEXT_FLOATING_POINT | WOW64_CONTEXT_DEBUG_REGISTERS | 
                                 WOW64_CONTEXT_EXTENDED_REGISTERS);

public static final long WOW64_CONTEXT_XSTATE =                (WOW64_CONTEXT_i386 | 0x00000040L);

public static final int WOW64_CONTEXT_EXCEPTION_ACTIVE =      0x08000000;
public static final int WOW64_CONTEXT_SERVICE_ACTIVE =        0x10000000;
public static final int WOW64_CONTEXT_EXCEPTION_REQUEST =     0x40000000;
public static final int WOW64_CONTEXT_EXCEPTION_REPORTING =   0x80000000;

// #endif // !defined(RC_INVOKED)

//
//  Define the size of the 80387 save area, which is in the context frame.
//

public static final int WOW64_SIZE_OF_80387_REGISTERS =      80;

public static final int WOW64_MAXIMUM_SUPPORTED_EXTENSION =     512;
// Targeting ..\windows\WOW64_FLOATING_SAVE_AREA.java



// #include "pshpack4.h"
// Targeting ..\windows\WOW64_CONTEXT.java



// #include "poppack.h"
// Targeting ..\windows\WOW64_LDT_ENTRY.java


// Targeting ..\windows\WOW64_DESCRIPTOR_TABLE_ENTRY.java



public static final int EXCEPTION_NONCONTINUABLE = 0x1;    // Noncontinuable exception
public static final int EXCEPTION_UNWINDING = 0x2;         // Unwind is in progress
public static final int EXCEPTION_EXIT_UNWIND = 0x4;       // Exit unwind is in progress
public static final int EXCEPTION_STACK_INVALID = 0x8;     // Stack out of limits or unaligned
public static final int EXCEPTION_NESTED_CALL = 0x10;      // Nested exception handler call
public static final int EXCEPTION_TARGET_UNWIND = 0x20;    // Target unwind in progress
public static final int EXCEPTION_COLLIDED_UNWIND = 0x40;  // Collided exception handler call

public static final int EXCEPTION_UNWIND = (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND | 
                          EXCEPTION_TARGET_UNWIND | EXCEPTION_COLLIDED_UNWIND);

// #define IS_UNWINDING(Flag) ((Flag & EXCEPTION_UNWIND) != 0)
// #define IS_DISPATCHING(Flag) ((Flag & EXCEPTION_UNWIND) == 0)
// #define IS_TARGET_UNWIND(Flag) (Flag & EXCEPTION_TARGET_UNWIND)

public static final int EXCEPTION_MAXIMUM_PARAMETERS = 15;
// Targeting ..\windows\EXCEPTION_RECORD.java


// Targeting ..\windows\EXCEPTION_RECORD32.java


// Targeting ..\windows\EXCEPTION_RECORD64.java


// Targeting ..\windows\EXCEPTION_POINTERS.java



// end_ntoshvp
// end_wdm


// #if defined(_IA64_)

// #endif     
////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             ACCESS MASK                            //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  Define the access mask as a longword sized structure divided up as
//  follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+---------------+-------------------------------+
//      |G|G|G|G|Res'd|A| StandardRights|         SpecificRights        |
//      |R|W|E|A|     |S|               |                               |
//      +-+-------------+---------------+-------------------------------+
//
//      typedef struct _ACCESS_MASK {
//          WORD   SpecificRights;
//          BYTE  StandardRights;
//          BYTE  AccessSystemAcl : 1;
//          BYTE  Reserved : 3;
//          BYTE  GenericAll : 1;
//          BYTE  GenericExecute : 1;
//          BYTE  GenericWrite : 1;
//          BYTE  GenericRead : 1;
//      } ACCESS_MASK;
//      typedef ACCESS_MASK *PACCESS_MASK;
//
//  but to make life simple for programmer's we'll allow them to specify
//  a desired access mask by simply OR'ing together mulitple single rights
//  and treat an access mask as a DWORD.  For example
//
//      DesiredAccess = DELETE | READ_CONTROL
//
//  So we'll declare ACCESS_MASK as DWORD
//

// begin_wdm
// begin_ntoshvp

// end_ntoshvp
////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             ACCESS TYPES                           //
//                                                                    //
////////////////////////////////////////////////////////////////////////


// begin_wdm
//
//  The following are masks for the predefined standard access types
//

public static final long DELETE =                           (0x00010000L);
public static final long READ_CONTROL =                     (0x00020000L);
public static final long WRITE_DAC =                        (0x00040000L);
public static final long WRITE_OWNER =                      (0x00080000L);
public static final long SYNCHRONIZE =                      (0x00100000L);

public static final long STANDARD_RIGHTS_REQUIRED =         (0x000F0000L);

public static final long STANDARD_RIGHTS_READ =             (READ_CONTROL);
public static final long STANDARD_RIGHTS_WRITE =            (READ_CONTROL);
public static final long STANDARD_RIGHTS_EXECUTE =          (READ_CONTROL);

public static final long STANDARD_RIGHTS_ALL =              (0x001F0000L);

public static final long SPECIFIC_RIGHTS_ALL =              (0x0000FFFFL);

//
// AccessSystemAcl access type
//

public static final long ACCESS_SYSTEM_SECURITY =           (0x01000000L);

//
// MaximumAllowed access type
//

public static final long MAXIMUM_ALLOWED =                  (0x02000000L);

//
//  These are the generic rights.
//

public static final long GENERIC_READ =                     (0x80000000L);
public static final long GENERIC_WRITE =                    (0x40000000L);
public static final long GENERIC_EXECUTE =                  (0x20000000L);
public static final long GENERIC_ALL =                      (0x10000000L);
// Targeting ..\windows\GENERIC_MAPPING.java





////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        LUID_AND_ATTRIBUTES                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//


// #include <pshpack4.h>
// Targeting ..\windows\LUID_AND_ATTRIBUTES.java



// #include <poppack.h>


////////////////////////////////////////////////////////////////////////
//                                                                    //
//              Security Id     (SID)                                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//
// Pictorially the structure of an SID is as follows:
//
//         1   1   1   1   1   1
//         5   4   3   2   1   0   9   8   7   6   5   4   3   2   1   0
//      +---------------------------------------------------------------+
//      |      SubAuthorityCount        |Reserved1 (SBZ)|   Revision    |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[0]                      |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[1]                      |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[2]                      |
//      +---------------------------------------------------------------+
//      |                                                               |
//      +- -  -  -  -  -  -  -  SubAuthority[]  -  -  -  -  -  -  -  - -+
//      |                                                               |
//      +---------------------------------------------------------------+
//
//


// begin_ntifs

// #ifndef SID_IDENTIFIER_AUTHORITY_DEFINED
// #define SID_IDENTIFIER_AUTHORITY_DEFINED
// Targeting ..\windows\SID_IDENTIFIER_AUTHORITY.java


// #endif


// #ifndef SID_DEFINED
// #define SID_DEFINED
// Targeting ..\windows\SID.java


// #endif

public static final int SID_REVISION =                     (1);    // Current revision level
public static final int SID_MAX_SUB_AUTHORITIES =          (15);
public static final int SID_RECOMMENDED_SUB_AUTHORITIES =  (1);    // Will change to around 6

                                                // in a future release.
// #ifndef MIDL_PASS
public static native @MemberGetter int SECURITY_MAX_SID_SIZE();
public static final int SECURITY_MAX_SID_SIZE = SECURITY_MAX_SID_SIZE();
// #endif // MIDL_PASS


/** enum SID_NAME_USE */
public static final int
    SidTypeUser = 1,
    SidTypeGroup = 2,
    SidTypeDomain = 3,
    SidTypeAlias = 4,
    SidTypeWellKnownGroup = 5,
    SidTypeDeletedAccount = 6,
    SidTypeInvalid = 7,
    SidTypeUnknown = 8,
    SidTypeComputer = 9,
    SidTypeLabel = 10;
// Targeting ..\windows\SID_AND_ATTRIBUTES.java



public static final int SID_HASH_SIZE = 32;
// Targeting ..\windows\SID_AND_ATTRIBUTES_HASH.java




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Universal well-known SIDs                                               //
//                                                                         //
//     Null SID                     S-1-0-0                                //
//     World                        S-1-1-0                                //
//     Local                        S-1-2-0                                //
//     Creator Owner ID             S-1-3-0                                //
//     Creator Group ID             S-1-3-1                                //
//     Creator Owner Server ID      S-1-3-2                                //
//     Creator Group Server ID      S-1-3-3                                //
//                                                                         //
//     (Non-unique IDs)             S-1-4                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

public static native @MemberGetter @Cast("BYTE*") @StdVector BytePointer SECURITY_NULL_SID_AUTHORITY();
public static final BytePointer SECURITY_NULL_SID_AUTHORITY = SECURITY_NULL_SID_AUTHORITY();
public static native @MemberGetter @Cast("BYTE*") @StdVector BytePointer SECURITY_WORLD_SID_AUTHORITY();
public static final BytePointer SECURITY_WORLD_SID_AUTHORITY = SECURITY_WORLD_SID_AUTHORITY();
public static native @MemberGetter @Cast("BYTE*") @StdVector BytePointer SECURITY_LOCAL_SID_AUTHORITY();
public static final BytePointer SECURITY_LOCAL_SID_AUTHORITY = SECURITY_LOCAL_SID_AUTHORITY();
public static native @MemberGetter @Cast("BYTE*") @StdVector BytePointer SECURITY_CREATOR_SID_AUTHORITY();
public static final BytePointer SECURITY_CREATOR_SID_AUTHORITY = SECURITY_CREATOR_SID_AUTHORITY();
public static native @MemberGetter @Cast("BYTE*") @StdVector BytePointer SECURITY_NON_UNIQUE_AUTHORITY();
public static final BytePointer SECURITY_NON_UNIQUE_AUTHORITY = SECURITY_NON_UNIQUE_AUTHORITY();
public static native @MemberGetter @Cast("BYTE*") @StdVector BytePointer SECURITY_RESOURCE_MANAGER_AUTHORITY();
public static final BytePointer SECURITY_RESOURCE_MANAGER_AUTHORITY = SECURITY_RESOURCE_MANAGER_AUTHORITY();


public static final long SECURITY_NULL_RID =                 (0x00000000L);
public static final long SECURITY_WORLD_RID =                (0x00000000L);
public static final long SECURITY_LOCAL_RID =                (0x00000000L);
public static final long SECURITY_LOCAL_LOGON_RID =          (0x00000001L);

public static final long SECURITY_CREATOR_OWNER_RID =        (0x00000000L);
public static final long SECURITY_CREATOR_GROUP_RID =        (0x00000001L);

public static final long SECURITY_CREATOR_OWNER_SERVER_RID = (0x00000002L);
public static final long SECURITY_CREATOR_GROUP_SERVER_RID = (0x00000003L);

public static final long SECURITY_CREATOR_OWNER_RIGHTS_RID = (0x00000004L);

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// NT well-known SIDs                                                        //
//                                                                           //
//     NT Authority            S-1-5                                         //
//     Dialup                  S-1-5-1                                       //
//                                                                           //
//     Network                 S-1-5-2                                       //
//     Batch                   S-1-5-3                                       //
//     Interactive             S-1-5-4                                       //
//     (Logon IDs)             S-1-5-5-X-Y                                   //
//     Service                 S-1-5-6                                       //
//     AnonymousLogon          S-1-5-7       (aka null logon session)        //
//     Proxy                   S-1-5-8                                       //
//     Enterprise DC (EDC)     S-1-5-9       (aka domain controller account) //
//     Self                    S-1-5-10      (self RID)                      //
//     Authenticated User      S-1-5-11      (Authenticated user somewhere)  //
//     Restricted Code         S-1-5-12      (Running restricted code)       //
//     Terminal Server         S-1-5-13      (Running on Terminal Server)    //
//     Remote Logon            S-1-5-14      (Remote Interactive Logon)      //
//     This Organization       S-1-5-15                                      //
//                                                                           //
//     IUser                   S-1-5-17
//     Local System            S-1-5-18                                      //
//     Local Service           S-1-5-19                                      //
//     Network Service         S-1-5-20                                      //
//                                                                           //
//     (NT non-unique IDs)     S-1-5-0x15-... (NT Domain Sids)               //
//                                                                           //
//     (Built-in domain)       S-1-5-0x20                                    //
//                                                                           //
//     (Security Package IDs)  S-1-5-0x40                                    //
//     NTLM Authentication     S-1-5-0x40-10                                 //
//     SChannel Authentication S-1-5-0x40-14                                 //
//     Digest Authentication   S-1-5-0x40-21                                 //
//                                                                           //
//     Other Organization      S-1-5-1000    (>=1000 can not be filtered)    //
//                                                                           //
//                                                                           //
// NOTE: the relative identifier values (RIDs) determine which security      //
//       boundaries the SID is allowed to cross.  Before adding new RIDs,    //
//       a determination needs to be made regarding which range they should  //
//       be added to in order to ensure proper "SID filtering"               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


public static native @MemberGetter @Cast("BYTE*") @StdVector BytePointer SECURITY_NT_AUTHORITY();
public static final BytePointer SECURITY_NT_AUTHORITY = SECURITY_NT_AUTHORITY();   // ntifs

public static final long SECURITY_DIALUP_RID =             (0x00000001L);
public static final long SECURITY_NETWORK_RID =            (0x00000002L);
public static final long SECURITY_BATCH_RID =              (0x00000003L);
public static final long SECURITY_INTERACTIVE_RID =        (0x00000004L);
public static final long SECURITY_LOGON_IDS_RID =          (0x00000005L);
public static final long SECURITY_LOGON_IDS_RID_COUNT =    (3L);
public static final long SECURITY_SERVICE_RID =            (0x00000006L);
public static final long SECURITY_ANONYMOUS_LOGON_RID =    (0x00000007L);
public static final long SECURITY_PROXY_RID =              (0x00000008L);
public static final long SECURITY_ENTERPRISE_CONTROLLERS_RID = (0x00000009L);
public static final long SECURITY_SERVER_LOGON_RID =       SECURITY_ENTERPRISE_CONTROLLERS_RID;
public static final long SECURITY_PRINCIPAL_SELF_RID =     (0x0000000AL);
public static final long SECURITY_AUTHENTICATED_USER_RID = (0x0000000BL);
public static final long SECURITY_RESTRICTED_CODE_RID =    (0x0000000CL);
public static final long SECURITY_TERMINAL_SERVER_RID =    (0x0000000DL);
public static final long SECURITY_REMOTE_LOGON_RID =       (0x0000000EL);
public static final long SECURITY_THIS_ORGANIZATION_RID =  (0x0000000FL);
public static final long SECURITY_IUSER_RID =              (0x00000011L);
public static final long SECURITY_LOCAL_SYSTEM_RID =       (0x00000012L);
public static final long SECURITY_LOCAL_SERVICE_RID =      (0x00000013L);
public static final long SECURITY_NETWORK_SERVICE_RID =    (0x00000014L);

public static final long SECURITY_NT_NON_UNIQUE =          (0x00000015L);
public static final long SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT =  (3L);

public static final long SECURITY_ENTERPRISE_READONLY_CONTROLLERS_RID = (0x00000016L);

public static final long SECURITY_BUILTIN_DOMAIN_RID =     (0x00000020L);
public static final long SECURITY_WRITE_RESTRICTED_CODE_RID = (0x00000021L);


public static final long SECURITY_PACKAGE_BASE_RID =       (0x00000040L);
public static final long SECURITY_PACKAGE_RID_COUNT =      (2L);
public static final long SECURITY_PACKAGE_NTLM_RID =       (0x0000000AL);
public static final long SECURITY_PACKAGE_SCHANNEL_RID =   (0x0000000EL);
public static final long SECURITY_PACKAGE_DIGEST_RID =     (0x00000015L);

public static final long SECURITY_CRED_TYPE_BASE_RID =             (0x00000041L);
public static final long SECURITY_CRED_TYPE_RID_COUNT =            (2L);
public static final long SECURITY_CRED_TYPE_THIS_ORG_CERT_RID =    (0x00000001L);

public static final long SECURITY_MIN_BASE_RID =           (0x00000050L);

public static final long SECURITY_SERVICE_ID_BASE_RID =    (0x00000050L);
public static final long SECURITY_SERVICE_ID_RID_COUNT =   (6L);

public static final long SECURITY_RESERVED_ID_BASE_RID =   (0x00000051L);

public static final long SECURITY_APPPOOL_ID_BASE_RID =    (0x00000052L);
public static final long SECURITY_APPPOOL_ID_RID_COUNT =   (6L);

public static final long SECURITY_VIRTUALSERVER_ID_BASE_RID =    (0x00000053L);
public static final long SECURITY_VIRTUALSERVER_ID_RID_COUNT =   (6L);

public static final long SECURITY_USERMODEDRIVERHOST_ID_BASE_RID =  (0x00000054L);
public static final long SECURITY_USERMODEDRIVERHOST_ID_RID_COUNT = (6L);

public static final long SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_BASE_RID =  (0x00000055L);
public static final long SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_RID_COUNT = (6L);

public static final long SECURITY_WMIHOST_ID_BASE_RID =  (0x00000056L);
public static final long SECURITY_WMIHOST_ID_RID_COUNT = (6L);

public static final long SECURITY_TASK_ID_BASE_RID =                 (0x00000057L);

public static final long SECURITY_NFS_ID_BASE_RID =        (0x00000058L);

public static final long SECURITY_COM_ID_BASE_RID =        (0x00000059L);

public static final long SECURITY_WINDOW_MANAGER_BASE_RID =     (0x0000005AL);

public static final long SECURITY_RDV_GFX_BASE_RID =       (0x0000005BL);

public static final long SECURITY_DASHOST_ID_BASE_RID =    (0x0000005CL);
public static final long SECURITY_DASHOST_ID_RID_COUNT =   (6L);

public static final long SECURITY_VIRTUALACCOUNT_ID_RID_COUNT =   (6L);

public static final long SECURITY_MAX_BASE_RID =           (0x0000006FL);
public static final long SECURITY_MAX_ALWAYS_FILTERED =    (0x000003E7L);
public static final long SECURITY_MIN_NEVER_FILTERED =     (0x000003E8L);

public static final long SECURITY_OTHER_ORGANIZATION_RID = (0x000003E8L);

//
//Service SID type RIDs are in the range 0x50- 0x6F.  Therefore, we are giving  the next available RID to Windows Mobile team.
//
public static final long SECURITY_WINDOWSMOBILE_ID_BASE_RID = (0x00000070L);

//
//Well-known group for local accounts
//
public static final long SECURITY_LOCAL_ACCOUNT_RID = (0x00000071L);
public static final long SECURITY_LOCAL_ACCOUNT_AND_ADMIN_RID = (0x00000072L);

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// well-known domain relative sub-authority values (RIDs)...               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


public static final long DOMAIN_GROUP_RID_AUTHORIZATION_DATA_IS_COMPOUNDED =       (0x000001F0L);
public static final long DOMAIN_GROUP_RID_AUTHORIZATION_DATA_CONTAINS_CLAIMS =     (0x000001F1L);
public static final long DOMAIN_GROUP_RID_ENTERPRISE_READONLY_DOMAIN_CONTROLLERS = (0x000001F2L);

public static final long FOREST_USER_RID_MAX =            (0x000001F3L);

// Well-known users ...

public static final long DOMAIN_USER_RID_ADMIN =          (0x000001F4L);
public static final long DOMAIN_USER_RID_GUEST =          (0x000001F5L);
public static final long DOMAIN_USER_RID_KRBTGT =         (0x000001F6L);

public static final long DOMAIN_USER_RID_MAX =            (0x000003E7L);


// well-known groups ...

public static final long DOMAIN_GROUP_RID_ADMINS =        (0x00000200L);
public static final long DOMAIN_GROUP_RID_USERS =         (0x00000201L);
public static final long DOMAIN_GROUP_RID_GUESTS =        (0x00000202L);
public static final long DOMAIN_GROUP_RID_COMPUTERS =     (0x00000203L);
public static final long DOMAIN_GROUP_RID_CONTROLLERS =   (0x00000204L);
public static final long DOMAIN_GROUP_RID_CERT_ADMINS =   (0x00000205L);
public static final long DOMAIN_GROUP_RID_SCHEMA_ADMINS = (0x00000206L);
public static final long DOMAIN_GROUP_RID_ENTERPRISE_ADMINS = (0x00000207L);
public static final long DOMAIN_GROUP_RID_POLICY_ADMINS = (0x00000208L);
public static final long DOMAIN_GROUP_RID_READONLY_CONTROLLERS = (0x00000209L);
public static final long DOMAIN_GROUP_RID_CLONEABLE_CONTROLLERS = (0x0000020AL);
public static final long DOMAIN_GROUP_RID_CDC_RESERVED =    (0x0000020CL);
public static final long DOMAIN_GROUP_RID_PROTECTED_USERS = (0x0000020DL);

// well-known aliases ...

public static final long DOMAIN_ALIAS_RID_ADMINS =                         (0x00000220L);
public static final long DOMAIN_ALIAS_RID_USERS =                          (0x00000221L);
public static final long DOMAIN_ALIAS_RID_GUESTS =                         (0x00000222L);
public static final long DOMAIN_ALIAS_RID_POWER_USERS =                    (0x00000223L);

public static final long DOMAIN_ALIAS_RID_ACCOUNT_OPS =                    (0x00000224L);
public static final long DOMAIN_ALIAS_RID_SYSTEM_OPS =                     (0x00000225L);
public static final long DOMAIN_ALIAS_RID_PRINT_OPS =                      (0x00000226L);
public static final long DOMAIN_ALIAS_RID_BACKUP_OPS =                     (0x00000227L);

public static final long DOMAIN_ALIAS_RID_REPLICATOR =                     (0x00000228L);
public static final long DOMAIN_ALIAS_RID_RAS_SERVERS =                    (0x00000229L);
public static final long DOMAIN_ALIAS_RID_PREW2KCOMPACCESS =               (0x0000022AL);
public static final long DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS =           (0x0000022BL);
public static final long DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS =      (0x0000022CL);
public static final long DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS = (0x0000022DL);

public static final long DOMAIN_ALIAS_RID_MONITORING_USERS =               (0x0000022EL);
public static final long DOMAIN_ALIAS_RID_LOGGING_USERS =                  (0x0000022FL);
public static final long DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS =            (0x00000230L);
public static final long DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS =             (0x00000231L);
public static final long DOMAIN_ALIAS_RID_DCOM_USERS =                     (0x00000232L);
public static final long DOMAIN_ALIAS_RID_IUSERS =                         (0x00000238L);
public static final long DOMAIN_ALIAS_RID_CRYPTO_OPERATORS =               (0x00000239L);
public static final long DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP =     (0x0000023BL);
public static final long DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP = (0x0000023CL);
public static final long DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP =        (0x0000023DL);
public static final long DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP =      (0x0000023EL);
public static final long DOMAIN_ALIAS_RID_RDS_REMOTE_ACCESS_SERVERS =      (0x0000023FL);
public static final long DOMAIN_ALIAS_RID_RDS_ENDPOINT_SERVERS =           (0x00000240L);
public static final long DOMAIN_ALIAS_RID_RDS_MANAGEMENT_SERVERS =         (0x00000241L);
public static final long DOMAIN_ALIAS_RID_HYPER_V_ADMINS =                 (0x00000242L);
public static final long DOMAIN_ALIAS_RID_ACCESS_CONTROL_ASSISTANCE_OPS =  (0x00000243L);
public static final long DOMAIN_ALIAS_RID_REMOTE_MANAGEMENT_USERS =        (0x00000244L);

//
// Application Package Authority.
//

public static native @MemberGetter @Cast("BYTE*") @StdVector BytePointer SECURITY_APP_PACKAGE_AUTHORITY();
public static final BytePointer SECURITY_APP_PACKAGE_AUTHORITY = SECURITY_APP_PACKAGE_AUTHORITY();

public static final long SECURITY_APP_PACKAGE_BASE_RID =               (0x00000002L);
public static final long SECURITY_BUILTIN_APP_PACKAGE_RID_COUNT =      (2L);
public static final long SECURITY_APP_PACKAGE_RID_COUNT =              (8L);
public static final long SECURITY_CAPABILITY_BASE_RID =                (0x00000003L);
public static final long SECURITY_BUILTIN_CAPABILITY_RID_COUNT =       (2L);
public static final long SECURITY_CAPABILITY_RID_COUNT =               (5L);
public static final long SECURITY_PARENT_PACKAGE_RID_COUNT =           (SECURITY_APP_PACKAGE_RID_COUNT);
public static final long SECURITY_CHILD_PACKAGE_RID_COUNT =            (12L);

//
// Built-in Packages.
//

public static final long SECURITY_BUILTIN_PACKAGE_ANY_PACKAGE =        (0x00000001L);

//
// Built-in Capabilities.
//

public static final long SECURITY_CAPABILITY_INTERNET_CLIENT =                     (0x00000001L);
public static final long SECURITY_CAPABILITY_INTERNET_CLIENT_SERVER =              (0x00000002L);
public static final long SECURITY_CAPABILITY_PRIVATE_NETWORK_CLIENT_SERVER =       (0x00000003L);
public static final long SECURITY_CAPABILITY_PICTURES_LIBRARY =                    (0x00000004L);
public static final long SECURITY_CAPABILITY_VIDEOS_LIBRARY =                      (0x00000005L);
public static final long SECURITY_CAPABILITY_MUSIC_LIBRARY =                       (0x00000006L);
public static final long SECURITY_CAPABILITY_DOCUMENTS_LIBRARY =                   (0x00000007L);
public static final long SECURITY_CAPABILITY_ENTERPRISE_AUTHENTICATION =           (0x00000008L);
public static final long SECURITY_CAPABILITY_SHARED_USER_CERTIFICATES =            (0x00000009L);
public static final long SECURITY_CAPABILITY_REMOVABLE_STORAGE =                   (0x0000000AL);

public static final long SECURITY_CAPABILITY_INTERNET_EXPLORER =                   (0x00001000L);

//
// Mandatory Label Authority.
//

public static native @MemberGetter @Cast("BYTE*") @StdVector BytePointer SECURITY_MANDATORY_LABEL_AUTHORITY();
public static final BytePointer SECURITY_MANDATORY_LABEL_AUTHORITY = SECURITY_MANDATORY_LABEL_AUTHORITY();
public static final long SECURITY_MANDATORY_UNTRUSTED_RID =            (0x00000000L);
public static final long SECURITY_MANDATORY_LOW_RID =                  (0x00001000L);
public static final long SECURITY_MANDATORY_MEDIUM_RID =               (0x00002000L);
public static final long SECURITY_MANDATORY_MEDIUM_PLUS_RID =          (SECURITY_MANDATORY_MEDIUM_RID + 0x100);
public static final long SECURITY_MANDATORY_HIGH_RID =                 (0x00003000L);
public static final long SECURITY_MANDATORY_SYSTEM_RID =               (0x00004000L);
public static final long SECURITY_MANDATORY_PROTECTED_PROCESS_RID =    (0x00005000L);

//
// SECURITY_MANDATORY_MAXIMUM_USER_RID is the highest RID that
// can be set by a usermode caller.
//

public static final long SECURITY_MANDATORY_MAXIMUM_USER_RID =   SECURITY_MANDATORY_SYSTEM_RID;

// #define MANDATORY_LEVEL_TO_MANDATORY_RID(IL) (IL * 0x1000)

public static native @MemberGetter @Cast("BYTE*") @StdVector BytePointer SECURITY_SCOPED_POLICY_ID_AUTHORITY();
public static final BytePointer SECURITY_SCOPED_POLICY_ID_AUTHORITY = SECURITY_SCOPED_POLICY_ID_AUTHORITY();

//
// Authentication Authority
//

public static native @MemberGetter @Cast("BYTE*") @StdVector BytePointer SECURITY_AUTHENTICATION_AUTHORITY();
public static final BytePointer SECURITY_AUTHENTICATION_AUTHORITY = SECURITY_AUTHENTICATION_AUTHORITY();
public static final long SECURITY_AUTHENTICATION_AUTHORITY_RID_COUNT =        (1L);
public static final long SECURITY_AUTHENTICATION_AUTHORITY_ASSERTED_RID =     (0x00000001L);
public static final long SECURITY_AUTHENTICATION_SERVICE_ASSERTED_RID =       (0x00000002L);

//
// Process Trust Authority
//

public static native @MemberGetter @Cast("BYTE*") @StdVector BytePointer SECURITY_PROCESS_TRUST_AUTHORITY();
public static final BytePointer SECURITY_PROCESS_TRUST_AUTHORITY = SECURITY_PROCESS_TRUST_AUTHORITY();
public static final long SECURITY_PROCESS_TRUST_AUTHORITY_RID_COUNT = (2L);

public static final long SECURITY_PROCESS_PROTECTION_TYPE_FULL_RID =           (0x00000400L);
public static final long SECURITY_PROCESS_PROTECTION_TYPE_LITE_RID =           (0x00000200L);
public static final long SECURITY_PROCESS_PROTECTION_TYPE_NONE_RID =           (0x00000000L);

public static final long SECURITY_PROCESS_PROTECTION_LEVEL_WINTCB_RID =        (0x00002000L);
public static final long SECURITY_PROCESS_PROTECTION_LEVEL_WINDOWS_RID =       (0x00001000L);
public static final long SECURITY_PROCESS_PROTECTION_LEVEL_NONE_RID =          (0x00000000L);

//
// Trusted Installer RIDs
//

public static final int SECURITY_TRUSTED_INSTALLER_RID1 = 956008885;
public static final int SECURITY_TRUSTED_INSTALLER_RID2 = (int)3418522649L;
public static final int SECURITY_TRUSTED_INSTALLER_RID3 = 1831038044;
public static final int SECURITY_TRUSTED_INSTALLER_RID4 = 1853292631;
public static final int SECURITY_TRUSTED_INSTALLER_RID5 = (int)2271478464L;





//
// Well known SID definitions for lookup.
//

/** enum WELL_KNOWN_SID_TYPE */
public static final int

    WinNullSid                                  = 0,
    WinWorldSid                                 = 1,
    WinLocalSid                                 = 2,
    WinCreatorOwnerSid                          = 3,
    WinCreatorGroupSid                          = 4,
    WinCreatorOwnerServerSid                    = 5,
    WinCreatorGroupServerSid                    = 6,
    WinNtAuthoritySid                           = 7,
    WinDialupSid                                = 8,
    WinNetworkSid                               = 9,
    WinBatchSid                                 = 10,
    WinInteractiveSid                           = 11,
    WinServiceSid                               = 12,
    WinAnonymousSid                             = 13,
    WinProxySid                                 = 14,
    WinEnterpriseControllersSid                 = 15,
    WinSelfSid                                  = 16,
    WinAuthenticatedUserSid                     = 17,
    WinRestrictedCodeSid                        = 18,
    WinTerminalServerSid                        = 19,
    WinRemoteLogonIdSid                         = 20,
    WinLogonIdsSid                              = 21,
    WinLocalSystemSid                           = 22,
    WinLocalServiceSid                          = 23,
    WinNetworkServiceSid                        = 24,
    WinBuiltinDomainSid                         = 25,
    WinBuiltinAdministratorsSid                 = 26,
    WinBuiltinUsersSid                          = 27,
    WinBuiltinGuestsSid                         = 28,
    WinBuiltinPowerUsersSid                     = 29,
    WinBuiltinAccountOperatorsSid               = 30,
    WinBuiltinSystemOperatorsSid                = 31,
    WinBuiltinPrintOperatorsSid                 = 32,
    WinBuiltinBackupOperatorsSid                = 33,
    WinBuiltinReplicatorSid                     = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid             = 36,
    WinBuiltinNetworkConfigurationOperatorsSid  = 37,
    WinAccountAdministratorSid                  = 38,
    WinAccountGuestSid                          = 39,
    WinAccountKrbtgtSid                         = 40,
    WinAccountDomainAdminsSid                   = 41,
    WinAccountDomainUsersSid                    = 42,
    WinAccountDomainGuestsSid                   = 43,
    WinAccountComputersSid                      = 44,
    WinAccountControllersSid                    = 45,
    WinAccountCertAdminsSid                     = 46,
    WinAccountSchemaAdminsSid                   = 47,
    WinAccountEnterpriseAdminsSid               = 48,
    WinAccountPolicyAdminsSid                   = 49,
    WinAccountRasAndIasServersSid               = 50,
    WinNTLMAuthenticationSid                    = 51,
    WinDigestAuthenticationSid                  = 52,
    WinSChannelAuthenticationSid                = 53,
    WinThisOrganizationSid                      = 54,
    WinOtherOrganizationSid                     = 55,
    WinBuiltinIncomingForestTrustBuildersSid    = 56,
    WinBuiltinPerfMonitoringUsersSid            = 57,
    WinBuiltinPerfLoggingUsersSid               = 58,
    WinBuiltinAuthorizationAccessSid            = 59,
    WinBuiltinTerminalServerLicenseServersSid   = 60,
    WinBuiltinDCOMUsersSid                      = 61,
    WinBuiltinIUsersSid                         = 62,
    WinIUserSid                                 = 63,
    WinBuiltinCryptoOperatorsSid                = 64,
    WinUntrustedLabelSid                        = 65,
    WinLowLabelSid                              = 66,
    WinMediumLabelSid                           = 67,
    WinHighLabelSid                             = 68,
    WinSystemLabelSid                           = 69,
    WinWriteRestrictedCodeSid                   = 70,
    WinCreatorOwnerRightsSid                    = 71,
    WinCacheablePrincipalsGroupSid              = 72,
    WinNonCacheablePrincipalsGroupSid           = 73,
    WinEnterpriseReadonlyControllersSid         = 74,
    WinAccountReadonlyControllersSid            = 75,
    WinBuiltinEventLogReadersGroup              = 76,
    WinNewEnterpriseReadonlyControllersSid      = 77,
    WinBuiltinCertSvcDComAccessGroup            = 78,
    WinMediumPlusLabelSid                       = 79,
    WinLocalLogonSid                            = 80,
    WinConsoleLogonSid                          = 81,
    WinThisOrganizationCertificateSid           = 82,
    WinApplicationPackageAuthoritySid           = 83,
    WinBuiltinAnyPackageSid                     = 84,
    WinCapabilityInternetClientSid              = 85,
    WinCapabilityInternetClientServerSid        = 86,
    WinCapabilityPrivateNetworkClientServerSid  = 87,
    WinCapabilityPicturesLibrarySid             = 88,
    WinCapabilityVideosLibrarySid               = 89,
    WinCapabilityMusicLibrarySid                = 90,
    WinCapabilityDocumentsLibrarySid            = 91,
    WinCapabilitySharedUserCertificatesSid      = 92,
    WinCapabilityEnterpriseAuthenticationSid    = 93,
    WinCapabilityRemovableStorageSid            = 94,
    WinBuiltinRDSRemoteAccessServersSid         = 95,
    WinBuiltinRDSEndpointServersSid             = 96,
    WinBuiltinRDSManagementServersSid           = 97,
    WinUserModeDriversSid                       = 98,
    WinBuiltinHyperVAdminsSid                   = 99,
    WinAccountCloneableControllersSid           = 100,
    WinBuiltinAccessControlAssistanceOperatorsSid = 101,
    WinBuiltinRemoteManagementUsersSid          = 102,
    WinAuthenticationAuthorityAssertedSid       = 103,
    WinAuthenticationServiceAssertedSid         = 104,
    WinLocalAccountSid                          = 105,
    WinLocalAccountAndAdministratorSid          = 106,
    WinAccountProtectedUsersSid                 = 107;

//
// Allocate the System Luid.  The first 1000 LUIDs are reserved.
// Use #999 here (0x3e7 = 999)
//

public static native @MemberGetter @ByVal LUID SYSTEM_LUID();
public static final LUID SYSTEM_LUID = SYSTEM_LUID();
public static native @MemberGetter @ByVal LUID ANONYMOUS_LOGON_LUID();
public static final LUID ANONYMOUS_LOGON_LUID = ANONYMOUS_LOGON_LUID();
public static native @MemberGetter @ByVal LUID LOCALSERVICE_LUID();
public static final LUID LOCALSERVICE_LUID = LOCALSERVICE_LUID();
public static native @MemberGetter @ByVal LUID NETWORKSERVICE_LUID();
public static final LUID NETWORKSERVICE_LUID = NETWORKSERVICE_LUID();
public static native @MemberGetter @ByVal LUID IUSER_LUID();
public static final LUID IUSER_LUID = IUSER_LUID();

// end_ntifs

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                          User and Group related SID attributes     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
// Group attributes
//

public static final long SE_GROUP_MANDATORY =                 (0x00000001L);
public static final long SE_GROUP_ENABLED_BY_DEFAULT =        (0x00000002L);
public static final long SE_GROUP_ENABLED =                   (0x00000004L);
public static final long SE_GROUP_OWNER =                     (0x00000008L);
public static final long SE_GROUP_USE_FOR_DENY_ONLY =         (0x00000010L);
public static final long SE_GROUP_INTEGRITY =                 (0x00000020L);
public static final long SE_GROUP_INTEGRITY_ENABLED =         (0x00000040L);
public static final long SE_GROUP_LOGON_ID =                  (0xC0000000L);
public static final long SE_GROUP_RESOURCE =                  (0x20000000L);

public static final long SE_GROUP_VALID_ATTRIBUTES =          (SE_GROUP_MANDATORY          | 
                                            SE_GROUP_ENABLED_BY_DEFAULT | 
                                            SE_GROUP_ENABLED            | 
                                            SE_GROUP_OWNER              | 
                                            SE_GROUP_USE_FOR_DENY_ONLY  | 
                                            SE_GROUP_LOGON_ID           | 
                                            SE_GROUP_RESOURCE           | 
                                            SE_GROUP_INTEGRITY          | 
                                            SE_GROUP_INTEGRITY_ENABLED);

//
// User attributes
//

// (None yet defined.)




////////////////////////////////////////////////////////////////////////
//                                                                    //
//                         ACL  and  ACE                              //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  Define an ACL and the ACE format.  The structure of an ACL header
//  followed by one or more ACEs.  Pictorally the structure of an ACL header
//  is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +-------------------------------+---------------+---------------+
//      |            AclSize            |      Sbz1     |  AclRevision  |
//      +-------------------------------+---------------+---------------+
//      |              Sbz2             |           AceCount            |
//      +-------------------------------+-------------------------------+
//
//  The current AclRevision is defined to be ACL_REVISION.
//
//  AclSize is the size, in bytes, allocated for the ACL.  This includes
//  the ACL header, ACES, and remaining free space in the buffer.
//
//  AceCount is the number of ACES in the ACL.
//

// begin_wdm
// This is the *current* ACL revision

public static final int ACL_REVISION =     (2);
public static final int ACL_REVISION_DS =  (4);

// This is the history of ACL revisions.  Add a new one whenever
// ACL_REVISION is updated

public static final int ACL_REVISION1 =   (1);
public static native @MemberGetter int MIN_ACL_REVISION();
public static final int MIN_ACL_REVISION = MIN_ACL_REVISION();
public static final int ACL_REVISION2 =   (2);
public static final int ACL_REVISION3 =   (3);
public static final int ACL_REVISION4 =   (4);
public static final int MAX_ACL_REVISION = ACL_REVISION4;
// Targeting ..\windows\ACL.java


// Targeting ..\windows\ACE_HEADER.java



//
//  The following are the predefined ace types that go into the AceType
//  field of an Ace header.
//

public static final int ACCESS_MIN_MS_ACE_TYPE =                  (0x0);
public static final int ACCESS_ALLOWED_ACE_TYPE =                 (0x0);
public static final int ACCESS_DENIED_ACE_TYPE =                  (0x1);
public static final int SYSTEM_AUDIT_ACE_TYPE =                   (0x2);
public static final int SYSTEM_ALARM_ACE_TYPE =                   (0x3);
public static final int ACCESS_MAX_MS_V2_ACE_TYPE =               (0x3);

public static final int ACCESS_ALLOWED_COMPOUND_ACE_TYPE =        (0x4);
public static final int ACCESS_MAX_MS_V3_ACE_TYPE =               (0x4);

public static final int ACCESS_MIN_MS_OBJECT_ACE_TYPE =           (0x5);
public static final int ACCESS_ALLOWED_OBJECT_ACE_TYPE =          (0x5);
public static final int ACCESS_DENIED_OBJECT_ACE_TYPE =           (0x6);
public static final int SYSTEM_AUDIT_OBJECT_ACE_TYPE =            (0x7);
public static final int SYSTEM_ALARM_OBJECT_ACE_TYPE =            (0x8);
public static final int ACCESS_MAX_MS_OBJECT_ACE_TYPE =           (0x8);

public static final int ACCESS_MAX_MS_V4_ACE_TYPE =               (0x8);
public static final int ACCESS_MAX_MS_ACE_TYPE =                  (0x8);

public static final int ACCESS_ALLOWED_CALLBACK_ACE_TYPE =        (0x9);
public static final int ACCESS_DENIED_CALLBACK_ACE_TYPE =         (0xA);
public static final int ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE = (0xB);
public static final int ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE =  (0xC);
public static final int SYSTEM_AUDIT_CALLBACK_ACE_TYPE =          (0xD);
public static final int SYSTEM_ALARM_CALLBACK_ACE_TYPE =          (0xE);
public static final int SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE =   (0xF);
public static final int SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE =   (0x10);

public static final int SYSTEM_MANDATORY_LABEL_ACE_TYPE =         (0x11);
public static final int SYSTEM_RESOURCE_ATTRIBUTE_ACE_TYPE =      (0x12);
public static final int SYSTEM_SCOPED_POLICY_ID_ACE_TYPE =        (0x13);
public static final int SYSTEM_PROCESS_TRUST_LABEL_ACE_TYPE =     (0x14);
public static final int ACCESS_MAX_MS_V5_ACE_TYPE =               (0x14);


//
//  The following are the inherit flags that go into the AceFlags field
//  of an Ace header.
//

public static final int OBJECT_INHERIT_ACE =                (0x1);
public static final int CONTAINER_INHERIT_ACE =             (0x2);
public static final int NO_PROPAGATE_INHERIT_ACE =          (0x4);
public static final int INHERIT_ONLY_ACE =                  (0x8);
public static final int INHERITED_ACE =                     (0x10);
public static final int VALID_INHERIT_FLAGS =               (0x1F);


//  The following are the currently defined ACE flags that go into the
//  AceFlags field of an ACE header.  Each ACE type has its own set of
//  AceFlags.
//
//  SUCCESSFUL_ACCESS_ACE_FLAG - used only with system audit and alarm ACE
//  types to indicate that a message is generated for successful accesses.
//
//  FAILED_ACCESS_ACE_FLAG - used only with system audit and alarm ACE types
//  to indicate that a message is generated for failed accesses.
//

//
//  SYSTEM_AUDIT and SYSTEM_ALARM AceFlags
//
//  These control the signaling of audit and alarms for success or failure.
//

public static final int SUCCESSFUL_ACCESS_ACE_FLAG =       (0x40);
public static final int FAILED_ACCESS_ACE_FLAG =           (0x80);
// Targeting ..\windows\ACCESS_ALLOWED_ACE.java


// Targeting ..\windows\ACCESS_DENIED_ACE.java


// Targeting ..\windows\SYSTEM_AUDIT_ACE.java


// Targeting ..\windows\SYSTEM_ALARM_ACE.java


// Targeting ..\windows\SYSTEM_RESOURCE_ATTRIBUTE_ACE.java


// Targeting ..\windows\SYSTEM_SCOPED_POLICY_ID_ACE.java


// Targeting ..\windows\SYSTEM_MANDATORY_LABEL_ACE.java


// Targeting ..\windows\SYSTEM_PROCESS_TRUST_LABEL_ACE.java



public static final int SYSTEM_MANDATORY_LABEL_NO_WRITE_UP =         0x1;
public static final int SYSTEM_MANDATORY_LABEL_NO_READ_UP =          0x2;
public static final int SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP =       0x4;

public static final int SYSTEM_MANDATORY_LABEL_VALID_MASK = (SYSTEM_MANDATORY_LABEL_NO_WRITE_UP   | 
                                           SYSTEM_MANDATORY_LABEL_NO_READ_UP    | 
                                           SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP);

// Placeholder value that allows all ranges
public static final int SYSTEM_PROCESS_TRUST_LABEL_VALID_MASK =      0x00ffffff;
public static final int SYSTEM_PROCESS_TRUST_NOCONSTRAINT_MASK =     0xffffffff;
// Targeting ..\windows\ACCESS_ALLOWED_OBJECT_ACE.java


// Targeting ..\windows\ACCESS_DENIED_OBJECT_ACE.java


// Targeting ..\windows\SYSTEM_AUDIT_OBJECT_ACE.java


// Targeting ..\windows\SYSTEM_ALARM_OBJECT_ACE.java


// Targeting ..\windows\ACCESS_ALLOWED_CALLBACK_ACE.java


// Targeting ..\windows\ACCESS_DENIED_CALLBACK_ACE.java


// Targeting ..\windows\SYSTEM_AUDIT_CALLBACK_ACE.java


// Targeting ..\windows\SYSTEM_ALARM_CALLBACK_ACE.java


// Targeting ..\windows\ACCESS_ALLOWED_CALLBACK_OBJECT_ACE.java


// Targeting ..\windows\ACCESS_DENIED_CALLBACK_OBJECT_ACE.java


// Targeting ..\windows\SYSTEM_AUDIT_CALLBACK_OBJECT_ACE.java


// Targeting ..\windows\SYSTEM_ALARM_CALLBACK_OBJECT_ACE.java



//
// Currently define Flags for "OBJECT" ACE types.
//

public static final int ACE_OBJECT_TYPE_PRESENT =           0x1;
public static final int ACE_INHERITED_OBJECT_TYPE_PRESENT = 0x2;


//
//  The following declarations are used for setting and querying information
//  about and ACL.  First are the various information classes available to
//  the user.
//

/** enum ACL_INFORMATION_CLASS */
public static final int
    AclRevisionInformation = 1,
    AclSizeInformation = 2;
// Targeting ..\windows\ACL_REVISION_INFORMATION.java


// Targeting ..\windows\ACL_SIZE_INFORMATION.java




////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             SECURITY_DESCRIPTOR                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//  Define the Security Descriptor and related data types.
//  This is an opaque data structure.
//

// begin_wdm
//
// Current security descriptor revision value
//

public static final int SECURITY_DESCRIPTOR_REVISION =     (1);
public static final int SECURITY_DESCRIPTOR_REVISION1 =    (1);

// end_wdm
// begin_ntifs

public static native @MemberGetter int SECURITY_DESCRIPTOR_MIN_LENGTH();
public static final int SECURITY_DESCRIPTOR_MIN_LENGTH = SECURITY_DESCRIPTOR_MIN_LENGTH();

public static final int SE_OWNER_DEFAULTED =               (0x0001);
public static final int SE_GROUP_DEFAULTED =               (0x0002);
public static final int SE_DACL_PRESENT =                  (0x0004);
public static final int SE_DACL_DEFAULTED =                (0x0008);
public static final int SE_SACL_PRESENT =                  (0x0010);
public static final int SE_SACL_DEFAULTED =                (0x0020);
public static final int SE_DACL_AUTO_INHERIT_REQ =         (0x0100);
public static final int SE_SACL_AUTO_INHERIT_REQ =         (0x0200);
public static final int SE_DACL_AUTO_INHERITED =           (0x0400);
public static final int SE_SACL_AUTO_INHERITED =           (0x0800);
public static final int SE_DACL_PROTECTED =                (0x1000);
public static final int SE_SACL_PROTECTED =                (0x2000);
public static final int SE_RM_CONTROL_VALID =              (0x4000);
public static final int SE_SELF_RELATIVE =                 (0x8000);
// Targeting ..\windows\SECURITY_DESCRIPTOR_RELATIVE.java


// Targeting ..\windows\SECURITY_DESCRIPTOR.java


// Targeting ..\windows\SECURITY_OBJECT_AI_PARAMS.java


// Targeting ..\windows\OBJECT_TYPE_LIST.java



//
// DS values for Level
//

public static final int ACCESS_OBJECT_GUID =       0;
public static final int ACCESS_PROPERTY_SET_GUID = 1;
public static final int ACCESS_PROPERTY_GUID =     2;

public static final int ACCESS_MAX_LEVEL =         4;

//
// Parameters to NtAccessCheckByTypeAndAditAlarm
//

/** enum AUDIT_EVENT_TYPE */
public static final int
    AuditEventObjectAccess = 0,
    AuditEventDirectoryServiceAccess = 1;

public static final int AUDIT_ALLOW_NO_PRIVILEGE = 0x1;

//
// DS values for Source and ObjectTypeName
//

public static final String ACCESS_DS_SOURCE_A = "DS";
public static final String ACCESS_DS_SOURCE_W = "DS";
public static final String ACCESS_DS_OBJECT_TYPE_NAME_A = "Directory Service Object";
public static final String ACCESS_DS_OBJECT_TYPE_NAME_W = "Directory Service Object";

////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Privilege Related Data Structures                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////

// end_ntifs
// begin_wdm
//
// Privilege attributes
//

public static final long SE_PRIVILEGE_ENABLED_BY_DEFAULT = (0x00000001L);
public static final long SE_PRIVILEGE_ENABLED =            (0x00000002L);
public static final long SE_PRIVILEGE_REMOVED =            (0X00000004L);
public static final long SE_PRIVILEGE_USED_FOR_ACCESS =    (0x80000000L);

public static final long SE_PRIVILEGE_VALID_ATTRIBUTES =   (SE_PRIVILEGE_ENABLED_BY_DEFAULT | 
                                         SE_PRIVILEGE_ENABLED            | 
                                         SE_PRIVILEGE_REMOVED            | 
                                         SE_PRIVILEGE_USED_FOR_ACCESS);


//
// Privilege Set Control flags
//

public static final int PRIVILEGE_SET_ALL_NECESSARY =    (1);
// Targeting ..\windows\PRIVILEGE_SET.java






//
// Values for different access granted\denied reasons:
// AccessReasonAceN = AccessReasonAce + N.
// AccessReasonPrivilegeN = AccessReasonPrivilege + N.
//

public static final int ACCESS_REASON_TYPE_MASK = 0x00ff0000;
public static final int ACCESS_REASON_DATA_MASK = 0x0000ffff;

public static final int ACCESS_REASON_STAGING_MASK =  0x80000000;
public static final int ACCESS_REASON_EXDATA_MASK =   0x7f000000;

/** enum ACCESS_REASON_TYPE */
public static final int

    AccessReasonNone                    = 0x00000000,   // Indicate no reason for the bit. The bit may not be checked, or just no known reason.

    //
    // The lowest 2 bytes store the index of the ACE that grant/deny this bit.
    // If the corresponding access mask is zero, then it is deny ACE; otherwise,
    // it is allow ACE.
    //
    AccessReasonAllowedAce                  = 0x00010000,   // Granted a permission.
    AccessReasonDeniedAce                   = 0x00020000,   // Denied a permission.

    AccessReasonAllowedParentAce            = 0x00030000,   // Granted a permission from parent ACE
    AccessReasonDeniedParentAce             = 0x00040000,   // Denied a permission from parent ACE

    AccessReasonNotGrantedByCape            = 0x00050000,   // A CAPE didn't grant the permission
    AccessReasonNotGrantedByParentCape      = 0x00060000,   // A CAPE from the parent's SD didn't grant the permission

    AccessReasonNotGrantedToAppContainer    = 0x00070000,   // This is an AppContainer and no ACE granted the permission.

    AccessReasonMissingPrivilege            = 0x00100000,
    AccessReasonFromPrivilege               = 0x00200000,


    AccessReasonIntegrityLevel              = 0x00300000,

    AccessReasonOwnership                   = 0x00400000,

    AccessReasonNullDacl                    = 0x00500000,
    AccessReasonEmptyDacl                   = 0x00600000,

    AccessReasonNoSD                        = 0x00700000,
    AccessReasonNoGrant                     = 0x00800000,   // this access bit is not granted by any ACE.

    AccessReasonTrustLabel                  = 0x00900000;    // The trust label ACE did not grant this access.

 //
// Structure to hold access denied\granted reason for every bit of ACCESS_MASK.
// There are 32-bits in ACCESS_MASK and only 27-bits are actually valid on
// return from AccessCheck because MAXIMUM_ALLOWED, GENERIC_READ,
// GENERIC_WRITE, GENERIC_EXECUTE, and GENERIC_ALL are never returned.
//
// The content in Data fields depends on the Access Reason, for example,
// if the reason is AccessReasonAce, the Data will be the ACE ID.
// If there are more than one reason (more than one bit is set), the array size
// of the Data is equal to the number of bits set (or number of reasons).
// The Data could be null for a particular reason.
//
// Targeting ..\windows\ACCESS_REASONS.java




/*
The following data structures are defined to consolidate various falvors of
access check functions. In particular for Windows 7, the new access check
function will enable security attribute check, plus returning the reason
for a access check result.

The new access check function based on these data structures will
form the foundation to reimplement other flavors of access check
functions.

*/

//
// Structure to hold pointer to security descriptor and its unique id, which
// can be used for caching access check results.
// (NOTE NOTE) The cache key can be constructed by SecurityDescriptorId, Token and
// PrincipalSelfSid. Watch how GenericMapping affects the cache results.
//
public static final int SE_SECURITY_DESCRIPTOR_FLAG_NO_OWNER_ACE =    0x00000001;
public static final int SE_SECURITY_DESCRIPTOR_FLAG_NO_LABEL_ACE =    0x00000002;
public static final int SE_SECURITY_DESCRIPTOR_VALID_FLAGS =          0x00000003;
// Targeting ..\windows\SE_SECURITY_DESCRIPTOR.java


// Targeting ..\windows\SE_ACCESS_REQUEST.java


// Targeting ..\windows\SE_ACCESS_REPLY.java




////////////////////////////////////////////////////////////////////////
//                                                                    //
//               NT Defined Privileges                                //
//                                                                    //
////////////////////////////////////////////////////////////////////////

public static native @MemberGetter String SE_CREATE_TOKEN_NAME();
public static final String SE_CREATE_TOKEN_NAME = SE_CREATE_TOKEN_NAME();
public static native @MemberGetter String SE_ASSIGNPRIMARYTOKEN_NAME();
public static final String SE_ASSIGNPRIMARYTOKEN_NAME = SE_ASSIGNPRIMARYTOKEN_NAME();
public static native @MemberGetter String SE_LOCK_MEMORY_NAME();
public static final String SE_LOCK_MEMORY_NAME = SE_LOCK_MEMORY_NAME();
public static native @MemberGetter String SE_INCREASE_QUOTA_NAME();
public static final String SE_INCREASE_QUOTA_NAME = SE_INCREASE_QUOTA_NAME();
public static native @MemberGetter String SE_UNSOLICITED_INPUT_NAME();
public static final String SE_UNSOLICITED_INPUT_NAME = SE_UNSOLICITED_INPUT_NAME();
public static native @MemberGetter String SE_MACHINE_ACCOUNT_NAME();
public static final String SE_MACHINE_ACCOUNT_NAME = SE_MACHINE_ACCOUNT_NAME();
public static native @MemberGetter String SE_TCB_NAME();
public static final String SE_TCB_NAME = SE_TCB_NAME();
public static native @MemberGetter String SE_SECURITY_NAME();
public static final String SE_SECURITY_NAME = SE_SECURITY_NAME();
public static native @MemberGetter String SE_TAKE_OWNERSHIP_NAME();
public static final String SE_TAKE_OWNERSHIP_NAME = SE_TAKE_OWNERSHIP_NAME();
public static native @MemberGetter String SE_LOAD_DRIVER_NAME();
public static final String SE_LOAD_DRIVER_NAME = SE_LOAD_DRIVER_NAME();
public static native @MemberGetter String SE_SYSTEM_PROFILE_NAME();
public static final String SE_SYSTEM_PROFILE_NAME = SE_SYSTEM_PROFILE_NAME();
public static native @MemberGetter String SE_SYSTEMTIME_NAME();
public static final String SE_SYSTEMTIME_NAME = SE_SYSTEMTIME_NAME();
public static native @MemberGetter String SE_PROF_SINGLE_PROCESS_NAME();
public static final String SE_PROF_SINGLE_PROCESS_NAME = SE_PROF_SINGLE_PROCESS_NAME();
public static native @MemberGetter String SE_INC_BASE_PRIORITY_NAME();
public static final String SE_INC_BASE_PRIORITY_NAME = SE_INC_BASE_PRIORITY_NAME();
public static native @MemberGetter String SE_CREATE_PAGEFILE_NAME();
public static final String SE_CREATE_PAGEFILE_NAME = SE_CREATE_PAGEFILE_NAME();
public static native @MemberGetter String SE_CREATE_PERMANENT_NAME();
public static final String SE_CREATE_PERMANENT_NAME = SE_CREATE_PERMANENT_NAME();
public static native @MemberGetter String SE_BACKUP_NAME();
public static final String SE_BACKUP_NAME = SE_BACKUP_NAME();
public static native @MemberGetter String SE_RESTORE_NAME();
public static final String SE_RESTORE_NAME = SE_RESTORE_NAME();
public static native @MemberGetter String SE_SHUTDOWN_NAME();
public static final String SE_SHUTDOWN_NAME = SE_SHUTDOWN_NAME();
public static native @MemberGetter String SE_DEBUG_NAME();
public static final String SE_DEBUG_NAME = SE_DEBUG_NAME();
public static native @MemberGetter String SE_AUDIT_NAME();
public static final String SE_AUDIT_NAME = SE_AUDIT_NAME();
public static native @MemberGetter String SE_SYSTEM_ENVIRONMENT_NAME();
public static final String SE_SYSTEM_ENVIRONMENT_NAME = SE_SYSTEM_ENVIRONMENT_NAME();
public static native @MemberGetter String SE_CHANGE_NOTIFY_NAME();
public static final String SE_CHANGE_NOTIFY_NAME = SE_CHANGE_NOTIFY_NAME();
public static native @MemberGetter String SE_REMOTE_SHUTDOWN_NAME();
public static final String SE_REMOTE_SHUTDOWN_NAME = SE_REMOTE_SHUTDOWN_NAME();
public static native @MemberGetter String SE_UNDOCK_NAME();
public static final String SE_UNDOCK_NAME = SE_UNDOCK_NAME();
public static native @MemberGetter String SE_SYNC_AGENT_NAME();
public static final String SE_SYNC_AGENT_NAME = SE_SYNC_AGENT_NAME();
public static native @MemberGetter String SE_ENABLE_DELEGATION_NAME();
public static final String SE_ENABLE_DELEGATION_NAME = SE_ENABLE_DELEGATION_NAME();
public static native @MemberGetter String SE_MANAGE_VOLUME_NAME();
public static final String SE_MANAGE_VOLUME_NAME = SE_MANAGE_VOLUME_NAME();
public static native @MemberGetter String SE_IMPERSONATE_NAME();
public static final String SE_IMPERSONATE_NAME = SE_IMPERSONATE_NAME();
public static native @MemberGetter String SE_CREATE_GLOBAL_NAME();
public static final String SE_CREATE_GLOBAL_NAME = SE_CREATE_GLOBAL_NAME();
public static native @MemberGetter String SE_TRUSTED_CREDMAN_ACCESS_NAME();
public static final String SE_TRUSTED_CREDMAN_ACCESS_NAME = SE_TRUSTED_CREDMAN_ACCESS_NAME();
public static native @MemberGetter String SE_RELABEL_NAME();
public static final String SE_RELABEL_NAME = SE_RELABEL_NAME();
public static native @MemberGetter String SE_INC_WORKING_SET_NAME();
public static final String SE_INC_WORKING_SET_NAME = SE_INC_WORKING_SET_NAME();
public static native @MemberGetter String SE_TIME_ZONE_NAME();
public static final String SE_TIME_ZONE_NAME = SE_TIME_ZONE_NAME();
public static native @MemberGetter String SE_CREATE_SYMBOLIC_LINK_NAME();
public static final String SE_CREATE_SYMBOLIC_LINK_NAME = SE_CREATE_SYMBOLIC_LINK_NAME();



////////////////////////////////////////////////////////////////////
//                                                                //
//           Security Quality Of Service                          //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////

// begin_wdm
//
// Impersonation Level
//
// Impersonation level is represented by a pair of bits in Windows.
// If a new impersonation level is added or lowest value is changed from
// 0 to something else, fix the Windows CreateFile call.
//

/** enum SECURITY_IMPERSONATION_LEVEL */
public static final int
    SecurityAnonymous = 0,
    SecurityIdentification = 1,
    SecurityImpersonation = 2,
    SecurityDelegation = 3;

public static final int SECURITY_MAX_IMPERSONATION_LEVEL = SecurityDelegation;
public static final int SECURITY_MIN_IMPERSONATION_LEVEL = SecurityAnonymous;
public static final int DEFAULT_IMPERSONATION_LEVEL = SecurityImpersonation;
// #define VALID_IMPERSONATION_LEVEL(L) (((L) >= SECURITY_MIN_IMPERSONATION_LEVEL) && ((L) <= SECURITY_MAX_IMPERSONATION_LEVEL))


////////////////////////////////////////////////////////////////////
//                                                                //
//           Token Object Definitions                             //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////


//
// Token Specific Access Rights.
//

public static final int TOKEN_ASSIGN_PRIMARY =    (0x0001);
public static final int TOKEN_DUPLICATE =         (0x0002);
public static final int TOKEN_IMPERSONATE =       (0x0004);
public static final int TOKEN_QUERY =             (0x0008);
public static final int TOKEN_QUERY_SOURCE =      (0x0010);
public static final int TOKEN_ADJUST_PRIVILEGES = (0x0020);
public static final int TOKEN_ADJUST_GROUPS =     (0x0040);
public static final int TOKEN_ADJUST_DEFAULT =    (0x0080);
public static final int TOKEN_ADJUST_SESSIONID =  (0x0100);

public static final long TOKEN_ALL_ACCESS_P = (STANDARD_RIGHTS_REQUIRED  |
                          TOKEN_ASSIGN_PRIMARY      |
                          TOKEN_DUPLICATE           |
                          TOKEN_IMPERSONATE         |
                          TOKEN_QUERY               |
                          TOKEN_QUERY_SOURCE        |
                          TOKEN_ADJUST_PRIVILEGES   |
                          TOKEN_ADJUST_GROUPS       |
                          TOKEN_ADJUST_DEFAULT );

// #if ((defined(_WIN32_WINNT) && (_WIN32_WINNT > 0x0400)) || (!defined(_WIN32_WINNT)))
public static final long TOKEN_ALL_ACCESS =  (TOKEN_ALL_ACCESS_P |
                          TOKEN_ADJUST_SESSIONID );
// #else
// #endif

public static final long TOKEN_READ =       (STANDARD_RIGHTS_READ      |
                          TOKEN_QUERY);


public static final long TOKEN_WRITE =      (STANDARD_RIGHTS_WRITE     |
                          TOKEN_ADJUST_PRIVILEGES   |
                          TOKEN_ADJUST_GROUPS       |
                          TOKEN_ADJUST_DEFAULT);

public static final long TOKEN_EXECUTE =    (STANDARD_RIGHTS_EXECUTE);

public static final long TOKEN_TRUST_CONSTRAINT_MASK =    (STANDARD_RIGHTS_READ  | 
                                       TOKEN_QUERY  |
                                       TOKEN_QUERY_SOURCE );

//
//
// Token Types
//

/** enum TOKEN_TYPE */
public static final int
    TokenPrimary = 1,
    TokenImpersonation = 2;

//
// Token elevation values describe the relative strength of a given token.
// A full token is a token with all groups and privileges to which the principal
// is authorized.  A limited token is one with some groups or privileges removed.
//

/** enum TOKEN_ELEVATION_TYPE */
public static final int
    TokenElevationTypeDefault = 1,
    TokenElevationTypeFull = 2,
    TokenElevationTypeLimited = 3;

//
// Token Information Classes.
//


/** enum TOKEN_INFORMATION_CLASS */
public static final int
    TokenUser = 1,
    TokenGroups = 2,
    TokenPrivileges = 3,
    TokenOwner = 4,
    TokenPrimaryGroup = 5,
    TokenDefaultDacl = 6,
    TokenSource = 7,
    TokenType = 8,
    TokenImpersonationLevel = 9,
    TokenStatistics = 10,
    TokenRestrictedSids = 11,
    TokenSessionId = 12,
    TokenGroupsAndPrivileges = 13,
    TokenSessionReference = 14,
    TokenSandBoxInert = 15,
    TokenAuditPolicy = 16,
    TokenOrigin = 17,
    TokenElevationType = 18,
    TokenLinkedToken = 19,
    TokenElevation = 20,
    TokenHasRestrictions = 21,
    TokenAccessInformation = 22,
    TokenVirtualizationAllowed = 23,
    TokenVirtualizationEnabled = 24,
    TokenIntegrityLevel = 25,
    TokenUIAccess = 26,
    TokenMandatoryPolicy = 27,
    TokenLogonSid = 28,
    TokenIsAppContainer = 29,
    TokenCapabilities = 30,
    TokenAppContainerSid = 31,
    TokenAppContainerNumber = 32,
    TokenUserClaimAttributes = 33,
    TokenDeviceClaimAttributes = 34,
    TokenRestrictedUserClaimAttributes = 35,
    TokenRestrictedDeviceClaimAttributes = 36,
    TokenDeviceGroups = 37,
    TokenRestrictedDeviceGroups = 38,
    TokenSecurityAttributes = 39,
    TokenIsRestricted = 40,
    TokenProcessTrustLevel = 41,
    MaxTokenInfoClass = 42;  // MaxTokenInfoClass should always be the last enum
// Targeting ..\windows\TOKEN_USER.java


// Targeting ..\windows\TOKEN_GROUPS.java


// Targeting ..\windows\TOKEN_PRIVILEGES.java


// Targeting ..\windows\TOKEN_OWNER.java


// Targeting ..\windows\TOKEN_PRIMARY_GROUP.java


// Targeting ..\windows\TOKEN_DEFAULT_DACL.java


// Targeting ..\windows\TOKEN_USER_CLAIMS.java


// Targeting ..\windows\TOKEN_DEVICE_CLAIMS.java


// Targeting ..\windows\TOKEN_GROUPS_AND_PRIVILEGES.java


// Targeting ..\windows\TOKEN_LINKED_TOKEN.java


// Targeting ..\windows\TOKEN_ELEVATION.java


// Targeting ..\windows\TOKEN_MANDATORY_LABEL.java



public static final int TOKEN_MANDATORY_POLICY_OFF =             0x0;
public static final int TOKEN_MANDATORY_POLICY_NO_WRITE_UP =     0x1;
public static final int TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN = 0x2;

public static final int TOKEN_MANDATORY_POLICY_VALID_MASK =      (TOKEN_MANDATORY_POLICY_NO_WRITE_UP | 
                                                TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN);
// Targeting ..\windows\TOKEN_MANDATORY_POLICY.java


// Targeting ..\windows\TOKEN_ACCESS_INFORMATION.java



//
// Valid bits for each TOKEN_AUDIT_POLICY policy mask field.
//

public static final int POLICY_AUDIT_SUBCATEGORY_COUNT = (56);
// Targeting ..\windows\TOKEN_AUDIT_POLICY.java



public static final int TOKEN_SOURCE_LENGTH = 8;
// Targeting ..\windows\TOKEN_SOURCE.java


// Targeting ..\windows\TOKEN_STATISTICS.java


// Targeting ..\windows\TOKEN_CONTROL.java


// Targeting ..\windows\TOKEN_ORIGIN.java




/** enum MANDATORY_LEVEL */
public static final int
    MandatoryLevelUntrusted = 0,
    MandatoryLevelLow = 1,
    MandatoryLevelMedium = 2,
    MandatoryLevelHigh = 3,
    MandatoryLevelSystem = 4,
    MandatoryLevelSecureProcess = 5,
    MandatoryLevelCount = 6;
// Targeting ..\windows\TOKEN_APPCONTAINER_INFORMATION.java


// Targeting ..\windows\TOKEN_SID_INFORMATION.java



//
//  *** Claim Security attributes ***
//
//      These #defines and data structures (almost) exactly mirror
//      the Token_XXX definitions (except for PWSTR/PUNICODE changes)
//      in ntseapi.w as well as AUTHZ_XXX in authz.w. 
//      Keep them in sync. 
//
//
//  Security attribute data types ...
//

public static final int CLAIM_SECURITY_ATTRIBUTE_TYPE_INVALID =   0x00;

public static final int CLAIM_SECURITY_ATTRIBUTE_TYPE_INT64 =     0x01;
public static final int CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64 =    0x02;

//
//  Case insensitive attribute value string by default.
//  Unless the flag CLAIM_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE
//  is set indicating otherwise.
//

public static final int CLAIM_SECURITY_ATTRIBUTE_TYPE_STRING =    0x03;
// Targeting ..\windows\CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE.java



public static final int CLAIM_SECURITY_ATTRIBUTE_TYPE_FQBN =      0x04;

public static final int CLAIM_SECURITY_ATTRIBUTE_TYPE_SID =       0x05;

public static final int CLAIM_SECURITY_ATTRIBUTE_TYPE_BOOLEAN =   0x06;
// Targeting ..\windows\CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE.java



public static final int CLAIM_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING =  0x10;

//
// Attribute Flags
//

//
//  Attribute must not be inherited across process spawns.
//

public static final int CLAIM_SECURITY_ATTRIBUTE_NON_INHERITABLE =      0x0001;


//
//  Attribute value is compared in a case sensitive way. It is valid with string value
//  or composite type containing string value. For other types of value, this flag
//  will be ignored. Currently, it is valid with the two types:
//  CLAIM_SECURITY_ATTRIBUTE_TYPE_STRING and CLAIM_SECURITY_ATTRIBUTE_TYPE_FQBN.
//
public static final int CLAIM_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE =         0x0002;

//
// Attribute is considered only for Deny Aces.
//

public static final int CLAIM_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY = 0x0004;

//
// Attribute is disabled by default.
//

public static final int CLAIM_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT = 0x0008;

// 
// Attribute is disabled.
//

public static final int CLAIM_SECURITY_ATTRIBUTE_DISABLED = 0x0010;

//
// Attribute is mandatory.
//

public static final int CLAIM_SECURITY_ATTRIBUTE_MANDATORY = 0x0020;


public static final int CLAIM_SECURITY_ATTRIBUTE_VALID_FLAGS =   (    
                        CLAIM_SECURITY_ATTRIBUTE_NON_INHERITABLE       |  
                        CLAIM_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE  |  
                        CLAIM_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY     |  
                        CLAIM_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT   |  
                        CLAIM_SECURITY_ATTRIBUTE_DISABLED              |  
                        CLAIM_SECURITY_ATTRIBUTE_MANDATORY );


//
// Reserve upper 16 bits for custom flags. These should be preserved but not
// validated as they do not affect security in any way.
//
public static final int CLAIM_SECURITY_ATTRIBUTE_CUSTOM_FLAGS =   0xFFFF0000;
// Targeting ..\windows\CLAIM_SECURITY_ATTRIBUTE_V1.java


// Targeting ..\windows\CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1.java




//
//  Set of security attributes.
//

//
//  Versioning. The interpretation of the pointers in the
//  Attribute field below is dependent on the version field.
//
//  Get operations return the version while the set operation
//  MUST specify the version of the data structure passed in.
//

public static final int CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1 =    1;

public static final int CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION =       
    CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1;
// Targeting ..\windows\CLAIM_SECURITY_ATTRIBUTES_INFORMATION.java



//
// Security Tracking Mode
//

public static final int SECURITY_DYNAMIC_TRACKING =      (TRUE);
public static final int SECURITY_STATIC_TRACKING =       (FALSE);
// Targeting ..\windows\SECURITY_QUALITY_OF_SERVICE.java


// Targeting ..\windows\SE_IMPERSONATION_STATE.java



public static final int DISABLE_MAX_PRIVILEGE =   0x1; 
public static final int SANDBOX_INERT =           0x2; 
public static final int LUA_TOKEN =               0x4; 
public static final int WRITE_RESTRICTED =        0x8;

public static final long OWNER_SECURITY_INFORMATION =       (0x00000001L);
public static final long GROUP_SECURITY_INFORMATION =       (0x00000002L);
public static final long DACL_SECURITY_INFORMATION =        (0x00000004L);
public static final long SACL_SECURITY_INFORMATION =        (0x00000008L);
public static final long LABEL_SECURITY_INFORMATION =       (0x00000010L);
public static final long ATTRIBUTE_SECURITY_INFORMATION =   (0x00000020L);
public static final long SCOPE_SECURITY_INFORMATION =       (0x00000040L);
public static final long PROCESS_TRUST_LABEL_SECURITY_INFORMATION = (0x00000080L); 
public static final long BACKUP_SECURITY_INFORMATION =      (0x00010000L);

public static final long PROTECTED_DACL_SECURITY_INFORMATION =     (0x80000000L);
public static final long PROTECTED_SACL_SECURITY_INFORMATION =     (0x40000000L);
public static final long UNPROTECTED_DACL_SECURITY_INFORMATION =   (0x20000000L);
public static final long UNPROTECTED_SACL_SECURITY_INFORMATION =   (0x10000000L);


//
// Learning Mode Types.
//

/** enum SE_LEARNING_MODE_DATA_TYPE */
public static final int
    SeLearningModeInvalidType = 0,
    SeLearningModeSettings = 1,
    SeLearningModeMax = 2;

public static final int SE_LEARNING_MODE_FLAG_PERMISSIVE = 0x00000001;
// Targeting ..\windows\SECURITY_CAPABILITIES.java



public static final int PROCESS_TERMINATE =                  (0x0001);  
public static final int PROCESS_CREATE_THREAD =              (0x0002);  
public static final int PROCESS_SET_SESSIONID =              (0x0004);  
public static final int PROCESS_VM_OPERATION =               (0x0008);  
public static final int PROCESS_VM_READ =                    (0x0010);  
public static final int PROCESS_VM_WRITE =                   (0x0020);  
public static final int PROCESS_DUP_HANDLE =                 (0x0040);  
public static final int PROCESS_CREATE_PROCESS =             (0x0080);  
public static final int PROCESS_SET_QUOTA =                  (0x0100);  
public static final int PROCESS_SET_INFORMATION =            (0x0200);  
public static final int PROCESS_QUERY_INFORMATION =          (0x0400);  
public static final int PROCESS_SUSPEND_RESUME =             (0x0800);  
public static final int PROCESS_QUERY_LIMITED_INFORMATION =  (0x1000);  
public static final int PROCESS_SET_LIMITED_INFORMATION =    (0x2000);  
// #if (NTDDI_VERSION >= NTDDI_VISTA)
public static final long PROCESS_ALL_ACCESS =        (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 
                                   0xFFFF);
// #else
// #endif

// #if defined(_WIN64)

public static final int MAXIMUM_PROC_PER_GROUP = 64;

// #else

// #endif

public static final int MAXIMUM_PROCESSORS =          MAXIMUM_PROC_PER_GROUP;

public static final int THREAD_TERMINATE =                 (0x0001);  
public static final int THREAD_SUSPEND_RESUME =            (0x0002);  
public static final int THREAD_GET_CONTEXT =               (0x0008);  
public static final int THREAD_SET_CONTEXT =               (0x0010);  
public static final int THREAD_QUERY_INFORMATION =         (0x0040);  
public static final int THREAD_SET_INFORMATION =           (0x0020);  
public static final int THREAD_SET_THREAD_TOKEN =          (0x0080);
public static final int THREAD_IMPERSONATE =               (0x0100);
public static final int THREAD_DIRECT_IMPERSONATION =      (0x0200);
// begin_wdm
public static final int THREAD_SET_LIMITED_INFORMATION =   (0x0400);  // winnt
public static final int THREAD_QUERY_LIMITED_INFORMATION = (0x0800);  // winnt
public static final int THREAD_RESUME =                    (0x1000);  // winnt
// #if (NTDDI_VERSION >= NTDDI_VISTA)
public static final long THREAD_ALL_ACCESS =         (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 
                                   0xFFFF);
// #else
// #endif
public static final int JOB_OBJECT_ASSIGN_PROCESS =           (0x0001);
public static final int JOB_OBJECT_SET_ATTRIBUTES =           (0x0002);
public static final int JOB_OBJECT_QUERY =                    (0x0004);
public static final int JOB_OBJECT_TERMINATE =                (0x0008);
public static final int JOB_OBJECT_SET_SECURITY_ATTRIBUTES =  (0x0010);
public static final long JOB_OBJECT_ALL_ACCESS =       (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 
                                        0x1F );
// Targeting ..\windows\JOB_SET_ARRAY.java



public static final int FLS_MAXIMUM_AVAILABLE = 128;   
public static final int TLS_MINIMUM_AVAILABLE = 64;
// Targeting ..\windows\EXCEPTION_REGISTRATION_RECORD.java


// Targeting ..\windows\NT_TIB.java


// Targeting ..\windows\NT_TIB32.java


// Targeting ..\windows\NT_TIB64.java





public static final int THREAD_BASE_PRIORITY_LOWRT =  15;  // value that gets a thread to LowRealtime-1
public static final int THREAD_BASE_PRIORITY_MAX =    2;   // maximum thread base priority boost
public static final int THREAD_BASE_PRIORITY_MIN =    (-2);  // minimum thread base priority boost
public static final int THREAD_BASE_PRIORITY_IDLE =   (-15);
// Targeting ..\windows\UMS_CREATE_THREAD_ATTRIBUTES.java


// Targeting ..\windows\QUOTA_LIMITS.java



public static final int QUOTA_LIMITS_HARDWS_MIN_ENABLE =  0x00000001;
public static final int QUOTA_LIMITS_HARDWS_MIN_DISABLE = 0x00000002;
public static final int QUOTA_LIMITS_HARDWS_MAX_ENABLE =  0x00000004;
public static final int QUOTA_LIMITS_HARDWS_MAX_DISABLE = 0x00000008;
public static final int QUOTA_LIMITS_USE_DEFAULT_LIMITS = 0x00000010;
// Targeting ..\windows\RATE_QUOTA_LIMIT.java


// Targeting ..\windows\QUOTA_LIMITS_EX.java


// Targeting ..\windows\IO_COUNTERS.java



public static final int MAX_HW_COUNTERS = 16;
public static final int THREAD_PROFILING_FLAG_DISPATCH =  0x00000001;

/** enum HARDWARE_COUNTER_TYPE */
public static final int
    PMCCounter = 0,
    MaxHardwareCounterType = 1;
/** enum PROCESS_MITIGATION_POLICY */
public static final int
    ProcessDEPPolicy = 0,
    ProcessASLRPolicy = 1,
    ProcessDynamicCodePolicy = 2,
    ProcessStrictHandleCheckPolicy = 3,
    ProcessSystemCallDisablePolicy = 4,
    ProcessMitigationOptionsMask = 5,
    ProcessExtensionPointDisablePolicy = 6,
    ProcessReserved1Policy = 7,
    ProcessSignaturePolicy = 8,
    MaxProcessMitigationPolicy = 9;
// Targeting ..\windows\PROCESS_MITIGATION_ASLR_POLICY.java


// Targeting ..\windows\PROCESS_MITIGATION_DEP_POLICY.java


// Targeting ..\windows\PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY.java


// Targeting ..\windows\PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY.java


// Targeting ..\windows\PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY.java


// Targeting ..\windows\PROCESS_MITIGATION_DYNAMIC_CODE_POLICY.java


// Targeting ..\windows\PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY.java


// Targeting ..\windows\JOBOBJECT_BASIC_ACCOUNTING_INFORMATION.java


// Targeting ..\windows\JOBOBJECT_BASIC_LIMIT_INFORMATION.java


// Targeting ..\windows\JOBOBJECT_EXTENDED_LIMIT_INFORMATION.java


// Targeting ..\windows\JOBOBJECT_BASIC_PROCESS_ID_LIST.java


// Targeting ..\windows\JOBOBJECT_BASIC_UI_RESTRICTIONS.java


// Targeting ..\windows\JOBOBJECT_SECURITY_LIMIT_INFORMATION.java


// Targeting ..\windows\JOBOBJECT_END_OF_JOB_TIME_INFORMATION.java


// Targeting ..\windows\JOBOBJECT_ASSOCIATE_COMPLETION_PORT.java


// Targeting ..\windows\JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION.java


// Targeting ..\windows\JOBOBJECT_JOBSET_INFORMATION.java



/** enum JOBOBJECT_RATE_CONTROL_TOLERANCE */
public static final int
    ToleranceLow = 1,
    ToleranceMedium = 2,
    ToleranceHigh = 3;

/** enum JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL */
public static final int
    ToleranceIntervalShort = 1,
    ToleranceIntervalMedium = 2,
    ToleranceIntervalLong = 3;
// Targeting ..\windows\JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION.java


// Targeting ..\windows\JOBOBJECT_LIMIT_VIOLATION_INFORMATION.java


// Targeting ..\windows\JOBOBJECT_CPU_RATE_CONTROL_INFORMATION.java



public static final int JOB_OBJECT_TERMINATE_AT_END_OF_JOB =  0;
public static final int JOB_OBJECT_POST_AT_END_OF_JOB =       1;

//
// Completion Port Messages for job objects
//
// These values are returned via the lpNumberOfBytesTransferred parameter
//

public static final int JOB_OBJECT_MSG_END_OF_JOB_TIME =          1;
public static final int JOB_OBJECT_MSG_END_OF_PROCESS_TIME =      2;
public static final int JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT =     3;
public static final int JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO =      4;
public static final int JOB_OBJECT_MSG_NEW_PROCESS =              6;
public static final int JOB_OBJECT_MSG_EXIT_PROCESS =             7;
public static final int JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS =    8;
public static final int JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT =     9;
public static final int JOB_OBJECT_MSG_JOB_MEMORY_LIMIT =         10;
public static final int JOB_OBJECT_MSG_NOTIFICATION_LIMIT =       11;
public static final int JOB_OBJECT_MSG_JOB_CYCLE_TIME_LIMIT =     12;

//
// Define the valid notification filter values.
//

public static final int JOB_OBJECT_MSG_MINIMUM = 1;
public static final int JOB_OBJECT_MSG_MAXIMUM = 12;

public static final long JOB_OBJECT_VALID_COMPLETION_FILTER = 
    (((1L << (JOB_OBJECT_MSG_MAXIMUM + 1)) - 1) - 
     ((1L << JOB_OBJECT_MSG_MINIMUM) - 1));

//
// Basic Limits
//
public static final int JOB_OBJECT_LIMIT_WORKINGSET =                 0x00000001;
public static final int JOB_OBJECT_LIMIT_PROCESS_TIME =               0x00000002;
public static final int JOB_OBJECT_LIMIT_JOB_TIME =                   0x00000004;
public static final int JOB_OBJECT_LIMIT_ACTIVE_PROCESS =             0x00000008;
public static final int JOB_OBJECT_LIMIT_AFFINITY =                   0x00000010;
public static final int JOB_OBJECT_LIMIT_PRIORITY_CLASS =             0x00000020;
public static final int JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME =          0x00000040;
public static final int JOB_OBJECT_LIMIT_SCHEDULING_CLASS =           0x00000080;

//
// Extended Limits
//
public static final int JOB_OBJECT_LIMIT_PROCESS_MEMORY =             0x00000100;
public static final int JOB_OBJECT_LIMIT_JOB_MEMORY =                 0x00000200;
public static final int JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 0x00000400;
public static final int JOB_OBJECT_LIMIT_BREAKAWAY_OK =               0x00000800;
public static final int JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK =        0x00001000;
public static final int JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE =          0x00002000;
public static final int JOB_OBJECT_LIMIT_SUBSET_AFFINITY =            0x00004000;

//
// Notification Limits
//

public static final int JOB_OBJECT_LIMIT_JOB_READ_BYTES =             0x00010000;
public static final int JOB_OBJECT_LIMIT_JOB_WRITE_BYTES =            0x00020000;
public static final int JOB_OBJECT_LIMIT_RATE_CONTROL =               0x00040000;

//
// Reserved flags
//

public static final int JOB_OBJECT_LIMIT_RESERVED3 =                  0x00008000;

//
// Valid Job Object Limits
//

public static final int JOB_OBJECT_LIMIT_VALID_FLAGS =                0x0007ffff;
public static final int JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS =          0x000000ff;
public static final int JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS =       0x00007fff;
public static final int JOB_OBJECT_NOTIFICATION_LIMIT_VALID_FLAGS =   0x00070204;
public static final int JOB_OBJECT_RESERVED_LIMIT_VALID_FLAGS =       0x0007ffff;

//
// UI restrictions for jobs
//

public static final int JOB_OBJECT_UILIMIT_NONE =             0x00000000;

public static final int JOB_OBJECT_UILIMIT_HANDLES =          0x00000001;
public static final int JOB_OBJECT_UILIMIT_READCLIPBOARD =    0x00000002;
public static final int JOB_OBJECT_UILIMIT_WRITECLIPBOARD =   0x00000004;
public static final int JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 0x00000008;
public static final int JOB_OBJECT_UILIMIT_DISPLAYSETTINGS =  0x00000010;
public static final int JOB_OBJECT_UILIMIT_GLOBALATOMS =      0x00000020;
public static final int JOB_OBJECT_UILIMIT_DESKTOP =          0x00000040;
public static final int JOB_OBJECT_UILIMIT_EXITWINDOWS =      0x00000080;

public static final int JOB_OBJECT_UILIMIT_ALL =              0x000000FF;

public static final int JOB_OBJECT_UI_VALID_FLAGS =           0x000000FF;

public static final int JOB_OBJECT_SECURITY_NO_ADMIN =            0x00000001;
public static final int JOB_OBJECT_SECURITY_RESTRICTED_TOKEN =    0x00000002;
public static final int JOB_OBJECT_SECURITY_ONLY_TOKEN =          0x00000004;
public static final int JOB_OBJECT_SECURITY_FILTER_TOKENS =       0x00000008;

public static final int JOB_OBJECT_SECURITY_VALID_FLAGS =         0x0000000f;

//
// Control flags for CPU rate control.
//

public static final int JOB_OBJECT_CPU_RATE_CONTROL_ENABLE = 0x1;
public static final int JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED = 0x2;
public static final int JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP = 0x4;
public static final int JOB_OBJECT_CPU_RATE_CONTROL_NOTIFY = 0x8;
public static final int JOB_OBJECT_CPU_RATE_CONTROL_VALID_FLAGS = 0xf;

/** enum JOBOBJECTINFOCLASS */
public static final int
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation = 2,
    JobObjectBasicProcessIdList = 3,
    JobObjectBasicUIRestrictions = 4,
    JobObjectSecurityLimitInformation = 5,  // deprecated
    JobObjectEndOfJobTimeInformation = 6,
    JobObjectAssociateCompletionPortInformation = 7,
    JobObjectBasicAndIoAccountingInformation = 8,
    JobObjectExtendedLimitInformation = 9,
    JobObjectJobSetInformation = 10,
    JobObjectGroupInformation = 11,
    JobObjectNotificationLimitInformation = 12,
    JobObjectLimitViolationInformation = 13,
    JobObjectGroupInformationEx = 14,
    JobObjectCpuRateControlInformation = 15,
    JobObjectCompletionFilter = 16,
    JobObjectCompletionCounter = 17,
    JobObjectReserved1Information = 18,
    JobObjectReserved2Information = 19,
    JobObjectReserved3Information = 20,
    JobObjectReserved4Information = 21,
    JobObjectReserved5Information = 22,
    JobObjectReserved6Information = 23,
    JobObjectReserved7Information = 24,
    JobObjectReserved8Information = 25,
    JobObjectReserved9Information = 26,
    MaxJobObjectInfoClass = 27;


/** enum FIRMWARE_TYPE */
public static final int
    FirmwareTypeUnknown = 0,
    FirmwareTypeBios = 1,
    FirmwareTypeUefi = 2,
    FirmwareTypeMax = 3;

public static final int EVENT_MODIFY_STATE =      0x0002;  
public static final long EVENT_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3); 

public static final int MUTANT_QUERY_STATE =      0x0001;

public static final long MUTANT_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|
                          MUTANT_QUERY_STATE);

public static final int SEMAPHORE_MODIFY_STATE =      0x0002;  
public static final long SEMAPHORE_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3); 

//
// Timer Specific Access Rights.
//

public static final int TIMER_QUERY_STATE =       0x0001;
public static final int TIMER_MODIFY_STATE =      0x0002;

public static final long TIMER_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|
                          TIMER_QUERY_STATE|TIMER_MODIFY_STATE);

// begin_nthal

public static final int TIME_ZONE_ID_UNKNOWN =  0;
public static final int TIME_ZONE_ID_STANDARD = 1;
public static final int TIME_ZONE_ID_DAYLIGHT = 2;

// end_nthal

/** enum LOGICAL_PROCESSOR_RELATIONSHIP */
public static final int
    RelationProcessorCore = 0,
    RelationNumaNode = 1,
    RelationCache = 2,
    RelationProcessorPackage = 3,
    RelationGroup = 4,
    RelationAll = 0xffff;

public static final int LTP_PC_SMT = 0x1;

/** enum PROCESSOR_CACHE_TYPE */
public static final int
    CacheUnified = 0,
    CacheInstruction = 1,
    CacheData = 2,
    CacheTrace = 3;

public static final int CACHE_FULLY_ASSOCIATIVE = 0xFF;
// Targeting ..\windows\CACHE_DESCRIPTOR.java


// Targeting ..\windows\SYSTEM_LOGICAL_PROCESSOR_INFORMATION.java


// Targeting ..\windows\PROCESSOR_RELATIONSHIP.java


// Targeting ..\windows\NUMA_NODE_RELATIONSHIP.java


// Targeting ..\windows\CACHE_RELATIONSHIP.java


// Targeting ..\windows\PROCESSOR_GROUP_INFO.java


// Targeting ..\windows\GROUP_RELATIONSHIP.java


// Targeting ..\windows\_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX.java


// Targeting ..\windows\SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX.java


// Targeting ..\windows\SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION.java




public static final int PROCESSOR_INTEL_386 =     386;
public static final int PROCESSOR_INTEL_486 =     486;
public static final int PROCESSOR_INTEL_PENTIUM = 586;
public static final int PROCESSOR_INTEL_IA64 =    2200;
public static final int PROCESSOR_AMD_X8664 =     8664;
public static final int PROCESSOR_MIPS_R4000 =    4000;    // incl R4101 & R3910 for Windows CE
public static final int PROCESSOR_ALPHA_21064 =   21064;
public static final int PROCESSOR_PPC_601 =       601;
public static final int PROCESSOR_PPC_603 =       603;
public static final int PROCESSOR_PPC_604 =       604;
public static final int PROCESSOR_PPC_620 =       620;
public static final int PROCESSOR_HITACHI_SH3 =   10003;   // Windows CE
public static final int PROCESSOR_HITACHI_SH3E =  10004;   // Windows CE
public static final int PROCESSOR_HITACHI_SH4 =   10005;   // Windows CE
public static final int PROCESSOR_MOTOROLA_821 =  821;     // Windows CE
public static final int PROCESSOR_SHx_SH3 =       103;     // Windows CE
public static final int PROCESSOR_SHx_SH4 =       104;     // Windows CE
public static final int PROCESSOR_STRONGARM =     2577;    // Windows CE - 0xA11
public static final int PROCESSOR_ARM720 =        1824;    // Windows CE - 0x720
public static final int PROCESSOR_ARM820 =        2080;    // Windows CE - 0x820
public static final int PROCESSOR_ARM920 =        2336;    // Windows CE - 0x920
public static final int PROCESSOR_ARM_7TDMI =     70001;   // Windows CE
public static final int PROCESSOR_OPTIL =         0x494f;  // MSIL

public static final int PROCESSOR_ARCHITECTURE_INTEL =            0;
public static final int PROCESSOR_ARCHITECTURE_MIPS =             1;
public static final int PROCESSOR_ARCHITECTURE_ALPHA =            2;
public static final int PROCESSOR_ARCHITECTURE_PPC =              3;
public static final int PROCESSOR_ARCHITECTURE_SHX =              4;
public static final int PROCESSOR_ARCHITECTURE_ARM =              5;
public static final int PROCESSOR_ARCHITECTURE_IA64 =             6;
public static final int PROCESSOR_ARCHITECTURE_ALPHA64 =          7;
public static final int PROCESSOR_ARCHITECTURE_MSIL =             8;
public static final int PROCESSOR_ARCHITECTURE_AMD64 =            9;
public static final int PROCESSOR_ARCHITECTURE_IA32_ON_WIN64 =    10;
public static final int PROCESSOR_ARCHITECTURE_NEUTRAL =          11;

public static final int PROCESSOR_ARCHITECTURE_UNKNOWN = 0xFFFF;

public static final int PF_FLOATING_POINT_PRECISION_ERRATA =   0;   
public static final int PF_FLOATING_POINT_EMULATED =           1;   
public static final int PF_COMPARE_EXCHANGE_DOUBLE =           2;   
public static final int PF_MMX_INSTRUCTIONS_AVAILABLE =        3;   
public static final int PF_PPC_MOVEMEM_64BIT_OK =              4;   
public static final int PF_ALPHA_BYTE_INSTRUCTIONS =           5;   
public static final int PF_XMMI_INSTRUCTIONS_AVAILABLE =       6;   
public static final int PF_3DNOW_INSTRUCTIONS_AVAILABLE =      7;   
public static final int PF_RDTSC_INSTRUCTION_AVAILABLE =       8;   
public static final int PF_PAE_ENABLED =                       9;   
public static final int PF_XMMI64_INSTRUCTIONS_AVAILABLE =    10;   
public static final int PF_SSE_DAZ_MODE_AVAILABLE =           11;   
public static final int PF_NX_ENABLED =                       12;   
public static final int PF_SSE3_INSTRUCTIONS_AVAILABLE =      13;   
public static final int PF_COMPARE_EXCHANGE128 =              14;   
public static final int PF_COMPARE64_EXCHANGE128 =            15;   
public static final int PF_CHANNELS_ENABLED =                 16;   
public static final int PF_XSAVE_ENABLED =                    17;   
public static final int PF_ARM_VFP_32_REGISTERS_AVAILABLE =   18;   
public static final int PF_ARM_NEON_INSTRUCTIONS_AVAILABLE =  19;   
public static final int PF_SECOND_LEVEL_ADDRESS_TRANSLATION = 20;   
public static final int PF_VIRT_FIRMWARE_ENABLED =            21;   
public static final int PF_RDWRFSGSBASE_AVAILABLE =           22;   
public static final int PF_FASTFAIL_AVAILABLE =               23;   
public static final int PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE = 24;   
public static final int PF_ARM_64BIT_LOADSTORE_ATOMIC =       25;   
public static final int PF_ARM_EXTERNAL_CACHE_AVAILABLE =     26;   
public static final int PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE =  27;   
public static final int PF_RDRAND_INSTRUCTION_AVAILABLE =     28;   

//
// Known extended CPU state feature IDs
//

public static final int XSTATE_LEGACY_FLOATING_POINT =        (0);
public static final int XSTATE_LEGACY_SSE =                   (1);
public static final int XSTATE_GSSE =                         (2);
public static final int XSTATE_AVX =                          (XSTATE_GSSE);

public static final long XSTATE_MASK_LEGACY_FLOATING_POINT =   (1L << (XSTATE_LEGACY_FLOATING_POINT));
public static final long XSTATE_MASK_LEGACY_SSE =              (1L << (XSTATE_LEGACY_SSE));
public static final long XSTATE_MASK_LEGACY =                  (XSTATE_MASK_LEGACY_FLOATING_POINT | XSTATE_MASK_LEGACY_SSE);
public static final long XSTATE_MASK_GSSE =                    (1L << (XSTATE_GSSE));
public static final long XSTATE_MASK_AVX =                     (XSTATE_MASK_GSSE);

public static final int MAXIMUM_XSTATE_FEATURES =             (64);
// Targeting ..\windows\XSTATE_FEATURE.java


// Targeting ..\windows\XSTATE_CONFIGURATION.java


// Targeting ..\windows\MEMORY_BASIC_INFORMATION.java


// Targeting ..\windows\MEMORY_BASIC_INFORMATION32.java


// Targeting ..\windows\MEMORY_BASIC_INFORMATION64.java



public static final int SECTION_QUERY =                0x0001;
public static final int SECTION_MAP_WRITE =            0x0002;
public static final int SECTION_MAP_READ =             0x0004;
public static final int SECTION_MAP_EXECUTE =          0x0008;
public static final int SECTION_EXTEND_SIZE =          0x0010;
public static final int SECTION_MAP_EXECUTE_EXPLICIT = 0x0020; // not included in SECTION_ALL_ACCESS

public static final long SECTION_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED|SECTION_QUERY|
                            SECTION_MAP_WRITE |      
                            SECTION_MAP_READ |       
                            SECTION_MAP_EXECUTE |    
                            SECTION_EXTEND_SIZE);

public static final int SESSION_QUERY_ACCESS =  0x0001;
public static final int SESSION_MODIFY_ACCESS = 0x0002;

public static final long SESSION_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED |  
                            SESSION_QUERY_ACCESS |             
                            SESSION_MODIFY_ACCESS);

public static final int PAGE_NOACCESS =          0x01;     
public static final int PAGE_READONLY =          0x02;     
public static final int PAGE_READWRITE =         0x04;     
public static final int PAGE_WRITECOPY =         0x08;     
// #pragma region Desktop Family           
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) 
public static final int PAGE_EXECUTE =           0x10;     
public static final int PAGE_EXECUTE_READ =      0x20;     
public static final int PAGE_EXECUTE_READWRITE = 0x40;     
public static final int PAGE_EXECUTE_WRITECOPY = 0x80;     
// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */ 
// #pragma endregion                       
public static final int PAGE_GUARD =            0x100;     
public static final int PAGE_NOCACHE =          0x200;     
public static final int PAGE_WRITECOMBINE =     0x400;     
public static final int PAGE_REVERT_TO_FILE_MAP =     0x80000000;     
public static final int MEM_COMMIT =                  0x1000;      
public static final int MEM_RESERVE =                 0x2000;      
public static final int MEM_DECOMMIT =                0x4000;      
public static final int MEM_RELEASE =                 0x8000;      
public static final int MEM_FREE =                    0x10000;     
public static final int MEM_PRIVATE =                 0x20000;     
public static final int MEM_MAPPED =                  0x40000;     
public static final int MEM_RESET =                   0x80000;     
public static final int MEM_TOP_DOWN =                0x100000;    
public static final int MEM_WRITE_WATCH =             0x200000;    
public static final int MEM_PHYSICAL =                0x400000;    
public static final int MEM_ROTATE =                  0x800000;    
public static final int MEM_DIFFERENT_IMAGE_BASE_OK = 0x800000;    
public static final int MEM_RESET_UNDO =              0x1000000;   
public static final int MEM_LARGE_PAGES =             0x20000000;  
public static final int MEM_4MB_PAGES =               0x80000000;  
public static final int SEC_FILE =           0x800000;     
public static final int SEC_IMAGE =         0x1000000;     
public static final int SEC_PROTECTED_IMAGE =  0x2000000;  
public static final int SEC_RESERVE =       0x4000000;     
public static final int SEC_COMMIT =        0x8000000;     
public static final int SEC_NOCACHE =      0x10000000;     
public static final int SEC_WRITECOMBINE = 0x40000000;     
public static final int SEC_LARGE_PAGES =  0x80000000;     
public static final int SEC_IMAGE_NO_EXECUTE = (SEC_IMAGE | SEC_NOCACHE);     
public static final int MEM_IMAGE =         SEC_IMAGE;     
public static final int WRITE_WATCH_FLAG_RESET =  0x01;     
public static final int MEM_UNMAP_WITH_TRANSIENT_BOOST =  0x01;     

//
// Define access rights to files and directories
//

//
// The FILE_READ_DATA and FILE_WRITE_DATA constants are also defined in
// devioctl.h as FILE_READ_ACCESS and FILE_WRITE_ACCESS. The values for these
// constants *MUST* always be in sync.
// The values are redefined in devioctl.h because they must be available to
// both DOS and NT.
//

public static final int FILE_READ_DATA =            ( 0x0001 );    // file & pipe
public static final int FILE_LIST_DIRECTORY =       ( 0x0001 );    // directory

public static final int FILE_WRITE_DATA =           ( 0x0002 );    // file & pipe
public static final int FILE_ADD_FILE =             ( 0x0002 );    // directory

public static final int FILE_APPEND_DATA =          ( 0x0004 );    // file
public static final int FILE_ADD_SUBDIRECTORY =     ( 0x0004 );    // directory
public static final int FILE_CREATE_PIPE_INSTANCE = ( 0x0004 );    // named pipe


public static final int FILE_READ_EA =              ( 0x0008 );    // file & directory

public static final int FILE_WRITE_EA =             ( 0x0010 );    // file & directory

public static final int FILE_EXECUTE =              ( 0x0020 );    // file
public static final int FILE_TRAVERSE =             ( 0x0020 );    // directory

public static final int FILE_DELETE_CHILD =         ( 0x0040 );    // directory

public static final int FILE_READ_ATTRIBUTES =      ( 0x0080 );    // all

public static final int FILE_WRITE_ATTRIBUTES =     ( 0x0100 );    // all

public static final long FILE_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1FF);

public static final long FILE_GENERIC_READ =         (STANDARD_RIGHTS_READ     |
                                   FILE_READ_DATA           |
                                   FILE_READ_ATTRIBUTES     |
                                   FILE_READ_EA             |
                                   SYNCHRONIZE);


public static final long FILE_GENERIC_WRITE =        (STANDARD_RIGHTS_WRITE    |
                                   FILE_WRITE_DATA          |
                                   FILE_WRITE_ATTRIBUTES    |
                                   FILE_WRITE_EA            |
                                   FILE_APPEND_DATA         |
                                   SYNCHRONIZE);


public static final long FILE_GENERIC_EXECUTE =      (STANDARD_RIGHTS_EXECUTE  |
                                   FILE_READ_ATTRIBUTES     |
                                   FILE_EXECUTE             |
                                   SYNCHRONIZE);

public static final int FILE_SHARE_READ =                 0x00000001;  
public static final int FILE_SHARE_WRITE =                0x00000002;  
public static final int FILE_SHARE_DELETE =               0x00000004;  
public static final int FILE_ATTRIBUTE_READONLY =             0x00000001;  
public static final int FILE_ATTRIBUTE_HIDDEN =               0x00000002;  
public static final int FILE_ATTRIBUTE_SYSTEM =               0x00000004;  
public static final int FILE_ATTRIBUTE_DIRECTORY =            0x00000010;  
public static final int FILE_ATTRIBUTE_ARCHIVE =              0x00000020;  
public static final int FILE_ATTRIBUTE_DEVICE =               0x00000040;  
public static final int FILE_ATTRIBUTE_NORMAL =               0x00000080;  
public static final int FILE_ATTRIBUTE_TEMPORARY =            0x00000100;  
public static final int FILE_ATTRIBUTE_SPARSE_FILE =          0x00000200;  
public static final int FILE_ATTRIBUTE_REPARSE_POINT =        0x00000400;  
public static final int FILE_ATTRIBUTE_COMPRESSED =           0x00000800;  
public static final int FILE_ATTRIBUTE_OFFLINE =              0x00001000;  
public static final int FILE_ATTRIBUTE_NOT_CONTENT_INDEXED =  0x00002000;  
public static final int FILE_ATTRIBUTE_ENCRYPTED =            0x00004000;  
public static final int FILE_ATTRIBUTE_INTEGRITY_STREAM =     0x00008000;  
public static final int FILE_ATTRIBUTE_VIRTUAL =              0x00010000;  
public static final int FILE_ATTRIBUTE_NO_SCRUB_DATA =        0x00020000;  
public static final int FILE_ATTRIBUTE_EA =                   0x00040000;  
public static final int FILE_NOTIFY_CHANGE_FILE_NAME =    0x00000001;   
public static final int FILE_NOTIFY_CHANGE_DIR_NAME =     0x00000002;   
public static final int FILE_NOTIFY_CHANGE_ATTRIBUTES =   0x00000004;   
public static final int FILE_NOTIFY_CHANGE_SIZE =         0x00000008;   
public static final int FILE_NOTIFY_CHANGE_LAST_WRITE =   0x00000010;   
public static final int FILE_NOTIFY_CHANGE_LAST_ACCESS =  0x00000020;   
public static final int FILE_NOTIFY_CHANGE_CREATION =     0x00000040;   
public static final int FILE_NOTIFY_CHANGE_SECURITY =     0x00000100;   
public static final int FILE_ACTION_ADDED =                   0x00000001;   
public static final int FILE_ACTION_REMOVED =                 0x00000002;   
public static final int FILE_ACTION_MODIFIED =                0x00000003;   
public static final int FILE_ACTION_RENAMED_OLD_NAME =        0x00000004;   
public static final int FILE_ACTION_RENAMED_NEW_NAME =        0x00000005;   
public static final int MAILSLOT_NO_MESSAGE =             ((int)-1); 
public static final int MAILSLOT_WAIT_FOREVER =           ((int)-1); 
public static final int FILE_CASE_SENSITIVE_SEARCH =          0x00000001;  
public static final int FILE_CASE_PRESERVED_NAMES =           0x00000002;  
public static final int FILE_UNICODE_ON_DISK =                0x00000004;  
public static final int FILE_PERSISTENT_ACLS =                0x00000008;  
public static final int FILE_FILE_COMPRESSION =               0x00000010;  
public static final int FILE_VOLUME_QUOTAS =                  0x00000020;  
public static final int FILE_SUPPORTS_SPARSE_FILES =          0x00000040;  
public static final int FILE_SUPPORTS_REPARSE_POINTS =        0x00000080;  
public static final int FILE_SUPPORTS_REMOTE_STORAGE =        0x00000100;  
public static final int FILE_VOLUME_IS_COMPRESSED =           0x00008000;  
public static final int FILE_SUPPORTS_OBJECT_IDS =            0x00010000;  
public static final int FILE_SUPPORTS_ENCRYPTION =            0x00020000;  
public static final int FILE_NAMED_STREAMS =                  0x00040000;  
public static final int FILE_READ_ONLY_VOLUME =               0x00080000;  
public static final int FILE_SEQUENTIAL_WRITE_ONCE =          0x00100000;  
public static final int FILE_SUPPORTS_TRANSACTIONS =          0x00200000;  
public static final int FILE_SUPPORTS_HARD_LINKS =            0x00400000;  
public static final int FILE_SUPPORTS_EXTENDED_ATTRIBUTES =   0x00800000;  
public static final int FILE_SUPPORTS_OPEN_BY_FILE_ID =       0x01000000;  
public static final int FILE_SUPPORTS_USN_JOURNAL =           0x02000000;  
public static final int FILE_SUPPORTS_INTEGRITY_STREAMS =     0x04000000;  
public static final long FILE_INVALID_FILE_ID =               ((long)-1L);
// Targeting ..\windows\FILE_ID_128.java


// Targeting ..\windows\FILE_NOTIFY_INFORMATION.java


// Targeting ..\windows\FILE_SEGMENT_ELEMENT.java


// Targeting ..\windows\REPARSE_GUID_DATA_BUFFER.java



public static native @MemberGetter int REPARSE_GUID_DATA_BUFFER_HEADER_SIZE();
public static final int REPARSE_GUID_DATA_BUFFER_HEADER_SIZE = REPARSE_GUID_DATA_BUFFER_HEADER_SIZE();

//
// Maximum allowed size of the reparse data.
//

public static final int MAXIMUM_REPARSE_DATA_BUFFER_SIZE =      ( 16 * 1024 );

//
// Predefined reparse tags.
// These tags need to avoid conflicting with IO_REMOUNT defined in ntos\inc\io.h
//

public static final int IO_REPARSE_TAG_RESERVED_ZERO =             (0);
public static final int IO_REPARSE_TAG_RESERVED_ONE =              (1);

//
// The value of the following constant needs to satisfy the following conditions:
//  (1) Be at least as large as the largest of the reserved tags.
//  (2) Be strictly smaller than all the tags in use.
//

public static final int IO_REPARSE_TAG_RESERVED_RANGE =            IO_REPARSE_TAG_RESERVED_ONE;

//
// The reparse tags are a DWORD. The 32 bits are laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-----------------------+-------------------------------+
//  |M|R|N|R|     Reserved bits     |       Reparse Tag Value       |
//  +-+-+-+-+-----------------------+-------------------------------+
//
// M is the Microsoft bit. When set to 1, it denotes a tag owned by Microsoft.
//   All ISVs must use a tag with a 0 in this position.
//   Note: If a Microsoft tag is used by non-Microsoft software, the
//   behavior is not defined.
//
// R is reserved.  Must be zero for non-Microsoft tags.
//
// N is name surrogate. When set to 1, the file represents another named
//   entity in the system.
//
// The M and N bits are OR-able.
// The following macros check for the M and N bit values:
//

//
// Macro to determine whether a reparse point tag corresponds to a tag
// owned by Microsoft.
//

// #define IsReparseTagMicrosoft(_tag) (
//                            ((_tag) & 0x80000000)
//                            )

//
// Macro to determine whether a reparse point tag is a name surrogate
//

// #define IsReparseTagNameSurrogate(_tag) (
//                            ((_tag) & 0x20000000)
//                            )

public static final long IO_REPARSE_TAG_MOUNT_POINT =              (0xA0000003L);       
public static final long IO_REPARSE_TAG_HSM =                      (0xC0000004L);       
public static final long IO_REPARSE_TAG_HSM2 =                     (0x80000006L);       
public static final long IO_REPARSE_TAG_SIS =                      (0x80000007L);       
public static final long IO_REPARSE_TAG_WIM =                      (0x80000008L);       
public static final long IO_REPARSE_TAG_CSV =                      (0x80000009L);       
public static final long IO_REPARSE_TAG_DFS =                      (0x8000000AL);       
public static final long IO_REPARSE_TAG_SYMLINK =                  (0xA000000CL);       
public static final long IO_REPARSE_TAG_DFSR =                     (0x80000012L);       
public static final long IO_REPARSE_TAG_DEDUP =                    (0x80000013L);       
public static final long IO_REPARSE_TAG_NFS =                      (0x80000014L);       
public static final long IO_REPARSE_TAG_FILE_PLACEHOLDER =         (0x80000015L);       
public static final long IO_REPARSE_TAG_WOF =                      (0x80000017L);       

// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)

// #endif /*_WIN32_WINNT >= _WIN32_WINNT_WIN8 */

// WINBLUE_abracadabra
//
// N.B. The following #if check needs to be against NTDDI_WINBLUE when it becomes available.
// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)

// #endif // (_WIN32_WINNT >= _WIN32_WINNT_WIN8)

// begin_winioctl begin_ntosifs
//
//=============== END FileSystem FSCTL Structure Defintions ==================
//

//
// I/O Completion Specific Access Rights.
//

public static final int IO_COMPLETION_MODIFY_STATE =  0x0002;  
public static final long IO_COMPLETION_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3); 

//
// Object Manager Symbolic Link Specific Access Rights.
//

public static final int DUPLICATE_CLOSE_SOURCE =      0x00000001;  
public static final int DUPLICATE_SAME_ACCESS =       0x00000002;  

//
// =========================================
// Define GUIDs which represent well-known power schemes
// =========================================
//

//
// Maximum Power Savings - indicates that very aggressive power savings measures will be used to help
//                         stretch battery life.
//
// {a1841308-3541-4fab-bc81-f71556f20b4a}
//
@MemberGetter public static native @Const @ByRef GUID GUID_MAX_POWER_SAVINGS();

//
// No Power Savings - indicates that almost no power savings measures will be used.
//
// {8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c}
//
@MemberGetter public static native @Const @ByRef GUID GUID_MIN_POWER_SAVINGS();

//
// Typical Power Savings - indicates that fairly aggressive power savings measures will be used.
//
// {381b4222-f694-41f0-9685-ff5bb260df2e}
//
@MemberGetter public static native @Const @ByRef GUID GUID_TYPICAL_POWER_SAVINGS();

//
// This is a special GUID that represents "no subgroup" of settings.  That is, it indicates
// that settings that are in the root of the power policy hierarchy as opposed to settings
// that are buried under a subgroup of settings.  This should be used when querying for
// power settings that may not fall into a subgroup.
//
@MemberGetter public static native @Const @ByRef GUID NO_SUBGROUP_GUID();

//
// This is a special GUID that represents "every power scheme".  That is, it indicates
// that any write to this power scheme should be reflected to every scheme present.
// This allows users to write a single setting once and have it apply to all schemes.  They
// can then apply custom settings to specific power schemes that they care about.
//
@MemberGetter public static native @Const @ByRef GUID ALL_POWERSCHEMES_GUID();

//
// This is a special GUID that represents a 'personality' that each power scheme will have.
// In other words, each power scheme will have this key indicating "I'm most like *this* base
// power scheme."  This individual setting will have one of three settings:
// GUID_MAX_POWER_SAVINGS
// GUID_MIN_POWER_SAVINGS
// GUID_TYPICAL_POWER_SAVINGS
//
// This allows several features:
// 1. Drivers and applications can register for notification of this GUID.  So when this power
//    scheme is activiated, this GUID's setting will be sent across the system and drivers/applications
//    can see "GUID_MAX_POWER_SAVINGS" which will tell them in a generic fashion "get real aggressive
//    about conserving power".
// 2. UserB may install a driver or application which creates power settings, and UserB may modify
//    those power settings.  Now UserA logs in.  How does he see those settings?  They simply don't
//    exist in his private power key.  Well they do exist over in the system power key.  When we
//    enumerate all the power settings in this system power key and don't find a corresponding entry
//    in the user's private power key, then we can go look at this "personality" key in the users
//    power scheme.  We can then go get a default value for the power setting, depending on which
//    "personality" power scheme is being operated on.  Here's an example:
//    A. UserB installs an application that creates a power setting Seetting1
//    B. UserB changes Setting1 to have a value of 50 because that's one of the possible settings
//       available for setting1.
//    C. UserB logs out
//    D. UserA logs in and his active power scheme is some custom scheme that was derived from
//       the GUID_TYPICAL_POWER_SAVINGS.  But remember that UserA has no setting1 in his
//       private power key.
//    E. When activating UserA's selected power scheme, all power settings in the system power key will
//       be enumerated (including Setting1).
//    F. The power manager will see that UserA has no Setting1 power setting in his private power scheme.
//    G. The power manager will query UserA's power scheme for its personality and retrieve
//       GUID_TYPICAL_POWER_SAVINGS.
//    H. The power manager then looks in Setting1 in the system power key and looks in its set of default
//       values for the corresponding value for GUID_TYPICAL_POWER_SAVINGS power schemes.
//    I. This derived power setting is applied.
@MemberGetter public static native @Const @ByRef GUID GUID_POWERSCHEME_PERSONALITY();

//
// Define a special GUID which will be used to define the active power scheme.
// User will register for this power setting GUID, and when the active power
// scheme changes, they'll get a callback where the payload is the GUID
// representing the active powerscheme.
// ( 31F9F286-5084-42FE-B720-2B0264993763 }
//
@MemberGetter public static native @Const @ByRef GUID GUID_ACTIVE_POWERSCHEME();

//
// =========================================
// Define GUIDs which represent well-known power settings
// =========================================
//

// Idle resiliency settings
// -------------------------
//
// Specifies the subgroup which will contain all of the idle resiliency
// settings for a single policy.
//
// {2E601130-5351-4d9d-8E04-252966BAD054}
@MemberGetter public static native @Const @ByRef GUID GUID_IDLE_RESILIENCY_SUBGROUP();

//
// Specifies the maximum clock interrupt period (in ms)
//
// {C42B79AA-AA3A-484b-A98F-2CF32AA90A28}
@MemberGetter public static native @Const @ByRef GUID GUID_IDLE_RESILIENCY_PERIOD();

//
// Specifies the platform idle state index associated with idle resiliency
// period.
//
// {D23F2FB8-9536-4038-9C94-1CE02E5C2152}


//
// Specifies (in milliseconds) how long we wait after the last disk access
// before we power off the disk in case when IO coalescing is active.
//
// {C36F0EB4-2988-4a70-8EEE-0884FC2C2433}
@MemberGetter public static native @Const @ByRef GUID GUID_DISK_COALESCING_POWERDOWN_TIMEOUT();

//
// Specifies (in seconds) how long we wait after the CS Enter before
// we deactivate execution required request.
//
//   0 : implies execution power requests are disabled and have no effect
//  -1 : implies execution power requests are never deactivated
//
// Note: Execution required power requests are mapped into system required
//      power requests on non-AoAc machines and this value has no effect.
//
// {3166BC41-7E98-4e03-B34E-EC0F5F2B218E}
@MemberGetter public static native @Const @ByRef GUID GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT();


// Video settings
// --------------
//
// Specifies the subgroup which will contain all of the video
// settings for a single policy.
//
@MemberGetter public static native @Const @ByRef GUID GUID_VIDEO_SUBGROUP();

//
// Specifies (in seconds) how long we wait after the last user input has been
// recieved before we power off the video.
//
@MemberGetter public static native @Const @ByRef GUID GUID_VIDEO_POWERDOWN_TIMEOUT();

//
// Specifies whether adaptive display dimming is turned on or off.
// 82DBCF2D-CD67-40C5-BFDC-9F1A5CCD4663
//
@MemberGetter public static native @Const @ByRef GUID GUID_VIDEO_ANNOYANCE_TIMEOUT();

//
// Specifies how much adaptive dim time out will be increased by.
// EED904DF-B142-4183-B10B-5A1197A37864
//
@MemberGetter public static native @Const @ByRef GUID GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE();

//
// Specifies (in seconds) how long we wait after the last user input has been
// recieved before we dim the video.
//
@MemberGetter public static native @Const @ByRef GUID GUID_VIDEO_DIM_TIMEOUT();

//
// Specifies if the operating system should use adaptive timers (based on
// previous behavior) to power down the video,
//
@MemberGetter public static native @Const @ByRef GUID GUID_VIDEO_ADAPTIVE_POWERDOWN();

//
// Specifies if the monitor is currently being powered or not.
// 02731015-4510-4526-99E6-E5A17EBD1AEA
//
@MemberGetter public static native @Const @ByRef GUID GUID_MONITOR_POWER_ON();

//
// Monitor brightness policy when in normal state
// {aded5e82-b909-4619-9949-f5d71dac0bcb}
@MemberGetter public static native @Const @ByRef GUID GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS();

//
//
// Monitor brightness policy when in dim state
// {f1fbfde2-a960-4165-9f88-50667911ce96}
@MemberGetter public static native @Const @ByRef GUID GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS();

//
// Current Monitor brightness
// {8ffee2c6-2d01-46be-adb9-398addc5b4ff}
@MemberGetter public static native @Const @ByRef GUID GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS();


//
// Specifies if the operating system should use ambient light sensor to change
// disply brightness adatively.
// {FBD9AA66-9553-4097-BA44-ED6E9D65EAB8}
@MemberGetter public static native @Const @ByRef GUID GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS();

//
// Specifies a change in the current monitor's display state.
// 6fe69556-704a-47a0-8f24-c28d936fda47
//
@MemberGetter public static native @Const @ByRef GUID GUID_CONSOLE_DISPLAY_STATE();

//
// Defines a guid for enabling/disabling the ability to create display required
// power requests.
//
// {A9CEB8DA-CD46-44FB-A98B-02AF69DE4623}
//
@MemberGetter public static native @Const @ByRef GUID GUID_ALLOW_DISPLAY_REQUIRED();

//
// Specifies the video power down timeout (in seconds) after the interactive
// console is locked (and sensors indicate UserNotPresent). Value 0
// effectively disables this feature.
//
// {8EC4B3A5-6868-48c2-BE75-4F3044BE88A7}
@MemberGetter public static native @Const @ByRef GUID GUID_VIDEO_CONSOLE_LOCK_TIMEOUT();


// Adaptive power behavior settings
// --------------------------------
//
// {8619B916-E004-4dd8-9B66-DAE86F806698}
@MemberGetter public static native @Const @ByRef GUID GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP();

//
// Specifies the input timeout (in seconds) to be used to indicate UserUnkown.
// Value 0 effectively disables this feature.
//
// {5ADBBFBC-074E-4da1-BA38-DB8B36B2C8F3}
@MemberGetter public static native @Const @ByRef GUID GUID_NON_ADAPTIVE_INPUT_TIMEOUT();

// Harddisk settings
// -----------------
//
// Specifies the subgroup which will contain all of the harddisk
// settings for a single policy.
//
@MemberGetter public static native @Const @ByRef GUID GUID_DISK_SUBGROUP();

//
// Specifies (in seconds) how long we wait after the last disk access
// before we power off the disk.
//
@MemberGetter public static native @Const @ByRef GUID GUID_DISK_POWERDOWN_TIMEOUT();

//
// Specifies (in milliseconds) how long we wait after the last disk access
// before we power off the disk taking into account if IO coalescing is active.
//
// {58E39BA8-B8E6-4EF6-90D0-89AE32B258D6}
@MemberGetter public static native @Const @ByRef GUID GUID_DISK_IDLE_TIMEOUT();

//
// Specifies the amount of contiguous disk activity time to ignore when
// calculating disk idleness.
//
// 80e3c60e-bb94-4ad8-bbe0-0d3195efc663
//

@MemberGetter public static native @Const @ByRef GUID GUID_DISK_BURST_IGNORE_THRESHOLD();

//
// Specifies if the operating system should use adaptive timers (based on
// previous behavior) to power down the disk,
//
@MemberGetter public static native @Const @ByRef GUID GUID_DISK_ADAPTIVE_POWERDOWN();

// System sleep settings
// ---------------------
//
// Specifies the subgroup which will contain all of the sleep
// settings for a single policy.
// { 238C9FA8-0AAD-41ED-83F4-97BE242C8F20 }
//
@MemberGetter public static native @Const @ByRef GUID GUID_SLEEP_SUBGROUP();

//
// Specifies an idle treshold percentage (0-100). The system must be this idle
// over a period of time in order to idle to sleep.
//
// N.B. DEPRECATED IN WINDOWS 6.1
//
@MemberGetter public static native @Const @ByRef GUID GUID_SLEEP_IDLE_THRESHOLD();

//
// Specifies (in seconds) how long we wait after the system is deemed
// "idle" before moving to standby (S1, S2 or S3).
//
@MemberGetter public static native @Const @ByRef GUID GUID_STANDBY_TIMEOUT();

//
// Specifies (in seconds) how long the system should go back to sleep after
// waking unattended. 0 indicates that the standard standby/hibernate idle
// policy should be used instead.
//
// {7bc4a2f9-d8fc-4469-b07b-33eb785aaca0}
//
@MemberGetter public static native @Const @ByRef GUID GUID_UNATTEND_SLEEP_TIMEOUT();

//
// Specifies (in seconds) how long we wait after the system is deemed
// "idle" before moving to hibernate (S4).
//
@MemberGetter public static native @Const @ByRef GUID GUID_HIBERNATE_TIMEOUT();

//
// Specifies whether or not Fast S4 should be enabled if the system supports it
// 94AC6D29-73CE-41A6-809F-6363BA21B47E
//
@MemberGetter public static native @Const @ByRef GUID GUID_HIBERNATE_FASTS4_POLICY();

//
// Define a GUID for controlling the criticality of sleep state transitions.
// Critical sleep transitions do not query applications, services or drivers
// before transitioning the platform to a sleep state.
//
// {B7A27025-E569-46c2-A504-2B96CAD225A1}
//
@MemberGetter public static native @Const @ByRef GUID GUID_CRITICAL_POWER_TRANSITION();

//
// Specifies if the system is entering or exiting 'away mode'.
// 98A7F580-01F7-48AA-9C0F-44352C29E5C0
//
@MemberGetter public static native @Const @ByRef GUID GUID_SYSTEM_AWAYMODE();

// Specify whether away mode is allowed
//
// {25DFA149-5DD1-4736-B5AB-E8A37B5B8187}
//
@MemberGetter public static native @Const @ByRef GUID GUID_ALLOW_AWAYMODE();

//
// Full-screen video playback GUID
// {3D5938F0-FF20-41EF-AE9F-EEA006F422E1}
//


//
// Audio playback GUID
// {23B61359-2977-4c74-8207-37BCA1400D9D}
//



//
// Defines a guid for enabling/disabling standby (S1-S3) states. This does not
// affect hibernation (S4).
//
// {abfc2519-3608-4c2a-94ea-171b0ed546ab}
//
@MemberGetter public static native @Const @ByRef GUID GUID_ALLOW_STANDBY_STATES();

//
// Defines a guid for enabling/disabling the ability to wake via RTC.
//
// {BD3B718A-0680-4D9D-8AB2-E1D2B4AC806D}
//
@MemberGetter public static native @Const @ByRef GUID GUID_ALLOW_RTC_WAKE();

//
// Defines a guid for enabling/disabling the ability to create system required
// power requests.
//
// {A4B195F5-8225-47D8-8012-9D41369786E2}
//
@MemberGetter public static native @Const @ByRef GUID GUID_ALLOW_SYSTEM_REQUIRED();

// System button actions
// ---------------------
//
//
// Specifies the subgroup which will contain all of the system button
// settings for a single policy.
//
@MemberGetter public static native @Const @ByRef GUID GUID_SYSTEM_BUTTON_SUBGROUP();

public static final int POWERBUTTON_ACTION_INDEX_NOTHING =    0;
public static final int POWERBUTTON_ACTION_INDEX_SLEEP =      1;
public static final int POWERBUTTON_ACTION_INDEX_HIBERNATE =  2;
public static final int POWERBUTTON_ACTION_INDEX_SHUTDOWN =   3;

//
// System button values which contain the PowerAction* value for each action.
//

public static final int POWERBUTTON_ACTION_VALUE_NOTHING =    0;
public static final int POWERBUTTON_ACTION_VALUE_SLEEP =      2;
public static final int POWERBUTTON_ACTION_VALUE_HIBERNATE =  3;
public static final int POWERBUTTON_ACTION_VALUE_SHUTDOWN =   6;

// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system power button is pressed.
//
@MemberGetter public static native @Const @ByRef GUID GUID_POWERBUTTON_ACTION();

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system sleep button is pressed.
//
@MemberGetter public static native @Const @ByRef GUID GUID_SLEEPBUTTON_ACTION();

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system sleep button is pressed.
// { A7066653-8D6C-40A8-910E-A1F54B84C7E5 }
//
@MemberGetter public static native @Const @ByRef GUID GUID_USERINTERFACEBUTTON_ACTION();

//
// Specifies (in a POWER_ACTION_POLICY structure) the appropriate action to
// take when the system lid is closed.
//
@MemberGetter public static native @Const @ByRef GUID GUID_LIDCLOSE_ACTION();
@MemberGetter public static native @Const @ByRef GUID GUID_LIDOPEN_POWERSTATE();


// Battery Discharge Settings
// --------------------------
//
// Specifies the subgroup which will contain all of the battery discharge
// settings for a single policy.
//
@MemberGetter public static native @Const @ByRef GUID GUID_BATTERY_SUBGROUP();

//
// 4 battery discharge alarm settings.
//
// GUID_BATTERY_DISCHARGE_ACTION_x - This is the action to take.  It is a value
//                                   of type POWER_ACTION
// GUID_BATTERY_DISCHARGE_LEVEL_x  - This is the battery level (%)
// GUID_BATTERY_DISCHARGE_FLAGS_x  - Flags defined below:
//                                   POWER_ACTION_POLICY->EventCode flags
//                                   BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK
//                                   BATTERY_DISCHARGE_FLAGS_ENABLE
@MemberGetter public static native @Const @ByRef GUID GUID_BATTERY_DISCHARGE_ACTION_0();
@MemberGetter public static native @Const @ByRef GUID GUID_BATTERY_DISCHARGE_LEVEL_0();
@MemberGetter public static native @Const @ByRef GUID GUID_BATTERY_DISCHARGE_FLAGS_0();

@MemberGetter public static native @Const @ByRef GUID GUID_BATTERY_DISCHARGE_ACTION_1();
@MemberGetter public static native @Const @ByRef GUID GUID_BATTERY_DISCHARGE_LEVEL_1();
@MemberGetter public static native @Const @ByRef GUID GUID_BATTERY_DISCHARGE_FLAGS_1();

@MemberGetter public static native @Const @ByRef GUID GUID_BATTERY_DISCHARGE_ACTION_2();
@MemberGetter public static native @Const @ByRef GUID GUID_BATTERY_DISCHARGE_LEVEL_2();
@MemberGetter public static native @Const @ByRef GUID GUID_BATTERY_DISCHARGE_FLAGS_2();

@MemberGetter public static native @Const @ByRef GUID GUID_BATTERY_DISCHARGE_ACTION_3();
@MemberGetter public static native @Const @ByRef GUID GUID_BATTERY_DISCHARGE_LEVEL_3();
@MemberGetter public static native @Const @ByRef GUID GUID_BATTERY_DISCHARGE_FLAGS_3();





// Processor power settings
// ------------------------
//

// Specifies the subgroup which will contain all of the processor
// settings for a single policy.
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_SETTINGS_SUBGROUP();

//
// Specifies various attributes that control processor performance/throttle
// states.
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_THROTTLE_POLICY();

public static final int PERFSTATE_POLICY_CHANGE_IDEAL =  0;
public static final int PERFSTATE_POLICY_CHANGE_SINGLE = 1;
public static final int PERFSTATE_POLICY_CHANGE_ROCKET = 2;
public static final int PERFSTATE_POLICY_CHANGE_IDEAL_AGGRESSIVE = 3;

public static final int PERFSTATE_POLICY_CHANGE_DECREASE_MAX = PERFSTATE_POLICY_CHANGE_ROCKET;
public static final int PERFSTATE_POLICY_CHANGE_INCREASE_MAX = PERFSTATE_POLICY_CHANGE_IDEAL_AGGRESSIVE;

//
// Specifies a percentage (between 0 and 100) that the processor frequency
// should never go above.  For example, if this value is set to 80, then
// the processor frequency will never be throttled above 80 percent of its
// maximum frequency by the system.
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_THROTTLE_MAXIMUM();

//
// Specifies a percentage (between 0 and 100) that the processor frequency
// should not drop below.  For example, if this value is set to 50, then the
// processor frequency will never be throttled below 50 percent of its
// maximum frequency by the system.
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_THROTTLE_MINIMUM();

//
// Specifies whether throttle states are allowed to be used even when
// performance states are available.
//
// {3b04d4fd-1cc7-4f23-ab1c-d1337819c4bb}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_ALLOW_THROTTLING();

//
// Specifies processor power settings for CState policy data
// {68F262A7-F621-4069-B9A5-4874169BE23C}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_IDLESTATE_POLICY();

//
// Specifies processor power settings for PerfState policy data
// {BBDC3814-18E9-4463-8A55-D197327C45C0}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PERFSTATE_POLICY();

//
// Specifies the increase busy percentage threshold that must be met before
// increasing the processor performance state.
//
// {06cadf0e-64ed-448a-8927-ce7bf90eb35d}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PERF_INCREASE_THRESHOLD();

//
// Specifies the decrease busy percentage threshold that must be met before
// decreasing the processor performance state.
//
// {12a0ab44-fe28-4fa9-b3bd-4b64f44960a6}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PERF_DECREASE_THRESHOLD();

//
// Specifies, either as ideal, single or rocket, how aggressive performance
// states should be selected when increasing the processor performance state.
//
// {465E1F50-B610-473a-AB58-00D1077DC418}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PERF_INCREASE_POLICY();

//
// Specifies, either as ideal, single or rocket, how aggressive performance
// states should be selected when decreasing the processor performance state.
//
// {40FBEFC7-2E9D-4d25-A185-0CFD8574BAC6}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PERF_DECREASE_POLICY();

//
// Specifies, in milliseconds, the minimum amount of time that must elapse after
// the last processor performance state change before increasing the processor
// performance state.
//
// {984CF492-3BED-4488-A8F9-4286C97BF5AA}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PERF_INCREASE_TIME();

//
// Specifies, in milliseconds, the minimum amount of time that must elapse after
// the last processor performance state change before increasing the processor
// performance state.
//
// {D8EDEB9B-95CF-4f95-A73C-B061973693C8}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PERF_DECREASE_TIME();

//
// Specifies the time, in milliseconds, that must expire before considering
// a change in the processor performance states or parked core set.
//
// {4D2B0152-7D5C-498b-88E2-34345392A2C5}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PERF_TIME_CHECK();

//
// Specifies how the processor should manage performance and efficiency
// tradeoffs when boosting frequency above the maximum.
//
// {45BCC044-D885-43e2-8605-EE0EC6E96B59}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PERF_BOOST_POLICY();

public static final int PROCESSOR_PERF_BOOST_POLICY_DISABLED = 0;
public static final int PROCESSOR_PERF_BOOST_POLICY_MAX = 100;

//
// Specifies how a processor opportunistically increases frequency above
// the maximum when operating contitions allow it to do so safely.
//
// {BE337238-0D82-4146-A960-4F3749D470C7}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PERF_BOOST_MODE();

public static final int PROCESSOR_PERF_BOOST_MODE_DISABLED = 0;
public static final int PROCESSOR_PERF_BOOST_MODE_ENABLED = 1;
public static final int PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE = 2;
public static final int PROCESSOR_PERF_BOOST_MODE_EFFICIENT_ENABLED = 3;
public static final int PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE = 4;
public static final int PROCESSOR_PERF_BOOST_MODE_MAX = PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE;

//
// Specifies if idle state promotion and demotion values should be scaled based
// on the current peformance state.
//
// {6C2993B0-8F48-481f-BCC6-00DD2742AA06}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_IDLE_ALLOW_SCALING();

//
// Specifies if idle states should be disabled.
//
// {5D76A2CA-E8C0-402f-A133-2158492D58AD}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_IDLE_DISABLE();

//
// Specifies the deepest idle state type that should be used. If this value is
// set to zero, this setting is ignored. Values higher than supported by the
// processor then this setting has no effect.
//
// {9943e905-9a30-4ec1-9b99-44dd3b76f7a2}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_IDLE_STATE_MAXIMUM();

//
// Specifies the time that elapsed since the last idle state promotion or
// demotion before idle states may be promoted or demoted again (in
// microseconds).
//
// {C4581C31-89AB-4597-8E2B-9C9CAB440E6B}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_IDLE_TIME_CHECK();


//
// Specifies the upper busy threshold that must be met before demoting the
// processor to a lighter idle state (in percentage).
//
// {4B92D758-5A24-4851-A470-815D78AEE119}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD();

//
// Specifies the lower busy threshold that must be met before promoting the
// processor to a deeper idle state (in percentage).
//
// {7B224883-B3CC-4d79-819F-8374152CBE7C}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD();

//
// Specifies the utilization threshold in percent that must be crossed in order to un-park cores.
//
// {df142941-20f3-4edf-9a4a-9c83d3d717d1}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD();

//
// Specifies the utilization threshold in percent that must be crossed in order to park cores.
//
// {68dd2f27-a4ce-4e11-8487-3794e4135dfa}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD();

//
// Specifies, either as ideal, single or rocket, how aggressive core parking is when cores must be unparked.
//
// {c7be0679-2817-4d69-9d02-519a537ed0c6}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY();

public static final int CORE_PARKING_POLICY_CHANGE_IDEAL =  0;
public static final int CORE_PARKING_POLICY_CHANGE_SINGLE = 1;
public static final int CORE_PARKING_POLICY_CHANGE_ROCKET = 2;
public static final int CORE_PARKING_POLICY_CHANGE_MULTISTEP = 3;
public static final int CORE_PARKING_POLICY_CHANGE_MAX = CORE_PARKING_POLICY_CHANGE_MULTISTEP;

//
// Specifies, either as ideal, single or rocket, how aggressive core parking is when cores must be parked.
//
// {71021b41-c749-4d21-be74-a00f335d582b}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY();

//
// Specifies, on a per processor group basis, the maximum number of cores that can be kept unparked.
//
// {ea062031-0e34-4ff1-9b6d-eb1059334028}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_CORE_PARKING_MAX_CORES();

//
// Specifies, on a per processor group basis, the minimum number of cores that must be kept unparked.
//
// {0cc5b647-c1df-4637-891a-dec35c318583}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_CORE_PARKING_MIN_CORES();

//
// Specifies, in milliseconds, the minimum amount of time a core must be parked before it can be unparked.
//
// {2ddd5a84-5a71-437e-912a-db0b8c788732}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME();

//
// Specifies, in milliseconds, the minimum amount of time a core must be unparked before it can be parked.
//
// {dfd10d17-d5eb-45dd-877a-9a34ddd15c82}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME();

//
// Specifies the factor by which to decrease affinity history on each core after each check.
//
// {8f7b45e3-c393-480a-878c-f67ac3d07082}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR();

//
// Specifies the threshold above which a core is considered to have had significant affinitized work scheduled to it while parked.
//
// {5b33697b-e89d-4d38-aa46-9e7dfb7cd2f9}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD();

//
// Specifies the weighting given to each occurence where affinitized work was scheduled to a parked core.
//
// {e70867f1-fa2f-4f4e-aea1-4d8a0ba23b20}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING();

//
// Specifies the factor by which to decrease the over utilization history on each core after the current performance check.
//
// {1299023c-bc28-4f0a-81ec-d3295a8d815d}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR();

//
// Specifies the threshold above which a core is considered to have been recently over utilized while parked.
//
// {9ac18e92-aa3c-4e27-b307-01ae37307129}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD();

//
// Specifies the weighting given to each occurence where a parked core is found to be over utilized.
//
// {8809c2d8-b155-42d4-bcda-0d345651b1db}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING();

//
// Specifies, in percentage, the busy threshold that must be met before a parked core is considered over utilized.
//
// {943c8cb6-6f93-4227-ad87-e9a3feec08d1}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD();

//
// Specifies if at least one processor per core should always remain unparked.
//
// {a55612aa-f624-42c6-a443-7397d064c04f}
//

@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PARKING_CORE_OVERRIDE();

//
// Specifies what performance state a processor should enter when first parked.
//
// {447235c7-6a8d-4cc0-8e24-9eaf70b96e2b}
//

@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PARKING_PERF_STATE();

//
// Specify the busy threshold that must be met when calculating the concurrency of a node's workload.
//
// {2430ab6f-a520-44a2-9601-f7f23b5134b1}
//

@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD();

//
// Specify the busy threshold that must be met by all cores in a concurrency set to unpark an extra core.
//
// {f735a673-2066-4f80-a0c5-ddee0cf1bf5d}
//

@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD();

//
// Specifies the number of perf time check intervals to average utility over.
//
// N.B. This power setting is deprecated.
//
// {7d24baa7-0b84-480f-840c-1b0743c00f5f}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PERF_HISTORY();

//
// Specifies the number of perf time check intervals to average utility over to
// determine performance increase.
//
// {99B3EF01-752F-46a1-80FB-7730011F2354}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PERF_INCREASE_HISTORY();

//
// Specifies the number of perf time check intervals to average utility over to
// determine performance decrease.
//
// {0300F6F8-ABD6-45a9-B74F-4908691A40B5}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PERF_DECREASE_HISTORY();

//
// Specifies the number of perf time check intervals to average utility over for
// core parking.
//
// {77D7F282-8F1A-42cd-8537-45450A839BE8}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY();

//
// Specifies whether latency sensitivity hints should be taken into account by
// the perf state engine.
//
// N.B. This power setting is deprecated.
//
// {0822df31-9c83-441c-a079-0de4cf009c7b}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PERF_LATENCY_HINT();

//
// Specifies the processor performance state in response to latency sensitivity hints.
//
// {619b7505-003b-4e82-b7a6-4dd29c300971}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_PERF_LATENCY_HINT_PERF();

//
// Specifies whether the core parking engine should distribute processor
// utility.
//
// {e0007330-f589-42ed-a401-5ddb10e785d3}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PROCESSOR_DISTRIBUTE_UTILITY();

//
// Specifies active vs passive cooling.  Although not directly related to
// processor settings, it is the processor that gets throttled if we're doing
// passive cooling, so it is fairly strongly related.
// {94D3A615-A899-4AC5-AE2B-E4D8F634367F}
//
@MemberGetter public static native @Const @ByRef GUID GUID_SYSTEM_COOLING_POLICY();

// Lock Console on Wake
// --------------------
//

// Specifies the behavior of the system when we wake from standby or
// hibernate.  If this is set, then we will cause the console to lock
// after we resume.
//
@MemberGetter public static native @Const @ByRef GUID GUID_LOCK_CONSOLE_ON_WAKE();

// Device idle characteristics
// ---------------------------
//
// Specifies whether to use the "performance" or "conservative" timeouts for
// device idle management.
//
// 4faab71a-92e5-4726-b531-224559672d19
//
@MemberGetter public static native @Const @ByRef GUID GUID_DEVICE_IDLE_POLICY();

public static final int POWER_DEVICE_IDLE_POLICY_PERFORMANCE =  0;
public static final int POWER_DEVICE_IDLE_POLICY_CONSERVATIVE = 1;

// AC/DC power source
// ------------------
//

// Specifies the power source for the system.  consumers may register for
// notification when the power source changes and will be notified with
// one of 3 values:
// 0 - Indicates the system is being powered by an AC power source.
// 1 - Indicates the system is being powered by a DC power source.
// 2 - Indicates the system is being powered by a short-term DC power
//     source.  For example, this would be the case if the system is
//     being powed by a short-term battery supply in a backing UPS
//     system.  When this value is recieved, the consumer should make
//     preparations for either a system hibernate or system shutdown.
//
// { 5D3E9A59-E9D5-4B00-A6BD-FF34FF516548 }
@MemberGetter public static native @Const @ByRef GUID GUID_ACDC_POWER_SOURCE();

// Lid state changes
// -----------------
//
// Specifies the current state of the lid (open or closed). The callback won't
// be called at all until a lid device is found and its current state is known.
//
// Values:
//
// 0 - closed
// 1 - opened
//
// { BA3E0F4D-B817-4094-A2D1-D56379E6A0F3 }
//

@MemberGetter public static native @Const @ByRef GUID GUID_LIDSWITCH_STATE_CHANGE();

// Battery status changes
// ----------------------
//

// Specifies the percentage of battery life remaining.  The consumer
// may register for notification in order to track battery life in
// a fine-grained manner.
//
// Once registered, the consumer can expect to be notified as the battery
// life percentage changes.
//
// The consumer will recieve a value between 0 and 100 (inclusive) which
// indicates percent battery life remaining.
//
// { A7AD8041-B45A-4CAE-87A3-EECBB468A9E1 }
@MemberGetter public static native @Const @ByRef GUID GUID_BATTERY_PERCENTAGE_REMAINING();

//
// Global notification indicating to listeners user activity/presence accross
// all sessions in the system (Present, NotPresent, Inactive)
//
// {786E8A1D-B427-4344-9207-09E70BDCBEA9}
@MemberGetter public static native @Const @ByRef GUID GUID_GLOBAL_USER_PRESENCE();

//
// Session specific notification indicating to listeners whether or not the display
// related to the given session is on/off/dim
//
// N.B. This is a session-specific notification, sent only to interactive
//      session registrants. Session 0 and kernel mode consumers do not receive
//      this notification.
//
// {2B84C20E-AD23-4ddf-93DB-05FFBD7EFCA5}
@MemberGetter public static native @Const @ByRef GUID GUID_SESSION_DISPLAY_STATUS();

//
// Session specific notification indicating to listeners user activity/presence
//(Present, NotPresent, Inactive)
//
// N.B. This is a session-specific notification, sent only to interactive
//      session registrants. Session 0 and kernel mode consumers do not receive
//      this notification.
// {3C0F4548-C03F-4c4d-B9F2-237EDE686376}
@MemberGetter public static native @Const @ByRef GUID GUID_SESSION_USER_PRESENCE();


// Notification to listeners that the system is fairly busy and won't be moving
// into an idle state any time soon.  This can be used as a hint to listeners
// that now might be a good time to do background tasks.
//
@MemberGetter public static native @Const @ByRef GUID GUID_IDLE_BACKGROUND_TASK();

// Notification to listeners that the system is fairly busy and won't be moving
// into an idle state any time soon.  This can be used as a hint to listeners
// that now might be a good time to do background tasks.
//
// { CF23F240-2A54-48D8-B114-DE1518FF052E }
@MemberGetter public static native @Const @ByRef GUID GUID_BACKGROUND_TASK_NOTIFICATION();

// Define a GUID that will represent the action of a direct experience button
// on the platform.  Users will register for this DPPE setting and recieve
// notification when the h/w button is pressed.
//
// { 1A689231-7399-4E9A-8F99-B71F999DB3FA }
//
@MemberGetter public static native @Const @ByRef GUID GUID_APPLAUNCH_BUTTON();

// PCI Express power settings
// ------------------------
//

// Specifies the subgroup which will contain all of the PCI Express
// settings for a single policy.
//
// {501a4d13-42af-4429-9fd1-a8218c268e20}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PCIEXPRESS_SETTINGS_SUBGROUP();

// Specifies the PCI Express ASPM power policy.
//
// {ee12f906-d277-404b-b6da-e5fa1a576df5}
//
@MemberGetter public static native @Const @ByRef GUID GUID_PCIEXPRESS_ASPM_POLICY();

// POWER Shutdown settings
// ------------------------
//

// Specifies if forced shutdown should be used for all button and lid initiated
// shutdown actions.
//
// {833a6b62-dfa4-46d1-82f8-e09e34d029d6}
//

@MemberGetter public static native @Const @ByRef GUID GUID_ENABLE_SWITCH_FORCED_SHUTDOWN();

// Interrupt Steering power settings
// ------------------------
//

// {48672F38-7A9A-4bb2-8BF8-3D85BE19DE4E}
@MemberGetter public static native @Const @ByRef GUID GUID_INTSTEER_SUBGROUP();

// {2BFC24F9-5EA2-4801-8213-3DBAE01AA39D}
@MemberGetter public static native @Const @ByRef GUID GUID_INTSTEER_MODE();

// {73CDE64D-D720-4bb2-A860-C755AFE77EF2}
@MemberGetter public static native @Const @ByRef GUID GUID_INTSTEER_LOAD_PER_PROC_TRIGGER();

// {D6BA4903-386F-4c2c-8ADB-5C21B3328D25}
@MemberGetter public static native @Const @ByRef GUID GUID_INTSTEER_TIME_UNPARK_TRIGGER();


/** enum SYSTEM_POWER_STATE */
public static final int
    PowerSystemUnspecified = 0,
    PowerSystemWorking     = 1,
    PowerSystemSleeping1   = 2,
    PowerSystemSleeping2   = 3,
    PowerSystemSleeping3   = 4,
    PowerSystemHibernate   = 5,
    PowerSystemShutdown    = 6,
    PowerSystemMaximum     = 7;

public static final int POWER_SYSTEM_MAXIMUM = 7;

/** enum POWER_ACTION */
public static final int
    PowerActionNone = 0,
    PowerActionReserved = 1,
    PowerActionSleep = 2,
    PowerActionHibernate = 3,
    PowerActionShutdown = 4,
    PowerActionShutdownReset = 5,
    PowerActionShutdownOff = 6,
    PowerActionWarmEject = 7;

/** enum DEVICE_POWER_STATE */
public static final int
    PowerDeviceUnspecified = 0,
    PowerDeviceD0 = 1,
    PowerDeviceD1 = 2,
    PowerDeviceD2 = 3,
    PowerDeviceD3 = 4,
    PowerDeviceMaximum = 5;

/** enum MONITOR_DISPLAY_STATE */
public static final int
    PowerMonitorOff = 0,
    PowerMonitorOn = 1,
    PowerMonitorDim = 2;

/** enum USER_ACTIVITY_PRESENCE */
public static final int
    PowerUserPresent = 0,
    PowerUserNotPresent = 1,
    PowerUserInactive = 2,
    PowerUserMaximum = 3,
    PowerUserInvalid = PowerUserMaximum;



public static final int ES_SYSTEM_REQUIRED =   ((int)0x00000001);
public static final int ES_DISPLAY_REQUIRED =  ((int)0x00000002);
public static final int ES_USER_PRESENT =      ((int)0x00000004);
public static final int ES_AWAYMODE_REQUIRED = ((int)0x00000040);
public static final int ES_CONTINUOUS =        ((int)0x80000000);

/** enum LATENCY_TIME */
public static final int
    LT_DONT_CARE = 0,
    LT_LOWEST_LATENCY = 1;

public static final int DIAGNOSTIC_REASON_VERSION =              0;

public static final int DIAGNOSTIC_REASON_SIMPLE_STRING =        0x00000001;
public static final int DIAGNOSTIC_REASON_DETAILED_STRING =      0x00000002;
public static final int DIAGNOSTIC_REASON_NOT_SPECIFIED =        0x80000000;
public static final int DIAGNOSTIC_REASON_INVALID_FLAGS =        (~0x80000003);

//
// Defines for power request APIs
//

public static final int POWER_REQUEST_CONTEXT_VERSION =          0;

public static final int POWER_REQUEST_CONTEXT_SIMPLE_STRING =    0x00000001;
public static final int POWER_REQUEST_CONTEXT_DETAILED_STRING =  0x00000002;

/** enum POWER_REQUEST_TYPE */
public static final int
    PowerRequestDisplayRequired = 0,
    PowerRequestSystemRequired = 1,
    PowerRequestAwayModeRequired = 2,
    PowerRequestExecutionRequired = 3;

// end_ntminiport

// #if (NTDDI_VERSION >= NTDDI_WINXP)

//-----------------------------------------------------------------------------
// Device Power Information
// Accessable via CM_Get_DevInst_Registry_Property_Ex(CM_DRP_DEVICE_POWER_DATA)
//-----------------------------------------------------------------------------

public static final int PDCAP_D0_SUPPORTED =              0x00000001;
public static final int PDCAP_D1_SUPPORTED =              0x00000002;
public static final int PDCAP_D2_SUPPORTED =              0x00000004;
public static final int PDCAP_D3_SUPPORTED =              0x00000008;
public static final int PDCAP_WAKE_FROM_D0_SUPPORTED =    0x00000010;
public static final int PDCAP_WAKE_FROM_D1_SUPPORTED =    0x00000020;
public static final int PDCAP_WAKE_FROM_D2_SUPPORTED =    0x00000040;
public static final int PDCAP_WAKE_FROM_D3_SUPPORTED =    0x00000080;
public static final int PDCAP_WARM_EJECT_SUPPORTED =      0x00000100;
// Targeting ..\windows\CM_POWER_DATA.java



// #endif // (NTDDI_VERSION >= NTDDI_WINXP)

// begin_wdm

/** enum POWER_INFORMATION_LEVEL */
public static final int
    SystemPowerPolicyAc = 0,
    SystemPowerPolicyDc = 1,
    VerifySystemPolicyAc = 2,
    VerifySystemPolicyDc = 3,
    SystemPowerCapabilities = 4,
    SystemBatteryState = 5,
    SystemPowerStateHandler = 6,
    ProcessorStateHandler = 7,
    SystemPowerPolicyCurrent = 8,
    AdministratorPowerPolicy = 9,
    SystemReserveHiberFile = 10,
    ProcessorInformation = 11,
    SystemPowerInformation = 12,
    ProcessorStateHandler2 = 13,
    LastWakeTime = 14,                                   // Compare with KeQueryInterruptTime()
    LastSleepTime = 15,                                  // Compare with KeQueryInterruptTime()
    SystemExecutionState = 16,
    SystemPowerStateNotifyHandler = 17,
    ProcessorPowerPolicyAc = 18,
    ProcessorPowerPolicyDc = 19,
    VerifyProcessorPowerPolicyAc = 20,
    VerifyProcessorPowerPolicyDc = 21,
    ProcessorPowerPolicyCurrent = 22,
    SystemPowerStateLogging = 23,
    SystemPowerLoggingEntry = 24,
    SetPowerSettingValue = 25,
    NotifyUserPowerSetting = 26,
    PowerInformationLevelUnused0 = 27,
    SystemMonitorHiberBootPowerOff = 28,
    SystemVideoState = 29,
    TraceApplicationPowerMessage = 30,
    TraceApplicationPowerMessageEnd = 31,
    ProcessorPerfStates = 32,
    ProcessorIdleStates = 33,
    ProcessorCap = 34,
    SystemWakeSource = 35,
    SystemHiberFileInformation = 36,
    TraceServicePowerMessage = 37,
    ProcessorLoad = 38,
    PowerShutdownNotification = 39,
    MonitorCapabilities = 40,
    SessionPowerInit = 41,
    SessionDisplayState = 42,
    PowerRequestCreate = 43,
    PowerRequestAction = 44,
    GetPowerRequestList = 45,
    ProcessorInformationEx = 46,
    NotifyUserModeLegacyPowerEvent = 47,
    GroupPark = 48,
    ProcessorIdleDomains = 49,
    WakeTimerList = 50,
    SystemHiberFileSize = 51,
    ProcessorIdleStatesHv = 52,
    ProcessorPerfStatesHv = 53,
    ProcessorPerfCapHv = 54,
    ProcessorSetIdle = 55,
    LogicalProcessorIdling = 56,
    UserPresence = 57,
    PowerSettingNotificationName = 58,
    GetPowerSettingValue = 59,
    IdleResiliency = 60,
    SessionRITState = 61,
    SessionConnectNotification = 62,
    SessionPowerCleanup = 63,
    SessionLockState = 64,
    SystemHiberbootState = 65,
    PlatformInformation = 66,
    PdcInvocation = 67,
    MonitorInvocation = 68,
    FirmwareTableInformationRegistered = 69,
    SetShutdownSelectedTime = 70,
    SuspendResumeInvocation = 71,
    PlmPowerRequestCreate = 72,
    ScreenOff = 73,
    CsDeviceNotification = 74,
    PlatformRole = 75,
    LastResumePerformance = 76,
    DisplayBurst = 77,
    ExitLatencySamplingPercentage = 78,
    RegisterSpmPowerSettings = 79,
    PlatformIdleStates = 80,
    ProcessorIdleVeto = 81,
    PlatformIdleVeto = 82,
    SystemBatteryStatePrecise = 83,
    ThermalEvent = 84,
    PowerInformationLevelMaximum = 85;

//
// User Presence Values
//

/** enum POWER_USER_PRESENCE_TYPE */
public static final int
    UserNotPresent = 0,
    UserPresent = 1,
    UserUnknown = 0xff;
// Targeting ..\windows\POWER_USER_PRESENCE.java


// Targeting ..\windows\POWER_SESSION_CONNECT.java


// Targeting ..\windows\POWER_SESSION_TIMEOUTS.java


// Targeting ..\windows\POWER_SESSION_RIT_STATE.java


// Targeting ..\windows\POWER_SESSION_WINLOGON.java


// Targeting ..\windows\POWER_IDLE_RESILIENCY.java



//
// Monitor on/off reasons
//
/** enum POWER_MONITOR_REQUEST_REASON */
public static final int
    MonitorRequestReasonUnknown = 0,
    MonitorRequestReasonPowerButton = 1,
    MonitorRequestReasonRemoteConnection = 2,
    MonitorRequestReasonScMonitorpower = 3,
    MonitorRequestReasonUserInput = 4,
    MonitorRequestReasonAcDcDisplayBurst = 5,
    MonitorRequestReasonUserDisplayBurst = 6,
    MonitorRequestReasonPoSetSystemState = 7,
    MonitorRequestReasonSetThreadExecutionState = 8,
    MonitorRequestReasonFullWake = 9,
    MonitorRequestReasonSessionUnlock = 10,
    MonitorRequestReasonScreenOffRequest = 11,
    MonitorRequestReasonIdleTimeout = 12,
    MonitorRequestReasonPolicyChange = 13,
    MonitorRequestReasonSleepButton = 14,
    MonitorRequestReasonLid = 15,
    MonitorRequestReasonBatteryCountChange = 16,
    MonitorRequestReasonMax = 17;
// Targeting ..\windows\POWER_MONITOR_INVOCATION.java


// Targeting ..\windows\RESUME_PERFORMANCE.java



//
// Power Setting definitions
//

/** enum SYSTEM_POWER_CONDITION */
public static final int
    PoAc = 0,
    PoDc = 1,
    PoHot = 2,
    PoConditionMaximum = 3;
// Targeting ..\windows\SET_POWER_SETTING_VALUE.java



public static final int POWER_SETTING_VALUE_VERSION = (0x1);
// Targeting ..\windows\NOTIFY_USER_POWER_SETTING.java


// Targeting ..\windows\APPLICATIONLAUNCH_SETTING_VALUE.java



//
// define platform roles
//

/** enum POWER_PLATFORM_ROLE */
public static final int
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop = 1,
    PlatformRoleMobile = 2,
    PlatformRoleWorkstation = 3,
    PlatformRoleEnterpriseServer = 4,
    PlatformRoleSOHOServer = 5,
    PlatformRoleAppliancePC = 6,
    PlatformRolePerformanceServer = 7, // v1 last supported
    PlatformRoleSlate = 8,             // v2 last supported
    PlatformRoleMaximum = 9;

public static final int POWER_PLATFORM_ROLE_V1 =     (0x00000001);
public static final int POWER_PLATFORM_ROLE_V1_MAX = (PlatformRolePerformanceServer + 1);

public static final int POWER_PLATFORM_ROLE_V2 =     (0x00000002);
public static final int POWER_PLATFORM_ROLE_V2_MAX = (PlatformRoleSlate + 1);

// #if (NTDDI_VERSION >= NTDDI_WIN8)

// #else

public static final int POWER_PLATFORM_ROLE_VERSION =     POWER_PLATFORM_ROLE_V1;
public static final int POWER_PLATFORM_ROLE_VERSION_MAX = POWER_PLATFORM_ROLE_V1_MAX;
// Targeting ..\windows\POWER_PLATFORM_INFORMATION.java


// Targeting ..\windows\BATTERY_REPORTING_SCALE.java


// Targeting ..\windows\PPM_WMI_LEGACY_PERFSTATE.java


// Targeting ..\windows\PPM_WMI_IDLE_STATE.java


// Targeting ..\windows\PPM_WMI_IDLE_STATES.java


// Targeting ..\windows\PPM_WMI_IDLE_STATES_EX.java


// Targeting ..\windows\PPM_WMI_PERF_STATE.java


// Targeting ..\windows\PPM_WMI_PERF_STATES.java


// Targeting ..\windows\PPM_WMI_PERF_STATES_EX.java



//
// Legacy processor idle accounting.
//

public static final int PROC_IDLE_BUCKET_COUNT = 6;
// Targeting ..\windows\PPM_IDLE_STATE_ACCOUNTING.java


// Targeting ..\windows\PPM_IDLE_ACCOUNTING.java



//
// Processor idle accounting.
//

public static final int PROC_IDLE_BUCKET_COUNT_EX = 16;
// Targeting ..\windows\PPM_IDLE_STATE_BUCKET_EX.java


// Targeting ..\windows\PPM_IDLE_STATE_ACCOUNTING_EX.java


// Targeting ..\windows\PPM_IDLE_ACCOUNTING_EX.java



//
// Definitions of coordination types for _PSD, _TSD, and _CSD BIOS objects from
// the Acpi 3.0 specification
//

public static final int ACPI_PPM_SOFTWARE_ALL =     0xFC;
public static final int ACPI_PPM_SOFTWARE_ANY =     0xFD;
public static final int ACPI_PPM_HARDWARE_ALL =     0xFE;

//
// Definition of Microsoft PPM coordination types.
//

public static final int MS_PPM_SOFTWARE_ALL =       0x1;

//
// Processor firmware rundown feature bit definitions.
//

public static final int PPM_FIRMWARE_ACPI1C2 =      0x00000001;
public static final int PPM_FIRMWARE_ACPI1C3 =      0x00000002;
public static final int PPM_FIRMWARE_ACPI1TSTATES = 0x00000004;
public static final int PPM_FIRMWARE_CST =          0x00000008;
public static final int PPM_FIRMWARE_CSD =          0x00000010;
public static final int PPM_FIRMWARE_PCT =          0x00000020;
public static final int PPM_FIRMWARE_PSS =          0x00000040;
public static final int PPM_FIRMWARE_XPSS =         0x00000080;
public static final int PPM_FIRMWARE_PPC =          0x00000100;
public static final int PPM_FIRMWARE_PSD =          0x00000200;
public static final int PPM_FIRMWARE_PTC =          0x00000400;
public static final int PPM_FIRMWARE_TSS =          0x00000800;
public static final int PPM_FIRMWARE_TPC =          0x00001000;
public static final int PPM_FIRMWARE_TSD =          0x00002000;
public static final int PPM_FIRMWARE_PCCH =         0x00004000;
public static final int PPM_FIRMWARE_PCCP =         0x00008000;
public static final int PPM_FIRMWARE_OSC =          0x00010000;
public static final int PPM_FIRMWARE_PDC =          0x00020000;
public static final int PPM_FIRMWARE_CPC =          0x00040000;

//
// Processor performance and idle controls implementations.
//

public static final int PPM_PERFORMANCE_IMPLEMENTATION_NONE =      0x00000000;
public static final int PPM_PERFORMANCE_IMPLEMENTATION_PSTATES =   0x00000001;
public static final int PPM_PERFORMANCE_IMPLEMENTATION_PCCV1 =     0x00000002;
public static final int PPM_PERFORMANCE_IMPLEMENTATION_CPPC =      0x00000003;
public static final int PPM_PERFORMANCE_IMPLEMENTATION_PEP =       0x00000004;

public static final int PPM_IDLE_IMPLEMENTATION_NONE =             0x00000000;
public static final int PPM_IDLE_IMPLEMENTATION_CSTATES =          0x00000001;
public static final int PPM_IDLE_IMPLEMENTATION_PEP =              0x00000002;
public static final int PPM_IDLE_IMPLEMENTATION_MICROPEP =         0x00000003;

//
// Processor Power Management WMI interface.
//

// {A5B32DDD-7F39-4abc-B892-900E43B59EBB}
@MemberGetter public static native @Const @ByRef GUID PPM_PERFSTATE_CHANGE_GUID();

// {995e6b7f-d653-497a-b978-36a30c29bf01}
@MemberGetter public static native @Const @ByRef GUID PPM_PERFSTATE_DOMAIN_CHANGE_GUID();

// {4838fe4f-f71c-4e51-9ecc-8430a7ac4c6c}
@MemberGetter public static native @Const @ByRef GUID PPM_IDLESTATE_CHANGE_GUID();

// {5708cc20-7d40-4bf4-b4aa-2b01338d0126}
@MemberGetter public static native @Const @ByRef GUID PPM_PERFSTATES_DATA_GUID();

// {ba138e10-e250-4ad7-8616-cf1a7ad410e7}
@MemberGetter public static native @Const @ByRef GUID PPM_IDLESTATES_DATA_GUID();

// {e2a26f78-ae07-4ee0-a30f-ce354f5a94cd}
@MemberGetter public static native @Const @ByRef GUID PPM_IDLE_ACCOUNTING_GUID();

// {d67abd39-81f8-4a5e-8152-72e31ec912ee}
@MemberGetter public static native @Const @ByRef GUID PPM_IDLE_ACCOUNTING_EX_GUID();

// {a852c2c8-1a4c-423b-8c2c-f30d82931a88}
@MemberGetter public static native @Const @ByRef GUID PPM_THERMALCONSTRAINT_GUID();

// {7fd18652-0cfe-40d2-b0a1-0b066a87759e}
@MemberGetter public static native @Const @ByRef GUID PPM_PERFMON_PERFSTATE_GUID();

// {48f377b8-6880-4c7b-8bdc-380176c6654d}
@MemberGetter public static native @Const @ByRef GUID PPM_THERMAL_POLICY_CHANGE_GUID();
// Targeting ..\windows\PPM_PERFSTATE_EVENT.java


// Targeting ..\windows\PPM_PERFSTATE_DOMAIN_EVENT.java


// Targeting ..\windows\PPM_IDLESTATE_EVENT.java


// Targeting ..\windows\PPM_THERMALCHANGE_EVENT.java



// #pragma warning(push)
// #pragma warning(disable:4121)
// Targeting ..\windows\PPM_THERMAL_POLICY_EVENT.java



// #pragma warning(pop)
// Targeting ..\windows\POWER_ACTION_POLICY.java



// POWER_ACTION_POLICY->Flags:
public static final int POWER_ACTION_QUERY_ALLOWED =      0x00000001;
public static final int POWER_ACTION_UI_ALLOWED =         0x00000002;
public static final int POWER_ACTION_OVERRIDE_APPS =      0x00000004;
public static final int POWER_ACTION_HIBERBOOT =          0x00000008;
public static final int POWER_ACTION_PSEUDO_TRANSITION =  0x08000000;
public static final int POWER_ACTION_LIGHTEST_FIRST =     0x10000000;
public static final int POWER_ACTION_LOCK_CONSOLE =       0x20000000;
public static final int POWER_ACTION_DISABLE_WAKES =      0x40000000;
public static final int POWER_ACTION_CRITICAL =           0x80000000;

// POWER_ACTION_POLICY->EventCode flags
public static final int POWER_LEVEL_USER_NOTIFY_TEXT =      0x00000001;
public static final int POWER_LEVEL_USER_NOTIFY_SOUND =     0x00000002;
public static final int POWER_LEVEL_USER_NOTIFY_EXEC =      0x00000004;
public static final int POWER_USER_NOTIFY_BUTTON =          0x00000008;
public static final int POWER_USER_NOTIFY_SHUTDOWN =        0x00000010;
public static final int POWER_USER_NOTIFY_FORCED_SHUTDOWN = 0x00000020;
public static final int POWER_FORCE_TRIGGER_RESET =         0x80000000;

// Note: for battery alarm EventCodes, the ID of the battery alarm << 16 is ORed
// into the flags.  For example: DISCHARGE_POLICY_LOW << 16

//
// The GUID_BATTERY_DISCHARGE_FLAGS_x power settings use a subset of EventCode
// flags.  The POWER_FORCE_TRIGGER_RESET flag doesn't make sense for a battery
// alarm so it is overloaded for other purposes (gerneral enable/disable).
public static final int BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK =  0x00000007;
public static final int BATTERY_DISCHARGE_FLAGS_ENABLE =  0x80000000;
// Targeting ..\windows\SYSTEM_POWER_LEVEL.java



// Discharge policy constants
public static final int NUM_DISCHARGE_POLICIES =      4;
public static final int DISCHARGE_POLICY_CRITICAL =   0;
public static final int DISCHARGE_POLICY_LOW =        1;
// Targeting ..\windows\SYSTEM_POWER_POLICY.java




// processor power policy state

//
// Processor Idle State Policy.
//

public static final int PROCESSOR_IDLESTATE_POLICY_COUNT = 0x3;
// Targeting ..\windows\PROCESSOR_IDLESTATE_INFO.java


// Targeting ..\windows\PROCESSOR_IDLESTATE_POLICY.java



//
// Legacy Processor Policy.  This is only provided to allow legacy
// applications to compile.  New applications must use
// PROCESSOR_IDLESTATE_POLICY.
//

public static final int PO_THROTTLE_NONE =            0;
public static final int PO_THROTTLE_CONSTANT =        1;
public static final int PO_THROTTLE_DEGRADE =         2;
public static final int PO_THROTTLE_ADAPTIVE =        3;
public static final int PO_THROTTLE_MAXIMUM =         4;
// Targeting ..\windows\PROCESSOR_POWER_POLICY_INFO.java


// Targeting ..\windows\PROCESSOR_POWER_POLICY.java


// Targeting ..\windows\PROCESSOR_PERFSTATE_POLICY.java


// Targeting ..\windows\ADMINISTRATOR_POWER_POLICY.java


// Targeting ..\windows\SYSTEM_POWER_CAPABILITIES.java


// Targeting ..\windows\SYSTEM_BATTERY_STATE.java





//
// Image Format
//


// #ifndef _MAC

// #include "pshpack4.h"                   // 4 byte packing is the default

public static final int IMAGE_DOS_SIGNATURE =                 0x5A4D;      // MZ
public static final int IMAGE_OS2_SIGNATURE =                 0x454E;      // NE
public static final int IMAGE_OS2_SIGNATURE_LE =              0x454C;      // LE
public static final int IMAGE_VXD_SIGNATURE =                 0x454C;      // LE
public static final int IMAGE_NT_SIGNATURE =                  0x00004550;  // PE00

// #include "pshpack2.h"
// Targeting ..\windows\IMAGE_DOS_HEADER.java


// Targeting ..\windows\IMAGE_OS2_HEADER.java


// Targeting ..\windows\IMAGE_VXD_HEADER.java



// #ifndef _MAC
// #include "poppack.h"
// Targeting ..\windows\IMAGE_FILE_HEADER.java



public static final int IMAGE_SIZEOF_FILE_HEADER =             20;

public static final int IMAGE_FILE_RELOCS_STRIPPED =           0x0001;  // Relocation info stripped from file.
public static final int IMAGE_FILE_EXECUTABLE_IMAGE =          0x0002;  // File is executable  (i.e. no unresolved external references).
public static final int IMAGE_FILE_LINE_NUMS_STRIPPED =        0x0004;  // Line nunbers stripped from file.
public static final int IMAGE_FILE_LOCAL_SYMS_STRIPPED =       0x0008;  // Local symbols stripped from file.
public static final int IMAGE_FILE_AGGRESIVE_WS_TRIM =         0x0010;  // Aggressively trim working set
public static final int IMAGE_FILE_LARGE_ADDRESS_AWARE =       0x0020;  // App can handle >2gb addresses
public static final int IMAGE_FILE_BYTES_REVERSED_LO =         0x0080;  // Bytes of machine word are reversed.
public static final int IMAGE_FILE_32BIT_MACHINE =             0x0100;  // 32 bit word machine.
public static final int IMAGE_FILE_DEBUG_STRIPPED =            0x0200;  // Debugging info stripped from file in .DBG file
public static final int IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP =   0x0400;  // If Image is on removable media, copy and run from the swap file.
public static final int IMAGE_FILE_NET_RUN_FROM_SWAP =         0x0800;  // If Image is on Net, copy and run from the swap file.
public static final int IMAGE_FILE_SYSTEM =                    0x1000;  // System File.
public static final int IMAGE_FILE_DLL =                       0x2000;  // File is a DLL.
public static final int IMAGE_FILE_UP_SYSTEM_ONLY =            0x4000;  // File should only be run on a UP machine
public static final int IMAGE_FILE_BYTES_REVERSED_HI =         0x8000;  // Bytes of machine word are reversed.

public static final int IMAGE_FILE_MACHINE_UNKNOWN =           0;
public static final int IMAGE_FILE_MACHINE_I386 =              0x014c;  // Intel 386.
public static final int IMAGE_FILE_MACHINE_R3000 =             0x0162;  // MIPS little-endian, 0x160 big-endian
public static final int IMAGE_FILE_MACHINE_R4000 =             0x0166;  // MIPS little-endian
public static final int IMAGE_FILE_MACHINE_R10000 =            0x0168;  // MIPS little-endian
public static final int IMAGE_FILE_MACHINE_WCEMIPSV2 =         0x0169;  // MIPS little-endian WCE v2
public static final int IMAGE_FILE_MACHINE_ALPHA =             0x0184;  // Alpha_AXP
public static final int IMAGE_FILE_MACHINE_SH3 =               0x01a2;  // SH3 little-endian
public static final int IMAGE_FILE_MACHINE_SH3DSP =            0x01a3;
public static final int IMAGE_FILE_MACHINE_SH3E =              0x01a4;  // SH3E little-endian
public static final int IMAGE_FILE_MACHINE_SH4 =               0x01a6;  // SH4 little-endian
public static final int IMAGE_FILE_MACHINE_SH5 =               0x01a8;  // SH5
public static final int IMAGE_FILE_MACHINE_ARM =               0x01c0;  // ARM Little-Endian
public static final int IMAGE_FILE_MACHINE_THUMB =             0x01c2;  // ARM Thumb/Thumb-2 Little-Endian
public static final int IMAGE_FILE_MACHINE_ARMNT =             0x01c4;  // ARM Thumb-2 Little-Endian
public static final int IMAGE_FILE_MACHINE_AM33 =              0x01d3;
public static final int IMAGE_FILE_MACHINE_POWERPC =           0x01F0;  // IBM PowerPC Little-Endian
public static final int IMAGE_FILE_MACHINE_POWERPCFP =         0x01f1;
public static final int IMAGE_FILE_MACHINE_IA64 =              0x0200;  // Intel 64
public static final int IMAGE_FILE_MACHINE_MIPS16 =            0x0266;  // MIPS
public static final int IMAGE_FILE_MACHINE_ALPHA64 =           0x0284;  // ALPHA64
public static final int IMAGE_FILE_MACHINE_MIPSFPU =           0x0366;  // MIPS
public static final int IMAGE_FILE_MACHINE_MIPSFPU16 =         0x0466;  // MIPS
public static final int IMAGE_FILE_MACHINE_AXP64 =             IMAGE_FILE_MACHINE_ALPHA64;
public static final int IMAGE_FILE_MACHINE_TRICORE =           0x0520;  // Infineon
public static final int IMAGE_FILE_MACHINE_CEF =               0x0CEF;
public static final int IMAGE_FILE_MACHINE_EBC =               0x0EBC;  // EFI Byte Code
public static final int IMAGE_FILE_MACHINE_AMD64 =             0x8664;  // AMD64 (K8)
public static final int IMAGE_FILE_MACHINE_M32R =              0x9041;  // M32R little-endian
public static final int IMAGE_FILE_MACHINE_CEE =               0xC0EE;
// Targeting ..\windows\IMAGE_DATA_DIRECTORY.java



public static final int IMAGE_NUMBEROF_DIRECTORY_ENTRIES =    16;
// Targeting ..\windows\IMAGE_OPTIONAL_HEADER32.java


// Targeting ..\windows\IMAGE_ROM_OPTIONAL_HEADER.java


// Targeting ..\windows\IMAGE_OPTIONAL_HEADER64.java



public static final int IMAGE_NT_OPTIONAL_HDR32_MAGIC =      0x10b;
public static final int IMAGE_NT_OPTIONAL_HDR64_MAGIC =      0x20b;
public static final int IMAGE_ROM_OPTIONAL_HDR_MAGIC =       0x107;

// #ifdef _WIN64
public static final int IMAGE_NT_OPTIONAL_HDR_MAGIC =         IMAGE_NT_OPTIONAL_HDR64_MAGIC;
// Targeting ..\windows\IMAGE_NT_HEADERS64.java


// Targeting ..\windows\IMAGE_NT_HEADERS32.java


// Targeting ..\windows\IMAGE_ROM_HEADERS.java



// #ifdef _WIN64
// #else
// #endif

// IMAGE_FIRST_SECTION doesn't need 32/64 versions since the file header is the same either way.

// #define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)
//     ((ULONG_PTR)(ntheader) +
//      FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +
//      ((ntheader))->FileHeader.SizeOfOptionalHeader
//     ))

// Subsystem Values

public static final int IMAGE_SUBSYSTEM_UNKNOWN =              0;   // Unknown subsystem.
public static final int IMAGE_SUBSYSTEM_NATIVE =               1;   // Image doesn't require a subsystem.
public static final int IMAGE_SUBSYSTEM_WINDOWS_GUI =          2;   // Image runs in the Windows GUI subsystem.
public static final int IMAGE_SUBSYSTEM_WINDOWS_CUI =          3;   // Image runs in the Windows character subsystem.
public static final int IMAGE_SUBSYSTEM_OS2_CUI =              5;   // image runs in the OS/2 character subsystem.
public static final int IMAGE_SUBSYSTEM_POSIX_CUI =            7;   // image runs in the Posix character subsystem.
public static final int IMAGE_SUBSYSTEM_NATIVE_WINDOWS =       8;   // image is a native Win9x driver.
public static final int IMAGE_SUBSYSTEM_WINDOWS_CE_GUI =       9;   // Image runs in the Windows CE subsystem.
public static final int IMAGE_SUBSYSTEM_EFI_APPLICATION =      10;  //
public static final int IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER =  11;   //
public static final int IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER =   12;  //
public static final int IMAGE_SUBSYSTEM_EFI_ROM =              13;
public static final int IMAGE_SUBSYSTEM_XBOX =                 14;
public static final int IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION = 16;

// DllCharacteristics Entries

//      IMAGE_LIBRARY_PROCESS_INIT            0x0001     // Reserved.
//      IMAGE_LIBRARY_PROCESS_TERM            0x0002     // Reserved.
//      IMAGE_LIBRARY_THREAD_INIT             0x0004     // Reserved.
//      IMAGE_LIBRARY_THREAD_TERM             0x0008     // Reserved.
public static final int IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA =    0x0020;  // Image can handle a high entropy 64-bit virtual address space.
public static final int IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE = 0x0040;     // DLL can move.
public static final int IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY =    0x0080;     // Code Integrity Image
public static final int IMAGE_DLLCHARACTERISTICS_NX_COMPAT =    0x0100;     // Image is NX compatible
public static final int IMAGE_DLLCHARACTERISTICS_NO_ISOLATION = 0x0200;     // Image understands isolation and doesn't want it
public static final int IMAGE_DLLCHARACTERISTICS_NO_SEH =       0x0400;     // Image does not use SEH.  No SE handler may reside in this image
public static final int IMAGE_DLLCHARACTERISTICS_NO_BIND =      0x0800;     // Do not bind this image.
public static final int IMAGE_DLLCHARACTERISTICS_APPCONTAINER = 0x1000;     // Image should execute in an AppContainer
public static final int IMAGE_DLLCHARACTERISTICS_WDM_DRIVER =   0x2000;     // Driver uses WDM model
public static final int IMAGE_DLLCHARACTERISTICS_GUARD_CF =     0x4000;     // Image supports Control Flow Guard.
public static final int IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE =     0x8000;

// Directory Entries

public static final int IMAGE_DIRECTORY_ENTRY_EXPORT =          0;   // Export Directory
public static final int IMAGE_DIRECTORY_ENTRY_IMPORT =          1;   // Import Directory
public static final int IMAGE_DIRECTORY_ENTRY_RESOURCE =        2;   // Resource Directory
public static final int IMAGE_DIRECTORY_ENTRY_EXCEPTION =       3;   // Exception Directory
public static final int IMAGE_DIRECTORY_ENTRY_SECURITY =        4;   // Security Directory
public static final int IMAGE_DIRECTORY_ENTRY_BASERELOC =       5;   // Base Relocation Table
public static final int IMAGE_DIRECTORY_ENTRY_DEBUG =           6;   // Debug Directory
//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
public static final int IMAGE_DIRECTORY_ENTRY_ARCHITECTURE =    7;   // Architecture Specific Data
public static final int IMAGE_DIRECTORY_ENTRY_GLOBALPTR =       8;   // RVA of GP
public static final int IMAGE_DIRECTORY_ENTRY_TLS =             9;   // TLS Directory
public static final int IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG =    10;   // Load Configuration Directory
public static final int IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT =   11;   // Bound Import Directory in headers
public static final int IMAGE_DIRECTORY_ENTRY_IAT =            12;   // Import Address Table
public static final int IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT =   13;   // Delay Load Import Descriptors
public static final int IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = 14;
// Targeting ..\windows\ANON_OBJECT_HEADER.java


// Targeting ..\windows\ANON_OBJECT_HEADER_V2.java


// Targeting ..\windows\ANON_OBJECT_HEADER_BIGOBJ.java



//
// Section header format.
//

public static final int IMAGE_SIZEOF_SHORT_NAME =              8;
// Targeting ..\windows\IMAGE_SECTION_HEADER.java



public static final int IMAGE_SIZEOF_SECTION_HEADER =          40;

//
// Section characteristics.
//
//      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.
//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.
//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.
//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.
public static final int IMAGE_SCN_TYPE_NO_PAD =                0x00000008;  // Reserved.
//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.

public static final int IMAGE_SCN_CNT_CODE =                   0x00000020;  // Section contains code.
public static final int IMAGE_SCN_CNT_INITIALIZED_DATA =       0x00000040;  // Section contains initialized data.
public static final int IMAGE_SCN_CNT_UNINITIALIZED_DATA =     0x00000080;  // Section contains uninitialized data.

public static final int IMAGE_SCN_LNK_OTHER =                  0x00000100;  // Reserved.
public static final int IMAGE_SCN_LNK_INFO =                   0x00000200;  // Section contains comments or some other type of information.
//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.
public static final int IMAGE_SCN_LNK_REMOVE =                 0x00000800;  // Section contents will not become part of image.
public static final int IMAGE_SCN_LNK_COMDAT =                 0x00001000;  // Section contents comdat.
//                                           0x00002000  // Reserved.
//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000
public static final int IMAGE_SCN_NO_DEFER_SPEC_EXC =          0x00004000;  // Reset speculative exceptions handling bits in the TLB entries for this section.
public static final int IMAGE_SCN_GPREL =                      0x00008000;  // Section content can be accessed relative to GP
public static final int IMAGE_SCN_MEM_FARDATA =                0x00008000;
//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000
public static final int IMAGE_SCN_MEM_PURGEABLE =              0x00020000;
public static final int IMAGE_SCN_MEM_16BIT =                  0x00020000;
public static final int IMAGE_SCN_MEM_LOCKED =                 0x00040000;
public static final int IMAGE_SCN_MEM_PRELOAD =                0x00080000;

public static final int IMAGE_SCN_ALIGN_1BYTES =               0x00100000;  //
public static final int IMAGE_SCN_ALIGN_2BYTES =               0x00200000;  //
public static final int IMAGE_SCN_ALIGN_4BYTES =               0x00300000;  //
public static final int IMAGE_SCN_ALIGN_8BYTES =               0x00400000;  //
public static final int IMAGE_SCN_ALIGN_16BYTES =              0x00500000;  // Default alignment if no others are specified.
public static final int IMAGE_SCN_ALIGN_32BYTES =              0x00600000;  //
public static final int IMAGE_SCN_ALIGN_64BYTES =              0x00700000;  //
public static final int IMAGE_SCN_ALIGN_128BYTES =             0x00800000;  //
public static final int IMAGE_SCN_ALIGN_256BYTES =             0x00900000;  //
public static final int IMAGE_SCN_ALIGN_512BYTES =             0x00A00000;  //
public static final int IMAGE_SCN_ALIGN_1024BYTES =            0x00B00000;  //
public static final int IMAGE_SCN_ALIGN_2048BYTES =            0x00C00000;  //
public static final int IMAGE_SCN_ALIGN_4096BYTES =            0x00D00000;  //
public static final int IMAGE_SCN_ALIGN_8192BYTES =            0x00E00000;  //
// Unused                                    0x00F00000
public static final int IMAGE_SCN_ALIGN_MASK =                 0x00F00000;

public static final int IMAGE_SCN_LNK_NRELOC_OVFL =            0x01000000;  // Section contains extended relocations.
public static final int IMAGE_SCN_MEM_DISCARDABLE =            0x02000000;  // Section can be discarded.
public static final int IMAGE_SCN_MEM_NOT_CACHED =             0x04000000;  // Section is not cachable.
public static final int IMAGE_SCN_MEM_NOT_PAGED =              0x08000000;  // Section is not pageable.
public static final int IMAGE_SCN_MEM_SHARED =                 0x10000000;  // Section is shareable.
public static final int IMAGE_SCN_MEM_EXECUTE =                0x20000000;  // Section is executable.
public static final int IMAGE_SCN_MEM_READ =                   0x40000000;  // Section is readable.
public static final int IMAGE_SCN_MEM_WRITE =                  0x80000000;  // Section is writeable.

//
// TLS Characteristic Flags
//
public static final int IMAGE_SCN_SCALE_INDEX =                0x00000001;  // Tls index is scaled

// #ifndef _MAC
// #include "pshpack2.h"
// Targeting ..\windows\IMAGE_SYMBOL.java



public static final int IMAGE_SIZEOF_SYMBOL =                  18;
// Targeting ..\windows\IMAGE_SYMBOL_EX.java



//
// Section values.
//
// Symbols have a section number of the section in which they are
// defined. Otherwise, section numbers have the following meanings:
//

public static final int IMAGE_SYM_UNDEFINED =           (short)0;          // Symbol is undefined or is common.
public static final int IMAGE_SYM_ABSOLUTE =            (short)-1;         // Symbol is an absolute value.
public static final int IMAGE_SYM_DEBUG =               (short)-2;         // Symbol is a special debug item.
public static final int IMAGE_SYM_SECTION_MAX =         0xFEFF;            // Values 0xFF00-0xFFFF are special
public static final int IMAGE_SYM_SECTION_MAX_EX =      MAXLONG;

//
// Type (fundamental) values.
//

public static final int IMAGE_SYM_TYPE_NULL =                 0x0000;  // no type.
public static final int IMAGE_SYM_TYPE_VOID =                 0x0001;  //
public static final int IMAGE_SYM_TYPE_CHAR =                 0x0002;  // type character.
public static final int IMAGE_SYM_TYPE_SHORT =                0x0003;  // type short integer.
public static final int IMAGE_SYM_TYPE_INT =                  0x0004;  //
public static final int IMAGE_SYM_TYPE_LONG =                 0x0005;  //
public static final int IMAGE_SYM_TYPE_FLOAT =                0x0006;  //
public static final int IMAGE_SYM_TYPE_DOUBLE =               0x0007;  //
public static final int IMAGE_SYM_TYPE_STRUCT =               0x0008;  //
public static final int IMAGE_SYM_TYPE_UNION =                0x0009;  //
public static final int IMAGE_SYM_TYPE_ENUM =                 0x000A;  // enumeration.
public static final int IMAGE_SYM_TYPE_MOE =                  0x000B;  // member of enumeration.
public static final int IMAGE_SYM_TYPE_BYTE =                 0x000C;  //
public static final int IMAGE_SYM_TYPE_WORD =                 0x000D;  //
public static final int IMAGE_SYM_TYPE_UINT =                 0x000E;  //
public static final int IMAGE_SYM_TYPE_DWORD =                0x000F;  //
public static final int IMAGE_SYM_TYPE_PCODE =                0x8000;  //
//
// Type (derived) values.
//

public static final int IMAGE_SYM_DTYPE_NULL =                0;       // no derived type.
public static final int IMAGE_SYM_DTYPE_POINTER =             1;       // pointer.
public static final int IMAGE_SYM_DTYPE_FUNCTION =            2;       // function.
public static final int IMAGE_SYM_DTYPE_ARRAY =               3;       // array.

//
// Storage classes.
//
public static final int IMAGE_SYM_CLASS_END_OF_FUNCTION =     (byte)-1;
public static final int IMAGE_SYM_CLASS_NULL =                0x0000;
public static final int IMAGE_SYM_CLASS_AUTOMATIC =           0x0001;
public static final int IMAGE_SYM_CLASS_EXTERNAL =            0x0002;
public static final int IMAGE_SYM_CLASS_STATIC =              0x0003;
public static final int IMAGE_SYM_CLASS_REGISTER =            0x0004;
public static final int IMAGE_SYM_CLASS_EXTERNAL_DEF =        0x0005;
public static final int IMAGE_SYM_CLASS_LABEL =               0x0006;
public static final int IMAGE_SYM_CLASS_UNDEFINED_LABEL =     0x0007;
public static final int IMAGE_SYM_CLASS_MEMBER_OF_STRUCT =    0x0008;
public static final int IMAGE_SYM_CLASS_ARGUMENT =            0x0009;
public static final int IMAGE_SYM_CLASS_STRUCT_TAG =          0x000A;
public static final int IMAGE_SYM_CLASS_MEMBER_OF_UNION =     0x000B;
public static final int IMAGE_SYM_CLASS_UNION_TAG =           0x000C;
public static final int IMAGE_SYM_CLASS_TYPE_DEFINITION =     0x000D;
public static final int IMAGE_SYM_CLASS_UNDEFINED_STATIC =    0x000E;
public static final int IMAGE_SYM_CLASS_ENUM_TAG =            0x000F;
public static final int IMAGE_SYM_CLASS_MEMBER_OF_ENUM =      0x0010;
public static final int IMAGE_SYM_CLASS_REGISTER_PARAM =      0x0011;
public static final int IMAGE_SYM_CLASS_BIT_FIELD =           0x0012;

public static final int IMAGE_SYM_CLASS_FAR_EXTERNAL =        0x0044;  //

public static final int IMAGE_SYM_CLASS_BLOCK =               0x0064;
public static final int IMAGE_SYM_CLASS_FUNCTION =            0x0065;
public static final int IMAGE_SYM_CLASS_END_OF_STRUCT =       0x0066;
public static final int IMAGE_SYM_CLASS_FILE =                0x0067;
// new
public static final int IMAGE_SYM_CLASS_SECTION =             0x0068;
public static final int IMAGE_SYM_CLASS_WEAK_EXTERNAL =       0x0069;

public static final int IMAGE_SYM_CLASS_CLR_TOKEN =           0x006B;

// type packing constants

public static final int N_BTMASK =                            0x000F;
public static final int N_TMASK =                             0x0030;
public static final int N_TMASK1 =                            0x00C0;
public static final int N_TMASK2 =                            0x00F0;
public static final int N_BTSHFT =                            4;
public static final int N_TSHIFT =                            2;
// MACROS

// Basic Type of  x
// #define BTYPE(x) ((x) & N_BTMASK)

// Is x a pointer?
// #ifndef ISPTR
// #define ISPTR(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_POINTER << N_BTSHFT))
// #endif

// Is x a function?
// #ifndef ISFCN
// #define ISFCN(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_FUNCTION << N_BTSHFT))
// #endif

// Is x an array?

// #ifndef ISARY
// #define ISARY(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_ARRAY << N_BTSHFT))
// #endif

// Is x a structure, union, or enumeration TAG?
// #ifndef ISTAG
// #define ISTAG(x) ((x)==IMAGE_SYM_CLASS_STRUCT_TAG || (x)==IMAGE_SYM_CLASS_UNION_TAG || (x)==IMAGE_SYM_CLASS_ENUM_TAG)
// #endif

// #ifndef INCREF
// #define INCREF(x) ((((x)&~N_BTMASK)<<N_TSHIFT)|(IMAGE_SYM_DTYPE_POINTER<<N_BTSHFT)|((x)&N_BTMASK))
// #endif
// #ifndef DECREF
// #define DECREF(x) ((((x)>>N_TSHIFT)&~N_BTMASK)|((x)&N_BTMASK))
// #endif

// #include <pshpack2.h>
// Targeting ..\windows\IMAGE_AUX_SYMBOL_TOKEN_DEF.java



// #include <poppack.h>
// Targeting ..\windows\IMAGE_AUX_SYMBOL.java


// Targeting ..\windows\IMAGE_AUX_SYMBOL_EX.java



/** enum IMAGE_AUX_SYMBOL_TYPE */
public static final int
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1;


//
// Communal selection types.
//

public static final int IMAGE_COMDAT_SELECT_NODUPLICATES =    1;
public static final int IMAGE_COMDAT_SELECT_ANY =             2;
public static final int IMAGE_COMDAT_SELECT_SAME_SIZE =       3;
public static final int IMAGE_COMDAT_SELECT_EXACT_MATCH =     4;
public static final int IMAGE_COMDAT_SELECT_ASSOCIATIVE =     5;
public static final int IMAGE_COMDAT_SELECT_LARGEST =         6;
public static final int IMAGE_COMDAT_SELECT_NEWEST =          7;

public static final int IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY =  1;
public static final int IMAGE_WEAK_EXTERN_SEARCH_LIBRARY =    2;
public static final int IMAGE_WEAK_EXTERN_SEARCH_ALIAS =      3;
// Targeting ..\windows\IMAGE_RELOCATION.java



//
// I386 relocation types.
//
public static final int IMAGE_REL_I386_ABSOLUTE =         0x0000;  // Reference is absolute, no relocation is necessary
public static final int IMAGE_REL_I386_DIR16 =            0x0001;  // Direct 16-bit reference to the symbols virtual address
public static final int IMAGE_REL_I386_REL16 =            0x0002;  // PC-relative 16-bit reference to the symbols virtual address
public static final int IMAGE_REL_I386_DIR32 =            0x0006;  // Direct 32-bit reference to the symbols virtual address
public static final int IMAGE_REL_I386_DIR32NB =          0x0007;  // Direct 32-bit reference to the symbols virtual address, base not included
public static final int IMAGE_REL_I386_SEG12 =            0x0009;  // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
public static final int IMAGE_REL_I386_SECTION =          0x000A;
public static final int IMAGE_REL_I386_SECREL =           0x000B;
public static final int IMAGE_REL_I386_TOKEN =            0x000C;  // clr token
public static final int IMAGE_REL_I386_SECREL7 =          0x000D;  // 7 bit offset from base of section containing target
public static final int IMAGE_REL_I386_REL32 =            0x0014;  // PC-relative 32-bit reference to the symbols virtual address

//
// MIPS relocation types.
//
public static final int IMAGE_REL_MIPS_ABSOLUTE =         0x0000;  // Reference is absolute, no relocation is necessary
public static final int IMAGE_REL_MIPS_REFHALF =          0x0001;
public static final int IMAGE_REL_MIPS_REFWORD =          0x0002;
public static final int IMAGE_REL_MIPS_JMPADDR =          0x0003;
public static final int IMAGE_REL_MIPS_REFHI =            0x0004;
public static final int IMAGE_REL_MIPS_REFLO =            0x0005;
public static final int IMAGE_REL_MIPS_GPREL =            0x0006;
public static final int IMAGE_REL_MIPS_LITERAL =          0x0007;
public static final int IMAGE_REL_MIPS_SECTION =          0x000A;
public static final int IMAGE_REL_MIPS_SECREL =           0x000B;
public static final int IMAGE_REL_MIPS_SECRELLO =         0x000C;  // Low 16-bit section relative referemce (used for >32k TLS)
public static final int IMAGE_REL_MIPS_SECRELHI =         0x000D;  // High 16-bit section relative reference (used for >32k TLS)
public static final int IMAGE_REL_MIPS_TOKEN =            0x000E;  // clr token
public static final int IMAGE_REL_MIPS_JMPADDR16 =        0x0010;
public static final int IMAGE_REL_MIPS_REFWORDNB =        0x0022;
public static final int IMAGE_REL_MIPS_PAIR =             0x0025;

//
// Alpha Relocation types.
//
public static final int IMAGE_REL_ALPHA_ABSOLUTE =        0x0000;
public static final int IMAGE_REL_ALPHA_REFLONG =         0x0001;
public static final int IMAGE_REL_ALPHA_REFQUAD =         0x0002;
public static final int IMAGE_REL_ALPHA_GPREL32 =         0x0003;
public static final int IMAGE_REL_ALPHA_LITERAL =         0x0004;
public static final int IMAGE_REL_ALPHA_LITUSE =          0x0005;
public static final int IMAGE_REL_ALPHA_GPDISP =          0x0006;
public static final int IMAGE_REL_ALPHA_BRADDR =          0x0007;
public static final int IMAGE_REL_ALPHA_HINT =            0x0008;
public static final int IMAGE_REL_ALPHA_INLINE_REFLONG =  0x0009;
public static final int IMAGE_REL_ALPHA_REFHI =           0x000A;
public static final int IMAGE_REL_ALPHA_REFLO =           0x000B;
public static final int IMAGE_REL_ALPHA_PAIR =            0x000C;
public static final int IMAGE_REL_ALPHA_MATCH =           0x000D;
public static final int IMAGE_REL_ALPHA_SECTION =         0x000E;
public static final int IMAGE_REL_ALPHA_SECREL =          0x000F;
public static final int IMAGE_REL_ALPHA_REFLONGNB =       0x0010;
public static final int IMAGE_REL_ALPHA_SECRELLO =        0x0011;  // Low 16-bit section relative reference
public static final int IMAGE_REL_ALPHA_SECRELHI =        0x0012;  // High 16-bit section relative reference
public static final int IMAGE_REL_ALPHA_REFQ3 =           0x0013;  // High 16 bits of 48 bit reference
public static final int IMAGE_REL_ALPHA_REFQ2 =           0x0014;  // Middle 16 bits of 48 bit reference
public static final int IMAGE_REL_ALPHA_REFQ1 =           0x0015;  // Low 16 bits of 48 bit reference
public static final int IMAGE_REL_ALPHA_GPRELLO =         0x0016;  // Low 16-bit GP relative reference
public static final int IMAGE_REL_ALPHA_GPRELHI =         0x0017;  // High 16-bit GP relative reference

//
// IBM PowerPC relocation types.
//
public static final int IMAGE_REL_PPC_ABSOLUTE =          0x0000;  // NOP
public static final int IMAGE_REL_PPC_ADDR64 =            0x0001;  // 64-bit address
public static final int IMAGE_REL_PPC_ADDR32 =            0x0002;  // 32-bit address
public static final int IMAGE_REL_PPC_ADDR24 =            0x0003;  // 26-bit address, shifted left 2 (branch absolute)
public static final int IMAGE_REL_PPC_ADDR16 =            0x0004;  // 16-bit address
public static final int IMAGE_REL_PPC_ADDR14 =            0x0005;  // 16-bit address, shifted left 2 (load doubleword)
public static final int IMAGE_REL_PPC_REL24 =             0x0006;  // 26-bit PC-relative offset, shifted left 2 (branch relative)
public static final int IMAGE_REL_PPC_REL14 =             0x0007;  // 16-bit PC-relative offset, shifted left 2 (br cond relative)
public static final int IMAGE_REL_PPC_TOCREL16 =          0x0008;  // 16-bit offset from TOC base
public static final int IMAGE_REL_PPC_TOCREL14 =          0x0009;  // 16-bit offset from TOC base, shifted left 2 (load doubleword)

public static final int IMAGE_REL_PPC_ADDR32NB =          0x000A;  // 32-bit addr w/o image base
public static final int IMAGE_REL_PPC_SECREL =            0x000B;  // va of containing section (as in an image sectionhdr)
public static final int IMAGE_REL_PPC_SECTION =           0x000C;  // sectionheader number
public static final int IMAGE_REL_PPC_IFGLUE =            0x000D;  // substitute TOC restore instruction iff symbol is glue code
public static final int IMAGE_REL_PPC_IMGLUE =            0x000E;  // symbol is glue code; virtual address is TOC restore instruction
public static final int IMAGE_REL_PPC_SECREL16 =          0x000F;  // va of containing section (limited to 16 bits)
public static final int IMAGE_REL_PPC_REFHI =             0x0010;
public static final int IMAGE_REL_PPC_REFLO =             0x0011;
public static final int IMAGE_REL_PPC_PAIR =              0x0012;
public static final int IMAGE_REL_PPC_SECRELLO =          0x0013;  // Low 16-bit section relative reference (used for >32k TLS)
public static final int IMAGE_REL_PPC_SECRELHI =          0x0014;  // High 16-bit section relative reference (used for >32k TLS)
public static final int IMAGE_REL_PPC_GPREL =             0x0015;
public static final int IMAGE_REL_PPC_TOKEN =             0x0016;  // clr token

public static final int IMAGE_REL_PPC_TYPEMASK =          0x00FF;  // mask to isolate above values in IMAGE_RELOCATION.Type

// Flag bits in IMAGE_RELOCATION.TYPE

public static final int IMAGE_REL_PPC_NEG =               0x0100;  // subtract reloc value rather than adding it
public static final int IMAGE_REL_PPC_BRTAKEN =           0x0200;  // fix branch prediction bit to predict branch taken
public static final int IMAGE_REL_PPC_BRNTAKEN =          0x0400;  // fix branch prediction bit to predict branch not taken
public static final int IMAGE_REL_PPC_TOCDEFN =           0x0800;  // toc slot defined in file (or, data in toc)

//
// Hitachi SH3 relocation types.
//
public static final int IMAGE_REL_SH3_ABSOLUTE =          0x0000;  // No relocation
public static final int IMAGE_REL_SH3_DIRECT16 =          0x0001;  // 16 bit direct
public static final int IMAGE_REL_SH3_DIRECT32 =          0x0002;  // 32 bit direct
public static final int IMAGE_REL_SH3_DIRECT8 =           0x0003;  // 8 bit direct, -128..255
public static final int IMAGE_REL_SH3_DIRECT8_WORD =      0x0004;  // 8 bit direct .W (0 ext.)
public static final int IMAGE_REL_SH3_DIRECT8_LONG =      0x0005;  // 8 bit direct .L (0 ext.)
public static final int IMAGE_REL_SH3_DIRECT4 =           0x0006;  // 4 bit direct (0 ext.)
public static final int IMAGE_REL_SH3_DIRECT4_WORD =      0x0007;  // 4 bit direct .W (0 ext.)
public static final int IMAGE_REL_SH3_DIRECT4_LONG =      0x0008;  // 4 bit direct .L (0 ext.)
public static final int IMAGE_REL_SH3_PCREL8_WORD =       0x0009;  // 8 bit PC relative .W
public static final int IMAGE_REL_SH3_PCREL8_LONG =       0x000A;  // 8 bit PC relative .L
public static final int IMAGE_REL_SH3_PCREL12_WORD =      0x000B;  // 12 LSB PC relative .W
public static final int IMAGE_REL_SH3_STARTOF_SECTION =   0x000C;  // Start of EXE section
public static final int IMAGE_REL_SH3_SIZEOF_SECTION =    0x000D;  // Size of EXE section
public static final int IMAGE_REL_SH3_SECTION =           0x000E;  // Section table index
public static final int IMAGE_REL_SH3_SECREL =            0x000F;  // Offset within section
public static final int IMAGE_REL_SH3_DIRECT32_NB =       0x0010;  // 32 bit direct not based
public static final int IMAGE_REL_SH3_GPREL4_LONG =       0x0011;  // GP-relative addressing
public static final int IMAGE_REL_SH3_TOKEN =             0x0012;  // clr token
public static final int IMAGE_REL_SHM_PCRELPT =           0x0013;  // Offset from current
                                                //  instruction in longwords
                                                //  if not NOMODE, insert the
                                                //  inverse of the low bit at
                                                //  bit 32 to select PTA/PTB
public static final int IMAGE_REL_SHM_REFLO =             0x0014;  // Low bits of 32-bit address
public static final int IMAGE_REL_SHM_REFHALF =           0x0015;  // High bits of 32-bit address
public static final int IMAGE_REL_SHM_RELLO =             0x0016;  // Low bits of relative reference
public static final int IMAGE_REL_SHM_RELHALF =           0x0017;  // High bits of relative reference
public static final int IMAGE_REL_SHM_PAIR =              0x0018;  // offset operand for relocation

public static final int IMAGE_REL_SH_NOMODE =             0x8000;  // relocation ignores section mode


public static final int IMAGE_REL_ARM_ABSOLUTE =          0x0000;  // No relocation required
public static final int IMAGE_REL_ARM_ADDR32 =            0x0001;  // 32 bit address
public static final int IMAGE_REL_ARM_ADDR32NB =          0x0002;  // 32 bit address w/o image base
public static final int IMAGE_REL_ARM_BRANCH24 =          0x0003;  // 24 bit offset << 2 & sign ext.
public static final int IMAGE_REL_ARM_BRANCH11 =          0x0004;  // Thumb: 2 11 bit offsets
public static final int IMAGE_REL_ARM_TOKEN =             0x0005;  // clr token
public static final int IMAGE_REL_ARM_GPREL12 =           0x0006;  // GP-relative addressing (ARM)
public static final int IMAGE_REL_ARM_GPREL7 =            0x0007;  // GP-relative addressing (Thumb)
public static final int IMAGE_REL_ARM_BLX24 =             0x0008;
public static final int IMAGE_REL_ARM_BLX11 =             0x0009;
public static final int IMAGE_REL_ARM_SECTION =           0x000E;  // Section table index
public static final int IMAGE_REL_ARM_SECREL =            0x000F;  // Offset within section
public static final int IMAGE_REL_ARM_MOV32A =            0x0010;  // ARM: MOVW/MOVT
public static final int IMAGE_REL_ARM_MOV32 =             0x0010;  // ARM: MOVW/MOVT (deprecated)
public static final int IMAGE_REL_ARM_MOV32T =            0x0011;  // Thumb: MOVW/MOVT
public static final int IMAGE_REL_THUMB_MOV32 =           0x0011;  // Thumb: MOVW/MOVT (deprecated)
public static final int IMAGE_REL_ARM_BRANCH20T =         0x0012;  // Thumb: 32-bit conditional B
public static final int IMAGE_REL_THUMB_BRANCH20 =        0x0012;  // Thumb: 32-bit conditional B (deprecated)
public static final int IMAGE_REL_ARM_BRANCH24T =         0x0014;  // Thumb: 32-bit B or BL
public static final int IMAGE_REL_THUMB_BRANCH24 =        0x0014;  // Thumb: 32-bit B or BL (deprecated)
public static final int IMAGE_REL_ARM_BLX23T =            0x0015;  // Thumb: BLX immediate
public static final int IMAGE_REL_THUMB_BLX23 =           0x0015;  // Thumb: BLX immediate (deprecated)

public static final int IMAGE_REL_AM_ABSOLUTE =           0x0000;
public static final int IMAGE_REL_AM_ADDR32 =             0x0001;
public static final int IMAGE_REL_AM_ADDR32NB =           0x0002;
public static final int IMAGE_REL_AM_CALL32 =             0x0003;
public static final int IMAGE_REL_AM_FUNCINFO =           0x0004;
public static final int IMAGE_REL_AM_REL32_1 =            0x0005;
public static final int IMAGE_REL_AM_REL32_2 =            0x0006;
public static final int IMAGE_REL_AM_SECREL =             0x0007;
public static final int IMAGE_REL_AM_SECTION =            0x0008;
public static final int IMAGE_REL_AM_TOKEN =              0x0009;

//
// x64 relocations
//
public static final int IMAGE_REL_AMD64_ABSOLUTE =        0x0000;  // Reference is absolute, no relocation is necessary
public static final int IMAGE_REL_AMD64_ADDR64 =          0x0001;  // 64-bit address (VA).
public static final int IMAGE_REL_AMD64_ADDR32 =          0x0002;  // 32-bit address (VA).
public static final int IMAGE_REL_AMD64_ADDR32NB =        0x0003;  // 32-bit address w/o image base (RVA).
public static final int IMAGE_REL_AMD64_REL32 =           0x0004;  // 32-bit relative address from byte following reloc
public static final int IMAGE_REL_AMD64_REL32_1 =         0x0005;  // 32-bit relative address from byte distance 1 from reloc
public static final int IMAGE_REL_AMD64_REL32_2 =         0x0006;  // 32-bit relative address from byte distance 2 from reloc
public static final int IMAGE_REL_AMD64_REL32_3 =         0x0007;  // 32-bit relative address from byte distance 3 from reloc
public static final int IMAGE_REL_AMD64_REL32_4 =         0x0008;  // 32-bit relative address from byte distance 4 from reloc
public static final int IMAGE_REL_AMD64_REL32_5 =         0x0009;  // 32-bit relative address from byte distance 5 from reloc
public static final int IMAGE_REL_AMD64_SECTION =         0x000A;  // Section index
public static final int IMAGE_REL_AMD64_SECREL =          0x000B;  // 32 bit offset from base of section containing target
public static final int IMAGE_REL_AMD64_SECREL7 =         0x000C;  // 7 bit unsigned offset from base of section containing target
public static final int IMAGE_REL_AMD64_TOKEN =           0x000D;  // 32 bit metadata token
public static final int IMAGE_REL_AMD64_SREL32 =          0x000E;  // 32 bit signed span-dependent value emitted into object
public static final int IMAGE_REL_AMD64_PAIR =            0x000F;
public static final int IMAGE_REL_AMD64_SSPAN32 =         0x0010;  // 32 bit signed span-dependent value applied at link time

//
// IA64 relocation types.
//
public static final int IMAGE_REL_IA64_ABSOLUTE =         0x0000;
public static final int IMAGE_REL_IA64_IMM14 =            0x0001;
public static final int IMAGE_REL_IA64_IMM22 =            0x0002;
public static final int IMAGE_REL_IA64_IMM64 =            0x0003;
public static final int IMAGE_REL_IA64_DIR32 =            0x0004;
public static final int IMAGE_REL_IA64_DIR64 =            0x0005;
public static final int IMAGE_REL_IA64_PCREL21B =         0x0006;
public static final int IMAGE_REL_IA64_PCREL21M =         0x0007;
public static final int IMAGE_REL_IA64_PCREL21F =         0x0008;
public static final int IMAGE_REL_IA64_GPREL22 =          0x0009;
public static final int IMAGE_REL_IA64_LTOFF22 =          0x000A;
public static final int IMAGE_REL_IA64_SECTION =          0x000B;
public static final int IMAGE_REL_IA64_SECREL22 =         0x000C;
public static final int IMAGE_REL_IA64_SECREL64I =        0x000D;
public static final int IMAGE_REL_IA64_SECREL32 =         0x000E;
//
public static final int IMAGE_REL_IA64_DIR32NB =          0x0010;
public static final int IMAGE_REL_IA64_SREL14 =           0x0011;
public static final int IMAGE_REL_IA64_SREL22 =           0x0012;
public static final int IMAGE_REL_IA64_SREL32 =           0x0013;
public static final int IMAGE_REL_IA64_UREL32 =           0x0014;
public static final int IMAGE_REL_IA64_PCREL60X =         0x0015;  // This is always a BRL and never converted
public static final int IMAGE_REL_IA64_PCREL60B =         0x0016;  // If possible, convert to MBB bundle with NOP.B in slot 1
public static final int IMAGE_REL_IA64_PCREL60F =         0x0017;  // If possible, convert to MFB bundle with NOP.F in slot 1
public static final int IMAGE_REL_IA64_PCREL60I =         0x0018;  // If possible, convert to MIB bundle with NOP.I in slot 1
public static final int IMAGE_REL_IA64_PCREL60M =         0x0019;  // If possible, convert to MMB bundle with NOP.M in slot 1
public static final int IMAGE_REL_IA64_IMMGPREL64 =       0x001A;
public static final int IMAGE_REL_IA64_TOKEN =            0x001B;  // clr token
public static final int IMAGE_REL_IA64_GPREL32 =          0x001C;
public static final int IMAGE_REL_IA64_ADDEND =           0x001F;

//
// CEF relocation types.
//
public static final int IMAGE_REL_CEF_ABSOLUTE =          0x0000;  // Reference is absolute, no relocation is necessary
public static final int IMAGE_REL_CEF_ADDR32 =            0x0001;  // 32-bit address (VA).
public static final int IMAGE_REL_CEF_ADDR64 =            0x0002;  // 64-bit address (VA).
public static final int IMAGE_REL_CEF_ADDR32NB =          0x0003;  // 32-bit address w/o image base (RVA).
public static final int IMAGE_REL_CEF_SECTION =           0x0004;  // Section index
public static final int IMAGE_REL_CEF_SECREL =            0x0005;  // 32 bit offset from base of section containing target
public static final int IMAGE_REL_CEF_TOKEN =             0x0006;  // 32 bit metadata token

//
// clr relocation types.
//
public static final int IMAGE_REL_CEE_ABSOLUTE =          0x0000;  // Reference is absolute, no relocation is necessary
public static final int IMAGE_REL_CEE_ADDR32 =            0x0001;  // 32-bit address (VA).
public static final int IMAGE_REL_CEE_ADDR64 =            0x0002;  // 64-bit address (VA).
public static final int IMAGE_REL_CEE_ADDR32NB =          0x0003;  // 32-bit address w/o image base (RVA).
public static final int IMAGE_REL_CEE_SECTION =           0x0004;  // Section index
public static final int IMAGE_REL_CEE_SECREL =            0x0005;  // 32 bit offset from base of section containing target
public static final int IMAGE_REL_CEE_TOKEN =             0x0006;  // 32 bit metadata token


public static final int IMAGE_REL_M32R_ABSOLUTE =         0x0000;  // No relocation required
public static final int IMAGE_REL_M32R_ADDR32 =           0x0001;  // 32 bit address
public static final int IMAGE_REL_M32R_ADDR32NB =         0x0002;  // 32 bit address w/o image base
public static final int IMAGE_REL_M32R_ADDR24 =           0x0003;  // 24 bit address
public static final int IMAGE_REL_M32R_GPREL16 =          0x0004;  // GP relative addressing
public static final int IMAGE_REL_M32R_PCREL24 =          0x0005;  // 24 bit offset << 2 & sign ext.
public static final int IMAGE_REL_M32R_PCREL16 =          0x0006;  // 16 bit offset << 2 & sign ext.
public static final int IMAGE_REL_M32R_PCREL8 =           0x0007;  // 8 bit offset << 2 & sign ext.
public static final int IMAGE_REL_M32R_REFHALF =          0x0008;  // 16 MSBs
public static final int IMAGE_REL_M32R_REFHI =            0x0009;  // 16 MSBs; adj for LSB sign ext.
public static final int IMAGE_REL_M32R_REFLO =            0x000A;  // 16 LSBs
public static final int IMAGE_REL_M32R_PAIR =             0x000B;  // Link HI and LO
public static final int IMAGE_REL_M32R_SECTION =          0x000C;  // Section table index
public static final int IMAGE_REL_M32R_SECREL32 =         0x000D;  // 32 bit section relative reference
public static final int IMAGE_REL_M32R_TOKEN =            0x000E;  // clr token

public static final int IMAGE_REL_EBC_ABSOLUTE =          0x0000;  // No relocation required
public static final int IMAGE_REL_EBC_ADDR32NB =          0x0001;  // 32 bit address w/o image base
public static final int IMAGE_REL_EBC_REL32 =             0x0002;  // 32-bit relative address from byte following reloc
public static final int IMAGE_REL_EBC_SECTION =           0x0003;  // Section table index
public static final int IMAGE_REL_EBC_SECREL =            0x0004;  // Offset within section

// #define EXT_IMM64(Value, Address, Size, InstPos, ValPos)  /* Intel-IA64-Filler */
//     Value |= (((ULONGLONG)((*(Address) >> InstPos) & (((ULONGLONG)1 << Size) - 1))) << ValPos)  // Intel-IA64-Filler

// #define INS_IMM64(Value, Address, Size, InstPos, ValPos)  /* Intel-IA64-Filler */
//     *(PDWORD)Address = (*(PDWORD)Address & ~(((1 << Size) - 1) << InstPos)) | /* Intel-IA64-Filler */
//           ((DWORD)((((ULONGLONG)Value >> ValPos) & (((ULONGLONG)1 << Size) - 1))) << InstPos)  // Intel-IA64-Filler

public static final int EMARCH_ENC_I17_IMM7B_INST_WORD_X =         3;  // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM7B_SIZE_X =              7;  // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X =     4;  // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM7B_VAL_POS_X =           0;  // Intel-IA64-Filler

public static final int EMARCH_ENC_I17_IMM9D_INST_WORD_X =         3;  // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM9D_SIZE_X =              9;  // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X =     18; // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM9D_VAL_POS_X =           7;  // Intel-IA64-Filler

public static final int EMARCH_ENC_I17_IMM5C_INST_WORD_X =         3;  // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM5C_SIZE_X =              5;  // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X =     13; // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM5C_VAL_POS_X =           16; // Intel-IA64-Filler

public static final int EMARCH_ENC_I17_IC_INST_WORD_X =            3;  // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IC_SIZE_X =                 1;  // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IC_INST_WORD_POS_X =        12; // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IC_VAL_POS_X =              21; // Intel-IA64-Filler

public static final int EMARCH_ENC_I17_IMM41a_INST_WORD_X =        1;  // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM41a_SIZE_X =             10; // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X =    14; // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM41a_VAL_POS_X =          22; // Intel-IA64-Filler

public static final int EMARCH_ENC_I17_IMM41b_INST_WORD_X =        1;  // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM41b_SIZE_X =             8;  // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X =    24; // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM41b_VAL_POS_X =          32; // Intel-IA64-Filler

public static final int EMARCH_ENC_I17_IMM41c_INST_WORD_X =        2;  // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM41c_SIZE_X =             23; // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X =    0;  // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_IMM41c_VAL_POS_X =          40; // Intel-IA64-Filler

public static final int EMARCH_ENC_I17_SIGN_INST_WORD_X =          3;  // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_SIGN_SIZE_X =               1;  // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_SIGN_INST_WORD_POS_X =      27; // Intel-IA64-Filler
public static final int EMARCH_ENC_I17_SIGN_VAL_POS_X =            63; // Intel-IA64-Filler

public static final int X3_OPCODE_INST_WORD_X =                    3;  // Intel-IA64-Filler
public static final int X3_OPCODE_SIZE_X =                         4;  // Intel-IA64-Filler
public static final int X3_OPCODE_INST_WORD_POS_X =                28; // Intel-IA64-Filler
public static final int X3_OPCODE_SIGN_VAL_POS_X =                 0;  // Intel-IA64-Filler

public static final int X3_I_INST_WORD_X =                         3;  // Intel-IA64-Filler
public static final int X3_I_SIZE_X =                              1;  // Intel-IA64-Filler
public static final int X3_I_INST_WORD_POS_X =                     27; // Intel-IA64-Filler
public static final int X3_I_SIGN_VAL_POS_X =                      59; // Intel-IA64-Filler

public static final int X3_D_WH_INST_WORD_X =                      3;  // Intel-IA64-Filler
public static final int X3_D_WH_SIZE_X =                           3;  // Intel-IA64-Filler
public static final int X3_D_WH_INST_WORD_POS_X =                  24; // Intel-IA64-Filler
public static final int X3_D_WH_SIGN_VAL_POS_X =                   0;  // Intel-IA64-Filler

public static final int X3_IMM20_INST_WORD_X =                     3;  // Intel-IA64-Filler
public static final int X3_IMM20_SIZE_X =                          20; // Intel-IA64-Filler
public static final int X3_IMM20_INST_WORD_POS_X =                 4;  // Intel-IA64-Filler
public static final int X3_IMM20_SIGN_VAL_POS_X =                  0;  // Intel-IA64-Filler

public static final int X3_IMM39_1_INST_WORD_X =                   2;  // Intel-IA64-Filler
public static final int X3_IMM39_1_SIZE_X =                        23; // Intel-IA64-Filler
public static final int X3_IMM39_1_INST_WORD_POS_X =               0;  // Intel-IA64-Filler
public static final int X3_IMM39_1_SIGN_VAL_POS_X =                36; // Intel-IA64-Filler

public static final int X3_IMM39_2_INST_WORD_X =                   1;  // Intel-IA64-Filler
public static final int X3_IMM39_2_SIZE_X =                        16; // Intel-IA64-Filler
public static final int X3_IMM39_2_INST_WORD_POS_X =               16; // Intel-IA64-Filler
public static final int X3_IMM39_2_SIGN_VAL_POS_X =                20; // Intel-IA64-Filler

public static final int X3_P_INST_WORD_X =                         3;  // Intel-IA64-Filler
public static final int X3_P_SIZE_X =                              4;  // Intel-IA64-Filler
public static final int X3_P_INST_WORD_POS_X =                     0;  // Intel-IA64-Filler
public static final int X3_P_SIGN_VAL_POS_X =                      0;  // Intel-IA64-Filler

public static final int X3_TMPLT_INST_WORD_X =                     0;  // Intel-IA64-Filler
public static final int X3_TMPLT_SIZE_X =                          4;  // Intel-IA64-Filler
public static final int X3_TMPLT_INST_WORD_POS_X =                 0;  // Intel-IA64-Filler
public static final int X3_TMPLT_SIGN_VAL_POS_X =                  0;  // Intel-IA64-Filler

public static final int X3_BTYPE_QP_INST_WORD_X =                  2;  // Intel-IA64-Filler
public static final int X3_BTYPE_QP_SIZE_X =                       9;  // Intel-IA64-Filler
public static final int X3_BTYPE_QP_INST_WORD_POS_X =              23; // Intel-IA64-Filler
public static final int X3_BTYPE_QP_INST_VAL_POS_X =               0;  // Intel-IA64-Filler

public static final int X3_EMPTY_INST_WORD_X =                     1;  // Intel-IA64-Filler
public static final int X3_EMPTY_SIZE_X =                          2;  // Intel-IA64-Filler
public static final int X3_EMPTY_INST_WORD_POS_X =                 14; // Intel-IA64-Filler
public static final int X3_EMPTY_INST_VAL_POS_X =                  0;
// Targeting ..\windows\IMAGE_LINENUMBER.java



// #ifndef _MAC
// #include "poppack.h"
// Targeting ..\windows\IMAGE_BASE_RELOCATION.java



//
// Based relocation types.
//

public static final int IMAGE_REL_BASED_ABSOLUTE =              0;
public static final int IMAGE_REL_BASED_HIGH =                  1;
public static final int IMAGE_REL_BASED_LOW =                   2;
public static final int IMAGE_REL_BASED_HIGHLOW =               3;
public static final int IMAGE_REL_BASED_HIGHADJ =               4;
public static final int IMAGE_REL_BASED_MACHINE_SPECIFIC_5 =    5;
public static final int IMAGE_REL_BASED_RESERVED =              6;
public static final int IMAGE_REL_BASED_MACHINE_SPECIFIC_7 =    7;
public static final int IMAGE_REL_BASED_MACHINE_SPECIFIC_8 =    8;
public static final int IMAGE_REL_BASED_MACHINE_SPECIFIC_9 =    9;
public static final int IMAGE_REL_BASED_DIR64 =                 10;

//
// Platform-specific based relocation types.
//

public static final int IMAGE_REL_BASED_IA64_IMM64 =            9;

public static final int IMAGE_REL_BASED_MIPS_JMPADDR =          5;
public static final int IMAGE_REL_BASED_MIPS_JMPADDR16 =        9;

public static final int IMAGE_REL_BASED_ARM_MOV32 =             5;
public static final int IMAGE_REL_BASED_THUMB_MOV32 =           7;


//
// Archive format.
//

public static final int IMAGE_ARCHIVE_START_SIZE =             8;
public static final String IMAGE_ARCHIVE_START =                  "!<arch>\n";
public static final String IMAGE_ARCHIVE_END =                    "`\n";
public static final String IMAGE_ARCHIVE_PAD =                    "\n";
public static final String IMAGE_ARCHIVE_LINKER_MEMBER =          "/               ";
public static final String IMAGE_ARCHIVE_LONGNAMES_MEMBER =       "//              ";
// Targeting ..\windows\IMAGE_ARCHIVE_MEMBER_HEADER.java



public static final int IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR =      60;
// Targeting ..\windows\IMAGE_EXPORT_DIRECTORY.java


// Targeting ..\windows\IMAGE_IMPORT_BY_NAME.java



// #include "pshpack8.h"
// Targeting ..\windows\IMAGE_THUNK_DATA64.java



// #include "poppack.h"
// Targeting ..\windows\IMAGE_THUNK_DATA32.java



public static final long IMAGE_ORDINAL_FLAG64 = 0x8000000000000000L;
public static final int IMAGE_ORDINAL_FLAG32 = 0x80000000;
// #define IMAGE_ORDINAL64(Ordinal) (Ordinal & 0xffff)
// #define IMAGE_ORDINAL32(Ordinal) (Ordinal & 0xffff)
// #define IMAGE_SNAP_BY_ORDINAL64(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG64) != 0)
// #define IMAGE_SNAP_BY_ORDINAL32(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG32) != 0)
// Targeting ..\windows\PIMAGE_TLS_CALLBACK.java


// Targeting ..\windows\IMAGE_TLS_DIRECTORY64.java


// Targeting ..\windows\IMAGE_TLS_DIRECTORY32.java



// #ifdef _WIN64
public static final long IMAGE_ORDINAL_FLAG =              IMAGE_ORDINAL_FLAG64;
// #define IMAGE_ORDINAL(Ordinal)          IMAGE_ORDINAL64(Ordinal)
// #define IMAGE_SNAP_BY_ORDINAL(Ordinal)  IMAGE_SNAP_BY_ORDINAL64(Ordinal)
// Targeting ..\windows\IMAGE_IMPORT_DESCRIPTOR.java


// Targeting ..\windows\IMAGE_BOUND_IMPORT_DESCRIPTOR.java


// Targeting ..\windows\IMAGE_BOUND_FORWARDER_REF.java


// Targeting ..\windows\IMAGE_DELAYLOAD_DESCRIPTOR.java


// Targeting ..\windows\IMAGE_RESOURCE_DIRECTORY.java



public static final int IMAGE_RESOURCE_NAME_IS_STRING =        0x80000000;
public static final int IMAGE_RESOURCE_DATA_IS_DIRECTORY =     0x80000000;
// Targeting ..\windows\IMAGE_RESOURCE_DIRECTORY_ENTRY.java


// Targeting ..\windows\IMAGE_RESOURCE_DIRECTORY_STRING.java


// Targeting ..\windows\IMAGE_RESOURCE_DIR_STRING_U.java


// Targeting ..\windows\IMAGE_RESOURCE_DATA_ENTRY.java


// Targeting ..\windows\IMAGE_LOAD_CONFIG_DIRECTORY32.java


// Targeting ..\windows\IMAGE_LOAD_CONFIG_DIRECTORY64.java



// #ifdef _WIN64
// #else
// #endif

public static final int IMAGE_GUARD_CF_INSTRUMENTED =                   0x00000100;
public static final int IMAGE_GUARD_CFW_INSTRUMENTED =                  0x00000200;
public static final int IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT =         0x00000400;
public static final int IMAGE_GUARD_SECURITY_COOKIE_UNUSED =            0x00000800;
public static final int IMAGE_GUARD_PROTECT_DELAYLOAD_IAT =             0x00001000;
public static final int IMAGE_GUARD_DELAYLOAD_IAT_IN_ITS_OWN_SECTION =  0x00002000;
public static final int IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK =       0xF0000000;
public static final int IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT = 28;
// Targeting ..\windows\IMAGE_CE_RUNTIME_FUNCTION_ENTRY.java


// Targeting ..\windows\IMAGE_ARM_RUNTIME_FUNCTION_ENTRY.java


// Targeting ..\windows\IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY.java


// Targeting ..\windows\IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY.java


// Targeting ..\windows\_IMAGE_RUNTIME_FUNCTION_ENTRY.java



// #if defined(_AXP64_)

// #elif defined(_ALPHA_)

// #elif defined(_ARM_)

// #else
// Targeting ..\windows\IMAGE_DEBUG_DIRECTORY.java



public static final int IMAGE_DEBUG_TYPE_UNKNOWN =          0;
public static final int IMAGE_DEBUG_TYPE_COFF =             1;
public static final int IMAGE_DEBUG_TYPE_CODEVIEW =         2;
public static final int IMAGE_DEBUG_TYPE_FPO =              3;
public static final int IMAGE_DEBUG_TYPE_MISC =             4;
public static final int IMAGE_DEBUG_TYPE_EXCEPTION =        5;
public static final int IMAGE_DEBUG_TYPE_FIXUP =            6;
public static final int IMAGE_DEBUG_TYPE_OMAP_TO_SRC =      7;
public static final int IMAGE_DEBUG_TYPE_OMAP_FROM_SRC =    8;
public static final int IMAGE_DEBUG_TYPE_BORLAND =          9;
public static final int IMAGE_DEBUG_TYPE_RESERVED10 =       10;
public static final int IMAGE_DEBUG_TYPE_CLSID =            11;
// Targeting ..\windows\IMAGE_COFF_SYMBOLS_HEADER.java



public static final int FRAME_FPO =       0;
public static final int FRAME_TRAP =      1;
public static final int FRAME_TSS =       2;
public static final int FRAME_NONFPO =    3;
// Targeting ..\windows\FPO_DATA.java


public static final int SIZEOF_RFPO_DATA = 16;


public static final int IMAGE_DEBUG_MISC_EXENAME =    1;
// Targeting ..\windows\IMAGE_DEBUG_MISC.java


// Targeting ..\windows\IMAGE_FUNCTION_ENTRY.java


// Targeting ..\windows\IMAGE_FUNCTION_ENTRY64.java


// Targeting ..\windows\IMAGE_SEPARATE_DEBUG_HEADER.java


// Targeting ..\windows\NON_PAGED_DEBUG_INFO.java



// #ifndef _MAC
public static final int IMAGE_SEPARATE_DEBUG_SIGNATURE = 0x4944;
public static final int NON_PAGED_DEBUG_SIGNATURE =      0x494E;
// #else
// #endif

public static final int IMAGE_SEPARATE_DEBUG_FLAGS_MASK = 0x8000;
public static final int IMAGE_SEPARATE_DEBUG_MISMATCH =   0x8000;
// Targeting ..\windows\IMAGE_ARCHITECTURE_HEADER.java


// Targeting ..\windows\IMAGE_ARCHITECTURE_ENTRY.java



// #include "poppack.h"                // Back to the initial value

// The following structure defines the new import object.  Note the values of the first two fields,
// which must be set as stated in order to differentiate old and new import members.
// Following this structure, the linker emits two null-terminated strings used to recreate the
// import at the time of use.  The first string is the import's name, the second is the dll's name.

public static final int IMPORT_OBJECT_HDR_SIG2 =  0xffff;
// Targeting ..\windows\IMPORT_OBJECT_HEADER.java



/** enum IMPORT_OBJECT_TYPE */
public static final int
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2;

/** enum IMPORT_OBJECT_NAME_TYPE */
public static final int
    IMPORT_OBJECT_ORDINAL = 0,          // Import by ordinal
    IMPORT_OBJECT_NAME = 1,             // Import name == public symbol name.
    IMPORT_OBJECT_NAME_NO_PREFIX = 2,   // Import name == public symbol name skipping leading ?, @, or optionally _.
    IMPORT_OBJECT_NAME_UNDECORATE = 3;  // Import name == public symbol name skipping leading ?, @, or optionally _
                                        // and truncating at first @


// #ifndef __IMAGE_COR20_HEADER_DEFINED__
// #define __IMAGE_COR20_HEADER_DEFINED__

/** enum ReplacesCorHdrNumericDefines */
public static final int
// COM+ Header entry point flags.
    COMIMAGE_FLAGS_ILONLY               = 0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED        = 0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY           = 0x00000004,
    COMIMAGE_FLAGS_STRONGNAMESIGNED     = 0x00000008,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT    = 0x00000010,
    COMIMAGE_FLAGS_TRACKDEBUGDATA       = 0x00010000,

// Version flags for image.
    COR_VERSION_MAJOR_V2                = 2,
    COR_VERSION_MAJOR                   = COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR                   = 5,
    COR_DELETED_NAME_LENGTH             = 8,
    COR_VTABLEGAP_NAME_LENGTH           = 8,

// Maximum size of a NativeType descriptor.
    NATIVE_TYPE_MAX_CB                  = 1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 0xFF,

// #defines for the MIH FLAGS
    IMAGE_COR_MIH_METHODRVA             = 0x01,
    IMAGE_COR_MIH_EHRVA                 = 0x02,
    IMAGE_COR_MIH_BASICBLOCK            = 0x08,

// V-table constants
    COR_VTABLE_32BIT                    = 0x01,          // V-table slots are 32-bits in size.
    COR_VTABLE_64BIT                    = 0x02,          // V-table slots are 64-bits in size.
    COR_VTABLE_FROM_UNMANAGED           = 0x04,          // If set, transition from unmanaged.
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN  = 0x08,  // If set, transition from unmanaged with keeping the current appdomain.
    COR_VTABLE_CALL_MOST_DERIVED        = 0x10,          // Call most derived method described by

// EATJ constants
    IMAGE_COR_EATJ_THUNK_SIZE           = 32,            // Size of a jump thunk reserved range.

// Max name lengths
    //@todo: Change to unlimited name lengths.
    MAX_CLASS_NAME                      = 1024,
    MAX_PACKAGE_NAME                    = 1024;
// Targeting ..\windows\IMAGE_COR20_HEADER.java



// #endif // __IMAGE_COR20_HEADER_DEFINED__

//
// End Image Format
//

// #include <apiset.h>

//
// prototypes
//

// begin_ntifs

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)


// #if (NTDDI_VERSION > NTDDI_WINXP)

public static native @Cast("WORD") short RtlCaptureStackBackTrace(
    @Cast("DWORD") int FramesToSkip,
    @Cast("DWORD") int FramesToCapture,
    @Cast("PVOID*") PointerPointer BackTrace,
    @Cast("PDWORD") IntPointer BackTraceHash
    );
public static native @Cast("WORD") short RtlCaptureStackBackTrace(
    @Cast("DWORD") int FramesToSkip,
    @Cast("DWORD") int FramesToCapture,
    @Cast("PVOID*") PointerPointer BackTrace,
    @Cast("PDWORD") IntBuffer BackTraceHash
    );
public static native @Cast("WORD") short RtlCaptureStackBackTrace(
    @Cast("DWORD") int FramesToSkip,
    @Cast("DWORD") int FramesToCapture,
    @Cast("PVOID*") PointerPointer BackTrace,
    @Cast("PDWORD") int[] BackTraceHash
    );


// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if (NTDDI_VERSION > NTDDI_WIN2K)

public static native void RtlCaptureContext(
    @Cast("PCONTEXT") CONTEXT ContextRecord
    );


// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// end_ntifs

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native void RtlUnwind(
    @Cast("PVOID") Pointer TargetFrame,
    @Cast("PVOID") Pointer TargetIp,
    @Cast("PEXCEPTION_RECORD") EXCEPTION_RECORD ExceptionRecord,
    @Cast("PVOID") Pointer ReturnValue
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion


// #if defined(_AMD64_)

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOLEAN") boolean RtlAddFunctionTable(
    @Cast("PRUNTIME_FUNCTION") Pointer FunctionTable,
    @Cast("DWORD") int EntryCount,
    @Cast("DWORD64") long BaseAddress
    );


public static native @Cast("BOOLEAN") boolean RtlDeleteFunctionTable(
    @Cast("PRUNTIME_FUNCTION") Pointer FunctionTable
    );


public static native @Cast("BOOLEAN") boolean RtlInstallFunctionTableCallback(
    @Cast("DWORD64") long TableIdentifier,
    @Cast("DWORD64") long BaseAddress,
    @Cast("DWORD") int Length,
    @Cast("PGET_RUNTIME_FUNCTION_CALLBACK") Pointer Callback,
    @Cast("PVOID") Pointer Context,
    @Cast("PCWSTR") CharPointer OutOfProcessCallbackDll
    );
public static native @Cast("BOOLEAN") boolean RtlInstallFunctionTableCallback(
    @Cast("DWORD64") long TableIdentifier,
    @Cast("DWORD64") long BaseAddress,
    @Cast("DWORD") int Length,
    @Cast("PGET_RUNTIME_FUNCTION_CALLBACK") Pointer Callback,
    @Cast("PVOID") Pointer Context,
    @Cast("PCWSTR") CharBuffer OutOfProcessCallbackDll
    );
public static native @Cast("BOOLEAN") boolean RtlInstallFunctionTableCallback(
    @Cast("DWORD64") long TableIdentifier,
    @Cast("DWORD64") long BaseAddress,
    @Cast("DWORD") int Length,
    @Cast("PGET_RUNTIME_FUNCTION_CALLBACK") Pointer Callback,
    @Cast("PVOID") Pointer Context,
    @Cast("PCWSTR") char[] OutOfProcessCallbackDll
    );


// end_1_0


// #if ((NTDDI_VERSION >= NTDDI_WIN8) && !defined(_CONTRACT_GEN)) || (_APISET_RTLSUPPORT_VER > 0x0100)


// #endif // ((NTDDI_VERSION >= NTDDI_WIN8) && !defined(_CONTRACT_GEN)) || (_APISET_RTLSUPPORT_VER > 0x0100)

// begin_1_0

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("PRUNTIME_FUNCTION") Pointer RtlLookupFunctionEntry(
    @Cast("DWORD64") long ControlPc,
    @Cast("PDWORD64") LongPointer ImageBase,
    @ByVal @Cast("PUNWIND_HISTORY_TABLE*") Pointer HistoryTable
    );
public static native @Cast("PRUNTIME_FUNCTION") Pointer RtlLookupFunctionEntry(
    @Cast("DWORD64") long ControlPc,
    @Cast("PDWORD64") LongBuffer ImageBase,
    @ByVal @Cast("PUNWIND_HISTORY_TABLE*") Pointer HistoryTable
    );
public static native @Cast("PRUNTIME_FUNCTION") Pointer RtlLookupFunctionEntry(
    @Cast("DWORD64") long ControlPc,
    @Cast("PDWORD64") long[] ImageBase,
    @ByVal @Cast("PUNWIND_HISTORY_TABLE*") Pointer HistoryTable
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native void RtlRestoreContext(
    @Cast("PCONTEXT") CONTEXT ContextRecord,
    EXCEPTION_RECORD ExceptionRecord
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native void RtlUnwindEx(
    @Cast("PVOID") Pointer TargetFrame,
    @Cast("PVOID") Pointer TargetIp,
    @Cast("PEXCEPTION_RECORD") EXCEPTION_RECORD ExceptionRecord,
    @Cast("PVOID") Pointer ReturnValue,
    @Cast("PCONTEXT") CONTEXT ContextRecord,
    @ByVal @Cast("PUNWIND_HISTORY_TABLE*") Pointer HistoryTable
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("PEXCEPTION_ROUTINE") EXCEPTION_ROUTINE RtlVirtualUnwind(
    @Cast("DWORD") int HandlerType,
    @Cast("DWORD64") long ImageBase,
    @Cast("DWORD64") long ControlPc,
    @Cast("PRUNTIME_FUNCTION") Pointer FunctionEntry,
    @Cast("PCONTEXT") CONTEXT ContextRecord,
    @Cast("PVOID*") PointerPointer HandlerData,
    @Cast("PDWORD64") LongPointer EstablisherFrame,
    @ByVal @Cast("PKNONVOLATILE_CONTEXT_POINTERS*") Pointer ContextPointers
    );
public static native @Cast("PEXCEPTION_ROUTINE") EXCEPTION_ROUTINE RtlVirtualUnwind(
    @Cast("DWORD") int HandlerType,
    @Cast("DWORD64") long ImageBase,
    @Cast("DWORD64") long ControlPc,
    @Cast("PRUNTIME_FUNCTION") Pointer FunctionEntry,
    @Cast("PCONTEXT") CONTEXT ContextRecord,
    @Cast("PVOID*") PointerPointer HandlerData,
    @Cast("PDWORD64") LongBuffer EstablisherFrame,
    @ByVal @Cast("PKNONVOLATILE_CONTEXT_POINTERS*") Pointer ContextPointers
    );
public static native @Cast("PEXCEPTION_ROUTINE") EXCEPTION_ROUTINE RtlVirtualUnwind(
    @Cast("DWORD") int HandlerType,
    @Cast("DWORD64") long ImageBase,
    @Cast("DWORD64") long ControlPc,
    @Cast("PRUNTIME_FUNCTION") Pointer FunctionEntry,
    @Cast("PCONTEXT") CONTEXT ContextRecord,
    @Cast("PVOID*") PointerPointer HandlerData,
    @Cast("PDWORD64") long[] EstablisherFrame,
    @ByVal @Cast("PKNONVOLATILE_CONTEXT_POINTERS*") Pointer ContextPointers
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif // _AMD64_



// #if defined(_ARM_)

// #endif // _ARM_



// #if defined(_IA64_)

// #endif // _IA64_



// #if defined(_IA64_)

// #endif // _IA64_


// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)


// #if !(defined(_CONTRACT_GEN) && (_APISET_RTLSUPPORT_VER <= 0x0100) && defined(_X86_))

public static native @Cast("PVOID") Pointer RtlPcToFileHeader(
    @Cast("PVOID") Pointer PcValue,
    @Cast("PVOID*") PointerPointer BaseOfImage
    );


// #endif // !(defined(_CONTRACT_GEN) && (_APISET_RTLSUPPORT_VER <= 0x0100) && defined(_X86_))

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion


// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if !(defined(_CONTRACT_GEN) && (_APISET_RTLSUPPORT_VER <= 0x0100) && defined(_X86_))


// #if (NTDDI_VERSION >= NTDDI_WIN2K)
public static native @Cast("SIZE_T") long RtlCompareMemory(
    @Const Pointer Source1,
    @Const Pointer Source2,
    @Cast("SIZE_T") long Length
    );


// #endif

// #endif // !(defined(_CONTRACT_GEN) && (_APISET_RTLSUPPORT_VER <= 0x0100) && defined(_X86_))

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

//
// for move macros
//
// #ifdef _MAC
// #else
// #include <string.h>
// #endif // _MAC


// #ifndef _SLIST_HEADER_
// #define _SLIST_HEADER_

// #if defined(_WIN64)

//
// The type SINGLE_LIST_ENTRY is not suitable for use with SLISTs.  For
// WIN64, an entry on an SLIST is required to be 16-byte aligned, while a
// SINGLE_LIST_ENTRY structure has only 8 byte alignment.
//
// Therefore, all SLIST code should use the SLIST_ENTRY type instead of the
// SINGLE_LIST_ENTRY type.
//

// #pragma warning(push)
// #pragma warning(disable:4324)
// Targeting ..\windows\SLIST_ENTRY.java



// #pragma warning(pop)
// Targeting ..\windows\SLIST_HEADER.java



// #elif defined(_X86_)

// #elif defined(_ARM_)

// #endif

// #endif // _SLIST_HEADER_


// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native void RtlInitializeSListHead(
    @Cast("PSLIST_HEADER") SLIST_HEADER ListHead
    );

public static native @Cast("PSLIST_ENTRY") SLIST_ENTRY RtlFirstEntrySList(
    @Const SLIST_HEADER ListHead
    );

public static native @Cast("PSLIST_ENTRY") SLIST_ENTRY RtlInterlockedPopEntrySList(
    @Cast("PSLIST_HEADER") SLIST_HEADER ListHead
    );

public static native @Cast("PSLIST_ENTRY") SLIST_ENTRY RtlInterlockedPushEntrySList(
    @Cast("PSLIST_HEADER") SLIST_HEADER ListHead,
    @Cast("PSLIST_ENTRY") SLIST_ENTRY ListEntry
    );

public static native @Cast("PSLIST_ENTRY") SLIST_ENTRY RtlInterlockedPushListSListEx(
    @Cast("PSLIST_HEADER") SLIST_HEADER ListHead,
    @Cast("PSLIST_ENTRY") SLIST_ENTRY List,
    @Cast("PSLIST_ENTRY") SLIST_ENTRY ListEnd,
    @Cast("DWORD") int Count
    );

public static native @Cast("PSLIST_ENTRY") SLIST_ENTRY RtlInterlockedFlushSList(
    @Cast("PSLIST_HEADER") SLIST_HEADER ListHead
    );

public static native @Cast("WORD") short RtlQueryDepthSList(
    @Cast("PSLIST_HEADER") SLIST_HEADER ListHead
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion


// #ifndef _RTL_RUN_ONCE_DEF
// #define _RTL_RUN_ONCE_DEF

//
// Run once
//

public static native @MemberGetter int RTL_RUN_ONCE_INIT();
public static final int RTL_RUN_ONCE_INIT = RTL_RUN_ONCE_INIT();   // Static initializer

//
// Run once flags
//

public static final long RTL_RUN_ONCE_CHECK_ONLY =     0x00000001L;
public static final long RTL_RUN_ONCE_ASYNC =          0x00000002L;
public static final long RTL_RUN_ONCE_INIT_FAILED =    0x00000004L;

//
// The context stored in the run once structure must leave the following number
// of low order bits unused.
//

public static final int RTL_RUN_ONCE_CTX_RESERVED_BITS = 2;
// Targeting ..\windows\RTL_RUN_ONCE.java


// Targeting ..\windows\RTL_BARRIER.java

                       
// begin_ntoshvp

//
// Fast fail failure codes.
//
// N.B.  Failure code zero should not be used, but is required to be reserved
//       for compatibility with previous handling of the
//       STATUS_STACK_BUFFER_OVERRUN exception status code.
//

public static final int FAST_FAIL_LEGACY_GS_VIOLATION =         0;
public static final int FAST_FAIL_VTGUARD_CHECK_FAILURE =       1;
public static final int FAST_FAIL_STACK_COOKIE_CHECK_FAILURE =  2;
public static final int FAST_FAIL_CORRUPT_LIST_ENTRY =          3;
public static final int FAST_FAIL_INCORRECT_STACK =             4;
public static final int FAST_FAIL_INVALID_ARG =                 5;
public static final int FAST_FAIL_GS_COOKIE_INIT =              6;
public static final int FAST_FAIL_FATAL_APP_EXIT =              7;
public static final int FAST_FAIL_RANGE_CHECK_FAILURE =         8;
public static final int FAST_FAIL_UNSAFE_REGISTRY_ACCESS =      9;
public static final int FAST_FAIL_GUARD_ICALL_CHECK_FAILURE =   10;
public static final int FAST_FAIL_GUARD_WRITE_CHECK_FAILURE =   11;
public static final int FAST_FAIL_INVALID_FIBER_SWITCH =        12;
public static final int FAST_FAIL_INVALID_SET_OF_CONTEXT =      13;
public static final int FAST_FAIL_INVALID_REFERENCE_COUNT =     14;
public static final int FAST_FAIL_INVALID_JUMP_BUFFER =         18;
public static final int FAST_FAIL_MRDATA_MODIFIED =             19;
public static final int FAST_FAIL_CERTIFICATION_FAILURE =       20;
public static final int FAST_FAIL_INVALID_EXCEPTION_CHAIN =     21;
public static final int FAST_FAIL_CRYPTO_LIBRARY =              22;
public static final int FAST_FAIL_INVALID_CALL_IN_DLL_CALLOUT = 23;
public static final int FAST_FAIL_INVALID_IMAGE_BASE =          24;
public static final int FAST_FAIL_DLOAD_PROTECTION_FAILURE =    25;
public static final int FAST_FAIL_UNSAFE_EXTENSION_CALL =       26;
public static final int FAST_FAIL_INVALID_FAST_FAIL_CODE =      0xFFFFFFFF;

// #if _MSC_VER >= 1610

public static native void __fastfail(
    @Cast("unsigned int") int Code
    );

// #pragma intrinsic(__fastfail)

// #endif

public static final int HEAP_NO_SERIALIZE =               0x00000001;      
public static final int HEAP_GROWABLE =                   0x00000002;      
public static final int HEAP_GENERATE_EXCEPTIONS =        0x00000004;      
public static final int HEAP_ZERO_MEMORY =                0x00000008;      
public static final int HEAP_REALLOC_IN_PLACE_ONLY =      0x00000010;      
public static final int HEAP_TAIL_CHECKING_ENABLED =      0x00000020;      
public static final int HEAP_FREE_CHECKING_ENABLED =      0x00000040;      
public static final int HEAP_DISABLE_COALESCE_ON_FREE =   0x00000080;      
public static final int HEAP_CREATE_ALIGN_16 =            0x00010000;      
public static final int HEAP_CREATE_ENABLE_TRACING =      0x00020000;      
public static final int HEAP_CREATE_ENABLE_EXECUTE =      0x00040000;      
public static final int HEAP_MAXIMUM_TAG =                0x0FFF;              
public static final int HEAP_PSEUDO_TAG_FLAG =            0x8000;              
public static final int HEAP_TAG_SHIFT =                  18;                  
// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #if !defined(MIDL_PASS)
public static native @Cast("DWORD") int HEAP_MAKE_TAG_FLAGS(
    @Cast("DWORD") int TagBase,
    @Cast("DWORD") int Tag
    );
// #endif
// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

public static final int IS_TEXT_UNICODE_ASCII16 =               0x0001;
public static final int IS_TEXT_UNICODE_REVERSE_ASCII16 =       0x0010;

public static final int IS_TEXT_UNICODE_STATISTICS =            0x0002;
public static final int IS_TEXT_UNICODE_REVERSE_STATISTICS =    0x0020;

public static final int IS_TEXT_UNICODE_CONTROLS =              0x0004;
public static final int IS_TEXT_UNICODE_REVERSE_CONTROLS =      0x0040;

public static final int IS_TEXT_UNICODE_SIGNATURE =             0x0008;
public static final int IS_TEXT_UNICODE_REVERSE_SIGNATURE =     0x0080;

public static final int IS_TEXT_UNICODE_ILLEGAL_CHARS =         0x0100;
public static final int IS_TEXT_UNICODE_ODD_LENGTH =            0x0200;
public static final int IS_TEXT_UNICODE_DBCS_LEADBYTE =         0x0400;
public static final int IS_TEXT_UNICODE_NULL_BYTES =            0x1000;

public static final int IS_TEXT_UNICODE_UNICODE_MASK =          0x000F;
public static final int IS_TEXT_UNICODE_REVERSE_MASK =          0x00F0;
public static final int IS_TEXT_UNICODE_NOT_UNICODE_MASK =      0x0F00;
public static final int IS_TEXT_UNICODE_NOT_ASCII_MASK =        0xF000;

public static final int COMPRESSION_FORMAT_NONE =          (0x0000);   
public static final int COMPRESSION_FORMAT_DEFAULT =       (0x0001);   
public static final int COMPRESSION_FORMAT_LZNT1 =         (0x0002);   
public static final int COMPRESSION_FORMAT_XPRESS =        (0x0003);   
public static final int COMPRESSION_FORMAT_XPRESS_HUFF =   (0x0004);   
public static final int COMPRESSION_ENGINE_STANDARD =      (0x0000);   
public static final int COMPRESSION_ENGINE_MAXIMUM =       (0x0100);   
public static final int COMPRESSION_ENGINE_HIBER =         (0x0200);   

// #if defined(_DBG_MEMCPY_INLINE_) && !defined(MIDL_PASS) && !defined(_MEMCPY_INLINE_) && !defined(_CRTBLD)
// #endif


// #define RtlEqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))
// #define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
// #define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
// #define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
// #define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))


// #if !defined(MIDL_PASS)

public static native @Cast("PVOID") Pointer RtlSecureZeroMemory(
    @Cast("PVOID") Pointer ptr,
    @Cast("SIZE_T") long cnt
    );

// #endif


public static final int SEF_DACL_AUTO_INHERIT =             0x01;
public static final int SEF_SACL_AUTO_INHERIT =             0x02;
public static final int SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT = 0x04;
public static final int SEF_AVOID_PRIVILEGE_CHECK =         0x08;
public static final int SEF_AVOID_OWNER_CHECK =             0x10;
public static final int SEF_DEFAULT_OWNER_FROM_PARENT =     0x20;
public static final int SEF_DEFAULT_GROUP_FROM_PARENT =     0x40;
public static final int SEF_MACL_NO_WRITE_UP =              0x100;
public static final int SEF_MACL_NO_READ_UP =               0x200;
public static final int SEF_MACL_NO_EXECUTE_UP =            0x400;
public static final int SEF_AI_USE_EXTRA_PARAMS =           0x800;
public static final int SEF_AVOID_OWNER_RESTRICTION =       0x1000;

public static final int SEF_MACL_VALID_FLAGS =              (SEF_MACL_NO_WRITE_UP   | 
                                           SEF_MACL_NO_READ_UP    | 
                                           SEF_MACL_NO_EXECUTE_UP);
// Targeting ..\windows\MESSAGE_RESOURCE_ENTRY.java



public static final int MESSAGE_RESOURCE_UNICODE = 0x0001;
// Targeting ..\windows\MESSAGE_RESOURCE_BLOCK.java


// Targeting ..\windows\MESSAGE_RESOURCE_DATA.java


// Targeting ..\windows\OSVERSIONINFOA.java


// Targeting ..\windows\OSVERSIONINFOW.java


// #ifdef UNICODE
// Targeting ..\windows\OSVERSIONINFOEXA.java


// Targeting ..\windows\OSVERSIONINFOEXW.java


// #ifdef UNICODE
// #else
// #endif // UNICODE

//
// RtlVerifyVersionInfo() conditions
//

public static final int VER_EQUAL =                       1;
public static final int VER_GREATER =                     2;
public static final int VER_GREATER_EQUAL =               3;
public static final int VER_LESS =                        4;
public static final int VER_LESS_EQUAL =                  5;
public static final int VER_AND =                         6;
public static final int VER_OR =                          7;

public static final int VER_CONDITION_MASK =              7;
public static final int VER_NUM_BITS_PER_CONDITION_MASK = 3;

//
// RtlVerifyVersionInfo() type mask bits
//

public static final int VER_MINORVERSION =                0x0000001;
public static final int VER_MAJORVERSION =                0x0000002;
public static final int VER_BUILDNUMBER =                 0x0000004;
public static final int VER_PLATFORMID =                  0x0000008;
public static final int VER_SERVICEPACKMINOR =            0x0000010;
public static final int VER_SERVICEPACKMAJOR =            0x0000020;
public static final int VER_SUITENAME =                   0x0000040;
public static final int VER_PRODUCT_TYPE =                0x0000080;

//
// RtlVerifyVersionInfo() os product type values
//

public static final int VER_NT_WORKSTATION =              0x0000001;
public static final int VER_NT_DOMAIN_CONTROLLER =        0x0000002;
public static final int VER_NT_SERVER =                   0x0000003;

//
// dwPlatformId defines:
//

public static final int VER_PLATFORM_WIN32s =             0;
public static final int VER_PLATFORM_WIN32_WINDOWS =      1;
public static final int VER_PLATFORM_WIN32_NT =           2;

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

//
//
// VerifyVersionInfo() macro to set the condition mask
//
// For documentation sakes here's the old version of the macro that got
// changed to call an API
// #define VER_SET_CONDITION(_m_,_t_,_c_)  _m_=(_m_|(_c_<<(1<<_t_)))
//

// #define VER_SET_CONDITION(_m_,_t_,_c_)
//         ((_m_)=VerSetConditionMask((_m_),(_t_),(_c_)))

// #if !defined(_WINBASE_) && !defined(MIDL_PASS)

// #if (NTDDI_VERSION >= NTDDI_WIN2K)

public static native @Cast("ULONGLONG") long VerSetConditionMask(
    @Cast("ULONGLONG") long ConditionMask,
    @Cast("DWORD") int TypeMask,
    @Cast("BYTE") byte Condition
    );

// #endif

// #endif // !defined(_WINBASE_) && !defined(MIDL_PASS)

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

//

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// begin_ntddk

// #if (NTDDI_VERSION >= NTDDI_VISTA)

public static native @Cast("BOOLEAN") boolean RtlGetProductInfo(
    @Cast("DWORD") int OSMajorVersion,
    @Cast("DWORD") int OSMinorVersion,
    @Cast("DWORD") int SpMajorVersion,
    @Cast("DWORD") int SpMinorVersion,
    @Cast("PDWORD") IntPointer ReturnedProductType
    );
public static native @Cast("BOOLEAN") boolean RtlGetProductInfo(
    @Cast("DWORD") int OSMajorVersion,
    @Cast("DWORD") int OSMinorVersion,
    @Cast("DWORD") int SpMajorVersion,
    @Cast("DWORD") int SpMinorVersion,
    @Cast("PDWORD") IntBuffer ReturnedProductType
    );
public static native @Cast("BOOLEAN") boolean RtlGetProductInfo(
    @Cast("DWORD") int OSMajorVersion,
    @Cast("DWORD") int OSMinorVersion,
    @Cast("DWORD") int SpMajorVersion,
    @Cast("DWORD") int SpMinorVersion,
    @Cast("PDWORD") int[] ReturnedProductType
    );

// #endif

// end_ntddk

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

public static final int RTL_UMS_VERSION =  (0x0100);  

/** enum RTL_UMS_THREAD_INFO_CLASS */
public static final int
    UmsThreadInvalidInfoClass = 0,
    UmsThreadUserContext = 1,
    UmsThreadPriority = 2,              // Reserved
    UmsThreadAffinity = 3,              // Reserved
    UmsThreadTeb = 4,
    UmsThreadIsSuspended = 5,
    UmsThreadIsTerminated = 6,
    UmsThreadMaxInfoClass = 7;

/** enum RTL_UMS_SCHEDULER_REASON */
public static final int
    UmsSchedulerStartup = 0,
    UmsSchedulerThreadBlocked = 1,
    UmsSchedulerThreadYield = 2;
// Targeting ..\windows\RTL_UMS_SCHEDULER_ENTRY_POINT.java


// Targeting ..\windows\RTL_CRITICAL_SECTION_DEBUG.java



public static final int RTL_CRITSECT_TYPE = 0;
public static final int RTL_RESOURCE_TYPE = 1;

//
// These flags define the upper byte of the critical section SpinCount field
//
public static final int RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO =         0x01000000;
public static final int RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN =          0x02000000;
public static final int RTL_CRITICAL_SECTION_FLAG_STATIC_INIT =           0x04000000;
public static final int RTL_CRITICAL_SECTION_FLAG_RESOURCE_TYPE =         0x08000000;
public static final int RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO =      0x10000000;
public static final int RTL_CRITICAL_SECTION_ALL_FLAG_BITS =              0xFF000000;
public static final int RTL_CRITICAL_SECTION_FLAG_RESERVED =              (RTL_CRITICAL_SECTION_ALL_FLAG_BITS & (~(RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO | RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN | RTL_CRITICAL_SECTION_FLAG_STATIC_INIT | RTL_CRITICAL_SECTION_FLAG_RESOURCE_TYPE | RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO)));

//
// These flags define possible values stored in the Flags field of a critsec debuginfo.
//
public static final int RTL_CRITICAL_SECTION_DEBUG_FLAG_STATIC_INIT =     0x00000001;

// #pragma pack(push, 8)
// Targeting ..\windows\RTL_CRITICAL_SECTION.java



// #pragma pack(pop)
// Targeting ..\windows\RTL_SRWLOCK.java

                            
public static native @MemberGetter int RTL_SRWLOCK_INIT();
public static final int RTL_SRWLOCK_INIT = RTL_SRWLOCK_INIT();
// Targeting ..\windows\RTL_CONDITION_VARIABLE.java

      
public static native @MemberGetter int RTL_CONDITION_VARIABLE_INIT();
public static final int RTL_CONDITION_VARIABLE_INIT = RTL_CONDITION_VARIABLE_INIT();                 
public static final int RTL_CONDITION_VARIABLE_LOCKMODE_SHARED =  0x1;
// Targeting ..\windows\PAPCFUNC.java


// Targeting ..\windows\PVECTORED_EXCEPTION_HANDLER.java



/** enum HEAP_INFORMATION_CLASS */
public static final int

    HeapCompatibilityInformation = 0,
    HeapEnableTerminationOnCorruption = 1;


// #if ((NTDDI_VERSION > NTDDI_WINBLUE) ||
//      (NTDDI_VERSION == NTDDI_WINBLUE && defined(WINBLUE_KBSPRING14)))

// #endif

// #if ((NTDDI_VERSION > NTDDI_WINBLUE) ||
//      (NTDDI_VERSION == NTDDI_WINBLUE && defined(WINBLUE_KBSPRING14)))

// #endif


public static final int WT_EXECUTEDEFAULT =       0x00000000;                           
public static final int WT_EXECUTEINIOTHREAD =    0x00000001;                           
public static final int WT_EXECUTEINUITHREAD =    0x00000002;                           
public static final int WT_EXECUTEINWAITTHREAD =  0x00000004;                           
public static final int WT_EXECUTEONLYONCE =      0x00000008;                           
public static final int WT_EXECUTEINTIMERTHREAD = 0x00000020;                           
public static final int WT_EXECUTELONGFUNCTION =  0x00000010;                           
public static final int WT_EXECUTEINPERSISTENTIOTHREAD =  0x00000040;                   
public static final int WT_EXECUTEINPERSISTENTTHREAD = 0x00000080;                      
public static final int WT_TRANSFER_IMPERSONATION = 0x00000100;                         
// #define WT_SET_MAX_THREADPOOL_THREADS(Flags, Limit)  ((Flags) |= (Limit)<<16)
// Targeting ..\windows\WAITORTIMERCALLBACKFUNC.java


// Targeting ..\windows\WORKERCALLBACKFUNC.java


// Targeting ..\windows\APC_CALLBACK_FUNCTION.java


// Targeting ..\windows\PFLS_CALLBACK_FUNCTION.java


// Targeting ..\windows\PSECURE_MEMORY_CACHE_CALLBACK.java



public static final int WT_EXECUTEINLONGTHREAD =  0x00000010;                           
public static final int WT_EXECUTEDELETEWAIT =    0x00000008;                           

/** enum ACTIVATION_CONTEXT_INFO_CLASS */
public static final int
    ActivationContextBasicInformation                       = 1,
    ActivationContextDetailedInformation                    = 2,
    AssemblyDetailedInformationInActivationContext          = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext  = 4,
    RunlevelInformationInActivationContext                  = 5,
    CompatibilityInformationInActivationContext             = 6,
    ActivationContextManifestResourceName                   = 7,
    MaxActivationContextInfoClass = 8,

    //
    // compatibility with old names
    //
    AssemblyDetailedInformationInActivationContxt           = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt   = 4;

// #define ACTIVATIONCONTEXTINFOCLASS ACTIVATION_CONTEXT_INFO_CLASS
// Targeting ..\windows\ACTIVATION_CONTEXT_QUERY_INDEX.java


// Targeting ..\windows\_ACTIVATION_CONTEXT_QUERY_INDEX.java




public static final int ACTIVATION_CONTEXT_PATH_TYPE_NONE = (1);
public static final int ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE = (2);
public static final int ACTIVATION_CONTEXT_PATH_TYPE_URL = (3);
public static final int ACTIVATION_CONTEXT_PATH_TYPE_ASSEMBLYREF = (4);
// Targeting ..\windows\ASSEMBLY_FILE_DETAILED_INFORMATION.java



//
// compatibility with old names
// The new names use "file" consistently.
//
// #define  _ASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION  _ASSEMBLY_FILE_DETAILED_INFORMATION
// #define   ASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION   ASSEMBLY_FILE_DETAILED_INFORMATION
// #define  PASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION  PASSEMBLY_FILE_DETAILED_INFORMATION
// #define PCASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION PCASSEMBLY_FILE_DETAILED_INFORMATION
// Targeting ..\windows\ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION.java


// Targeting ..\windows\_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION.java



/** enum ACTCTX_REQUESTED_RUN_LEVEL */
public static final int
    ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
    ACTCTX_RUN_LEVEL_AS_INVOKER = 1,
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = 2,
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN = 3,
    ACTCTX_RUN_LEVEL_NUMBERS = 4;
// Targeting ..\windows\ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION.java


// Targeting ..\windows\_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION.java



/** enum ACTCTX_COMPATIBILITY_ELEMENT_TYPE */
public static final int
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS = 1,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION = 2;
// Targeting ..\windows\COMPATIBILITY_CONTEXT_ELEMENT.java


// Targeting ..\windows\_COMPATIBILITY_CONTEXT_ELEMENT.java



// #pragma warning(push)
// #pragma warning(disable:4200)
// Targeting ..\windows\ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION.java



// #pragma warning(pop)
// Targeting ..\windows\_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION.java



public static final int MAX_SUPPORTED_OS_NUM =    (4);
public static final int INVALID_OS_COUNT =        (0xffff);
// Targeting ..\windows\SUPPORTED_OS_INFO.java


// Targeting ..\windows\ACTIVATION_CONTEXT_DETAILED_INFORMATION.java


// Targeting ..\windows\_ACTIVATION_CONTEXT_DETAILED_INFORMATION.java




public static final int CREATE_BOUNDARY_DESCRIPTOR_ADD_APPCONTAINER_SID = 0x1;
// Targeting ..\windows\HARDWARE_COUNTER_DATA.java



public static final int PERFORMANCE_DATA_VERSION = 1;
// Targeting ..\windows\PERFORMANCE_DATA.java



public static final int READ_THREAD_PROFILING_FLAG_DISPATCHING =        0x00000001;
public static final int READ_THREAD_PROFILING_FLAG_HARDWARE_COUNTERS =  0x00000002;
public static final int DLL_PROCESS_ATTACH =   1;    
public static final int DLL_THREAD_ATTACH =    2;    
public static final int DLL_THREAD_DETACH =    3;    
public static final int DLL_PROCESS_DETACH =   0;    

//
// Defines for the READ flags for Eventlogging
//
public static final int EVENTLOG_SEQUENTIAL_READ =        0x0001;
public static final int EVENTLOG_SEEK_READ =              0x0002;
public static final int EVENTLOG_FORWARDS_READ =          0x0004;
public static final int EVENTLOG_BACKWARDS_READ =         0x0008;

//
// The types of events that can be logged.
//
public static final int EVENTLOG_SUCCESS =                0x0000;
public static final int EVENTLOG_ERROR_TYPE =             0x0001;
public static final int EVENTLOG_WARNING_TYPE =           0x0002;
public static final int EVENTLOG_INFORMATION_TYPE =       0x0004;
public static final int EVENTLOG_AUDIT_SUCCESS =          0x0008;
public static final int EVENTLOG_AUDIT_FAILURE =          0x0010;

//
// Defines for the WRITE flags used by Auditing for paired events
// These are not implemented in Product 1
//

public static final int EVENTLOG_START_PAIRED_EVENT =    0x0001;
public static final int EVENTLOG_END_PAIRED_EVENT =      0x0002;
public static final int EVENTLOG_END_ALL_PAIRED_EVENTS = 0x0004;
public static final int EVENTLOG_PAIRED_EVENT_ACTIVE =   0x0008;
public static final int EVENTLOG_PAIRED_EVENT_INACTIVE = 0x0010;
// Targeting ..\windows\EVENTLOGRECORD.java



//SS: start of changes to support clustering
//SS: ideally the
public static final int MAXLOGICALLOGNAMESIZE =   256;

// #if _MSC_VER >= 1200
// #pragma warning(push)
// #endif
// #pragma warning(disable : 4200)
// Targeting ..\windows\EVENTSFORLOGFILE.java


// Targeting ..\windows\PACKEDEVENTINFO.java


// Targeting ..\windows\_EVENTSFORLOGFILE.java


// Targeting ..\windows\_PACKEDEVENTINFO.java



// #endif

// #if _MSC_VER >= 1200
// #pragma warning(pop)
// #else
// #pragma warning(default : 4200) /* nonstandard extension used : zero-sized array in struct/union */
// #endif
//SS: end of changes to support clustering
//

// begin_wdm
//
// Registry Specific Access Rights.
//

public static final int KEY_QUERY_VALUE =         (0x0001);
public static final int KEY_SET_VALUE =           (0x0002);
public static final int KEY_CREATE_SUB_KEY =      (0x0004);
public static final int KEY_ENUMERATE_SUB_KEYS =  (0x0008);
public static final int KEY_NOTIFY =              (0x0010);
public static final int KEY_CREATE_LINK =         (0x0020);
public static final int KEY_WOW64_32KEY =         (0x0200);
public static final int KEY_WOW64_64KEY =         (0x0100);
public static final int KEY_WOW64_RES =           (0x0300);

public static final long KEY_READ =                ((STANDARD_RIGHTS_READ       |
                                  KEY_QUERY_VALUE            |
                                  KEY_ENUMERATE_SUB_KEYS     |
                                  KEY_NOTIFY)                 
                                  &                           
                                 (~SYNCHRONIZE));


public static final long KEY_WRITE =               ((STANDARD_RIGHTS_WRITE      |
                                  KEY_SET_VALUE              |
                                  KEY_CREATE_SUB_KEY)         
                                  &                           
                                 (~SYNCHRONIZE));

public static final long KEY_EXECUTE =             ((KEY_READ)                   
                                  &                           
                                 (~SYNCHRONIZE));

public static final long KEY_ALL_ACCESS =          ((STANDARD_RIGHTS_ALL        |
                                  KEY_QUERY_VALUE            |
                                  KEY_SET_VALUE              |
                                  KEY_CREATE_SUB_KEY         |
                                  KEY_ENUMERATE_SUB_KEYS     |
                                  KEY_NOTIFY                 |
                                  KEY_CREATE_LINK)            
                                  &                           
                                 (~SYNCHRONIZE));

//
// Open/Create Options
//

public static final long REG_OPTION_RESERVED =         (0x00000000L);   // Parameter is reserved

public static final long REG_OPTION_NON_VOLATILE =     (0x00000000L);   // Key is preserved
                                                    // when system is rebooted

public static final long REG_OPTION_VOLATILE =         (0x00000001L);   // Key is not preserved
                                                    // when system is rebooted

public static final long REG_OPTION_CREATE_LINK =      (0x00000002L);   // Created key is a
                                                    // symbolic link

public static final long REG_OPTION_BACKUP_RESTORE =   (0x00000004L);   // open for backup or restore
                                                    // special access rules
                                                    // privilege required

public static final long REG_OPTION_OPEN_LINK =        (0x00000008L);   // Open symbolic link

public static final long REG_LEGAL_OPTION =            
                (REG_OPTION_RESERVED            |
                 REG_OPTION_NON_VOLATILE        |
                 REG_OPTION_VOLATILE            |
                 REG_OPTION_CREATE_LINK         |
                 REG_OPTION_BACKUP_RESTORE      |
                 REG_OPTION_OPEN_LINK);

public static final long REG_OPEN_LEGAL_OPTION =       
                (REG_OPTION_RESERVED            |
                 REG_OPTION_BACKUP_RESTORE      |
                 REG_OPTION_OPEN_LINK);

//
// Key creation/open disposition
//

public static final long REG_CREATED_NEW_KEY =         (0x00000001L);   // New Registry Key created
public static final long REG_OPENED_EXISTING_KEY =     (0x00000002L);   // Existing Key opened

//
// hive format to be used by Reg(Nt)SaveKeyEx
//
public static final int REG_STANDARD_FORMAT =     1;
public static final int REG_LATEST_FORMAT =       2;
public static final int REG_NO_COMPRESSION =      4;

//
// Key restore & hive load flags
//

public static final long REG_WHOLE_HIVE_VOLATILE =         (0x00000001L);   // Restore whole hive volatile
public static final long REG_REFRESH_HIVE =                (0x00000002L);   // Unwind changes to last flush
public static final long REG_NO_LAZY_FLUSH =               (0x00000004L);   // Never lazy flush this hive
public static final long REG_FORCE_RESTORE =               (0x00000008L);   // Force the restore process even when we have open handles on subkeys
public static final long REG_APP_HIVE =                    (0x00000010L);   // Loads the hive visible to the calling process
public static final long REG_PROCESS_PRIVATE =             (0x00000020L);   // Hive cannot be mounted by any other process while in use
public static final long REG_START_JOURNAL =               (0x00000040L);   // Starts Hive Journal
public static final long REG_HIVE_EXACT_FILE_GROWTH =      (0x00000080L);   // Grow hive file in exact 4k increments
public static final long REG_HIVE_NO_RM =                  (0x00000100L);   // No RM is started for this hive (no transactions)
public static final long REG_HIVE_SINGLE_LOG =             (0x00000200L);   // Legacy single logging is used for this hive
public static final long REG_BOOT_HIVE =                   (0x00000400L);   // This hive might be used by the OS loader
public static final long REG_LOAD_HIVE_OPEN_HANDLE =       (0x00000800L);   // Load the hive and return a handle to its root kcb
public static final long REG_FLUSH_HIVE_FILE_GROWTH =      (0x00001000L);   // Flush changes to primary hive file size as part of all flushes

//
// Unload Flags
//
public static final int REG_FORCE_UNLOAD =            1;

//
// Notify filter values
//

public static final long REG_NOTIFY_CHANGE_NAME =          (0x00000001L); // Create or delete (child)
public static final long REG_NOTIFY_CHANGE_ATTRIBUTES =    (0x00000002L);
public static final long REG_NOTIFY_CHANGE_LAST_SET =      (0x00000004L); // time stamp
public static final long REG_NOTIFY_CHANGE_SECURITY =      (0x00000008L);
public static final long REG_NOTIFY_THREAD_AGNOSTIC =      (0x10000000L); // Not associated with a calling thread, can only be used
                                                      // for async user event based notification

public static final long REG_LEGAL_CHANGE_FILTER =                 
                (REG_NOTIFY_CHANGE_NAME          |
                 REG_NOTIFY_CHANGE_ATTRIBUTES    |
                 REG_NOTIFY_CHANGE_LAST_SET      |
                 REG_NOTIFY_CHANGE_SECURITY      |
                 REG_NOTIFY_THREAD_AGNOSTIC);

// end_wdm

//
//
// Predefined Value Types.
//

public static final int REG_NONE =                    ( 0 );   // No value type
public static final int REG_SZ =                      ( 1 );   // Unicode nul terminated string
public static final int REG_EXPAND_SZ =               ( 2 );   // Unicode nul terminated string
                                            // (with environment variable references)
public static final int REG_BINARY =                  ( 3 );   // Free form binary
public static final int REG_DWORD =                   ( 4 );   // 32-bit number
public static final int REG_DWORD_LITTLE_ENDIAN =     ( 4 );   // 32-bit number (same as REG_DWORD)
public static final int REG_DWORD_BIG_ENDIAN =        ( 5 );   // 32-bit number
public static final int REG_LINK =                    ( 6 );   // Symbolic Link (unicode)
public static final int REG_MULTI_SZ =                ( 7 );   // Multiple Unicode strings
public static final int REG_RESOURCE_LIST =           ( 8 );   // Resource list in the resource map
public static final int REG_FULL_RESOURCE_DESCRIPTOR = ( 9 );  // Resource list in the hardware description
public static final int REG_RESOURCE_REQUIREMENTS_LIST = ( 10 );
public static final int REG_QWORD =                   ( 11 );  // 64-bit number
public static final int REG_QWORD_LITTLE_ENDIAN =     ( 11 );  // 64-bit number (same as REG_QWORD)

// end_wdm

// begin_wdm
//
// Service Types (Bit Mask)
//
public static final int SERVICE_KERNEL_DRIVER =          0x00000001;
public static final int SERVICE_FILE_SYSTEM_DRIVER =     0x00000002;
public static final int SERVICE_ADAPTER =                0x00000004;
public static final int SERVICE_RECOGNIZER_DRIVER =      0x00000008;

public static final int SERVICE_DRIVER =                 (SERVICE_KERNEL_DRIVER | 
                                        SERVICE_FILE_SYSTEM_DRIVER | 
                                        SERVICE_RECOGNIZER_DRIVER);

public static final int SERVICE_WIN32_OWN_PROCESS =      0x00000010;
public static final int SERVICE_WIN32_SHARE_PROCESS =    0x00000020;
public static final int SERVICE_WIN32 =                  (SERVICE_WIN32_OWN_PROCESS | 
                                        SERVICE_WIN32_SHARE_PROCESS);

public static final int SERVICE_INTERACTIVE_PROCESS =    0x00000100;

public static final int SERVICE_TYPE_ALL =               (SERVICE_WIN32  | 
                                        SERVICE_ADAPTER | 
                                        SERVICE_DRIVER  | 
                                        SERVICE_INTERACTIVE_PROCESS);

//
// Start Type
//

public static final int SERVICE_BOOT_START =             0x00000000;
public static final int SERVICE_SYSTEM_START =           0x00000001;
public static final int SERVICE_AUTO_START =             0x00000002;
public static final int SERVICE_DEMAND_START =           0x00000003;
public static final int SERVICE_DISABLED =               0x00000004;

//
// Error control type
//
public static final int SERVICE_ERROR_IGNORE =           0x00000000;
public static final int SERVICE_ERROR_NORMAL =           0x00000001;
public static final int SERVICE_ERROR_SEVERE =           0x00000002;
public static final int SERVICE_ERROR_CRITICAL =         0x00000003;

//
//
// Define the registry driver node enumerations
//

/** enum SERVICE_NODE_TYPE */
public static final int
    DriverType               = SERVICE_KERNEL_DRIVER,
    FileSystemType           = SERVICE_FILE_SYSTEM_DRIVER,
    Win32ServiceOwnProcess   = SERVICE_WIN32_OWN_PROCESS,
    Win32ServiceShareProcess = SERVICE_WIN32_SHARE_PROCESS,
    AdapterType              = SERVICE_ADAPTER,
    RecognizerType           = SERVICE_RECOGNIZER_DRIVER;

/** enum SERVICE_LOAD_TYPE */
public static final int
    BootLoad    = SERVICE_BOOT_START,
    SystemLoad  = SERVICE_SYSTEM_START,
    AutoLoad    = SERVICE_AUTO_START,
    DemandLoad  = SERVICE_DEMAND_START,
    DisableLoad = SERVICE_DISABLED;

/** enum SERVICE_ERROR_TYPE */
public static final int
    IgnoreError   = SERVICE_ERROR_IGNORE,
    NormalError   = SERVICE_ERROR_NORMAL,
    SevereError   = SERVICE_ERROR_SEVERE,
    CriticalError = SERVICE_ERROR_CRITICAL;

//
// Service node Flags. These flags are used by the OS loader to promote
// a driver's start type to boot start if the system is booting using
// the specified mechanism. The flags should be set in the driver's
// registry configuration.
//
// CM_SERVICE_NETWORK_BOOT_LOAD - Specified if a driver should be
// promoted on network boot.
//
// CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD - Specified if a driver should be
// promoted on booting from a VHD.
//
// CM_SERVICE_USB_DISK_BOOT_LOAD - Specified if a driver should be promoted
// while booting from a USB disk.
//
// CM_SERVICE_SD_DISK_BOOT_LOAD - Specified if a driver should be promoted
// while booting from SD storage.
//
// CM_SERVICE_USB3_DISK_BOOT_LOAD - Specified if a driver should be promoted
// while booting from a disk on a USB3 controller.
//
// CM_SERVICE_MEASURED_BOOT_LOAD - Specified if a driver should be promoted
// while booting with measured boot enabled.
//
// CM_SERVICE_VERIFIER_BOOT_LOAD - Specified if a driver should be promoted
// while booting with verifier boot enabled.
//
// CM_SERVICE_WINPE_BOOT_LOAD - Specified if a driver should be promoted
// on WinPE boot.
//

public static final int CM_SERVICE_NETWORK_BOOT_LOAD =      0x00000001;
public static final int CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD = 0x00000002;
public static final int CM_SERVICE_USB_DISK_BOOT_LOAD =     0x00000004;
public static final int CM_SERVICE_SD_DISK_BOOT_LOAD =      0x00000008;
public static final int CM_SERVICE_USB3_DISK_BOOT_LOAD =    0x00000010;
public static final int CM_SERVICE_MEASURED_BOOT_LOAD =     0x00000020;
public static final int CM_SERVICE_VERIFIER_BOOT_LOAD =     0x00000040;
public static final int CM_SERVICE_WINPE_BOOT_LOAD =        0x00000080;

//
// Mask defining the legal promotion flag values.
//

public static final int CM_SERVICE_VALID_PROMOTION_MASK = (CM_SERVICE_NETWORK_BOOT_LOAD |       
                                         CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD |  
                                         CM_SERVICE_USB_DISK_BOOT_LOAD |      
                                         CM_SERVICE_SD_DISK_BOOT_LOAD |       
                                         CM_SERVICE_USB3_DISK_BOOT_LOAD |     
                                         CM_SERVICE_MEASURED_BOOT_LOAD |      
                                         CM_SERVICE_VERIFIER_BOOT_LOAD |      
                                         CM_SERVICE_WINPE_BOOT_LOAD);


// #ifndef _NTDDTAPE_WINNT_
// #define _NTDDTAPE_WINNT_

//
// IOCTL_TAPE_ERASE definitions
//

public static final long TAPE_ERASE_SHORT =            0L;
public static final long TAPE_ERASE_LONG =             1L;
// Targeting ..\windows\TAPE_ERASE.java



//
// IOCTL_TAPE_PREPARE definitions
//

public static final long TAPE_LOAD =                   0L;
public static final long TAPE_UNLOAD =                 1L;
public static final long TAPE_TENSION =                2L;
public static final long TAPE_LOCK =                   3L;
public static final long TAPE_UNLOCK =                 4L;
public static final long TAPE_FORMAT =                 5L;
// Targeting ..\windows\TAPE_PREPARE.java



//
// IOCTL_TAPE_WRITE_MARKS definitions
//

public static final long TAPE_SETMARKS =               0L;
public static final long TAPE_FILEMARKS =              1L;
public static final long TAPE_SHORT_FILEMARKS =        2L;
public static final long TAPE_LONG_FILEMARKS =         3L;
// Targeting ..\windows\TAPE_WRITE_MARKS.java



//
// IOCTL_TAPE_GET_POSITION definitions
//

public static final long TAPE_ABSOLUTE_POSITION =       0L;
public static final long TAPE_LOGICAL_POSITION =        1L;
public static final long TAPE_PSEUDO_LOGICAL_POSITION = 2L;
// Targeting ..\windows\TAPE_GET_POSITION.java



//
// IOCTL_TAPE_SET_POSITION definitions
//

public static final long TAPE_REWIND =                 0L;
public static final long TAPE_ABSOLUTE_BLOCK =         1L;
public static final long TAPE_LOGICAL_BLOCK =          2L;
public static final long TAPE_PSEUDO_LOGICAL_BLOCK =   3L;
public static final long TAPE_SPACE_END_OF_DATA =      4L;
public static final long TAPE_SPACE_RELATIVE_BLOCKS =  5L;
public static final long TAPE_SPACE_FILEMARKS =        6L;
public static final long TAPE_SPACE_SEQUENTIAL_FMKS =  7L;
public static final long TAPE_SPACE_SETMARKS =         8L;
public static final long TAPE_SPACE_SEQUENTIAL_SMKS =  9L;
// Targeting ..\windows\TAPE_SET_POSITION.java



//
// IOCTL_TAPE_GET_DRIVE_PARAMS definitions
//

//
// Definitions for FeaturesLow parameter
//

public static final int TAPE_DRIVE_FIXED =            0x00000001;
public static final int TAPE_DRIVE_SELECT =           0x00000002;
public static final int TAPE_DRIVE_INITIATOR =        0x00000004;

public static final int TAPE_DRIVE_ERASE_SHORT =      0x00000010;
public static final int TAPE_DRIVE_ERASE_LONG =       0x00000020;
public static final int TAPE_DRIVE_ERASE_BOP_ONLY =   0x00000040;
public static final int TAPE_DRIVE_ERASE_IMMEDIATE =  0x00000080;

public static final int TAPE_DRIVE_TAPE_CAPACITY =    0x00000100;
public static final int TAPE_DRIVE_TAPE_REMAINING =   0x00000200;
public static final int TAPE_DRIVE_FIXED_BLOCK =      0x00000400;
public static final int TAPE_DRIVE_VARIABLE_BLOCK =   0x00000800;

public static final int TAPE_DRIVE_WRITE_PROTECT =    0x00001000;
public static final int TAPE_DRIVE_EOT_WZ_SIZE =      0x00002000;

public static final int TAPE_DRIVE_ECC =              0x00010000;
public static final int TAPE_DRIVE_COMPRESSION =      0x00020000;
public static final int TAPE_DRIVE_PADDING =          0x00040000;
public static final int TAPE_DRIVE_REPORT_SMKS =      0x00080000;

public static final int TAPE_DRIVE_GET_ABSOLUTE_BLK = 0x00100000;
public static final int TAPE_DRIVE_GET_LOGICAL_BLK =  0x00200000;
public static final int TAPE_DRIVE_SET_EOT_WZ_SIZE =  0x00400000;

public static final int TAPE_DRIVE_EJECT_MEDIA =      0x01000000;
public static final int TAPE_DRIVE_CLEAN_REQUESTS =   0x02000000;
public static final int TAPE_DRIVE_SET_CMP_BOP_ONLY = 0x04000000;

public static final int TAPE_DRIVE_RESERVED_BIT =     0x80000000;  //don't use this bit!
//                                              //can't be a low features bit!
//                                              //reserved; high features only

//
// Definitions for FeaturesHigh parameter
//

public static final int TAPE_DRIVE_LOAD_UNLOAD =      0x80000001;
public static final int TAPE_DRIVE_TENSION =          0x80000002;
public static final int TAPE_DRIVE_LOCK_UNLOCK =      0x80000004;
public static final int TAPE_DRIVE_REWIND_IMMEDIATE = 0x80000008;

public static final int TAPE_DRIVE_SET_BLOCK_SIZE =   0x80000010;
public static final int TAPE_DRIVE_LOAD_UNLD_IMMED =  0x80000020;
public static final int TAPE_DRIVE_TENSION_IMMED =    0x80000040;
public static final int TAPE_DRIVE_LOCK_UNLK_IMMED =  0x80000080;

public static final int TAPE_DRIVE_SET_ECC =          0x80000100;
public static final int TAPE_DRIVE_SET_COMPRESSION =  0x80000200;
public static final int TAPE_DRIVE_SET_PADDING =      0x80000400;
public static final int TAPE_DRIVE_SET_REPORT_SMKS =  0x80000800;

public static final int TAPE_DRIVE_ABSOLUTE_BLK =     0x80001000;
public static final int TAPE_DRIVE_ABS_BLK_IMMED =    0x80002000;
public static final int TAPE_DRIVE_LOGICAL_BLK =      0x80004000;
public static final int TAPE_DRIVE_LOG_BLK_IMMED =    0x80008000;

public static final int TAPE_DRIVE_END_OF_DATA =      0x80010000;
public static final int TAPE_DRIVE_RELATIVE_BLKS =    0x80020000;
public static final int TAPE_DRIVE_FILEMARKS =        0x80040000;
public static final int TAPE_DRIVE_SEQUENTIAL_FMKS =  0x80080000;

public static final int TAPE_DRIVE_SETMARKS =         0x80100000;
public static final int TAPE_DRIVE_SEQUENTIAL_SMKS =  0x80200000;
public static final int TAPE_DRIVE_REVERSE_POSITION = 0x80400000;
public static final int TAPE_DRIVE_SPACE_IMMEDIATE =  0x80800000;

public static final int TAPE_DRIVE_WRITE_SETMARKS =   0x81000000;
public static final int TAPE_DRIVE_WRITE_FILEMARKS =  0x82000000;
public static final int TAPE_DRIVE_WRITE_SHORT_FMKS = 0x84000000;
public static final int TAPE_DRIVE_WRITE_LONG_FMKS =  0x88000000;

public static final int TAPE_DRIVE_WRITE_MARK_IMMED = 0x90000000;
public static final int TAPE_DRIVE_FORMAT =           0xA0000000;
public static final int TAPE_DRIVE_FORMAT_IMMEDIATE = 0xC0000000;
public static final int TAPE_DRIVE_HIGH_FEATURES =    0x80000000;
// Targeting ..\windows\TAPE_GET_DRIVE_PARAMETERS.java


// Targeting ..\windows\TAPE_SET_DRIVE_PARAMETERS.java


// Targeting ..\windows\TAPE_GET_MEDIA_PARAMETERS.java


// Targeting ..\windows\TAPE_SET_MEDIA_PARAMETERS.java



//
// IOCTL_TAPE_CREATE_PARTITION definitions
//

public static final long TAPE_FIXED_PARTITIONS =       0L;
public static final long TAPE_SELECT_PARTITIONS =      1L;
public static final long TAPE_INITIATOR_PARTITIONS =   2L;
// Targeting ..\windows\TAPE_CREATE_PARTITION.java




//
// WMI Methods
//
public static final long TAPE_QUERY_DRIVE_PARAMETERS =       0L;
public static final long TAPE_QUERY_MEDIA_CAPACITY =         1L;
public static final long TAPE_CHECK_FOR_DRIVE_PROBLEM =      2L;
public static final long TAPE_QUERY_IO_ERROR_DATA =          3L;
public static final long TAPE_QUERY_DEVICE_ERROR_DATA =      4L;
// Targeting ..\windows\TAPE_WMI_OPERATIONS.java



//
// Type of drive errors
//
/** enum TAPE_DRIVE_PROBLEM_TYPE */
public static final int
   TapeDriveProblemNone = 0, TapeDriveReadWriteWarning = 1,
   TapeDriveReadWriteError = 2, TapeDriveReadWarning = 3,
   TapeDriveWriteWarning = 4, TapeDriveReadError = 5,
   TapeDriveWriteError = 6, TapeDriveHardwareError = 7,
   TapeDriveUnsupportedMedia = 8, TapeDriveScsiConnectionError = 9,
   TapeDriveTimetoClean = 10, TapeDriveCleanDriveNow = 11,
   TapeDriveMediaLifeExpired = 12, TapeDriveSnappedTape = 13;

// #endif
// #ifndef _NTTMAPI_
// #define _NTTMAPI_


// #ifdef __cplusplus
// #endif


// #include <ktmtypes.h>

//
// Types for Nt level TM calls
//

//
// KTM Tm object rights
//
public static final int TRANSACTIONMANAGER_QUERY_INFORMATION =     ( 0x0001 );
public static final int TRANSACTIONMANAGER_SET_INFORMATION =       ( 0x0002 );
public static final int TRANSACTIONMANAGER_RECOVER =               ( 0x0004 );
public static final int TRANSACTIONMANAGER_RENAME =                ( 0x0008 );
public static final int TRANSACTIONMANAGER_CREATE_RM =             ( 0x0010 );

// The following right is intended for DTC's use only; it will be
// deprecated, and no one else should take a dependency on it.
public static final int TRANSACTIONMANAGER_BIND_TRANSACTION =      ( 0x0020 );

//
// Generic mappings for transaction manager rights.
//

public static final long TRANSACTIONMANAGER_GENERIC_READ =            (STANDARD_RIGHTS_READ            |
                                                    TRANSACTIONMANAGER_QUERY_INFORMATION);

public static final long TRANSACTIONMANAGER_GENERIC_WRITE =           (STANDARD_RIGHTS_WRITE           |
                                                    TRANSACTIONMANAGER_SET_INFORMATION     |
                                                    TRANSACTIONMANAGER_RECOVER             |
                                                    TRANSACTIONMANAGER_RENAME              |
                                                    TRANSACTIONMANAGER_CREATE_RM);

public static final long TRANSACTIONMANAGER_GENERIC_EXECUTE =         (STANDARD_RIGHTS_EXECUTE);

public static final long TRANSACTIONMANAGER_ALL_ACCESS =              (STANDARD_RIGHTS_REQUIRED        |
                                                    TRANSACTIONMANAGER_GENERIC_READ        |
                                                    TRANSACTIONMANAGER_GENERIC_WRITE       |
                                                    TRANSACTIONMANAGER_GENERIC_EXECUTE     |
                                                    TRANSACTIONMANAGER_BIND_TRANSACTION);


//
// KTM transaction object rights.
//
public static final int TRANSACTION_QUERY_INFORMATION =     ( 0x0001 );
public static final int TRANSACTION_SET_INFORMATION =       ( 0x0002 );
public static final int TRANSACTION_ENLIST =                ( 0x0004 );
public static final int TRANSACTION_COMMIT =                ( 0x0008 );
public static final int TRANSACTION_ROLLBACK =              ( 0x0010 );
public static final int TRANSACTION_PROPAGATE =             ( 0x0020 );
public static final int TRANSACTION_RIGHT_RESERVED1 =       ( 0x0040 );

//
// Generic mappings for transaction rights.
// Resource managers, when enlisting, should generally use the macro
// TRANSACTION_RESOURCE_MANAGER_RIGHTS when opening a transaction.
// It's the same as generic read and write except that it does not allow
// a commit decision to be made.
//

public static final long TRANSACTION_GENERIC_READ =            (STANDARD_RIGHTS_READ            |
                                             TRANSACTION_QUERY_INFORMATION   |
                                             SYNCHRONIZE);

public static final long TRANSACTION_GENERIC_WRITE =           (STANDARD_RIGHTS_WRITE           |
                                             TRANSACTION_SET_INFORMATION     |
                                             TRANSACTION_COMMIT              |
                                             TRANSACTION_ENLIST              |
                                             TRANSACTION_ROLLBACK            |
                                             TRANSACTION_PROPAGATE           |
                                             SYNCHRONIZE);

public static final long TRANSACTION_GENERIC_EXECUTE =         (STANDARD_RIGHTS_EXECUTE         |
                                             TRANSACTION_COMMIT              |
                                             TRANSACTION_ROLLBACK            |
                                             SYNCHRONIZE);

public static final long TRANSACTION_ALL_ACCESS =              (STANDARD_RIGHTS_REQUIRED        |
                                             TRANSACTION_GENERIC_READ        |
                                             TRANSACTION_GENERIC_WRITE       |
                                             TRANSACTION_GENERIC_EXECUTE);

public static final long TRANSACTION_RESOURCE_MANAGER_RIGHTS = (TRANSACTION_GENERIC_READ        |
                                             STANDARD_RIGHTS_WRITE           |
                                             TRANSACTION_SET_INFORMATION     |
                                             TRANSACTION_ENLIST              |
                                             TRANSACTION_ROLLBACK            |
                                             TRANSACTION_PROPAGATE           |
                                             SYNCHRONIZE);

//
// KTM resource manager object rights.
//
public static final int RESOURCEMANAGER_QUERY_INFORMATION =     ( 0x0001 );
public static final int RESOURCEMANAGER_SET_INFORMATION =       ( 0x0002 );
public static final int RESOURCEMANAGER_RECOVER =               ( 0x0004 );
public static final int RESOURCEMANAGER_ENLIST =                ( 0x0008 );
public static final int RESOURCEMANAGER_GET_NOTIFICATION =      ( 0x0010 );
public static final int RESOURCEMANAGER_REGISTER_PROTOCOL =     ( 0x0020 );
public static final int RESOURCEMANAGER_COMPLETE_PROPAGATION =  ( 0x0040 );

//
// Generic mappings for resource manager rights.
//
public static final long RESOURCEMANAGER_GENERIC_READ =        (STANDARD_RIGHTS_READ                 |
                                             RESOURCEMANAGER_QUERY_INFORMATION    |
                                             SYNCHRONIZE);

public static final long RESOURCEMANAGER_GENERIC_WRITE =       (STANDARD_RIGHTS_WRITE                |
                                             RESOURCEMANAGER_SET_INFORMATION      |
                                             RESOURCEMANAGER_RECOVER              |
                                             RESOURCEMANAGER_ENLIST               |
                                             RESOURCEMANAGER_GET_NOTIFICATION     |
                                             RESOURCEMANAGER_REGISTER_PROTOCOL    |
                                             RESOURCEMANAGER_COMPLETE_PROPAGATION |
                                             SYNCHRONIZE);

public static final long RESOURCEMANAGER_GENERIC_EXECUTE =     (STANDARD_RIGHTS_EXECUTE              |
                                             RESOURCEMANAGER_RECOVER              |
                                             RESOURCEMANAGER_ENLIST               |
                                             RESOURCEMANAGER_GET_NOTIFICATION     |
                                             RESOURCEMANAGER_COMPLETE_PROPAGATION |
                                             SYNCHRONIZE);

public static final long RESOURCEMANAGER_ALL_ACCESS =          (STANDARD_RIGHTS_REQUIRED             |
                                             RESOURCEMANAGER_GENERIC_READ         |
                                             RESOURCEMANAGER_GENERIC_WRITE        |
                                             RESOURCEMANAGER_GENERIC_EXECUTE);


//
// KTM enlistment object rights.
//
public static final int ENLISTMENT_QUERY_INFORMATION =     ( 0x0001 );
public static final int ENLISTMENT_SET_INFORMATION =       ( 0x0002 );
public static final int ENLISTMENT_RECOVER =               ( 0x0004 );
public static final int ENLISTMENT_SUBORDINATE_RIGHTS =    ( 0x0008 );
public static final int ENLISTMENT_SUPERIOR_RIGHTS =       ( 0x0010 );

//
// Generic mappings for enlistment rights.
//
public static final long ENLISTMENT_GENERIC_READ =        (STANDARD_RIGHTS_READ           |
                                        ENLISTMENT_QUERY_INFORMATION);

public static final long ENLISTMENT_GENERIC_WRITE =       (STANDARD_RIGHTS_WRITE          |
                                        ENLISTMENT_SET_INFORMATION     |
                                        ENLISTMENT_RECOVER             |
                                        ENLISTMENT_SUBORDINATE_RIGHTS  |
                                        ENLISTMENT_SUPERIOR_RIGHTS);

public static final long ENLISTMENT_GENERIC_EXECUTE =     (STANDARD_RIGHTS_EXECUTE        |
                                        ENLISTMENT_RECOVER             |
                                        ENLISTMENT_SUBORDINATE_RIGHTS  |
                                        ENLISTMENT_SUPERIOR_RIGHTS);

public static final long ENLISTMENT_ALL_ACCESS =          (STANDARD_RIGHTS_REQUIRED       |
                                        ENLISTMENT_GENERIC_READ        |
                                        ENLISTMENT_GENERIC_WRITE       |
                                        ENLISTMENT_GENERIC_EXECUTE);


//
// Transaction outcomes.
//
// TODO: warning, must match values in KTRANSACTION_OUTCOME duplicated def 
// in tm.h.
//

/** enum TRANSACTION_OUTCOME */
public static final int
    TransactionOutcomeUndetermined = 1,
    TransactionOutcomeCommitted = 2,
    TransactionOutcomeAborted = 3;


/** enum TRANSACTION_STATE */
public static final int
    TransactionStateNormal = 1,
    TransactionStateIndoubt = 2,
    TransactionStateCommittedNotify = 3;
// Targeting ..\windows\TRANSACTION_BASIC_INFORMATION.java


// Targeting ..\windows\TRANSACTIONMANAGER_BASIC_INFORMATION.java


// Targeting ..\windows\TRANSACTIONMANAGER_LOG_INFORMATION.java


// Targeting ..\windows\TRANSACTIONMANAGER_LOGPATH_INFORMATION.java


// Targeting ..\windows\TRANSACTIONMANAGER_RECOVERY_INFORMATION.java


// Targeting ..\windows\TRANSACTIONMANAGER_OLDEST_INFORMATION.java


// Targeting ..\windows\TRANSACTION_PROPERTIES_INFORMATION.java


// Targeting ..\windows\TRANSACTION_BIND_INFORMATION.java


// Targeting ..\windows\TRANSACTION_ENLISTMENT_PAIR.java


// Targeting ..\windows\TRANSACTION_ENLISTMENTS_INFORMATION.java


// Targeting ..\windows\TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION.java


// Targeting ..\windows\RESOURCEMANAGER_BASIC_INFORMATION.java


// Targeting ..\windows\RESOURCEMANAGER_COMPLETION_INFORMATION.java



// end_wdm

// begin_wdm
/** enum TRANSACTION_INFORMATION_CLASS */
public static final int
    TransactionBasicInformation = 0,
    TransactionPropertiesInformation = 1,
    TransactionEnlistmentInformation = 2,
    TransactionSuperiorEnlistmentInformation = 3,
// The following info-classes are intended for DTC's use only; it will be
// deprecated, and no one else should take a dependency on it.
    TransactionBindInformation = 4, // private and deprecated
    TransactionDTCPrivateInformation = 5;
// begin_wdm

// begin_wdm
/** enum TRANSACTIONMANAGER_INFORMATION_CLASS */
public static final int
    TransactionManagerBasicInformation = 0,
    TransactionManagerLogInformation = 1,
    TransactionManagerLogPathInformation = 2,
    TransactionManagerRecoveryInformation = 4,
// The following info-classes are intended for internal use only; they
// are considered deprecated, and no one else should take a dependency
// on them.
    TransactionManagerOnlineProbeInformation = 3,
    TransactionManagerOldestTransactionInformation = 5;
// end_wdm

// begin_wdm


// begin_wdm
/** enum RESOURCEMANAGER_INFORMATION_CLASS */
public static final int
    ResourceManagerBasicInformation = 0,
    ResourceManagerCompletionInformation = 1;
// Targeting ..\windows\ENLISTMENT_BASIC_INFORMATION.java


// Targeting ..\windows\ENLISTMENT_CRM_INFORMATION.java




// begin_wdm
/** enum ENLISTMENT_INFORMATION_CLASS */
public static final int
    EnlistmentBasicInformation = 0,
    EnlistmentRecoveryInformation = 1,
    EnlistmentCrmInformation = 2;
// Targeting ..\windows\TRANSACTION_LIST_ENTRY.java


// Targeting ..\windows\TRANSACTION_LIST_INFORMATION.java




//
// Types of objects known to the kernel transaction manager.
//

/** enum KTMOBJECT_TYPE */
public static final int

    KTMOBJECT_TRANSACTION = 0,
    KTMOBJECT_TRANSACTION_MANAGER = 1,
    KTMOBJECT_RESOURCE_MANAGER = 2,
    KTMOBJECT_ENLISTMENT = 3,
    KTMOBJECT_INVALID = 4;
// Targeting ..\windows\KTMOBJECT_CURSOR.java



// begin_wdm

// #ifdef __cplusplus
// #endif

// #endif // _NTTMAPI_
// Targeting ..\windows\TP_CALLBACK_INSTANCE.java


// Targeting ..\windows\PTP_SIMPLE_CALLBACK.java


// Targeting ..\windows\TP_POOL.java

 

/** enum TP_CALLBACK_PRIORITY */
public static final int
    TP_CALLBACK_PRIORITY_HIGH = 0,
    TP_CALLBACK_PRIORITY_NORMAL = 1,
    TP_CALLBACK_PRIORITY_LOW = 2,
    TP_CALLBACK_PRIORITY_INVALID = 3,
    TP_CALLBACK_PRIORITY_COUNT = TP_CALLBACK_PRIORITY_INVALID;
// Targeting ..\windows\TP_POOL_STACK_INFORMATION.java


// Targeting ..\windows\TP_CLEANUP_GROUP.java


// Targeting ..\windows\PTP_CLEANUP_GROUP_CANCEL_CALLBACK.java


// Targeting ..\windows\TP_CALLBACK_ENVIRON_V3.java



// #else

// #endif

// #if !defined(MIDL_PASS)

public static native void TpInitializeCallbackEnviron(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 CallbackEnviron
    );

public static native void TpSetCallbackThreadpool(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 CallbackEnviron,
    @Cast("PTP_POOL") TP_POOL Pool
    );

public static native void TpSetCallbackCleanupGroup(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 CallbackEnviron,
    @Cast("PTP_CLEANUP_GROUP") TP_CLEANUP_GROUP CleanupGroup,
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback
    );

public static native void TpSetCallbackActivationContext(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 CallbackEnviron,
    @Cast("_ACTIVATION_CONTEXT*") Pointer ActivationContext
    );

public static native void TpSetCallbackNoActivationContext(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 CallbackEnviron
    );

public static native void TpSetCallbackLongFunction(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 CallbackEnviron
    );

public static native void TpSetCallbackRaceWithDll(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 CallbackEnviron,
    @Cast("PVOID") Pointer DllHandle
    );

public static native void TpSetCallbackFinalizationCallback(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 CallbackEnviron,
    PTP_SIMPLE_CALLBACK FinalizationCallback
    );

// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

public static native void TpSetCallbackPriority(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 CallbackEnviron,
    @Cast("TP_CALLBACK_PRIORITY") int Priority
    );

// #endif

public static native void TpSetCallbackPersistent(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 CallbackEnviron
    );


public static native void TpDestroyCallbackEnviron(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 CallbackEnviron
    );
// Targeting ..\windows\TP_WORK.java


// Targeting ..\windows\PTP_WORK_CALLBACK.java


// Targeting ..\windows\TP_TIMER.java


// Targeting ..\windows\PTP_TIMER_CALLBACK.java


// Targeting ..\windows\TP_WAIT.java


// Targeting ..\windows\PTP_WAIT_CALLBACK.java


// Targeting ..\windows\TP_IO.java



// #if defined(_M_AMD64) && !defined(__midl)

public static native @Cast("_TEB*") Pointer NtCurrentTeb(
    );

public static native @Cast("PVOID") Pointer GetCurrentFiber(
    );

public static native @Cast("PVOID") Pointer GetFiberData(
    );

// #endif // _M_AMD64 && !defined(__midl)


// #if defined(_M_ARM) && !defined(__midl) && !defined(_M_CEE_PURE)

// #endif // _M_ARM && !defined(__midl) && !defined(_M_CEE_PURE)


// #if defined(_M_IX86) && !defined(MIDL_PASS)

public static final int PcTeb = 0x18;

// #if !defined(_M_CEE_PURE)

// #endif // !defined(_M_CEE_PURE)

// #endif // defined(_M_IX86) && !defined(MIDL_PASS)

// #if (_WIN32_WINNT > 0x0500) || (_WIN32_FUSION >= 0x0100) || ISOLATION_AWARE_ENABLED // winnt_only
public static final int ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION =         (1);
public static final int ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION =              (2);
public static final int ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION =     (3);
public static final int ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION =       (4);
public static final int ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION =    (5);
public static final int ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION = (6);
public static final int ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION =       (7);
public static final int ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE =   (8);
public static final int ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES =               (9);
public static final int ACTIVATION_CONTEXT_SECTION_APPLICATION_SETTINGS =         (10);
public static final int ACTIVATION_CONTEXT_SECTION_COMPATIBILITY_INFO =           (11);
// #endif // winnt_only

// #ifdef __cplusplus
// #endif

// #if _MSC_VER >= 1200
// #pragma warning(pop)
// #else
// #pragma warning(default:4201)
// #pragma warning(default:4214)
// #endif

// #endif /* _WINNT_ */



// Parsed from minwinbase.h

/************************************************************************
*                                                                       *
*   minwinbase.h -- This module defines the 32-Bit Windows Base APIs    *
*                                                                       *
*   Copyright (c) Microsoft Corp. All rights reserved.                  *
*                                                                       *
************************************************************************/
// #pragma once
// #ifndef _MINWINBASE_
// #define _MINWINBASE_

// #if     ( _MSC_VER >= 800 )
// #pragma warning(disable:4514)
// #ifndef __WINDOWS_DONT_DISABLE_PRAGMA_PACK_WARNING__
// #pragma warning(disable:4103)
// #endif
// #if _MSC_VER >= 1200
// #pragma warning(push)
// #endif
// #pragma warning(disable:4001)
// #pragma warning(disable:4201)
// #pragma warning(disable:4214)
// #endif




// #ifdef __cplusplus
// #endif

//
// Constants
//
// #define MoveMemory RtlMoveMemory
// #define CopyMemory RtlCopyMemory
// #define FillMemory RtlFillMemory
// #define ZeroMemory RtlZeroMemory
// Targeting ..\windows\SECURITY_ATTRIBUTES.java


// Targeting ..\windows\OVERLAPPED.java


// Targeting ..\windows\OVERLAPPED_ENTRY.java



//
//  File System time stamps are represented with the following structure:
//


// #ifndef _FILETIME_
// #define _FILETIME_
// Targeting ..\windows\SYSTEMTIME.java


// Targeting ..\windows\WIN32_FIND_DATAA.java


// Targeting ..\windows\WIN32_FIND_DATAW.java


// #ifdef UNICODE
// #else
// #endif // UNICODE


// #if(_WIN32_WINNT >= 0x0400)
/** enum FINDEX_INFO_LEVELS */
public static final int
    FindExInfoStandard = 0,
    FindExInfoBasic = 1,
    FindExInfoMaxInfoLevel = 2;

public static final int FIND_FIRST_EX_CASE_SENSITIVE =   0x00000001;
public static final int FIND_FIRST_EX_LARGE_FETCH =      0x00000002;

/** enum FINDEX_SEARCH_OPS */
public static final int
    FindExSearchNameMatch = 0,
    FindExSearchLimitToDirectories = 1,
    FindExSearchLimitToDevices = 2,
    FindExSearchMaxSearchOp = 3;
// #endif /* _WIN32_WINNT >= 0x0400 */

/** enum GET_FILEEX_INFO_LEVELS */
public static final int
    GetFileExInfoStandard = 0,
    GetFileExMaxInfoLevel = 1;

// #if (_WIN32_WINNT >= _WIN32_WINNT_LONGHORN)
/** enum FILE_INFO_BY_HANDLE_CLASS */
public static final int
    FileBasicInfo = 0,
    FileStandardInfo = 1,
    FileNameInfo = 2,
    FileRenameInfo = 3,
    FileDispositionInfo = 4,
    FileAllocationInfo = 5,
    FileEndOfFileInfo = 6,
    FileStreamInfo = 7,
    FileCompressionInfo = 8,
    FileAttributeTagInfo = 9,
    FileIdBothDirectoryInfo = 10,
    FileIdBothDirectoryRestartInfo = 11,
    FileIoPriorityHintInfo = 12,
    FileRemoteProtocolInfo = 13,
    FileFullDirectoryInfo = 14,
    FileFullDirectoryRestartInfo = 15,
// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)
// #endif
    MaximumFileInfoByHandleClass = 16;
// #endif
// Targeting ..\windows\LPOVERLAPPED_COMPLETION_ROUTINE.java



public static final int LOCKFILE_FAIL_IMMEDIATELY =   0x00000001;
public static final int LOCKFILE_EXCLUSIVE_LOCK =     0x00000002;
// Targeting ..\windows\PROCESS_HEAP_ENTRY.java



public static final int PROCESS_HEAP_REGION =             0x0001;
public static final int PROCESS_HEAP_UNCOMMITTED_RANGE =  0x0002;
public static final int PROCESS_HEAP_ENTRY_BUSY =         0x0004;
public static final int PROCESS_HEAP_SEG_ALLOC =          0x0008;
public static final int PROCESS_HEAP_ENTRY_MOVEABLE =     0x0010;
public static final int PROCESS_HEAP_ENTRY_DDESHARE =     0x0020;
// Targeting ..\windows\REASON_CONTEXT.java



//
// Debug APIs
//
public static final int EXCEPTION_DEBUG_EVENT =       1;
public static final int CREATE_THREAD_DEBUG_EVENT =   2;
public static final int CREATE_PROCESS_DEBUG_EVENT =  3;
public static final int EXIT_THREAD_DEBUG_EVENT =     4;
public static final int EXIT_PROCESS_DEBUG_EVENT =    5;
public static final int LOAD_DLL_DEBUG_EVENT =        6;
public static final int UNLOAD_DLL_DEBUG_EVENT =      7;
public static final int OUTPUT_DEBUG_STRING_EVENT =   8;
public static final int RIP_EVENT =                   9;
// Targeting ..\windows\PTHREAD_START_ROUTINE.java


// Targeting ..\windows\EXCEPTION_DEBUG_INFO.java


// Targeting ..\windows\CREATE_THREAD_DEBUG_INFO.java


// Targeting ..\windows\CREATE_PROCESS_DEBUG_INFO.java


// Targeting ..\windows\EXIT_THREAD_DEBUG_INFO.java


// Targeting ..\windows\EXIT_PROCESS_DEBUG_INFO.java


// Targeting ..\windows\LOAD_DLL_DEBUG_INFO.java


// Targeting ..\windows\UNLOAD_DLL_DEBUG_INFO.java


// Targeting ..\windows\OUTPUT_DEBUG_STRING_INFO.java


// Targeting ..\windows\RIP_INFO.java


// Targeting ..\windows\DEBUG_EVENT.java




//
// Context definitions
//

// #if !defined(MIDL_PASS)
// #endif // !defined(MIDL_PASS)

//
// macros
//

/* compatibility macros */
public static final long STILL_ACTIVE =                        STATUS_PENDING;
public static final long EXCEPTION_ACCESS_VIOLATION =          STATUS_ACCESS_VIOLATION;
public static final long EXCEPTION_DATATYPE_MISALIGNMENT =     STATUS_DATATYPE_MISALIGNMENT;
public static final long EXCEPTION_BREAKPOINT =                STATUS_BREAKPOINT;
public static final long EXCEPTION_SINGLE_STEP =               STATUS_SINGLE_STEP;
public static final long EXCEPTION_ARRAY_BOUNDS_EXCEEDED =     STATUS_ARRAY_BOUNDS_EXCEEDED;
public static final long EXCEPTION_FLT_DENORMAL_OPERAND =      STATUS_FLOAT_DENORMAL_OPERAND;
public static final long EXCEPTION_FLT_DIVIDE_BY_ZERO =        STATUS_FLOAT_DIVIDE_BY_ZERO;
public static final long EXCEPTION_FLT_INEXACT_RESULT =        STATUS_FLOAT_INEXACT_RESULT;
public static final long EXCEPTION_FLT_INVALID_OPERATION =     STATUS_FLOAT_INVALID_OPERATION;
public static final long EXCEPTION_FLT_OVERFLOW =              STATUS_FLOAT_OVERFLOW;
public static final long EXCEPTION_FLT_STACK_CHECK =           STATUS_FLOAT_STACK_CHECK;
public static final long EXCEPTION_FLT_UNDERFLOW =             STATUS_FLOAT_UNDERFLOW;
public static final long EXCEPTION_INT_DIVIDE_BY_ZERO =        STATUS_INTEGER_DIVIDE_BY_ZERO;
public static final long EXCEPTION_INT_OVERFLOW =              STATUS_INTEGER_OVERFLOW;
public static final long EXCEPTION_PRIV_INSTRUCTION =          STATUS_PRIVILEGED_INSTRUCTION;
public static final long EXCEPTION_IN_PAGE_ERROR =             STATUS_IN_PAGE_ERROR;
public static final long EXCEPTION_ILLEGAL_INSTRUCTION =       STATUS_ILLEGAL_INSTRUCTION;
public static final long EXCEPTION_NONCONTINUABLE_EXCEPTION =  STATUS_NONCONTINUABLE_EXCEPTION;
public static final long EXCEPTION_STACK_OVERFLOW =            STATUS_STACK_OVERFLOW;
public static final long EXCEPTION_INVALID_DISPOSITION =       STATUS_INVALID_DISPOSITION;
public static final long EXCEPTION_GUARD_PAGE =                STATUS_GUARD_PAGE_VIOLATION;
public static final long EXCEPTION_INVALID_HANDLE =            STATUS_INVALID_HANDLE;
// #define EXCEPTION_POSSIBLE_DEADLOCK         STATUS_POSSIBLE_DEADLOCK
public static final long CONTROL_C_EXIT =                      STATUS_CONTROL_C_EXIT;

/* Local Memory Flags */
public static final int LMEM_FIXED =          0x0000;
public static final int LMEM_MOVEABLE =       0x0002;
public static final int LMEM_NOCOMPACT =      0x0010;
public static final int LMEM_NODISCARD =      0x0020;
public static final int LMEM_ZEROINIT =       0x0040;
public static final int LMEM_MODIFY =         0x0080;
public static final int LMEM_DISCARDABLE =    0x0F00;
public static final int LMEM_VALID_FLAGS =    0x0F72;
public static final int LMEM_INVALID_HANDLE = 0x8000;

public static final int LHND =                (LMEM_MOVEABLE | LMEM_ZEROINIT);
public static final int LPTR =                (LMEM_FIXED | LMEM_ZEROINIT);

public static final int NONZEROLHND =         (LMEM_MOVEABLE);
public static final int NONZEROLPTR =         (LMEM_FIXED);

// #define LocalDiscard( h )   LocalReAlloc( (h), 0, LMEM_MOVEABLE )

/* Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE) */
public static final int LMEM_DISCARDED =      0x4000;
public static final int LMEM_LOCKCOUNT =      0x00FF;


// #ifdef __cplusplus
// #endif



// #if     ( _MSC_VER >= 800 )
// #if _MSC_VER >= 1200
// #pragma warning(pop)
// #else
// #pragma warning(default:4001)
// #pragma warning(default:4201)
// #pragma warning(default:4214)
/* Leave 4514 disabled.  It's an unneeded warning anyway. */
// #endif
// #endif

// #endif // _MINWINBASE_



// Parsed from processenv.h

 
// begin_1_0
// begin2_0
/********************************************************************************
*                                                                               *
* ProcessEnv.h -- ApiSet Contract for api-ms-win-core-processenvironment-l1     *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _PROCESSENV_
// #define _PROCESSENV_

// #include <apiset.h>
// #include <apisetcconv.h>


// #include <minwindef.h>

/* APISET_NAME: api-ms-win-core-processenvironment-l1 */

// #ifndef _APISET_PROCESSENV_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION > 0x0100
public static final int _APISET_PROCESSENV_VER = 0x0200;
// #elif _APISET_MINWIN_VERSION == 0x0100
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// end_1_0
// end2_0

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// begin_1_0

public static native @Cast("LPCH") BytePointer GetEnvironmentStrings(
    );


public static native @Cast("LPWCH") CharPointer GetEnvironmentStringsW(
    );


// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean SetEnvironmentStringsW(
    @Cast("LPWCH") CharPointer NewEnvironment
    );
public static native @Cast("BOOL") boolean SetEnvironmentStringsW(
    @Cast("LPWCH") CharBuffer NewEnvironment
    );
public static native @Cast("BOOL") boolean SetEnvironmentStringsW(
    @Cast("LPWCH") char[] NewEnvironment
    );

// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean FreeEnvironmentStringsA(
    @Cast("LPCH") BytePointer penv
    );
public static native @Cast("BOOL") boolean FreeEnvironmentStringsA(
    @Cast("LPCH") ByteBuffer penv
    );
public static native @Cast("BOOL") boolean FreeEnvironmentStringsA(
    @Cast("LPCH") byte[] penv
    );

public static native @Cast("BOOL") boolean FreeEnvironmentStringsW(
    @Cast("LPWCH") CharPointer penv
    );
public static native @Cast("BOOL") boolean FreeEnvironmentStringsW(
    @Cast("LPWCH") CharBuffer penv
    );
public static native @Cast("BOOL") boolean FreeEnvironmentStringsW(
    @Cast("LPWCH") char[] penv
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("HANDLE") Pointer GetStdHandle(
    @Cast("DWORD") int nStdHandle
    );


public static native @Cast("BOOL") boolean SetStdHandle(
    @Cast("DWORD") int nStdHandle,
    @Cast("HANDLE") Pointer hHandle
    );



// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean SetStdHandleEx(
    @Cast("DWORD") int nStdHandle,
    @Cast("HANDLE") Pointer hHandle,
    @Cast("PHANDLE") PointerPointer phPrevValue
    );


// #endif // _WIN32_WINNT >= 0x0600

// end_1_0

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

// begin_1_0

public static native @Cast("LPSTR") BytePointer GetCommandLineA(
    );

public static native @Cast("LPWSTR") CharPointer GetCommandLineW(
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// end_1_0

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// begin_1_0

public static native @Cast("DWORD") int GetEnvironmentVariableA(
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetEnvironmentVariableA(
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetEnvironmentVariableA(
    @Cast("LPCSTR") byte[] lpName,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetEnvironmentVariableA(
    @Cast("LPCSTR") String lpName,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetEnvironmentVariableA(
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetEnvironmentVariableA(
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetEnvironmentVariableA(
    @Cast("LPCSTR") byte[] lpName,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetEnvironmentVariableA(
    @Cast("LPCSTR") String lpName,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetEnvironmentVariableA(
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetEnvironmentVariableA(
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetEnvironmentVariableA(
    @Cast("LPCSTR") byte[] lpName,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetEnvironmentVariableA(
    @Cast("LPCSTR") String lpName,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("DWORD") int nSize
    );

public static native @Cast("DWORD") int GetEnvironmentVariableW(
    @Cast("LPCWSTR") CharPointer lpName,
    @Cast("LPWSTR") CharPointer lpBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetEnvironmentVariableW(
    @Cast("LPCWSTR") CharBuffer lpName,
    @Cast("LPWSTR") CharBuffer lpBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetEnvironmentVariableW(
    @Cast("LPCWSTR") char[] lpName,
    @Cast("LPWSTR") char[] lpBuffer,
    @Cast("DWORD") int nSize
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean SetEnvironmentVariableA(
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("LPCSTR") BytePointer lpValue
    );
public static native @Cast("BOOL") boolean SetEnvironmentVariableA(
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("LPCSTR") ByteBuffer lpValue
    );
public static native @Cast("BOOL") boolean SetEnvironmentVariableA(
    @Cast("LPCSTR") byte[] lpName,
    @Cast("LPCSTR") byte[] lpValue
    );
public static native @Cast("BOOL") boolean SetEnvironmentVariableA(
    @Cast("LPCSTR") String lpName,
    @Cast("LPCSTR") String lpValue
    );

public static native @Cast("BOOL") boolean SetEnvironmentVariableW(
    @Cast("LPCWSTR") CharPointer lpName,
    @Cast("LPCWSTR") CharPointer lpValue
    );
public static native @Cast("BOOL") boolean SetEnvironmentVariableW(
    @Cast("LPCWSTR") CharBuffer lpName,
    @Cast("LPCWSTR") CharBuffer lpValue
    );
public static native @Cast("BOOL") boolean SetEnvironmentVariableW(
    @Cast("LPCWSTR") char[] lpName,
    @Cast("LPCWSTR") char[] lpValue
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("DWORD") int ExpandEnvironmentStringsA(
    @Cast("LPCSTR") BytePointer lpSrc,
    @Cast("LPSTR") BytePointer lpDst,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int ExpandEnvironmentStringsA(
    @Cast("LPCSTR") ByteBuffer lpSrc,
    @Cast("LPSTR") ByteBuffer lpDst,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int ExpandEnvironmentStringsA(
    @Cast("LPCSTR") byte[] lpSrc,
    @Cast("LPSTR") byte[] lpDst,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int ExpandEnvironmentStringsA(
    @Cast("LPCSTR") String lpSrc,
    @Cast("LPSTR") BytePointer lpDst,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int ExpandEnvironmentStringsA(
    @Cast("LPCSTR") BytePointer lpSrc,
    @Cast("LPSTR") ByteBuffer lpDst,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int ExpandEnvironmentStringsA(
    @Cast("LPCSTR") ByteBuffer lpSrc,
    @Cast("LPSTR") byte[] lpDst,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int ExpandEnvironmentStringsA(
    @Cast("LPCSTR") byte[] lpSrc,
    @Cast("LPSTR") BytePointer lpDst,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int ExpandEnvironmentStringsA(
    @Cast("LPCSTR") String lpSrc,
    @Cast("LPSTR") ByteBuffer lpDst,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int ExpandEnvironmentStringsA(
    @Cast("LPCSTR") BytePointer lpSrc,
    @Cast("LPSTR") byte[] lpDst,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int ExpandEnvironmentStringsA(
    @Cast("LPCSTR") ByteBuffer lpSrc,
    @Cast("LPSTR") BytePointer lpDst,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int ExpandEnvironmentStringsA(
    @Cast("LPCSTR") byte[] lpSrc,
    @Cast("LPSTR") ByteBuffer lpDst,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int ExpandEnvironmentStringsA(
    @Cast("LPCSTR") String lpSrc,
    @Cast("LPSTR") byte[] lpDst,
    @Cast("DWORD") int nSize
    );

public static native @Cast("DWORD") int ExpandEnvironmentStringsW(
    @Cast("LPCWSTR") CharPointer lpSrc,
    @Cast("LPWSTR") CharPointer lpDst,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int ExpandEnvironmentStringsW(
    @Cast("LPCWSTR") CharBuffer lpSrc,
    @Cast("LPWSTR") CharBuffer lpDst,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int ExpandEnvironmentStringsW(
    @Cast("LPCWSTR") char[] lpSrc,
    @Cast("LPWSTR") char[] lpDst,
    @Cast("DWORD") int nSize
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean SetCurrentDirectoryA(
    @Cast("LPCSTR") BytePointer lpPathName
    );
public static native @Cast("BOOL") boolean SetCurrentDirectoryA(
    @Cast("LPCSTR") ByteBuffer lpPathName
    );
public static native @Cast("BOOL") boolean SetCurrentDirectoryA(
    @Cast("LPCSTR") byte[] lpPathName
    );
public static native @Cast("BOOL") boolean SetCurrentDirectoryA(
    @Cast("LPCSTR") String lpPathName
    );

public static native @Cast("BOOL") boolean SetCurrentDirectoryW(
    @Cast("LPCWSTR") CharPointer lpPathName
    );
public static native @Cast("BOOL") boolean SetCurrentDirectoryW(
    @Cast("LPCWSTR") CharBuffer lpPathName
    );
public static native @Cast("BOOL") boolean SetCurrentDirectoryW(
    @Cast("LPCWSTR") char[] lpPathName
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("DWORD") int GetCurrentDirectoryA(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") BytePointer lpBuffer
    );
public static native @Cast("DWORD") int GetCurrentDirectoryA(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") ByteBuffer lpBuffer
    );
public static native @Cast("DWORD") int GetCurrentDirectoryA(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") byte[] lpBuffer
    );

public static native @Cast("DWORD") int GetCurrentDirectoryW(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") CharPointer lpBuffer
    );
public static native @Cast("DWORD") int GetCurrentDirectoryW(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") CharBuffer lpBuffer
    );
public static native @Cast("DWORD") int GetCurrentDirectoryW(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") char[] lpBuffer
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("DWORD") int SearchPathW(
    @Cast("LPCWSTR") CharPointer lpPath,
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("LPCWSTR") CharPointer lpExtension,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") CharPointer lpBuffer,
    @Cast("LPWSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int SearchPathW(
    @Cast("LPCWSTR") CharBuffer lpPath,
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("LPCWSTR") CharBuffer lpExtension,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") CharBuffer lpBuffer,
    @Cast("LPWSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int SearchPathW(
    @Cast("LPCWSTR") char[] lpPath,
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("LPCWSTR") char[] lpExtension,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") char[] lpBuffer,
    @Cast("LPWSTR*") PointerPointer lpFilePart
    );


// #ifdef UNICODE
// #else
// #endif // !UNICODE

// end_1_0

// begin2_0


// #if (defined(_WIN32_WINNT) && !defined(_CONTRACT_GEN)) || (_APISET_PROCESSENV_VER > 0x0100)

public static native @Cast("DWORD") int SearchPathA(
    @Cast("LPCSTR") BytePointer lpPath,
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("LPCSTR") BytePointer lpExtension,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int SearchPathA(
    @Cast("LPCSTR") ByteBuffer lpPath,
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("LPCSTR") ByteBuffer lpExtension,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int SearchPathA(
    @Cast("LPCSTR") byte[] lpPath,
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("LPCSTR") byte[] lpExtension,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int SearchPathA(
    @Cast("LPCSTR") String lpPath,
    @Cast("LPCSTR") String lpFileName,
    @Cast("LPCSTR") String lpExtension,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int SearchPathA(
    @Cast("LPCSTR") BytePointer lpPath,
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("LPCSTR") BytePointer lpExtension,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int SearchPathA(
    @Cast("LPCSTR") ByteBuffer lpPath,
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("LPCSTR") ByteBuffer lpExtension,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int SearchPathA(
    @Cast("LPCSTR") byte[] lpPath,
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("LPCSTR") byte[] lpExtension,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int SearchPathA(
    @Cast("LPCSTR") String lpPath,
    @Cast("LPCSTR") String lpFileName,
    @Cast("LPCSTR") String lpExtension,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int SearchPathA(
    @Cast("LPCSTR") BytePointer lpPath,
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("LPCSTR") BytePointer lpExtension,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int SearchPathA(
    @Cast("LPCSTR") ByteBuffer lpPath,
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("LPCSTR") ByteBuffer lpExtension,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int SearchPathA(
    @Cast("LPCSTR") byte[] lpPath,
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("LPCSTR") byte[] lpExtension,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int SearchPathA(
    @Cast("LPCSTR") String lpPath,
    @Cast("LPCSTR") String lpFileName,
    @Cast("LPCSTR") String lpExtension,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );



// #if _WIN32_WINNT >= 0x0502

public static native @Cast("BOOL") boolean NeedCurrentDirectoryForExePathA(
    @Cast("LPCSTR") BytePointer ExeName
    );
public static native @Cast("BOOL") boolean NeedCurrentDirectoryForExePathA(
    @Cast("LPCSTR") ByteBuffer ExeName
    );
public static native @Cast("BOOL") boolean NeedCurrentDirectoryForExePathA(
    @Cast("LPCSTR") byte[] ExeName
    );
public static native @Cast("BOOL") boolean NeedCurrentDirectoryForExePathA(
    @Cast("LPCSTR") String ExeName
    );

public static native @Cast("BOOL") boolean NeedCurrentDirectoryForExePathW(
    @Cast("LPCWSTR") CharPointer ExeName
    );
public static native @Cast("BOOL") boolean NeedCurrentDirectoryForExePathW(
    @Cast("LPCWSTR") CharBuffer ExeName
    );
public static native @Cast("BOOL") boolean NeedCurrentDirectoryForExePathW(
    @Cast("LPCWSTR") char[] ExeName
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif

// #endif // (defined(_WIN32_WINNT) && !defined(_CONTRACT_GEN)) || (_APISET_PROCESSENV_VER > 0x0100)

// end2_0

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// begin_1_0
// begin2_0

// #ifdef __cplusplus
// #endif

// #endif // _PROCESSENV_
// end_1_0
// end2_0


// Parsed from fileapi.h

 
 
// begin_1_0
// begin_2_0
// begin_2_1
/********************************************************************************
*                                                                               *
* FileApi.h -- ApiSet Contract for api-ms-win-core-file-l1                      *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _APISETFILE_
// #define _APISETFILE_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-core-file-l1 */

// #ifndef _APISET_FILE_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0102
public static final int _APISET_FILE_VER = 0x0201;
// #elif _APISET_MINWIN_VERSION == 0x0101
// #elif _APISET_MINWIN_VERSION <= 0x0100
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

//
// Constants
//
public static final int CREATE_NEW =          1;
public static final int CREATE_ALWAYS =       2;
public static final int OPEN_EXISTING =       3;
public static final int OPEN_ALWAYS =         4;
public static final int TRUNCATE_EXISTING =   5;

public static final int INVALID_FILE_SIZE = ((int)0xFFFFFFFF);
public static final int INVALID_SET_FILE_POINTER = ((int)-1);
public static final int INVALID_FILE_ATTRIBUTES = ((int)-1);

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// end_1_0
// end_2_0
// end_2_1

// begin_1_0

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("LONG") int CompareFileTime(
    @Const FILETIME lpFileTime1,
    @Const FILETIME lpFileTime2
    );


// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean CreateDirectoryA(
    @Cast("LPCSTR") BytePointer lpPathName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateDirectoryA(
    @Cast("LPCSTR") ByteBuffer lpPathName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateDirectoryA(
    @Cast("LPCSTR") byte[] lpPathName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateDirectoryA(
    @Cast("LPCSTR") String lpPathName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );

public static native @Cast("BOOL") boolean CreateDirectoryW(
    @Cast("LPCWSTR") CharPointer lpPathName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateDirectoryW(
    @Cast("LPCWSTR") CharBuffer lpPathName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateDirectoryW(
    @Cast("LPCWSTR") char[] lpPathName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("HANDLE") Pointer CreateFileA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwShareMode,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("DWORD") int dwCreationDisposition,
    @Cast("DWORD") int dwFlagsAndAttributes,
    @Cast("HANDLE") Pointer hTemplateFile
    );
public static native @Cast("HANDLE") Pointer CreateFileA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwShareMode,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("DWORD") int dwCreationDisposition,
    @Cast("DWORD") int dwFlagsAndAttributes,
    @Cast("HANDLE") Pointer hTemplateFile
    );
public static native @Cast("HANDLE") Pointer CreateFileA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwShareMode,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("DWORD") int dwCreationDisposition,
    @Cast("DWORD") int dwFlagsAndAttributes,
    @Cast("HANDLE") Pointer hTemplateFile
    );
public static native @Cast("HANDLE") Pointer CreateFileA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwShareMode,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("DWORD") int dwCreationDisposition,
    @Cast("DWORD") int dwFlagsAndAttributes,
    @Cast("HANDLE") Pointer hTemplateFile
    );

public static native @Cast("HANDLE") Pointer CreateFileW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwShareMode,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("DWORD") int dwCreationDisposition,
    @Cast("DWORD") int dwFlagsAndAttributes,
    @Cast("HANDLE") Pointer hTemplateFile
    );
public static native @Cast("HANDLE") Pointer CreateFileW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwShareMode,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("DWORD") int dwCreationDisposition,
    @Cast("DWORD") int dwFlagsAndAttributes,
    @Cast("HANDLE") Pointer hTemplateFile
    );
public static native @Cast("HANDLE") Pointer CreateFileW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwShareMode,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("DWORD") int dwCreationDisposition,
    @Cast("DWORD") int dwFlagsAndAttributes,
    @Cast("HANDLE") Pointer hTemplateFile
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean DefineDosDeviceW(
    @Cast("DWORD") int dwFlags,
    @Cast("LPCWSTR") CharPointer lpDeviceName,
    @Cast("LPCWSTR") CharPointer lpTargetPath
    );
public static native @Cast("BOOL") boolean DefineDosDeviceW(
    @Cast("DWORD") int dwFlags,
    @Cast("LPCWSTR") CharBuffer lpDeviceName,
    @Cast("LPCWSTR") CharBuffer lpTargetPath
    );
public static native @Cast("BOOL") boolean DefineDosDeviceW(
    @Cast("DWORD") int dwFlags,
    @Cast("LPCWSTR") char[] lpDeviceName,
    @Cast("LPCWSTR") char[] lpTargetPath
    );


// #ifdef UNICODE
// #endif

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean DeleteFileA(
    @Cast("LPCSTR") BytePointer lpFileName
    );
public static native @Cast("BOOL") boolean DeleteFileA(
    @Cast("LPCSTR") ByteBuffer lpFileName
    );
public static native @Cast("BOOL") boolean DeleteFileA(
    @Cast("LPCSTR") byte[] lpFileName
    );
public static native @Cast("BOOL") boolean DeleteFileA(
    @Cast("LPCSTR") String lpFileName
    );

public static native @Cast("BOOL") boolean DeleteFileW(
    @Cast("LPCWSTR") CharPointer lpFileName
    );
public static native @Cast("BOOL") boolean DeleteFileW(
    @Cast("LPCWSTR") CharBuffer lpFileName
    );
public static native @Cast("BOOL") boolean DeleteFileW(
    @Cast("LPCWSTR") char[] lpFileName
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean DeleteVolumeMountPointW(
    @Cast("LPCWSTR") CharPointer lpszVolumeMountPoint
    );
public static native @Cast("BOOL") boolean DeleteVolumeMountPointW(
    @Cast("LPCWSTR") CharBuffer lpszVolumeMountPoint
    );
public static native @Cast("BOOL") boolean DeleteVolumeMountPointW(
    @Cast("LPCWSTR") char[] lpszVolumeMountPoint
    );


// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean FileTimeToLocalFileTime(
    @Const FILETIME lpFileTime,
    @Cast("LPFILETIME") FILETIME lpLocalFileTime
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

// end_1_0
// begin_1_0

public static native @Cast("BOOL") boolean FindClose(
    @Cast("HANDLE") Pointer hFindFile
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean FindCloseChangeNotification(
    @Cast("HANDLE") Pointer hChangeHandle
    );


public static native @Cast("HANDLE") Pointer FindFirstChangeNotificationA(
    @Cast("LPCSTR") BytePointer lpPathName,
    @Cast("BOOL") boolean bWatchSubtree,
    @Cast("DWORD") int dwNotifyFilter
    );
public static native @Cast("HANDLE") Pointer FindFirstChangeNotificationA(
    @Cast("LPCSTR") ByteBuffer lpPathName,
    @Cast("BOOL") boolean bWatchSubtree,
    @Cast("DWORD") int dwNotifyFilter
    );
public static native @Cast("HANDLE") Pointer FindFirstChangeNotificationA(
    @Cast("LPCSTR") byte[] lpPathName,
    @Cast("BOOL") boolean bWatchSubtree,
    @Cast("DWORD") int dwNotifyFilter
    );
public static native @Cast("HANDLE") Pointer FindFirstChangeNotificationA(
    @Cast("LPCSTR") String lpPathName,
    @Cast("BOOL") boolean bWatchSubtree,
    @Cast("DWORD") int dwNotifyFilter
    );

public static native @Cast("HANDLE") Pointer FindFirstChangeNotificationW(
    @Cast("LPCWSTR") CharPointer lpPathName,
    @Cast("BOOL") boolean bWatchSubtree,
    @Cast("DWORD") int dwNotifyFilter
    );
public static native @Cast("HANDLE") Pointer FindFirstChangeNotificationW(
    @Cast("LPCWSTR") CharBuffer lpPathName,
    @Cast("BOOL") boolean bWatchSubtree,
    @Cast("DWORD") int dwNotifyFilter
    );
public static native @Cast("HANDLE") Pointer FindFirstChangeNotificationW(
    @Cast("LPCWSTR") char[] lpPathName,
    @Cast("BOOL") boolean bWatchSubtree,
    @Cast("DWORD") int dwNotifyFilter
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("HANDLE") Pointer FindFirstFileA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("LPWIN32_FIND_DATAA") WIN32_FIND_DATAA lpFindFileData
    );
public static native @Cast("HANDLE") Pointer FindFirstFileA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("LPWIN32_FIND_DATAA") WIN32_FIND_DATAA lpFindFileData
    );
public static native @Cast("HANDLE") Pointer FindFirstFileA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("LPWIN32_FIND_DATAA") WIN32_FIND_DATAA lpFindFileData
    );
public static native @Cast("HANDLE") Pointer FindFirstFileA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("LPWIN32_FIND_DATAA") WIN32_FIND_DATAA lpFindFileData
    );

public static native @Cast("HANDLE") Pointer FindFirstFileW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("LPWIN32_FIND_DATAW") WIN32_FIND_DATAW lpFindFileData
    );
public static native @Cast("HANDLE") Pointer FindFirstFileW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("LPWIN32_FIND_DATAW") WIN32_FIND_DATAW lpFindFileData
    );
public static native @Cast("HANDLE") Pointer FindFirstFileW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("LPWIN32_FIND_DATAW") WIN32_FIND_DATAW lpFindFileData
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)


// #if (_WIN32_WINNT >= 0x0400)

public static native @Cast("HANDLE") Pointer FindFirstFileExA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("FINDEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFindFileData,
    @Cast("FINDEX_SEARCH_OPS") int fSearchOp,
    @Cast("LPVOID") Pointer lpSearchFilter,
    @Cast("DWORD") int dwAdditionalFlags
    );
public static native @Cast("HANDLE") Pointer FindFirstFileExA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("FINDEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFindFileData,
    @Cast("FINDEX_SEARCH_OPS") int fSearchOp,
    @Cast("LPVOID") Pointer lpSearchFilter,
    @Cast("DWORD") int dwAdditionalFlags
    );
public static native @Cast("HANDLE") Pointer FindFirstFileExA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("FINDEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFindFileData,
    @Cast("FINDEX_SEARCH_OPS") int fSearchOp,
    @Cast("LPVOID") Pointer lpSearchFilter,
    @Cast("DWORD") int dwAdditionalFlags
    );
public static native @Cast("HANDLE") Pointer FindFirstFileExA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("FINDEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFindFileData,
    @Cast("FINDEX_SEARCH_OPS") int fSearchOp,
    @Cast("LPVOID") Pointer lpSearchFilter,
    @Cast("DWORD") int dwAdditionalFlags
    );

public static native @Cast("HANDLE") Pointer FindFirstFileExW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("FINDEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFindFileData,
    @Cast("FINDEX_SEARCH_OPS") int fSearchOp,
    @Cast("LPVOID") Pointer lpSearchFilter,
    @Cast("DWORD") int dwAdditionalFlags
    );
public static native @Cast("HANDLE") Pointer FindFirstFileExW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("FINDEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFindFileData,
    @Cast("FINDEX_SEARCH_OPS") int fSearchOp,
    @Cast("LPVOID") Pointer lpSearchFilter,
    @Cast("DWORD") int dwAdditionalFlags
    );
public static native @Cast("HANDLE") Pointer FindFirstFileExW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("FINDEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFindFileData,
    @Cast("FINDEX_SEARCH_OPS") int fSearchOp,
    @Cast("LPVOID") Pointer lpSearchFilter,
    @Cast("DWORD") int dwAdditionalFlags
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif /* _WIN32_WINNT >= 0x0400 */

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("HANDLE") Pointer FindFirstVolumeW(
    @Cast("LPWSTR") CharPointer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeW(
    @Cast("LPWSTR") CharBuffer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeW(
    @Cast("LPWSTR") char[] lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );


// #ifdef UNICODE
// #endif // !UNICODE

public static native @Cast("BOOL") boolean FindNextChangeNotification(
    @Cast("HANDLE") Pointer hChangeHandle
    );


// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean FindNextFileA(
    @Cast("HANDLE") Pointer hFindFile,
    @Cast("LPWIN32_FIND_DATAA") WIN32_FIND_DATAA lpFindFileData
    );

public static native @Cast("BOOL") boolean FindNextFileW(
    @Cast("HANDLE") Pointer hFindFile,
    @Cast("LPWIN32_FIND_DATAW") WIN32_FIND_DATAW lpFindFileData
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean FindNextVolumeW(
    @Cast("HANDLE") Pointer hFindVolume,
    @Cast("LPWSTR") CharPointer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean FindNextVolumeW(
    @Cast("HANDLE") Pointer hFindVolume,
    @Cast("LPWSTR") CharBuffer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean FindNextVolumeW(
    @Cast("HANDLE") Pointer hFindVolume,
    @Cast("LPWSTR") char[] lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );


// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean FindVolumeClose(
    @Cast("HANDLE") Pointer hFindVolume
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean FlushFileBuffers(
    @Cast("HANDLE") Pointer hFile
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean GetDiskFreeSpaceA(
    @Cast("LPCSTR") BytePointer lpRootPathName,
    @Cast("LPDWORD") IntPointer lpSectorsPerCluster,
    @Cast("LPDWORD") IntPointer lpBytesPerSector,
    @Cast("LPDWORD") IntPointer lpNumberOfFreeClusters,
    @Cast("LPDWORD") IntPointer lpTotalNumberOfClusters
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceA(
    @Cast("LPCSTR") ByteBuffer lpRootPathName,
    @Cast("LPDWORD") IntBuffer lpSectorsPerCluster,
    @Cast("LPDWORD") IntBuffer lpBytesPerSector,
    @Cast("LPDWORD") IntBuffer lpNumberOfFreeClusters,
    @Cast("LPDWORD") IntBuffer lpTotalNumberOfClusters
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceA(
    @Cast("LPCSTR") byte[] lpRootPathName,
    @Cast("LPDWORD") int[] lpSectorsPerCluster,
    @Cast("LPDWORD") int[] lpBytesPerSector,
    @Cast("LPDWORD") int[] lpNumberOfFreeClusters,
    @Cast("LPDWORD") int[] lpTotalNumberOfClusters
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceA(
    @Cast("LPCSTR") String lpRootPathName,
    @Cast("LPDWORD") IntPointer lpSectorsPerCluster,
    @Cast("LPDWORD") IntPointer lpBytesPerSector,
    @Cast("LPDWORD") IntPointer lpNumberOfFreeClusters,
    @Cast("LPDWORD") IntPointer lpTotalNumberOfClusters
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceA(
    @Cast("LPCSTR") BytePointer lpRootPathName,
    @Cast("LPDWORD") IntBuffer lpSectorsPerCluster,
    @Cast("LPDWORD") IntBuffer lpBytesPerSector,
    @Cast("LPDWORD") IntBuffer lpNumberOfFreeClusters,
    @Cast("LPDWORD") IntBuffer lpTotalNumberOfClusters
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceA(
    @Cast("LPCSTR") ByteBuffer lpRootPathName,
    @Cast("LPDWORD") int[] lpSectorsPerCluster,
    @Cast("LPDWORD") int[] lpBytesPerSector,
    @Cast("LPDWORD") int[] lpNumberOfFreeClusters,
    @Cast("LPDWORD") int[] lpTotalNumberOfClusters
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceA(
    @Cast("LPCSTR") byte[] lpRootPathName,
    @Cast("LPDWORD") IntPointer lpSectorsPerCluster,
    @Cast("LPDWORD") IntPointer lpBytesPerSector,
    @Cast("LPDWORD") IntPointer lpNumberOfFreeClusters,
    @Cast("LPDWORD") IntPointer lpTotalNumberOfClusters
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceA(
    @Cast("LPCSTR") String lpRootPathName,
    @Cast("LPDWORD") IntBuffer lpSectorsPerCluster,
    @Cast("LPDWORD") IntBuffer lpBytesPerSector,
    @Cast("LPDWORD") IntBuffer lpNumberOfFreeClusters,
    @Cast("LPDWORD") IntBuffer lpTotalNumberOfClusters
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceA(
    @Cast("LPCSTR") BytePointer lpRootPathName,
    @Cast("LPDWORD") int[] lpSectorsPerCluster,
    @Cast("LPDWORD") int[] lpBytesPerSector,
    @Cast("LPDWORD") int[] lpNumberOfFreeClusters,
    @Cast("LPDWORD") int[] lpTotalNumberOfClusters
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceA(
    @Cast("LPCSTR") ByteBuffer lpRootPathName,
    @Cast("LPDWORD") IntPointer lpSectorsPerCluster,
    @Cast("LPDWORD") IntPointer lpBytesPerSector,
    @Cast("LPDWORD") IntPointer lpNumberOfFreeClusters,
    @Cast("LPDWORD") IntPointer lpTotalNumberOfClusters
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceA(
    @Cast("LPCSTR") byte[] lpRootPathName,
    @Cast("LPDWORD") IntBuffer lpSectorsPerCluster,
    @Cast("LPDWORD") IntBuffer lpBytesPerSector,
    @Cast("LPDWORD") IntBuffer lpNumberOfFreeClusters,
    @Cast("LPDWORD") IntBuffer lpTotalNumberOfClusters
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceA(
    @Cast("LPCSTR") String lpRootPathName,
    @Cast("LPDWORD") int[] lpSectorsPerCluster,
    @Cast("LPDWORD") int[] lpBytesPerSector,
    @Cast("LPDWORD") int[] lpNumberOfFreeClusters,
    @Cast("LPDWORD") int[] lpTotalNumberOfClusters
    );

public static native @Cast("BOOL") boolean GetDiskFreeSpaceW(
    @Cast("LPCWSTR") CharPointer lpRootPathName,
    @Cast("LPDWORD") IntPointer lpSectorsPerCluster,
    @Cast("LPDWORD") IntPointer lpBytesPerSector,
    @Cast("LPDWORD") IntPointer lpNumberOfFreeClusters,
    @Cast("LPDWORD") IntPointer lpTotalNumberOfClusters
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceW(
    @Cast("LPCWSTR") CharBuffer lpRootPathName,
    @Cast("LPDWORD") IntBuffer lpSectorsPerCluster,
    @Cast("LPDWORD") IntBuffer lpBytesPerSector,
    @Cast("LPDWORD") IntBuffer lpNumberOfFreeClusters,
    @Cast("LPDWORD") IntBuffer lpTotalNumberOfClusters
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceW(
    @Cast("LPCWSTR") char[] lpRootPathName,
    @Cast("LPDWORD") int[] lpSectorsPerCluster,
    @Cast("LPDWORD") int[] lpBytesPerSector,
    @Cast("LPDWORD") int[] lpNumberOfFreeClusters,
    @Cast("LPDWORD") int[] lpTotalNumberOfClusters
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean GetDiskFreeSpaceExA(
    @Cast("LPCSTR") BytePointer lpDirectoryName,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpFreeBytesAvailableToCaller,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpTotalNumberOfBytes,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpTotalNumberOfFreeBytes
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceExA(
    @Cast("LPCSTR") ByteBuffer lpDirectoryName,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpFreeBytesAvailableToCaller,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpTotalNumberOfBytes,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpTotalNumberOfFreeBytes
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceExA(
    @Cast("LPCSTR") byte[] lpDirectoryName,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpFreeBytesAvailableToCaller,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpTotalNumberOfBytes,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpTotalNumberOfFreeBytes
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceExA(
    @Cast("LPCSTR") String lpDirectoryName,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpFreeBytesAvailableToCaller,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpTotalNumberOfBytes,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpTotalNumberOfFreeBytes
    );

public static native @Cast("BOOL") boolean GetDiskFreeSpaceExW(
    @Cast("LPCWSTR") CharPointer lpDirectoryName,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpFreeBytesAvailableToCaller,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpTotalNumberOfBytes,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpTotalNumberOfFreeBytes
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceExW(
    @Cast("LPCWSTR") CharBuffer lpDirectoryName,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpFreeBytesAvailableToCaller,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpTotalNumberOfBytes,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpTotalNumberOfFreeBytes
    );
public static native @Cast("BOOL") boolean GetDiskFreeSpaceExW(
    @Cast("LPCWSTR") char[] lpDirectoryName,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpFreeBytesAvailableToCaller,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpTotalNumberOfBytes,
    @Cast("PULARGE_INTEGER") ULARGE_INTEGER lpTotalNumberOfFreeBytes
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("UINT") int GetDriveTypeA(
    @Cast("LPCSTR") BytePointer lpRootPathName
    );
public static native @Cast("UINT") int GetDriveTypeA(
    @Cast("LPCSTR") ByteBuffer lpRootPathName
    );
public static native @Cast("UINT") int GetDriveTypeA(
    @Cast("LPCSTR") byte[] lpRootPathName
    );
public static native @Cast("UINT") int GetDriveTypeA(
    @Cast("LPCSTR") String lpRootPathName
    );

public static native @Cast("UINT") int GetDriveTypeW(
    @Cast("LPCWSTR") CharPointer lpRootPathName
    );
public static native @Cast("UINT") int GetDriveTypeW(
    @Cast("LPCWSTR") CharBuffer lpRootPathName
    );
public static native @Cast("UINT") int GetDriveTypeW(
    @Cast("LPCWSTR") char[] lpRootPathName
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("DWORD") int GetFileAttributesA(
    @Cast("LPCSTR") BytePointer lpFileName
    );
public static native @Cast("DWORD") int GetFileAttributesA(
    @Cast("LPCSTR") ByteBuffer lpFileName
    );
public static native @Cast("DWORD") int GetFileAttributesA(
    @Cast("LPCSTR") byte[] lpFileName
    );
public static native @Cast("DWORD") int GetFileAttributesA(
    @Cast("LPCSTR") String lpFileName
    );

public static native @Cast("DWORD") int GetFileAttributesW(
    @Cast("LPCWSTR") CharPointer lpFileName
    );
public static native @Cast("DWORD") int GetFileAttributesW(
    @Cast("LPCWSTR") CharBuffer lpFileName
    );
public static native @Cast("DWORD") int GetFileAttributesW(
    @Cast("LPCWSTR") char[] lpFileName
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #pragma region Application Family
// Targeting ..\windows\WIN32_FILE_ATTRIBUTE_DATA.java



// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean GetFileAttributesExA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("GET_FILEEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFileInformation
    );
public static native @Cast("BOOL") boolean GetFileAttributesExA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("GET_FILEEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFileInformation
    );
public static native @Cast("BOOL") boolean GetFileAttributesExA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("GET_FILEEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFileInformation
    );
public static native @Cast("BOOL") boolean GetFileAttributesExA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("GET_FILEEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFileInformation
    );

public static native @Cast("BOOL") boolean GetFileAttributesExW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("GET_FILEEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFileInformation
    );
public static native @Cast("BOOL") boolean GetFileAttributesExW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("GET_FILEEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFileInformation
    );
public static native @Cast("BOOL") boolean GetFileAttributesExW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("GET_FILEEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFileInformation
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family
// Targeting ..\windows\BY_HANDLE_FILE_INFORMATION.java



public static native @Cast("BOOL") boolean GetFileInformationByHandle(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPBY_HANDLE_FILE_INFORMATION") BY_HANDLE_FILE_INFORMATION lpFileInformation
    );


public static native @Cast("DWORD") int GetFileSize(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") IntPointer lpFileSizeHigh
    );
public static native @Cast("DWORD") int GetFileSize(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") IntBuffer lpFileSizeHigh
    );
public static native @Cast("DWORD") int GetFileSize(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") int[] lpFileSizeHigh
    );


public static native @Cast("BOOL") boolean GetFileSizeEx(
    @Cast("HANDLE") Pointer hFile,
    @Cast("PLARGE_INTEGER") LARGE_INTEGER lpFileSize
    );


public static native @Cast("BOOL") boolean GetFileTime(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPFILETIME") FILETIME lpCreationTime,
    @Cast("LPFILETIME") FILETIME lpLastAccessTime,
    @Cast("LPFILETIME") FILETIME lpLastWriteTime
    );


public static native @Cast("DWORD") int GetFileType(
    @Cast("HANDLE") Pointer hFile
    );



// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("DWORD") int GetFinalPathNameByHandleA(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPSTR") BytePointer lpszFilePath,
    @Cast("DWORD") int cchFilePath,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("DWORD") int GetFinalPathNameByHandleA(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPSTR") ByteBuffer lpszFilePath,
    @Cast("DWORD") int cchFilePath,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("DWORD") int GetFinalPathNameByHandleA(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPSTR") byte[] lpszFilePath,
    @Cast("DWORD") int cchFilePath,
    @Cast("DWORD") int dwFlags
    );

public static native @Cast("DWORD") int GetFinalPathNameByHandleW(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPWSTR") CharPointer lpszFilePath,
    @Cast("DWORD") int cchFilePath,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("DWORD") int GetFinalPathNameByHandleW(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPWSTR") CharBuffer lpszFilePath,
    @Cast("DWORD") int cchFilePath,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("DWORD") int GetFinalPathNameByHandleW(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPWSTR") char[] lpszFilePath,
    @Cast("DWORD") int cchFilePath,
    @Cast("DWORD") int dwFlags
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // (_WIN32_WINNT >= 0x0600)

public static native @Cast("DWORD") int GetFullPathNameA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int GetFullPathNameA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int GetFullPathNameA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int GetFullPathNameA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int GetFullPathNameA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int GetFullPathNameA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int GetFullPathNameA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int GetFullPathNameA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int GetFullPathNameA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int GetFullPathNameA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int GetFullPathNameA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int GetFullPathNameA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart
    );

public static native @Cast("DWORD") int GetFullPathNameW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") CharPointer lpBuffer,
    @Cast("LPWSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int GetFullPathNameW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") CharBuffer lpBuffer,
    @Cast("LPWSTR*") PointerPointer lpFilePart
    );
public static native @Cast("DWORD") int GetFullPathNameW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") char[] lpBuffer,
    @Cast("LPWSTR*") PointerPointer lpFilePart
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("DWORD") int GetLogicalDrives(
    );


public static native @Cast("DWORD") int GetLogicalDriveStringsW(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") CharPointer lpBuffer
    );
public static native @Cast("DWORD") int GetLogicalDriveStringsW(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") CharBuffer lpBuffer
    );
public static native @Cast("DWORD") int GetLogicalDriveStringsW(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") char[] lpBuffer
    );


// #ifdef UNICODE
// #endif

public static native @Cast("DWORD") int GetLongPathNameA(
    @Cast("LPCSTR") BytePointer lpszShortPath,
    @Cast("LPSTR") BytePointer lpszLongPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetLongPathNameA(
    @Cast("LPCSTR") ByteBuffer lpszShortPath,
    @Cast("LPSTR") ByteBuffer lpszLongPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetLongPathNameA(
    @Cast("LPCSTR") byte[] lpszShortPath,
    @Cast("LPSTR") byte[] lpszLongPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetLongPathNameA(
    @Cast("LPCSTR") String lpszShortPath,
    @Cast("LPSTR") BytePointer lpszLongPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetLongPathNameA(
    @Cast("LPCSTR") BytePointer lpszShortPath,
    @Cast("LPSTR") ByteBuffer lpszLongPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetLongPathNameA(
    @Cast("LPCSTR") ByteBuffer lpszShortPath,
    @Cast("LPSTR") byte[] lpszLongPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetLongPathNameA(
    @Cast("LPCSTR") byte[] lpszShortPath,
    @Cast("LPSTR") BytePointer lpszLongPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetLongPathNameA(
    @Cast("LPCSTR") String lpszShortPath,
    @Cast("LPSTR") ByteBuffer lpszLongPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetLongPathNameA(
    @Cast("LPCSTR") BytePointer lpszShortPath,
    @Cast("LPSTR") byte[] lpszLongPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetLongPathNameA(
    @Cast("LPCSTR") ByteBuffer lpszShortPath,
    @Cast("LPSTR") BytePointer lpszLongPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetLongPathNameA(
    @Cast("LPCSTR") byte[] lpszShortPath,
    @Cast("LPSTR") ByteBuffer lpszLongPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetLongPathNameA(
    @Cast("LPCSTR") String lpszShortPath,
    @Cast("LPSTR") byte[] lpszLongPath,
    @Cast("DWORD") int cchBuffer
    );

public static native @Cast("DWORD") int GetLongPathNameW(
    @Cast("LPCWSTR") CharPointer lpszShortPath,
    @Cast("LPWSTR") CharPointer lpszLongPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetLongPathNameW(
    @Cast("LPCWSTR") CharBuffer lpszShortPath,
    @Cast("LPWSTR") CharBuffer lpszLongPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetLongPathNameW(
    @Cast("LPCWSTR") char[] lpszShortPath,
    @Cast("LPWSTR") char[] lpszLongPath,
    @Cast("DWORD") int cchBuffer
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("DWORD") int GetShortPathNameW(
    @Cast("LPCWSTR") CharPointer lpszLongPath,
    @Cast("LPWSTR") CharPointer lpszShortPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetShortPathNameW(
    @Cast("LPCWSTR") CharBuffer lpszLongPath,
    @Cast("LPWSTR") CharBuffer lpszShortPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetShortPathNameW(
    @Cast("LPCWSTR") char[] lpszLongPath,
    @Cast("LPWSTR") char[] lpszShortPath,
    @Cast("DWORD") int cchBuffer
    );


// #ifdef UNICODE
// #endif

public static native @Cast("UINT") int GetTempFileNameW(
    @Cast("LPCWSTR") CharPointer lpPathName,
    @Cast("LPCWSTR") CharPointer lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPWSTR") CharPointer lpTempFileName
    );
public static native @Cast("UINT") int GetTempFileNameW(
    @Cast("LPCWSTR") CharBuffer lpPathName,
    @Cast("LPCWSTR") CharBuffer lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPWSTR") CharBuffer lpTempFileName
    );
public static native @Cast("UINT") int GetTempFileNameW(
    @Cast("LPCWSTR") char[] lpPathName,
    @Cast("LPCWSTR") char[] lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPWSTR") char[] lpTempFileName
    );


// #ifdef UNICODE
// #endif


// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean GetVolumeInformationByHandleW(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPWSTR") CharPointer lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") IntPointer lpVolumeSerialNumber,
    @Cast("LPDWORD") IntPointer lpMaximumComponentLength,
    @Cast("LPDWORD") IntPointer lpFileSystemFlags,
    @Cast("LPWSTR") CharPointer lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );
public static native @Cast("BOOL") boolean GetVolumeInformationByHandleW(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPWSTR") CharBuffer lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") IntBuffer lpVolumeSerialNumber,
    @Cast("LPDWORD") IntBuffer lpMaximumComponentLength,
    @Cast("LPDWORD") IntBuffer lpFileSystemFlags,
    @Cast("LPWSTR") CharBuffer lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );
public static native @Cast("BOOL") boolean GetVolumeInformationByHandleW(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPWSTR") char[] lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") int[] lpVolumeSerialNumber,
    @Cast("LPDWORD") int[] lpMaximumComponentLength,
    @Cast("LPDWORD") int[] lpFileSystemFlags,
    @Cast("LPWSTR") char[] lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );


// #endif /* _WIN32_WINNT >=  0x0600 */

public static native @Cast("BOOL") boolean GetVolumeInformationW(
    @Cast("LPCWSTR") CharPointer lpRootPathName,
    @Cast("LPWSTR") CharPointer lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") IntPointer lpVolumeSerialNumber,
    @Cast("LPDWORD") IntPointer lpMaximumComponentLength,
    @Cast("LPDWORD") IntPointer lpFileSystemFlags,
    @Cast("LPWSTR") CharPointer lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );
public static native @Cast("BOOL") boolean GetVolumeInformationW(
    @Cast("LPCWSTR") CharBuffer lpRootPathName,
    @Cast("LPWSTR") CharBuffer lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") IntBuffer lpVolumeSerialNumber,
    @Cast("LPDWORD") IntBuffer lpMaximumComponentLength,
    @Cast("LPDWORD") IntBuffer lpFileSystemFlags,
    @Cast("LPWSTR") CharBuffer lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );
public static native @Cast("BOOL") boolean GetVolumeInformationW(
    @Cast("LPCWSTR") char[] lpRootPathName,
    @Cast("LPWSTR") char[] lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") int[] lpVolumeSerialNumber,
    @Cast("LPDWORD") int[] lpMaximumComponentLength,
    @Cast("LPDWORD") int[] lpFileSystemFlags,
    @Cast("LPWSTR") char[] lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );


// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean GetVolumePathNameW(
    @Cast("LPCWSTR") CharPointer lpszFileName,
    @Cast("LPWSTR") CharPointer lpszVolumePathName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNameW(
    @Cast("LPCWSTR") CharBuffer lpszFileName,
    @Cast("LPWSTR") CharBuffer lpszVolumePathName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNameW(
    @Cast("LPCWSTR") char[] lpszFileName,
    @Cast("LPWSTR") char[] lpszVolumePathName,
    @Cast("DWORD") int cchBufferLength
    );


// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean LocalFileTimeToFileTime(
    @Const FILETIME lpLocalFileTime,
    @Cast("LPFILETIME") FILETIME lpFileTime
    );


public static native @Cast("BOOL") boolean LockFile(
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwFileOffsetLow,
    @Cast("DWORD") int dwFileOffsetHigh,
    @Cast("DWORD") int nNumberOfBytesToLockLow,
    @Cast("DWORD") int nNumberOfBytesToLockHigh
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean LockFileEx(
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwReserved,
    @Cast("DWORD") int nNumberOfBytesToLockLow,
    @Cast("DWORD") int nNumberOfBytesToLockHigh,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("DWORD") int QueryDosDeviceW(
    @Cast("LPCWSTR") CharPointer lpDeviceName,
    @Cast("LPWSTR") CharPointer lpTargetPath,
    @Cast("DWORD") int ucchMax
    );
public static native @Cast("DWORD") int QueryDosDeviceW(
    @Cast("LPCWSTR") CharBuffer lpDeviceName,
    @Cast("LPWSTR") CharBuffer lpTargetPath,
    @Cast("DWORD") int ucchMax
    );
public static native @Cast("DWORD") int QueryDosDeviceW(
    @Cast("LPCWSTR") char[] lpDeviceName,
    @Cast("LPWSTR") char[] lpTargetPath,
    @Cast("DWORD") int ucchMax
    );


// #ifdef UNICODE
// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean ReadFile(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToRead,
    @Cast("LPDWORD") IntPointer lpNumberOfBytesRead,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );
public static native @Cast("BOOL") boolean ReadFile(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToRead,
    @Cast("LPDWORD") IntBuffer lpNumberOfBytesRead,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );
public static native @Cast("BOOL") boolean ReadFile(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToRead,
    @Cast("LPDWORD") int[] lpNumberOfBytesRead,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean ReadFileEx(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToRead,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );


public static native @Cast("BOOL") boolean ReadFileScatter(
    @Cast("HANDLE") Pointer hFile,
    FILE_SEGMENT_ELEMENT aSegmentArray,
    @Cast("DWORD") int nNumberOfBytesToRead,
    @Cast("LPDWORD") IntPointer lpReserved,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );
public static native @Cast("BOOL") boolean ReadFileScatter(
    @Cast("HANDLE") Pointer hFile,
    FILE_SEGMENT_ELEMENT aSegmentArray,
    @Cast("DWORD") int nNumberOfBytesToRead,
    @Cast("LPDWORD") IntBuffer lpReserved,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );
public static native @Cast("BOOL") boolean ReadFileScatter(
    @Cast("HANDLE") Pointer hFile,
    FILE_SEGMENT_ELEMENT aSegmentArray,
    @Cast("DWORD") int nNumberOfBytesToRead,
    @Cast("LPDWORD") int[] lpReserved,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );


// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean RemoveDirectoryA(
    @Cast("LPCSTR") BytePointer lpPathName
    );
public static native @Cast("BOOL") boolean RemoveDirectoryA(
    @Cast("LPCSTR") ByteBuffer lpPathName
    );
public static native @Cast("BOOL") boolean RemoveDirectoryA(
    @Cast("LPCSTR") byte[] lpPathName
    );
public static native @Cast("BOOL") boolean RemoveDirectoryA(
    @Cast("LPCSTR") String lpPathName
    );

public static native @Cast("BOOL") boolean RemoveDirectoryW(
    @Cast("LPCWSTR") CharPointer lpPathName
    );
public static native @Cast("BOOL") boolean RemoveDirectoryW(
    @Cast("LPCWSTR") CharBuffer lpPathName
    );
public static native @Cast("BOOL") boolean RemoveDirectoryW(
    @Cast("LPCWSTR") char[] lpPathName
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean SetEndOfFile(
    @Cast("HANDLE") Pointer hFile
    );


public static native @Cast("BOOL") boolean SetFileAttributesA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("DWORD") int dwFileAttributes
    );
public static native @Cast("BOOL") boolean SetFileAttributesA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("DWORD") int dwFileAttributes
    );
public static native @Cast("BOOL") boolean SetFileAttributesA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("DWORD") int dwFileAttributes
    );
public static native @Cast("BOOL") boolean SetFileAttributesA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("DWORD") int dwFileAttributes
    );

public static native @Cast("BOOL") boolean SetFileAttributesW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("DWORD") int dwFileAttributes
    );
public static native @Cast("BOOL") boolean SetFileAttributesW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("DWORD") int dwFileAttributes
    );
public static native @Cast("BOOL") boolean SetFileAttributesW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("DWORD") int dwFileAttributes
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE


// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean SetFileInformationByHandle(
    @Cast("HANDLE") Pointer hFile,
    @Cast("FILE_INFO_BY_HANDLE_CLASS") int FileInformationClass,
    @Cast("LPVOID") Pointer lpFileInformation,
    @Cast("DWORD") int dwBufferSize
    );


// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("DWORD") int SetFilePointer(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LONG") int lDistanceToMove,
    @Cast("PLONG") IntPointer lpDistanceToMoveHigh,
    @Cast("DWORD") int dwMoveMethod
    );
public static native @Cast("DWORD") int SetFilePointer(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LONG") int lDistanceToMove,
    @Cast("PLONG") IntBuffer lpDistanceToMoveHigh,
    @Cast("DWORD") int dwMoveMethod
    );
public static native @Cast("DWORD") int SetFilePointer(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LONG") int lDistanceToMove,
    @Cast("PLONG") int[] lpDistanceToMoveHigh,
    @Cast("DWORD") int dwMoveMethod
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean SetFilePointerEx(
    @Cast("HANDLE") Pointer hFile,
    @ByVal LARGE_INTEGER liDistanceToMove,
    @Cast("PLARGE_INTEGER") LARGE_INTEGER lpNewFilePointer,
    @Cast("DWORD") int dwMoveMethod
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean SetFileTime(
    @Cast("HANDLE") Pointer hFile,
    @Const FILETIME lpCreationTime,
    @Const FILETIME lpLastAccessTime,
    @Const FILETIME lpLastWriteTime
    );



// #if _WIN32_WINNT >= 0x0501

public static native @Cast("BOOL") boolean SetFileValidData(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LONGLONG") long ValidDataLength
    );


// #endif // (_WIN32_WINNT >= 0x0501)

public static native @Cast("BOOL") boolean UnlockFile(
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwFileOffsetLow,
    @Cast("DWORD") int dwFileOffsetHigh,
    @Cast("DWORD") int nNumberOfBytesToUnlockLow,
    @Cast("DWORD") int nNumberOfBytesToUnlockHigh
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean UnlockFileEx(
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwReserved,
    @Cast("DWORD") int nNumberOfBytesToUnlockLow,
    @Cast("DWORD") int nNumberOfBytesToUnlockHigh,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );


public static native @Cast("BOOL") boolean WriteFile(
    @Cast("HANDLE") Pointer hFile,
    LPCVOID lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToWrite,
    @Cast("LPDWORD") IntPointer lpNumberOfBytesWritten,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );
public static native @Cast("BOOL") boolean WriteFile(
    @Cast("HANDLE") Pointer hFile,
    LPCVOID lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToWrite,
    @Cast("LPDWORD") IntBuffer lpNumberOfBytesWritten,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );
public static native @Cast("BOOL") boolean WriteFile(
    @Cast("HANDLE") Pointer hFile,
    LPCVOID lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToWrite,
    @Cast("LPDWORD") int[] lpNumberOfBytesWritten,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean WriteFileEx(
    @Cast("HANDLE") Pointer hFile,
    LPCVOID lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToWrite,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );


public static native @Cast("BOOL") boolean WriteFileGather(
    @Cast("HANDLE") Pointer hFile,
    FILE_SEGMENT_ELEMENT aSegmentArray,
    @Cast("DWORD") int nNumberOfBytesToWrite,
    @Cast("LPDWORD") IntPointer lpReserved,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );
public static native @Cast("BOOL") boolean WriteFileGather(
    @Cast("HANDLE") Pointer hFile,
    FILE_SEGMENT_ELEMENT aSegmentArray,
    @Cast("DWORD") int nNumberOfBytesToWrite,
    @Cast("LPDWORD") IntBuffer lpReserved,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );
public static native @Cast("BOOL") boolean WriteFileGather(
    @Cast("HANDLE") Pointer hFile,
    FILE_SEGMENT_ELEMENT aSegmentArray,
    @Cast("DWORD") int nNumberOfBytesToWrite,
    @Cast("LPDWORD") int[] lpReserved,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// end_1_0

// begin_2_0


// #if !defined(_CONTRACT_GEN) || (_APISET_FILE_VER >= 0x0200)

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("DWORD") int GetTempPathW(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") CharPointer lpBuffer
    );
public static native @Cast("DWORD") int GetTempPathW(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") CharBuffer lpBuffer
    );
public static native @Cast("DWORD") int GetTempPathW(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") char[] lpBuffer
    );


// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean GetVolumeNameForVolumeMountPointW(
    @Cast("LPCWSTR") CharPointer lpszVolumeMountPoint,
    @Cast("LPWSTR") CharPointer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumeNameForVolumeMountPointW(
    @Cast("LPCWSTR") CharBuffer lpszVolumeMountPoint,
    @Cast("LPWSTR") CharBuffer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumeNameForVolumeMountPointW(
    @Cast("LPCWSTR") char[] lpszVolumeMountPoint,
    @Cast("LPWSTR") char[] lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );


// #ifdef UNICODE
// #endif


// #if (_WIN32_WINNT >= 0x0501)

public static native @Cast("BOOL") boolean GetVolumePathNamesForVolumeNameW(
    @Cast("LPCWSTR") CharPointer lpszVolumeName,
    @Cast("LPWCH") CharPointer lpszVolumePathNames,
    @Cast("DWORD") int cchBufferLength,
    @Cast("PDWORD") IntPointer lpcchReturnLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNamesForVolumeNameW(
    @Cast("LPCWSTR") CharBuffer lpszVolumeName,
    @Cast("LPWCH") CharBuffer lpszVolumePathNames,
    @Cast("DWORD") int cchBufferLength,
    @Cast("PDWORD") IntBuffer lpcchReturnLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNamesForVolumeNameW(
    @Cast("LPCWSTR") char[] lpszVolumeName,
    @Cast("LPWCH") char[] lpszVolumePathNames,
    @Cast("DWORD") int cchBufferLength,
    @Cast("PDWORD") int[] lpcchReturnLength
    );


// #ifdef UNICODE
// #endif

// #endif // _WIN32_WINNT >= 0x0501

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)


// #if (_WIN32_WINNT >= 0x0602)


// #endif // _WIN32_WINNT >= 0x0602

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #endif // !defined(_CONTRACT_GEN) || (_APISET_FILE_VER >= 0x0200)

// end_2_0
// begin_2_1


// #if !defined(_CONTRACT_GEN) || (_APISET_FILE_VER >= 0x0201)

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean SetFileIoOverlappedRange(
    @Cast("HANDLE") Pointer FileHandle,
    @Cast("PUCHAR") BytePointer OverlappedRangeStart,
    @Cast("ULONG") long Length
    );
public static native @Cast("BOOL") boolean SetFileIoOverlappedRange(
    @Cast("HANDLE") Pointer FileHandle,
    @Cast("PUCHAR") ByteBuffer OverlappedRangeStart,
    @Cast("ULONG") long Length
    );
public static native @Cast("BOOL") boolean SetFileIoOverlappedRange(
    @Cast("HANDLE") Pointer FileHandle,
    @Cast("PUCHAR") byte[] OverlappedRangeStart,
    @Cast("ULONG") long Length
    );


// #endif // _WIN32_WINNT >= 0x0600

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if _WIN32_WINNT >= 0x0501

public static native @Cast("DWORD") int GetCompressedFileSizeA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("LPDWORD") IntPointer lpFileSizeHigh
    );
public static native @Cast("DWORD") int GetCompressedFileSizeA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("LPDWORD") IntBuffer lpFileSizeHigh
    );
public static native @Cast("DWORD") int GetCompressedFileSizeA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("LPDWORD") int[] lpFileSizeHigh
    );
public static native @Cast("DWORD") int GetCompressedFileSizeA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("LPDWORD") IntPointer lpFileSizeHigh
    );
public static native @Cast("DWORD") int GetCompressedFileSizeA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("LPDWORD") IntBuffer lpFileSizeHigh
    );
public static native @Cast("DWORD") int GetCompressedFileSizeA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("LPDWORD") int[] lpFileSizeHigh
    );
public static native @Cast("DWORD") int GetCompressedFileSizeA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("LPDWORD") IntPointer lpFileSizeHigh
    );
public static native @Cast("DWORD") int GetCompressedFileSizeA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("LPDWORD") IntBuffer lpFileSizeHigh
    );
public static native @Cast("DWORD") int GetCompressedFileSizeA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("LPDWORD") int[] lpFileSizeHigh
    );
public static native @Cast("DWORD") int GetCompressedFileSizeA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("LPDWORD") IntPointer lpFileSizeHigh
    );
public static native @Cast("DWORD") int GetCompressedFileSizeA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("LPDWORD") IntBuffer lpFileSizeHigh
    );
public static native @Cast("DWORD") int GetCompressedFileSizeA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("LPDWORD") int[] lpFileSizeHigh
    );

public static native @Cast("DWORD") int GetCompressedFileSizeW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("LPDWORD") IntPointer lpFileSizeHigh
    );
public static native @Cast("DWORD") int GetCompressedFileSizeW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("LPDWORD") IntBuffer lpFileSizeHigh
    );
public static native @Cast("DWORD") int GetCompressedFileSizeW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("LPDWORD") int[] lpFileSizeHigh
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // _WIN32_WINNT >= 0x0501

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif // !defined(_CONTRACT_GEN) || (_APISET_FILE_VER >= 0x0201)

// end_2_1
// begin_1_0
// begin_2_0
// begin_2_1

// #ifdef __cplusplus
// #endif

// #endif // _APISETFILE_


// Parsed from debugapi.h

 
// begin_1_0
// begin_1_1
/********************************************************************************
*                                                                               *
* DebugApi.h -- ApiSet Contract for api-ms-win-core-debug-l1                    *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _APISETDEBUG_
// #define _APISETDEBUG_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-core-debug-l1 */

// #ifndef _APISET_DEBUG_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0101
public static final int _APISET_DEBUG_VER = 0x0101;
// #elif _APISET_MINWIN_VERSION == 0x0100
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// end_1_0
// end_1_1

// begin_1_0

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)


// #if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)
public static native @Cast("BOOL") boolean IsDebuggerPresent(
    );

// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native void DebugBreak(
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native void OutputDebugStringA(
    @Cast("LPCSTR") BytePointer lpOutputString
    );
public static native void OutputDebugStringA(
    @Cast("LPCSTR") ByteBuffer lpOutputString
    );
public static native void OutputDebugStringA(
    @Cast("LPCSTR") byte[] lpOutputString
    );
public static native void OutputDebugStringA(
    @Cast("LPCSTR") String lpOutputString
    );

public static native void OutputDebugStringW(
    @Cast("LPCWSTR") CharPointer lpOutputString
    );
public static native void OutputDebugStringW(
    @Cast("LPCWSTR") CharBuffer lpOutputString
    );
public static native void OutputDebugStringW(
    @Cast("LPCWSTR") char[] lpOutputString
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion
// end_1_0

// begin_1_1
// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if (defined(_WIN32_WINNT) && !defined(_CONTRACT_GEN)) || (_APISET_MINWIN_VERSION > 0x0100)

public static native @Cast("BOOL") boolean ContinueDebugEvent(
    @Cast("DWORD") int dwProcessId,
    @Cast("DWORD") int dwThreadId,
    @Cast("DWORD") int dwContinueStatus
    );


public static native @Cast("BOOL") boolean WaitForDebugEvent(
    @Cast("LPDEBUG_EVENT") DEBUG_EVENT lpDebugEvent,
    @Cast("DWORD") int dwMilliseconds
    );


public static native @Cast("BOOL") boolean DebugActiveProcess(
    @Cast("DWORD") int dwProcessId
    );


public static native @Cast("BOOL") boolean DebugActiveProcessStop(
    @Cast("DWORD") int dwProcessId
    );



// #if (_WIN32_WINNT >= 0x0501)
  
public static native @Cast("BOOL") boolean CheckRemoteDebuggerPresent(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PBOOL") boolean pbDebuggerPresent
    );
  
  
// #endif // (_WIN32_WINNT >= 0x0501)  

// #endif // (defined(_WIN32_WINNT) && !defined(_CONTRACT_GEN)) || (_APISET_MINWIN_VERSION > 0x0100)

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion
// end_1_1

// begin_1_0
// begin_1_1

// #ifdef __cplusplus
// #endif


// #endif // _APISETDEBUG_
// end_1_0
// end_1_1


// Parsed from utilapiset.h

 
/********************************************************************************
*                                                                               *
* UtilApiSet.h -- ApiSet Contract for api-ms-win-core-util-l1-1-0               *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _APISETUTIL_
// #define _APISETUTIL_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>

/* APISET_NAME: api-ms-win-core-util-l1 */

// #ifndef _APISET_UTIL_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0100
public static final int _APISET_UTIL_VER = 0x0100;
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("PVOID") Pointer EncodePointer(
    @Cast("PVOID") Pointer Ptr
    );


public static native @Cast("PVOID") Pointer DecodePointer(
    @Cast("PVOID") Pointer Ptr
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("PVOID") Pointer EncodeSystemPointer(
    @Cast("PVOID") Pointer Ptr
    );


public static native @Cast("PVOID") Pointer DecodeSystemPointer(
    @Cast("PVOID") Pointer Ptr
    );


public static native @Cast("BOOL") boolean Beep(
    @Cast("DWORD") int dwFreq,
    @Cast("DWORD") int dwDuration
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #ifdef __cplusplus
// #endif

// #endif // _APISETUTIL_


// Parsed from handleapi.h

 
/********************************************************************************
*                                                                               *
* handleapi.h -- ApiSet Contract for api-ms-win-core-handle-l1-1-0              *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _APISETHANDLE_
// #define _APISETHANDLE_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>

/* APISET_NAME: api-ms-win-core-handle-l1 */

// #ifndef _APISET_HANDLE_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0100
public static final int _APISET_HANDLE_VER = 0x0100;
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

//
// Constants
//
public static native @MemberGetter @Cast("HANDLE") Pointer INVALID_HANDLE_VALUE();
public static final Pointer INVALID_HANDLE_VALUE = INVALID_HANDLE_VALUE();

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

//
// Prototypes
//
public static native @Cast("BOOL") boolean CloseHandle(
    @Cast("HANDLE") Pointer hObject
    );


public static native @Cast("BOOL") boolean DuplicateHandle(
    @Cast("HANDLE") Pointer hSourceProcessHandle,
    @Cast("HANDLE") Pointer hSourceHandle,
    @Cast("HANDLE") Pointer hTargetProcessHandle,
    @Cast("LPHANDLE") Pointer lpTargetHandle,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("DWORD") int dwOptions
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean GetHandleInformation(
    @Cast("HANDLE") Pointer hObject,
    @Cast("LPDWORD") IntPointer lpdwFlags
    );
public static native @Cast("BOOL") boolean GetHandleInformation(
    @Cast("HANDLE") Pointer hObject,
    @Cast("LPDWORD") IntBuffer lpdwFlags
    );
public static native @Cast("BOOL") boolean GetHandleInformation(
    @Cast("HANDLE") Pointer hObject,
    @Cast("LPDWORD") int[] lpdwFlags
    );


public static native @Cast("BOOL") boolean SetHandleInformation(
    @Cast("HANDLE") Pointer hObject,
    @Cast("DWORD") int dwMask,
    @Cast("DWORD") int dwFlags
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #ifdef __cplusplus
// #endif

// #endif // _APISETHANDLE_


// Parsed from errhandlingapi.h

 
// begin_1_0
// begin_1_1
/********************************************************************************
*                                                                               *
* errhandlingapi.h - ApiSet Contract for api-ms-win-core-errorhandling-l1       *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _ERRHANDLING_H_
// #define _ERRHANDLING_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>

/* APISET_NAME: api-ms-win-core-errorhandling-l1 */

// #ifndef _APISET_ERRORHANDLING_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0101
public static final int _APISET_ERRORHANDLING_VER = 0x0101;
// #elif _APISET_MINWIN_VERSION == 0x0100
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// end_1_0
// end_1_1

// begin_1_0

// #pragma region Desktop Family
// Targeting ..\windows\PTOP_LEVEL_EXCEPTION_FILTER.java



//
// Prototypes
//

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native void RaiseException(
    @Cast("DWORD") int dwExceptionCode,
    @Cast("DWORD") int dwExceptionFlags,
    @Cast("DWORD") int nNumberOfArguments,
    @Cast("const ULONG_PTR*") SizeTPointer lpArguments
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("LONG") int UnhandledExceptionFilter(
    EXCEPTION_POINTERS ExceptionInfo
    );


public static native PTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(
    PTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

// #ifndef _M_CEE_PURE

public static native @Cast("DWORD") int GetLastError(
    );


// #endif

public static native void SetLastError(
    @Cast("DWORD") int dwErrCode
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("UINT") int GetErrorMode(
    );


// #endif // (_WIN32_WINNT >= 0x0600)

public static native @Cast("UINT") int SetErrorMode(
    @Cast("UINT") int uMode
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// end_1_0

// begin_1_1

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if ((_WIN32_WINNT >= 0x0501) && !defined(_CONTRACT_GEN)) || (_APISET_ERRORHANDLING_VER > 0x0100)

public static native @Cast("PVOID") Pointer AddVectoredExceptionHandler(
    @Cast("ULONG") long First,
    PVECTORED_EXCEPTION_HANDLER Handler
    );


public static native @Cast("ULONG") long RemoveVectoredExceptionHandler(
    @Cast("PVOID") Pointer Handle
    );


public static native @Cast("PVOID") Pointer AddVectoredContinueHandler(
    @Cast("ULONG") long First,
    PVECTORED_EXCEPTION_HANDLER Handler
    );


public static native @Cast("ULONG") long RemoveVectoredContinueHandler(
    @Cast("PVOID") Pointer Handle
    );


// #endif // ((_WIN32_WINNT >= 0x0501) && !defined(_CONTRACT_GEN)) || (_APISET_ERRORHANDLING_VER > 0x0100)


// #if !defined(_CONTRACT_GEN) || (_APISET_ERRORHANDLING_VER > 0x0100)

// RC warns because "WINBASE_DECLARE_RESTORE_LAST_ERROR" is a bit long.
// #if !defined(RC_INVOKED)
//#if _WIN32_WINNT >= 0x0501 || defined(WINBASE_DECLARE_RESTORE_LAST_ERROR)

// #if defined(WINBASE_DECLARE_RESTORE_LAST_ERROR)

// #endif 
// #endif

// #endif // !defined(_CONTRACT_GEN) || (_APISET_ERRORHANDLING_VER > 0x0100)

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// end_1_1

// begin_1_0
// begin_1_1

// #ifdef __cplusplus
// #endif

// #endif // _ERRHANDLING_H_
// end_1_0
// end_1_1


// Parsed from fibersapi.h

 
// begin_1_0
// begin_1_1
/********************************************************************************
*                                                                               *
* fibersapi.h - ApiSet Contract for api-ms-win-core-fibers-l1                   *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _FIBERS_H_
// #define _FIBERS_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>

/* APISET_NAME: api-ms-win-core-fibers-l1 */

// #ifndef _APISET_FIBERS_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0101
public static final int _APISET_FIBERS_VER = 0x0101;
// #elif _APISET_MINWIN_VERSION == 0x0100
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// end_1_0
// end_1_1

// begin_1_0

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)


// #if (_WIN32_WINNT >= 0x0600)

// #ifndef FLS_OUT_OF_INDEXES
public static final int FLS_OUT_OF_INDEXES = ((int)0xFFFFFFFF);
// #endif

public static native @Cast("DWORD") int FlsAlloc(
    PFLS_CALLBACK_FUNCTION lpCallback
    );


public static native @Cast("PVOID") Pointer FlsGetValue(
    @Cast("DWORD") int dwFlsIndex
    );


public static native @Cast("BOOL") boolean FlsSetValue(
    @Cast("DWORD") int dwFlsIndex,
    @Cast("PVOID") Pointer lpFlsData
    );


public static native @Cast("BOOL") boolean FlsFree(
    @Cast("DWORD") int dwFlsIndex
    );


// #endif // (_WIN32_WINNT >= 0x0600)

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// end_1_0

// begin_1_1

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)


// #if ((_WIN32_WINNT >= 0x0600) && !defined(_CONTRACT_GEN)) || (_APISET_FIBERS_VER > 0x0100)

public static native @Cast("BOOL") boolean IsThreadAFiber(
    );


// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// end_1_1

// begin_1_0
// begin_1_1

// #ifdef __cplusplus
// #endif

// #endif // _FIBERS_H_
// end_1_0
// end_1_1


// Parsed from namedpipeapi.h

 
 
// begin_1_0
/********************************************************************************
*                                                                               *
* namedpipeapi.h - ApiSet Contract for api-ms-win-core-namedpipe-l1-1-0         *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _NAMEDPIPE_H_
// #define _NAMEDPIPE_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-core-namedpipe-l1 */

// #ifndef _APISET_NAMEDPIPE_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION > 0x0100
public static final int _APISET_NAMEDPIPE_VER = 0x0200;
// #elif _APISET_MINWIN_VERSION <= 0x0100
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// end_1_0

// begin_1_0


// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean CreatePipe(
    @Cast("PHANDLE") PointerPointer hReadPipe,
    @Cast("PHANDLE") PointerPointer hWritePipe,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpPipeAttributes,
    @Cast("DWORD") int nSize
    );


public static native @Cast("BOOL") boolean ConnectNamedPipe(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );


public static native @Cast("BOOL") boolean DisconnectNamedPipe(
    @Cast("HANDLE") Pointer hNamedPipe
    );


public static native @Cast("BOOL") boolean SetNamedPipeHandleState(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPDWORD") IntPointer lpMode,
    @Cast("LPDWORD") IntPointer lpMaxCollectionCount,
    @Cast("LPDWORD") IntPointer lpCollectDataTimeout
    );
public static native @Cast("BOOL") boolean SetNamedPipeHandleState(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPDWORD") IntBuffer lpMode,
    @Cast("LPDWORD") IntBuffer lpMaxCollectionCount,
    @Cast("LPDWORD") IntBuffer lpCollectDataTimeout
    );
public static native @Cast("BOOL") boolean SetNamedPipeHandleState(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPDWORD") int[] lpMode,
    @Cast("LPDWORD") int[] lpMaxCollectionCount,
    @Cast("LPDWORD") int[] lpCollectDataTimeout
    );


public static native @Cast("BOOL") boolean PeekNamedPipe(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int nBufferSize,
    @Cast("LPDWORD") IntPointer lpBytesRead,
    @Cast("LPDWORD") IntPointer lpTotalBytesAvail,
    @Cast("LPDWORD") IntPointer lpBytesLeftThisMessage
    );
public static native @Cast("BOOL") boolean PeekNamedPipe(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int nBufferSize,
    @Cast("LPDWORD") IntBuffer lpBytesRead,
    @Cast("LPDWORD") IntBuffer lpTotalBytesAvail,
    @Cast("LPDWORD") IntBuffer lpBytesLeftThisMessage
    );
public static native @Cast("BOOL") boolean PeekNamedPipe(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int nBufferSize,
    @Cast("LPDWORD") int[] lpBytesRead,
    @Cast("LPDWORD") int[] lpTotalBytesAvail,
    @Cast("LPDWORD") int[] lpBytesLeftThisMessage
    );


public static native @Cast("BOOL") boolean TransactNamedPipe(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") IntPointer lpBytesRead,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );
public static native @Cast("BOOL") boolean TransactNamedPipe(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") IntBuffer lpBytesRead,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );
public static native @Cast("BOOL") boolean TransactNamedPipe(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") int[] lpBytesRead,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );


public static native @Cast("HANDLE") Pointer CreateNamedPipeW(
    @Cast("LPCWSTR") CharPointer lpName,
    @Cast("DWORD") int dwOpenMode,
    @Cast("DWORD") int dwPipeMode,
    @Cast("DWORD") int nMaxInstances,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("DWORD") int nInBufferSize,
    @Cast("DWORD") int nDefaultTimeOut,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("HANDLE") Pointer CreateNamedPipeW(
    @Cast("LPCWSTR") CharBuffer lpName,
    @Cast("DWORD") int dwOpenMode,
    @Cast("DWORD") int dwPipeMode,
    @Cast("DWORD") int nMaxInstances,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("DWORD") int nInBufferSize,
    @Cast("DWORD") int nDefaultTimeOut,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("HANDLE") Pointer CreateNamedPipeW(
    @Cast("LPCWSTR") char[] lpName,
    @Cast("DWORD") int dwOpenMode,
    @Cast("DWORD") int dwPipeMode,
    @Cast("DWORD") int nMaxInstances,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("DWORD") int nInBufferSize,
    @Cast("DWORD") int nDefaultTimeOut,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );


// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean WaitNamedPipeW(
    @Cast("LPCWSTR") CharPointer lpNamedPipeName,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean WaitNamedPipeW(
    @Cast("LPCWSTR") CharBuffer lpNamedPipeName,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean WaitNamedPipeW(
    @Cast("LPCWSTR") char[] lpNamedPipeName,
    @Cast("DWORD") int nTimeOut
    );


// #ifdef UNICODE
// #endif


// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean GetNamedPipeClientComputerNameW(
    @Cast("HANDLE") Pointer Pipe,
    @Cast("LPWSTR") CharPointer ClientComputerName,
    @Cast("ULONG") long ClientComputerNameLength
    );
public static native @Cast("BOOL") boolean GetNamedPipeClientComputerNameW(
    @Cast("HANDLE") Pointer Pipe,
    @Cast("LPWSTR") CharBuffer ClientComputerName,
    @Cast("ULONG") long ClientComputerNameLength
    );
public static native @Cast("BOOL") boolean GetNamedPipeClientComputerNameW(
    @Cast("HANDLE") Pointer Pipe,
    @Cast("LPWSTR") char[] ClientComputerName,
    @Cast("ULONG") long ClientComputerNameLength
    );


// #endif // (_WIN32_WINNT >= 0x0600)

// #ifdef UNICODE
// #endif

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// end_1_0


// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean ImpersonateNamedPipeClient(
    @Cast("HANDLE") Pointer hNamedPipe
    );
                               

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// begin_1_0

// #ifdef __cplusplus
// #endif

// #endif // _NAMEDPIPE_H_

// end_1_0


// Parsed from profileapi.h

 
/********************************************************************************
*                                                                               *
* profileapi.h -- ApiSet Contract for api-ms-win-core-profile-l1                *  
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _PROFILEAPI_H_
// #define _PROFILEAPI_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>

/* APISET_NAME: api-ms-win-core-profile-l1 */

// #ifndef _APISET_PROFILE_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0101
public static final int _APISET_PROFILE_VER = 0x0100;
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

//
// Performance counter API's
//

public static native @Cast("BOOL") boolean QueryPerformanceCounter(
    LARGE_INTEGER lpPerformanceCount
    );


public static native @Cast("BOOL") boolean QueryPerformanceFrequency(
    LARGE_INTEGER lpFrequency
    );


// #ifdef __cplusplus
// #endif

// #endif // _PROFILEAPI_H_


// Parsed from heapapi.h

 
/********************************************************************************
*                                                                               *
* HeapApi.h -- ApiSet Contract for api-ms-win-core-heap-l1                      *  
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _HEAPAPI_H_
// #define _HEAPAPI_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-core-heap-l1 */

// #ifndef _APISET_HEAP_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION > 0x0100
public static final int _APISET_HEAP_VER = 0x0200;
// #elif _APISET_MINWIN_VERSION <= 0x0100
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// #pragma region Desktop Family
// Targeting ..\windows\HEAP_SUMMARY.java



// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

//
// Prototypes
//

public static native @Cast("HANDLE") Pointer HeapCreate(
    @Cast("DWORD") int flOptions,
    @Cast("SIZE_T") long dwInitialSize,
    @Cast("SIZE_T") long dwMaximumSize
    );


public static native @Cast("BOOL") boolean HeapDestroy(
    @Cast("HANDLE") Pointer hHeap
    );

    
// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("LPVOID") Pointer HeapAlloc(
    @Cast("HANDLE") Pointer hHeap,
    @Cast("DWORD") int dwFlags,
    @Cast("SIZE_T") long dwBytes
    );


public static native @Cast("LPVOID") Pointer HeapReAlloc(
    @Cast("HANDLE") Pointer hHeap,
    @Cast("DWORD") int dwFlags,
    @Cast("LPVOID") Pointer lpMem,
    @Cast("SIZE_T") long dwBytes
    );


public static native @Cast("BOOL") boolean HeapFree(
    @Cast("HANDLE") Pointer hHeap,
    @Cast("DWORD") int dwFlags,
    @Cast("LPVOID") Pointer lpMem
    );


public static native @Cast("SIZE_T") long HeapSize(
    @Cast("HANDLE") Pointer hHeap,
    @Cast("DWORD") int dwFlags,
    LPCVOID lpMem
    );


// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean HeapValidate(
    @Cast("HANDLE") Pointer hHeap,
    @Cast("DWORD") int dwFlags,
    LPCVOID lpMem
    );


public static native @Cast("SIZE_T") long HeapCompact(
    @Cast("HANDLE") Pointer hHeap,
    @Cast("DWORD") int dwFlags
    );



// #if (defined(_WIN32_WINNT) && !defined(_CONTRACT_GEN)) || (_APISET_HEAP_VER <= 0x0100)

public static native @Cast("BOOL") boolean HeapSummary(
    @Cast("HANDLE") Pointer hHeap,
    @Cast("DWORD") int dwFlags,
    @Cast("LPHEAP_SUMMARY") HEAP_SUMMARY lpSummary
    );


// #endif

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("HANDLE") Pointer GetProcessHeap(
    );


// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("DWORD") int GetProcessHeaps(
    @Cast("DWORD") int NumberOfHeaps,
    @Cast("PHANDLE") PointerPointer ProcessHeaps
    );


public static native @Cast("BOOL") boolean HeapLock(
    @Cast("HANDLE") Pointer hHeap
    );


public static native @Cast("BOOL") boolean HeapUnlock(
    @Cast("HANDLE") Pointer hHeap
    );


public static native @Cast("BOOL") boolean HeapWalk(
    @Cast("HANDLE") Pointer hHeap,
    @Cast("LPPROCESS_HEAP_ENTRY") PROCESS_HEAP_ENTRY lpEntry
    );


public static native @Cast("BOOL") boolean HeapSetInformation(
    @Cast("HANDLE") Pointer HeapHandle,
    @Cast("HEAP_INFORMATION_CLASS") int HeapInformationClass,
    @Cast("PVOID") Pointer HeapInformation,
    @Cast("SIZE_T") long HeapInformationLength
    );


public static native @Cast("BOOL") boolean HeapQueryInformation(
    @Cast("HANDLE") Pointer HeapHandle,
    @Cast("HEAP_INFORMATION_CLASS") int HeapInformationClass,
    @Cast("PVOID") Pointer HeapInformation,
    @Cast("SIZE_T") long HeapInformationLength,
    @Cast("PSIZE_T") SizeTPointer ReturnLength
    );

    
// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

//
// HeapSummary() is in minwinbase.w within ;beg_internal tags. Has to stay there for downlevel reasons.
// 

// #ifdef __cplusplus
// #endif

// #endif // _HEAPAPI_H_


// Parsed from ioapiset.h

 
// begin_1_0
// begin_1_1
/********************************************************************************
*                                                                               *
* ioapiset.h -- ApiSet Contract for api-ms-win-core-io-l1                       *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _IO_APISET_H_
// #define _IO_APISET_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-core-io-l1 */

// #ifndef _APISET_IO_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0101
public static final int _APISET_IO_VER = 0x0101;
// #elif _APISET_MINWIN_VERSION <= 0x0100
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// end_1_0
// end_1_1

// begin_1_0

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean GetOverlappedResult(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped,
    @Cast("LPDWORD") IntPointer lpNumberOfBytesTransferred,
    @Cast("BOOL") boolean bWait
    );
public static native @Cast("BOOL") boolean GetOverlappedResult(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped,
    @Cast("LPDWORD") IntBuffer lpNumberOfBytesTransferred,
    @Cast("BOOL") boolean bWait
    );
public static native @Cast("BOOL") boolean GetOverlappedResult(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped,
    @Cast("LPDWORD") int[] lpNumberOfBytesTransferred,
    @Cast("BOOL") boolean bWait
    );


public static native @Cast("HANDLE") Pointer CreateIoCompletionPort(
    @Cast("HANDLE") Pointer FileHandle,
    @Cast("HANDLE") Pointer ExistingCompletionPort,
    @Cast("ULONG_PTR") long CompletionKey,
    @Cast("DWORD") int NumberOfConcurrentThreads
    );


public static native @Cast("BOOL") boolean GetQueuedCompletionStatus(
    @Cast("HANDLE") Pointer CompletionPort,
    @Cast("LPDWORD") IntPointer lpNumberOfBytesTransferred,
    @Cast("PULONG_PTR") SizeTPointer lpCompletionKey,
    @Cast("LPOVERLAPPED*") PointerPointer lpOverlapped,
    @Cast("DWORD") int dwMilliseconds
    );
public static native @Cast("BOOL") boolean GetQueuedCompletionStatus(
    @Cast("HANDLE") Pointer CompletionPort,
    @Cast("LPDWORD") IntBuffer lpNumberOfBytesTransferred,
    @Cast("PULONG_PTR") SizeTPointer lpCompletionKey,
    @Cast("LPOVERLAPPED*") PointerPointer lpOverlapped,
    @Cast("DWORD") int dwMilliseconds
    );
public static native @Cast("BOOL") boolean GetQueuedCompletionStatus(
    @Cast("HANDLE") Pointer CompletionPort,
    @Cast("LPDWORD") int[] lpNumberOfBytesTransferred,
    @Cast("PULONG_PTR") SizeTPointer lpCompletionKey,
    @Cast("LPOVERLAPPED*") PointerPointer lpOverlapped,
    @Cast("DWORD") int dwMilliseconds
    );



// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean GetQueuedCompletionStatusEx(
    @Cast("HANDLE") Pointer CompletionPort,
    @Cast("LPOVERLAPPED_ENTRY") OVERLAPPED_ENTRY lpCompletionPortEntries,
    @Cast("ULONG") long ulCount,
    @Cast("PULONG") long ulNumEntriesRemoved,
    @Cast("DWORD") int dwMilliseconds,
    @Cast("BOOL") boolean fAlertable
    );


// #endif // _WIN32_WINNT >= 0x0600

public static native @Cast("BOOL") boolean PostQueuedCompletionStatus(
    @Cast("HANDLE") Pointer CompletionPort,
    @Cast("DWORD") int dwNumberOfBytesTransferred,
    @Cast("ULONG_PTR") long dwCompletionKey,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );


public static native @Cast("BOOL") boolean DeviceIoControl(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("DWORD") int dwIoControlCode,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") IntPointer lpBytesReturned,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );
public static native @Cast("BOOL") boolean DeviceIoControl(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("DWORD") int dwIoControlCode,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") IntBuffer lpBytesReturned,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );
public static native @Cast("BOOL") boolean DeviceIoControl(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("DWORD") int dwIoControlCode,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") int[] lpBytesReturned,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );



// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean CancelIoEx(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );


// #endif // _WIN32_WINNT >= 0x0600

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// end_1_0

// begin_1_1


// #if !defined(_CONTRACT_GEN) || (_APISET_IO_VER > 0x0100)

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean GetOverlappedResultEx(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped,
    @Cast("LPDWORD") IntPointer lpNumberOfBytesTransferred,
    @Cast("DWORD") int dwMilliseconds,
    @Cast("BOOL") boolean bAlertable
    );
public static native @Cast("BOOL") boolean GetOverlappedResultEx(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped,
    @Cast("LPDWORD") IntBuffer lpNumberOfBytesTransferred,
    @Cast("DWORD") int dwMilliseconds,
    @Cast("BOOL") boolean bAlertable
    );
public static native @Cast("BOOL") boolean GetOverlappedResultEx(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped,
    @Cast("LPDWORD") int[] lpNumberOfBytesTransferred,
    @Cast("DWORD") int dwMilliseconds,
    @Cast("BOOL") boolean bAlertable
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean CancelIo(
    @Cast("HANDLE") Pointer hFile
    );



// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean CancelSynchronousIo(
    @Cast("HANDLE") Pointer hThread
    );


// #endif // _WIN32_WINNT >= 0x0600

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif // !defined(_CONTRACT_GEN) || (_APISET_IO_VER > 0x0100)

// end_1_1

// begin_1_0
// begin_1_1

// #ifdef __cplusplus
// #endif

// #endif // _IO_APISET_H_
// end_1_0
// end_1_1


// Parsed from synchapi.h

 
 
// begin_1_0
// begin_2_0
/********************************************************************************
*                                                                               *
* synchapi.h -- ApiSet Contract for api-ms-win-core-synch-l1                    *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _SYNCHAPI_H_
// #define _SYNCHAPI_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-core-synch-l1 */

// #ifndef _APISET_SYNCH_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION > 0x0100
public static final int _APISET_SYNCH_VER = 0x0200;
// #elif _APISET_MINWIN_VERSION <= 0x0100
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// end_1_0
// end_2_0

// begin_1_0
// begin_2_0

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

//
// Define the slim R/W lock.
//

public static native @MemberGetter int SRWLOCK_INIT();
public static final int SRWLOCK_INIT = SRWLOCK_INIT();

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// end_1_0
// end_2_0

// begin_1_0

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)


// #if (_WIN32_WINNT >= 0x0600)

public static native void InitializeSRWLock(
    @Cast("PSRWLOCK") RTL_SRWLOCK SRWLock
    );


public static native void ReleaseSRWLockExclusive(
    @Cast("PSRWLOCK") RTL_SRWLOCK SRWLock
    );


public static native void ReleaseSRWLockShared(
    @Cast("PSRWLOCK") RTL_SRWLOCK SRWLock
    );


public static native void AcquireSRWLockExclusive(
    @Cast("PSRWLOCK") RTL_SRWLOCK SRWLock
    );


public static native void AcquireSRWLockShared(
    @Cast("PSRWLOCK") RTL_SRWLOCK SRWLock
    );


public static native @Cast("BOOLEAN") boolean TryAcquireSRWLockExclusive(
    @Cast("PSRWLOCK") RTL_SRWLOCK SRWLock
    );


public static native @Cast("BOOLEAN") boolean TryAcquireSRWLockShared(
    @Cast("PSRWLOCK") RTL_SRWLOCK SRWLock
    );


// #endif // (_WIN32_WINNT >= 0x0600)

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if (_WIN32_WINNT < 0x0600)

public static native void InitializeCriticalSection(
    @Cast("LPCRITICAL_SECTION") RTL_CRITICAL_SECTION lpCriticalSection
    );


// #else


// #endif  // (_WIN32_WINNT < 0x0600)

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native void EnterCriticalSection(
    @Cast("LPCRITICAL_SECTION") RTL_CRITICAL_SECTION lpCriticalSection
    );


public static native void LeaveCriticalSection(
    @Cast("LPCRITICAL_SECTION") RTL_CRITICAL_SECTION lpCriticalSection
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean InitializeCriticalSectionAndSpinCount(
    @Cast("LPCRITICAL_SECTION") RTL_CRITICAL_SECTION lpCriticalSection,
    @Cast("DWORD") int dwSpinCount
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)


// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean InitializeCriticalSectionEx(
    @Cast("LPCRITICAL_SECTION") RTL_CRITICAL_SECTION lpCriticalSection,
    @Cast("DWORD") int dwSpinCount,
    @Cast("DWORD") int Flags
    );


// #endif // (_WIN32_WINNT >= 0x0600)

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("DWORD") int SetCriticalSectionSpinCount(
    @Cast("LPCRITICAL_SECTION") RTL_CRITICAL_SECTION lpCriticalSection,
    @Cast("DWORD") int dwSpinCount
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)


// #if (_WIN32_WINNT >= 0x0400)

public static native @Cast("BOOL") boolean TryEnterCriticalSection(
    @Cast("LPCRITICAL_SECTION") RTL_CRITICAL_SECTION lpCriticalSection
    );


// #endif /* _WIN32_WINNT >= 0x0400 */

public static native void DeleteCriticalSection(
    @Cast("LPCRITICAL_SECTION") RTL_CRITICAL_SECTION lpCriticalSection
    );


// end_1_0

// begin_2_0

//
// Define one-time initialization primitive
//

public static native @MemberGetter int INIT_ONCE_STATIC_INIT();
public static final int INIT_ONCE_STATIC_INIT = INIT_ONCE_STATIC_INIT();

//
// Run once flags
//

public static final long INIT_ONCE_CHECK_ONLY =        RTL_RUN_ONCE_CHECK_ONLY;
public static final long INIT_ONCE_ASYNC =             RTL_RUN_ONCE_ASYNC;
public static final long INIT_ONCE_INIT_FAILED =       RTL_RUN_ONCE_INIT_FAILED;

//
// The context stored in the run once structure must leave the following number
// of low order bits unused.
//

public static final int INIT_ONCE_CTX_RESERVED_BITS = RTL_RUN_ONCE_CTX_RESERVED_BITS;
// Targeting ..\windows\PINIT_ONCE_FN.java




// #if ((!defined(_CONTRACT_GEN) && (_WIN32_WINNT >= 0x0600)) || (_APISET_MINWIN_VERSION >= 0x0101))

public static native void InitOnceInitialize(
    @Cast("PINIT_ONCE") RTL_RUN_ONCE InitOnce
    );


public static native @Cast("BOOL") boolean InitOnceExecuteOnce(
    @Cast("PINIT_ONCE") RTL_RUN_ONCE InitOnce,
    PINIT_ONCE_FN InitFn,
    @Cast("PVOID") Pointer Parameter,
    @Cast("LPVOID*") PointerPointer Context
    );


public static native @Cast("BOOL") boolean InitOnceBeginInitialize(
    @Cast("LPINIT_ONCE") RTL_RUN_ONCE lpInitOnce,
    @Cast("DWORD") int dwFlags,
    @Cast("PBOOL") boolean fPending,
    @Cast("LPVOID*") PointerPointer lpContext
    );


public static native @Cast("BOOL") boolean InitOnceComplete(
    @Cast("LPINIT_ONCE") RTL_RUN_ONCE lpInitOnce,
    @Cast("DWORD") int dwFlags,
    @Cast("LPVOID") Pointer lpContext
    );


// #endif // ((!defined(_CONTRACT_GEN) && (_WIN32_WINNT >= 0x0600)) || (_APISET_MINWIN_VERSION >= 0x0101))

//
// Define condition variable
//

//
// Static initializer for the condition variable
//

public static native @MemberGetter int CONDITION_VARIABLE_INIT();
public static final int CONDITION_VARIABLE_INIT = CONDITION_VARIABLE_INIT();

//
// Flags for condition variables
//

public static final int CONDITION_VARIABLE_LOCKMODE_SHARED = RTL_CONDITION_VARIABLE_LOCKMODE_SHARED;


// #if ((!defined(_CONTRACT_GEN) && (_WIN32_WINNT >= 0x0600)) || (_APISET_MINWIN_VERSION >= 0x0101))

public static native void InitializeConditionVariable(
    @Cast("PCONDITION_VARIABLE") RTL_CONDITION_VARIABLE ConditionVariable
    );


public static native void WakeConditionVariable(
    @Cast("PCONDITION_VARIABLE") RTL_CONDITION_VARIABLE ConditionVariable
    );


public static native void WakeAllConditionVariable(
    @Cast("PCONDITION_VARIABLE") RTL_CONDITION_VARIABLE ConditionVariable
    );


public static native @Cast("BOOL") boolean SleepConditionVariableCS(
    @Cast("PCONDITION_VARIABLE") RTL_CONDITION_VARIABLE ConditionVariable,
    @Cast("PCRITICAL_SECTION") RTL_CRITICAL_SECTION CriticalSection,
    @Cast("DWORD") int dwMilliseconds
    );


public static native @Cast("BOOL") boolean SleepConditionVariableSRW(
    @Cast("PCONDITION_VARIABLE") RTL_CONDITION_VARIABLE ConditionVariable,
    @Cast("PSRWLOCK") RTL_SRWLOCK SRWLock,
    @Cast("DWORD") int dwMilliseconds,
    @Cast("ULONG") long Flags
    );


// #endif // ((!defined(_CONTRACT_GEN) && (_WIN32_WINNT >= 0x0600)) || (_APISET_MINWIN_VERSION >= 0x0101))

// end_2_0

// begin_1_0

public static native @Cast("BOOL") boolean SetEvent(
    @Cast("HANDLE") Pointer hEvent
    );


public static native @Cast("BOOL") boolean ResetEvent(
    @Cast("HANDLE") Pointer hEvent
    );


public static native @Cast("BOOL") boolean ReleaseSemaphore(
    @Cast("HANDLE") Pointer hSemaphore,
    @Cast("LONG") int lReleaseCount,
    @Cast("LPLONG") IntPointer lpPreviousCount
    );
public static native @Cast("BOOL") boolean ReleaseSemaphore(
    @Cast("HANDLE") Pointer hSemaphore,
    @Cast("LONG") int lReleaseCount,
    @Cast("LPLONG") IntBuffer lpPreviousCount
    );
public static native @Cast("BOOL") boolean ReleaseSemaphore(
    @Cast("HANDLE") Pointer hSemaphore,
    @Cast("LONG") int lReleaseCount,
    @Cast("LPLONG") int[] lpPreviousCount
    );


public static native @Cast("BOOL") boolean ReleaseMutex(
    @Cast("HANDLE") Pointer hMutex
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("DWORD") int WaitForSingleObject(
    @Cast("HANDLE") Pointer hHandle,
    @Cast("DWORD") int dwMilliseconds
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("DWORD") int SleepEx(
    @Cast("DWORD") int dwMilliseconds,
    @Cast("BOOL") boolean bAlertable
    );


public static native @Cast("DWORD") int WaitForSingleObjectEx(
    @Cast("HANDLE") Pointer hHandle,
    @Cast("DWORD") int dwMilliseconds,
    @Cast("BOOL") boolean bAlertable
    );


public static native @Cast("DWORD") int WaitForMultipleObjectsEx(
    @Cast("DWORD") int nCount,
    @Cast("const HANDLE*") PointerPointer lpHandles,
    @Cast("BOOL") boolean bWaitAll,
    @Cast("DWORD") int dwMilliseconds,
    @Cast("BOOL") boolean bAlertable
    );


//
// Synchronization APIs
//

public static final int MUTEX_MODIFY_STATE =  MUTANT_QUERY_STATE;
public static final long MUTEX_ALL_ACCESS =    MUTANT_ALL_ACCESS;

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("HANDLE") Pointer CreateMutexA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpMutexAttributes,
    @Cast("BOOL") boolean bInitialOwner,
    @Cast("LPCSTR") BytePointer lpName
    );
public static native @Cast("HANDLE") Pointer CreateMutexA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpMutexAttributes,
    @Cast("BOOL") boolean bInitialOwner,
    @Cast("LPCSTR") ByteBuffer lpName
    );
public static native @Cast("HANDLE") Pointer CreateMutexA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpMutexAttributes,
    @Cast("BOOL") boolean bInitialOwner,
    @Cast("LPCSTR") byte[] lpName
    );
public static native @Cast("HANDLE") Pointer CreateMutexA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpMutexAttributes,
    @Cast("BOOL") boolean bInitialOwner,
    @Cast("LPCSTR") String lpName
    );

public static native @Cast("HANDLE") Pointer CreateMutexW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpMutexAttributes,
    @Cast("BOOL") boolean bInitialOwner,
    @Cast("LPCWSTR") CharPointer lpName
    );
public static native @Cast("HANDLE") Pointer CreateMutexW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpMutexAttributes,
    @Cast("BOOL") boolean bInitialOwner,
    @Cast("LPCWSTR") CharBuffer lpName
    );
public static native @Cast("HANDLE") Pointer CreateMutexW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpMutexAttributes,
    @Cast("BOOL") boolean bInitialOwner,
    @Cast("LPCWSTR") char[] lpName
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("HANDLE") Pointer OpenMutexW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") CharPointer lpName
    );
public static native @Cast("HANDLE") Pointer OpenMutexW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") CharBuffer lpName
    );
public static native @Cast("HANDLE") Pointer OpenMutexW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") char[] lpName
    );


// #ifdef UNICODE
// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("HANDLE") Pointer CreateEventA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpEventAttributes,
    @Cast("BOOL") boolean bManualReset,
    @Cast("BOOL") boolean bInitialState,
    @Cast("LPCSTR") BytePointer lpName
    );
public static native @Cast("HANDLE") Pointer CreateEventA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpEventAttributes,
    @Cast("BOOL") boolean bManualReset,
    @Cast("BOOL") boolean bInitialState,
    @Cast("LPCSTR") ByteBuffer lpName
    );
public static native @Cast("HANDLE") Pointer CreateEventA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpEventAttributes,
    @Cast("BOOL") boolean bManualReset,
    @Cast("BOOL") boolean bInitialState,
    @Cast("LPCSTR") byte[] lpName
    );
public static native @Cast("HANDLE") Pointer CreateEventA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpEventAttributes,
    @Cast("BOOL") boolean bManualReset,
    @Cast("BOOL") boolean bInitialState,
    @Cast("LPCSTR") String lpName
    );

public static native @Cast("HANDLE") Pointer CreateEventW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpEventAttributes,
    @Cast("BOOL") boolean bManualReset,
    @Cast("BOOL") boolean bInitialState,
    @Cast("LPCWSTR") CharPointer lpName
    );
public static native @Cast("HANDLE") Pointer CreateEventW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpEventAttributes,
    @Cast("BOOL") boolean bManualReset,
    @Cast("BOOL") boolean bInitialState,
    @Cast("LPCWSTR") CharBuffer lpName
    );
public static native @Cast("HANDLE") Pointer CreateEventW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpEventAttributes,
    @Cast("BOOL") boolean bManualReset,
    @Cast("BOOL") boolean bInitialState,
    @Cast("LPCWSTR") char[] lpName
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("HANDLE") Pointer OpenEventA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") BytePointer lpName
    );
public static native @Cast("HANDLE") Pointer OpenEventA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") ByteBuffer lpName
    );
public static native @Cast("HANDLE") Pointer OpenEventA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") byte[] lpName
    );
public static native @Cast("HANDLE") Pointer OpenEventA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") String lpName
    );

public static native @Cast("HANDLE") Pointer OpenEventW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") CharPointer lpName
    );
public static native @Cast("HANDLE") Pointer OpenEventW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") CharBuffer lpName
    );
public static native @Cast("HANDLE") Pointer OpenEventW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") char[] lpName
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("HANDLE") Pointer OpenSemaphoreW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") CharPointer lpName
    );
public static native @Cast("HANDLE") Pointer OpenSemaphoreW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") CharBuffer lpName
    );
public static native @Cast("HANDLE") Pointer OpenSemaphoreW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") char[] lpName
    );


// #ifdef UNICODE
// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion


// #if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)

// #pragma region Desktop Family
// Targeting ..\windows\PTIMERAPCROUTINE.java



public static native @Cast("HANDLE") Pointer OpenWaitableTimerW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") CharPointer lpTimerName
    );
public static native @Cast("HANDLE") Pointer OpenWaitableTimerW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") CharBuffer lpTimerName
    );
public static native @Cast("HANDLE") Pointer OpenWaitableTimerW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") char[] lpTimerName
    );


// #ifdef UNICODE
// #endif


// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

public static native @Cast("BOOL") boolean SetWaitableTimerEx(
    @Cast("HANDLE") Pointer hTimer,
    @Const LARGE_INTEGER lpDueTime,
    @Cast("LONG") int lPeriod,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    @Cast("LPVOID") Pointer lpArgToCompletionRoutine,
    @Cast("PREASON_CONTEXT") REASON_CONTEXT WakeContext,
    @Cast("ULONG") long TolerableDelay
    );


// #endif // (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

public static native @Cast("BOOL") boolean SetWaitableTimer(
    @Cast("HANDLE") Pointer hTimer,
    @Const LARGE_INTEGER lpDueTime,
    @Cast("LONG") int lPeriod,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    @Cast("LPVOID") Pointer lpArgToCompletionRoutine,
    @Cast("BOOL") boolean fResume
    );


public static native @Cast("BOOL") boolean CancelWaitableTimer(
    @Cast("HANDLE") Pointer hTimer
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion


// #if (_WIN32_WINNT >= 0x0600)

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static final int CREATE_MUTEX_INITIAL_OWNER =  0x00000001;

public static native @Cast("HANDLE") Pointer CreateMutexExA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpMutexAttributes,
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateMutexExA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpMutexAttributes,
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateMutexExA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpMutexAttributes,
    @Cast("LPCSTR") byte[] lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateMutexExA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpMutexAttributes,
    @Cast("LPCSTR") String lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );

public static native @Cast("HANDLE") Pointer CreateMutexExW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpMutexAttributes,
    @Cast("LPCWSTR") CharPointer lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateMutexExW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpMutexAttributes,
    @Cast("LPCWSTR") CharBuffer lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateMutexExW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpMutexAttributes,
    @Cast("LPCWSTR") char[] lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static final int CREATE_EVENT_MANUAL_RESET =   0x00000001;
public static final int CREATE_EVENT_INITIAL_SET =    0x00000002;

public static native @Cast("HANDLE") Pointer CreateEventExA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpEventAttributes,
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateEventExA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpEventAttributes,
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateEventExA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpEventAttributes,
    @Cast("LPCSTR") byte[] lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateEventExA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpEventAttributes,
    @Cast("LPCSTR") String lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );

public static native @Cast("HANDLE") Pointer CreateEventExW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpEventAttributes,
    @Cast("LPCWSTR") CharPointer lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateEventExW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpEventAttributes,
    @Cast("LPCWSTR") CharBuffer lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateEventExW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpEventAttributes,
    @Cast("LPCWSTR") char[] lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("HANDLE") Pointer CreateSemaphoreExW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSemaphoreAttributes,
    @Cast("LONG") int lInitialCount,
    @Cast("LONG") int lMaximumCount,
    @Cast("LPCWSTR") CharPointer lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateSemaphoreExW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSemaphoreAttributes,
    @Cast("LONG") int lInitialCount,
    @Cast("LONG") int lMaximumCount,
    @Cast("LPCWSTR") CharBuffer lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateSemaphoreExW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSemaphoreAttributes,
    @Cast("LONG") int lInitialCount,
    @Cast("LONG") int lMaximumCount,
    @Cast("LPCWSTR") char[] lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );


// #ifdef UNICODE
// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static final int CREATE_WAITABLE_TIMER_MANUAL_RESET =  0x00000001;

public static native @Cast("HANDLE") Pointer CreateWaitableTimerExW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpTimerAttributes,
    @Cast("LPCWSTR") CharPointer lpTimerName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateWaitableTimerExW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpTimerAttributes,
    @Cast("LPCWSTR") CharBuffer lpTimerName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateWaitableTimerExW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpTimerAttributes,
    @Cast("LPCWSTR") char[] lpTimerName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );


// #ifdef UNICODE
// #endif

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #endif // (_WIN32_WINNT >= 0x0600)

// #endif // (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)

// end_1_0

// begin_2_0


// #if !defined(_CONTRACT_GEN) || (_APISET_SYNCH_VER >= 0x0101)

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static final int SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY =  0x01;
public static final int SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY = 0x02;
public static final int SYNCHRONIZATION_BARRIER_FLAGS_NO_DELETE =  0x04;

public static native @Cast("BOOL") boolean EnterSynchronizationBarrier(
    @Cast("LPSYNCHRONIZATION_BARRIER") RTL_BARRIER lpBarrier,
    @Cast("DWORD") int dwFlags
    );


public static native @Cast("BOOL") boolean InitializeSynchronizationBarrier(
    @Cast("LPSYNCHRONIZATION_BARRIER") RTL_BARRIER lpBarrier,
    @Cast("LONG") int lTotalThreads,
    @Cast("LONG") int lSpinCount
    );


public static native @Cast("BOOL") boolean DeleteSynchronizationBarrier(
    @Cast("LPSYNCHRONIZATION_BARRIER") RTL_BARRIER lpBarrier
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native void Sleep(
    @Cast("DWORD") int dwMilliseconds
    );


public static native @Cast("BOOL") boolean WaitOnAddress(
    Pointer Address,
    @Cast("PVOID") Pointer CompareAddress,
    @Cast("SIZE_T") long AddressSize,
    @Cast("DWORD") int dwMilliseconds
    );


public static native void WakeByAddressSingle(
    @Cast("PVOID") Pointer Address
    );


public static native void WakeByAddressAll(
    @Cast("PVOID") Pointer Address
    );

    
// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// #ifndef MIDL_PASS

public static native @Cast("DWORD") int SignalObjectAndWait(
    @Cast("HANDLE") Pointer hObjectToSignal,
    @Cast("HANDLE") Pointer hObjectToWaitOn,
    @Cast("DWORD") int dwMilliseconds,
    @Cast("BOOL") boolean bAlertable
    );


// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif // (_APISET_SYNCH_VER >= 0x0101)

// end_2_0
// begin_1_0
// begin_2_0

// #ifdef __cplusplus
// #endif

// #endif // _SYNCHAPI_H_
// end_1_0
// end_2_0


// Parsed from interlockedapi.h

 
 
// begin_1_0
/********************************************************************************
*                                                                               *
* interlockedapi.h -- ApiSet Contract for api-ms-win-core-interlocked-l1        *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _INTERLOCKAPI_H_
// #define _INTERLOCKAPI_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>

/* APISET_NAME: api-ms-win-core-interlocked-l1 */

// #ifndef _APISET_INTERLOCKED_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION > 0x0100
public static final int _APISET_INTERLOCKED_VER = 0x0200;
// #elif _APISET_MINWIN_VERSION <= 0x0100
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// #ifndef NOWINBASEINTERLOCK

// #ifndef _NTOS_



// #if defined(_SLIST_HEADER_) && !defined(_NTOSP_)

public static native void InitializeSListHead(
    @Cast("PSLIST_HEADER") SLIST_HEADER ListHead
    );


public static native @Cast("PSLIST_ENTRY") SLIST_ENTRY InterlockedPopEntrySList(
    @Cast("PSLIST_HEADER") SLIST_HEADER ListHead
    );


public static native @Cast("PSLIST_ENTRY") SLIST_ENTRY InterlockedPushEntrySList(
    @Cast("PSLIST_HEADER") SLIST_HEADER ListHead,
    @Cast("PSLIST_ENTRY") SLIST_ENTRY ListEntry
    );



// #if ((NTDDI_VERSION >= NTDDI_WIN8) && !defined(_CONTRACT_GEN)) || (_APISET_INTERLOCKED_VER > 0x0100)


// #endif // ((NTDDI_VERSION >= NTDDI_WIN8) && !defined(_CONTRACT_GEN)) || (_APISET_INTERLOCKED_VER > 0x0100)

public static native @Cast("PSLIST_ENTRY") SLIST_ENTRY InterlockedFlushSList(
    @Cast("PSLIST_HEADER") SLIST_HEADER ListHead
    );


public static native @Cast("USHORT") short QueryDepthSList(
    @Cast("PSLIST_HEADER") SLIST_HEADER ListHead
    );


// #endif /* SLIST_HEADER_ */

// #endif /* _NTOS_ */

// #endif /* NOWINBASEINTERLOCK */

// end_1_0
// begin_1_0

// #ifdef __cplusplus
// #endif

// #endif // _INTERLOCKAPI_H_
// end_1_0


// Parsed from processthreadsapi.h

 
// begin_1_0
// begin_1_1
// begin_1_2
/***********************************************************************************
*                                                                                  *
* processthreadsapi.h -- ApiSet Contract for api-ms-win-core-processthreads-l1     *
*                                                                                  *
* Copyright (c) Microsoft Corporation. All rights reserved.                        *
*                                                                                  *
***********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _PROCESSTHREADSAPI_H_
// #define _PROCESSTHREADSAPI_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-core-processthreads-l1 */

// #ifndef _APISET_PROCESSTHREADS_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0102
public static final int _APISET_PROCESSTHREADS_VER = 0x0102;
// #elif _APISET_MINWIN_VERSION == 0x0101
// #elif _APISET_MINWIN_VERSION == 0x0100
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// end_1_0
// end_1_1
// end_1_2

// begin_1_0

// #pragma region Desktop Family
// Targeting ..\windows\PROCESS_INFORMATION.java


// Targeting ..\windows\STARTUPINFOA.java


// Targeting ..\windows\STARTUPINFOW.java


// #ifdef UNICODE
// #else
// #endif // UNICODE


// #if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)

public static native @Cast("DWORD") int QueueUserAPC(
    PAPCFUNC pfnAPC,
    @Cast("HANDLE") Pointer hThread,
    @Cast("ULONG_PTR") long dwData
    );


// #endif /* _WIN32_WINNT >= 0x0400 || _WIN32_WINDOWS > 0x0400 */

public static native @Cast("BOOL") boolean GetProcessTimes(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPFILETIME") FILETIME lpCreationTime,
    @Cast("LPFILETIME") FILETIME lpExitTime,
    @Cast("LPFILETIME") FILETIME lpKernelTime,
    @Cast("LPFILETIME") FILETIME lpUserTime
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("HANDLE") Pointer GetCurrentProcess(
    );


public static native @Cast("DWORD") int GetCurrentProcessId(
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native void ExitProcess(
    @Cast("UINT") int uExitCode
    );


public static native @Cast("BOOL") boolean TerminateProcess(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("UINT") int uExitCode
    );


public static native @Cast("BOOL") boolean GetExitCodeProcess(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPDWORD") IntPointer lpExitCode
    );
public static native @Cast("BOOL") boolean GetExitCodeProcess(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPDWORD") IntBuffer lpExitCode
    );
public static native @Cast("BOOL") boolean GetExitCodeProcess(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPDWORD") int[] lpExitCode
    );


public static native @Cast("BOOL") boolean SwitchToThread(
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
public static native @Cast("HANDLE") Pointer CreateThread(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("SIZE_T") long dwStackSize,
    @Cast("LPTHREAD_START_ROUTINE") PTHREAD_START_ROUTINE lpStartAddress,
    @Cast("LPVOID") Pointer lpParameter,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPDWORD") IntPointer lpThreadId
    );
public static native @Cast("HANDLE") Pointer CreateThread(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("SIZE_T") long dwStackSize,
    @Cast("LPTHREAD_START_ROUTINE") PTHREAD_START_ROUTINE lpStartAddress,
    @Cast("LPVOID") Pointer lpParameter,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPDWORD") IntBuffer lpThreadId
    );
public static native @Cast("HANDLE") Pointer CreateThread(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("SIZE_T") long dwStackSize,
    @Cast("LPTHREAD_START_ROUTINE") PTHREAD_START_ROUTINE lpStartAddress,
    @Cast("LPVOID") Pointer lpParameter,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPDWORD") int[] lpThreadId
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
public static native @Cast("HANDLE") Pointer CreateRemoteThread(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("SIZE_T") long dwStackSize,
    @Cast("LPTHREAD_START_ROUTINE") PTHREAD_START_ROUTINE lpStartAddress,
    @Cast("LPVOID") Pointer lpParameter,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPDWORD") IntPointer lpThreadId
    );
public static native @Cast("HANDLE") Pointer CreateRemoteThread(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("SIZE_T") long dwStackSize,
    @Cast("LPTHREAD_START_ROUTINE") PTHREAD_START_ROUTINE lpStartAddress,
    @Cast("LPVOID") Pointer lpParameter,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPDWORD") IntBuffer lpThreadId
    );
public static native @Cast("HANDLE") Pointer CreateRemoteThread(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("SIZE_T") long dwStackSize,
    @Cast("LPTHREAD_START_ROUTINE") PTHREAD_START_ROUTINE lpStartAddress,
    @Cast("LPVOID") Pointer lpParameter,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPDWORD") int[] lpThreadId
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("HANDLE") Pointer GetCurrentThread(
    );


public static native @Cast("DWORD") int GetCurrentThreadId(
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("HANDLE") Pointer OpenThread(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("DWORD") int dwThreadId
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
public static native @Cast("BOOL") boolean SetThreadPriority(
    @Cast("HANDLE") Pointer hThread,
    int nPriority
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean SetThreadPriorityBoost(
    @Cast("HANDLE") Pointer hThread,
    @Cast("BOOL") boolean bDisablePriorityBoost
    );


public static native @Cast("BOOL") boolean GetThreadPriorityBoost(
    @Cast("HANDLE") Pointer hThread,
    @Cast("PBOOL") boolean pDisablePriorityBoost
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
public static native int GetThreadPriority(
    @Cast("HANDLE") Pointer hThread
    );


public static native void ExitThread(
    @Cast("DWORD") int dwExitCode
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
public static native @Cast("BOOL") boolean TerminateThread(
    @Cast("HANDLE") Pointer hThread,
    @Cast("DWORD") int dwExitCode
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean GetExitCodeThread(
    @Cast("HANDLE") Pointer hThread,
    @Cast("LPDWORD") IntPointer lpExitCode
    );
public static native @Cast("BOOL") boolean GetExitCodeThread(
    @Cast("HANDLE") Pointer hThread,
    @Cast("LPDWORD") IntBuffer lpExitCode
    );
public static native @Cast("BOOL") boolean GetExitCodeThread(
    @Cast("HANDLE") Pointer hThread,
    @Cast("LPDWORD") int[] lpExitCode
    );


public static native @Cast("DWORD") int SuspendThread(
    @Cast("HANDLE") Pointer hThread
    );


public static native @Cast("DWORD") int ResumeThread(
    @Cast("HANDLE") Pointer hThread
    );


// #ifndef FLS_OUT_OF_INDEXES
// #endif

public static final int TLS_OUT_OF_INDEXES = ((int)0xFFFFFFFF);

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// TlsAlloc, TlsFree, TlsGetValue and TlsSetValue are defined as inlines 
// only for the store apps, not for desktop apps
// #pragma region Application Family

// #if WINAPI_PARTITION_APP && !WINAPI_PARTITION_DESKTOP

// #include <fibersapi.h>

public static native @Cast("DWORD") int TlsAlloc(
    );

public static native @Cast("LPVOID") Pointer TlsGetValue(
    @Cast("DWORD") int dwTlsIndex
    );

public static native @Cast("BOOL") boolean TlsSetValue(
    @Cast("DWORD") int dwTlsIndex,
    @Cast("LPVOID") Pointer lpTlsValue
    );

public static native @Cast("BOOL") boolean TlsFree(
    @Cast("DWORD") int dwTlsIndex
    );

// #endif  /* WINAPI_PARTITION_APP && !WINAPI_PARTITION_DESKTOP */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// #ifndef _APISET_EXPORTS_FILTER

public static native @Cast("BOOL") boolean CreateProcessA(
    @Cast("LPCSTR") BytePointer lpApplicationName,
    @Cast("LPSTR") BytePointer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") BytePointer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessA(
    @Cast("LPCSTR") ByteBuffer lpApplicationName,
    @Cast("LPSTR") ByteBuffer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") ByteBuffer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessA(
    @Cast("LPCSTR") byte[] lpApplicationName,
    @Cast("LPSTR") byte[] lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") byte[] lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessA(
    @Cast("LPCSTR") String lpApplicationName,
    @Cast("LPSTR") BytePointer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") String lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessA(
    @Cast("LPCSTR") BytePointer lpApplicationName,
    @Cast("LPSTR") ByteBuffer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") BytePointer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessA(
    @Cast("LPCSTR") ByteBuffer lpApplicationName,
    @Cast("LPSTR") byte[] lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") ByteBuffer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessA(
    @Cast("LPCSTR") byte[] lpApplicationName,
    @Cast("LPSTR") BytePointer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") byte[] lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessA(
    @Cast("LPCSTR") String lpApplicationName,
    @Cast("LPSTR") ByteBuffer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") String lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessA(
    @Cast("LPCSTR") BytePointer lpApplicationName,
    @Cast("LPSTR") byte[] lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") BytePointer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessA(
    @Cast("LPCSTR") ByteBuffer lpApplicationName,
    @Cast("LPSTR") BytePointer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") ByteBuffer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessA(
    @Cast("LPCSTR") byte[] lpApplicationName,
    @Cast("LPSTR") ByteBuffer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") byte[] lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessA(
    @Cast("LPCSTR") String lpApplicationName,
    @Cast("LPSTR") byte[] lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") String lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );

public static native @Cast("BOOL") boolean CreateProcessW(
    @Cast("LPCWSTR") CharPointer lpApplicationName,
    @Cast("LPWSTR") CharPointer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCWSTR") CharPointer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOW") STARTUPINFOW lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessW(
    @Cast("LPCWSTR") CharBuffer lpApplicationName,
    @Cast("LPWSTR") CharBuffer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCWSTR") CharBuffer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOW") STARTUPINFOW lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessW(
    @Cast("LPCWSTR") char[] lpApplicationName,
    @Cast("LPWSTR") char[] lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCWSTR") char[] lpCurrentDirectory,
    @Cast("LPSTARTUPINFOW") STARTUPINFOW lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // _APISET_EXPORTS_FILTER

public static native @Cast("BOOL") boolean SetProcessShutdownParameters(
    @Cast("DWORD") int dwLevel,
    @Cast("DWORD") int dwFlags
    );


public static native @Cast("DWORD") int GetProcessVersion(
    @Cast("DWORD") int ProcessId
    );


public static native void GetStartupInfoW(
    @Cast("LPSTARTUPINFOW") STARTUPINFOW lpStartupInfo
    );

// #ifdef UNICODE
// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// end_1_0

// #ifndef _APISET_EXPORTS_FILTER

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean CreateProcessAsUserW(
    @Cast("HANDLE") Pointer hToken,
    @Cast("LPCWSTR") CharPointer lpApplicationName,
    @Cast("LPWSTR") CharPointer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCWSTR") CharPointer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOW") STARTUPINFOW lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessAsUserW(
    @Cast("HANDLE") Pointer hToken,
    @Cast("LPCWSTR") CharBuffer lpApplicationName,
    @Cast("LPWSTR") CharBuffer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCWSTR") CharBuffer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOW") STARTUPINFOW lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessAsUserW(
    @Cast("HANDLE") Pointer hToken,
    @Cast("LPCWSTR") char[] lpApplicationName,
    @Cast("LPWSTR") char[] lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCWSTR") char[] lpCurrentDirectory,
    @Cast("LPSTARTUPINFOW") STARTUPINFOW lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );


// #ifdef UNICODE
// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif // _APISET_EXPORTS_FILTER

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean SetThreadToken(
    @Cast("PHANDLE") PointerPointer Thread,
    @Cast("HANDLE") Pointer Token
    );


public static native @Cast("BOOL") boolean OpenProcessToken(
    @Cast("HANDLE") Pointer ProcessHandle,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PHANDLE") PointerPointer TokenHandle
    );


public static native @Cast("BOOL") boolean OpenThreadToken(
    @Cast("HANDLE") Pointer ThreadHandle,
    @Cast("DWORD") int DesiredAccess,
    @Cast("BOOL") boolean OpenAsSelf,
    @Cast("PHANDLE") PointerPointer TokenHandle
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// begin_1_0

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean SetPriorityClass(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("DWORD") int dwPriorityClass
    );


public static native @Cast("BOOL") boolean SetThreadStackGuarantee(
    @Cast("PULONG") long StackSizeInBytes
    );


public static native @Cast("DWORD") int GetPriorityClass(
    @Cast("HANDLE") Pointer hProcess
    );


public static native @Cast("BOOL") boolean ProcessIdToSessionId(
    @Cast("DWORD") int dwProcessId,
    @Cast("DWORD*") IntPointer pSessionId
    );
public static native @Cast("BOOL") boolean ProcessIdToSessionId(
    @Cast("DWORD") int dwProcessId,
    @Cast("DWORD*") IntBuffer pSessionId
    );
public static native @Cast("BOOL") boolean ProcessIdToSessionId(
    @Cast("DWORD") int dwProcessId,
    @Cast("DWORD*") int[] pSessionId
    );




// #if (_WIN32_WINNT >= 0x0501)

public static native @Cast("DWORD") int GetProcessId(
    @Cast("HANDLE") Pointer Process
    );


// #endif // _WIN32_WINNT >= 0x0501


// #if (_WIN32_WINNT >= 0x0502)

public static native @Cast("DWORD") int GetThreadId(
    @Cast("HANDLE") Pointer Thread
    );
// Targeting ..\windows\_PROC_THREAD_ATTRIBUTE_LIST.java



// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion


// #if (_WIN32_WINNT >= 0x0600)

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native void FlushProcessWriteBuffers(
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("DWORD") int GetProcessIdOfThread(
    @Cast("HANDLE") Pointer Thread
    );


public static native @Cast("BOOL") boolean InitializeProcThreadAttributeList(
    _PROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
    @Cast("DWORD") int dwAttributeCount,
    @Cast("DWORD") int dwFlags,
    @Cast("PSIZE_T") SizeTPointer lpSize
    );


public static native void DeleteProcThreadAttributeList(
    _PROC_THREAD_ATTRIBUTE_LIST lpAttributeList
    );


public static final long PROCESS_AFFINITY_ENABLE_AUTO_UPDATE = 0x00000001L;

public static native @Cast("BOOL") boolean SetProcessAffinityUpdateMode(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("DWORD") int dwFlags
    );


public static native @Cast("BOOL") boolean QueryProcessAffinityUpdateMode(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPDWORD") IntPointer lpdwFlags
    );
public static native @Cast("BOOL") boolean QueryProcessAffinityUpdateMode(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPDWORD") IntBuffer lpdwFlags
    );
public static native @Cast("BOOL") boolean QueryProcessAffinityUpdateMode(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPDWORD") int[] lpdwFlags
    );


public static final int PROC_THREAD_ATTRIBUTE_REPLACE_VALUE =     0x00000001;

public static native @Cast("BOOL") boolean UpdateProcThreadAttribute(
    _PROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD_PTR") long Attribute,
    @Cast("PVOID") Pointer lpValue,
    @Cast("SIZE_T") long cbSize,
    @Cast("PVOID") Pointer lpPreviousValue,
    @Cast("PSIZE_T") SizeTPointer lpReturnSize
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif // (_WIN32_WINNT >= 0x0600)

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("HANDLE") Pointer CreateRemoteThreadEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("SIZE_T") long dwStackSize,
    @Cast("LPTHREAD_START_ROUTINE") PTHREAD_START_ROUTINE lpStartAddress,
    @Cast("LPVOID") Pointer lpParameter,
    @Cast("DWORD") int dwCreationFlags,
    _PROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
    @Cast("LPDWORD") IntPointer lpThreadId
    );
public static native @Cast("HANDLE") Pointer CreateRemoteThreadEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("SIZE_T") long dwStackSize,
    @Cast("LPTHREAD_START_ROUTINE") PTHREAD_START_ROUTINE lpStartAddress,
    @Cast("LPVOID") Pointer lpParameter,
    @Cast("DWORD") int dwCreationFlags,
    _PROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
    @Cast("LPDWORD") IntBuffer lpThreadId
    );
public static native @Cast("HANDLE") Pointer CreateRemoteThreadEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("SIZE_T") long dwStackSize,
    @Cast("LPTHREAD_START_ROUTINE") PTHREAD_START_ROUTINE lpStartAddress,
    @Cast("LPVOID") Pointer lpParameter,
    @Cast("DWORD") int dwCreationFlags,
    _PROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
    @Cast("LPDWORD") int[] lpThreadId
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// end_1_0
// begin_1_1


// #if !defined(MIDL_PASS)

// #if (defined(_WIN32_WINNT) && !defined(_CONTRACT_GEN)) || (_APISET_PROCESSTHREADS_VER > 0x0100)

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if (_WIN32_WINNT >= 0x0602)


// #endif

public static native @Cast("BOOL") boolean GetThreadContext(
    @Cast("HANDLE") Pointer hThread,
    @Cast("LPCONTEXT") CONTEXT lpContext
    );


public static native @Cast("BOOL") boolean SetThreadContext(
    @Cast("HANDLE") Pointer hThread,
    @Const CONTEXT lpContext
    );



// #if (_WIN32_WINNT >= 0x0602)


// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif // (defined(_WIN32_WINNT) && !defined(_CONTRACT_GEN)) || (_APISET_PROCESSTHREADS_VER > 0x0100)
// #endif // defined(MIDL_PASS)


// #if (defined(_WIN32_WINNT) && !defined(_CONTRACT_GEN)) || (_APISET_PROCESSTHREADS_VER > 0x0100)

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean FlushInstructionCache(
    @Cast("HANDLE") Pointer hProcess,
    LPCVOID lpBaseAddress,
    @Cast("SIZE_T") long dwSize
    );


public static native @Cast("BOOL") boolean GetThreadTimes(
    @Cast("HANDLE") Pointer hThread,
    @Cast("LPFILETIME") FILETIME lpCreationTime,
    @Cast("LPFILETIME") FILETIME lpExitTime,
    @Cast("LPFILETIME") FILETIME lpKernelTime,
    @Cast("LPFILETIME") FILETIME lpUserTime
    );


public static native @Cast("HANDLE") Pointer OpenProcess(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("DWORD") int dwProcessId
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean IsProcessorFeaturePresent(
    @Cast("DWORD") int ProcessorFeature
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #endif // (defined(_WIN32_WINNT) && !defined(_CONTRACT_GEN)) || (_APISET_PROCESSTHREADS_VER > 0x0100)


// #if ((_WIN32_WINNT >= 0x0501) && !defined(_CONTRACT_GEN)) || (_APISET_PROCESSTHREADS_VER > 0x0100)

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean GetProcessHandleCount(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PDWORD") IntPointer pdwHandleCount
    );
public static native @Cast("BOOL") boolean GetProcessHandleCount(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PDWORD") IntBuffer pdwHandleCount
    );
public static native @Cast("BOOL") boolean GetProcessHandleCount(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PDWORD") int[] pdwHandleCount
    );


// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #endif // ((_WIN32_WINNT >= 0x0501) && !defined(_CONTRACT_GEN)) || (_APISET_PROCESSTHREADS_VER > 0x0100)


// #if ((_WIN32_WINNT >= 0x0502) && !defined(_CONTRACT_GEN)) || (_APISET_PROCESSTHREADS_VER > 0x0100)

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("DWORD") int GetCurrentProcessorNumber(
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif // ((_WIN32_WINNT >= 0x0502) && !defined(_CONTRACT_GEN)) || (_APISET_PROCESSTHREADS_VER > 0x0100)


// #if ((_WIN32_WINNT >= 0x0601) && !defined(_CONTRACT_GEN)) || (_APISET_PROCESSTHREADS_VER > 0x0100)

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean SetThreadIdealProcessorEx(
    @Cast("HANDLE") Pointer hThread,
    @Cast("PPROCESSOR_NUMBER") PROCESSOR_NUMBER lpIdealProcessor,
    @Cast("PPROCESSOR_NUMBER") PROCESSOR_NUMBER lpPreviousIdealProcessor
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean GetThreadIdealProcessorEx(
    @Cast("HANDLE") Pointer hThread,
    @Cast("PPROCESSOR_NUMBER") PROCESSOR_NUMBER lpIdealProcessor
    );


public static native void GetCurrentProcessorNumberEx(
    @Cast("PPROCESSOR_NUMBER") PROCESSOR_NUMBER ProcNumber
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif // ((_WIN32_WINNT >= 0x0601) && !defined(_CONTRACT_GEN)) || (_APISET_PROCESSTHREADS_VER > 0x0100)

// end_1_1
// begin_1_2


// #if !defined(_CONTRACT_GEN) || (_APISET_PROCESSTHREADS_VER >= 0x0102)

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if (_WIN32_WINNT >= _WIN32_WINNT_WINXP)

public static native @Cast("BOOL") boolean GetProcessPriorityBoost(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PBOOL") boolean pDisablePriorityBoost
    );


public static native @Cast("BOOL") boolean SetProcessPriorityBoost(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("BOOL") boolean bDisablePriorityBoost
    );


public static native @Cast("BOOL") boolean GetThreadIOPendingFlag(
    @Cast("HANDLE") Pointer hThread,
    @Cast("PBOOL") boolean lpIOIsPending
    );


public static native @Cast("BOOL") boolean GetSystemTimes(
    @Cast("PFILETIME") FILETIME lpIdleTime,
    @Cast("PFILETIME") FILETIME lpKernelTime,
    @Cast("PFILETIME") FILETIME lpUserTime
    );


// #endif // (_WIN32_WINNT >= _WIN32_WINNT_WINXP)

//
// Thread information classes.
//

/** enum THREAD_INFORMATION_CLASS */
public static final int
    ThreadMemoryPriority = 0,
    ThreadAbsoluteCpuPriority = 1,
    ThreadInformationClassMax = 2;


// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)

// #endif // (_WIN32_WINNT >= _WIN32_WINNT_WIN8)


// #if (_WIN32_WINNT >= _WIN32_WINNT_WINBLUE)


// #endif // (_WIN32_WINNT >= _WIN32_WINNT_WINBLUE)


// #if (_WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD)

public static native @Cast("BOOL") boolean SetProtectedPolicy(
    @Cast("LPCGUID") GUID PolicyGuid,
    @Cast("ULONG_PTR") long PolicyValue,
    @Cast("PULONG_PTR") SizeTPointer OldPolicyValue
    );


public static native @Cast("BOOL") boolean QueryProtectedPolicy(
    @Cast("LPCGUID") GUID PolicyGuid,
    @Cast("PULONG_PTR") SizeTPointer PolicyValue
    );


// #endif // (_WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD)

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif // !defined(_CONTRACT_GEN) || (_APISET_PROCESSTHREADS_VER >= 0x0102)

// end_1_2
// begin_1_0
// begin_1_1
// begin_1_2

// #ifdef __cplusplus
// #endif

// #endif // _PROCESSTHREADSAPI_H_
// end_1_0
// end_1_1
// end_1_2


// Parsed from sysinfoapi.h

 
 
// begin_1_0
// begin_2_0
// begin_2_1
/********************************************************************************
*                                                                               *
* sysinfoapi.h -- ApiSet Contract for api-ms-win-core-sysinfo-l1                *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _SYSINFOAPI_H_
// #define _SYSINFOAPI_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>


// #if (_MSC_VER >= 800)
// #pragma warning(disable:4514)
// #ifndef __WINDOWS_DONT_DISABLE_PRAGMA_PACK_WARNING__
// #pragma warning(disable:4103)
// #endif

// #if _MSC_VER >= 1200
// #pragma warning(push)
// #endif
// #pragma warning(disable:4001)
// #pragma warning(disable:4201)
// #pragma warning(disable:4214)
// #endif

/* APISET_NAME: api-ms-win-core-sysinfo-l1 */

// #ifndef _APISET_SYSINFO_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0102
public static final int _APISET_SYSINFO_VER = 0x0201;
// #elif _APISET_MINWIN_VERSION == 0x0101
// #elif _APISET_MINWIN_VERSION == 0x0100
// #endif
// #endif
// #endif

// #ifndef BUILD_WINDOWS
// #define NOT_BUILD_WINDOWS_DEPRECATE __declspec(deprecated)
// #else   // BUILD_WINDOWS
// #define NOT_BUILD_WINDOWS_DEPRECATE
// #endif  // BUILD_WINDOWS

// #ifdef __cplusplus
// #endif

// end_1_0
// end_2_0
// end_2_1
// begin_1_0
// begin_2_0

// #pragma region Application Family
// Targeting ..\windows\SYSTEM_INFO.java



// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
// #pragma endregion

// end_1_0
// end_2_0
// begin_1_0

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("DWORD") int GetVersion(
    );
// Targeting ..\windows\MEMORYSTATUSEX.java



public static native @Cast("BOOL") boolean GlobalMemoryStatusEx(
    @Cast("LPMEMORYSTATUSEX") MEMORYSTATUSEX lpBuffer
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native void GetSystemTime(
    @Cast("LPSYSTEMTIME") SYSTEMTIME lpSystemTime
    );


public static native void GetSystemTimeAsFileTime(
    @Cast("LPFILETIME") FILETIME lpSystemTimeAsFileTime
    );


public static native void GetLocalTime(
    @Cast("LPSYSTEMTIME") SYSTEMTIME lpSystemTime
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean SetLocalTime(
    @Const SYSTEMTIME lpSystemTime
    );


public static native void GetSystemInfo(
    @Cast("LPSYSTEM_INFO") SYSTEM_INFO lpSystemInfo
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// end_1_0
// begin_1_0

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("DWORD") int GetTickCount(
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)


// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("ULONGLONG") long GetTickCount64(
    );


// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean GetSystemTimeAdjustment(
    @Cast("PDWORD") IntPointer lpTimeAdjustment,
    @Cast("PDWORD") IntPointer lpTimeIncrement,
    @Cast("PBOOL") boolean lpTimeAdjustmentDisabled
    );
public static native @Cast("BOOL") boolean GetSystemTimeAdjustment(
    @Cast("PDWORD") IntBuffer lpTimeAdjustment,
    @Cast("PDWORD") IntBuffer lpTimeIncrement,
    @Cast("PBOOL") boolean lpTimeAdjustmentDisabled
    );
public static native @Cast("BOOL") boolean GetSystemTimeAdjustment(
    @Cast("PDWORD") int[] lpTimeAdjustment,
    @Cast("PDWORD") int[] lpTimeIncrement,
    @Cast("PBOOL") boolean lpTimeAdjustmentDisabled
    );


public static native @Cast("UINT") int GetSystemDirectoryA(
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("UINT") int uSize
    );
public static native @Cast("UINT") int GetSystemDirectoryA(
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("UINT") int uSize
    );
public static native @Cast("UINT") int GetSystemDirectoryA(
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("UINT") int uSize
    );

public static native @Cast("UINT") int GetSystemDirectoryW(
    @Cast("LPWSTR") CharPointer lpBuffer,
    @Cast("UINT") int uSize
    );
public static native @Cast("UINT") int GetSystemDirectoryW(
    @Cast("LPWSTR") CharBuffer lpBuffer,
    @Cast("UINT") int uSize
    );
public static native @Cast("UINT") int GetSystemDirectoryW(
    @Cast("LPWSTR") char[] lpBuffer,
    @Cast("UINT") int uSize
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("UINT") int GetWindowsDirectoryA(
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("UINT") int uSize
    );
public static native @Cast("UINT") int GetWindowsDirectoryA(
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("UINT") int uSize
    );
public static native @Cast("UINT") int GetWindowsDirectoryA(
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("UINT") int uSize
    );

public static native @Cast("UINT") int GetWindowsDirectoryW(
    @Cast("LPWSTR") CharPointer lpBuffer,
    @Cast("UINT") int uSize
    );
public static native @Cast("UINT") int GetWindowsDirectoryW(
    @Cast("LPWSTR") CharBuffer lpBuffer,
    @Cast("UINT") int uSize
    );
public static native @Cast("UINT") int GetWindowsDirectoryW(
    @Cast("LPWSTR") char[] lpBuffer,
    @Cast("UINT") int uSize
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("UINT") int GetSystemWindowsDirectoryA(
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("UINT") int uSize
    );
public static native @Cast("UINT") int GetSystemWindowsDirectoryA(
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("UINT") int uSize
    );
public static native @Cast("UINT") int GetSystemWindowsDirectoryA(
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("UINT") int uSize
    );

public static native @Cast("UINT") int GetSystemWindowsDirectoryW(
    @Cast("LPWSTR") CharPointer lpBuffer,
    @Cast("UINT") int uSize
    );
public static native @Cast("UINT") int GetSystemWindowsDirectoryW(
    @Cast("LPWSTR") CharBuffer lpBuffer,
    @Cast("UINT") int uSize
    );
public static native @Cast("UINT") int GetSystemWindowsDirectoryW(
    @Cast("LPWSTR") char[] lpBuffer,
    @Cast("UINT") int uSize
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// end_1_0
// begin_1_0
// begin_2_0
// begin_2_1

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

/** enum COMPUTER_NAME_FORMAT */
public static final int
    ComputerNameNetBIOS = 0,
    ComputerNameDnsHostname = 1,
    ComputerNameDnsDomain = 2,
    ComputerNameDnsFullyQualified = 3,
    ComputerNamePhysicalNetBIOS = 4,
    ComputerNamePhysicalDnsHostname = 5,
    ComputerNamePhysicalDnsDomain = 6,
    ComputerNamePhysicalDnsFullyQualified = 7,
    ComputerNameMax = 8 ;

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// end_1_0
// end_2_0
// end_2_1
// begin_1_0

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean GetComputerNameExA(
    @Cast("COMPUTER_NAME_FORMAT") int NameType,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("LPDWORD") IntPointer nSize
    );
public static native @Cast("BOOL") boolean GetComputerNameExA(
    @Cast("COMPUTER_NAME_FORMAT") int NameType,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("LPDWORD") IntBuffer nSize
    );
public static native @Cast("BOOL") boolean GetComputerNameExA(
    @Cast("COMPUTER_NAME_FORMAT") int NameType,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("LPDWORD") int[] nSize
    );

public static native @Cast("BOOL") boolean GetComputerNameExW(
    @Cast("COMPUTER_NAME_FORMAT") int NameType,
    @Cast("LPWSTR") CharPointer lpBuffer,
    @Cast("LPDWORD") IntPointer nSize
    );
public static native @Cast("BOOL") boolean GetComputerNameExW(
    @Cast("COMPUTER_NAME_FORMAT") int NameType,
    @Cast("LPWSTR") CharBuffer lpBuffer,
    @Cast("LPDWORD") IntBuffer nSize
    );
public static native @Cast("BOOL") boolean GetComputerNameExW(
    @Cast("COMPUTER_NAME_FORMAT") int NameType,
    @Cast("LPWSTR") char[] lpBuffer,
    @Cast("LPDWORD") int[] nSize
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// end_1_0
// begin_2_0


// #if !defined(_CONTRACT_GEN) || (_APISET_SYSINFO_VER >= 0x0101)

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean SetComputerNameExW(
    @Cast("COMPUTER_NAME_FORMAT") int NameType,
    @Cast("LPCWSTR") CharPointer lpBuffer
    );
public static native @Cast("BOOL") boolean SetComputerNameExW(
    @Cast("COMPUTER_NAME_FORMAT") int NameType,
    @Cast("LPCWSTR") CharBuffer lpBuffer
    );
public static native @Cast("BOOL") boolean SetComputerNameExW(
    @Cast("COMPUTER_NAME_FORMAT") int NameType,
    @Cast("LPCWSTR") char[] lpBuffer
    );


// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean SetSystemTime(
    @Const SYSTEMTIME lpSystemTime
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif // !defined(_CONTRACT_GEN) || (_APISET_SYSINFO_VER > 0x0100)

// end_2_0
// begin_1_0

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean GetVersionExA(
    @Cast("LPOSVERSIONINFOA") OSVERSIONINFOA lpVersionInformation
    );

public static native @Cast("BOOL") boolean GetVersionExW(
    @Cast("LPOSVERSIONINFOW") OSVERSIONINFOW lpVersionInformation
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean GetLogicalProcessorInformation(
    @Cast("PSYSTEM_LOGICAL_PROCESSOR_INFORMATION") SYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer,
    @Cast("PDWORD") IntPointer ReturnedLength
    );
public static native @Cast("BOOL") boolean GetLogicalProcessorInformation(
    @Cast("PSYSTEM_LOGICAL_PROCESSOR_INFORMATION") SYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer,
    @Cast("PDWORD") IntBuffer ReturnedLength
    );
public static native @Cast("BOOL") boolean GetLogicalProcessorInformation(
    @Cast("PSYSTEM_LOGICAL_PROCESSOR_INFORMATION") SYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer,
    @Cast("PDWORD") int[] ReturnedLength
    );



// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

public static native @Cast("BOOL") boolean GetLogicalProcessorInformationEx(
    @Cast("LOGICAL_PROCESSOR_RELATIONSHIP") int RelationshipType,
    @Cast("PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX") SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer,
    @Cast("PDWORD") IntPointer ReturnedLength
    );
public static native @Cast("BOOL") boolean GetLogicalProcessorInformationEx(
    @Cast("LOGICAL_PROCESSOR_RELATIONSHIP") int RelationshipType,
    @Cast("PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX") SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer,
    @Cast("PDWORD") IntBuffer ReturnedLength
    );
public static native @Cast("BOOL") boolean GetLogicalProcessorInformationEx(
    @Cast("LOGICAL_PROCESSOR_RELATIONSHIP") int RelationshipType,
    @Cast("PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX") SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer,
    @Cast("PDWORD") int[] ReturnedLength
    );


// #endif // (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// end_1_0
// begin_2_0


// #if !defined(_CONTRACT_GEN) || (_APISET_SYSINFO_VER >= 0x0101)

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)


// #if (_WIN32_WINNT >= _WIN32_WINNT_WINXP)

public static native void GetNativeSystemInfo(
    @Cast("LPSYSTEM_INFO") SYSTEM_INFO lpSystemInfo
    );


// #endif // (_WIN32_WINNT >= _WIN32_WINNT_WINXP)

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)

public static native @Cast("BOOL") boolean GetProductInfo(
    @Cast("DWORD") int dwOSMajorVersion,
    @Cast("DWORD") int dwOSMinorVersion,
    @Cast("DWORD") int dwSpMajorVersion,
    @Cast("DWORD") int dwSpMinorVersion,
    @Cast("PDWORD") IntPointer pdwReturnedProductType
    );
public static native @Cast("BOOL") boolean GetProductInfo(
    @Cast("DWORD") int dwOSMajorVersion,
    @Cast("DWORD") int dwOSMinorVersion,
    @Cast("DWORD") int dwSpMajorVersion,
    @Cast("DWORD") int dwSpMinorVersion,
    @Cast("PDWORD") IntBuffer pdwReturnedProductType
    );
public static native @Cast("BOOL") boolean GetProductInfo(
    @Cast("DWORD") int dwOSMajorVersion,
    @Cast("DWORD") int dwOSMinorVersion,
    @Cast("DWORD") int dwSpMajorVersion,
    @Cast("DWORD") int dwSpMinorVersion,
    @Cast("PDWORD") int[] pdwReturnedProductType
    );


// #endif // (_WIN32_WINNT >= _WIN32_WINNT_VISTA)


// #if (NTDDI_VERSION >= NTDDI_WIN2K)

public static native @Cast("ULONGLONG") long VerSetConditionMask(
    @Cast("ULONGLONG") long ConditionMask,
    @Cast("ULONG") long TypeMask,
    @Cast("UCHAR") byte Condition
    );


// #endif // (NTDDI_VERSION >= NTDDI_WIN2K)


// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)


// #endif // (_WIN32_WINNT >= _WIN32_WINNT_WIN8)

public static native void GetSystemTimePreciseAsFileTime(
    @Cast("LPFILETIME") FILETIME lpSystemTimeAsFileTime
    );


public static native @Cast("UINT") int EnumSystemFirmwareTables(
    @Cast("DWORD") int FirmwareTableProviderSignature,
    @Cast("PVOID") Pointer pFirmwareTableEnumBuffer,
    @Cast("DWORD") int BufferSize
    );


public static native @Cast("UINT") int GetSystemFirmwareTable(
    @Cast("DWORD") int FirmwareTableProviderSignature,
    @Cast("DWORD") int FirmwareTableID,
    @Cast("PVOID") Pointer pFirmwareTableBuffer,
    @Cast("DWORD") int BufferSize
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif // !defined(_CONTRACT_GEN) || (_APISET_SYSINFO_VER > 0x0100)

// end_2_0
// begin_2_1


// #if !defined(_CONTRACT_GEN) || (_APISET_SYSINFO_VER >= 0x0201)

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean DnsHostnameToComputerNameExW(
    @Cast("LPCWSTR") CharPointer Hostname,
    @Cast("LPWSTR") CharPointer ComputerName,
    @Cast("LPDWORD") IntPointer nSize
    );
public static native @Cast("BOOL") boolean DnsHostnameToComputerNameExW(
    @Cast("LPCWSTR") CharBuffer Hostname,
    @Cast("LPWSTR") CharBuffer ComputerName,
    @Cast("LPDWORD") IntBuffer nSize
    );
public static native @Cast("BOOL") boolean DnsHostnameToComputerNameExW(
    @Cast("LPCWSTR") char[] Hostname,
    @Cast("LPWSTR") char[] ComputerName,
    @Cast("LPDWORD") int[] nSize
    );


public static native @Cast("BOOL") boolean GetPhysicallyInstalledSystemMemory(
    @Cast("PULONGLONG") LongPointer TotalMemoryInKilobytes
    );
public static native @Cast("BOOL") boolean GetPhysicallyInstalledSystemMemory(
    @Cast("PULONGLONG") LongBuffer TotalMemoryInKilobytes
    );
public static native @Cast("BOOL") boolean GetPhysicallyInstalledSystemMemory(
    @Cast("PULONGLONG") long[] TotalMemoryInKilobytes
    );


public static final int SCEX2_ALT_NETBIOS_NAME = 0x00000001;

public static native @Cast("BOOL") boolean SetComputerNameEx2W(
    @Cast("COMPUTER_NAME_FORMAT") int NameType,
    @Cast("DWORD") int Flags,
    @Cast("LPCWSTR") CharPointer lpBuffer
    );
public static native @Cast("BOOL") boolean SetComputerNameEx2W(
    @Cast("COMPUTER_NAME_FORMAT") int NameType,
    @Cast("DWORD") int Flags,
    @Cast("LPCWSTR") CharBuffer lpBuffer
    );
public static native @Cast("BOOL") boolean SetComputerNameEx2W(
    @Cast("COMPUTER_NAME_FORMAT") int NameType,
    @Cast("DWORD") int Flags,
    @Cast("LPCWSTR") char[] lpBuffer
    );


// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean SetSystemTimeAdjustment(
    @Cast("DWORD") int dwTimeAdjustment,
    @Cast("BOOL") boolean bTimeAdjustmentDisabled
    );


public static native @Cast("BOOL") boolean InstallELAMCertificateInfo(
    @Cast("HANDLE") Pointer ELAMFile
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif // !defined(_CONTRACT_GEN) || (_APISET_SYSINFO_VER >= 0x0201)

// end_2_1
// begin_1_0
// begin_2_0
// begin_2_1

// #ifdef __cplusplus
// #endif


// #if (_MSC_VER >= 800)

// #if _MSC_VER >= 1200
// #pragma warning(pop)
// #else
// #pragma warning(default:4001)
// #pragma warning(default:4201)
// #pragma warning(default:4214)
/* Leave 4514 disabled.  It's an unneeded warning anyway. */
// #endif
// #endif

// #endif // _SYSINFOAPI_H_

// end_1_0
// end_2_0
// end_2_1


// Parsed from memoryapi.h

 
// begin_1_0
// begin_1_1
// begin_1_2
/********************************************************************************
*                                                                               *
* memoryapi.h -- ApiSet Contract for api-ms-win-core-memory-l1-1-0              *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _MEMORYAPI_H_
// #define _MEMORYAPI_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-core-memory-l1 */

// #ifndef _APISET_MEMORY_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0102
public static final int _APISET_MEMORY_VER = 0x0102;
// #elif _APISET_MINWIN_VERSION == 0x0101
// #elif _APISET_MINWIN_VERSION == 0x0100
// #endif
// #endif
// #endif


// #ifdef __cplusplus
// #endif

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

//
// Constants
//
public static final int FILE_MAP_WRITE =      SECTION_MAP_WRITE;
public static final int FILE_MAP_READ =       SECTION_MAP_READ;
public static final long FILE_MAP_ALL_ACCESS = SECTION_ALL_ACCESS;

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static final int FILE_MAP_EXECUTE =    SECTION_MAP_EXECUTE_EXPLICIT;    // not included in FILE_MAP_ALL_ACCESS

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static final int FILE_MAP_COPY =       0x00000001;
public static final int FILE_MAP_RESERVE =    0x80000000;

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// end_1_0
// end_1_1
// end_1_2
// begin_1_0

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("LPVOID") Pointer VirtualAlloc(
    @Cast("LPVOID") Pointer lpAddress,
    @Cast("SIZE_T") long dwSize,
    @Cast("DWORD") int flAllocationType,
    @Cast("DWORD") int flProtect
    );


public static native @Cast("BOOL") boolean VirtualFree(
    @Cast("LPVOID") Pointer lpAddress,
    @Cast("SIZE_T") long dwSize,
    @Cast("DWORD") int dwFreeType
    );


public static native @Cast("BOOL") boolean VirtualProtect(
    @Cast("LPVOID") Pointer lpAddress,
    @Cast("SIZE_T") long dwSize,
    @Cast("DWORD") int flNewProtect,
    @Cast("PDWORD") IntPointer lpflOldProtect
    );
public static native @Cast("BOOL") boolean VirtualProtect(
    @Cast("LPVOID") Pointer lpAddress,
    @Cast("SIZE_T") long dwSize,
    @Cast("DWORD") int flNewProtect,
    @Cast("PDWORD") IntBuffer lpflOldProtect
    );
public static native @Cast("BOOL") boolean VirtualProtect(
    @Cast("LPVOID") Pointer lpAddress,
    @Cast("SIZE_T") long dwSize,
    @Cast("DWORD") int flNewProtect,
    @Cast("PDWORD") int[] lpflOldProtect
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("SIZE_T") long VirtualQuery(
    LPCVOID lpAddress,
    @Cast("PMEMORY_BASIC_INFORMATION") MEMORY_BASIC_INFORMATION lpBuffer,
    @Cast("SIZE_T") long dwLength
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("LPVOID") Pointer VirtualAllocEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPVOID") Pointer lpAddress,
    @Cast("SIZE_T") long dwSize,
    @Cast("DWORD") int flAllocationType,
    @Cast("DWORD") int flProtect
    );


public static native @Cast("BOOL") boolean VirtualFreeEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPVOID") Pointer lpAddress,
    @Cast("SIZE_T") long dwSize,
    @Cast("DWORD") int dwFreeType
    );


public static native @Cast("BOOL") boolean VirtualProtectEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPVOID") Pointer lpAddress,
    @Cast("SIZE_T") long dwSize,
    @Cast("DWORD") int flNewProtect,
    @Cast("PDWORD") IntPointer lpflOldProtect
    );
public static native @Cast("BOOL") boolean VirtualProtectEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPVOID") Pointer lpAddress,
    @Cast("SIZE_T") long dwSize,
    @Cast("DWORD") int flNewProtect,
    @Cast("PDWORD") IntBuffer lpflOldProtect
    );
public static native @Cast("BOOL") boolean VirtualProtectEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPVOID") Pointer lpAddress,
    @Cast("SIZE_T") long dwSize,
    @Cast("DWORD") int flNewProtect,
    @Cast("PDWORD") int[] lpflOldProtect
    );


public static native @Cast("SIZE_T") long VirtualQueryEx(
    @Cast("HANDLE") Pointer hProcess,
    LPCVOID lpAddress,
    @Cast("PMEMORY_BASIC_INFORMATION") MEMORY_BASIC_INFORMATION lpBuffer,
    @Cast("SIZE_T") long dwLength
    );


public static native @Cast("BOOL") boolean ReadProcessMemory(
    @Cast("HANDLE") Pointer hProcess,
    LPCVOID lpBaseAddress,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("SIZE_T") long nSize,
    @Cast("SIZE_T*") SizeTPointer lpNumberOfBytesRead
    );


public static native @Cast("BOOL") boolean WriteProcessMemory(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPVOID") Pointer lpBaseAddress,
    LPCVOID lpBuffer,
    @Cast("SIZE_T") long nSize,
    @Cast("SIZE_T*") SizeTPointer lpNumberOfBytesWritten
    );


public static native @Cast("HANDLE") Pointer CreateFileMappingW(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpFileMappingAttributes,
    @Cast("DWORD") int flProtect,
    @Cast("DWORD") int dwMaximumSizeHigh,
    @Cast("DWORD") int dwMaximumSizeLow,
    @Cast("LPCWSTR") CharPointer lpName
    );
public static native @Cast("HANDLE") Pointer CreateFileMappingW(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpFileMappingAttributes,
    @Cast("DWORD") int flProtect,
    @Cast("DWORD") int dwMaximumSizeHigh,
    @Cast("DWORD") int dwMaximumSizeLow,
    @Cast("LPCWSTR") CharBuffer lpName
    );
public static native @Cast("HANDLE") Pointer CreateFileMappingW(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpFileMappingAttributes,
    @Cast("DWORD") int flProtect,
    @Cast("DWORD") int dwMaximumSizeHigh,
    @Cast("DWORD") int dwMaximumSizeLow,
    @Cast("LPCWSTR") char[] lpName
    );


// #ifdef UNICODE
// #endif

public static native @Cast("HANDLE") Pointer OpenFileMappingW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") CharPointer lpName
    );
public static native @Cast("HANDLE") Pointer OpenFileMappingW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") CharBuffer lpName
    );
public static native @Cast("HANDLE") Pointer OpenFileMappingW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") char[] lpName
    );


// #ifdef UNICODE
// #endif

public static native @Cast("LPVOID") Pointer MapViewOfFile(
    @Cast("HANDLE") Pointer hFileMappingObject,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwFileOffsetHigh,
    @Cast("DWORD") int dwFileOffsetLow,
    @Cast("SIZE_T") long dwNumberOfBytesToMap
    );


public static native @Cast("LPVOID") Pointer MapViewOfFileEx(
    @Cast("HANDLE") Pointer hFileMappingObject,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwFileOffsetHigh,
    @Cast("DWORD") int dwFileOffsetLow,
    @Cast("SIZE_T") long dwNumberOfBytesToMap,
    @Cast("LPVOID") Pointer lpBaseAddress
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean FlushViewOfFile(
    LPCVOID lpBaseAddress,
    @Cast("SIZE_T") long dwNumberOfBytesToFlush
    );


public static native @Cast("BOOL") boolean UnmapViewOfFile(
    LPCVOID lpBaseAddress
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// end_1_0
// begin_1_1


// #if !defined(_CONTRACT_GEN) || (_APISET_MEMORY_VER >= 0x0101)

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("SIZE_T") long GetLargePageMinimum(
    );


public static native @Cast("BOOL") boolean GetProcessWorkingSetSizeEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PSIZE_T") SizeTPointer lpMinimumWorkingSetSize,
    @Cast("PSIZE_T") SizeTPointer lpMaximumWorkingSetSize,
    @Cast("PDWORD") IntPointer Flags
    );
public static native @Cast("BOOL") boolean GetProcessWorkingSetSizeEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PSIZE_T") SizeTPointer lpMinimumWorkingSetSize,
    @Cast("PSIZE_T") SizeTPointer lpMaximumWorkingSetSize,
    @Cast("PDWORD") IntBuffer Flags
    );
public static native @Cast("BOOL") boolean GetProcessWorkingSetSizeEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PSIZE_T") SizeTPointer lpMinimumWorkingSetSize,
    @Cast("PSIZE_T") SizeTPointer lpMaximumWorkingSetSize,
    @Cast("PDWORD") int[] Flags
    );


public static native @Cast("BOOL") boolean SetProcessWorkingSetSizeEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("SIZE_T") long dwMinimumWorkingSetSize,
    @Cast("SIZE_T") long dwMaximumWorkingSetSize,
    @Cast("DWORD") int Flags
    );


public static native @Cast("BOOL") boolean VirtualLock(
    @Cast("LPVOID") Pointer lpAddress,
    @Cast("SIZE_T") long dwSize
    );


public static native @Cast("BOOL") boolean VirtualUnlock(
    @Cast("LPVOID") Pointer lpAddress,
    @Cast("SIZE_T") long dwSize
    );


public static native @Cast("UINT") int GetWriteWatch(
    @Cast("DWORD") int dwFlags,
    @Cast("PVOID") Pointer lpBaseAddress,
    @Cast("SIZE_T") long dwRegionSize,
    @Cast("PVOID*") PointerPointer lpAddresses,
    @Cast("ULONG_PTR*") SizeTPointer lpdwCount,
    @Cast("LPDWORD") IntPointer lpdwGranularity
    );
public static native @Cast("UINT") int GetWriteWatch(
    @Cast("DWORD") int dwFlags,
    @Cast("PVOID") Pointer lpBaseAddress,
    @Cast("SIZE_T") long dwRegionSize,
    @Cast("PVOID*") PointerPointer lpAddresses,
    @Cast("ULONG_PTR*") SizeTPointer lpdwCount,
    @Cast("LPDWORD") IntBuffer lpdwGranularity
    );
public static native @Cast("UINT") int GetWriteWatch(
    @Cast("DWORD") int dwFlags,
    @Cast("PVOID") Pointer lpBaseAddress,
    @Cast("SIZE_T") long dwRegionSize,
    @Cast("PVOID*") PointerPointer lpAddresses,
    @Cast("ULONG_PTR*") SizeTPointer lpdwCount,
    @Cast("LPDWORD") int[] lpdwGranularity
    );


public static native @Cast("UINT") int ResetWriteWatch(
    @Cast("LPVOID") Pointer lpBaseAddress,
    @Cast("SIZE_T") long dwRegionSize
    );



// #if (_WIN32_WINNT >= _WIN32_WINNT_WINXP)

/** enum MEMORY_RESOURCE_NOTIFICATION_TYPE */
public static final int
    LowMemoryResourceNotification = 0,
    HighMemoryResourceNotification = 1;

public static native @Cast("HANDLE") Pointer CreateMemoryResourceNotification(
    @Cast("MEMORY_RESOURCE_NOTIFICATION_TYPE") int NotificationType
    );


public static native @Cast("BOOL") boolean QueryMemoryResourceNotification(
    @Cast("HANDLE") Pointer ResourceNotificationHandle,
    @Cast("PBOOL") boolean ResourceState
    );


// #endif // (_WIN32_WINNT >= _WIN32_WINNT_WINXP)


// #if (_WIN32_WINNT >= _WIN32_WINNT_WS03)

// #define FILE_CACHE_FLAGS_DEFINED
public static final int FILE_CACHE_MAX_HARD_ENABLE =      0x00000001;
public static final int FILE_CACHE_MAX_HARD_DISABLE =     0x00000002;
public static final int FILE_CACHE_MIN_HARD_ENABLE =      0x00000004;
public static final int FILE_CACHE_MIN_HARD_DISABLE =     0x00000008;

public static native @Cast("BOOL") boolean GetSystemFileCacheSize(
    @Cast("PSIZE_T") SizeTPointer lpMinimumFileCacheSize,
    @Cast("PSIZE_T") SizeTPointer lpMaximumFileCacheSize,
    @Cast("PDWORD") IntPointer lpFlags
    );
public static native @Cast("BOOL") boolean GetSystemFileCacheSize(
    @Cast("PSIZE_T") SizeTPointer lpMinimumFileCacheSize,
    @Cast("PSIZE_T") SizeTPointer lpMaximumFileCacheSize,
    @Cast("PDWORD") IntBuffer lpFlags
    );
public static native @Cast("BOOL") boolean GetSystemFileCacheSize(
    @Cast("PSIZE_T") SizeTPointer lpMinimumFileCacheSize,
    @Cast("PSIZE_T") SizeTPointer lpMaximumFileCacheSize,
    @Cast("PDWORD") int[] lpFlags
    );


public static native @Cast("BOOL") boolean SetSystemFileCacheSize(
    @Cast("SIZE_T") long MinimumFileCacheSize,
    @Cast("SIZE_T") long MaximumFileCacheSize,
    @Cast("DWORD") int Flags
    );


// #endif // (_WIN32_WINNT >= _WIN32_WINNT_WS03)


// #if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)

public static native @Cast("HANDLE") Pointer CreateFileMappingNumaW(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpFileMappingAttributes,
    @Cast("DWORD") int flProtect,
    @Cast("DWORD") int dwMaximumSizeHigh,
    @Cast("DWORD") int dwMaximumSizeLow,
    @Cast("LPCWSTR") CharPointer lpName,
    @Cast("DWORD") int nndPreferred
    );
public static native @Cast("HANDLE") Pointer CreateFileMappingNumaW(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpFileMappingAttributes,
    @Cast("DWORD") int flProtect,
    @Cast("DWORD") int dwMaximumSizeHigh,
    @Cast("DWORD") int dwMaximumSizeLow,
    @Cast("LPCWSTR") CharBuffer lpName,
    @Cast("DWORD") int nndPreferred
    );
public static native @Cast("HANDLE") Pointer CreateFileMappingNumaW(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpFileMappingAttributes,
    @Cast("DWORD") int flProtect,
    @Cast("DWORD") int dwMaximumSizeHigh,
    @Cast("DWORD") int dwMaximumSizeLow,
    @Cast("LPCWSTR") char[] lpName,
    @Cast("DWORD") int nndPreferred
    );


// #ifdef UNICODE
// #endif

// #endif // (_WIN32_WINNT >= _WIN32_WINNT_VISTA)


// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)


// #endif // (_WIN32_WINNT >= _WIN32_WINNT_WIN8)

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)


// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)


// #endif // (_WIN32_WINNT >= _WIN32_WINNT_WIN8)

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #endif // !defined(_CONTRACT_GEN) || (_APISET_MEMORY_VER >= 0x0101)

// end_1_1
// begin_1_2


// #if !defined(_CONTRACT_GEN) || (_APISET_MEMORY_VER >= 0x0102)

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if (_WIN32_WINNT >= _WIN32_WINNT_WINXP)

public static native @Cast("BOOL") boolean AllocateUserPhysicalPages(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PULONG_PTR") SizeTPointer NumberOfPages,
    @Cast("PULONG_PTR") SizeTPointer PageArray
    );


public static native @Cast("BOOL") boolean FreeUserPhysicalPages(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PULONG_PTR") SizeTPointer NumberOfPages,
    @Cast("PULONG_PTR") SizeTPointer PageArray
    );


public static native @Cast("BOOL") boolean MapUserPhysicalPages(
    @Cast("PVOID") Pointer VirtualAddress,
    @Cast("ULONG_PTR") long NumberOfPages,
    @Cast("PULONG_PTR") SizeTPointer PageArray
    );


// #endif // (_WIN32_WINNT >= _WIN32_WINNT_WINXP)


// #if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)

public static native @Cast("BOOL") boolean AllocateUserPhysicalPagesNuma(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PULONG_PTR") SizeTPointer NumberOfPages,
    @Cast("PULONG_PTR") SizeTPointer PageArray,
    @Cast("DWORD") int nndPreferred
    );


public static native @Cast("LPVOID") Pointer VirtualAllocExNuma(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPVOID") Pointer lpAddress,
    @Cast("SIZE_T") long dwSize,
    @Cast("DWORD") int flAllocationType,
    @Cast("DWORD") int flProtect,
    @Cast("DWORD") int nndPreferred
    );


// #endif // (_WIN32_WINNT >= _WIN32_WINNT_VISTA)


// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)


// #endif // (_WIN32_WINNT >= _WIN32_WINNT_WIN8)

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #endif // !defined(_CONTRACT_GEN) || (_APISET_MEMORY_VER >= 0x0102)

// end_1_2


// #if !defined(_CONTRACT_GEN) || (_APISET_MEMORY_VER >= 0x0102)

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// This API is not actually available in all blue builds since it is part
// of the S14 GDR release, however because there is no new version for GDR
// this is the most accurate version available.  To safely use this API on
// BLUE builds callers will need to use LoadLibrary and GetProcAddress to 
// check for the existance of the API's before calling them.


// #if (_WIN32_WINNT >= _WIN32_WINNT_WINBLUE)

// #endif /* (_WIN32_WINNT >= _WIN32_WINNT_WINBLUE) */

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif // !defined(_CONTRACT_GEN) || (_APISET_MEMORY_VER >= 0x0102)

// begin_1_0
// begin_1_1
// begin_1_2

// #ifdef __cplusplus
// #endif

// #endif // _MEMORYAPI_H_
// end_1_0
// end_1_1
// end_1_2


// Parsed from threadpoollegacyapiset.h

 
/********************************************************************************
*                                                                               *
* threadpoolapi.h -- ApiSet Contract for api-ms-win-core-threadpool-l1          *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _THREADPOOLLEGACYAPISET_H_
// #define _THREADPOOLLEGACYAPISET_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-core-threadpool-legacy-l1 */

// #ifndef _APISET_THREADPOOL_LEGACY_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0101
public static final int _APISET_THREADPOOL_LEGACY_VER = 0x0100;
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

//
// Thread pool API's
//

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean QueueUserWorkItem(
    @Cast("LPTHREAD_START_ROUTINE") PTHREAD_START_ROUTINE Function,
    @Cast("PVOID") Pointer Context,
    @Cast("ULONG") long Flags
    );


public static native @Cast("BOOL") boolean UnregisterWaitEx(
    @Cast("HANDLE") Pointer WaitHandle,
    @Cast("HANDLE") Pointer CompletionEvent
    );


public static native @Cast("HANDLE") Pointer CreateTimerQueue(
    );


public static native @Cast("BOOL") boolean CreateTimerQueueTimer(
    @Cast("PHANDLE") PointerPointer phNewTimer,
    @Cast("HANDLE") Pointer TimerQueue,
    @Cast("WAITORTIMERCALLBACK") WAITORTIMERCALLBACKFUNC Callback,
    @Cast("PVOID") Pointer Parameter,
    @Cast("DWORD") int DueTime,
    @Cast("DWORD") int Period,
    @Cast("ULONG") long Flags
    );


public static native @Cast("BOOL") boolean ChangeTimerQueueTimer(
    @Cast("HANDLE") Pointer TimerQueue,
    @Cast("HANDLE") Pointer Timer,
    @Cast("ULONG") long DueTime,
    @Cast("ULONG") long Period
    );


public static native @Cast("BOOL") boolean DeleteTimerQueueTimer(
    @Cast("HANDLE") Pointer TimerQueue,
    @Cast("HANDLE") Pointer Timer,
    @Cast("HANDLE") Pointer CompletionEvent
    );


public static native @Cast("BOOL") boolean DeleteTimerQueueEx(
    @Cast("HANDLE") Pointer TimerQueue,
    @Cast("HANDLE") Pointer CompletionEvent
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #ifdef __cplusplus
// #endif

// #endif // _THREADPOOLLEGACYAPISET_H_


// Parsed from threadpoolapiset.h

 
 
/********************************************************************************
*                                                                               *
* threadpoolapi.h -- ApiSet Contract for api-ms-win-core-threadpool-l1          *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _THREADPOOLAPISET_H_
// #define _THREADPOOLAPISET_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-core-threadpool-l1 */

// #ifndef _APISET_THREADPOOL_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0101
public static final int _APISET_THREADPOOL_VER = 0x0200;
// #elif _APISET_MINWIN_VERSION <= 0x0100
// #endif
// #endif // _APISET_MINWIN_VERSION
// #endif // _APISET_THREADPOOL_VER

// #ifdef __cplusplus
// #endif

//
// Thread pool API's
//

// #pragma region Desktop Family
// Targeting ..\windows\PTP_WIN32_IO_CALLBACK.java




// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("PTP_POOL") TP_POOL CreateThreadpool(
    @Cast("PVOID") Pointer reserved
    );


public static native void SetThreadpoolThreadMaximum(
    @Cast("PTP_POOL") TP_POOL ptpp,
    @Cast("DWORD") int cthrdMost
    );


public static native @Cast("BOOL") boolean SetThreadpoolThreadMinimum(
    @Cast("PTP_POOL") TP_POOL ptpp,
    @Cast("DWORD") int cthrdMic
    );


public static native @Cast("BOOL") boolean SetThreadpoolStackInformation(
    @Cast("PTP_POOL") TP_POOL ptpp,
    @Cast("PTP_POOL_STACK_INFORMATION") TP_POOL_STACK_INFORMATION ptpsi
    );


public static native @Cast("BOOL") boolean QueryThreadpoolStackInformation(
    @Cast("PTP_POOL") TP_POOL ptpp,
    @Cast("PTP_POOL_STACK_INFORMATION") TP_POOL_STACK_INFORMATION ptpsi
    );


public static native void CloseThreadpool(
    @Cast("PTP_POOL") TP_POOL ptpp
    );


public static native @Cast("PTP_CLEANUP_GROUP") TP_CLEANUP_GROUP CreateThreadpoolCleanupGroup(
    );


public static native void CloseThreadpoolCleanupGroupMembers(
    @Cast("PTP_CLEANUP_GROUP") TP_CLEANUP_GROUP ptpcg,
    @Cast("BOOL") boolean fCancelPendingCallbacks,
    @Cast("PVOID") Pointer pvCleanupContext
    );


public static native void CloseThreadpoolCleanupGroup(
    @Cast("PTP_CLEANUP_GROUP") TP_CLEANUP_GROUP ptpcg
    );


public static native void SetEventWhenCallbackReturns(
    @Cast("PTP_CALLBACK_INSTANCE") TP_CALLBACK_INSTANCE pci,
    @Cast("HANDLE") Pointer evt
    );


public static native void ReleaseSemaphoreWhenCallbackReturns(
    @Cast("PTP_CALLBACK_INSTANCE") TP_CALLBACK_INSTANCE pci,
    @Cast("HANDLE") Pointer sem,
    @Cast("DWORD") int crel
    );


public static native void ReleaseMutexWhenCallbackReturns(
    @Cast("PTP_CALLBACK_INSTANCE") TP_CALLBACK_INSTANCE pci,
    @Cast("HANDLE") Pointer mut
    );


public static native void LeaveCriticalSectionWhenCallbackReturns(
    @Cast("PTP_CALLBACK_INSTANCE") TP_CALLBACK_INSTANCE pci,
    @Cast("PCRITICAL_SECTION") RTL_CRITICAL_SECTION pcs
    );


public static native void FreeLibraryWhenCallbackReturns(
    @Cast("PTP_CALLBACK_INSTANCE") TP_CALLBACK_INSTANCE pci,
    @Cast("HMODULE") Pointer mod
    );


public static native @Cast("BOOL") boolean CallbackMayRunLong(
    @Cast("PTP_CALLBACK_INSTANCE") TP_CALLBACK_INSTANCE pci
    );


public static native void DisassociateCurrentThreadFromCallback(
    @Cast("PTP_CALLBACK_INSTANCE") TP_CALLBACK_INSTANCE pci
    );


public static native @Cast("BOOL") boolean TrySubmitThreadpoolCallback(
    PTP_SIMPLE_CALLBACK pfns,
    @Cast("PVOID") Pointer pv,
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 pcbe
    );


public static native @Cast("PTP_WORK") TP_WORK CreateThreadpoolWork(
    PTP_WORK_CALLBACK pfnwk,
    @Cast("PVOID") Pointer pv,
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 pcbe
    );


public static native void SubmitThreadpoolWork(
    @Cast("PTP_WORK") TP_WORK pwk
    );


public static native void WaitForThreadpoolWorkCallbacks(
    @Cast("PTP_WORK") TP_WORK pwk,
    @Cast("BOOL") boolean fCancelPendingCallbacks
    );


public static native void CloseThreadpoolWork(
    @Cast("PTP_WORK") TP_WORK pwk
    );


public static native @Cast("PTP_TIMER") TP_TIMER CreateThreadpoolTimer(
    PTP_TIMER_CALLBACK pfnti,
    @Cast("PVOID") Pointer pv,
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 pcbe
    );


public static native void SetThreadpoolTimer(
    @Cast("PTP_TIMER") TP_TIMER pti,
    @Cast("PFILETIME") FILETIME pftDueTime,
    @Cast("DWORD") int msPeriod,
    @Cast("DWORD") int msWindowLength
    );


public static native @Cast("BOOL") boolean IsThreadpoolTimerSet(
    @Cast("PTP_TIMER") TP_TIMER pti
    );


public static native void WaitForThreadpoolTimerCallbacks(
    @Cast("PTP_TIMER") TP_TIMER pti,
    @Cast("BOOL") boolean fCancelPendingCallbacks
    );


public static native void CloseThreadpoolTimer(
    @Cast("PTP_TIMER") TP_TIMER pti
    );


public static native @Cast("PTP_WAIT") TP_WAIT CreateThreadpoolWait(
    PTP_WAIT_CALLBACK pfnwa,
    @Cast("PVOID") Pointer pv,
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 pcbe
    );


public static native void SetThreadpoolWait(
    @Cast("PTP_WAIT") TP_WAIT pwa,
    @Cast("HANDLE") Pointer h,
    @Cast("PFILETIME") FILETIME pftTimeout
    );


public static native void WaitForThreadpoolWaitCallbacks(
    @Cast("PTP_WAIT") TP_WAIT pwa,
    @Cast("BOOL") boolean fCancelPendingCallbacks
    );


public static native void CloseThreadpoolWait(
    @Cast("PTP_WAIT") TP_WAIT pwa
    );


public static native @Cast("PTP_IO") TP_IO CreateThreadpoolIo(
    @Cast("HANDLE") Pointer fl,
    PTP_WIN32_IO_CALLBACK pfnio,
    @Cast("PVOID") Pointer pv,
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 pcbe
    );


public static native void StartThreadpoolIo(
    @Cast("PTP_IO") TP_IO pio
    );


public static native void CancelThreadpoolIo(
    @Cast("PTP_IO") TP_IO pio
    );


public static native void WaitForThreadpoolIoCallbacks(
    @Cast("PTP_IO") TP_IO pio,
    @Cast("BOOL") boolean fCancelPendingCallbacks
    );


public static native void CloseThreadpoolIo(
    @Cast("PTP_IO") TP_IO pio
    );



// #if !defined(_CONTRACT_GEN) || (_APISET_THREADPOOL_VER >= 0x0200)

public static native @Cast("BOOL") boolean SetThreadpoolTimerEx(
    @Cast("PTP_TIMER") TP_TIMER pti,
    @Cast("PFILETIME") FILETIME pftDueTime,
    @Cast("DWORD") int msPeriod,
    @Cast("DWORD") int msWindowLength
    );


public static native @Cast("BOOL") boolean SetThreadpoolWaitEx(
    @Cast("PTP_WAIT") TP_WAIT pwa,
    @Cast("HANDLE") Pointer h,
    @Cast("PFILETIME") FILETIME pftTimeout,
    @Cast("PVOID") Pointer Reserved
    );


// #endif // !defined(_CONTRACT_GEN) || (_APISET_THREADPOOL_VER >= 0x0200)


// #endif  // _WIN32_WINNT >= 0x0600

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #ifdef __cplusplus
// #endif

// #endif // _THREADPOOLAPISET_H_


// Parsed from jobapi.h

 
/********************************************************************************
*                                                                               *
* jobapiset.h -- ApiSet Contract for api-ms-win-core-job-l1                     *  
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _JOBAPISET_H_
// #define _JOBAPISET_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-core-job-l1 */

// #ifndef _APISET_JOB_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0100
public static final int _APISET_JOB_VER = 0x0100;
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if (_WIN32_WINNT >= 0x0501)

public static native @Cast("BOOL") boolean IsProcessInJob(
    @Cast("HANDLE") Pointer ProcessHandle,
    @Cast("HANDLE") Pointer JobHandle,
    @Cast("PBOOL") boolean Result
    );


// #endif

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #ifdef __cplusplus
// #endif

// #endif // _JOBAPISET_H_


// Parsed from wow64apiset.h

 
/********************************************************************************
*                                                                               *
* wow64app.h - ApiSet Contract for api-ms-win-core-wow64-l1                     *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _WOW64APISET_H_
// #define _WOW64APISET_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-core-wow64-l1 */

// #ifndef _APISET_WOW64_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0100
public static final int _APISET_WOW64_VER = 0x0100;
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// RC warns because "WINBASE_DECLARE_GET_SYSTEM_WOW64_DIRECTORY" is a bit long.
// #if !defined(RC_INVOKED)


// #if _WIN32_WINNT >= 0x0501 || defined(WINBASE_DECLARE_GET_SYSTEM_WOW64_DIRECTORY)

public static native @Cast("BOOL") boolean Wow64DisableWow64FsRedirection(
    @Cast("PVOID*") PointerPointer OldValue
    );


public static native @Cast("BOOL") boolean Wow64RevertWow64FsRedirection(
    @Cast("PVOID") Pointer OlValue
    );


// #endif // _WIN32_WINNT >= 0x0501

// #endif // !defined(RC_INVOKED)


// #if (_WIN32_WINNT >= 0x0501)

public static native @Cast("BOOL") boolean IsWow64Process(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PBOOL") boolean Wow64Process
    );


// #endif

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #ifdef __cplusplus
// #endif

// #endif // _WOW64APISET_H_


// Parsed from libloaderapi.h

 
 
// begin_1_0
// begin_1_1
/********************************************************************************
*                                                                               *
* libloaderapi.h -- ApiSet Contract for api-ms-win-core-libraryloader-l1        *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _APISETLIBLOADER_
// #define _APISETLIBLOADER_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-core-libraryloader-l1 */

// #ifndef _APISET_LIBLOADER_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0102
public static final int _APISET_LIBLOADER_VER = 0x0200;
// #elif _APISET_MINWIN_VERSION == 0x0101
// #elif _APISET_MINWIN_VERSION <= 0x0100
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static final int FIND_RESOURCE_DIRECTORY_TYPES =       (0x0100);
public static final int FIND_RESOURCE_DIRECTORY_NAMES =       (0x0200);
public static final int FIND_RESOURCE_DIRECTORY_LANGUAGES =   (0x0400);

public static final int RESOURCE_ENUM_LN =               (0x0001);
public static final int RESOURCE_ENUM_MUI =              (0x0002);
public static final int RESOURCE_ENUM_MUI_SYSTEM =       (0x0004);
public static final int RESOURCE_ENUM_VALIDATE =         (0x0008);
public static final int RESOURCE_ENUM_MODULE_EXACT =     (0x0010);

public static final int SUPPORT_LANG_NUMBER =  32;
// Targeting ..\windows\ENUMUILANG.java


// Targeting ..\windows\ENUMRESLANGPROCA.java


// Targeting ..\windows\ENUMRESLANGPROCW.java


// Targeting ..\windows\ENUMRESNAMEPROCA.java


// Targeting ..\windows\ENUMRESNAMEPROCW.java


// Targeting ..\windows\ENUMRESTYPEPROCA.java


// Targeting ..\windows\ENUMRESTYPEPROCW.java


// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #else

// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// end_1_0
// end_1_1
// begin_1_0

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean DisableThreadLibraryCalls(
    @Cast("HMODULE") Pointer hLibModule
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("HRSRC") Pointer FindResourceExW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") CharPointer lpType,
    @Cast("LPCWSTR") CharPointer lpName,
    @Cast("WORD") short wLanguage
    );
public static native @Cast("HRSRC") Pointer FindResourceExW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") CharBuffer lpType,
    @Cast("LPCWSTR") CharBuffer lpName,
    @Cast("WORD") short wLanguage
    );
public static native @Cast("HRSRC") Pointer FindResourceExW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") char[] lpType,
    @Cast("LPCWSTR") char[] lpName,
    @Cast("WORD") short wLanguage
    );


// #ifdef UNICODE
// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)


// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

public static native int FindStringOrdinal(
    @Cast("DWORD") int dwFindStringOrdinalFlags,
    @Cast("LPCWSTR") CharPointer lpStringSource,
    int cchSource,
    @Cast("LPCWSTR") CharPointer lpStringValue,
    int cchValue,
    @Cast("BOOL") boolean bIgnoreCase
    );
public static native int FindStringOrdinal(
    @Cast("DWORD") int dwFindStringOrdinalFlags,
    @Cast("LPCWSTR") CharBuffer lpStringSource,
    int cchSource,
    @Cast("LPCWSTR") CharBuffer lpStringValue,
    int cchValue,
    @Cast("BOOL") boolean bIgnoreCase
    );
public static native int FindStringOrdinal(
    @Cast("DWORD") int dwFindStringOrdinalFlags,
    @Cast("LPCWSTR") char[] lpStringSource,
    int cchSource,
    @Cast("LPCWSTR") char[] lpStringValue,
    int cchValue,
    @Cast("BOOL") boolean bIgnoreCase
    );


// #endif // (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

public static native @Cast("BOOL") boolean FreeLibrary(
    @Cast("HMODULE") Pointer hLibModule
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native void FreeLibraryAndExitThread(
    @Cast("HMODULE") Pointer hLibModule,
    @Cast("DWORD") int dwExitCode
    );


public static native @Cast("BOOL") boolean FreeResource(
    @Cast("HGLOBAL") Pointer hResData
    );


public static native @Cast("DWORD") int GetModuleFileNameA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPSTR") BytePointer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetModuleFileNameA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPSTR") ByteBuffer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetModuleFileNameA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPSTR") byte[] lpFilename,
    @Cast("DWORD") int nSize
    );

public static native @Cast("DWORD") int GetModuleFileNameW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPWSTR") CharPointer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetModuleFileNameW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPWSTR") CharBuffer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetModuleFileNameW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPWSTR") char[] lpFilename,
    @Cast("DWORD") int nSize
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("HMODULE") Pointer GetModuleHandleA(
    @Cast("LPCSTR") BytePointer lpModuleName
    );
public static native @Cast("HMODULE") Pointer GetModuleHandleA(
    @Cast("LPCSTR") ByteBuffer lpModuleName
    );
public static native @Cast("HMODULE") Pointer GetModuleHandleA(
    @Cast("LPCSTR") byte[] lpModuleName
    );
public static native @Cast("HMODULE") Pointer GetModuleHandleA(
    @Cast("LPCSTR") String lpModuleName
    );

public static native @Cast("HMODULE") Pointer GetModuleHandleW(
    @Cast("LPCWSTR") CharPointer lpModuleName
    );
public static native @Cast("HMODULE") Pointer GetModuleHandleW(
    @Cast("LPCWSTR") CharBuffer lpModuleName
    );
public static native @Cast("HMODULE") Pointer GetModuleHandleW(
    @Cast("LPCWSTR") char[] lpModuleName
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE


// #if !defined(RC_INVOKED)

public static final int GET_MODULE_HANDLE_EX_FLAG_PIN =                 (0x00000001);
public static final int GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT =  (0x00000002);
public static final int GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS =        (0x00000004);
// Targeting ..\windows\PGET_MODULE_HANDLE_EXA.java


// Targeting ..\windows\PGET_MODULE_HANDLE_EXW.java


// #ifdef UNICODE
// #define PGET_MODULE_HANDLE_EX  PGET_MODULE_HANDLE_EXW
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean GetModuleHandleExA(
    @Cast("DWORD") int dwFlags,
    @Cast("LPCSTR") BytePointer lpModuleName,
    @Cast("HMODULE*") PointerPointer phModule
    );
public static native @Cast("BOOL") boolean GetModuleHandleExA(
    @Cast("DWORD") int dwFlags,
    @Cast("LPCSTR") ByteBuffer lpModuleName,
    @Cast("HMODULE*") PointerPointer phModule
    );
public static native @Cast("BOOL") boolean GetModuleHandleExA(
    @Cast("DWORD") int dwFlags,
    @Cast("LPCSTR") byte[] lpModuleName,
    @Cast("HMODULE*") PointerPointer phModule
    );
public static native @Cast("BOOL") boolean GetModuleHandleExA(
    @Cast("DWORD") int dwFlags,
    @Cast("LPCSTR") String lpModuleName,
    @Cast("HMODULE*") PointerPointer phModule
    );

public static native @Cast("BOOL") boolean GetModuleHandleExW(
    @Cast("DWORD") int dwFlags,
    @Cast("LPCWSTR") CharPointer lpModuleName,
    @Cast("HMODULE*") PointerPointer phModule
    );
public static native @Cast("BOOL") boolean GetModuleHandleExW(
    @Cast("DWORD") int dwFlags,
    @Cast("LPCWSTR") CharBuffer lpModuleName,
    @Cast("HMODULE*") PointerPointer phModule
    );
public static native @Cast("BOOL") boolean GetModuleHandleExW(
    @Cast("DWORD") int dwFlags,
    @Cast("LPCWSTR") char[] lpModuleName,
    @Cast("HMODULE*") PointerPointer phModule
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native FARPROC GetProcAddress(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") BytePointer lpProcName
    );
public static native FARPROC GetProcAddress(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") ByteBuffer lpProcName
    );
public static native FARPROC GetProcAddress(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") byte[] lpProcName
    );
public static native FARPROC GetProcAddress(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") String lpProcName
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("HMODULE") Pointer LoadLibraryExA(
    @Cast("LPCSTR") BytePointer lpLibFileName,
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("HMODULE") Pointer LoadLibraryExA(
    @Cast("LPCSTR") ByteBuffer lpLibFileName,
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("HMODULE") Pointer LoadLibraryExA(
    @Cast("LPCSTR") byte[] lpLibFileName,
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("HMODULE") Pointer LoadLibraryExA(
    @Cast("LPCSTR") String lpLibFileName,
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwFlags
    );

public static native @Cast("HMODULE") Pointer LoadLibraryExW(
    @Cast("LPCWSTR") CharPointer lpLibFileName,
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("HMODULE") Pointer LoadLibraryExW(
    @Cast("LPCWSTR") CharBuffer lpLibFileName,
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("HMODULE") Pointer LoadLibraryExW(
    @Cast("LPCWSTR") char[] lpLibFileName,
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwFlags
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static final int DONT_RESOLVE_DLL_REFERENCES =         0x00000001;
public static final int LOAD_LIBRARY_AS_DATAFILE =            0x00000002;
// reserved for internal LOAD_PACKAGED_LIBRARY: 0x00000004
public static final int LOAD_WITH_ALTERED_SEARCH_PATH =       0x00000008;
public static final int LOAD_IGNORE_CODE_AUTHZ_LEVEL =        0x00000010;
public static final int LOAD_LIBRARY_AS_IMAGE_RESOURCE =      0x00000020;
public static final int LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE =  0x00000040;
public static final int LOAD_LIBRARY_REQUIRE_SIGNED_TARGET =  0x00000080;
public static final int LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR =    0x00000100;
public static final int LOAD_LIBRARY_SEARCH_APPLICATION_DIR = 0x00000200;
public static final int LOAD_LIBRARY_SEARCH_USER_DIRS =       0x00000400;
public static final int LOAD_LIBRARY_SEARCH_SYSTEM32 =        0x00000800;
public static final int LOAD_LIBRARY_SEARCH_DEFAULT_DIRS =    0x00001000;

public static native @Cast("HGLOBAL") Pointer LoadResource(
    @Cast("HMODULE") Pointer hModule,
    @Cast("HRSRC") Pointer hResInfo
    );


// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// end_1_0

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native int LoadStringA(
    @Cast("HINSTANCE") Pointer hInstance,
    @Cast("UINT") int uID,
    @Cast("LPSTR") BytePointer lpBuffer,
    int cchBufferMax
    );
public static native int LoadStringA(
    @Cast("HINSTANCE") Pointer hInstance,
    @Cast("UINT") int uID,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    int cchBufferMax
    );
public static native int LoadStringA(
    @Cast("HINSTANCE") Pointer hInstance,
    @Cast("UINT") int uID,
    @Cast("LPSTR") byte[] lpBuffer,
    int cchBufferMax
    );

public static native int LoadStringW(
    @Cast("HINSTANCE") Pointer hInstance,
    @Cast("UINT") int uID,
    @Cast("LPWSTR") CharPointer lpBuffer,
    int cchBufferMax
    );
public static native int LoadStringW(
    @Cast("HINSTANCE") Pointer hInstance,
    @Cast("UINT") int uID,
    @Cast("LPWSTR") CharBuffer lpBuffer,
    int cchBufferMax
    );
public static native int LoadStringW(
    @Cast("HINSTANCE") Pointer hInstance,
    @Cast("UINT") int uID,
    @Cast("LPWSTR") char[] lpBuffer,
    int cchBufferMax
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// begin_1_0

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("LPVOID") Pointer LockResource(
    @Cast("HGLOBAL") Pointer hResData
    );


public static native @Cast("DWORD") int SizeofResource(
    @Cast("HMODULE") Pointer hModule,
    @Cast("HRSRC") Pointer hResInfo
    );


// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// end_1_0

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("DLL_DIRECTORY_COOKIE") Pointer AddDllDirectory(
    @Cast("PCWSTR") CharPointer NewDirectory
    );
public static native @Cast("DLL_DIRECTORY_COOKIE") Pointer AddDllDirectory(
    @Cast("PCWSTR") CharBuffer NewDirectory
    );
public static native @Cast("DLL_DIRECTORY_COOKIE") Pointer AddDllDirectory(
    @Cast("PCWSTR") char[] NewDirectory
    );


public static native @Cast("BOOL") boolean RemoveDllDirectory(
    @Cast("DLL_DIRECTORY_COOKIE") Pointer Cookie
    );


public static native @Cast("BOOL") boolean SetDefaultDllDirectories(
    @Cast("DWORD") int DirectoryFlags
    );


// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// begin_1_1


// #if !defined(_CONTRACT_GEN) || (_APISET_LIBLOADER_VER >= 0x0100)

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)

public static native @Cast("BOOL") boolean EnumResourceLanguagesExA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") BytePointer lpType,
    @Cast("LPCSTR") BytePointer lpName,
    ENUMRESLANGPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam,
    @Cast("DWORD") int dwFlags,
    @Cast("LANGID") short LangId
    );
public static native @Cast("BOOL") boolean EnumResourceLanguagesExA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") ByteBuffer lpType,
    @Cast("LPCSTR") ByteBuffer lpName,
    ENUMRESLANGPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam,
    @Cast("DWORD") int dwFlags,
    @Cast("LANGID") short LangId
    );
public static native @Cast("BOOL") boolean EnumResourceLanguagesExA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") byte[] lpType,
    @Cast("LPCSTR") byte[] lpName,
    ENUMRESLANGPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam,
    @Cast("DWORD") int dwFlags,
    @Cast("LANGID") short LangId
    );
public static native @Cast("BOOL") boolean EnumResourceLanguagesExA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") String lpType,
    @Cast("LPCSTR") String lpName,
    ENUMRESLANGPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam,
    @Cast("DWORD") int dwFlags,
    @Cast("LANGID") short LangId
    );

public static native @Cast("BOOL") boolean EnumResourceLanguagesExW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") CharPointer lpType,
    @Cast("LPCWSTR") CharPointer lpName,
    ENUMRESLANGPROCW lpEnumFunc,
    @Cast("LONG_PTR") long lParam,
    @Cast("DWORD") int dwFlags,
    @Cast("LANGID") short LangId
    );
public static native @Cast("BOOL") boolean EnumResourceLanguagesExW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") CharBuffer lpType,
    @Cast("LPCWSTR") CharBuffer lpName,
    ENUMRESLANGPROCW lpEnumFunc,
    @Cast("LONG_PTR") long lParam,
    @Cast("DWORD") int dwFlags,
    @Cast("LANGID") short LangId
    );
public static native @Cast("BOOL") boolean EnumResourceLanguagesExW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") char[] lpType,
    @Cast("LPCWSTR") char[] lpName,
    ENUMRESLANGPROCW lpEnumFunc,
    @Cast("LONG_PTR") long lParam,
    @Cast("DWORD") int dwFlags,
    @Cast("LANGID") short LangId
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean EnumResourceNamesExA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") BytePointer lpType,
    ENUMRESNAMEPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam,
    @Cast("DWORD") int dwFlags,
    @Cast("LANGID") short LangId
    );
public static native @Cast("BOOL") boolean EnumResourceNamesExA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") ByteBuffer lpType,
    ENUMRESNAMEPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam,
    @Cast("DWORD") int dwFlags,
    @Cast("LANGID") short LangId
    );
public static native @Cast("BOOL") boolean EnumResourceNamesExA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") byte[] lpType,
    ENUMRESNAMEPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam,
    @Cast("DWORD") int dwFlags,
    @Cast("LANGID") short LangId
    );
public static native @Cast("BOOL") boolean EnumResourceNamesExA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") String lpType,
    ENUMRESNAMEPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam,
    @Cast("DWORD") int dwFlags,
    @Cast("LANGID") short LangId
    );

public static native @Cast("BOOL") boolean EnumResourceNamesExW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") CharPointer lpType,
    ENUMRESNAMEPROCW lpEnumFunc,
    @Cast("LONG_PTR") long lParam,
    @Cast("DWORD") int dwFlags,
    @Cast("LANGID") short LangId
    );
public static native @Cast("BOOL") boolean EnumResourceNamesExW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") CharBuffer lpType,
    ENUMRESNAMEPROCW lpEnumFunc,
    @Cast("LONG_PTR") long lParam,
    @Cast("DWORD") int dwFlags,
    @Cast("LANGID") short LangId
    );
public static native @Cast("BOOL") boolean EnumResourceNamesExW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") char[] lpType,
    ENUMRESNAMEPROCW lpEnumFunc,
    @Cast("LONG_PTR") long lParam,
    @Cast("DWORD") int dwFlags,
    @Cast("LANGID") short LangId
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean EnumResourceTypesExA(
    @Cast("HMODULE") Pointer hModule,
    ENUMRESTYPEPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam,
    @Cast("DWORD") int dwFlags,
    @Cast("LANGID") short LangId
    );

public static native @Cast("BOOL") boolean EnumResourceTypesExW(
    @Cast("HMODULE") Pointer hModule,
    ENUMRESTYPEPROCW lpEnumFunc,
    @Cast("LONG_PTR") long lParam,
    @Cast("DWORD") int dwFlags,
    @Cast("LANGID") short LangId
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // (_WIN32_WINNT >= _WIN32_WINNT_VISTA)

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #endif // !defined(_CONTRACT_GEN) || (_APISET_LIBLOADER_VER >= 0x0100)

// end_1_1
// begin_1_0
// begin_1_1

// #ifdef __cplusplus
// #endif

// #endif // _APISETLIBLOADER_



// Parsed from securitybaseapi.h

 
 
// begin_1_0
/********************************************************************************
*                                                                               *
* securitybaseapi.h -- ApiSet Contract for api-ms-win-security-base-l1          *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _APISECUREBASE_
// #define _APISECUREBASE_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-security-base-l1 */

// #ifndef _APISET_SECURITYBASE_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION > 0x0100
public static final int _APISET_SECURITYBASE_VER = 0x0200;
// #elif _APISET_MINWIN_VERSION <= 0x0100
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// end_1_0

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// begin_1_0

//
//
// Security APIs
//

public static native @Cast("BOOL") boolean AccessCheck(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET PrivilegeSet,
    @Cast("LPDWORD") IntPointer PrivilegeSetLength,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus
    );
public static native @Cast("BOOL") boolean AccessCheck(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET PrivilegeSet,
    @Cast("LPDWORD") IntBuffer PrivilegeSetLength,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus
    );
public static native @Cast("BOOL") boolean AccessCheck(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET PrivilegeSet,
    @Cast("LPDWORD") int[] PrivilegeSetLength,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus
    );


public static native @Cast("BOOL") boolean AccessCheckAndAuditAlarmW(
    @Cast("LPCWSTR") CharPointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPWSTR") CharPointer ObjectTypeName,
    @Cast("LPWSTR") CharPointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckAndAuditAlarmW(
    @Cast("LPCWSTR") CharBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPWSTR") CharBuffer ObjectTypeName,
    @Cast("LPWSTR") CharBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckAndAuditAlarmW(
    @Cast("LPCWSTR") char[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPWSTR") char[] ObjectTypeName,
    @Cast("LPWSTR") char[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );


// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean AccessCheckByType(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET PrivilegeSet,
    @Cast("LPDWORD") IntPointer PrivilegeSetLength,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus
    );
public static native @Cast("BOOL") boolean AccessCheckByType(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET PrivilegeSet,
    @Cast("LPDWORD") IntBuffer PrivilegeSetLength,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus
    );
public static native @Cast("BOOL") boolean AccessCheckByType(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET PrivilegeSet,
    @Cast("LPDWORD") int[] PrivilegeSetLength,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus
    );


public static native @Cast("BOOL") boolean AccessCheckByTypeResultList(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET PrivilegeSet,
    @Cast("LPDWORD") IntPointer PrivilegeSetLength,
    @Cast("LPDWORD") IntPointer GrantedAccessList,
    @Cast("LPDWORD") IntPointer AccessStatusList
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultList(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET PrivilegeSet,
    @Cast("LPDWORD") IntBuffer PrivilegeSetLength,
    @Cast("LPDWORD") IntBuffer GrantedAccessList,
    @Cast("LPDWORD") IntBuffer AccessStatusList
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultList(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET PrivilegeSet,
    @Cast("LPDWORD") int[] PrivilegeSetLength,
    @Cast("LPDWORD") int[] GrantedAccessList,
    @Cast("LPDWORD") int[] AccessStatusList
    );


public static native @Cast("BOOL") boolean AccessCheckByTypeAndAuditAlarmW(
    @Cast("LPCWSTR") CharPointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCWSTR") CharPointer ObjectTypeName,
    @Cast("LPCWSTR") CharPointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeAndAuditAlarmW(
    @Cast("LPCWSTR") CharBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCWSTR") CharBuffer ObjectTypeName,
    @Cast("LPCWSTR") CharBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeAndAuditAlarmW(
    @Cast("LPCWSTR") char[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCWSTR") char[] ObjectTypeName,
    @Cast("LPCWSTR") char[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );


// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmW(
    @Cast("LPCWSTR") CharPointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCWSTR") CharPointer ObjectTypeName,
    @Cast("LPCWSTR") CharPointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccessList,
    @Cast("LPDWORD") IntPointer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmW(
    @Cast("LPCWSTR") CharBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCWSTR") CharBuffer ObjectTypeName,
    @Cast("LPCWSTR") CharBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccessList,
    @Cast("LPDWORD") IntBuffer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmW(
    @Cast("LPCWSTR") char[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCWSTR") char[] ObjectTypeName,
    @Cast("LPCWSTR") char[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccessList,
    @Cast("LPDWORD") int[] AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );


// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmByHandleW(
    @Cast("LPCWSTR") CharPointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("LPCWSTR") CharPointer ObjectTypeName,
    @Cast("LPCWSTR") CharPointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccessList,
    @Cast("LPDWORD") IntPointer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmByHandleW(
    @Cast("LPCWSTR") CharBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("LPCWSTR") CharBuffer ObjectTypeName,
    @Cast("LPCWSTR") CharBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccessList,
    @Cast("LPDWORD") IntBuffer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmByHandleW(
    @Cast("LPCWSTR") char[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("LPCWSTR") char[] ObjectTypeName,
    @Cast("LPCWSTR") char[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccessList,
    @Cast("LPDWORD") int[] AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );


// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean AddAccessAllowedAce(
    @Cast("PACL") ACL pAcl,
    @Cast("DWORD") int dwAceRevision,
    @Cast("DWORD") int AccessMask,
    @Cast("PSID") Pointer pSid
    );


public static native @Cast("BOOL") boolean AddAccessAllowedAceEx(
    @Cast("PACL") ACL pAcl,
    @Cast("DWORD") int dwAceRevision,
    @Cast("DWORD") int AceFlags,
    @Cast("DWORD") int AccessMask,
    @Cast("PSID") Pointer pSid
    );


public static native @Cast("BOOL") boolean AddAccessAllowedObjectAce(
    @Cast("PACL") ACL pAcl,
    @Cast("DWORD") int dwAceRevision,
    @Cast("DWORD") int AceFlags,
    @Cast("DWORD") int AccessMask,
    GUID ObjectTypeGuid,
    GUID InheritedObjectTypeGuid,
    @Cast("PSID") Pointer pSid
    );


public static native @Cast("BOOL") boolean AddAccessDeniedAce(
    @Cast("PACL") ACL pAcl,
    @Cast("DWORD") int dwAceRevision,
    @Cast("DWORD") int AccessMask,
    @Cast("PSID") Pointer pSid
    );


public static native @Cast("BOOL") boolean AddAccessDeniedAceEx(
    @Cast("PACL") ACL pAcl,
    @Cast("DWORD") int dwAceRevision,
    @Cast("DWORD") int AceFlags,
    @Cast("DWORD") int AccessMask,
    @Cast("PSID") Pointer pSid
    );


public static native @Cast("BOOL") boolean AddAccessDeniedObjectAce(
    @Cast("PACL") ACL pAcl,
    @Cast("DWORD") int dwAceRevision,
    @Cast("DWORD") int AceFlags,
    @Cast("DWORD") int AccessMask,
    GUID ObjectTypeGuid,
    GUID InheritedObjectTypeGuid,
    @Cast("PSID") Pointer pSid
    );


public static native @Cast("BOOL") boolean AddAce(
    @Cast("PACL") ACL pAcl,
    @Cast("DWORD") int dwAceRevision,
    @Cast("DWORD") int dwStartingAceIndex,
    @Cast("LPVOID") Pointer pAceList,
    @Cast("DWORD") int nAceListLength
    );


public static native @Cast("BOOL") boolean AddAuditAccessAce(
    @Cast("PACL") ACL pAcl,
    @Cast("DWORD") int dwAceRevision,
    @Cast("DWORD") int dwAccessMask,
    @Cast("PSID") Pointer pSid,
    @Cast("BOOL") boolean bAuditSuccess,
    @Cast("BOOL") boolean bAuditFailure
    );


public static native @Cast("BOOL") boolean AddAuditAccessAceEx(
    @Cast("PACL") ACL pAcl,
    @Cast("DWORD") int dwAceRevision,
    @Cast("DWORD") int AceFlags,
    @Cast("DWORD") int dwAccessMask,
    @Cast("PSID") Pointer pSid,
    @Cast("BOOL") boolean bAuditSuccess,
    @Cast("BOOL") boolean bAuditFailure
    );


public static native @Cast("BOOL") boolean AddAuditAccessObjectAce(
    @Cast("PACL") ACL pAcl,
    @Cast("DWORD") int dwAceRevision,
    @Cast("DWORD") int AceFlags,
    @Cast("DWORD") int AccessMask,
    GUID ObjectTypeGuid,
    GUID InheritedObjectTypeGuid,
    @Cast("PSID") Pointer pSid,
    @Cast("BOOL") boolean bAuditSuccess,
    @Cast("BOOL") boolean bAuditFailure
    );



// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean AddMandatoryAce(
    @Cast("PACL") ACL pAcl,
    @Cast("DWORD") int dwAceRevision,
    @Cast("DWORD") int AceFlags,
    @Cast("DWORD") int MandatoryPolicy,
    @Cast("PSID") Pointer pLabelSid
    );


// #endif /* _WIN32_WINNT >=  0x0600 */

// end_1_0


// #if ((!defined(_CONTRACT_GEN) && (_WIN32_WINNT >= _WIN32_WINNT_WIN8)) || (_APISET_SECURITYBASE_VER > 0x0100))


// #endif /* ((!defined(_CONTRACT_GEN) && (_WIN32_WINNT >= _WIN32_WINNT_WIN8)) || (_APISET_SECURITYBASE_VER > 0x0100)) */

// begin_1_0

public static native @Cast("BOOL") boolean AdjustTokenGroups(
    @Cast("HANDLE") Pointer TokenHandle,
    @Cast("BOOL") boolean ResetToDefault,
    @Cast("PTOKEN_GROUPS") TOKEN_GROUPS NewState,
    @Cast("DWORD") int BufferLength,
    @Cast("PTOKEN_GROUPS") TOKEN_GROUPS PreviousState,
    @Cast("PDWORD") IntPointer ReturnLength
    );
public static native @Cast("BOOL") boolean AdjustTokenGroups(
    @Cast("HANDLE") Pointer TokenHandle,
    @Cast("BOOL") boolean ResetToDefault,
    @Cast("PTOKEN_GROUPS") TOKEN_GROUPS NewState,
    @Cast("DWORD") int BufferLength,
    @Cast("PTOKEN_GROUPS") TOKEN_GROUPS PreviousState,
    @Cast("PDWORD") IntBuffer ReturnLength
    );
public static native @Cast("BOOL") boolean AdjustTokenGroups(
    @Cast("HANDLE") Pointer TokenHandle,
    @Cast("BOOL") boolean ResetToDefault,
    @Cast("PTOKEN_GROUPS") TOKEN_GROUPS NewState,
    @Cast("DWORD") int BufferLength,
    @Cast("PTOKEN_GROUPS") TOKEN_GROUPS PreviousState,
    @Cast("PDWORD") int[] ReturnLength
    );


public static native @Cast("BOOL") boolean AdjustTokenPrivileges(
    @Cast("HANDLE") Pointer TokenHandle,
    @Cast("BOOL") boolean DisableAllPrivileges,
    @Cast("PTOKEN_PRIVILEGES") TOKEN_PRIVILEGES NewState,
    @Cast("DWORD") int BufferLength,
    @Cast("PTOKEN_PRIVILEGES") TOKEN_PRIVILEGES PreviousState,
    @Cast("PDWORD") IntPointer ReturnLength
    );
public static native @Cast("BOOL") boolean AdjustTokenPrivileges(
    @Cast("HANDLE") Pointer TokenHandle,
    @Cast("BOOL") boolean DisableAllPrivileges,
    @Cast("PTOKEN_PRIVILEGES") TOKEN_PRIVILEGES NewState,
    @Cast("DWORD") int BufferLength,
    @Cast("PTOKEN_PRIVILEGES") TOKEN_PRIVILEGES PreviousState,
    @Cast("PDWORD") IntBuffer ReturnLength
    );
public static native @Cast("BOOL") boolean AdjustTokenPrivileges(
    @Cast("HANDLE") Pointer TokenHandle,
    @Cast("BOOL") boolean DisableAllPrivileges,
    @Cast("PTOKEN_PRIVILEGES") TOKEN_PRIVILEGES NewState,
    @Cast("DWORD") int BufferLength,
    @Cast("PTOKEN_PRIVILEGES") TOKEN_PRIVILEGES PreviousState,
    @Cast("PDWORD") int[] ReturnLength
    );


public static native @Cast("BOOL") boolean AllocateAndInitializeSid(
    @Cast("PSID_IDENTIFIER_AUTHORITY") SID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    @Cast("BYTE") byte nSubAuthorityCount,
    @Cast("DWORD") int nSubAuthority0,
    @Cast("DWORD") int nSubAuthority1,
    @Cast("DWORD") int nSubAuthority2,
    @Cast("DWORD") int nSubAuthority3,
    @Cast("DWORD") int nSubAuthority4,
    @Cast("DWORD") int nSubAuthority5,
    @Cast("DWORD") int nSubAuthority6,
    @Cast("DWORD") int nSubAuthority7,
    @Cast("PSID*") PointerPointer pSid
    );


public static native @Cast("BOOL") boolean AllocateLocallyUniqueId(
    @Cast("PLUID") LongPointer Luid
    );
public static native @Cast("BOOL") boolean AllocateLocallyUniqueId(
    @Cast("PLUID") LongBuffer Luid
    );
public static native @Cast("BOOL") boolean AllocateLocallyUniqueId(
    @Cast("PLUID") long[] Luid
    );


public static native @Cast("BOOL") boolean AreAllAccessesGranted(
    @Cast("DWORD") int GrantedAccess,
    @Cast("DWORD") int DesiredAccess
    );


public static native @Cast("BOOL") boolean AreAnyAccessesGranted(
    @Cast("DWORD") int GrantedAccess,
    @Cast("DWORD") int DesiredAccess
    );


public static native @Cast("BOOL") boolean CheckTokenMembership(
    @Cast("HANDLE") Pointer TokenHandle,
    @Cast("PSID") Pointer SidToCheck,
    @Cast("PBOOL") boolean IsMember
    );


// end_1_0


// #if ((!defined(_CONTRACT_GEN) && (_WIN32_WINNT >= _WIN32_WINNT_WIN8)) || (_APISET_SECURITYBASE_VER > 0x0100))


// #endif /* ((!defined(_CONTRACT_GEN) && (_WIN32_WINNT >= _WIN32_WINNT_WIN8)) || (_APISET_SECURITYBASE_VER > 0x0100)) */

// begin_1_0

public static native @Cast("BOOL") boolean ConvertToAutoInheritPrivateObjectSecurity(
    @Cast("PSECURITY_DESCRIPTOR") Pointer ParentDescriptor,
    @Cast("PSECURITY_DESCRIPTOR") Pointer CurrentSecurityDescriptor,
    @Cast("PSECURITY_DESCRIPTOR*") PointerPointer NewSecurityDescriptor,
    GUID ObjectType,
    @Cast("BOOLEAN") boolean IsDirectoryObject,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping
    );


public static native @Cast("BOOL") boolean CopySid(
    @Cast("DWORD") int nDestinationSidLength,
    @Cast("PSID") Pointer pDestinationSid,
    @Cast("PSID") Pointer pSourceSid
    );


public static native @Cast("BOOL") boolean CreatePrivateObjectSecurity(
    @Cast("PSECURITY_DESCRIPTOR") Pointer ParentDescriptor,
    @Cast("PSECURITY_DESCRIPTOR") Pointer CreatorDescriptor,
    @Cast("PSECURITY_DESCRIPTOR*") PointerPointer NewDescriptor,
    @Cast("BOOL") boolean IsDirectoryObject,
    @Cast("HANDLE") Pointer Token,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping
    );


public static native @Cast("BOOL") boolean CreatePrivateObjectSecurityEx(
    @Cast("PSECURITY_DESCRIPTOR") Pointer ParentDescriptor,
    @Cast("PSECURITY_DESCRIPTOR") Pointer CreatorDescriptor,
    @Cast("PSECURITY_DESCRIPTOR*") PointerPointer NewDescriptor,
    GUID ObjectType,
    @Cast("BOOL") boolean IsContainerObject,
    @Cast("ULONG") long AutoInheritFlags,
    @Cast("HANDLE") Pointer Token,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping
    );


public static native @Cast("BOOL") boolean CreatePrivateObjectSecurityWithMultipleInheritance(
    @Cast("PSECURITY_DESCRIPTOR") Pointer ParentDescriptor,
    @Cast("PSECURITY_DESCRIPTOR") Pointer CreatorDescriptor,
    @Cast("PSECURITY_DESCRIPTOR*") PointerPointer NewDescriptor,
    @Cast("GUID**") PointerPointer ObjectTypes,
    @Cast("ULONG") long GuidCount,
    @Cast("BOOL") boolean IsContainerObject,
    @Cast("ULONG") long AutoInheritFlags,
    @Cast("HANDLE") Pointer Token,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping
    );
public static native @Cast("BOOL") boolean CreatePrivateObjectSecurityWithMultipleInheritance(
    @Cast("PSECURITY_DESCRIPTOR") Pointer ParentDescriptor,
    @Cast("PSECURITY_DESCRIPTOR") Pointer CreatorDescriptor,
    @Cast("PSECURITY_DESCRIPTOR*") PointerPointer NewDescriptor,
    @ByPtrPtr GUID ObjectTypes,
    @Cast("ULONG") long GuidCount,
    @Cast("BOOL") boolean IsContainerObject,
    @Cast("ULONG") long AutoInheritFlags,
    @Cast("HANDLE") Pointer Token,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping
    );


public static native @Cast("BOOL") boolean CreateRestrictedToken(
    @Cast("HANDLE") Pointer ExistingTokenHandle,
    @Cast("DWORD") int Flags,
    @Cast("DWORD") int DisableSidCount,
    @Cast("PSID_AND_ATTRIBUTES") SID_AND_ATTRIBUTES SidsToDisable,
    @Cast("DWORD") int DeletePrivilegeCount,
    @Cast("PLUID_AND_ATTRIBUTES") LUID_AND_ATTRIBUTES PrivilegesToDelete,
    @Cast("DWORD") int RestrictedSidCount,
    @Cast("PSID_AND_ATTRIBUTES") SID_AND_ATTRIBUTES SidsToRestrict,
    @Cast("PHANDLE") PointerPointer NewTokenHandle
    );



// #if (_WIN32_WINNT >= 0x0501)

public static native @Cast("BOOL") boolean CreateWellKnownSid(
    @Cast("WELL_KNOWN_SID_TYPE") int WellKnownSidType,
    @Cast("PSID") Pointer DomainSid,
    @Cast("PSID") Pointer pSid,
    @Cast("DWORD*") IntPointer cbSid
    );
public static native @Cast("BOOL") boolean CreateWellKnownSid(
    @Cast("WELL_KNOWN_SID_TYPE") int WellKnownSidType,
    @Cast("PSID") Pointer DomainSid,
    @Cast("PSID") Pointer pSid,
    @Cast("DWORD*") IntBuffer cbSid
    );
public static native @Cast("BOOL") boolean CreateWellKnownSid(
    @Cast("WELL_KNOWN_SID_TYPE") int WellKnownSidType,
    @Cast("PSID") Pointer DomainSid,
    @Cast("PSID") Pointer pSid,
    @Cast("DWORD*") int[] cbSid
    );


public static native @Cast("BOOL") boolean EqualDomainSid(
    @Cast("PSID") Pointer pSid1,
    @Cast("PSID") Pointer pSid2,
    @Cast("BOOL*") IntPointer pfEqual
    );
public static native @Cast("BOOL") boolean EqualDomainSid(
    @Cast("PSID") Pointer pSid1,
    @Cast("PSID") Pointer pSid2,
    @Cast("BOOL*") IntBuffer pfEqual
    );
public static native @Cast("BOOL") boolean EqualDomainSid(
    @Cast("PSID") Pointer pSid1,
    @Cast("PSID") Pointer pSid2,
    @Cast("BOOL*") int[] pfEqual
    );


// #endif //(_WIN32_WINNT >= 0x0501)

public static native @Cast("BOOL") boolean DeleteAce(
    @Cast("PACL") ACL pAcl,
    @Cast("DWORD") int dwAceIndex
    );


public static native @Cast("BOOL") boolean DestroyPrivateObjectSecurity(
    @Cast("PSECURITY_DESCRIPTOR*") PointerPointer ObjectDescriptor
    );


public static native @Cast("BOOL") boolean DuplicateToken(
    @Cast("HANDLE") Pointer ExistingTokenHandle,
    @Cast("SECURITY_IMPERSONATION_LEVEL") int ImpersonationLevel,
    @Cast("PHANDLE") PointerPointer DuplicateTokenHandle
    );


public static native @Cast("BOOL") boolean DuplicateTokenEx(
    @Cast("HANDLE") Pointer hExistingToken,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpTokenAttributes,
    @Cast("SECURITY_IMPERSONATION_LEVEL") int ImpersonationLevel,
    @Cast("TOKEN_TYPE") int TokenType,
    @Cast("PHANDLE") PointerPointer phNewToken
    );


public static native @Cast("BOOL") boolean EqualPrefixSid(
    @Cast("PSID") Pointer pSid1,
    @Cast("PSID") Pointer pSid2
    );


public static native @Cast("BOOL") boolean EqualSid(
    @Cast("PSID") Pointer pSid1,
    @Cast("PSID") Pointer pSid2
    );


public static native @Cast("BOOL") boolean FindFirstFreeAce(
    @Cast("PACL") ACL pAcl,
    @Cast("LPVOID*") PointerPointer pAce
    );


public static native @Cast("PVOID") Pointer FreeSid(
    @Cast("PSID") Pointer pSid
    );


public static native @Cast("BOOL") boolean GetAce(
    @Cast("PACL") ACL pAcl,
    @Cast("DWORD") int dwAceIndex,
    @Cast("LPVOID*") PointerPointer pAce
    );


public static native @Cast("BOOL") boolean GetAclInformation(
    @Cast("PACL") ACL pAcl,
    @Cast("LPVOID") Pointer pAclInformation,
    @Cast("DWORD") int nAclInformationLength,
    @Cast("ACL_INFORMATION_CLASS") int dwAclInformationClass
    );


public static native @Cast("BOOL") boolean GetFileSecurityW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") IntPointer lpnLengthNeeded
    );
public static native @Cast("BOOL") boolean GetFileSecurityW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") IntBuffer lpnLengthNeeded
    );
public static native @Cast("BOOL") boolean GetFileSecurityW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") int[] lpnLengthNeeded
    );


// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean GetKernelObjectSecurity(
    @Cast("HANDLE") Pointer Handle,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") IntPointer lpnLengthNeeded
    );
public static native @Cast("BOOL") boolean GetKernelObjectSecurity(
    @Cast("HANDLE") Pointer Handle,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") IntBuffer lpnLengthNeeded
    );
public static native @Cast("BOOL") boolean GetKernelObjectSecurity(
    @Cast("HANDLE") Pointer Handle,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") int[] lpnLengthNeeded
    );


public static native @Cast("DWORD") int GetLengthSid(
    @Cast("PSID") Pointer pSid
    );


public static native @Cast("BOOL") boolean GetPrivateObjectSecurity(
    @Cast("PSECURITY_DESCRIPTOR") Pointer ObjectDescriptor,
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer ResultantDescriptor,
    @Cast("DWORD") int DescriptorLength,
    @Cast("PDWORD") IntPointer ReturnLength
    );
public static native @Cast("BOOL") boolean GetPrivateObjectSecurity(
    @Cast("PSECURITY_DESCRIPTOR") Pointer ObjectDescriptor,
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer ResultantDescriptor,
    @Cast("DWORD") int DescriptorLength,
    @Cast("PDWORD") IntBuffer ReturnLength
    );
public static native @Cast("BOOL") boolean GetPrivateObjectSecurity(
    @Cast("PSECURITY_DESCRIPTOR") Pointer ObjectDescriptor,
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer ResultantDescriptor,
    @Cast("DWORD") int DescriptorLength,
    @Cast("PDWORD") int[] ReturnLength
    );


public static native @Cast("BOOL") boolean GetSecurityDescriptorControl(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("PSECURITY_DESCRIPTOR_CONTROL") short pControl,
    @Cast("LPDWORD") IntPointer lpdwRevision
    );
public static native @Cast("BOOL") boolean GetSecurityDescriptorControl(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("PSECURITY_DESCRIPTOR_CONTROL") short pControl,
    @Cast("LPDWORD") IntBuffer lpdwRevision
    );
public static native @Cast("BOOL") boolean GetSecurityDescriptorControl(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("PSECURITY_DESCRIPTOR_CONTROL") short pControl,
    @Cast("LPDWORD") int[] lpdwRevision
    );


public static native @Cast("BOOL") boolean GetSecurityDescriptorDacl(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("LPBOOL") boolean lpbDaclPresent,
    @Cast("PACL*") PointerPointer pDacl,
    @Cast("LPBOOL") boolean lpbDaclDefaulted
    );


public static native @Cast("BOOL") boolean GetSecurityDescriptorGroup(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("PSID*") PointerPointer pGroup,
    @Cast("LPBOOL") boolean lpbGroupDefaulted
    );


public static native @Cast("DWORD") int GetSecurityDescriptorLength(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor
    );


public static native @Cast("BOOL") boolean GetSecurityDescriptorOwner(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("PSID*") PointerPointer pOwner,
    @Cast("LPBOOL") boolean lpbOwnerDefaulted
    );


public static native @Cast("DWORD") int GetSecurityDescriptorRMControl(
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PUCHAR") BytePointer RMControl
    );
public static native @Cast("DWORD") int GetSecurityDescriptorRMControl(
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PUCHAR") ByteBuffer RMControl
    );
public static native @Cast("DWORD") int GetSecurityDescriptorRMControl(
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PUCHAR") byte[] RMControl
    );


public static native @Cast("BOOL") boolean GetSecurityDescriptorSacl(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("LPBOOL") boolean lpbSaclPresent,
    @Cast("PACL*") PointerPointer pSacl,
    @Cast("LPBOOL") boolean lpbSaclDefaulted
    );


public static native @Cast("PSID_IDENTIFIER_AUTHORITY") SID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority(
    @Cast("PSID") Pointer pSid
    );


public static native @Cast("DWORD") int GetSidLengthRequired(
    @Cast("UCHAR") byte nSubAuthorityCount
    );


public static native @Cast("PDWORD") IntPointer GetSidSubAuthority(
    @Cast("PSID") Pointer pSid,
    @Cast("DWORD") int nSubAuthority
    );


public static native @Cast("PUCHAR") BytePointer GetSidSubAuthorityCount(
    @Cast("PSID") Pointer pSid
    );


public static native @Cast("BOOL") boolean GetTokenInformation(
    @Cast("HANDLE") Pointer TokenHandle,
    @Cast("TOKEN_INFORMATION_CLASS") int TokenInformationClass,
    @Cast("LPVOID") Pointer TokenInformation,
    @Cast("DWORD") int TokenInformationLength,
    @Cast("PDWORD") IntPointer ReturnLength
    );
public static native @Cast("BOOL") boolean GetTokenInformation(
    @Cast("HANDLE") Pointer TokenHandle,
    @Cast("TOKEN_INFORMATION_CLASS") int TokenInformationClass,
    @Cast("LPVOID") Pointer TokenInformation,
    @Cast("DWORD") int TokenInformationLength,
    @Cast("PDWORD") IntBuffer ReturnLength
    );
public static native @Cast("BOOL") boolean GetTokenInformation(
    @Cast("HANDLE") Pointer TokenHandle,
    @Cast("TOKEN_INFORMATION_CLASS") int TokenInformationClass,
    @Cast("LPVOID") Pointer TokenInformation,
    @Cast("DWORD") int TokenInformationLength,
    @Cast("PDWORD") int[] ReturnLength
    );



// #if (_WIN32_WINNT >= 0x0501)

public static native @Cast("BOOL") boolean GetWindowsAccountDomainSid(
    @Cast("PSID") Pointer pSid,
    @Cast("PSID") Pointer pDomainSid,
    @Cast("DWORD*") IntPointer cbDomainSid
    );
public static native @Cast("BOOL") boolean GetWindowsAccountDomainSid(
    @Cast("PSID") Pointer pSid,
    @Cast("PSID") Pointer pDomainSid,
    @Cast("DWORD*") IntBuffer cbDomainSid
    );
public static native @Cast("BOOL") boolean GetWindowsAccountDomainSid(
    @Cast("PSID") Pointer pSid,
    @Cast("PSID") Pointer pDomainSid,
    @Cast("DWORD*") int[] cbDomainSid
    );


// #endif //(_WIN32_WINNT >= 0x0501)

public static native @Cast("BOOL") boolean ImpersonateAnonymousToken(
    @Cast("HANDLE") Pointer ThreadHandle
    );


public static native @Cast("BOOL") boolean ImpersonateLoggedOnUser(
    @Cast("HANDLE") Pointer hToken
    );


public static native @Cast("BOOL") boolean ImpersonateSelf(
    @Cast("SECURITY_IMPERSONATION_LEVEL") int ImpersonationLevel
    );


public static native @Cast("BOOL") boolean InitializeAcl(
    @Cast("PACL") ACL pAcl,
    @Cast("DWORD") int nAclLength,
    @Cast("DWORD") int dwAclRevision
    );


public static native @Cast("BOOL") boolean InitializeSecurityDescriptor(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int dwRevision
    );


public static native @Cast("BOOL") boolean InitializeSid(
    @Cast("PSID") Pointer Sid,
    @Cast("PSID_IDENTIFIER_AUTHORITY") SID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    @Cast("BYTE") byte nSubAuthorityCount
    );


public static native @Cast("BOOL") boolean IsTokenRestricted(
    @Cast("HANDLE") Pointer TokenHandle
    );


public static native @Cast("BOOL") boolean IsValidAcl(
    @Cast("PACL") ACL pAcl
    );


public static native @Cast("BOOL") boolean IsValidSecurityDescriptor(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor
    );


public static native @Cast("BOOL") boolean IsValidSid(
    @Cast("PSID") Pointer pSid
    );



// #if (_WIN32_WINNT >= 0x0501)

public static native @Cast("BOOL") boolean IsWellKnownSid(
    @Cast("PSID") Pointer pSid,
    @Cast("WELL_KNOWN_SID_TYPE") int WellKnownSidType
    );


// #endif // (_WIN32_WINNT >= 0x0501)

public static native @Cast("BOOL") boolean MakeAbsoluteSD(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSelfRelativeSecurityDescriptor,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pAbsoluteSecurityDescriptor,
    @Cast("LPDWORD") IntPointer lpdwAbsoluteSecurityDescriptorSize,
    @Cast("PACL") ACL pDacl,
    @Cast("LPDWORD") IntPointer lpdwDaclSize,
    @Cast("PACL") ACL pSacl,
    @Cast("LPDWORD") IntPointer lpdwSaclSize,
    @Cast("PSID") Pointer pOwner,
    @Cast("LPDWORD") IntPointer lpdwOwnerSize,
    @Cast("PSID") Pointer pPrimaryGroup,
    @Cast("LPDWORD") IntPointer lpdwPrimaryGroupSize
    );
public static native @Cast("BOOL") boolean MakeAbsoluteSD(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSelfRelativeSecurityDescriptor,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pAbsoluteSecurityDescriptor,
    @Cast("LPDWORD") IntBuffer lpdwAbsoluteSecurityDescriptorSize,
    @Cast("PACL") ACL pDacl,
    @Cast("LPDWORD") IntBuffer lpdwDaclSize,
    @Cast("PACL") ACL pSacl,
    @Cast("LPDWORD") IntBuffer lpdwSaclSize,
    @Cast("PSID") Pointer pOwner,
    @Cast("LPDWORD") IntBuffer lpdwOwnerSize,
    @Cast("PSID") Pointer pPrimaryGroup,
    @Cast("LPDWORD") IntBuffer lpdwPrimaryGroupSize
    );
public static native @Cast("BOOL") boolean MakeAbsoluteSD(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSelfRelativeSecurityDescriptor,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pAbsoluteSecurityDescriptor,
    @Cast("LPDWORD") int[] lpdwAbsoluteSecurityDescriptorSize,
    @Cast("PACL") ACL pDacl,
    @Cast("LPDWORD") int[] lpdwDaclSize,
    @Cast("PACL") ACL pSacl,
    @Cast("LPDWORD") int[] lpdwSaclSize,
    @Cast("PSID") Pointer pOwner,
    @Cast("LPDWORD") int[] lpdwOwnerSize,
    @Cast("PSID") Pointer pPrimaryGroup,
    @Cast("LPDWORD") int[] lpdwPrimaryGroupSize
    );


public static native @Cast("BOOL") boolean MakeSelfRelativeSD(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pAbsoluteSecurityDescriptor,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSelfRelativeSecurityDescriptor,
    @Cast("LPDWORD") IntPointer lpdwBufferLength
    );
public static native @Cast("BOOL") boolean MakeSelfRelativeSD(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pAbsoluteSecurityDescriptor,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSelfRelativeSecurityDescriptor,
    @Cast("LPDWORD") IntBuffer lpdwBufferLength
    );
public static native @Cast("BOOL") boolean MakeSelfRelativeSD(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pAbsoluteSecurityDescriptor,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSelfRelativeSecurityDescriptor,
    @Cast("LPDWORD") int[] lpdwBufferLength
    );


public static native void MapGenericMask(
    @Cast("PDWORD") IntPointer AccessMask,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping
    );
public static native void MapGenericMask(
    @Cast("PDWORD") IntBuffer AccessMask,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping
    );
public static native void MapGenericMask(
    @Cast("PDWORD") int[] AccessMask,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping
    );


public static native @Cast("BOOL") boolean ObjectCloseAuditAlarmW(
    @Cast("LPCWSTR") CharPointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("BOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectCloseAuditAlarmW(
    @Cast("LPCWSTR") CharBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("BOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectCloseAuditAlarmW(
    @Cast("LPCWSTR") char[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("BOOL") boolean GenerateOnClose
    );


// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean ObjectDeleteAuditAlarmW(
    @Cast("LPCWSTR") CharPointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("BOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectDeleteAuditAlarmW(
    @Cast("LPCWSTR") CharBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("BOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectDeleteAuditAlarmW(
    @Cast("LPCWSTR") char[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("BOOL") boolean GenerateOnClose
    );


// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean ObjectOpenAuditAlarmW(
    @Cast("LPCWSTR") CharPointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPWSTR") CharPointer ObjectTypeName,
    @Cast("LPWSTR") CharPointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("DWORD") int GrantedAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("BOOL") boolean AccessGranted,
    @Cast("LPBOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectOpenAuditAlarmW(
    @Cast("LPCWSTR") CharBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPWSTR") CharBuffer ObjectTypeName,
    @Cast("LPWSTR") CharBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("DWORD") int GrantedAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("BOOL") boolean AccessGranted,
    @Cast("LPBOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectOpenAuditAlarmW(
    @Cast("LPCWSTR") char[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPWSTR") char[] ObjectTypeName,
    @Cast("LPWSTR") char[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("DWORD") int GrantedAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("BOOL") boolean AccessGranted,
    @Cast("LPBOOL") boolean GenerateOnClose
    );


// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean ObjectPrivilegeAuditAlarmW(
    @Cast("LPCWSTR") CharPointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean AccessGranted
    );
public static native @Cast("BOOL") boolean ObjectPrivilegeAuditAlarmW(
    @Cast("LPCWSTR") CharBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean AccessGranted
    );
public static native @Cast("BOOL") boolean ObjectPrivilegeAuditAlarmW(
    @Cast("LPCWSTR") char[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean AccessGranted
    );


// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean PrivilegeCheck(
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET RequiredPrivileges,
    @Cast("LPBOOL") boolean pfResult
    );


public static native @Cast("BOOL") boolean PrivilegedServiceAuditAlarmW(
    @Cast("LPCWSTR") CharPointer SubsystemName,
    @Cast("LPCWSTR") CharPointer ServiceName,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean AccessGranted
    );
public static native @Cast("BOOL") boolean PrivilegedServiceAuditAlarmW(
    @Cast("LPCWSTR") CharBuffer SubsystemName,
    @Cast("LPCWSTR") CharBuffer ServiceName,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean AccessGranted
    );
public static native @Cast("BOOL") boolean PrivilegedServiceAuditAlarmW(
    @Cast("LPCWSTR") char[] SubsystemName,
    @Cast("LPCWSTR") char[] ServiceName,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean AccessGranted
    );


// #ifdef UNICODE
// #endif


// #if (_WIN32_WINNT >= 0x0600)

public static native void QuerySecurityAccessMask(
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("LPDWORD") IntPointer DesiredAccess
    );
public static native void QuerySecurityAccessMask(
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("LPDWORD") IntBuffer DesiredAccess
    );
public static native void QuerySecurityAccessMask(
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("LPDWORD") int[] DesiredAccess
    );


// #endif // (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean RevertToSelf(
    );


public static native @Cast("BOOL") boolean SetAclInformation(
    @Cast("PACL") ACL pAcl,
    @Cast("LPVOID") Pointer pAclInformation,
    @Cast("DWORD") int nAclInformationLength,
    @Cast("ACL_INFORMATION_CLASS") int dwAclInformationClass
    );


public static native @Cast("BOOL") boolean SetFileSecurityW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor
    );
public static native @Cast("BOOL") boolean SetFileSecurityW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor
    );
public static native @Cast("BOOL") boolean SetFileSecurityW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor
    );

// #ifdef UNICODE
// #endif

public static native @Cast("BOOL") boolean SetKernelObjectSecurity(
    @Cast("HANDLE") Pointer Handle,
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor
    );


public static native @Cast("BOOL") boolean SetPrivateObjectSecurity(
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer ModificationDescriptor,
    @Cast("PSECURITY_DESCRIPTOR*") PointerPointer ObjectsSecurityDescriptor,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("HANDLE") Pointer Token
    );


public static native @Cast("BOOL") boolean SetPrivateObjectSecurityEx(
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer ModificationDescriptor,
    @Cast("PSECURITY_DESCRIPTOR*") PointerPointer ObjectsSecurityDescriptor,
    @Cast("ULONG") long AutoInheritFlags,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("HANDLE") Pointer Token
    );



// #if (_WIN32_WINNT >= 0x0600)

public static native void SetSecurityAccessMask(
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("LPDWORD") IntPointer DesiredAccess
    );
public static native void SetSecurityAccessMask(
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("LPDWORD") IntBuffer DesiredAccess
    );
public static native void SetSecurityAccessMask(
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("LPDWORD") int[] DesiredAccess
    );


// #endif // (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean SetSecurityDescriptorControl(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("SECURITY_DESCRIPTOR_CONTROL") short ControlBitsOfInterest,
    @Cast("SECURITY_DESCRIPTOR_CONTROL") short ControlBitsToSet
    );


public static native @Cast("BOOL") boolean SetSecurityDescriptorDacl(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("BOOL") boolean bDaclPresent,
    @Cast("PACL") ACL pDacl,
    @Cast("BOOL") boolean bDaclDefaulted
    );


public static native @Cast("BOOL") boolean SetSecurityDescriptorGroup(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("PSID") Pointer pGroup,
    @Cast("BOOL") boolean bGroupDefaulted
    );


public static native @Cast("BOOL") boolean SetSecurityDescriptorOwner(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("PSID") Pointer pOwner,
    @Cast("BOOL") boolean bOwnerDefaulted
    );


public static native @Cast("DWORD") int SetSecurityDescriptorRMControl(
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PUCHAR") BytePointer RMControl
    );
public static native @Cast("DWORD") int SetSecurityDescriptorRMControl(
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PUCHAR") ByteBuffer RMControl
    );
public static native @Cast("DWORD") int SetSecurityDescriptorRMControl(
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PUCHAR") byte[] RMControl
    );


public static native @Cast("BOOL") boolean SetSecurityDescriptorSacl(
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("BOOL") boolean bSaclPresent,
    @Cast("PACL") ACL pSacl,
    @Cast("BOOL") boolean bSaclDefaulted
    );


public static native @Cast("BOOL") boolean SetTokenInformation(
    @Cast("HANDLE") Pointer TokenHandle,
    @Cast("TOKEN_INFORMATION_CLASS") int TokenInformationClass,
    @Cast("LPVOID") Pointer TokenInformation,
    @Cast("DWORD") int TokenInformationLength
    );


// end_1_0


// #if ((!defined(_CONTRACT_GEN) && (_WIN32_WINNT >= _WIN32_WINNT_WIN8)) || (_APISET_SECURITYBASE_VER > 0x0100))

    
// #endif /* ((!defined(_CONTRACT_GEN) && (_WIN32_WINNT >= _WIN32_WINNT_WIN8)) || (_APISET_SECURITYBASE_VER > 0x0100)) */

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// begin_1_0

// #ifdef __cplusplus
// #endif

// #endif // _APISECUREBASE_
// end_1_0


// Parsed from namespaceapi.h

 
/********************************************************************************
*                                                                               *
* consoleapi.h -- ApiSet Contract for api-ms-win-core-namespace-l1              *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _APISETNAMESPACE_
// #define _APISETNAMESPACE_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-core-namespace-l1 */

// #ifndef _APISET_NAMESPACE_VER
// #ifdef _APISET_MINCORE_VERSION
// #if _APISET_MINCORE_VERSION >= 0x0100
public static final int _APISET_NAMESPACE_VER = 0x0100;
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static final int PRIVATE_NAMESPACE_FLAG_DESTROY =      0x00000001;

public static native @Cast("HANDLE") Pointer CreatePrivateNamespaceW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
    @Cast("LPVOID") Pointer lpBoundaryDescriptor,
    @Cast("LPCWSTR") CharPointer lpAliasPrefix
    );
public static native @Cast("HANDLE") Pointer CreatePrivateNamespaceW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
    @Cast("LPVOID") Pointer lpBoundaryDescriptor,
    @Cast("LPCWSTR") CharBuffer lpAliasPrefix
    );
public static native @Cast("HANDLE") Pointer CreatePrivateNamespaceW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
    @Cast("LPVOID") Pointer lpBoundaryDescriptor,
    @Cast("LPCWSTR") char[] lpAliasPrefix
    );


public static native @Cast("HANDLE") Pointer OpenPrivateNamespaceW(
    @Cast("LPVOID") Pointer lpBoundaryDescriptor,
    @Cast("LPCWSTR") CharPointer lpAliasPrefix
    );
public static native @Cast("HANDLE") Pointer OpenPrivateNamespaceW(
    @Cast("LPVOID") Pointer lpBoundaryDescriptor,
    @Cast("LPCWSTR") CharBuffer lpAliasPrefix
    );
public static native @Cast("HANDLE") Pointer OpenPrivateNamespaceW(
    @Cast("LPVOID") Pointer lpBoundaryDescriptor,
    @Cast("LPCWSTR") char[] lpAliasPrefix
    );


public static native @Cast("BOOLEAN") boolean ClosePrivateNamespace(
    @Cast("HANDLE") Pointer Handle,
    @Cast("ULONG") long Flags
    );


public static native @Cast("HANDLE") Pointer CreateBoundaryDescriptorW(
    @Cast("LPCWSTR") CharPointer Name,
    @Cast("ULONG") long Flags
    );
public static native @Cast("HANDLE") Pointer CreateBoundaryDescriptorW(
    @Cast("LPCWSTR") CharBuffer Name,
    @Cast("ULONG") long Flags
    );
public static native @Cast("HANDLE") Pointer CreateBoundaryDescriptorW(
    @Cast("LPCWSTR") char[] Name,
    @Cast("ULONG") long Flags
    );


public static native @Cast("BOOL") boolean AddSIDToBoundaryDescriptor(
    @Cast("HANDLE*") PointerPointer BoundaryDescriptor,
    @Cast("PSID") Pointer RequiredSid
    );


public static native void DeleteBoundaryDescriptor(
    @Cast("HANDLE") Pointer BoundaryDescriptor
    );


// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #ifdef __cplusplus
// #endif

// #endif // _APISETNAMESPACE_


// Parsed from systemtopologyapi.h

 
/********************************************************************************
*                                                                               *
* consoleapi.h -- ApiSet Contract for api-ms-win-core-systemtopology-l1         *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _SYSTEMTOPOLOGY_H_
// #define _SYSTEMTOPOLOGY_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-core-systemtopology-l1 */

// #ifndef _APISET_SYSTEMTOPOLOGY_VER
// #ifdef _APISET_MINCORE_VERSION
// #if _APISET_MINCORE_VERSION >= 0x0100
public static final int _APISET_SYSTEMTOPOLOGY_VER = 0x0100;
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean GetNumaHighestNodeNumber(
    @Cast("PULONG") long HighestNodeNumber
    );



// #if _WIN32_WINNT >= 0x0601

public static native @Cast("BOOL") boolean GetNumaNodeProcessorMaskEx(
    @Cast("USHORT") short Node,
    @Cast("PGROUP_AFFINITY") GROUP_AFFINITY ProcessorMask
    );


// #endif // (_WIN32_WINNT >=0x0601)

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #ifdef __cplusplus
// #endif

// #endif // _SYSTEMTOPOLOGY_H_


// Parsed from processtopologyapi.h

 
 
/********************************************************************************
*                                                                               *
* processtopologyapi.h -- ApiSet Contract for api-ms-win-core-processtopology-l1 *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _PROCESSTOPOLOGYAPI_H_
// #define _PROCESSTOPOLOGYAPI_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-core-processtopology-l1 */

// #ifndef _APISET_PROCESSTOPOLOGY_VER
// #ifdef _APISET_MINCORE_VERSION
// #if _APISET_MINCORE_VERSION >= 0x0101
public static final int _APISET_PROCESSTOPOLOGY_VER = 0x0200;
// #elif _APISET_MINCORE_VERSION == 0x0100
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if (_WIN32_WINNT >= 0x0601)

public static native @Cast("BOOL") boolean GetProcessGroupAffinity(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PUSHORT") short GroupCount,
    @Cast("PUSHORT") short GroupArray
    );


// #endif // (_WIN32_WINNT >= 0x0601)

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion


// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if (_WIN32_WINNT >= 0x0601)

public static native @Cast("BOOL") boolean GetThreadGroupAffinity(
    @Cast("HANDLE") Pointer hThread,
    @Cast("PGROUP_AFFINITY") GROUP_AFFINITY GroupAffinity
    );


public static native @Cast("BOOL") boolean SetThreadGroupAffinity(
    @Cast("HANDLE") Pointer hThread,
    @Const GROUP_AFFINITY GroupAffinity,
    @Cast("PGROUP_AFFINITY") GROUP_AFFINITY PreviousGroupAffinity
    );


// #endif // (_WIN32_WINNT >= 0x0601)

// #endif // WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// #pragma endregion

// #ifdef __cplusplus
// #endif

// #endif // _PROCESSTOPOLOGYAPI_H_


// Parsed from securityappcontainer.h

 
/********************************************************************************
*                                                                               *
* securityappcontainer.h -- ApiSet Contract for api-ms-win-security-appcontainer-l1 *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _APIAPPCONTAINER_
// #define _APIAPPCONTAINER_

// #include <apiset.h>
// #include <apisetcconv.h>


// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-security-appcontainer-l1 */

// #ifndef _APISET_APPCONTAINER_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0101
public static final int _APISET_APPCONTAINER_VER = 0x0100;
// #endif
// #endif
// #endif

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// #ifdef __cplusplus
// #endif


// #if NTDDI_VERSION >= NTDDI_WIN8


// #endif

// #ifdef __cplusplus
// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif // _APIAPPCONTAINER_


// Parsed from realtimeapiset.h

 
/********************************************************************************
*                                                                               *
* realtimeapi.h -- ApiSet Contract for api-ms-win-core-realtime-l1              *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _APISETREALTIME_
// #define _APISETREALTIME_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>

/* APISET_NAME: api-ms-win-core-realtime-l1 */

// #ifndef _APISET_REALTIME_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION >= 0x0100
public static final int _APISET_REALTIME_VER = 0x0100;
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean QueryThreadCycleTime(
    @Cast("HANDLE") Pointer ThreadHandle,
    @Cast("PULONG64") LongPointer CycleTime
    );
public static native @Cast("BOOL") boolean QueryThreadCycleTime(
    @Cast("HANDLE") Pointer ThreadHandle,
    @Cast("PULONG64") LongBuffer CycleTime
    );
public static native @Cast("BOOL") boolean QueryThreadCycleTime(
    @Cast("HANDLE") Pointer ThreadHandle,
    @Cast("PULONG64") long[] CycleTime
    );


public static native @Cast("BOOL") boolean QueryProcessCycleTime(
    @Cast("HANDLE") Pointer ProcessHandle,
    @Cast("PULONG64") LongPointer CycleTime
    );
public static native @Cast("BOOL") boolean QueryProcessCycleTime(
    @Cast("HANDLE") Pointer ProcessHandle,
    @Cast("PULONG64") LongBuffer CycleTime
    );
public static native @Cast("BOOL") boolean QueryProcessCycleTime(
    @Cast("HANDLE") Pointer ProcessHandle,
    @Cast("PULONG64") long[] CycleTime
    );


public static native @Cast("BOOL") boolean QueryIdleProcessorCycleTime(
    @Cast("PULONG") long BufferLength,
    @Cast("PULONG64") LongPointer ProcessorIdleCycleTime
    );
public static native @Cast("BOOL") boolean QueryIdleProcessorCycleTime(
    @Cast("PULONG") long BufferLength,
    @Cast("PULONG64") LongBuffer ProcessorIdleCycleTime
    );
public static native @Cast("BOOL") boolean QueryIdleProcessorCycleTime(
    @Cast("PULONG") long BufferLength,
    @Cast("PULONG64") long[] ProcessorIdleCycleTime
    );


// #endif


// #if (_WIN32_WINNT >= 0x0601)

public static native @Cast("BOOL") boolean QueryIdleProcessorCycleTimeEx(
    @Cast("USHORT") short Group,
    @Cast("PULONG") long BufferLength,
    @Cast("PULONG64") LongPointer ProcessorIdleCycleTime
    );
public static native @Cast("BOOL") boolean QueryIdleProcessorCycleTimeEx(
    @Cast("USHORT") short Group,
    @Cast("PULONG") long BufferLength,
    @Cast("PULONG64") LongBuffer ProcessorIdleCycleTime
    );
public static native @Cast("BOOL") boolean QueryIdleProcessorCycleTimeEx(
    @Cast("USHORT") short Group,
    @Cast("PULONG") long BufferLength,
    @Cast("PULONG64") long[] ProcessorIdleCycleTime
    );

    
// #endif // (_WIN32_WINNT >= 0x0601)

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)


// #if (_WIN32_WINNT >= 0x0601)

public static native @Cast("BOOL") boolean QueryUnbiasedInterruptTime(
    @Cast("PULONGLONG") LongPointer UnbiasedTime
    );
public static native @Cast("BOOL") boolean QueryUnbiasedInterruptTime(
    @Cast("PULONGLONG") LongBuffer UnbiasedTime
    );
public static native @Cast("BOOL") boolean QueryUnbiasedInterruptTime(
    @Cast("PULONGLONG") long[] UnbiasedTime
    );


// #endif // (_WIN32_WINNT >= 0x0601)

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #ifdef __cplusplus
// #endif

// #endif // _APISETREALTIME_


// Parsed from WinBase.h

// #include <winapifamily.h>

/************************************************************************
*                                                                       *
*   winbase.h -- This module defines the 32-Bit Windows Base APIs       *
*                                                                       *
*   Copyright (c) Microsoft Corp. All rights reserved.                  *
*                                                                       *
************************************************************************/
// #ifndef _WINBASE_
// #define _WINBASE_


// #if defined(_MSC_VER)
// #if _MSC_VER > 1000
// #pragma once
// #endif
// #if _MSC_VER >= 1200
// #pragma warning(push)
// #endif
// #pragma warning(disable:4001) /* nonstandard extension : single line comment */
// #pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union */
// #pragma warning(disable:4214) /* nonstandard extension used : bit field types other then int */
// #endif // defined(_MSC_VER)

// #ifdef _MAC
// #endif //_MAC

// #include <apisetcconv.h>
// #include <minwinbase.h>

//
// APISET contracts
//

// #include <processenv.h>
// #include <fileapi.h>
// #include <debugapi.h>
// #include <utilapiset.h>
// #include <handleapi.h>
// #include <errhandlingapi.h>
// #include <fibersapi.h>
// #include <namedpipeapi.h>
// #include <profileapi.h>
// #include <heapapi.h>
// #include <ioapiset.h>
// #include <synchapi.h>
// #include <interlockedapi.h>
// #include <processthreadsapi.h>
// #include <sysinfoapi.h>
// #include <memoryapi.h>
// #include <threadpoollegacyapiset.h>
// #include <threadpoolapiset.h>
// #include <bemapiset.h>
// #include <jobapi.h>
// #include <wow64apiset.h>
// #include <libloaderapi.h>
// #include <securitybaseapi.h>
// #include <namespaceapi.h>
// #include <systemtopologyapi.h>
// #include <processtopologyapi.h>
// #include <securityappcontainer.h>
// #include <realtimeapiset.h>

// #ifdef __cplusplus
// #endif

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

/*
 * Compatibility macros
 */

// #define DefineHandleTable(w)            ((w),TRUE)
// #define LimitEmsPages(dw)
// #define SetSwapAreaSize(w)              (w)
// #define LockSegment(w)                  GlobalFix((HANDLE)(w))
// #define UnlockSegment(w)                GlobalUnfix((HANDLE)(w))

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// #define GetCurrentTime()                GetTickCount()

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

// #define Yield()

public static final int FILE_BEGIN =           0;
public static final int FILE_CURRENT =         1;
public static final int FILE_END =             2;

public static final int WAIT_FAILED = ((int)0xFFFFFFFF);
public static final long WAIT_OBJECT_0 =       ((STATUS_WAIT_0 ) + 0 );

public static final long WAIT_ABANDONED =         ((STATUS_ABANDONED_WAIT_0 ) + 0 );
public static final long WAIT_ABANDONED_0 =       ((STATUS_ABANDONED_WAIT_0 ) + 0 );

public static final long WAIT_IO_COMPLETION =                  STATUS_USER_APC;

// #define SecureZeroMemory RtlSecureZeroMemory
// #define CaptureStackBackTrace RtlCaptureStackBackTrace

//
// File creation flags must start at the high end since they
// are combined with the attributes
//

//
//  These are flags supported through CreateFile (W7) and CreateFile2 (W8 and beyond)
//

public static final int FILE_FLAG_WRITE_THROUGH =         0x80000000;
public static final int FILE_FLAG_OVERLAPPED =            0x40000000;
public static final int FILE_FLAG_NO_BUFFERING =          0x20000000;
public static final int FILE_FLAG_RANDOM_ACCESS =         0x10000000;
public static final int FILE_FLAG_SEQUENTIAL_SCAN =       0x08000000;
public static final int FILE_FLAG_DELETE_ON_CLOSE =       0x04000000;
public static final int FILE_FLAG_BACKUP_SEMANTICS =      0x02000000;
public static final int FILE_FLAG_POSIX_SEMANTICS =       0x01000000;
public static final int FILE_FLAG_SESSION_AWARE =         0x00800000;
public static final int FILE_FLAG_OPEN_REPARSE_POINT =    0x00200000;
public static final int FILE_FLAG_OPEN_NO_RECALL =        0x00100000;
public static final int FILE_FLAG_FIRST_PIPE_INSTANCE =   0x00080000;

// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)

// #endif



// #if(_WIN32_WINNT >= 0x0400)
//
// Define possible return codes from the CopyFileEx callback routine
//

public static final int PROGRESS_CONTINUE =   0;
public static final int PROGRESS_CANCEL =     1;
public static final int PROGRESS_STOP =       2;
public static final int PROGRESS_QUIET =      3;

//
// Define CopyFileEx callback routine state change values
//

public static final int CALLBACK_CHUNK_FINISHED =         0x00000000;
public static final int CALLBACK_STREAM_SWITCH =          0x00000001;

//
// Define CopyFileEx option flags
//

public static final int COPY_FILE_FAIL_IF_EXISTS =              0x00000001;
public static final int COPY_FILE_RESTARTABLE =                 0x00000002;
public static final int COPY_FILE_OPEN_SOURCE_FOR_WRITE =       0x00000004;
public static final int COPY_FILE_ALLOW_DECRYPTED_DESTINATION = 0x00000008;

//
//  Gap for private copyfile flags
//

// #if (_WIN32_WINNT >= 0x0600)
public static final int COPY_FILE_COPY_SYMLINK =                0x00000800;
public static final int COPY_FILE_NO_BUFFERING =                0x00001000;
// #endif


// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)

// #endif

// #endif /* _WIN32_WINNT >= 0x0400 */

// #if (_WIN32_WINNT >= 0x0500)
//
// Define ReplaceFile option flags
//

public static final int REPLACEFILE_WRITE_THROUGH =       0x00000001;
public static final int REPLACEFILE_IGNORE_MERGE_ERRORS = 0x00000002;

// #if (_WIN32_WINNT >= 0x0600)
public static final int REPLACEFILE_IGNORE_ACL_ERRORS =   0x00000004;
// #endif

// #endif // #if (_WIN32_WINNT >= 0x0500)

//
// Define the NamedPipe definitions
//


//
// Define the dwOpenMode values for CreateNamedPipe
//

public static final int PIPE_ACCESS_INBOUND =         0x00000001;
public static final int PIPE_ACCESS_OUTBOUND =        0x00000002;
public static final int PIPE_ACCESS_DUPLEX =          0x00000003;

//
// Define the Named Pipe End flags for GetNamedPipeInfo
//

public static final int PIPE_CLIENT_END =             0x00000000;
public static final int PIPE_SERVER_END =             0x00000001;

//
// Define the dwPipeMode values for CreateNamedPipe
//

public static final int PIPE_WAIT =                   0x00000000;
public static final int PIPE_NOWAIT =                 0x00000001;
public static final int PIPE_READMODE_BYTE =          0x00000000;
public static final int PIPE_READMODE_MESSAGE =       0x00000002;
public static final int PIPE_TYPE_BYTE =              0x00000000;
public static final int PIPE_TYPE_MESSAGE =           0x00000004;
public static final int PIPE_ACCEPT_REMOTE_CLIENTS =  0x00000000;
public static final int PIPE_REJECT_REMOTE_CLIENTS =  0x00000008;

//
// Define the well known values for CreateNamedPipe nMaxInstances
//

public static final int PIPE_UNLIMITED_INSTANCES =    255;

//
// Define the Security Quality of Service bits to be passed
// into CreateFile
//

public static final int SECURITY_ANONYMOUS =          ( SecurityAnonymous      << 16 );
public static final int SECURITY_IDENTIFICATION =     ( SecurityIdentification << 16 );
public static final int SECURITY_IMPERSONATION =      ( SecurityImpersonation  << 16 );
public static final int SECURITY_DELEGATION =         ( SecurityDelegation     << 16 );

public static final int SECURITY_CONTEXT_TRACKING =  0x00040000;
public static final int SECURITY_EFFECTIVE_ONLY =    0x00080000;

public static final int SECURITY_SQOS_PRESENT =      0x00100000;
public static final int SECURITY_VALID_SQOS_FLAGS =  0x001F0000;
// Targeting ..\windows\PFIBER_START_ROUTINE.java


// Targeting ..\windows\PFIBER_CALLOUT_ROUTINE.java


// #endif /* _WIN32_WINNT >= 0x0400 */

//
// FailFast Exception Flags
//

public static final int FAIL_FAST_GENERATE_EXCEPTION_ADDRESS =    0x1;
public static final int FAIL_FAST_NO_HARD_ERROR_DLG =             0x2;

// #if defined(_X86_)
// #else
// #endif

//
// Serial provider type.
//

public static final int SP_SERIALCOMM =    ((int)0x00000001);

//
// Provider SubTypes
//

public static final int PST_UNSPECIFIED =      ((int)0x00000000);
public static final int PST_RS232 =            ((int)0x00000001);
public static final int PST_PARALLELPORT =     ((int)0x00000002);
public static final int PST_RS422 =            ((int)0x00000003);
public static final int PST_RS423 =            ((int)0x00000004);
public static final int PST_RS449 =            ((int)0x00000005);
public static final int PST_MODEM =            ((int)0x00000006);
public static final int PST_FAX =              ((int)0x00000021);
public static final int PST_SCANNER =          ((int)0x00000022);
public static final int PST_NETWORK_BRIDGE =   ((int)0x00000100);
public static final int PST_LAT =              ((int)0x00000101);
public static final int PST_TCPIP_TELNET =     ((int)0x00000102);
public static final int PST_X25 =              ((int)0x00000103);

//
// Provider capabilities flags.
//

public static final int PCF_DTRDSR =        ((int)0x0001);
public static final int PCF_RTSCTS =        ((int)0x0002);
public static final int PCF_RLSD =          ((int)0x0004);
public static final int PCF_PARITY_CHECK =  ((int)0x0008);
public static final int PCF_XONXOFF =       ((int)0x0010);
public static final int PCF_SETXCHAR =      ((int)0x0020);
public static final int PCF_TOTALTIMEOUTS = ((int)0x0040);
public static final int PCF_INTTIMEOUTS =   ((int)0x0080);
public static final int PCF_SPECIALCHARS =  ((int)0x0100);
public static final int PCF_16BITMODE =     ((int)0x0200);

//
// Comm provider settable parameters.
//

public static final int SP_PARITY =         ((int)0x0001);
public static final int SP_BAUD =           ((int)0x0002);
public static final int SP_DATABITS =       ((int)0x0004);
public static final int SP_STOPBITS =       ((int)0x0008);
public static final int SP_HANDSHAKING =    ((int)0x0010);
public static final int SP_PARITY_CHECK =   ((int)0x0020);
public static final int SP_RLSD =           ((int)0x0040);

//
// Settable baud rates in the provider.
//

public static final int BAUD_075 =          ((int)0x00000001);
public static final int BAUD_110 =          ((int)0x00000002);
public static final int BAUD_134_5 =        ((int)0x00000004);
public static final int BAUD_150 =          ((int)0x00000008);
public static final int BAUD_300 =          ((int)0x00000010);
public static final int BAUD_600 =          ((int)0x00000020);
public static final int BAUD_1200 =         ((int)0x00000040);
public static final int BAUD_1800 =         ((int)0x00000080);
public static final int BAUD_2400 =         ((int)0x00000100);
public static final int BAUD_4800 =         ((int)0x00000200);
public static final int BAUD_7200 =         ((int)0x00000400);
public static final int BAUD_9600 =         ((int)0x00000800);
public static final int BAUD_14400 =        ((int)0x00001000);
public static final int BAUD_19200 =        ((int)0x00002000);
public static final int BAUD_38400 =        ((int)0x00004000);
public static final int BAUD_56K =          ((int)0x00008000);
public static final int BAUD_128K =         ((int)0x00010000);
public static final int BAUD_115200 =       ((int)0x00020000);
public static final int BAUD_57600 =        ((int)0x00040000);
public static final int BAUD_USER =         ((int)0x10000000);

//
// Settable Data Bits
//

public static final int DATABITS_5 =        ((short)0x0001);
public static final int DATABITS_6 =        ((short)0x0002);
public static final int DATABITS_7 =        ((short)0x0004);
public static final int DATABITS_8 =        ((short)0x0008);
public static final int DATABITS_16 =       ((short)0x0010);
public static final int DATABITS_16X =      ((short)0x0020);

//
// Settable Stop and Parity bits.
//

public static final int STOPBITS_10 =       ((short)0x0001);
public static final int STOPBITS_15 =       ((short)0x0002);
public static final int STOPBITS_20 =       ((short)0x0004);
public static final int PARITY_NONE =       ((short)0x0100);
public static final int PARITY_ODD =        ((short)0x0200);
public static final int PARITY_EVEN =       ((short)0x0400);
public static final int PARITY_MARK =       ((short)0x0800);
public static final int PARITY_SPACE =      ((short)0x1000);
// Targeting ..\windows\COMMPROP.java



//
// Set dwProvSpec1 to COMMPROP_INITIALIZED to indicate that wPacketLength
// is valid before a call to GetCommProperties().
//
public static final int COMMPROP_INITIALIZED = ((int)0xE73CF52E);
// Targeting ..\windows\COMSTAT.java



//
// DTR Control Flow Values.
//
public static final int DTR_CONTROL_DISABLE =    0x00;
public static final int DTR_CONTROL_ENABLE =     0x01;
public static final int DTR_CONTROL_HANDSHAKE =  0x02;

//
// RTS Control Flow Values
//
public static final int RTS_CONTROL_DISABLE =    0x00;
public static final int RTS_CONTROL_ENABLE =     0x01;
public static final int RTS_CONTROL_HANDSHAKE =  0x02;
public static final int RTS_CONTROL_TOGGLE =     0x03;
// Targeting ..\windows\DCB.java


// Targeting ..\windows\COMMTIMEOUTS.java


// Targeting ..\windows\COMMCONFIG.java



//
//


// #define FreeModule(hLibModule) FreeLibrary((hLibModule))
// #define MakeProcInstance(lpProc,hInstance) (lpProc)
// #define FreeProcInstance(lpProc) (lpProc)

/* Global Memory Flags */
public static final int GMEM_FIXED =          0x0000;
public static final int GMEM_MOVEABLE =       0x0002;
public static final int GMEM_NOCOMPACT =      0x0010;
public static final int GMEM_NODISCARD =      0x0020;
public static final int GMEM_ZEROINIT =       0x0040;
public static final int GMEM_MODIFY =         0x0080;
public static final int GMEM_DISCARDABLE =    0x0100;
public static final int GMEM_NOT_BANKED =     0x1000;
public static final int GMEM_SHARE =          0x2000;
public static final int GMEM_DDESHARE =       0x2000;
public static final int GMEM_NOTIFY =         0x4000;
public static final int GMEM_LOWER =          GMEM_NOT_BANKED;
public static final int GMEM_VALID_FLAGS =    0x7F72;
public static final int GMEM_INVALID_HANDLE = 0x8000;

public static final int GHND =                (GMEM_MOVEABLE | GMEM_ZEROINIT);
public static final int GPTR =                (GMEM_FIXED | GMEM_ZEROINIT);

// #define GlobalLRUNewest( h )    ((HANDLE)(h))
// #define GlobalLRUOldest( h )    ((HANDLE)(h))
// #define GlobalDiscard( h )      GlobalReAlloc( (h), 0, GMEM_MOVEABLE )

/* Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE) */
public static final int GMEM_DISCARDED =      0x4000;
public static final int GMEM_LOCKCOUNT =      0x00FF;
// Targeting ..\windows\MEMORYSTATUS.java




//
// NUMA values
//
public static final int NUMA_NO_PREFERRED_NODE = ((int) -1);

//
// Process dwCreationFlag values
//

public static final int DEBUG_PROCESS =                     0x00000001;
public static final int DEBUG_ONLY_THIS_PROCESS =           0x00000002;
public static final int CREATE_SUSPENDED =                  0x00000004;
public static final int DETACHED_PROCESS =                  0x00000008;

public static final int CREATE_NEW_CONSOLE =                0x00000010;
public static final int NORMAL_PRIORITY_CLASS =             0x00000020;
public static final int IDLE_PRIORITY_CLASS =               0x00000040;
public static final int HIGH_PRIORITY_CLASS =               0x00000080;

public static final int REALTIME_PRIORITY_CLASS =           0x00000100;
public static final int CREATE_NEW_PROCESS_GROUP =          0x00000200;
public static final int CREATE_UNICODE_ENVIRONMENT =        0x00000400;
public static final int CREATE_SEPARATE_WOW_VDM =           0x00000800;

public static final int CREATE_SHARED_WOW_VDM =             0x00001000;
public static final int CREATE_FORCEDOS =                   0x00002000;
public static final int BELOW_NORMAL_PRIORITY_CLASS =       0x00004000;
public static final int ABOVE_NORMAL_PRIORITY_CLASS =       0x00008000;

public static final int INHERIT_PARENT_AFFINITY =           0x00010000;
public static final int INHERIT_CALLER_PRIORITY =           0x00020000;    // Deprecated
public static final int CREATE_PROTECTED_PROCESS =          0x00040000;
public static final int EXTENDED_STARTUPINFO_PRESENT =      0x00080000;

public static final int PROCESS_MODE_BACKGROUND_BEGIN =     0x00100000;
public static final int PROCESS_MODE_BACKGROUND_END =       0x00200000;

public static final int CREATE_BREAKAWAY_FROM_JOB =         0x01000000;
public static final int CREATE_PRESERVE_CODE_AUTHZ_LEVEL =  0x02000000;
public static final int CREATE_DEFAULT_ERROR_MODE =         0x04000000;
public static final int CREATE_NO_WINDOW =                  0x08000000;

public static final int PROFILE_USER =                      0x10000000;
public static final int PROFILE_KERNEL =                    0x20000000;
public static final int PROFILE_SERVER =                    0x40000000;
public static final int CREATE_IGNORE_SYSTEM_DEFAULT =      0x80000000;

//
// Thread dwCreationFlag values
//

//#define CREATE_SUSPENDED                  0x00000004

public static final int STACK_SIZE_PARAM_IS_A_RESERVATION =   0x00010000;    // Threads only

//
// Priority flags
//

public static final int THREAD_PRIORITY_LOWEST =          THREAD_BASE_PRIORITY_MIN;
public static final int THREAD_PRIORITY_BELOW_NORMAL =    (THREAD_PRIORITY_LOWEST+1);
public static final int THREAD_PRIORITY_NORMAL =          0;
public static final int THREAD_PRIORITY_HIGHEST =         THREAD_BASE_PRIORITY_MAX;
public static final int THREAD_PRIORITY_ABOVE_NORMAL =    (THREAD_PRIORITY_HIGHEST-1);
public static final int THREAD_PRIORITY_ERROR_RETURN =    (MAXLONG);

public static final int THREAD_PRIORITY_TIME_CRITICAL =   THREAD_BASE_PRIORITY_LOWRT;
public static final int THREAD_PRIORITY_IDLE =            THREAD_BASE_PRIORITY_IDLE;

public static final int THREAD_MODE_BACKGROUND_BEGIN =    0x00010000;
public static final int THREAD_MODE_BACKGROUND_END =      0x00020000;

//
// GetFinalPathNameByHandle
//

public static final int VOLUME_NAME_DOS =  0x0;      //default
public static final int VOLUME_NAME_GUID = 0x1;
public static final int VOLUME_NAME_NT =   0x2;
public static final int VOLUME_NAME_NONE = 0x4;

public static final int FILE_NAME_NORMALIZED = 0x0;  //default
public static final int FILE_NAME_OPENED =     0x8;
// Targeting ..\windows\JIT_DEBUG_INFO.java



// #if !defined(MIDL_PASS)
// #endif

public static final int DRIVE_UNKNOWN =     0;
public static final int DRIVE_NO_ROOT_DIR = 1;
public static final int DRIVE_REMOVABLE =   2;
public static final int DRIVE_FIXED =       3;
public static final int DRIVE_REMOTE =      4;
public static final int DRIVE_CDROM =       5;
public static final int DRIVE_RAMDISK =     6;


// #ifndef _MAC
// #define GetFreeSpace(w)                 (0x100000L)
// #else
// #endif


public static final int FILE_TYPE_UNKNOWN =   0x0000;
public static final int FILE_TYPE_DISK =      0x0001;
public static final int FILE_TYPE_CHAR =      0x0002;
public static final int FILE_TYPE_PIPE =      0x0003;
public static final int FILE_TYPE_REMOTE =    0x8000;


public static final int STD_INPUT_HANDLE =    ((int)-10);
public static final int STD_OUTPUT_HANDLE =   ((int)-11);
public static final int STD_ERROR_HANDLE =    ((int)-12);

public static final int NOPARITY =            0;
public static final int ODDPARITY =           1;
public static final int EVENPARITY =          2;
public static final int MARKPARITY =          3;
public static final int SPACEPARITY =         4;

public static final int ONESTOPBIT =          0;
public static final int ONE5STOPBITS =        1;
public static final int TWOSTOPBITS =         2;

public static final int IGNORE =              0;       // Ignore signal
public static final int INFINITE =            0xFFFFFFFF;  // Infinite timeout

//
// Baud rates at which the communication device operates
//

public static final int CBR_110 =             110;
public static final int CBR_300 =             300;
public static final int CBR_600 =             600;
public static final int CBR_1200 =            1200;
public static final int CBR_2400 =            2400;
public static final int CBR_4800 =            4800;
public static final int CBR_9600 =            9600;
public static final int CBR_14400 =           14400;
public static final int CBR_19200 =           19200;
public static final int CBR_38400 =           38400;
public static final int CBR_56000 =           56000;
public static final int CBR_57600 =           57600;
public static final int CBR_115200 =          115200;
public static final int CBR_128000 =          128000;
public static final int CBR_256000 =          256000;

//
// Error Flags
//

public static final int CE_RXOVER =           0x0001;  // Receive Queue overflow
public static final int CE_OVERRUN =          0x0002;  // Receive Overrun Error
public static final int CE_RXPARITY =         0x0004;  // Receive Parity Error
public static final int CE_FRAME =            0x0008;  // Receive Framing error
public static final int CE_BREAK =            0x0010;  // Break Detected
public static final int CE_TXFULL =           0x0100;  // TX Queue is full
public static final int CE_PTO =              0x0200;  // LPTx Timeout
public static final int CE_IOE =              0x0400;  // LPTx I/O Error
public static final int CE_DNS =              0x0800;  // LPTx Device not selected
public static final int CE_OOP =              0x1000;  // LPTx Out-Of-Paper
public static final int CE_MODE =             0x8000;  // Requested mode unsupported

public static final int IE_BADID =            (-1);    // Invalid or unsupported id
public static final int IE_OPEN =             (-2);    // Device Already Open
public static final int IE_NOPEN =            (-3);    // Device Not Open
public static final int IE_MEMORY =           (-4);    // Unable to allocate queues
public static final int IE_DEFAULT =          (-5);    // Error in default parameters
public static final int IE_HARDWARE =         (-10);   // Hardware Not Present
public static final int IE_BYTESIZE =         (-11);   // Illegal Byte Size
public static final int IE_BAUDRATE =         (-12);   // Unsupported BaudRate

//
// Events
//

public static final int EV_RXCHAR =           0x0001;  // Any Character received
public static final int EV_RXFLAG =           0x0002;  // Received certain character
public static final int EV_TXEMPTY =          0x0004;  // Transmitt Queue Empty
public static final int EV_CTS =              0x0008;  // CTS changed state
public static final int EV_DSR =              0x0010;  // DSR changed state
public static final int EV_RLSD =             0x0020;  // RLSD changed state
public static final int EV_BREAK =            0x0040;  // BREAK received
public static final int EV_ERR =              0x0080;  // Line status error occurred
public static final int EV_RING =             0x0100;  // Ring signal detected
public static final int EV_PERR =             0x0200;  // Printer error occured
public static final int EV_RX80FULL =         0x0400;  // Receive buffer is 80 percent full
public static final int EV_EVENT1 =           0x0800;  // Provider specific event 1
public static final int EV_EVENT2 =           0x1000;  // Provider specific event 2

//
// Escape Functions
//

public static final int SETXOFF =             1;       // Simulate XOFF received
public static final int SETXON =              2;       // Simulate XON received
public static final int SETRTS =              3;       // Set RTS high
public static final int CLRRTS =              4;       // Set RTS low
public static final int SETDTR =              5;       // Set DTR high
public static final int CLRDTR =              6;       // Set DTR low
public static final int RESETDEV =            7;       // Reset device if possible
public static final int SETBREAK =            8;       // Set the device break line.
public static final int CLRBREAK =            9;       // Clear the device break line.

//
// PURGE function flags.
//
public static final int PURGE_TXABORT =       0x0001;  // Kill the pending/current writes to the comm port.
public static final int PURGE_RXABORT =       0x0002;  // Kill the pending/current reads to the comm port.
public static final int PURGE_TXCLEAR =       0x0004;  // Kill the transmit queue if there.
public static final int PURGE_RXCLEAR =       0x0008;  // Kill the typeahead buffer if there.

public static final int LPTx =                0x80;    // Set if ID is for LPT device

//
// Modem Status Flags
//
public static final int MS_CTS_ON =           ((int)0x0010);
public static final int MS_DSR_ON =           ((int)0x0020);
public static final int MS_RING_ON =          ((int)0x0040);
public static final int MS_RLSD_ON =          ((int)0x0080);

//
// WaitSoundState() Constants
//

public static final int S_QUEUEEMPTY =        0;
public static final int S_THRESHOLD =         1;
public static final int S_ALLTHRESHOLD =      2;

//
// Accent Modes
//

public static final int S_NORMAL =      0;
public static final int S_LEGATO =      1;
public static final int S_STACCATO =    2;

//
// SetSoundNoise() Sources
//

public static final int S_PERIOD512 =   0;     // Freq = N/512 high pitch, less coarse hiss
public static final int S_PERIOD1024 =  1;     // Freq = N/1024
public static final int S_PERIOD2048 =  2;     // Freq = N/2048 low pitch, more coarse hiss
public static final int S_PERIODVOICE = 3;     // Source is frequency from voice channel (3)
public static final int S_WHITE512 =    4;     // Freq = N/512 high pitch, less coarse hiss
public static final int S_WHITE1024 =   5;     // Freq = N/1024
public static final int S_WHITE2048 =   6;     // Freq = N/2048 low pitch, more coarse hiss
public static final int S_WHITEVOICE =  7;     // Source is frequency from voice channel (3)

public static final int S_SERDVNA =     (-1);  // Device not available
public static final int S_SEROFM =      (-2);  // Out of memory
public static final int S_SERMACT =     (-3);  // Music active
public static final int S_SERQFUL =     (-4);  // Queue full
public static final int S_SERBDNT =     (-5);  // Invalid note
public static final int S_SERDLN =      (-6);  // Invalid note length
public static final int S_SERDCC =      (-7);  // Invalid note count
public static final int S_SERDTP =      (-8);  // Invalid tempo
public static final int S_SERDVL =      (-9);  // Invalid volume
public static final int S_SERDMD =      (-10); // Invalid mode
public static final int S_SERDSH =      (-11); // Invalid shape
public static final int S_SERDPT =      (-12); // Invalid pitch
public static final int S_SERDFQ =      (-13); // Invalid frequency
public static final int S_SERDDR =      (-14); // Invalid duration
public static final int S_SERDSR =      (-15); // Invalid source
public static final int S_SERDST =      (-16); // Invalid state

public static final int NMPWAIT_WAIT_FOREVER =            0xffffffff;
public static final int NMPWAIT_NOWAIT =                  0x00000001;
public static final int NMPWAIT_USE_DEFAULT_WAIT =        0x00000000;

public static final int FS_CASE_IS_PRESERVED =            FILE_CASE_PRESERVED_NAMES;
public static final int FS_CASE_SENSITIVE =               FILE_CASE_SENSITIVE_SEARCH;
public static final int FS_UNICODE_STORED_ON_DISK =       FILE_UNICODE_ON_DISK;
public static final int FS_PERSISTENT_ACLS =              FILE_PERSISTENT_ACLS;
public static final int FS_VOL_IS_COMPRESSED =            FILE_VOLUME_IS_COMPRESSED;
public static final int FS_FILE_COMPRESSION =             FILE_FILE_COMPRESSION;
public static final int FS_FILE_ENCRYPTION =              FILE_SUPPORTS_ENCRYPTION;

public static final int OF_READ =             0x00000000;
public static final int OF_WRITE =            0x00000001;
public static final int OF_READWRITE =        0x00000002;
public static final int OF_SHARE_COMPAT =     0x00000000;
public static final int OF_SHARE_EXCLUSIVE =  0x00000010;
public static final int OF_SHARE_DENY_WRITE = 0x00000020;
public static final int OF_SHARE_DENY_READ =  0x00000030;
public static final int OF_SHARE_DENY_NONE =  0x00000040;
public static final int OF_PARSE =            0x00000100;
public static final int OF_DELETE =           0x00000200;
public static final int OF_VERIFY =           0x00000400;
public static final int OF_CANCEL =           0x00000800;
public static final int OF_CREATE =           0x00001000;
public static final int OF_PROMPT =           0x00002000;
public static final int OF_EXIST =            0x00004000;
public static final int OF_REOPEN =           0x00008000;

public static final int OFS_MAXPATHNAME = 128;
// Targeting ..\windows\OFSTRUCT.java



// #define UnlockResource(hResData) ((hResData), 0)
public static final int MAXINTATOM = 0xC000;
// #define MAKEINTATOM(i)  (LPTSTR)((ULONG_PTR)((WORD)(i)))
public static final int INVALID_ATOM = ((short)0);

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)





public static native @Cast("HGLOBAL") Pointer GlobalAlloc(
    @Cast("UINT") int uFlags,
    @Cast("SIZE_T") long dwBytes
    );



public static native @Cast("SIZE_T") long GlobalSize(
    @Cast("HGLOBAL") Pointer hMem
    );

public static native @Cast("UINT") int GlobalFlags(
    @Cast("HGLOBAL") Pointer hMem
    );

public static native @Cast("LPVOID") Pointer GlobalLock(
    @Cast("HGLOBAL") Pointer hMem
    );

public static native @Cast("HGLOBAL") Pointer GlobalHandle(
    LPCVOID pMem
    );

public static native @Cast("BOOL") boolean GlobalUnlock(
    @Cast("HGLOBAL") Pointer hMem
    );

public static native @Cast("HGLOBAL") Pointer GlobalFree(
    @Cast("HGLOBAL") Pointer hMem
    );

public static native @Cast("SIZE_T") long GlobalCompact(
    @Cast("DWORD") int dwMinFree
    );

public static native void GlobalFix(
    @Cast("HGLOBAL") Pointer hMem
    );

public static native void GlobalUnfix(
    @Cast("HGLOBAL") Pointer hMem
    );

public static native @Cast("LPVOID") Pointer GlobalWire(
    @Cast("HGLOBAL") Pointer hMem
    );

public static native @Cast("BOOL") boolean GlobalUnWire(
    @Cast("HGLOBAL") Pointer hMem
    );

public static native void GlobalMemoryStatus(
    @Cast("LPMEMORYSTATUS") MEMORYSTATUS lpBuffer
    );

public static native @Cast("HLOCAL") Pointer LocalAlloc(
    @Cast("UINT") int uFlags,
    @Cast("SIZE_T") long uBytes
    );



public static native @Cast("LPVOID") Pointer LocalLock(
    @Cast("HLOCAL") Pointer hMem
    );

public static native @Cast("HLOCAL") Pointer LocalHandle(
    LPCVOID pMem
    );

public static native @Cast("BOOL") boolean LocalUnlock(
    @Cast("HLOCAL") Pointer hMem
    );

public static native @Cast("SIZE_T") long LocalSize(
    @Cast("HLOCAL") Pointer hMem
    );

public static native @Cast("UINT") int LocalFlags(
    @Cast("HLOCAL") Pointer hMem
    );

public static native @Cast("HLOCAL") Pointer LocalFree(
    @Cast("HLOCAL") Pointer hMem
    );

public static native @Cast("SIZE_T") long LocalShrink(
    @Cast("HLOCAL") Pointer hMem,
    @Cast("UINT") int cbNewSize
    );

public static native @Cast("SIZE_T") long LocalCompact(
    @Cast("UINT") int uMinFree
    );

// #if (_WIN32_WINNT >= 0x0601)

public static native @Cast("BOOL") boolean GetProcessorSystemCycleTime(
    @Cast("USHORT") short Group,
    @Cast("PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION") LongPointer Buffer,
    @Cast("PDWORD") IntPointer ReturnedLength
    );
public static native @Cast("BOOL") boolean GetProcessorSystemCycleTime(
    @Cast("USHORT") short Group,
    @Cast("PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION") LongBuffer Buffer,
    @Cast("PDWORD") IntBuffer ReturnedLength
    );
public static native @Cast("BOOL") boolean GetProcessorSystemCycleTime(
    @Cast("USHORT") short Group,
    @Cast("PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION") long[] Buffer,
    @Cast("PDWORD") int[] ReturnedLength
    );

// #endif // (_WIN32_WINNT >= 0x0601)

// GetBinaryType return values.

public static final int SCS_32BIT_BINARY =    0;
public static final int SCS_DOS_BINARY =      1;
public static final int SCS_WOW_BINARY =      2;
public static final int SCS_PIF_BINARY =      3;
public static final int SCS_POSIX_BINARY =    4;
public static final int SCS_OS216_BINARY =    5;
public static final int SCS_64BIT_BINARY =    6;

// #if defined(_WIN64)
public static final int SCS_THIS_PLATFORM_BINARY = SCS_64BIT_BINARY;
// #else
// #endif

public static native @Cast("BOOL") boolean GetBinaryTypeA(
    @Cast("LPCSTR") BytePointer lpApplicationName,
    @Cast("LPDWORD") IntPointer lpBinaryType
    );
public static native @Cast("BOOL") boolean GetBinaryTypeA(
    @Cast("LPCSTR") ByteBuffer lpApplicationName,
    @Cast("LPDWORD") IntBuffer lpBinaryType
    );
public static native @Cast("BOOL") boolean GetBinaryTypeA(
    @Cast("LPCSTR") byte[] lpApplicationName,
    @Cast("LPDWORD") int[] lpBinaryType
    );
public static native @Cast("BOOL") boolean GetBinaryTypeA(
    @Cast("LPCSTR") String lpApplicationName,
    @Cast("LPDWORD") IntPointer lpBinaryType
    );
public static native @Cast("BOOL") boolean GetBinaryTypeA(
    @Cast("LPCSTR") BytePointer lpApplicationName,
    @Cast("LPDWORD") IntBuffer lpBinaryType
    );
public static native @Cast("BOOL") boolean GetBinaryTypeA(
    @Cast("LPCSTR") ByteBuffer lpApplicationName,
    @Cast("LPDWORD") int[] lpBinaryType
    );
public static native @Cast("BOOL") boolean GetBinaryTypeA(
    @Cast("LPCSTR") byte[] lpApplicationName,
    @Cast("LPDWORD") IntPointer lpBinaryType
    );
public static native @Cast("BOOL") boolean GetBinaryTypeA(
    @Cast("LPCSTR") String lpApplicationName,
    @Cast("LPDWORD") IntBuffer lpBinaryType
    );
public static native @Cast("BOOL") boolean GetBinaryTypeA(
    @Cast("LPCSTR") BytePointer lpApplicationName,
    @Cast("LPDWORD") int[] lpBinaryType
    );
public static native @Cast("BOOL") boolean GetBinaryTypeA(
    @Cast("LPCSTR") ByteBuffer lpApplicationName,
    @Cast("LPDWORD") IntPointer lpBinaryType
    );
public static native @Cast("BOOL") boolean GetBinaryTypeA(
    @Cast("LPCSTR") byte[] lpApplicationName,
    @Cast("LPDWORD") IntBuffer lpBinaryType
    );
public static native @Cast("BOOL") boolean GetBinaryTypeA(
    @Cast("LPCSTR") String lpApplicationName,
    @Cast("LPDWORD") int[] lpBinaryType
    );
public static native @Cast("BOOL") boolean GetBinaryTypeW(
    @Cast("LPCWSTR") CharPointer lpApplicationName,
    @Cast("LPDWORD") IntPointer lpBinaryType
    );
public static native @Cast("BOOL") boolean GetBinaryTypeW(
    @Cast("LPCWSTR") CharBuffer lpApplicationName,
    @Cast("LPDWORD") IntBuffer lpBinaryType
    );
public static native @Cast("BOOL") boolean GetBinaryTypeW(
    @Cast("LPCWSTR") char[] lpApplicationName,
    @Cast("LPDWORD") int[] lpBinaryType
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("DWORD") int GetShortPathNameA(
    @Cast("LPCSTR") BytePointer lpszLongPath,
    @Cast("LPSTR") BytePointer lpszShortPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetShortPathNameA(
    @Cast("LPCSTR") ByteBuffer lpszLongPath,
    @Cast("LPSTR") ByteBuffer lpszShortPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetShortPathNameA(
    @Cast("LPCSTR") byte[] lpszLongPath,
    @Cast("LPSTR") byte[] lpszShortPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetShortPathNameA(
    @Cast("LPCSTR") String lpszLongPath,
    @Cast("LPSTR") BytePointer lpszShortPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetShortPathNameA(
    @Cast("LPCSTR") BytePointer lpszLongPath,
    @Cast("LPSTR") ByteBuffer lpszShortPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetShortPathNameA(
    @Cast("LPCSTR") ByteBuffer lpszLongPath,
    @Cast("LPSTR") byte[] lpszShortPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetShortPathNameA(
    @Cast("LPCSTR") byte[] lpszLongPath,
    @Cast("LPSTR") BytePointer lpszShortPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetShortPathNameA(
    @Cast("LPCSTR") String lpszLongPath,
    @Cast("LPSTR") ByteBuffer lpszShortPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetShortPathNameA(
    @Cast("LPCSTR") BytePointer lpszLongPath,
    @Cast("LPSTR") byte[] lpszShortPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetShortPathNameA(
    @Cast("LPCSTR") ByteBuffer lpszLongPath,
    @Cast("LPSTR") BytePointer lpszShortPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetShortPathNameA(
    @Cast("LPCSTR") byte[] lpszLongPath,
    @Cast("LPSTR") ByteBuffer lpszShortPath,
    @Cast("DWORD") int cchBuffer
    );
public static native @Cast("DWORD") int GetShortPathNameA(
    @Cast("LPCSTR") String lpszLongPath,
    @Cast("LPSTR") byte[] lpszShortPath,
    @Cast("DWORD") int cchBuffer
    );
// #ifndef UNICODE
// #endif

// #if _WIN32_WINNT >= 0x0600

public static native @Cast("DWORD") int GetLongPathNameTransactedA(
    @Cast("LPCSTR") BytePointer lpszShortPath,
    @Cast("LPSTR") BytePointer lpszLongPath,
    @Cast("DWORD") int cchBuffer,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetLongPathNameTransactedA(
    @Cast("LPCSTR") ByteBuffer lpszShortPath,
    @Cast("LPSTR") ByteBuffer lpszLongPath,
    @Cast("DWORD") int cchBuffer,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetLongPathNameTransactedA(
    @Cast("LPCSTR") byte[] lpszShortPath,
    @Cast("LPSTR") byte[] lpszLongPath,
    @Cast("DWORD") int cchBuffer,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetLongPathNameTransactedA(
    @Cast("LPCSTR") String lpszShortPath,
    @Cast("LPSTR") BytePointer lpszLongPath,
    @Cast("DWORD") int cchBuffer,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetLongPathNameTransactedA(
    @Cast("LPCSTR") BytePointer lpszShortPath,
    @Cast("LPSTR") ByteBuffer lpszLongPath,
    @Cast("DWORD") int cchBuffer,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetLongPathNameTransactedA(
    @Cast("LPCSTR") ByteBuffer lpszShortPath,
    @Cast("LPSTR") byte[] lpszLongPath,
    @Cast("DWORD") int cchBuffer,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetLongPathNameTransactedA(
    @Cast("LPCSTR") byte[] lpszShortPath,
    @Cast("LPSTR") BytePointer lpszLongPath,
    @Cast("DWORD") int cchBuffer,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetLongPathNameTransactedA(
    @Cast("LPCSTR") String lpszShortPath,
    @Cast("LPSTR") ByteBuffer lpszLongPath,
    @Cast("DWORD") int cchBuffer,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetLongPathNameTransactedA(
    @Cast("LPCSTR") BytePointer lpszShortPath,
    @Cast("LPSTR") byte[] lpszLongPath,
    @Cast("DWORD") int cchBuffer,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetLongPathNameTransactedA(
    @Cast("LPCSTR") ByteBuffer lpszShortPath,
    @Cast("LPSTR") BytePointer lpszLongPath,
    @Cast("DWORD") int cchBuffer,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetLongPathNameTransactedA(
    @Cast("LPCSTR") byte[] lpszShortPath,
    @Cast("LPSTR") ByteBuffer lpszLongPath,
    @Cast("DWORD") int cchBuffer,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetLongPathNameTransactedA(
    @Cast("LPCSTR") String lpszShortPath,
    @Cast("LPSTR") byte[] lpszLongPath,
    @Cast("DWORD") int cchBuffer,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetLongPathNameTransactedW(
    @Cast("LPCWSTR") CharPointer lpszShortPath,
    @Cast("LPWSTR") CharPointer lpszLongPath,
    @Cast("DWORD") int cchBuffer,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetLongPathNameTransactedW(
    @Cast("LPCWSTR") CharBuffer lpszShortPath,
    @Cast("LPWSTR") CharBuffer lpszLongPath,
    @Cast("DWORD") int cchBuffer,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetLongPathNameTransactedW(
    @Cast("LPCWSTR") char[] lpszShortPath,
    @Cast("LPWSTR") char[] lpszLongPath,
    @Cast("DWORD") int cchBuffer,
    @Cast("HANDLE") Pointer hTransaction
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // _WIN32_WINNT >= 0x0600

public static native @Cast("BOOL") boolean GetProcessAffinityMask(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PDWORD_PTR") SizeTPointer lpProcessAffinityMask,
    @Cast("PDWORD_PTR") SizeTPointer lpSystemAffinityMask
    );

public static native @Cast("BOOL") boolean SetProcessAffinityMask(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("DWORD_PTR") long dwProcessAffinityMask
    );

public static native @Cast("BOOL") boolean GetProcessIoCounters(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PIO_COUNTERS") IO_COUNTERS lpIoCounters
    );

public static native @Cast("BOOL") boolean GetProcessWorkingSetSize(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PSIZE_T") SizeTPointer lpMinimumWorkingSetSize,
    @Cast("PSIZE_T") SizeTPointer lpMaximumWorkingSetSize
    );

public static native @Cast("BOOL") boolean SetProcessWorkingSetSize(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("SIZE_T") long dwMinimumWorkingSetSize,
    @Cast("SIZE_T") long dwMaximumWorkingSetSize
    );

public static native void FatalExit(
    int ExitCode
    );

public static native @Cast("BOOL") boolean SetEnvironmentStringsA(
    @Cast("LPCH") BytePointer NewEnvironment
    );
public static native @Cast("BOOL") boolean SetEnvironmentStringsA(
    @Cast("LPCH") ByteBuffer NewEnvironment
    );
public static native @Cast("BOOL") boolean SetEnvironmentStringsA(
    @Cast("LPCH") byte[] NewEnvironment
    );
// #ifndef UNICODE
// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native void RaiseFailFastException(
    @Cast("PEXCEPTION_RECORD") EXCEPTION_RECORD pExceptionRecord,
    @Cast("PCONTEXT") CONTEXT pContextRecord,
    @Cast("DWORD") int dwFlags
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #if(_WIN32_WINNT >= 0x0400)

//
// Fiber begin
//

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static final int FIBER_FLAG_FLOAT_SWITCH = 0x1;     // context switch floating point

public static native void SwitchToFiber(
    @Cast("LPVOID") Pointer lpFiber
    );

public static native void DeleteFiber(
    @Cast("LPVOID") Pointer lpFiber
    );

// #if (_WIN32_WINNT >= 0x0501)

public static native @Cast("BOOL") boolean ConvertFiberToThread(
    );

// #endif

// #if (_WIN32_WINNT >= 0x0603)

// #endif

public static native @Cast("LPVOID") Pointer CreateFiberEx(
    @Cast("SIZE_T") long dwStackCommitSize,
    @Cast("SIZE_T") long dwStackReserveSize,
    @Cast("DWORD") int dwFlags,
    @Cast("LPFIBER_START_ROUTINE") PFIBER_START_ROUTINE lpStartAddress,
    @Cast("LPVOID") Pointer lpParameter
    );

public static native @Cast("LPVOID") Pointer ConvertThreadToFiberEx(
    @Cast("LPVOID") Pointer lpParameter,
    @Cast("DWORD") int dwFlags
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("LPVOID") Pointer CreateFiber(
    @Cast("SIZE_T") long dwStackSize,
    @Cast("LPFIBER_START_ROUTINE") PFIBER_START_ROUTINE lpStartAddress,
    @Cast("LPVOID") Pointer lpParameter
    );

public static native @Cast("LPVOID") Pointer ConvertThreadToFiber(
    @Cast("LPVOID") Pointer lpParameter
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

//
// Fiber end
//

//
// UMS begin
//

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// #if (_WIN32_WINNT >= 0x0601) && !defined(MIDL_PASS)

public static final int UMS_VERSION = RTL_UMS_VERSION;
// Targeting ..\windows\PUMS_CONTEXT.java


// Targeting ..\windows\PUMS_COMPLETION_LIST.java



public static native @Cast("BOOL") boolean CreateUmsCompletionList(
    @Cast("PUMS_COMPLETION_LIST*") Pointer UmsCompletionList
    );

public static native @Cast("BOOL") boolean DequeueUmsCompletionListItems(
    @ByVal @Cast("PUMS_COMPLETION_LIST*") Pointer UmsCompletionList,
    @Cast("DWORD") int WaitTimeOut,
    @Cast("PUMS_CONTEXT*") Pointer UmsThreadList
    );

public static native @Cast("BOOL") boolean GetUmsCompletionListEvent(
    @ByVal @Cast("PUMS_COMPLETION_LIST*") Pointer UmsCompletionList,
    @Cast("PHANDLE") PointerPointer UmsCompletionEvent
    );

public static native @Cast("BOOL") boolean ExecuteUmsThread(
    @ByVal @Cast("PUMS_CONTEXT*") Pointer UmsThread
    );

public static native @Cast("BOOL") boolean UmsThreadYield(
    @Cast("PVOID") Pointer SchedulerParam
    );

public static native @Cast("BOOL") boolean DeleteUmsCompletionList(
    @ByVal @Cast("PUMS_COMPLETION_LIST*") Pointer UmsCompletionList
    );

public static native @ByVal @Cast("PUMS_CONTEXT*") Pointer GetCurrentUmsThread(
    );

public static native @ByVal @Cast("PUMS_CONTEXT*") Pointer GetNextUmsListItem(
    @ByVal @Cast("PUMS_CONTEXT*") Pointer UmsContext
    );

public static native @Cast("BOOL") boolean QueryUmsThreadInformation(
    @ByVal @Cast("PUMS_CONTEXT*") Pointer UmsThread,
    @Cast("UMS_THREAD_INFO_CLASS") int UmsThreadInfoClass,
    @Cast("PVOID") Pointer UmsThreadInformation,
    @Cast("ULONG") long UmsThreadInformationLength,
    @Cast("PULONG") long ReturnLength
    );

public static native @Cast("BOOL") boolean SetUmsThreadInformation(
    @ByVal @Cast("PUMS_CONTEXT*") Pointer UmsThread,
    @Cast("UMS_THREAD_INFO_CLASS") int UmsThreadInfoClass,
    @Cast("PVOID") Pointer UmsThreadInformation,
    @Cast("ULONG") long UmsThreadInformationLength
    );

public static native @Cast("BOOL") boolean DeleteUmsThreadContext(
    @ByVal @Cast("PUMS_CONTEXT*") Pointer UmsThread
    );

public static native @Cast("BOOL") boolean CreateUmsThreadContext(
    @Cast("PUMS_CONTEXT*") Pointer lpUmsThread
    );

public static native @Cast("BOOL") boolean EnterUmsSchedulingMode(
    @ByVal @Cast("PUMS_SCHEDULER_STARTUP_INFO*") Pointer SchedulerStartupInfo
    );

public static native @Cast("BOOL") boolean GetUmsSystemThreadInformation(
    @Cast("HANDLE") Pointer ThreadHandle,
    @ByVal @Cast("PUMS_SYSTEM_THREAD_INFORMATION*") Pointer SystemThreadInfo
    );

// #endif // (_WIN32_WINNT >= 0x0601) && !defined(MIDL_PASS)

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

//
// UMS end
//

// #endif /* _WIN32_WINNT >= 0x0400 */

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("DWORD_PTR") long SetThreadAffinityMask(
    @Cast("HANDLE") Pointer hThread,
    @Cast("DWORD_PTR") long dwThreadAffinityMask
    );
// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
// #if(_WIN32_WINNT >= 0x0400)
public static native @Cast("DWORD") int SetThreadIdealProcessor(
    @Cast("HANDLE") Pointer hThread,
    @Cast("DWORD") int dwIdealProcessor
    );
// #endif /* _WIN32_WINNT >= 0x0400 */
// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

//
// Process information classes.
//

/** enum PROCESS_INFORMATION_CLASS */
public static final int
    ProcessMemoryPriority = 0,
    ProcessInformationClassMax = 1;

// #if (_WIN32_WINNT >= 0x0602)

// #endif // _WIN32_WINNT >= 0x0602

// #if (_WIN32_WINNT >= 0x0600)

public static final int PROCESS_DEP_ENABLE =                          0x00000001;
public static final int PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION =     0x00000002;

public static native @Cast("BOOL") boolean SetProcessDEPPolicy(
    @Cast("DWORD") int dwFlags
    );

public static native @Cast("BOOL") boolean GetProcessDEPPolicy(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPDWORD") IntPointer lpFlags,
    @Cast("PBOOL") boolean lpPermanent
    );
public static native @Cast("BOOL") boolean GetProcessDEPPolicy(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPDWORD") IntBuffer lpFlags,
    @Cast("PBOOL") boolean lpPermanent
    );
public static native @Cast("BOOL") boolean GetProcessDEPPolicy(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPDWORD") int[] lpFlags,
    @Cast("PBOOL") boolean lpPermanent
    );

// #endif // _WIN32_WINNT >= 0x0600

public static native @Cast("BOOL") boolean RequestWakeupLatency(
    @Cast("LATENCY_TIME") int latency
    );

public static native @Cast("BOOL") boolean IsSystemResumeAutomatic(
    );

public static native @Cast("BOOL") boolean GetThreadSelectorEntry(
    @Cast("HANDLE") Pointer hThread,
    @Cast("DWORD") int dwSelector,
    @Cast("LPLDT_ENTRY") Pointer lpSelectorEntry
    );

public static native @Cast("EXECUTION_STATE") int SetThreadExecutionState(
    @Cast("EXECUTION_STATE") int esFlags
    );

// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

//
// Power Request APIs
//

public static native @Cast("HANDLE") Pointer PowerCreateRequest(
    @Cast("PREASON_CONTEXT") REASON_CONTEXT Context
    );

public static native @Cast("BOOL") boolean PowerSetRequest(
    @Cast("HANDLE") Pointer PowerRequest,
    @Cast("POWER_REQUEST_TYPE") int RequestType
    );

public static native @Cast("BOOL") boolean PowerClearRequest(
    @Cast("HANDLE") Pointer PowerRequest,
    @Cast("POWER_REQUEST_TYPE") int RequestType
    );

// #endif // (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

// #ifdef _M_CEE_PURE
// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// #if !defined(RC_INVOKED) // RC warns because "WINBASE_DECLARE_RESTORE_LAST_ERROR" is a bit long.
//#if _WIN32_WINNT >= 0x0501 || defined(WINBASE_DECLARE_RESTORE_LAST_ERROR)
// #if defined(WINBASE_DECLARE_RESTORE_LAST_ERROR)

// #endif
// #endif

// #define HasOverlappedIoCompleted(lpOverlapped) (((DWORD)(lpOverlapped)->Internal) != STATUS_PENDING)

// #if (_WIN32_WINNT >= 0x0600)

//
// The following flags allows an application to change
// the semantics of IO completion notification.
//

//
// Don't queue an entry to an associated completion port if returning success
// synchronously.
//
public static final int FILE_SKIP_COMPLETION_PORT_ON_SUCCESS =    0x1;

//
// Don't set the file handle event on IO completion.
//
public static final int FILE_SKIP_SET_EVENT_ON_HANDLE =           0x2;

public static native @Cast("BOOL") boolean SetFileCompletionNotificationModes(
    @Cast("HANDLE") Pointer FileHandle,
    @Cast("UCHAR") byte Flags
    );

// #endif // _WIN32_WINNT >= 0x0600

public static final int SEM_FAILCRITICALERRORS =      0x0001;
public static final int SEM_NOGPFAULTERRORBOX =       0x0002;
public static final int SEM_NOALIGNMENTFAULTEXCEPT =  0x0004;
public static final int SEM_NOOPENFILEERRORBOX =      0x8000;

//
// Thread error mode support
//

public static native @Cast("DWORD") int GetThreadErrorMode(
    );

public static native @Cast("BOOL") boolean SetThreadErrorMode(
    @Cast("DWORD") int dwNewMode,
    @Cast("LPDWORD") IntPointer lpOldMode
    );
public static native @Cast("BOOL") boolean SetThreadErrorMode(
    @Cast("DWORD") int dwNewMode,
    @Cast("LPDWORD") IntBuffer lpOldMode
    );
public static native @Cast("BOOL") boolean SetThreadErrorMode(
    @Cast("DWORD") int dwNewMode,
    @Cast("LPDWORD") int[] lpOldMode
    );

// #if !defined(MIDL_PASS)

// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean Wow64GetThreadContext(
    @Cast("HANDLE") Pointer hThread,
    @Cast("PWOW64_CONTEXT") WOW64_CONTEXT lpContext
    );

public static native @Cast("BOOL") boolean Wow64SetThreadContext(
    @Cast("HANDLE") Pointer hThread,
    @Const WOW64_CONTEXT lpContext
    );

// #endif // (_WIN32_WINNT >= 0x0600)

// #if (_WIN32_WINNT >= 0x0601)

public static native @Cast("BOOL") boolean Wow64GetThreadSelectorEntry(
    @Cast("HANDLE") Pointer hThread,
    @Cast("DWORD") int dwSelector,
    @Cast("PWOW64_LDT_ENTRY") WOW64_LDT_ENTRY lpSelectorEntry
    );

// #endif // (_WIN32_WINNT >= 0x0601)

// #endif // !defined(MIDL_PASS)

// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("DWORD") int Wow64SuspendThread(
    @Cast("HANDLE") Pointer hThread
    );

// #endif // (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean DebugSetProcessKillOnExit(
    @Cast("BOOL") boolean KillOnExit
    );

public static native @Cast("BOOL") boolean DebugBreakProcess(
    @Cast("HANDLE") Pointer Process
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

// #if (_WIN32_WINNT >= 0x0403)
public static final int CRITICAL_SECTION_NO_DEBUG_INFO =  RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO;
// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean PulseEvent(
    @Cast("HANDLE") Pointer hEvent
    );

public static native @Cast("DWORD") int WaitForMultipleObjects(
    @Cast("DWORD") int nCount,
    @Cast("const HANDLE*") PointerPointer lpHandles,
    @Cast("BOOL") boolean bWaitAll,
    @Cast("DWORD") int dwMilliseconds
    );

public static native @Cast("ATOM") short GlobalDeleteAtom(
    @Cast("ATOM") short nAtom
    );

public static native @Cast("BOOL") boolean InitAtomTable(
    @Cast("DWORD") int nSize
    );

public static native @Cast("ATOM") short DeleteAtom(
    @Cast("ATOM") short nAtom
    );

public static native @Cast("UINT") int SetHandleCount(
    @Cast("UINT") int uNumber
    );

public static native @Cast("BOOL") boolean RequestDeviceWakeup(
    @Cast("HANDLE") Pointer hDevice
    );

public static native @Cast("BOOL") boolean CancelDeviceWakeupRequest(
    @Cast("HANDLE") Pointer hDevice
    );

public static native @Cast("BOOL") boolean GetDevicePowerState(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("BOOL*") IntPointer pfOn
    );
public static native @Cast("BOOL") boolean GetDevicePowerState(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("BOOL*") IntBuffer pfOn
    );
public static native @Cast("BOOL") boolean GetDevicePowerState(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("BOOL*") int[] pfOn
    );

public static native @Cast("BOOL") boolean SetMessageWaitingIndicator(
    @Cast("HANDLE") Pointer hMsgIndicator,
    @Cast("ULONG") long ulMsgCount
    );


public static native @Cast("BOOL") boolean SetFileShortNameA(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPCSTR") BytePointer lpShortName
    );
public static native @Cast("BOOL") boolean SetFileShortNameA(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPCSTR") ByteBuffer lpShortName
    );
public static native @Cast("BOOL") boolean SetFileShortNameA(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPCSTR") byte[] lpShortName
    );
public static native @Cast("BOOL") boolean SetFileShortNameA(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPCSTR") String lpShortName
    );
public static native @Cast("BOOL") boolean SetFileShortNameW(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPCWSTR") CharPointer lpShortName
    );
public static native @Cast("BOOL") boolean SetFileShortNameW(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPCWSTR") CharBuffer lpShortName
    );
public static native @Cast("BOOL") boolean SetFileShortNameW(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPCWSTR") char[] lpShortName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static final int HANDLE_FLAG_INHERIT =             0x00000001;
public static final int HANDLE_FLAG_PROTECT_FROM_CLOSE =  0x00000002;

public static final int HINSTANCE_ERROR = 32;

public static native @Cast("DWORD") int LoadModule(
    @Cast("LPCSTR") BytePointer lpModuleName,
    @Cast("LPVOID") Pointer lpParameterBlock
    );
public static native @Cast("DWORD") int LoadModule(
    @Cast("LPCSTR") ByteBuffer lpModuleName,
    @Cast("LPVOID") Pointer lpParameterBlock
    );
public static native @Cast("DWORD") int LoadModule(
    @Cast("LPCSTR") byte[] lpModuleName,
    @Cast("LPVOID") Pointer lpParameterBlock
    );
public static native @Cast("DWORD") int LoadModule(
    @Cast("LPCSTR") String lpModuleName,
    @Cast("LPVOID") Pointer lpParameterBlock
    );


public static native @Cast("UINT") int WinExec(
    @Cast("LPCSTR") BytePointer lpCmdLine,
    @Cast("UINT") int uCmdShow
    );
public static native @Cast("UINT") int WinExec(
    @Cast("LPCSTR") ByteBuffer lpCmdLine,
    @Cast("UINT") int uCmdShow
    );
public static native @Cast("UINT") int WinExec(
    @Cast("LPCSTR") byte[] lpCmdLine,
    @Cast("UINT") int uCmdShow
    );
public static native @Cast("UINT") int WinExec(
    @Cast("LPCSTR") String lpCmdLine,
    @Cast("UINT") int uCmdShow
    );

public static native @Cast("BOOL") boolean ClearCommBreak(
    @Cast("HANDLE") Pointer hFile
    );

public static native @Cast("BOOL") boolean ClearCommError(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") IntPointer lpErrors,
    @Cast("LPCOMSTAT") COMSTAT lpStat
    );
public static native @Cast("BOOL") boolean ClearCommError(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") IntBuffer lpErrors,
    @Cast("LPCOMSTAT") COMSTAT lpStat
    );
public static native @Cast("BOOL") boolean ClearCommError(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") int[] lpErrors,
    @Cast("LPCOMSTAT") COMSTAT lpStat
    );

public static native @Cast("BOOL") boolean SetupComm(
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwInQueue,
    @Cast("DWORD") int dwOutQueue
    );

public static native @Cast("BOOL") boolean EscapeCommFunction(
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwFunc
    );

public static native @Cast("BOOL") boolean GetCommConfig(
    @Cast("HANDLE") Pointer hCommDev,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") IntPointer lpdwSize
    );
public static native @Cast("BOOL") boolean GetCommConfig(
    @Cast("HANDLE") Pointer hCommDev,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") IntBuffer lpdwSize
    );
public static native @Cast("BOOL") boolean GetCommConfig(
    @Cast("HANDLE") Pointer hCommDev,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") int[] lpdwSize
    );

public static native @Cast("BOOL") boolean GetCommMask(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") IntPointer lpEvtMask
    );
public static native @Cast("BOOL") boolean GetCommMask(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") IntBuffer lpEvtMask
    );
public static native @Cast("BOOL") boolean GetCommMask(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") int[] lpEvtMask
    );

public static native @Cast("BOOL") boolean GetCommProperties(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPCOMMPROP") COMMPROP lpCommProp
    );

public static native @Cast("BOOL") boolean GetCommModemStatus(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") IntPointer lpModemStat
    );
public static native @Cast("BOOL") boolean GetCommModemStatus(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") IntBuffer lpModemStat
    );
public static native @Cast("BOOL") boolean GetCommModemStatus(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") int[] lpModemStat
    );

public static native @Cast("BOOL") boolean GetCommState(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDCB") DCB lpDCB
    );

public static native @Cast("BOOL") boolean GetCommTimeouts(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPCOMMTIMEOUTS") COMMTIMEOUTS lpCommTimeouts
    );

public static native @Cast("BOOL") boolean PurgeComm(
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwFlags
    );

public static native @Cast("BOOL") boolean SetCommBreak(
    @Cast("HANDLE") Pointer hFile
    );

public static native @Cast("BOOL") boolean SetCommConfig(
    @Cast("HANDLE") Pointer hCommDev,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("DWORD") int dwSize
    );

public static native @Cast("BOOL") boolean SetCommMask(
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwEvtMask
    );

public static native @Cast("BOOL") boolean SetCommState(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDCB") DCB lpDCB
    );

public static native @Cast("BOOL") boolean SetCommTimeouts(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPCOMMTIMEOUTS") COMMTIMEOUTS lpCommTimeouts
    );

public static native @Cast("BOOL") boolean TransmitCommChar(
    @Cast("HANDLE") Pointer hFile,
    @Cast("char") byte cChar
    );

public static native @Cast("BOOL") boolean WaitCommEvent(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") IntPointer lpEvtMask,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );
public static native @Cast("BOOL") boolean WaitCommEvent(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") IntBuffer lpEvtMask,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );
public static native @Cast("BOOL") boolean WaitCommEvent(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") int[] lpEvtMask,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped
    );


public static native @Cast("DWORD") int SetTapePosition(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("DWORD") int dwPositionMethod,
    @Cast("DWORD") int dwPartition,
    @Cast("DWORD") int dwOffsetLow,
    @Cast("DWORD") int dwOffsetHigh,
    @Cast("BOOL") boolean bImmediate
    );

public static native @Cast("DWORD") int GetTapePosition(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("DWORD") int dwPositionType,
    @Cast("LPDWORD") IntPointer lpdwPartition,
    @Cast("LPDWORD") IntPointer lpdwOffsetLow,
    @Cast("LPDWORD") IntPointer lpdwOffsetHigh
    );
public static native @Cast("DWORD") int GetTapePosition(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("DWORD") int dwPositionType,
    @Cast("LPDWORD") IntBuffer lpdwPartition,
    @Cast("LPDWORD") IntBuffer lpdwOffsetLow,
    @Cast("LPDWORD") IntBuffer lpdwOffsetHigh
    );
public static native @Cast("DWORD") int GetTapePosition(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("DWORD") int dwPositionType,
    @Cast("LPDWORD") int[] lpdwPartition,
    @Cast("LPDWORD") int[] lpdwOffsetLow,
    @Cast("LPDWORD") int[] lpdwOffsetHigh
    );

public static native @Cast("DWORD") int PrepareTape(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("DWORD") int dwOperation,
    @Cast("BOOL") boolean bImmediate
    );

public static native @Cast("DWORD") int EraseTape(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("DWORD") int dwEraseType,
    @Cast("BOOL") boolean bImmediate
    );

public static native @Cast("DWORD") int CreateTapePartition(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("DWORD") int dwPartitionMethod,
    @Cast("DWORD") int dwCount,
    @Cast("DWORD") int dwSize
    );

public static native @Cast("DWORD") int WriteTapemark(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("DWORD") int dwTapemarkType,
    @Cast("DWORD") int dwTapemarkCount,
    @Cast("BOOL") boolean bImmediate
    );

public static native @Cast("DWORD") int GetTapeStatus(
    @Cast("HANDLE") Pointer hDevice
    );

public static native @Cast("DWORD") int GetTapeParameters(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("DWORD") int dwOperation,
    @Cast("LPDWORD") IntPointer lpdwSize,
    @Cast("LPVOID") Pointer lpTapeInformation
    );
public static native @Cast("DWORD") int GetTapeParameters(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("DWORD") int dwOperation,
    @Cast("LPDWORD") IntBuffer lpdwSize,
    @Cast("LPVOID") Pointer lpTapeInformation
    );
public static native @Cast("DWORD") int GetTapeParameters(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("DWORD") int dwOperation,
    @Cast("LPDWORD") int[] lpdwSize,
    @Cast("LPVOID") Pointer lpTapeInformation
    );

public static final int GET_TAPE_MEDIA_INFORMATION = 0;
public static final int GET_TAPE_DRIVE_INFORMATION = 1;

public static native @Cast("DWORD") int SetTapeParameters(
    @Cast("HANDLE") Pointer hDevice,
    @Cast("DWORD") int dwOperation,
    @Cast("LPVOID") Pointer lpTapeInformation
    );

public static final int SET_TAPE_MEDIA_INFORMATION = 0;
public static final int SET_TAPE_DRIVE_INFORMATION = 1;

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native int MulDiv(
    int nNumber,
    int nNumerator,
    int nDenominator
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

/** enum DEP_SYSTEM_POLICY_TYPE */
public static final int
    DEPPolicyAlwaysOff = 0,
    DEPPolicyAlwaysOn = 1,
    DEPPolicyOptIn = 2,
    DEPPolicyOptOut = 3,
    DEPTotalPolicyCount = 4;

// #if (NTDDI_VERSION >= NTDDI_WINXPSP3)

public static native @Cast("DEP_SYSTEM_POLICY_TYPE") int GetSystemDEPPolicy(
    );

// #endif // (NTDDI_VERSION >= NTDDI_WINXPSP3)

// #if _WIN32_WINNT >= 0x0501

public static native @Cast("BOOL") boolean GetSystemRegistryQuota(
    @Cast("PDWORD") IntPointer pdwQuotaAllowed,
    @Cast("PDWORD") IntPointer pdwQuotaUsed
    );
public static native @Cast("BOOL") boolean GetSystemRegistryQuota(
    @Cast("PDWORD") IntBuffer pdwQuotaAllowed,
    @Cast("PDWORD") IntBuffer pdwQuotaUsed
    );
public static native @Cast("BOOL") boolean GetSystemRegistryQuota(
    @Cast("PDWORD") int[] pdwQuotaAllowed,
    @Cast("PDWORD") int[] pdwQuotaUsed
    );

// #endif // (_WIN32_WINNT >= 0x0501)

//
// Routines to convert back and forth between system time and file time
//

public static native @Cast("BOOL") boolean FileTimeToDosDateTime(
    @Const FILETIME lpFileTime,
    @Cast("LPWORD") short lpFatDate,
    @Cast("LPWORD") short lpFatTime
    );

public static native @Cast("BOOL") boolean DosDateTimeToFileTime(
    @Cast("WORD") short wFatDate,
    @Cast("WORD") short wFatTime,
    @Cast("LPFILETIME") FILETIME lpFileTime
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion


// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

// #if !defined(MIDL_PASS)
public static native @Cast("DWORD") int FormatMessageA(
    @Cast("DWORD") int dwFlags,
    LPCVOID lpSource,
    @Cast("DWORD") int dwMessageId,
    @Cast("DWORD") int dwLanguageId,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("DWORD") int nSize,
    @Cast("va_list*") Pointer Arguments
    );
public static native @Cast("DWORD") int FormatMessageA(
    @Cast("DWORD") int dwFlags,
    LPCVOID lpSource,
    @Cast("DWORD") int dwMessageId,
    @Cast("DWORD") int dwLanguageId,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("DWORD") int nSize,
    @Cast("va_list*") Pointer Arguments
    );
public static native @Cast("DWORD") int FormatMessageA(
    @Cast("DWORD") int dwFlags,
    LPCVOID lpSource,
    @Cast("DWORD") int dwMessageId,
    @Cast("DWORD") int dwLanguageId,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("DWORD") int nSize,
    @Cast("va_list*") Pointer Arguments
    );
public static native @Cast("DWORD") int FormatMessageW(
    @Cast("DWORD") int dwFlags,
    LPCVOID lpSource,
    @Cast("DWORD") int dwMessageId,
    @Cast("DWORD") int dwLanguageId,
    @Cast("LPWSTR") CharPointer lpBuffer,
    @Cast("DWORD") int nSize,
    @Cast("va_list*") Pointer Arguments
    );
public static native @Cast("DWORD") int FormatMessageW(
    @Cast("DWORD") int dwFlags,
    LPCVOID lpSource,
    @Cast("DWORD") int dwMessageId,
    @Cast("DWORD") int dwLanguageId,
    @Cast("LPWSTR") CharBuffer lpBuffer,
    @Cast("DWORD") int nSize,
    @Cast("va_list*") Pointer Arguments
    );
public static native @Cast("DWORD") int FormatMessageW(
    @Cast("DWORD") int dwFlags,
    LPCVOID lpSource,
    @Cast("DWORD") int dwMessageId,
    @Cast("DWORD") int dwLanguageId,
    @Cast("LPWSTR") char[] lpBuffer,
    @Cast("DWORD") int nSize,
    @Cast("va_list*") Pointer Arguments
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #if defined(_M_CEE)
// #undef FormatMessage
public static native @Cast("DWORD") int FormatMessage(
    @Cast("DWORD") int dwFlags,
    LPCVOID lpSource,
    @Cast("DWORD") int dwMessageId,
    @Cast("DWORD") int dwLanguageId,
    @Cast("LPTSTR") CharPointer lpBuffer,
    @Cast("DWORD") int nSize,
    @Cast("va_list*") Pointer Arguments
    );
public static native @Cast("DWORD") int FormatMessage(
    @Cast("DWORD") int dwFlags,
    LPCVOID lpSource,
    @Cast("DWORD") int dwMessageId,
    @Cast("DWORD") int dwLanguageId,
    @Cast("LPTSTR") CharBuffer lpBuffer,
    @Cast("DWORD") int nSize,
    @Cast("va_list*") Pointer Arguments
    );
public static native @Cast("DWORD") int FormatMessage(
    @Cast("DWORD") int dwFlags,
    LPCVOID lpSource,
    @Cast("DWORD") int dwMessageId,
    @Cast("DWORD") int dwLanguageId,
    @Cast("LPTSTR") char[] lpBuffer,
    @Cast("DWORD") int nSize,
    @Cast("va_list*") Pointer Arguments
    );
// #endif  /* _M_CEE */
// #endif  /* MIDL_PASS */

public static final int FORMAT_MESSAGE_IGNORE_INSERTS =  0x00000200;
public static final int FORMAT_MESSAGE_FROM_STRING =     0x00000400;
public static final int FORMAT_MESSAGE_FROM_HMODULE =    0x00000800;
public static final int FORMAT_MESSAGE_FROM_SYSTEM =     0x00001000;
public static final int FORMAT_MESSAGE_ARGUMENT_ARRAY =  0x00002000;
public static final int FORMAT_MESSAGE_MAX_WIDTH_MASK =  0x000000FF;

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

//
// FORMAT_MESSAGE_ALLOCATE_BUFFER requires use of LocalFree which is in the
// "Desktop Family" only.
//

public static final int FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100;


public static native @Cast("BOOL") boolean GetNamedPipeInfo(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPDWORD") IntPointer lpFlags,
    @Cast("LPDWORD") IntPointer lpOutBufferSize,
    @Cast("LPDWORD") IntPointer lpInBufferSize,
    @Cast("LPDWORD") IntPointer lpMaxInstances
    );
public static native @Cast("BOOL") boolean GetNamedPipeInfo(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPDWORD") IntBuffer lpFlags,
    @Cast("LPDWORD") IntBuffer lpOutBufferSize,
    @Cast("LPDWORD") IntBuffer lpInBufferSize,
    @Cast("LPDWORD") IntBuffer lpMaxInstances
    );
public static native @Cast("BOOL") boolean GetNamedPipeInfo(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPDWORD") int[] lpFlags,
    @Cast("LPDWORD") int[] lpOutBufferSize,
    @Cast("LPDWORD") int[] lpInBufferSize,
    @Cast("LPDWORD") int[] lpMaxInstances
    );

public static native @Cast("HANDLE") Pointer CreateMailslotA(
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("DWORD") int nMaxMessageSize,
    @Cast("DWORD") int lReadTimeout,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("HANDLE") Pointer CreateMailslotA(
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("DWORD") int nMaxMessageSize,
    @Cast("DWORD") int lReadTimeout,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("HANDLE") Pointer CreateMailslotA(
    @Cast("LPCSTR") byte[] lpName,
    @Cast("DWORD") int nMaxMessageSize,
    @Cast("DWORD") int lReadTimeout,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("HANDLE") Pointer CreateMailslotA(
    @Cast("LPCSTR") String lpName,
    @Cast("DWORD") int nMaxMessageSize,
    @Cast("DWORD") int lReadTimeout,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("HANDLE") Pointer CreateMailslotW(
    @Cast("LPCWSTR") CharPointer lpName,
    @Cast("DWORD") int nMaxMessageSize,
    @Cast("DWORD") int lReadTimeout,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("HANDLE") Pointer CreateMailslotW(
    @Cast("LPCWSTR") CharBuffer lpName,
    @Cast("DWORD") int nMaxMessageSize,
    @Cast("DWORD") int lReadTimeout,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("HANDLE") Pointer CreateMailslotW(
    @Cast("LPCWSTR") char[] lpName,
    @Cast("DWORD") int nMaxMessageSize,
    @Cast("DWORD") int lReadTimeout,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean GetMailslotInfo(
    @Cast("HANDLE") Pointer hMailslot,
    @Cast("LPDWORD") IntPointer lpMaxMessageSize,
    @Cast("LPDWORD") IntPointer lpNextSize,
    @Cast("LPDWORD") IntPointer lpMessageCount,
    @Cast("LPDWORD") IntPointer lpReadTimeout
    );
public static native @Cast("BOOL") boolean GetMailslotInfo(
    @Cast("HANDLE") Pointer hMailslot,
    @Cast("LPDWORD") IntBuffer lpMaxMessageSize,
    @Cast("LPDWORD") IntBuffer lpNextSize,
    @Cast("LPDWORD") IntBuffer lpMessageCount,
    @Cast("LPDWORD") IntBuffer lpReadTimeout
    );
public static native @Cast("BOOL") boolean GetMailslotInfo(
    @Cast("HANDLE") Pointer hMailslot,
    @Cast("LPDWORD") int[] lpMaxMessageSize,
    @Cast("LPDWORD") int[] lpNextSize,
    @Cast("LPDWORD") int[] lpMessageCount,
    @Cast("LPDWORD") int[] lpReadTimeout
    );

public static native @Cast("BOOL") boolean SetMailslotInfo(
    @Cast("HANDLE") Pointer hMailslot,
    @Cast("DWORD") int lReadTimeout
    );

//
// File Encryption API
//

public static native @Cast("BOOL") boolean EncryptFileA(
    @Cast("LPCSTR") BytePointer lpFileName
    );
public static native @Cast("BOOL") boolean EncryptFileA(
    @Cast("LPCSTR") ByteBuffer lpFileName
    );
public static native @Cast("BOOL") boolean EncryptFileA(
    @Cast("LPCSTR") byte[] lpFileName
    );
public static native @Cast("BOOL") boolean EncryptFileA(
    @Cast("LPCSTR") String lpFileName
    );
public static native @Cast("BOOL") boolean EncryptFileW(
    @Cast("LPCWSTR") CharPointer lpFileName
    );
public static native @Cast("BOOL") boolean EncryptFileW(
    @Cast("LPCWSTR") CharBuffer lpFileName
    );
public static native @Cast("BOOL") boolean EncryptFileW(
    @Cast("LPCWSTR") char[] lpFileName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean DecryptFileA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("DWORD") int dwReserved
    );
public static native @Cast("BOOL") boolean DecryptFileA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("DWORD") int dwReserved
    );
public static native @Cast("BOOL") boolean DecryptFileA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("DWORD") int dwReserved
    );
public static native @Cast("BOOL") boolean DecryptFileA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("DWORD") int dwReserved
    );
public static native @Cast("BOOL") boolean DecryptFileW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("DWORD") int dwReserved
    );
public static native @Cast("BOOL") boolean DecryptFileW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("DWORD") int dwReserved
    );
public static native @Cast("BOOL") boolean DecryptFileW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("DWORD") int dwReserved
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

//
//  Encryption Status Value
//

public static final int FILE_ENCRYPTABLE =                0;
public static final int FILE_IS_ENCRYPTED =               1;
public static final int FILE_SYSTEM_ATTR =                2;
public static final int FILE_ROOT_DIR =                   3;
public static final int FILE_SYSTEM_DIR =                 4;
public static final int FILE_UNKNOWN =                    5;
public static final int FILE_SYSTEM_NOT_SUPPORT =         6;
public static final int FILE_USER_DISALLOWED =            7;
public static final int FILE_READ_ONLY =                  8;
public static final int FILE_DIR_DISALLOWED =             9;

public static native @Cast("BOOL") boolean FileEncryptionStatusA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("LPDWORD") IntPointer lpStatus
    );
public static native @Cast("BOOL") boolean FileEncryptionStatusA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("LPDWORD") IntBuffer lpStatus
    );
public static native @Cast("BOOL") boolean FileEncryptionStatusA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("LPDWORD") int[] lpStatus
    );
public static native @Cast("BOOL") boolean FileEncryptionStatusA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("LPDWORD") IntPointer lpStatus
    );
public static native @Cast("BOOL") boolean FileEncryptionStatusA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("LPDWORD") IntBuffer lpStatus
    );
public static native @Cast("BOOL") boolean FileEncryptionStatusA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("LPDWORD") int[] lpStatus
    );
public static native @Cast("BOOL") boolean FileEncryptionStatusA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("LPDWORD") IntPointer lpStatus
    );
public static native @Cast("BOOL") boolean FileEncryptionStatusA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("LPDWORD") IntBuffer lpStatus
    );
public static native @Cast("BOOL") boolean FileEncryptionStatusA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("LPDWORD") int[] lpStatus
    );
public static native @Cast("BOOL") boolean FileEncryptionStatusA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("LPDWORD") IntPointer lpStatus
    );
public static native @Cast("BOOL") boolean FileEncryptionStatusA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("LPDWORD") IntBuffer lpStatus
    );
public static native @Cast("BOOL") boolean FileEncryptionStatusA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("LPDWORD") int[] lpStatus
    );
public static native @Cast("BOOL") boolean FileEncryptionStatusW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("LPDWORD") IntPointer lpStatus
    );
public static native @Cast("BOOL") boolean FileEncryptionStatusW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("LPDWORD") IntBuffer lpStatus
    );
public static native @Cast("BOOL") boolean FileEncryptionStatusW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("LPDWORD") int[] lpStatus
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

//
// Currently defined recovery flags
//

public static final int EFS_USE_RECOVERY_KEYS =  (0x1);
// Targeting ..\windows\PFE_EXPORT_FUNC.java


// Targeting ..\windows\PFE_IMPORT_FUNC.java




//
//  OpenRaw flag values
//

public static final int CREATE_FOR_IMPORT =  (1);
public static final int CREATE_FOR_DIR =     (2);
public static final int OVERWRITE_HIDDEN =   (4);
public static final int EFSRPC_SECURE_ONLY = (8);


public static native @Cast("DWORD") int OpenEncryptedFileRawA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("ULONG") long ulFlags,
    @Cast("PVOID*") PointerPointer pvContext
    );
public static native @Cast("DWORD") int OpenEncryptedFileRawA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("ULONG") long ulFlags,
    @Cast("PVOID*") PointerPointer pvContext
    );
public static native @Cast("DWORD") int OpenEncryptedFileRawA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("ULONG") long ulFlags,
    @Cast("PVOID*") PointerPointer pvContext
    );
public static native @Cast("DWORD") int OpenEncryptedFileRawA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("ULONG") long ulFlags,
    @Cast("PVOID*") PointerPointer pvContext
    );
public static native @Cast("DWORD") int OpenEncryptedFileRawW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("ULONG") long ulFlags,
    @Cast("PVOID*") PointerPointer pvContext
    );
public static native @Cast("DWORD") int OpenEncryptedFileRawW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("ULONG") long ulFlags,
    @Cast("PVOID*") PointerPointer pvContext
    );
public static native @Cast("DWORD") int OpenEncryptedFileRawW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("ULONG") long ulFlags,
    @Cast("PVOID*") PointerPointer pvContext
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("DWORD") int ReadEncryptedFileRaw(
    PFE_EXPORT_FUNC pfExportCallback,
    @Cast("PVOID") Pointer pvCallbackContext,
    @Cast("PVOID") Pointer pvContext
    );

public static native @Cast("DWORD") int WriteEncryptedFileRaw(
    PFE_IMPORT_FUNC pfImportCallback,
    @Cast("PVOID") Pointer pvCallbackContext,
    @Cast("PVOID") Pointer pvContext
    );

public static native void CloseEncryptedFileRaw(
    @Cast("PVOID") Pointer pvContext
    );

//
// _l Compat Functions
//

public static native int lstrcmpA(
    @Cast("LPCSTR") BytePointer lpString1,
    @Cast("LPCSTR") BytePointer lpString2
    );
public static native int lstrcmpA(
    @Cast("LPCSTR") ByteBuffer lpString1,
    @Cast("LPCSTR") ByteBuffer lpString2
    );
public static native int lstrcmpA(
    @Cast("LPCSTR") byte[] lpString1,
    @Cast("LPCSTR") byte[] lpString2
    );
public static native int lstrcmpA(
    @Cast("LPCSTR") String lpString1,
    @Cast("LPCSTR") String lpString2
    );
public static native int lstrcmpW(
    @Cast("LPCWSTR") CharPointer lpString1,
    @Cast("LPCWSTR") CharPointer lpString2
    );
public static native int lstrcmpW(
    @Cast("LPCWSTR") CharBuffer lpString1,
    @Cast("LPCWSTR") CharBuffer lpString2
    );
public static native int lstrcmpW(
    @Cast("LPCWSTR") char[] lpString1,
    @Cast("LPCWSTR") char[] lpString2
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native int lstrcmpiA(
    @Cast("LPCSTR") BytePointer lpString1,
    @Cast("LPCSTR") BytePointer lpString2
    );
public static native int lstrcmpiA(
    @Cast("LPCSTR") ByteBuffer lpString1,
    @Cast("LPCSTR") ByteBuffer lpString2
    );
public static native int lstrcmpiA(
    @Cast("LPCSTR") byte[] lpString1,
    @Cast("LPCSTR") byte[] lpString2
    );
public static native int lstrcmpiA(
    @Cast("LPCSTR") String lpString1,
    @Cast("LPCSTR") String lpString2
    );
public static native int lstrcmpiW(
    @Cast("LPCWSTR") CharPointer lpString1,
    @Cast("LPCWSTR") CharPointer lpString2
    );
public static native int lstrcmpiW(
    @Cast("LPCWSTR") CharBuffer lpString1,
    @Cast("LPCWSTR") CharBuffer lpString2
    );
public static native int lstrcmpiW(
    @Cast("LPCWSTR") char[] lpString1,
    @Cast("LPCWSTR") char[] lpString2
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("LPSTR") BytePointer lstrcpynA(
    @Cast("LPSTR") BytePointer lpString1,
    @Cast("LPCSTR") BytePointer lpString2,
    int iMaxLength
    );
public static native @Cast("LPSTR") ByteBuffer lstrcpynA(
    @Cast("LPSTR") ByteBuffer lpString1,
    @Cast("LPCSTR") ByteBuffer lpString2,
    int iMaxLength
    );
public static native @Cast("LPSTR") byte[] lstrcpynA(
    @Cast("LPSTR") byte[] lpString1,
    @Cast("LPCSTR") byte[] lpString2,
    int iMaxLength
    );
public static native @Cast("LPSTR") BytePointer lstrcpynA(
    @Cast("LPSTR") BytePointer lpString1,
    @Cast("LPCSTR") String lpString2,
    int iMaxLength
    );
public static native @Cast("LPSTR") ByteBuffer lstrcpynA(
    @Cast("LPSTR") ByteBuffer lpString1,
    @Cast("LPCSTR") BytePointer lpString2,
    int iMaxLength
    );
public static native @Cast("LPSTR") byte[] lstrcpynA(
    @Cast("LPSTR") byte[] lpString1,
    @Cast("LPCSTR") ByteBuffer lpString2,
    int iMaxLength
    );
public static native @Cast("LPSTR") BytePointer lstrcpynA(
    @Cast("LPSTR") BytePointer lpString1,
    @Cast("LPCSTR") byte[] lpString2,
    int iMaxLength
    );
public static native @Cast("LPSTR") ByteBuffer lstrcpynA(
    @Cast("LPSTR") ByteBuffer lpString1,
    @Cast("LPCSTR") String lpString2,
    int iMaxLength
    );
public static native @Cast("LPSTR") byte[] lstrcpynA(
    @Cast("LPSTR") byte[] lpString1,
    @Cast("LPCSTR") BytePointer lpString2,
    int iMaxLength
    );
public static native @Cast("LPSTR") BytePointer lstrcpynA(
    @Cast("LPSTR") BytePointer lpString1,
    @Cast("LPCSTR") ByteBuffer lpString2,
    int iMaxLength
    );
public static native @Cast("LPSTR") ByteBuffer lstrcpynA(
    @Cast("LPSTR") ByteBuffer lpString1,
    @Cast("LPCSTR") byte[] lpString2,
    int iMaxLength
    );
public static native @Cast("LPSTR") byte[] lstrcpynA(
    @Cast("LPSTR") byte[] lpString1,
    @Cast("LPCSTR") String lpString2,
    int iMaxLength
    );
public static native @Cast("LPWSTR") CharPointer lstrcpynW(
    @Cast("LPWSTR") CharPointer lpString1,
    @Cast("LPCWSTR") CharPointer lpString2,
    int iMaxLength
    );
public static native @Cast("LPWSTR") CharBuffer lstrcpynW(
    @Cast("LPWSTR") CharBuffer lpString1,
    @Cast("LPCWSTR") CharBuffer lpString2,
    int iMaxLength
    );
public static native @Cast("LPWSTR") char[] lstrcpynW(
    @Cast("LPWSTR") char[] lpString1,
    @Cast("LPCWSTR") char[] lpString2,
    int iMaxLength
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #if defined(DEPRECATE_SUPPORTED)
// #pragma warning(push)
// #pragma warning(disable:4995)
// #endif

public static native @Cast("LPSTR") BytePointer lstrcpyA(
    @Cast("LPSTR") BytePointer lpString1,
    @Cast("LPCSTR") BytePointer lpString2
    );
public static native @Cast("LPSTR") ByteBuffer lstrcpyA(
    @Cast("LPSTR") ByteBuffer lpString1,
    @Cast("LPCSTR") ByteBuffer lpString2
    );
public static native @Cast("LPSTR") byte[] lstrcpyA(
    @Cast("LPSTR") byte[] lpString1,
    @Cast("LPCSTR") byte[] lpString2
    );
public static native @Cast("LPSTR") BytePointer lstrcpyA(
    @Cast("LPSTR") BytePointer lpString1,
    @Cast("LPCSTR") String lpString2
    );
public static native @Cast("LPSTR") ByteBuffer lstrcpyA(
    @Cast("LPSTR") ByteBuffer lpString1,
    @Cast("LPCSTR") BytePointer lpString2
    );
public static native @Cast("LPSTR") byte[] lstrcpyA(
    @Cast("LPSTR") byte[] lpString1,
    @Cast("LPCSTR") ByteBuffer lpString2
    );
public static native @Cast("LPSTR") BytePointer lstrcpyA(
    @Cast("LPSTR") BytePointer lpString1,
    @Cast("LPCSTR") byte[] lpString2
    );
public static native @Cast("LPSTR") ByteBuffer lstrcpyA(
    @Cast("LPSTR") ByteBuffer lpString1,
    @Cast("LPCSTR") String lpString2
    );
public static native @Cast("LPSTR") byte[] lstrcpyA(
    @Cast("LPSTR") byte[] lpString1,
    @Cast("LPCSTR") BytePointer lpString2
    );
public static native @Cast("LPSTR") BytePointer lstrcpyA(
    @Cast("LPSTR") BytePointer lpString1,
    @Cast("LPCSTR") ByteBuffer lpString2
    );
public static native @Cast("LPSTR") ByteBuffer lstrcpyA(
    @Cast("LPSTR") ByteBuffer lpString1,
    @Cast("LPCSTR") byte[] lpString2
    );
public static native @Cast("LPSTR") byte[] lstrcpyA(
    @Cast("LPSTR") byte[] lpString1,
    @Cast("LPCSTR") String lpString2
    );
public static native @Cast("LPWSTR") CharPointer lstrcpyW(
    @Cast("LPWSTR") CharPointer lpString1,
    @Cast("LPCWSTR") CharPointer lpString2
    );
public static native @Cast("LPWSTR") CharBuffer lstrcpyW(
    @Cast("LPWSTR") CharBuffer lpString1,
    @Cast("LPCWSTR") CharBuffer lpString2
    );
public static native @Cast("LPWSTR") char[] lstrcpyW(
    @Cast("LPWSTR") char[] lpString1,
    @Cast("LPCWSTR") char[] lpString2
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("LPSTR") BytePointer lstrcatA(
    @Cast("LPSTR") BytePointer lpString1,
    @Cast("LPCSTR") BytePointer lpString2
    );
public static native @Cast("LPSTR") ByteBuffer lstrcatA(
    @Cast("LPSTR") ByteBuffer lpString1,
    @Cast("LPCSTR") ByteBuffer lpString2
    );
public static native @Cast("LPSTR") byte[] lstrcatA(
    @Cast("LPSTR") byte[] lpString1,
    @Cast("LPCSTR") byte[] lpString2
    );
public static native @Cast("LPSTR") BytePointer lstrcatA(
    @Cast("LPSTR") BytePointer lpString1,
    @Cast("LPCSTR") String lpString2
    );
public static native @Cast("LPSTR") ByteBuffer lstrcatA(
    @Cast("LPSTR") ByteBuffer lpString1,
    @Cast("LPCSTR") BytePointer lpString2
    );
public static native @Cast("LPSTR") byte[] lstrcatA(
    @Cast("LPSTR") byte[] lpString1,
    @Cast("LPCSTR") ByteBuffer lpString2
    );
public static native @Cast("LPSTR") BytePointer lstrcatA(
    @Cast("LPSTR") BytePointer lpString1,
    @Cast("LPCSTR") byte[] lpString2
    );
public static native @Cast("LPSTR") ByteBuffer lstrcatA(
    @Cast("LPSTR") ByteBuffer lpString1,
    @Cast("LPCSTR") String lpString2
    );
public static native @Cast("LPSTR") byte[] lstrcatA(
    @Cast("LPSTR") byte[] lpString1,
    @Cast("LPCSTR") BytePointer lpString2
    );
public static native @Cast("LPSTR") BytePointer lstrcatA(
    @Cast("LPSTR") BytePointer lpString1,
    @Cast("LPCSTR") ByteBuffer lpString2
    );
public static native @Cast("LPSTR") ByteBuffer lstrcatA(
    @Cast("LPSTR") ByteBuffer lpString1,
    @Cast("LPCSTR") byte[] lpString2
    );
public static native @Cast("LPSTR") byte[] lstrcatA(
    @Cast("LPSTR") byte[] lpString1,
    @Cast("LPCSTR") String lpString2
    );
public static native @Cast("LPWSTR") CharPointer lstrcatW(
    @Cast("LPWSTR") CharPointer lpString1,
    @Cast("LPCWSTR") CharPointer lpString2
    );
public static native @Cast("LPWSTR") CharBuffer lstrcatW(
    @Cast("LPWSTR") CharBuffer lpString1,
    @Cast("LPCWSTR") CharBuffer lpString2
    );
public static native @Cast("LPWSTR") char[] lstrcatW(
    @Cast("LPWSTR") char[] lpString1,
    @Cast("LPCWSTR") char[] lpString2
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #if defined(DEPRECATE_SUPPORTED)
// #pragma warning(pop)
// #endif

public static native int lstrlenA(
    @Cast("LPCSTR") BytePointer lpString
    );
public static native int lstrlenA(
    @Cast("LPCSTR") ByteBuffer lpString
    );
public static native int lstrlenA(
    @Cast("LPCSTR") byte[] lpString
    );
public static native int lstrlenA(
    @Cast("LPCSTR") String lpString
    );
public static native int lstrlenW(
    @Cast("LPCWSTR") CharPointer lpString
    );
public static native int lstrlenW(
    @Cast("LPCWSTR") CharBuffer lpString
    );
public static native int lstrlenW(
    @Cast("LPCWSTR") char[] lpString
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("HFILE") int OpenFile(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("LPOFSTRUCT") OFSTRUCT lpReOpenBuff,
    @Cast("UINT") int uStyle
    );
public static native @Cast("HFILE") int OpenFile(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("LPOFSTRUCT") OFSTRUCT lpReOpenBuff,
    @Cast("UINT") int uStyle
    );
public static native @Cast("HFILE") int OpenFile(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("LPOFSTRUCT") OFSTRUCT lpReOpenBuff,
    @Cast("UINT") int uStyle
    );
public static native @Cast("HFILE") int OpenFile(
    @Cast("LPCSTR") String lpFileName,
    @Cast("LPOFSTRUCT") OFSTRUCT lpReOpenBuff,
    @Cast("UINT") int uStyle
    );

public static native @Cast("HFILE") int _lopen(
    @Cast("LPCSTR") BytePointer lpPathName,
    int iReadWrite
    );
public static native @Cast("HFILE") int _lopen(
    @Cast("LPCSTR") ByteBuffer lpPathName,
    int iReadWrite
    );
public static native @Cast("HFILE") int _lopen(
    @Cast("LPCSTR") byte[] lpPathName,
    int iReadWrite
    );
public static native @Cast("HFILE") int _lopen(
    @Cast("LPCSTR") String lpPathName,
    int iReadWrite
    );

public static native @Cast("HFILE") int _lcreat(
    @Cast("LPCSTR") BytePointer lpPathName,
    int iAttribute
    );
public static native @Cast("HFILE") int _lcreat(
    @Cast("LPCSTR") ByteBuffer lpPathName,
    int iAttribute
    );
public static native @Cast("HFILE") int _lcreat(
    @Cast("LPCSTR") byte[] lpPathName,
    int iAttribute
    );
public static native @Cast("HFILE") int _lcreat(
    @Cast("LPCSTR") String lpPathName,
    int iAttribute
    );

public static native @Cast("UINT") int _lread(
    @Cast("HFILE") int hFile,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("UINT") int uBytes
    );

public static native @Cast("UINT") int _lwrite(
    @Cast("HFILE") int hFile,
    @Cast("LPCCH") BytePointer lpBuffer,
    @Cast("UINT") int uBytes
    );
public static native @Cast("UINT") int _lwrite(
    @Cast("HFILE") int hFile,
    @Cast("LPCCH") ByteBuffer lpBuffer,
    @Cast("UINT") int uBytes
    );
public static native @Cast("UINT") int _lwrite(
    @Cast("HFILE") int hFile,
    @Cast("LPCCH") byte[] lpBuffer,
    @Cast("UINT") int uBytes
    );
public static native @Cast("UINT") int _lwrite(
    @Cast("HFILE") int hFile,
    @Cast("LPCCH") String lpBuffer,
    @Cast("UINT") int uBytes
    );

public static native long _hread(
    @Cast("HFILE") int hFile,
    @Cast("LPVOID") Pointer lpBuffer,
    long lBytes
    );

public static native long _hwrite(
    @Cast("HFILE") int hFile,
    @Cast("LPCCH") BytePointer lpBuffer,
    long lBytes
    );
public static native long _hwrite(
    @Cast("HFILE") int hFile,
    @Cast("LPCCH") ByteBuffer lpBuffer,
    long lBytes
    );
public static native long _hwrite(
    @Cast("HFILE") int hFile,
    @Cast("LPCCH") byte[] lpBuffer,
    long lBytes
    );
public static native long _hwrite(
    @Cast("HFILE") int hFile,
    @Cast("LPCCH") String lpBuffer,
    long lBytes
    );

public static native @Cast("HFILE") int _lclose(
    @Cast("HFILE") int hFile
    );

public static native @Cast("LONG") int _llseek(
    @Cast("HFILE") int hFile,
    @Cast("LONG") int lOffset,
    int iOrigin
    );

public static native @Cast("BOOL") boolean IsTextUnicode(
    @Const Pointer lpv,
    int iSize,
    @Cast("LPINT") IntPointer lpiResult
    );
public static native @Cast("BOOL") boolean IsTextUnicode(
    @Const Pointer lpv,
    int iSize,
    @Cast("LPINT") IntBuffer lpiResult
    );
public static native @Cast("BOOL") boolean IsTextUnicode(
    @Const Pointer lpv,
    int iSize,
    @Cast("LPINT") int[] lpiResult
    );

// #if(_WIN32_WINNT >= 0x0400)
// #endif /* _WIN32_WINNT >= 0x0400 */

public static native @Cast("BOOL") boolean BackupRead(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPBYTE") BytePointer lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToRead,
    @Cast("LPDWORD") IntPointer lpNumberOfBytesRead,
    @Cast("BOOL") boolean bAbort,
    @Cast("BOOL") boolean bProcessSecurity,
    @Cast("LPVOID*") PointerPointer lpContext
    );
public static native @Cast("BOOL") boolean BackupRead(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPBYTE") ByteBuffer lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToRead,
    @Cast("LPDWORD") IntBuffer lpNumberOfBytesRead,
    @Cast("BOOL") boolean bAbort,
    @Cast("BOOL") boolean bProcessSecurity,
    @Cast("LPVOID*") PointerPointer lpContext
    );
public static native @Cast("BOOL") boolean BackupRead(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPBYTE") byte[] lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToRead,
    @Cast("LPDWORD") int[] lpNumberOfBytesRead,
    @Cast("BOOL") boolean bAbort,
    @Cast("BOOL") boolean bProcessSecurity,
    @Cast("LPVOID*") PointerPointer lpContext
    );

public static native @Cast("BOOL") boolean BackupSeek(
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwLowBytesToSeek,
    @Cast("DWORD") int dwHighBytesToSeek,
    @Cast("LPDWORD") IntPointer lpdwLowByteSeeked,
    @Cast("LPDWORD") IntPointer lpdwHighByteSeeked,
    @Cast("LPVOID*") PointerPointer lpContext
    );
public static native @Cast("BOOL") boolean BackupSeek(
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwLowBytesToSeek,
    @Cast("DWORD") int dwHighBytesToSeek,
    @Cast("LPDWORD") IntBuffer lpdwLowByteSeeked,
    @Cast("LPDWORD") IntBuffer lpdwHighByteSeeked,
    @Cast("LPVOID*") PointerPointer lpContext
    );
public static native @Cast("BOOL") boolean BackupSeek(
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int dwLowBytesToSeek,
    @Cast("DWORD") int dwHighBytesToSeek,
    @Cast("LPDWORD") int[] lpdwLowByteSeeked,
    @Cast("LPDWORD") int[] lpdwHighByteSeeked,
    @Cast("LPVOID*") PointerPointer lpContext
    );

public static native @Cast("BOOL") boolean BackupWrite(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPBYTE") BytePointer lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToWrite,
    @Cast("LPDWORD") IntPointer lpNumberOfBytesWritten,
    @Cast("BOOL") boolean bAbort,
    @Cast("BOOL") boolean bProcessSecurity,
    @Cast("LPVOID*") PointerPointer lpContext
    );
public static native @Cast("BOOL") boolean BackupWrite(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPBYTE") ByteBuffer lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToWrite,
    @Cast("LPDWORD") IntBuffer lpNumberOfBytesWritten,
    @Cast("BOOL") boolean bAbort,
    @Cast("BOOL") boolean bProcessSecurity,
    @Cast("LPVOID*") PointerPointer lpContext
    );
public static native @Cast("BOOL") boolean BackupWrite(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPBYTE") byte[] lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToWrite,
    @Cast("LPDWORD") int[] lpNumberOfBytesWritten,
    @Cast("BOOL") boolean bAbort,
    @Cast("BOOL") boolean bProcessSecurity,
    @Cast("LPVOID*") PointerPointer lpContext
    );
// Targeting ..\windows\WIN32_STREAM_ID.java



//
//  Stream Ids
//

public static final int BACKUP_INVALID =          0x00000000;
public static final int BACKUP_DATA =             0x00000001;
public static final int BACKUP_EA_DATA =          0x00000002;
public static final int BACKUP_SECURITY_DATA =    0x00000003;
public static final int BACKUP_ALTERNATE_DATA =   0x00000004;
public static final int BACKUP_LINK =             0x00000005;
public static final int BACKUP_PROPERTY_DATA =    0x00000006;
public static final int BACKUP_OBJECT_ID =        0x00000007;
public static final int BACKUP_REPARSE_DATA =     0x00000008;
public static final int BACKUP_SPARSE_BLOCK =     0x00000009;
public static final int BACKUP_TXFS_DATA =        0x0000000a;


//
//  Stream Attributes
//

public static final int STREAM_NORMAL_ATTRIBUTE =         0x00000000;
public static final int STREAM_MODIFIED_WHEN_READ =       0x00000001;
public static final int STREAM_CONTAINS_SECURITY =        0x00000002;
public static final int STREAM_CONTAINS_PROPERTIES =      0x00000004;
public static final int STREAM_SPARSE_ATTRIBUTE =         0x00000008;

//
// Dual Mode API below this line. Dual Mode Structures also included.
//

public static final int STARTF_USESHOWWINDOW =       0x00000001;
public static final int STARTF_USESIZE =             0x00000002;
public static final int STARTF_USEPOSITION =         0x00000004;
public static final int STARTF_USECOUNTCHARS =       0x00000008;
public static final int STARTF_USEFILLATTRIBUTE =    0x00000010;
public static final int STARTF_RUNFULLSCREEN =       0x00000020;  // ignored for non-x86 platforms
public static final int STARTF_FORCEONFEEDBACK =     0x00000040;
public static final int STARTF_FORCEOFFFEEDBACK =    0x00000080;
public static final int STARTF_USESTDHANDLES =       0x00000100;

// #if(WINVER >= 0x0400)

public static final int STARTF_USEHOTKEY =           0x00000200;
public static final int STARTF_TITLEISLINKNAME =     0x00000800;
public static final int STARTF_TITLEISAPPID =        0x00001000;
public static final int STARTF_PREVENTPINNING =      0x00002000;
// Targeting ..\windows\STARTUPINFOEXA.java


// Targeting ..\windows\STARTUPINFOEXW.java


// #ifdef UNICODE
// #else
// #endif // UNICODE

// #endif // (_WIN32_WINNT >= 0x0600)

public static final int SHUTDOWN_NORETRY =                0x00000001;

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("HANDLE") Pointer OpenMutexA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") BytePointer lpName
    );
public static native @Cast("HANDLE") Pointer OpenMutexA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") ByteBuffer lpName
    );
public static native @Cast("HANDLE") Pointer OpenMutexA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") byte[] lpName
    );
public static native @Cast("HANDLE") Pointer OpenMutexA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") String lpName
    );
// #ifndef UNICODE
// #endif

public static native @Cast("HANDLE") Pointer CreateSemaphoreA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSemaphoreAttributes,
    @Cast("LONG") int lInitialCount,
    @Cast("LONG") int lMaximumCount,
    @Cast("LPCSTR") BytePointer lpName
    );
public static native @Cast("HANDLE") Pointer CreateSemaphoreA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSemaphoreAttributes,
    @Cast("LONG") int lInitialCount,
    @Cast("LONG") int lMaximumCount,
    @Cast("LPCSTR") ByteBuffer lpName
    );
public static native @Cast("HANDLE") Pointer CreateSemaphoreA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSemaphoreAttributes,
    @Cast("LONG") int lInitialCount,
    @Cast("LONG") int lMaximumCount,
    @Cast("LPCSTR") byte[] lpName
    );
public static native @Cast("HANDLE") Pointer CreateSemaphoreA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSemaphoreAttributes,
    @Cast("LONG") int lInitialCount,
    @Cast("LONG") int lMaximumCount,
    @Cast("LPCSTR") String lpName
    );
public static native @Cast("HANDLE") Pointer CreateSemaphoreW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSemaphoreAttributes,
    @Cast("LONG") int lInitialCount,
    @Cast("LONG") int lMaximumCount,
    @Cast("LPCWSTR") CharPointer lpName
    );
public static native @Cast("HANDLE") Pointer CreateSemaphoreW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSemaphoreAttributes,
    @Cast("LONG") int lInitialCount,
    @Cast("LONG") int lMaximumCount,
    @Cast("LPCWSTR") CharBuffer lpName
    );
public static native @Cast("HANDLE") Pointer CreateSemaphoreW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSemaphoreAttributes,
    @Cast("LONG") int lInitialCount,
    @Cast("LONG") int lMaximumCount,
    @Cast("LPCWSTR") char[] lpName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("HANDLE") Pointer OpenSemaphoreA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") BytePointer lpName
    );
public static native @Cast("HANDLE") Pointer OpenSemaphoreA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") ByteBuffer lpName
    );
public static native @Cast("HANDLE") Pointer OpenSemaphoreA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") byte[] lpName
    );
public static native @Cast("HANDLE") Pointer OpenSemaphoreA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") String lpName
    );
// #ifndef UNICODE
// #endif

// #if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)

public static native @Cast("HANDLE") Pointer CreateWaitableTimerA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpTimerAttributes,
    @Cast("BOOL") boolean bManualReset,
    @Cast("LPCSTR") BytePointer lpTimerName
    );
public static native @Cast("HANDLE") Pointer CreateWaitableTimerA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpTimerAttributes,
    @Cast("BOOL") boolean bManualReset,
    @Cast("LPCSTR") ByteBuffer lpTimerName
    );
public static native @Cast("HANDLE") Pointer CreateWaitableTimerA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpTimerAttributes,
    @Cast("BOOL") boolean bManualReset,
    @Cast("LPCSTR") byte[] lpTimerName
    );
public static native @Cast("HANDLE") Pointer CreateWaitableTimerA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpTimerAttributes,
    @Cast("BOOL") boolean bManualReset,
    @Cast("LPCSTR") String lpTimerName
    );
public static native @Cast("HANDLE") Pointer CreateWaitableTimerW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpTimerAttributes,
    @Cast("BOOL") boolean bManualReset,
    @Cast("LPCWSTR") CharPointer lpTimerName
    );
public static native @Cast("HANDLE") Pointer CreateWaitableTimerW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpTimerAttributes,
    @Cast("BOOL") boolean bManualReset,
    @Cast("LPCWSTR") CharBuffer lpTimerName
    );
public static native @Cast("HANDLE") Pointer CreateWaitableTimerW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpTimerAttributes,
    @Cast("BOOL") boolean bManualReset,
    @Cast("LPCWSTR") char[] lpTimerName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("HANDLE") Pointer OpenWaitableTimerA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") BytePointer lpTimerName
    );
public static native @Cast("HANDLE") Pointer OpenWaitableTimerA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") ByteBuffer lpTimerName
    );
public static native @Cast("HANDLE") Pointer OpenWaitableTimerA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") byte[] lpTimerName
    );
public static native @Cast("HANDLE") Pointer OpenWaitableTimerA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") String lpTimerName
    );
// #ifndef UNICODE
// #endif

// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("HANDLE") Pointer CreateSemaphoreExA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSemaphoreAttributes,
    @Cast("LONG") int lInitialCount,
    @Cast("LONG") int lMaximumCount,
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateSemaphoreExA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSemaphoreAttributes,
    @Cast("LONG") int lInitialCount,
    @Cast("LONG") int lMaximumCount,
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateSemaphoreExA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSemaphoreAttributes,
    @Cast("LONG") int lInitialCount,
    @Cast("LONG") int lMaximumCount,
    @Cast("LPCSTR") byte[] lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateSemaphoreExA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSemaphoreAttributes,
    @Cast("LONG") int lInitialCount,
    @Cast("LONG") int lMaximumCount,
    @Cast("LPCSTR") String lpName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
// #ifndef UNICODE
// #endif

public static native @Cast("HANDLE") Pointer CreateWaitableTimerExA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpTimerAttributes,
    @Cast("LPCSTR") BytePointer lpTimerName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateWaitableTimerExA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpTimerAttributes,
    @Cast("LPCSTR") ByteBuffer lpTimerName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateWaitableTimerExA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpTimerAttributes,
    @Cast("LPCSTR") byte[] lpTimerName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
public static native @Cast("HANDLE") Pointer CreateWaitableTimerExA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpTimerAttributes,
    @Cast("LPCSTR") String lpTimerName,
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int dwDesiredAccess
    );
// #ifndef UNICODE
// #endif

// #endif /* (_WIN32_WINNT >= 0x0600) */

// #endif /* (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400) */

public static native @Cast("HANDLE") Pointer CreateFileMappingA(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpFileMappingAttributes,
    @Cast("DWORD") int flProtect,
    @Cast("DWORD") int dwMaximumSizeHigh,
    @Cast("DWORD") int dwMaximumSizeLow,
    @Cast("LPCSTR") BytePointer lpName
    );
public static native @Cast("HANDLE") Pointer CreateFileMappingA(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpFileMappingAttributes,
    @Cast("DWORD") int flProtect,
    @Cast("DWORD") int dwMaximumSizeHigh,
    @Cast("DWORD") int dwMaximumSizeLow,
    @Cast("LPCSTR") ByteBuffer lpName
    );
public static native @Cast("HANDLE") Pointer CreateFileMappingA(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpFileMappingAttributes,
    @Cast("DWORD") int flProtect,
    @Cast("DWORD") int dwMaximumSizeHigh,
    @Cast("DWORD") int dwMaximumSizeLow,
    @Cast("LPCSTR") byte[] lpName
    );
public static native @Cast("HANDLE") Pointer CreateFileMappingA(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpFileMappingAttributes,
    @Cast("DWORD") int flProtect,
    @Cast("DWORD") int dwMaximumSizeHigh,
    @Cast("DWORD") int dwMaximumSizeLow,
    @Cast("LPCSTR") String lpName
    );
// #ifndef UNICODE
// #endif

// #if _WIN32_WINNT >= 0x0600

public static native @Cast("HANDLE") Pointer CreateFileMappingNumaA(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpFileMappingAttributes,
    @Cast("DWORD") int flProtect,
    @Cast("DWORD") int dwMaximumSizeHigh,
    @Cast("DWORD") int dwMaximumSizeLow,
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("DWORD") int nndPreferred
    );
public static native @Cast("HANDLE") Pointer CreateFileMappingNumaA(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpFileMappingAttributes,
    @Cast("DWORD") int flProtect,
    @Cast("DWORD") int dwMaximumSizeHigh,
    @Cast("DWORD") int dwMaximumSizeLow,
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("DWORD") int nndPreferred
    );
public static native @Cast("HANDLE") Pointer CreateFileMappingNumaA(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpFileMappingAttributes,
    @Cast("DWORD") int flProtect,
    @Cast("DWORD") int dwMaximumSizeHigh,
    @Cast("DWORD") int dwMaximumSizeLow,
    @Cast("LPCSTR") byte[] lpName,
    @Cast("DWORD") int nndPreferred
    );
public static native @Cast("HANDLE") Pointer CreateFileMappingNumaA(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpFileMappingAttributes,
    @Cast("DWORD") int flProtect,
    @Cast("DWORD") int dwMaximumSizeHigh,
    @Cast("DWORD") int dwMaximumSizeLow,
    @Cast("LPCSTR") String lpName,
    @Cast("DWORD") int nndPreferred
    );

// #ifndef UNICODE
// #endif

// #endif // _WIN32_WINNT >= 0x0600

public static native @Cast("HANDLE") Pointer OpenFileMappingA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") BytePointer lpName
    );
public static native @Cast("HANDLE") Pointer OpenFileMappingA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") ByteBuffer lpName
    );
public static native @Cast("HANDLE") Pointer OpenFileMappingA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") byte[] lpName
    );
public static native @Cast("HANDLE") Pointer OpenFileMappingA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") String lpName
    );
// #ifndef UNICODE
// #endif

public static native @Cast("DWORD") int GetLogicalDriveStringsA(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") BytePointer lpBuffer
    );
public static native @Cast("DWORD") int GetLogicalDriveStringsA(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") ByteBuffer lpBuffer
    );
public static native @Cast("DWORD") int GetLogicalDriveStringsA(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") byte[] lpBuffer
    );
// #ifndef UNICODE
// #endif


public static native @Cast("HMODULE") Pointer LoadLibraryA(
    @Cast("LPCSTR") BytePointer lpLibFileName
    );
public static native @Cast("HMODULE") Pointer LoadLibraryA(
    @Cast("LPCSTR") ByteBuffer lpLibFileName
    );
public static native @Cast("HMODULE") Pointer LoadLibraryA(
    @Cast("LPCSTR") byte[] lpLibFileName
    );
public static native @Cast("HMODULE") Pointer LoadLibraryA(
    @Cast("LPCSTR") String lpLibFileName
    );
public static native @Cast("HMODULE") Pointer LoadLibraryW(
    @Cast("LPCWSTR") CharPointer lpLibFileName
    );
public static native @Cast("HMODULE") Pointer LoadLibraryW(
    @Cast("LPCWSTR") CharBuffer lpLibFileName
    );
public static native @Cast("HMODULE") Pointer LoadLibraryW(
    @Cast("LPCWSTR") char[] lpLibFileName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

// #if (_WIN32_WINNT >= 0x0602)

// #endif // _WIN32_WINNT >= 0x0602

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// #if (_WIN32_WINNT >= 0x0600)

public static final int PROCESS_NAME_NATIVE =     0x00000001;

public static native @Cast("BOOL") boolean QueryFullProcessImageNameA(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("DWORD") int dwFlags,
    @Cast("LPSTR") BytePointer lpExeName,
    @Cast("PDWORD") IntPointer lpdwSize
    );
public static native @Cast("BOOL") boolean QueryFullProcessImageNameA(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("DWORD") int dwFlags,
    @Cast("LPSTR") ByteBuffer lpExeName,
    @Cast("PDWORD") IntBuffer lpdwSize
    );
public static native @Cast("BOOL") boolean QueryFullProcessImageNameA(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("DWORD") int dwFlags,
    @Cast("LPSTR") byte[] lpExeName,
    @Cast("PDWORD") int[] lpdwSize
    );
public static native @Cast("BOOL") boolean QueryFullProcessImageNameW(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("DWORD") int dwFlags,
    @Cast("LPWSTR") CharPointer lpExeName,
    @Cast("PDWORD") IntPointer lpdwSize
    );
public static native @Cast("BOOL") boolean QueryFullProcessImageNameW(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("DWORD") int dwFlags,
    @Cast("LPWSTR") CharBuffer lpExeName,
    @Cast("PDWORD") IntBuffer lpdwSize
    );
public static native @Cast("BOOL") boolean QueryFullProcessImageNameW(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("DWORD") int dwFlags,
    @Cast("LPWSTR") char[] lpExeName,
    @Cast("PDWORD") int[] lpdwSize
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif

// #if (_WIN32_WINNT >= 0x0600)

//
// Extended process and thread attribute support
//

public static final int PROC_THREAD_ATTRIBUTE_NUMBER =    0x0000FFFF;
public static final int PROC_THREAD_ATTRIBUTE_THREAD =    0x00010000;  // Attribute may be used with thread creation
public static final int PROC_THREAD_ATTRIBUTE_INPUT =     0x00020000;  // Attribute is input only
public static final int PROC_THREAD_ATTRIBUTE_ADDITIVE =  0x00040000;  // Attribute may be "accumulated," e.g. bitmasks, counters, etc.


public static final int PROTECTION_LEVEL_SAME =               0xFFFFFFFF;

// #ifndef _USE_FULL_PROC_THREAD_ATTRIBUTE
/** enum PROC_THREAD_ATTRIBUTE_NUM */
public static final int
    ProcThreadAttributeParentProcess        = 0,
    ProcThreadAttributeHandleList           = 2,
// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
    ProcThreadAttributeGroupAffinity        = 3,
    ProcThreadAttributePreferredNode        = 4,
    ProcThreadAttributeIdealProcessor       = 5,
    ProcThreadAttributeUmsThread            = 6,
    ProcThreadAttributeMitigationPolicy     = 7,
// #endif
// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)
// #endif
    ProcThreadAttributeProtectionLevel      = 11;
// #endif

public static native int ProcThreadAttributeValue(int Number, int Thread, int Input, int Additive);

public static native @MemberGetter int PROC_THREAD_ATTRIBUTE_PARENT_PROCESS();
public static final int PROC_THREAD_ATTRIBUTE_PARENT_PROCESS = PROC_THREAD_ATTRIBUTE_PARENT_PROCESS();
public static native @MemberGetter int PROC_THREAD_ATTRIBUTE_HANDLE_LIST();
public static final int PROC_THREAD_ATTRIBUTE_HANDLE_LIST = PROC_THREAD_ATTRIBUTE_HANDLE_LIST();

// #endif // (_WIN32_WINNT >= 0x0600)

// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
public static native @MemberGetter int PROC_THREAD_ATTRIBUTE_GROUP_AFFINITY();
public static final int PROC_THREAD_ATTRIBUTE_GROUP_AFFINITY = PROC_THREAD_ATTRIBUTE_GROUP_AFFINITY();
public static native @MemberGetter int PROC_THREAD_ATTRIBUTE_PREFERRED_NODE();
public static final int PROC_THREAD_ATTRIBUTE_PREFERRED_NODE = PROC_THREAD_ATTRIBUTE_PREFERRED_NODE();
public static native @MemberGetter int PROC_THREAD_ATTRIBUTE_IDEAL_PROCESSOR();
public static final int PROC_THREAD_ATTRIBUTE_IDEAL_PROCESSOR = PROC_THREAD_ATTRIBUTE_IDEAL_PROCESSOR();
public static native @MemberGetter int PROC_THREAD_ATTRIBUTE_UMS_THREAD();
public static final int PROC_THREAD_ATTRIBUTE_UMS_THREAD = PROC_THREAD_ATTRIBUTE_UMS_THREAD();
public static native @MemberGetter int PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY();
public static final int PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY = PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY();
// #endif

// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)
// #endif

public static native @MemberGetter int PROC_THREAD_ATTRIBUTE_PROTECTION_LEVEL();
public static final int PROC_THREAD_ATTRIBUTE_PROTECTION_LEVEL = PROC_THREAD_ATTRIBUTE_PROTECTION_LEVEL();

// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
//
// Define legacy creation mitigation policy options, which are straight
// bitmasks.  Bits 0-5 are legacy bits.
//

public static final int PROCESS_CREATION_MITIGATION_POLICY_DEP_ENABLE =            0x01;
public static final int PROCESS_CREATION_MITIGATION_POLICY_DEP_ATL_THUNK_ENABLE =  0x02;
public static final int PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE =          0x04;
// #endif


// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)
// #endif // _WIN32_WINNT_WIN8


public static native @Cast("BOOL") boolean GetProcessShutdownParameters(
    @Cast("LPDWORD") IntPointer lpdwLevel,
    @Cast("LPDWORD") IntPointer lpdwFlags
    );
public static native @Cast("BOOL") boolean GetProcessShutdownParameters(
    @Cast("LPDWORD") IntBuffer lpdwLevel,
    @Cast("LPDWORD") IntBuffer lpdwFlags
    );
public static native @Cast("BOOL") boolean GetProcessShutdownParameters(
    @Cast("LPDWORD") int[] lpdwLevel,
    @Cast("LPDWORD") int[] lpdwFlags
    );

public static native void FatalAppExitA(
    @Cast("UINT") int uAction,
    @Cast("LPCSTR") BytePointer lpMessageText
    );
public static native void FatalAppExitA(
    @Cast("UINT") int uAction,
    @Cast("LPCSTR") ByteBuffer lpMessageText
    );
public static native void FatalAppExitA(
    @Cast("UINT") int uAction,
    @Cast("LPCSTR") byte[] lpMessageText
    );
public static native void FatalAppExitA(
    @Cast("UINT") int uAction,
    @Cast("LPCSTR") String lpMessageText
    );
public static native void FatalAppExitW(
    @Cast("UINT") int uAction,
    @Cast("LPCWSTR") CharPointer lpMessageText
    );
public static native void FatalAppExitW(
    @Cast("UINT") int uAction,
    @Cast("LPCWSTR") CharBuffer lpMessageText
    );
public static native void FatalAppExitW(
    @Cast("UINT") int uAction,
    @Cast("LPCWSTR") char[] lpMessageText
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native void GetStartupInfoA(
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo
    );
// #ifndef UNICODE
// #endif

// #if defined(_M_CEE)
// #undef GetEnvironmentVariable

// #if _MSC_VER >= 1400
// #pragma warning(push)
// #pragma warning(disable: 6103) 
// #endif _MSC_VER >= 1400 /* _MSC_VER >= 1400 */

public static native @Cast("DWORD") int GetEnvironmentVariable(
    @Cast("LPCTSTR") CharPointer lpName,
    @Cast("LPTSTR") CharPointer lpBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetEnvironmentVariable(
    @Cast("LPCTSTR") CharBuffer lpName,
    @Cast("LPTSTR") CharBuffer lpBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetEnvironmentVariable(
    @Cast("LPCTSTR") char[] lpName,
    @Cast("LPTSTR") char[] lpBuffer,
    @Cast("DWORD") int nSize
    );

// #if _MSC_VER >= 1400
// #pragma warning(pop)
// #endif _MSC_VER >= 1400 /* _MSC_VER >= 1400 */

// #endif  /* _M_CEE */

// #if defined(_M_CEE)
// #undef SetEnvironmentVariable
public static native @Cast("BOOL") boolean SetEnvironmentVariable(
    @Cast("LPCTSTR") CharPointer lpName,
    @Cast("LPCTSTR") CharPointer lpValue
    );
public static native @Cast("BOOL") boolean SetEnvironmentVariable(
    @Cast("LPCTSTR") CharBuffer lpName,
    @Cast("LPCTSTR") CharBuffer lpValue
    );
public static native @Cast("BOOL") boolean SetEnvironmentVariable(
    @Cast("LPCTSTR") char[] lpName,
    @Cast("LPCTSTR") char[] lpValue
    );
// #endif  /* _M_CEE */

public static native @Cast("DWORD") int GetFirmwareEnvironmentVariableA(
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("LPCSTR") BytePointer lpGuid,
    @Cast("PVOID") Pointer pBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetFirmwareEnvironmentVariableA(
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("LPCSTR") ByteBuffer lpGuid,
    @Cast("PVOID") Pointer pBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetFirmwareEnvironmentVariableA(
    @Cast("LPCSTR") byte[] lpName,
    @Cast("LPCSTR") byte[] lpGuid,
    @Cast("PVOID") Pointer pBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetFirmwareEnvironmentVariableA(
    @Cast("LPCSTR") String lpName,
    @Cast("LPCSTR") String lpGuid,
    @Cast("PVOID") Pointer pBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetFirmwareEnvironmentVariableW(
    @Cast("LPCWSTR") CharPointer lpName,
    @Cast("LPCWSTR") CharPointer lpGuid,
    @Cast("PVOID") Pointer pBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetFirmwareEnvironmentVariableW(
    @Cast("LPCWSTR") CharBuffer lpName,
    @Cast("LPCWSTR") CharBuffer lpGuid,
    @Cast("PVOID") Pointer pBuffer,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetFirmwareEnvironmentVariableW(
    @Cast("LPCWSTR") char[] lpName,
    @Cast("LPCWSTR") char[] lpGuid,
    @Cast("PVOID") Pointer pBuffer,
    @Cast("DWORD") int nSize
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)

// #endif

public static native @Cast("BOOL") boolean SetFirmwareEnvironmentVariableA(
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("LPCSTR") BytePointer lpGuid,
    @Cast("PVOID") Pointer pValue,
    @Cast("DWORD") int nSize
    );
public static native @Cast("BOOL") boolean SetFirmwareEnvironmentVariableA(
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("LPCSTR") ByteBuffer lpGuid,
    @Cast("PVOID") Pointer pValue,
    @Cast("DWORD") int nSize
    );
public static native @Cast("BOOL") boolean SetFirmwareEnvironmentVariableA(
    @Cast("LPCSTR") byte[] lpName,
    @Cast("LPCSTR") byte[] lpGuid,
    @Cast("PVOID") Pointer pValue,
    @Cast("DWORD") int nSize
    );
public static native @Cast("BOOL") boolean SetFirmwareEnvironmentVariableA(
    @Cast("LPCSTR") String lpName,
    @Cast("LPCSTR") String lpGuid,
    @Cast("PVOID") Pointer pValue,
    @Cast("DWORD") int nSize
    );
public static native @Cast("BOOL") boolean SetFirmwareEnvironmentVariableW(
    @Cast("LPCWSTR") CharPointer lpName,
    @Cast("LPCWSTR") CharPointer lpGuid,
    @Cast("PVOID") Pointer pValue,
    @Cast("DWORD") int nSize
    );
public static native @Cast("BOOL") boolean SetFirmwareEnvironmentVariableW(
    @Cast("LPCWSTR") CharBuffer lpName,
    @Cast("LPCWSTR") CharBuffer lpGuid,
    @Cast("PVOID") Pointer pValue,
    @Cast("DWORD") int nSize
    );
public static native @Cast("BOOL") boolean SetFirmwareEnvironmentVariableW(
    @Cast("LPCWSTR") char[] lpName,
    @Cast("LPCWSTR") char[] lpGuid,
    @Cast("PVOID") Pointer pValue,
    @Cast("DWORD") int nSize
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)

// #endif

// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)

// #endif // _WIN32_WINNT >= _WIN32_WINNT_WIN8

public static native @Cast("HRSRC") Pointer FindResourceA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("LPCSTR") BytePointer lpType
    );
public static native @Cast("HRSRC") Pointer FindResourceA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("LPCSTR") ByteBuffer lpType
    );
public static native @Cast("HRSRC") Pointer FindResourceA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") byte[] lpName,
    @Cast("LPCSTR") byte[] lpType
    );
public static native @Cast("HRSRC") Pointer FindResourceA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") String lpName,
    @Cast("LPCSTR") String lpType
    );
public static native @Cast("HRSRC") Pointer FindResourceW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") CharPointer lpName,
    @Cast("LPCWSTR") CharPointer lpType
    );
public static native @Cast("HRSRC") Pointer FindResourceW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") CharBuffer lpName,
    @Cast("LPCWSTR") CharBuffer lpType
    );
public static native @Cast("HRSRC") Pointer FindResourceW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") char[] lpName,
    @Cast("LPCWSTR") char[] lpType
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("HRSRC") Pointer FindResourceExA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") BytePointer lpType,
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("WORD") short wLanguage
    );
public static native @Cast("HRSRC") Pointer FindResourceExA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") ByteBuffer lpType,
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("WORD") short wLanguage
    );
public static native @Cast("HRSRC") Pointer FindResourceExA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") byte[] lpType,
    @Cast("LPCSTR") byte[] lpName,
    @Cast("WORD") short wLanguage
    );
public static native @Cast("HRSRC") Pointer FindResourceExA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") String lpType,
    @Cast("LPCSTR") String lpName,
    @Cast("WORD") short wLanguage
    );
// #ifndef UNICODE
// #endif

public static native @Cast("BOOL") boolean EnumResourceTypesA(
    @Cast("HMODULE") Pointer hModule,
    ENUMRESTYPEPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam
    );
public static native @Cast("BOOL") boolean EnumResourceTypesW(
    @Cast("HMODULE") Pointer hModule,
    ENUMRESTYPEPROCW lpEnumFunc,
    @Cast("LONG_PTR") long lParam
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean EnumResourceNamesA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") BytePointer lpType,
    ENUMRESNAMEPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam
    );
public static native @Cast("BOOL") boolean EnumResourceNamesA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") ByteBuffer lpType,
    ENUMRESNAMEPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam
    );
public static native @Cast("BOOL") boolean EnumResourceNamesA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") byte[] lpType,
    ENUMRESNAMEPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam
    );
public static native @Cast("BOOL") boolean EnumResourceNamesA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") String lpType,
    ENUMRESNAMEPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam
    );
public static native @Cast("BOOL") boolean EnumResourceNamesW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") CharPointer lpType,
    ENUMRESNAMEPROCW lpEnumFunc,
    @Cast("LONG_PTR") long lParam
    );
public static native @Cast("BOOL") boolean EnumResourceNamesW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") CharBuffer lpType,
    ENUMRESNAMEPROCW lpEnumFunc,
    @Cast("LONG_PTR") long lParam
    );
public static native @Cast("BOOL") boolean EnumResourceNamesW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") char[] lpType,
    ENUMRESNAMEPROCW lpEnumFunc,
    @Cast("LONG_PTR") long lParam
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean EnumResourceLanguagesA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") BytePointer lpType,
    @Cast("LPCSTR") BytePointer lpName,
    ENUMRESLANGPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam
    );
public static native @Cast("BOOL") boolean EnumResourceLanguagesA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") ByteBuffer lpType,
    @Cast("LPCSTR") ByteBuffer lpName,
    ENUMRESLANGPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam
    );
public static native @Cast("BOOL") boolean EnumResourceLanguagesA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") byte[] lpType,
    @Cast("LPCSTR") byte[] lpName,
    ENUMRESLANGPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam
    );
public static native @Cast("BOOL") boolean EnumResourceLanguagesA(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCSTR") String lpType,
    @Cast("LPCSTR") String lpName,
    ENUMRESLANGPROCA lpEnumFunc,
    @Cast("LONG_PTR") long lParam
    );
public static native @Cast("BOOL") boolean EnumResourceLanguagesW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") CharPointer lpType,
    @Cast("LPCWSTR") CharPointer lpName,
    ENUMRESLANGPROCW lpEnumFunc,
    @Cast("LONG_PTR") long lParam
    );
public static native @Cast("BOOL") boolean EnumResourceLanguagesW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") CharBuffer lpType,
    @Cast("LPCWSTR") CharBuffer lpName,
    ENUMRESLANGPROCW lpEnumFunc,
    @Cast("LONG_PTR") long lParam
    );
public static native @Cast("BOOL") boolean EnumResourceLanguagesW(
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPCWSTR") char[] lpType,
    @Cast("LPCWSTR") char[] lpName,
    ENUMRESLANGPROCW lpEnumFunc,
    @Cast("LONG_PTR") long lParam
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("HANDLE") Pointer BeginUpdateResourceA(
    @Cast("LPCSTR") BytePointer pFileName,
    @Cast("BOOL") boolean bDeleteExistingResources
    );
public static native @Cast("HANDLE") Pointer BeginUpdateResourceA(
    @Cast("LPCSTR") ByteBuffer pFileName,
    @Cast("BOOL") boolean bDeleteExistingResources
    );
public static native @Cast("HANDLE") Pointer BeginUpdateResourceA(
    @Cast("LPCSTR") byte[] pFileName,
    @Cast("BOOL") boolean bDeleteExistingResources
    );
public static native @Cast("HANDLE") Pointer BeginUpdateResourceA(
    @Cast("LPCSTR") String pFileName,
    @Cast("BOOL") boolean bDeleteExistingResources
    );
public static native @Cast("HANDLE") Pointer BeginUpdateResourceW(
    @Cast("LPCWSTR") CharPointer pFileName,
    @Cast("BOOL") boolean bDeleteExistingResources
    );
public static native @Cast("HANDLE") Pointer BeginUpdateResourceW(
    @Cast("LPCWSTR") CharBuffer pFileName,
    @Cast("BOOL") boolean bDeleteExistingResources
    );
public static native @Cast("HANDLE") Pointer BeginUpdateResourceW(
    @Cast("LPCWSTR") char[] pFileName,
    @Cast("BOOL") boolean bDeleteExistingResources
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean UpdateResourceA(
    @Cast("HANDLE") Pointer hUpdate,
    @Cast("LPCSTR") BytePointer lpType,
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("WORD") short wLanguage,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int cb
    );
public static native @Cast("BOOL") boolean UpdateResourceA(
    @Cast("HANDLE") Pointer hUpdate,
    @Cast("LPCSTR") ByteBuffer lpType,
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("WORD") short wLanguage,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int cb
    );
public static native @Cast("BOOL") boolean UpdateResourceA(
    @Cast("HANDLE") Pointer hUpdate,
    @Cast("LPCSTR") byte[] lpType,
    @Cast("LPCSTR") byte[] lpName,
    @Cast("WORD") short wLanguage,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int cb
    );
public static native @Cast("BOOL") boolean UpdateResourceA(
    @Cast("HANDLE") Pointer hUpdate,
    @Cast("LPCSTR") String lpType,
    @Cast("LPCSTR") String lpName,
    @Cast("WORD") short wLanguage,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int cb
    );
public static native @Cast("BOOL") boolean UpdateResourceW(
    @Cast("HANDLE") Pointer hUpdate,
    @Cast("LPCWSTR") CharPointer lpType,
    @Cast("LPCWSTR") CharPointer lpName,
    @Cast("WORD") short wLanguage,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int cb
    );
public static native @Cast("BOOL") boolean UpdateResourceW(
    @Cast("HANDLE") Pointer hUpdate,
    @Cast("LPCWSTR") CharBuffer lpType,
    @Cast("LPCWSTR") CharBuffer lpName,
    @Cast("WORD") short wLanguage,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int cb
    );
public static native @Cast("BOOL") boolean UpdateResourceW(
    @Cast("HANDLE") Pointer hUpdate,
    @Cast("LPCWSTR") char[] lpType,
    @Cast("LPCWSTR") char[] lpName,
    @Cast("WORD") short wLanguage,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int cb
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean EndUpdateResourceA(
    @Cast("HANDLE") Pointer hUpdate,
    @Cast("BOOL") boolean fDiscard
    );
public static native @Cast("BOOL") boolean EndUpdateResourceW(
    @Cast("HANDLE") Pointer hUpdate,
    @Cast("BOOL") boolean fDiscard
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static final int ATOM_FLAG_GLOBAL = 0x2;

public static native @Cast("ATOM") short GlobalAddAtomA(
    @Cast("LPCSTR") BytePointer lpString
    );
public static native @Cast("ATOM") short GlobalAddAtomA(
    @Cast("LPCSTR") ByteBuffer lpString
    );
public static native @Cast("ATOM") short GlobalAddAtomA(
    @Cast("LPCSTR") byte[] lpString
    );
public static native @Cast("ATOM") short GlobalAddAtomA(
    @Cast("LPCSTR") String lpString
    );
public static native @Cast("ATOM") short GlobalAddAtomW(
    @Cast("LPCWSTR") CharPointer lpString
    );
public static native @Cast("ATOM") short GlobalAddAtomW(
    @Cast("LPCWSTR") CharBuffer lpString
    );
public static native @Cast("ATOM") short GlobalAddAtomW(
    @Cast("LPCWSTR") char[] lpString
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("ATOM") short GlobalAddAtomExA(
    @Cast("LPCSTR") BytePointer lpString,
    @Cast("DWORD") int Flags
    );
public static native @Cast("ATOM") short GlobalAddAtomExA(
    @Cast("LPCSTR") ByteBuffer lpString,
    @Cast("DWORD") int Flags
    );
public static native @Cast("ATOM") short GlobalAddAtomExA(
    @Cast("LPCSTR") byte[] lpString,
    @Cast("DWORD") int Flags
    );
public static native @Cast("ATOM") short GlobalAddAtomExA(
    @Cast("LPCSTR") String lpString,
    @Cast("DWORD") int Flags
    );
public static native @Cast("ATOM") short GlobalAddAtomExW(
    @Cast("LPCWSTR") CharPointer lpString,
    @Cast("DWORD") int Flags
    );
public static native @Cast("ATOM") short GlobalAddAtomExW(
    @Cast("LPCWSTR") CharBuffer lpString,
    @Cast("DWORD") int Flags
    );
public static native @Cast("ATOM") short GlobalAddAtomExW(
    @Cast("LPCWSTR") char[] lpString,
    @Cast("DWORD") int Flags
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("ATOM") short GlobalFindAtomA(
    @Cast("LPCSTR") BytePointer lpString
    );
public static native @Cast("ATOM") short GlobalFindAtomA(
    @Cast("LPCSTR") ByteBuffer lpString
    );
public static native @Cast("ATOM") short GlobalFindAtomA(
    @Cast("LPCSTR") byte[] lpString
    );
public static native @Cast("ATOM") short GlobalFindAtomA(
    @Cast("LPCSTR") String lpString
    );
public static native @Cast("ATOM") short GlobalFindAtomW(
    @Cast("LPCWSTR") CharPointer lpString
    );
public static native @Cast("ATOM") short GlobalFindAtomW(
    @Cast("LPCWSTR") CharBuffer lpString
    );
public static native @Cast("ATOM") short GlobalFindAtomW(
    @Cast("LPCWSTR") char[] lpString
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("UINT") int GlobalGetAtomNameA(
    @Cast("ATOM") short nAtom,
    @Cast("LPSTR") BytePointer lpBuffer,
    int nSize
    );
public static native @Cast("UINT") int GlobalGetAtomNameA(
    @Cast("ATOM") short nAtom,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    int nSize
    );
public static native @Cast("UINT") int GlobalGetAtomNameA(
    @Cast("ATOM") short nAtom,
    @Cast("LPSTR") byte[] lpBuffer,
    int nSize
    );
public static native @Cast("UINT") int GlobalGetAtomNameW(
    @Cast("ATOM") short nAtom,
    @Cast("LPWSTR") CharPointer lpBuffer,
    int nSize
    );
public static native @Cast("UINT") int GlobalGetAtomNameW(
    @Cast("ATOM") short nAtom,
    @Cast("LPWSTR") CharBuffer lpBuffer,
    int nSize
    );
public static native @Cast("UINT") int GlobalGetAtomNameW(
    @Cast("ATOM") short nAtom,
    @Cast("LPWSTR") char[] lpBuffer,
    int nSize
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("ATOM") short AddAtomA(
    @Cast("LPCSTR") BytePointer lpString
    );
public static native @Cast("ATOM") short AddAtomA(
    @Cast("LPCSTR") ByteBuffer lpString
    );
public static native @Cast("ATOM") short AddAtomA(
    @Cast("LPCSTR") byte[] lpString
    );
public static native @Cast("ATOM") short AddAtomA(
    @Cast("LPCSTR") String lpString
    );
public static native @Cast("ATOM") short AddAtomW(
    @Cast("LPCWSTR") CharPointer lpString
    );
public static native @Cast("ATOM") short AddAtomW(
    @Cast("LPCWSTR") CharBuffer lpString
    );
public static native @Cast("ATOM") short AddAtomW(
    @Cast("LPCWSTR") char[] lpString
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("ATOM") short FindAtomA(
    @Cast("LPCSTR") BytePointer lpString
    );
public static native @Cast("ATOM") short FindAtomA(
    @Cast("LPCSTR") ByteBuffer lpString
    );
public static native @Cast("ATOM") short FindAtomA(
    @Cast("LPCSTR") byte[] lpString
    );
public static native @Cast("ATOM") short FindAtomA(
    @Cast("LPCSTR") String lpString
    );
public static native @Cast("ATOM") short FindAtomW(
    @Cast("LPCWSTR") CharPointer lpString
    );
public static native @Cast("ATOM") short FindAtomW(
    @Cast("LPCWSTR") CharBuffer lpString
    );
public static native @Cast("ATOM") short FindAtomW(
    @Cast("LPCWSTR") char[] lpString
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("UINT") int GetAtomNameA(
    @Cast("ATOM") short nAtom,
    @Cast("LPSTR") BytePointer lpBuffer,
    int nSize
    );
public static native @Cast("UINT") int GetAtomNameA(
    @Cast("ATOM") short nAtom,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    int nSize
    );
public static native @Cast("UINT") int GetAtomNameA(
    @Cast("ATOM") short nAtom,
    @Cast("LPSTR") byte[] lpBuffer,
    int nSize
    );
public static native @Cast("UINT") int GetAtomNameW(
    @Cast("ATOM") short nAtom,
    @Cast("LPWSTR") CharPointer lpBuffer,
    int nSize
    );
public static native @Cast("UINT") int GetAtomNameW(
    @Cast("ATOM") short nAtom,
    @Cast("LPWSTR") CharBuffer lpBuffer,
    int nSize
    );
public static native @Cast("UINT") int GetAtomNameW(
    @Cast("ATOM") short nAtom,
    @Cast("LPWSTR") char[] lpBuffer,
    int nSize
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("UINT") int GetProfileIntA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPCSTR") BytePointer lpKeyName,
    @Cast("INT") int nDefault
    );
public static native @Cast("UINT") int GetProfileIntA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPCSTR") ByteBuffer lpKeyName,
    @Cast("INT") int nDefault
    );
public static native @Cast("UINT") int GetProfileIntA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPCSTR") byte[] lpKeyName,
    @Cast("INT") int nDefault
    );
public static native @Cast("UINT") int GetProfileIntA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPCSTR") String lpKeyName,
    @Cast("INT") int nDefault
    );
public static native @Cast("UINT") int GetProfileIntW(
    @Cast("LPCWSTR") CharPointer lpAppName,
    @Cast("LPCWSTR") CharPointer lpKeyName,
    @Cast("INT") int nDefault
    );
public static native @Cast("UINT") int GetProfileIntW(
    @Cast("LPCWSTR") CharBuffer lpAppName,
    @Cast("LPCWSTR") CharBuffer lpKeyName,
    @Cast("INT") int nDefault
    );
public static native @Cast("UINT") int GetProfileIntW(
    @Cast("LPCWSTR") char[] lpAppName,
    @Cast("LPCWSTR") char[] lpKeyName,
    @Cast("INT") int nDefault
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("DWORD") int GetProfileStringA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPCSTR") BytePointer lpKeyName,
    @Cast("LPCSTR") BytePointer lpDefault,
    @Cast("LPSTR") BytePointer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileStringA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPCSTR") ByteBuffer lpKeyName,
    @Cast("LPCSTR") ByteBuffer lpDefault,
    @Cast("LPSTR") ByteBuffer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileStringA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPCSTR") byte[] lpKeyName,
    @Cast("LPCSTR") byte[] lpDefault,
    @Cast("LPSTR") byte[] lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileStringA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPCSTR") String lpKeyName,
    @Cast("LPCSTR") String lpDefault,
    @Cast("LPSTR") BytePointer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileStringA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPCSTR") BytePointer lpKeyName,
    @Cast("LPCSTR") BytePointer lpDefault,
    @Cast("LPSTR") ByteBuffer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileStringA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPCSTR") ByteBuffer lpKeyName,
    @Cast("LPCSTR") ByteBuffer lpDefault,
    @Cast("LPSTR") byte[] lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileStringA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPCSTR") byte[] lpKeyName,
    @Cast("LPCSTR") byte[] lpDefault,
    @Cast("LPSTR") BytePointer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileStringA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPCSTR") String lpKeyName,
    @Cast("LPCSTR") String lpDefault,
    @Cast("LPSTR") ByteBuffer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileStringA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPCSTR") BytePointer lpKeyName,
    @Cast("LPCSTR") BytePointer lpDefault,
    @Cast("LPSTR") byte[] lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileStringA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPCSTR") ByteBuffer lpKeyName,
    @Cast("LPCSTR") ByteBuffer lpDefault,
    @Cast("LPSTR") BytePointer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileStringA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPCSTR") byte[] lpKeyName,
    @Cast("LPCSTR") byte[] lpDefault,
    @Cast("LPSTR") ByteBuffer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileStringA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPCSTR") String lpKeyName,
    @Cast("LPCSTR") String lpDefault,
    @Cast("LPSTR") byte[] lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileStringW(
    @Cast("LPCWSTR") CharPointer lpAppName,
    @Cast("LPCWSTR") CharPointer lpKeyName,
    @Cast("LPCWSTR") CharPointer lpDefault,
    @Cast("LPWSTR") CharPointer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileStringW(
    @Cast("LPCWSTR") CharBuffer lpAppName,
    @Cast("LPCWSTR") CharBuffer lpKeyName,
    @Cast("LPCWSTR") CharBuffer lpDefault,
    @Cast("LPWSTR") CharBuffer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileStringW(
    @Cast("LPCWSTR") char[] lpAppName,
    @Cast("LPCWSTR") char[] lpKeyName,
    @Cast("LPCWSTR") char[] lpDefault,
    @Cast("LPWSTR") char[] lpReturnedString,
    @Cast("DWORD") int nSize
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean WriteProfileStringA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPCSTR") BytePointer lpKeyName,
    @Cast("LPCSTR") BytePointer lpString
    );
public static native @Cast("BOOL") boolean WriteProfileStringA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPCSTR") ByteBuffer lpKeyName,
    @Cast("LPCSTR") ByteBuffer lpString
    );
public static native @Cast("BOOL") boolean WriteProfileStringA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPCSTR") byte[] lpKeyName,
    @Cast("LPCSTR") byte[] lpString
    );
public static native @Cast("BOOL") boolean WriteProfileStringA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPCSTR") String lpKeyName,
    @Cast("LPCSTR") String lpString
    );
public static native @Cast("BOOL") boolean WriteProfileStringW(
    @Cast("LPCWSTR") CharPointer lpAppName,
    @Cast("LPCWSTR") CharPointer lpKeyName,
    @Cast("LPCWSTR") CharPointer lpString
    );
public static native @Cast("BOOL") boolean WriteProfileStringW(
    @Cast("LPCWSTR") CharBuffer lpAppName,
    @Cast("LPCWSTR") CharBuffer lpKeyName,
    @Cast("LPCWSTR") CharBuffer lpString
    );
public static native @Cast("BOOL") boolean WriteProfileStringW(
    @Cast("LPCWSTR") char[] lpAppName,
    @Cast("LPCWSTR") char[] lpKeyName,
    @Cast("LPCWSTR") char[] lpString
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("DWORD") int GetProfileSectionA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPSTR") BytePointer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileSectionA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPSTR") ByteBuffer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileSectionA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPSTR") byte[] lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileSectionA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPSTR") BytePointer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileSectionA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPSTR") ByteBuffer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileSectionA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPSTR") byte[] lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileSectionA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPSTR") BytePointer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileSectionA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPSTR") ByteBuffer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileSectionA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPSTR") byte[] lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileSectionA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPSTR") BytePointer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileSectionA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPSTR") ByteBuffer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileSectionA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPSTR") byte[] lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileSectionW(
    @Cast("LPCWSTR") CharPointer lpAppName,
    @Cast("LPWSTR") CharPointer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileSectionW(
    @Cast("LPCWSTR") CharBuffer lpAppName,
    @Cast("LPWSTR") CharBuffer lpReturnedString,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProfileSectionW(
    @Cast("LPCWSTR") char[] lpAppName,
    @Cast("LPWSTR") char[] lpReturnedString,
    @Cast("DWORD") int nSize
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean WriteProfileSectionA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPCSTR") BytePointer lpString
    );
public static native @Cast("BOOL") boolean WriteProfileSectionA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPCSTR") ByteBuffer lpString
    );
public static native @Cast("BOOL") boolean WriteProfileSectionA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPCSTR") byte[] lpString
    );
public static native @Cast("BOOL") boolean WriteProfileSectionA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPCSTR") String lpString
    );
public static native @Cast("BOOL") boolean WriteProfileSectionW(
    @Cast("LPCWSTR") CharPointer lpAppName,
    @Cast("LPCWSTR") CharPointer lpString
    );
public static native @Cast("BOOL") boolean WriteProfileSectionW(
    @Cast("LPCWSTR") CharBuffer lpAppName,
    @Cast("LPCWSTR") CharBuffer lpString
    );
public static native @Cast("BOOL") boolean WriteProfileSectionW(
    @Cast("LPCWSTR") char[] lpAppName,
    @Cast("LPCWSTR") char[] lpString
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("UINT") int GetPrivateProfileIntA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPCSTR") BytePointer lpKeyName,
    @Cast("INT") int nDefault,
    @Cast("LPCSTR") BytePointer lpFileName
    );
public static native @Cast("UINT") int GetPrivateProfileIntA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPCSTR") ByteBuffer lpKeyName,
    @Cast("INT") int nDefault,
    @Cast("LPCSTR") ByteBuffer lpFileName
    );
public static native @Cast("UINT") int GetPrivateProfileIntA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPCSTR") byte[] lpKeyName,
    @Cast("INT") int nDefault,
    @Cast("LPCSTR") byte[] lpFileName
    );
public static native @Cast("UINT") int GetPrivateProfileIntA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPCSTR") String lpKeyName,
    @Cast("INT") int nDefault,
    @Cast("LPCSTR") String lpFileName
    );
public static native @Cast("UINT") int GetPrivateProfileIntW(
    @Cast("LPCWSTR") CharPointer lpAppName,
    @Cast("LPCWSTR") CharPointer lpKeyName,
    @Cast("INT") int nDefault,
    @Cast("LPCWSTR") CharPointer lpFileName
    );
public static native @Cast("UINT") int GetPrivateProfileIntW(
    @Cast("LPCWSTR") CharBuffer lpAppName,
    @Cast("LPCWSTR") CharBuffer lpKeyName,
    @Cast("INT") int nDefault,
    @Cast("LPCWSTR") CharBuffer lpFileName
    );
public static native @Cast("UINT") int GetPrivateProfileIntW(
    @Cast("LPCWSTR") char[] lpAppName,
    @Cast("LPCWSTR") char[] lpKeyName,
    @Cast("INT") int nDefault,
    @Cast("LPCWSTR") char[] lpFileName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #if defined(_M_CEE)
// #undef GetPrivateProfileInt
public static native @Cast("UINT") int GetPrivateProfileInt(
    @Cast("LPCTSTR") CharPointer lpAppName,
    @Cast("LPCTSTR") CharPointer lpKeyName,
    @Cast("INT") int nDefault,
    @Cast("LPCTSTR") CharPointer lpFileName
    );
public static native @Cast("UINT") int GetPrivateProfileInt(
    @Cast("LPCTSTR") CharBuffer lpAppName,
    @Cast("LPCTSTR") CharBuffer lpKeyName,
    @Cast("INT") int nDefault,
    @Cast("LPCTSTR") CharBuffer lpFileName
    );
public static native @Cast("UINT") int GetPrivateProfileInt(
    @Cast("LPCTSTR") char[] lpAppName,
    @Cast("LPCTSTR") char[] lpKeyName,
    @Cast("INT") int nDefault,
    @Cast("LPCTSTR") char[] lpFileName
    );
// #endif  /* _M_CEE */

public static native @Cast("DWORD") int GetPrivateProfileStringA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPCSTR") BytePointer lpKeyName,
    @Cast("LPCSTR") BytePointer lpDefault,
    @Cast("LPSTR") BytePointer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") BytePointer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileStringA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPCSTR") ByteBuffer lpKeyName,
    @Cast("LPCSTR") ByteBuffer lpDefault,
    @Cast("LPSTR") ByteBuffer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") ByteBuffer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileStringA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPCSTR") byte[] lpKeyName,
    @Cast("LPCSTR") byte[] lpDefault,
    @Cast("LPSTR") byte[] lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") byte[] lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileStringA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPCSTR") String lpKeyName,
    @Cast("LPCSTR") String lpDefault,
    @Cast("LPSTR") BytePointer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") String lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileStringA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPCSTR") BytePointer lpKeyName,
    @Cast("LPCSTR") BytePointer lpDefault,
    @Cast("LPSTR") ByteBuffer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") BytePointer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileStringA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPCSTR") ByteBuffer lpKeyName,
    @Cast("LPCSTR") ByteBuffer lpDefault,
    @Cast("LPSTR") byte[] lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") ByteBuffer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileStringA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPCSTR") byte[] lpKeyName,
    @Cast("LPCSTR") byte[] lpDefault,
    @Cast("LPSTR") BytePointer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") byte[] lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileStringA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPCSTR") String lpKeyName,
    @Cast("LPCSTR") String lpDefault,
    @Cast("LPSTR") ByteBuffer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") String lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileStringA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPCSTR") BytePointer lpKeyName,
    @Cast("LPCSTR") BytePointer lpDefault,
    @Cast("LPSTR") byte[] lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") BytePointer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileStringA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPCSTR") ByteBuffer lpKeyName,
    @Cast("LPCSTR") ByteBuffer lpDefault,
    @Cast("LPSTR") BytePointer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") ByteBuffer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileStringA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPCSTR") byte[] lpKeyName,
    @Cast("LPCSTR") byte[] lpDefault,
    @Cast("LPSTR") ByteBuffer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") byte[] lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileStringA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPCSTR") String lpKeyName,
    @Cast("LPCSTR") String lpDefault,
    @Cast("LPSTR") byte[] lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") String lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileStringW(
    @Cast("LPCWSTR") CharPointer lpAppName,
    @Cast("LPCWSTR") CharPointer lpKeyName,
    @Cast("LPCWSTR") CharPointer lpDefault,
    @Cast("LPWSTR") CharPointer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCWSTR") CharPointer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileStringW(
    @Cast("LPCWSTR") CharBuffer lpAppName,
    @Cast("LPCWSTR") CharBuffer lpKeyName,
    @Cast("LPCWSTR") CharBuffer lpDefault,
    @Cast("LPWSTR") CharBuffer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCWSTR") CharBuffer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileStringW(
    @Cast("LPCWSTR") char[] lpAppName,
    @Cast("LPCWSTR") char[] lpKeyName,
    @Cast("LPCWSTR") char[] lpDefault,
    @Cast("LPWSTR") char[] lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCWSTR") char[] lpFileName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #if defined(_M_CEE)
// #undef GetPrivateProfileString
public static native @Cast("DWORD") int GetPrivateProfileString(
    @Cast("LPCTSTR") CharPointer lpAppName,
    @Cast("LPCTSTR") CharPointer lpKeyName,
    @Cast("LPCTSTR") CharPointer lpDefault,
    @Cast("LPTSTR") CharPointer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCTSTR") CharPointer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileString(
    @Cast("LPCTSTR") CharBuffer lpAppName,
    @Cast("LPCTSTR") CharBuffer lpKeyName,
    @Cast("LPCTSTR") CharBuffer lpDefault,
    @Cast("LPTSTR") CharBuffer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCTSTR") CharBuffer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileString(
    @Cast("LPCTSTR") char[] lpAppName,
    @Cast("LPCTSTR") char[] lpKeyName,
    @Cast("LPCTSTR") char[] lpDefault,
    @Cast("LPTSTR") char[] lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCTSTR") char[] lpFileName
    );
// #endif  /* _M_CEE */

public static native @Cast("BOOL") boolean WritePrivateProfileStringA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPCSTR") BytePointer lpKeyName,
    @Cast("LPCSTR") BytePointer lpString,
    @Cast("LPCSTR") BytePointer lpFileName
    );
public static native @Cast("BOOL") boolean WritePrivateProfileStringA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPCSTR") ByteBuffer lpKeyName,
    @Cast("LPCSTR") ByteBuffer lpString,
    @Cast("LPCSTR") ByteBuffer lpFileName
    );
public static native @Cast("BOOL") boolean WritePrivateProfileStringA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPCSTR") byte[] lpKeyName,
    @Cast("LPCSTR") byte[] lpString,
    @Cast("LPCSTR") byte[] lpFileName
    );
public static native @Cast("BOOL") boolean WritePrivateProfileStringA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPCSTR") String lpKeyName,
    @Cast("LPCSTR") String lpString,
    @Cast("LPCSTR") String lpFileName
    );
public static native @Cast("BOOL") boolean WritePrivateProfileStringW(
    @Cast("LPCWSTR") CharPointer lpAppName,
    @Cast("LPCWSTR") CharPointer lpKeyName,
    @Cast("LPCWSTR") CharPointer lpString,
    @Cast("LPCWSTR") CharPointer lpFileName
    );
public static native @Cast("BOOL") boolean WritePrivateProfileStringW(
    @Cast("LPCWSTR") CharBuffer lpAppName,
    @Cast("LPCWSTR") CharBuffer lpKeyName,
    @Cast("LPCWSTR") CharBuffer lpString,
    @Cast("LPCWSTR") CharBuffer lpFileName
    );
public static native @Cast("BOOL") boolean WritePrivateProfileStringW(
    @Cast("LPCWSTR") char[] lpAppName,
    @Cast("LPCWSTR") char[] lpKeyName,
    @Cast("LPCWSTR") char[] lpString,
    @Cast("LPCWSTR") char[] lpFileName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("DWORD") int GetPrivateProfileSectionA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPSTR") BytePointer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") BytePointer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPSTR") ByteBuffer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") ByteBuffer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPSTR") byte[] lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") byte[] lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPSTR") BytePointer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") String lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPSTR") ByteBuffer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") BytePointer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPSTR") byte[] lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") ByteBuffer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPSTR") BytePointer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") byte[] lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPSTR") ByteBuffer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") String lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPSTR") byte[] lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") BytePointer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPSTR") BytePointer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") ByteBuffer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPSTR") ByteBuffer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") byte[] lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPSTR") byte[] lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") String lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionW(
    @Cast("LPCWSTR") CharPointer lpAppName,
    @Cast("LPWSTR") CharPointer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCWSTR") CharPointer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionW(
    @Cast("LPCWSTR") CharBuffer lpAppName,
    @Cast("LPWSTR") CharBuffer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCWSTR") CharBuffer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionW(
    @Cast("LPCWSTR") char[] lpAppName,
    @Cast("LPWSTR") char[] lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCWSTR") char[] lpFileName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #if defined(_M_CEE)
// #undef GetPrivateProfileSection
public static native @Cast("DWORD") int GetPrivateProfileSection(
    @Cast("LPCTSTR") CharPointer lpAppName,
    @Cast("LPTSTR") CharPointer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCTSTR") CharPointer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSection(
    @Cast("LPCTSTR") CharBuffer lpAppName,
    @Cast("LPTSTR") CharBuffer lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCTSTR") CharBuffer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSection(
    @Cast("LPCTSTR") char[] lpAppName,
    @Cast("LPTSTR") char[] lpReturnedString,
    @Cast("DWORD") int nSize,
    @Cast("LPCTSTR") char[] lpFileName
    );
// #endif  /* _M_CEE */

public static native @Cast("BOOL") boolean WritePrivateProfileSectionA(
    @Cast("LPCSTR") BytePointer lpAppName,
    @Cast("LPCSTR") BytePointer lpString,
    @Cast("LPCSTR") BytePointer lpFileName
    );
public static native @Cast("BOOL") boolean WritePrivateProfileSectionA(
    @Cast("LPCSTR") ByteBuffer lpAppName,
    @Cast("LPCSTR") ByteBuffer lpString,
    @Cast("LPCSTR") ByteBuffer lpFileName
    );
public static native @Cast("BOOL") boolean WritePrivateProfileSectionA(
    @Cast("LPCSTR") byte[] lpAppName,
    @Cast("LPCSTR") byte[] lpString,
    @Cast("LPCSTR") byte[] lpFileName
    );
public static native @Cast("BOOL") boolean WritePrivateProfileSectionA(
    @Cast("LPCSTR") String lpAppName,
    @Cast("LPCSTR") String lpString,
    @Cast("LPCSTR") String lpFileName
    );
public static native @Cast("BOOL") boolean WritePrivateProfileSectionW(
    @Cast("LPCWSTR") CharPointer lpAppName,
    @Cast("LPCWSTR") CharPointer lpString,
    @Cast("LPCWSTR") CharPointer lpFileName
    );
public static native @Cast("BOOL") boolean WritePrivateProfileSectionW(
    @Cast("LPCWSTR") CharBuffer lpAppName,
    @Cast("LPCWSTR") CharBuffer lpString,
    @Cast("LPCWSTR") CharBuffer lpFileName
    );
public static native @Cast("BOOL") boolean WritePrivateProfileSectionW(
    @Cast("LPCWSTR") char[] lpAppName,
    @Cast("LPCWSTR") char[] lpString,
    @Cast("LPCWSTR") char[] lpFileName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE


public static native @Cast("DWORD") int GetPrivateProfileSectionNamesA(
    @Cast("LPSTR") BytePointer lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") BytePointer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionNamesA(
    @Cast("LPSTR") ByteBuffer lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") ByteBuffer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionNamesA(
    @Cast("LPSTR") byte[] lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") byte[] lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionNamesA(
    @Cast("LPSTR") BytePointer lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") String lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionNamesA(
    @Cast("LPSTR") ByteBuffer lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") BytePointer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionNamesA(
    @Cast("LPSTR") byte[] lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") ByteBuffer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionNamesA(
    @Cast("LPSTR") BytePointer lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") byte[] lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionNamesA(
    @Cast("LPSTR") ByteBuffer lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") String lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionNamesA(
    @Cast("LPSTR") byte[] lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") BytePointer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionNamesA(
    @Cast("LPSTR") BytePointer lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") ByteBuffer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionNamesA(
    @Cast("LPSTR") ByteBuffer lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") byte[] lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionNamesA(
    @Cast("LPSTR") byte[] lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCSTR") String lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionNamesW(
    @Cast("LPWSTR") CharPointer lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCWSTR") CharPointer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionNamesW(
    @Cast("LPWSTR") CharBuffer lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCWSTR") CharBuffer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionNamesW(
    @Cast("LPWSTR") char[] lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCWSTR") char[] lpFileName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #if defined(_M_CEE)
// #undef GetPrivateProfileSectionNames
public static native @Cast("DWORD") int GetPrivateProfileSectionNames(
    @Cast("LPTSTR") CharPointer lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCTSTR") CharPointer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionNames(
    @Cast("LPTSTR") CharBuffer lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCTSTR") CharBuffer lpFileName
    );
public static native @Cast("DWORD") int GetPrivateProfileSectionNames(
    @Cast("LPTSTR") char[] lpszReturnBuffer,
    @Cast("DWORD") int nSize,
    @Cast("LPCTSTR") char[] lpFileName
    );
// #endif  /* _M_CEE */

public static native @Cast("BOOL") boolean GetPrivateProfileStructA(
    @Cast("LPCSTR") BytePointer lpszSection,
    @Cast("LPCSTR") BytePointer lpszKey,
    @Cast("LPVOID") Pointer lpStruct,
    @Cast("UINT") int uSizeStruct,
    @Cast("LPCSTR") BytePointer szFile
    );
public static native @Cast("BOOL") boolean GetPrivateProfileStructA(
    @Cast("LPCSTR") ByteBuffer lpszSection,
    @Cast("LPCSTR") ByteBuffer lpszKey,
    @Cast("LPVOID") Pointer lpStruct,
    @Cast("UINT") int uSizeStruct,
    @Cast("LPCSTR") ByteBuffer szFile
    );
public static native @Cast("BOOL") boolean GetPrivateProfileStructA(
    @Cast("LPCSTR") byte[] lpszSection,
    @Cast("LPCSTR") byte[] lpszKey,
    @Cast("LPVOID") Pointer lpStruct,
    @Cast("UINT") int uSizeStruct,
    @Cast("LPCSTR") byte[] szFile
    );
public static native @Cast("BOOL") boolean GetPrivateProfileStructA(
    @Cast("LPCSTR") String lpszSection,
    @Cast("LPCSTR") String lpszKey,
    @Cast("LPVOID") Pointer lpStruct,
    @Cast("UINT") int uSizeStruct,
    @Cast("LPCSTR") String szFile
    );
public static native @Cast("BOOL") boolean GetPrivateProfileStructW(
    @Cast("LPCWSTR") CharPointer lpszSection,
    @Cast("LPCWSTR") CharPointer lpszKey,
    @Cast("LPVOID") Pointer lpStruct,
    @Cast("UINT") int uSizeStruct,
    @Cast("LPCWSTR") CharPointer szFile
    );
public static native @Cast("BOOL") boolean GetPrivateProfileStructW(
    @Cast("LPCWSTR") CharBuffer lpszSection,
    @Cast("LPCWSTR") CharBuffer lpszKey,
    @Cast("LPVOID") Pointer lpStruct,
    @Cast("UINT") int uSizeStruct,
    @Cast("LPCWSTR") CharBuffer szFile
    );
public static native @Cast("BOOL") boolean GetPrivateProfileStructW(
    @Cast("LPCWSTR") char[] lpszSection,
    @Cast("LPCWSTR") char[] lpszKey,
    @Cast("LPVOID") Pointer lpStruct,
    @Cast("UINT") int uSizeStruct,
    @Cast("LPCWSTR") char[] szFile
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #if defined(_M_CEE)
// #undef GetPrivateProfileStruct
public static native @Cast("BOOL") boolean GetPrivateProfileStruct(
    @Cast("LPCTSTR") CharPointer lpszSection,
    @Cast("LPCTSTR") CharPointer lpszKey,
    @Cast("LPVOID") Pointer lpStruct,
    @Cast("UINT") int uSizeStruct,
    @Cast("LPCTSTR") CharPointer szFile
    );
public static native @Cast("BOOL") boolean GetPrivateProfileStruct(
    @Cast("LPCTSTR") CharBuffer lpszSection,
    @Cast("LPCTSTR") CharBuffer lpszKey,
    @Cast("LPVOID") Pointer lpStruct,
    @Cast("UINT") int uSizeStruct,
    @Cast("LPCTSTR") CharBuffer szFile
    );
public static native @Cast("BOOL") boolean GetPrivateProfileStruct(
    @Cast("LPCTSTR") char[] lpszSection,
    @Cast("LPCTSTR") char[] lpszKey,
    @Cast("LPVOID") Pointer lpStruct,
    @Cast("UINT") int uSizeStruct,
    @Cast("LPCTSTR") char[] szFile
    );
// #endif  /* _M_CEE */

public static native @Cast("BOOL") boolean WritePrivateProfileStructA(
    @Cast("LPCSTR") BytePointer lpszSection,
    @Cast("LPCSTR") BytePointer lpszKey,
    @Cast("LPVOID") Pointer lpStruct,
    @Cast("UINT") int uSizeStruct,
    @Cast("LPCSTR") BytePointer szFile
    );
public static native @Cast("BOOL") boolean WritePrivateProfileStructA(
    @Cast("LPCSTR") ByteBuffer lpszSection,
    @Cast("LPCSTR") ByteBuffer lpszKey,
    @Cast("LPVOID") Pointer lpStruct,
    @Cast("UINT") int uSizeStruct,
    @Cast("LPCSTR") ByteBuffer szFile
    );
public static native @Cast("BOOL") boolean WritePrivateProfileStructA(
    @Cast("LPCSTR") byte[] lpszSection,
    @Cast("LPCSTR") byte[] lpszKey,
    @Cast("LPVOID") Pointer lpStruct,
    @Cast("UINT") int uSizeStruct,
    @Cast("LPCSTR") byte[] szFile
    );
public static native @Cast("BOOL") boolean WritePrivateProfileStructA(
    @Cast("LPCSTR") String lpszSection,
    @Cast("LPCSTR") String lpszKey,
    @Cast("LPVOID") Pointer lpStruct,
    @Cast("UINT") int uSizeStruct,
    @Cast("LPCSTR") String szFile
    );
public static native @Cast("BOOL") boolean WritePrivateProfileStructW(
    @Cast("LPCWSTR") CharPointer lpszSection,
    @Cast("LPCWSTR") CharPointer lpszKey,
    @Cast("LPVOID") Pointer lpStruct,
    @Cast("UINT") int uSizeStruct,
    @Cast("LPCWSTR") CharPointer szFile
    );
public static native @Cast("BOOL") boolean WritePrivateProfileStructW(
    @Cast("LPCWSTR") CharBuffer lpszSection,
    @Cast("LPCWSTR") CharBuffer lpszKey,
    @Cast("LPVOID") Pointer lpStruct,
    @Cast("UINT") int uSizeStruct,
    @Cast("LPCWSTR") CharBuffer szFile
    );
public static native @Cast("BOOL") boolean WritePrivateProfileStructW(
    @Cast("LPCWSTR") char[] lpszSection,
    @Cast("LPCWSTR") char[] lpszKey,
    @Cast("LPVOID") Pointer lpStruct,
    @Cast("UINT") int uSizeStruct,
    @Cast("LPCWSTR") char[] szFile
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("DWORD") int GetTempPathA(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") BytePointer lpBuffer
    );
public static native @Cast("DWORD") int GetTempPathA(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") ByteBuffer lpBuffer
    );
public static native @Cast("DWORD") int GetTempPathA(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") byte[] lpBuffer
    );
// #ifndef UNICODE
// #endif

public static native @Cast("UINT") int GetTempFileNameA(
    @Cast("LPCSTR") BytePointer lpPathName,
    @Cast("LPCSTR") BytePointer lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPSTR") BytePointer lpTempFileName
    );
public static native @Cast("UINT") int GetTempFileNameA(
    @Cast("LPCSTR") ByteBuffer lpPathName,
    @Cast("LPCSTR") ByteBuffer lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPSTR") ByteBuffer lpTempFileName
    );
public static native @Cast("UINT") int GetTempFileNameA(
    @Cast("LPCSTR") byte[] lpPathName,
    @Cast("LPCSTR") byte[] lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPSTR") byte[] lpTempFileName
    );
public static native @Cast("UINT") int GetTempFileNameA(
    @Cast("LPCSTR") String lpPathName,
    @Cast("LPCSTR") String lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPSTR") BytePointer lpTempFileName
    );
public static native @Cast("UINT") int GetTempFileNameA(
    @Cast("LPCSTR") BytePointer lpPathName,
    @Cast("LPCSTR") BytePointer lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPSTR") ByteBuffer lpTempFileName
    );
public static native @Cast("UINT") int GetTempFileNameA(
    @Cast("LPCSTR") ByteBuffer lpPathName,
    @Cast("LPCSTR") ByteBuffer lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPSTR") byte[] lpTempFileName
    );
public static native @Cast("UINT") int GetTempFileNameA(
    @Cast("LPCSTR") byte[] lpPathName,
    @Cast("LPCSTR") byte[] lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPSTR") BytePointer lpTempFileName
    );
public static native @Cast("UINT") int GetTempFileNameA(
    @Cast("LPCSTR") String lpPathName,
    @Cast("LPCSTR") String lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPSTR") ByteBuffer lpTempFileName
    );
public static native @Cast("UINT") int GetTempFileNameA(
    @Cast("LPCSTR") BytePointer lpPathName,
    @Cast("LPCSTR") BytePointer lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPSTR") byte[] lpTempFileName
    );
public static native @Cast("UINT") int GetTempFileNameA(
    @Cast("LPCSTR") ByteBuffer lpPathName,
    @Cast("LPCSTR") ByteBuffer lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPSTR") BytePointer lpTempFileName
    );
public static native @Cast("UINT") int GetTempFileNameA(
    @Cast("LPCSTR") byte[] lpPathName,
    @Cast("LPCSTR") byte[] lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPSTR") ByteBuffer lpTempFileName
    );
public static native @Cast("UINT") int GetTempFileNameA(
    @Cast("LPCSTR") String lpPathName,
    @Cast("LPCSTR") String lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPSTR") byte[] lpTempFileName
    );
// #ifndef UNICODE
// #endif

// #if defined(_M_CEE)
// #undef GetTempFileName
public static native @Cast("UINT") int GetTempFileName(
    @Cast("LPCTSTR") CharPointer lpPathName,
    @Cast("LPCTSTR") CharPointer lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPTSTR") CharPointer lpTempFileName
    );
public static native @Cast("UINT") int GetTempFileName(
    @Cast("LPCTSTR") CharBuffer lpPathName,
    @Cast("LPCTSTR") CharBuffer lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPTSTR") CharBuffer lpTempFileName
    );
public static native @Cast("UINT") int GetTempFileName(
    @Cast("LPCTSTR") char[] lpPathName,
    @Cast("LPCTSTR") char[] lpPrefixString,
    @Cast("UINT") int uUnique,
    @Cast("LPTSTR") char[] lpTempFileName
    );
// #endif  /* _M_CEE */

// #if !defined(RC_INVOKED) // RC warns because "WINBASE_DECLARE_GET_SYSTEM_WOW64_DIRECTORY" is a bit long.
// #if _WIN32_WINNT >= 0x0501 || defined(WINBASE_DECLARE_GET_SYSTEM_WOW64_DIRECTORY)

public static native @Cast("UINT") int GetSystemWow64DirectoryA(
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("UINT") int uSize
    );
public static native @Cast("UINT") int GetSystemWow64DirectoryA(
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("UINT") int uSize
    );
public static native @Cast("UINT") int GetSystemWow64DirectoryA(
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("UINT") int uSize
    );
public static native @Cast("UINT") int GetSystemWow64DirectoryW(
    @Cast("LPWSTR") CharPointer lpBuffer,
    @Cast("UINT") int uSize
    );
public static native @Cast("UINT") int GetSystemWow64DirectoryW(
    @Cast("LPWSTR") CharBuffer lpBuffer,
    @Cast("UINT") int uSize
    );
public static native @Cast("UINT") int GetSystemWow64DirectoryW(
    @Cast("LPWSTR") char[] lpBuffer,
    @Cast("UINT") int uSize
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOLEAN") boolean Wow64EnableWow64FsRedirection(
    @Cast("BOOLEAN") boolean Wow64FsEnableRedirection
    );
// Targeting ..\windows\PGET_SYSTEM_WOW64_DIRECTORY_A.java


// Targeting ..\windows\PGET_SYSTEM_WOW64_DIRECTORY_W.java



//
// GetProcAddress only accepts GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A,
// GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A, GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A.
// The others are if you want to use the strings in some other way.
//
public static final String GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A =      "GetSystemWow64DirectoryA";
public static final String GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W =     "GetSystemWow64DirectoryA";
public static native @MemberGetter String GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T();
public static final String GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T = GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T();
public static final String GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A =      "GetSystemWow64DirectoryW";
public static final String GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W =     "GetSystemWow64DirectoryW";
public static native @MemberGetter String GET_SYSTEM_WOW64_DIRECTORY_NAME_W_T();
public static final String GET_SYSTEM_WOW64_DIRECTORY_NAME_W_T = GET_SYSTEM_WOW64_DIRECTORY_NAME_W_T();

// #ifdef UNICODE
public static final String GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A = GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A;
public static final String GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W = GET_SYSTEM_WOW64_DIRECTORY_NAME_W_W;
public static native @MemberGetter String GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T();
public static final String GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T = GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T();
// #else
// #endif

// #endif // _WIN32_WINNT >= 0x0501
// #endif

// #if defined(_M_CEE)
// #undef SetCurrentDirectory
public static native @Cast("BOOL") boolean SetCurrentDirectory(
    @Cast("LPCTSTR") CharPointer lpPathName
    );
public static native @Cast("BOOL") boolean SetCurrentDirectory(
    @Cast("LPCTSTR") CharBuffer lpPathName
    );
public static native @Cast("BOOL") boolean SetCurrentDirectory(
    @Cast("LPCTSTR") char[] lpPathName
    );
// #endif  /* _M_CEE */

// #if defined(_M_CEE)
// #undef GetCurrentDirectory
public static native @Cast("DWORD") int GetCurrentDirectory(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPTSTR") CharPointer lpBuffer
    );
public static native @Cast("DWORD") int GetCurrentDirectory(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPTSTR") CharBuffer lpBuffer
    );
public static native @Cast("DWORD") int GetCurrentDirectory(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPTSTR") char[] lpBuffer
    );
// #endif  /* _M_CEE */

// #if _WIN32_WINNT >= 0x0502

public static native @Cast("BOOL") boolean SetDllDirectoryA(
    @Cast("LPCSTR") BytePointer lpPathName
    );
public static native @Cast("BOOL") boolean SetDllDirectoryA(
    @Cast("LPCSTR") ByteBuffer lpPathName
    );
public static native @Cast("BOOL") boolean SetDllDirectoryA(
    @Cast("LPCSTR") byte[] lpPathName
    );
public static native @Cast("BOOL") boolean SetDllDirectoryA(
    @Cast("LPCSTR") String lpPathName
    );
public static native @Cast("BOOL") boolean SetDllDirectoryW(
    @Cast("LPCWSTR") CharPointer lpPathName
    );
public static native @Cast("BOOL") boolean SetDllDirectoryW(
    @Cast("LPCWSTR") CharBuffer lpPathName
    );
public static native @Cast("BOOL") boolean SetDllDirectoryW(
    @Cast("LPCWSTR") char[] lpPathName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("DWORD") int GetDllDirectoryA(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") BytePointer lpBuffer
    );
public static native @Cast("DWORD") int GetDllDirectoryA(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") ByteBuffer lpBuffer
    );
public static native @Cast("DWORD") int GetDllDirectoryA(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") byte[] lpBuffer
    );
public static native @Cast("DWORD") int GetDllDirectoryW(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") CharPointer lpBuffer
    );
public static native @Cast("DWORD") int GetDllDirectoryW(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") CharBuffer lpBuffer
    );
public static native @Cast("DWORD") int GetDllDirectoryW(
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") char[] lpBuffer
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // _WIN32_WINNT >= 0x0502

public static final int BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE = 0x1;
public static final int BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE = 0x10000;
public static final int BASE_SEARCH_PATH_PERMANENT = 0x8000;
public static final int BASE_SEARCH_PATH_INVALID_FLAGS = ~0x18001;

public static native @Cast("BOOL") boolean SetSearchPathMode(
    @Cast("DWORD") int Flags
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

// #if defined(_M_CEE)
// #undef CreateDirectory
public static native @Cast("BOOL") boolean CreateDirectory(
    @Cast("LPCTSTR") CharPointer lpPathName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateDirectory(
    @Cast("LPCTSTR") CharBuffer lpPathName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateDirectory(
    @Cast("LPCTSTR") char[] lpPathName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
// #endif  /* _M_CEE */

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean CreateDirectoryExA(
    @Cast("LPCSTR") BytePointer lpTemplateDirectory,
    @Cast("LPCSTR") BytePointer lpNewDirectory,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateDirectoryExA(
    @Cast("LPCSTR") ByteBuffer lpTemplateDirectory,
    @Cast("LPCSTR") ByteBuffer lpNewDirectory,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateDirectoryExA(
    @Cast("LPCSTR") byte[] lpTemplateDirectory,
    @Cast("LPCSTR") byte[] lpNewDirectory,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateDirectoryExA(
    @Cast("LPCSTR") String lpTemplateDirectory,
    @Cast("LPCSTR") String lpNewDirectory,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateDirectoryExW(
    @Cast("LPCWSTR") CharPointer lpTemplateDirectory,
    @Cast("LPCWSTR") CharPointer lpNewDirectory,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateDirectoryExW(
    @Cast("LPCWSTR") CharBuffer lpTemplateDirectory,
    @Cast("LPCWSTR") CharBuffer lpNewDirectory,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateDirectoryExW(
    @Cast("LPCWSTR") char[] lpTemplateDirectory,
    @Cast("LPCWSTR") char[] lpNewDirectory,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #if _WIN32_WINNT >= 0x0600

public static native @Cast("BOOL") boolean CreateDirectoryTransactedA(
    @Cast("LPCSTR") BytePointer lpTemplateDirectory,
    @Cast("LPCSTR") BytePointer lpNewDirectory,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CreateDirectoryTransactedA(
    @Cast("LPCSTR") ByteBuffer lpTemplateDirectory,
    @Cast("LPCSTR") ByteBuffer lpNewDirectory,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CreateDirectoryTransactedA(
    @Cast("LPCSTR") byte[] lpTemplateDirectory,
    @Cast("LPCSTR") byte[] lpNewDirectory,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CreateDirectoryTransactedA(
    @Cast("LPCSTR") String lpTemplateDirectory,
    @Cast("LPCSTR") String lpNewDirectory,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CreateDirectoryTransactedW(
    @Cast("LPCWSTR") CharPointer lpTemplateDirectory,
    @Cast("LPCWSTR") CharPointer lpNewDirectory,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CreateDirectoryTransactedW(
    @Cast("LPCWSTR") CharBuffer lpTemplateDirectory,
    @Cast("LPCWSTR") CharBuffer lpNewDirectory,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CreateDirectoryTransactedW(
    @Cast("LPCWSTR") char[] lpTemplateDirectory,
    @Cast("LPCWSTR") char[] lpNewDirectory,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean RemoveDirectoryTransactedA(
    @Cast("LPCSTR") BytePointer lpPathName,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean RemoveDirectoryTransactedA(
    @Cast("LPCSTR") ByteBuffer lpPathName,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean RemoveDirectoryTransactedA(
    @Cast("LPCSTR") byte[] lpPathName,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean RemoveDirectoryTransactedA(
    @Cast("LPCSTR") String lpPathName,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean RemoveDirectoryTransactedW(
    @Cast("LPCWSTR") CharPointer lpPathName,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean RemoveDirectoryTransactedW(
    @Cast("LPCWSTR") CharBuffer lpPathName,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean RemoveDirectoryTransactedW(
    @Cast("LPCWSTR") char[] lpPathName,
    @Cast("HANDLE") Pointer hTransaction
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("DWORD") int GetFullPathNameTransactedA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetFullPathNameTransactedA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetFullPathNameTransactedA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetFullPathNameTransactedA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetFullPathNameTransactedA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetFullPathNameTransactedA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetFullPathNameTransactedA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetFullPathNameTransactedA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetFullPathNameTransactedA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetFullPathNameTransactedA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetFullPathNameTransactedA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetFullPathNameTransactedA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("LPSTR*") PointerPointer lpFilePart,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetFullPathNameTransactedW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") CharPointer lpBuffer,
    @Cast("LPWSTR*") PointerPointer lpFilePart,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetFullPathNameTransactedW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") CharBuffer lpBuffer,
    @Cast("LPWSTR*") PointerPointer lpFilePart,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetFullPathNameTransactedW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("DWORD") int nBufferLength,
    @Cast("LPWSTR") char[] lpBuffer,
    @Cast("LPWSTR*") PointerPointer lpFilePart,
    @Cast("HANDLE") Pointer hTransaction
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // _WIN32_WINNT >= 0x0600

public static final int DDD_RAW_TARGET_PATH =         0x00000001;
public static final int DDD_REMOVE_DEFINITION =       0x00000002;
public static final int DDD_EXACT_MATCH_ON_REMOVE =   0x00000004;
public static final int DDD_NO_BROADCAST_SYSTEM =     0x00000008;
public static final int DDD_LUID_BROADCAST_DRIVE =    0x00000010;

public static native @Cast("BOOL") boolean DefineDosDeviceA(
    @Cast("DWORD") int dwFlags,
    @Cast("LPCSTR") BytePointer lpDeviceName,
    @Cast("LPCSTR") BytePointer lpTargetPath
    );
public static native @Cast("BOOL") boolean DefineDosDeviceA(
    @Cast("DWORD") int dwFlags,
    @Cast("LPCSTR") ByteBuffer lpDeviceName,
    @Cast("LPCSTR") ByteBuffer lpTargetPath
    );
public static native @Cast("BOOL") boolean DefineDosDeviceA(
    @Cast("DWORD") int dwFlags,
    @Cast("LPCSTR") byte[] lpDeviceName,
    @Cast("LPCSTR") byte[] lpTargetPath
    );
public static native @Cast("BOOL") boolean DefineDosDeviceA(
    @Cast("DWORD") int dwFlags,
    @Cast("LPCSTR") String lpDeviceName,
    @Cast("LPCSTR") String lpTargetPath
    );
// #ifndef UNICODE
// #endif

public static native @Cast("DWORD") int QueryDosDeviceA(
    @Cast("LPCSTR") BytePointer lpDeviceName,
    @Cast("LPSTR") BytePointer lpTargetPath,
    @Cast("DWORD") int ucchMax
    );
public static native @Cast("DWORD") int QueryDosDeviceA(
    @Cast("LPCSTR") ByteBuffer lpDeviceName,
    @Cast("LPSTR") ByteBuffer lpTargetPath,
    @Cast("DWORD") int ucchMax
    );
public static native @Cast("DWORD") int QueryDosDeviceA(
    @Cast("LPCSTR") byte[] lpDeviceName,
    @Cast("LPSTR") byte[] lpTargetPath,
    @Cast("DWORD") int ucchMax
    );
public static native @Cast("DWORD") int QueryDosDeviceA(
    @Cast("LPCSTR") String lpDeviceName,
    @Cast("LPSTR") BytePointer lpTargetPath,
    @Cast("DWORD") int ucchMax
    );
public static native @Cast("DWORD") int QueryDosDeviceA(
    @Cast("LPCSTR") BytePointer lpDeviceName,
    @Cast("LPSTR") ByteBuffer lpTargetPath,
    @Cast("DWORD") int ucchMax
    );
public static native @Cast("DWORD") int QueryDosDeviceA(
    @Cast("LPCSTR") ByteBuffer lpDeviceName,
    @Cast("LPSTR") byte[] lpTargetPath,
    @Cast("DWORD") int ucchMax
    );
public static native @Cast("DWORD") int QueryDosDeviceA(
    @Cast("LPCSTR") byte[] lpDeviceName,
    @Cast("LPSTR") BytePointer lpTargetPath,
    @Cast("DWORD") int ucchMax
    );
public static native @Cast("DWORD") int QueryDosDeviceA(
    @Cast("LPCSTR") String lpDeviceName,
    @Cast("LPSTR") ByteBuffer lpTargetPath,
    @Cast("DWORD") int ucchMax
    );
public static native @Cast("DWORD") int QueryDosDeviceA(
    @Cast("LPCSTR") BytePointer lpDeviceName,
    @Cast("LPSTR") byte[] lpTargetPath,
    @Cast("DWORD") int ucchMax
    );
public static native @Cast("DWORD") int QueryDosDeviceA(
    @Cast("LPCSTR") ByteBuffer lpDeviceName,
    @Cast("LPSTR") BytePointer lpTargetPath,
    @Cast("DWORD") int ucchMax
    );
public static native @Cast("DWORD") int QueryDosDeviceA(
    @Cast("LPCSTR") byte[] lpDeviceName,
    @Cast("LPSTR") ByteBuffer lpTargetPath,
    @Cast("DWORD") int ucchMax
    );
public static native @Cast("DWORD") int QueryDosDeviceA(
    @Cast("LPCSTR") String lpDeviceName,
    @Cast("LPSTR") byte[] lpTargetPath,
    @Cast("DWORD") int ucchMax
    );
// #ifndef UNICODE
// #endif

// #define EXPAND_LOCAL_DRIVES

// #if _WIN32_WINNT >= 0x0600

public static native @Cast("HANDLE") Pointer CreateFileTransactedA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwShareMode,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("DWORD") int dwCreationDisposition,
    @Cast("DWORD") int dwFlagsAndAttributes,
    @Cast("HANDLE") Pointer hTemplateFile,
    @Cast("HANDLE") Pointer hTransaction,
    @Cast("PUSHORT") short pusMiniVersion,
    @Cast("PVOID") Pointer lpExtendedParameter
    );
public static native @Cast("HANDLE") Pointer CreateFileTransactedA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwShareMode,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("DWORD") int dwCreationDisposition,
    @Cast("DWORD") int dwFlagsAndAttributes,
    @Cast("HANDLE") Pointer hTemplateFile,
    @Cast("HANDLE") Pointer hTransaction,
    @Cast("PUSHORT") short pusMiniVersion,
    @Cast("PVOID") Pointer lpExtendedParameter
    );
public static native @Cast("HANDLE") Pointer CreateFileTransactedA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwShareMode,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("DWORD") int dwCreationDisposition,
    @Cast("DWORD") int dwFlagsAndAttributes,
    @Cast("HANDLE") Pointer hTemplateFile,
    @Cast("HANDLE") Pointer hTransaction,
    @Cast("PUSHORT") short pusMiniVersion,
    @Cast("PVOID") Pointer lpExtendedParameter
    );
public static native @Cast("HANDLE") Pointer CreateFileTransactedA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwShareMode,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("DWORD") int dwCreationDisposition,
    @Cast("DWORD") int dwFlagsAndAttributes,
    @Cast("HANDLE") Pointer hTemplateFile,
    @Cast("HANDLE") Pointer hTransaction,
    @Cast("PUSHORT") short pusMiniVersion,
    @Cast("PVOID") Pointer lpExtendedParameter
    );
public static native @Cast("HANDLE") Pointer CreateFileTransactedW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwShareMode,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("DWORD") int dwCreationDisposition,
    @Cast("DWORD") int dwFlagsAndAttributes,
    @Cast("HANDLE") Pointer hTemplateFile,
    @Cast("HANDLE") Pointer hTransaction,
    @Cast("PUSHORT") short pusMiniVersion,
    @Cast("PVOID") Pointer lpExtendedParameter
    );
public static native @Cast("HANDLE") Pointer CreateFileTransactedW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwShareMode,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("DWORD") int dwCreationDisposition,
    @Cast("DWORD") int dwFlagsAndAttributes,
    @Cast("HANDLE") Pointer hTemplateFile,
    @Cast("HANDLE") Pointer hTransaction,
    @Cast("PUSHORT") short pusMiniVersion,
    @Cast("PVOID") Pointer lpExtendedParameter
    );
public static native @Cast("HANDLE") Pointer CreateFileTransactedW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwShareMode,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("DWORD") int dwCreationDisposition,
    @Cast("DWORD") int dwFlagsAndAttributes,
    @Cast("HANDLE") Pointer hTemplateFile,
    @Cast("HANDLE") Pointer hTransaction,
    @Cast("PUSHORT") short pusMiniVersion,
    @Cast("PVOID") Pointer lpExtendedParameter
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // _WIN32_WINNT >= 0x0600


// #if _WIN32_WINNT >= 0x0502

public static native @Cast("HANDLE") Pointer ReOpenFile(
    @Cast("HANDLE") Pointer hOriginalFile,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwShareMode,
    @Cast("DWORD") int dwFlagsAndAttributes
    );

// #endif // _WIN32_WINNT >= 0x0502


// #if _WIN32_WINNT >= 0x0600

public static native @Cast("BOOL") boolean SetFileAttributesTransactedA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("DWORD") int dwFileAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean SetFileAttributesTransactedA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("DWORD") int dwFileAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean SetFileAttributesTransactedA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("DWORD") int dwFileAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean SetFileAttributesTransactedA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("DWORD") int dwFileAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean SetFileAttributesTransactedW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("DWORD") int dwFileAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean SetFileAttributesTransactedW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("DWORD") int dwFileAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean SetFileAttributesTransactedW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("DWORD") int dwFileAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean GetFileAttributesTransactedA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("GET_FILEEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFileInformation,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean GetFileAttributesTransactedA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("GET_FILEEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFileInformation,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean GetFileAttributesTransactedA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("GET_FILEEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFileInformation,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean GetFileAttributesTransactedA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("GET_FILEEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFileInformation,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean GetFileAttributesTransactedW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("GET_FILEEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFileInformation,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean GetFileAttributesTransactedW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("GET_FILEEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFileInformation,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean GetFileAttributesTransactedW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("GET_FILEEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFileInformation,
    @Cast("HANDLE") Pointer hTransaction
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("DWORD") int GetCompressedFileSizeTransactedA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("LPDWORD") IntPointer lpFileSizeHigh,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetCompressedFileSizeTransactedA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("LPDWORD") IntBuffer lpFileSizeHigh,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetCompressedFileSizeTransactedA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("LPDWORD") int[] lpFileSizeHigh,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetCompressedFileSizeTransactedA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("LPDWORD") IntPointer lpFileSizeHigh,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetCompressedFileSizeTransactedA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("LPDWORD") IntBuffer lpFileSizeHigh,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetCompressedFileSizeTransactedA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("LPDWORD") int[] lpFileSizeHigh,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetCompressedFileSizeTransactedA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("LPDWORD") IntPointer lpFileSizeHigh,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetCompressedFileSizeTransactedA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("LPDWORD") IntBuffer lpFileSizeHigh,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetCompressedFileSizeTransactedA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("LPDWORD") int[] lpFileSizeHigh,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetCompressedFileSizeTransactedA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("LPDWORD") IntPointer lpFileSizeHigh,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetCompressedFileSizeTransactedA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("LPDWORD") IntBuffer lpFileSizeHigh,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetCompressedFileSizeTransactedA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("LPDWORD") int[] lpFileSizeHigh,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetCompressedFileSizeTransactedW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("LPDWORD") IntPointer lpFileSizeHigh,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetCompressedFileSizeTransactedW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("LPDWORD") IntBuffer lpFileSizeHigh,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("DWORD") int GetCompressedFileSizeTransactedW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("LPDWORD") int[] lpFileSizeHigh,
    @Cast("HANDLE") Pointer hTransaction
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean DeleteFileTransactedA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean DeleteFileTransactedA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean DeleteFileTransactedA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean DeleteFileTransactedA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean DeleteFileTransactedW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean DeleteFileTransactedW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean DeleteFileTransactedW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("HANDLE") Pointer hTransaction
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // _WIN32_WINNT >= 0x0600

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

// #if defined(_M_CEE)
// #undef DeleteFile
public static native @Cast("BOOL") boolean DeleteFile(
    @Cast("LPCTSTR") CharPointer lpFileName
    );
public static native @Cast("BOOL") boolean DeleteFile(
    @Cast("LPCTSTR") CharBuffer lpFileName
    );
public static native @Cast("BOOL") boolean DeleteFile(
    @Cast("LPCTSTR") char[] lpFileName
    );
// #endif  /* _M_CEE */

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// #if _WIN32_WINNT >= 0x0501

public static native @Cast("BOOL") boolean CheckNameLegalDOS8Dot3A(
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("LPSTR") BytePointer lpOemName,
    @Cast("DWORD") int OemNameSize,
    @Cast("PBOOL") boolean pbNameContainsSpaces,
    @Cast("PBOOL") boolean pbNameLegal
    );
public static native @Cast("BOOL") boolean CheckNameLegalDOS8Dot3A(
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("LPSTR") ByteBuffer lpOemName,
    @Cast("DWORD") int OemNameSize,
    @Cast("PBOOL") boolean pbNameContainsSpaces,
    @Cast("PBOOL") boolean pbNameLegal
    );
public static native @Cast("BOOL") boolean CheckNameLegalDOS8Dot3A(
    @Cast("LPCSTR") byte[] lpName,
    @Cast("LPSTR") byte[] lpOemName,
    @Cast("DWORD") int OemNameSize,
    @Cast("PBOOL") boolean pbNameContainsSpaces,
    @Cast("PBOOL") boolean pbNameLegal
    );
public static native @Cast("BOOL") boolean CheckNameLegalDOS8Dot3A(
    @Cast("LPCSTR") String lpName,
    @Cast("LPSTR") BytePointer lpOemName,
    @Cast("DWORD") int OemNameSize,
    @Cast("PBOOL") boolean pbNameContainsSpaces,
    @Cast("PBOOL") boolean pbNameLegal
    );
public static native @Cast("BOOL") boolean CheckNameLegalDOS8Dot3A(
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("LPSTR") ByteBuffer lpOemName,
    @Cast("DWORD") int OemNameSize,
    @Cast("PBOOL") boolean pbNameContainsSpaces,
    @Cast("PBOOL") boolean pbNameLegal
    );
public static native @Cast("BOOL") boolean CheckNameLegalDOS8Dot3A(
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("LPSTR") byte[] lpOemName,
    @Cast("DWORD") int OemNameSize,
    @Cast("PBOOL") boolean pbNameContainsSpaces,
    @Cast("PBOOL") boolean pbNameLegal
    );
public static native @Cast("BOOL") boolean CheckNameLegalDOS8Dot3A(
    @Cast("LPCSTR") byte[] lpName,
    @Cast("LPSTR") BytePointer lpOemName,
    @Cast("DWORD") int OemNameSize,
    @Cast("PBOOL") boolean pbNameContainsSpaces,
    @Cast("PBOOL") boolean pbNameLegal
    );
public static native @Cast("BOOL") boolean CheckNameLegalDOS8Dot3A(
    @Cast("LPCSTR") String lpName,
    @Cast("LPSTR") ByteBuffer lpOemName,
    @Cast("DWORD") int OemNameSize,
    @Cast("PBOOL") boolean pbNameContainsSpaces,
    @Cast("PBOOL") boolean pbNameLegal
    );
public static native @Cast("BOOL") boolean CheckNameLegalDOS8Dot3A(
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("LPSTR") byte[] lpOemName,
    @Cast("DWORD") int OemNameSize,
    @Cast("PBOOL") boolean pbNameContainsSpaces,
    @Cast("PBOOL") boolean pbNameLegal
    );
public static native @Cast("BOOL") boolean CheckNameLegalDOS8Dot3A(
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("LPSTR") BytePointer lpOemName,
    @Cast("DWORD") int OemNameSize,
    @Cast("PBOOL") boolean pbNameContainsSpaces,
    @Cast("PBOOL") boolean pbNameLegal
    );
public static native @Cast("BOOL") boolean CheckNameLegalDOS8Dot3A(
    @Cast("LPCSTR") byte[] lpName,
    @Cast("LPSTR") ByteBuffer lpOemName,
    @Cast("DWORD") int OemNameSize,
    @Cast("PBOOL") boolean pbNameContainsSpaces,
    @Cast("PBOOL") boolean pbNameLegal
    );
public static native @Cast("BOOL") boolean CheckNameLegalDOS8Dot3A(
    @Cast("LPCSTR") String lpName,
    @Cast("LPSTR") byte[] lpOemName,
    @Cast("DWORD") int OemNameSize,
    @Cast("PBOOL") boolean pbNameContainsSpaces,
    @Cast("PBOOL") boolean pbNameLegal
    );
public static native @Cast("BOOL") boolean CheckNameLegalDOS8Dot3W(
    @Cast("LPCWSTR") CharPointer lpName,
    @Cast("LPSTR") BytePointer lpOemName,
    @Cast("DWORD") int OemNameSize,
    @Cast("PBOOL") boolean pbNameContainsSpaces,
    @Cast("PBOOL") boolean pbNameLegal
    );
public static native @Cast("BOOL") boolean CheckNameLegalDOS8Dot3W(
    @Cast("LPCWSTR") CharBuffer lpName,
    @Cast("LPSTR") ByteBuffer lpOemName,
    @Cast("DWORD") int OemNameSize,
    @Cast("PBOOL") boolean pbNameContainsSpaces,
    @Cast("PBOOL") boolean pbNameLegal
    );
public static native @Cast("BOOL") boolean CheckNameLegalDOS8Dot3W(
    @Cast("LPCWSTR") char[] lpName,
    @Cast("LPSTR") byte[] lpOemName,
    @Cast("DWORD") int OemNameSize,
    @Cast("PBOOL") boolean pbNameContainsSpaces,
    @Cast("PBOOL") boolean pbNameLegal
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // (_WIN32_WINNT >= 0x0501)

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #if(_WIN32_WINNT >= 0x0400)

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// #if _WIN32_WINNT >= 0x0600

public static native @Cast("HANDLE") Pointer FindFirstFileTransactedA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("FINDEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFindFileData,
    @Cast("FINDEX_SEARCH_OPS") int fSearchOp,
    @Cast("LPVOID") Pointer lpSearchFilter,
    @Cast("DWORD") int dwAdditionalFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("HANDLE") Pointer FindFirstFileTransactedA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("FINDEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFindFileData,
    @Cast("FINDEX_SEARCH_OPS") int fSearchOp,
    @Cast("LPVOID") Pointer lpSearchFilter,
    @Cast("DWORD") int dwAdditionalFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("HANDLE") Pointer FindFirstFileTransactedA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("FINDEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFindFileData,
    @Cast("FINDEX_SEARCH_OPS") int fSearchOp,
    @Cast("LPVOID") Pointer lpSearchFilter,
    @Cast("DWORD") int dwAdditionalFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("HANDLE") Pointer FindFirstFileTransactedA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("FINDEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFindFileData,
    @Cast("FINDEX_SEARCH_OPS") int fSearchOp,
    @Cast("LPVOID") Pointer lpSearchFilter,
    @Cast("DWORD") int dwAdditionalFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("HANDLE") Pointer FindFirstFileTransactedW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("FINDEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFindFileData,
    @Cast("FINDEX_SEARCH_OPS") int fSearchOp,
    @Cast("LPVOID") Pointer lpSearchFilter,
    @Cast("DWORD") int dwAdditionalFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("HANDLE") Pointer FindFirstFileTransactedW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("FINDEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFindFileData,
    @Cast("FINDEX_SEARCH_OPS") int fSearchOp,
    @Cast("LPVOID") Pointer lpSearchFilter,
    @Cast("DWORD") int dwAdditionalFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("HANDLE") Pointer FindFirstFileTransactedW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("FINDEX_INFO_LEVELS") int fInfoLevelId,
    @Cast("LPVOID") Pointer lpFindFileData,
    @Cast("FINDEX_SEARCH_OPS") int fSearchOp,
    @Cast("LPVOID") Pointer lpSearchFilter,
    @Cast("DWORD") int dwAdditionalFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif /* _WIN32_WINNT >= 0x0400 */

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


public static native @Cast("BOOL") boolean CopyFileA(
    @Cast("LPCSTR") BytePointer lpExistingFileName,
    @Cast("LPCSTR") BytePointer lpNewFileName,
    @Cast("BOOL") boolean bFailIfExists
    );
public static native @Cast("BOOL") boolean CopyFileA(
    @Cast("LPCSTR") ByteBuffer lpExistingFileName,
    @Cast("LPCSTR") ByteBuffer lpNewFileName,
    @Cast("BOOL") boolean bFailIfExists
    );
public static native @Cast("BOOL") boolean CopyFileA(
    @Cast("LPCSTR") byte[] lpExistingFileName,
    @Cast("LPCSTR") byte[] lpNewFileName,
    @Cast("BOOL") boolean bFailIfExists
    );
public static native @Cast("BOOL") boolean CopyFileA(
    @Cast("LPCSTR") String lpExistingFileName,
    @Cast("LPCSTR") String lpNewFileName,
    @Cast("BOOL") boolean bFailIfExists
    );
public static native @Cast("BOOL") boolean CopyFileW(
    @Cast("LPCWSTR") CharPointer lpExistingFileName,
    @Cast("LPCWSTR") CharPointer lpNewFileName,
    @Cast("BOOL") boolean bFailIfExists
    );
public static native @Cast("BOOL") boolean CopyFileW(
    @Cast("LPCWSTR") CharBuffer lpExistingFileName,
    @Cast("LPCWSTR") CharBuffer lpNewFileName,
    @Cast("BOOL") boolean bFailIfExists
    );
public static native @Cast("BOOL") boolean CopyFileW(
    @Cast("LPCWSTR") char[] lpExistingFileName,
    @Cast("LPCWSTR") char[] lpNewFileName,
    @Cast("BOOL") boolean bFailIfExists
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #if defined(_M_CEE)
// #undef CopyFile
public static native @Cast("BOOL") boolean CopyFile(
    @Cast("LPCTSTR") CharPointer lpExistingFileName,
    @Cast("LPCTSTR") CharPointer lpNewFileName,
    @Cast("BOOL") boolean bFailIfExists
    );
public static native @Cast("BOOL") boolean CopyFile(
    @Cast("LPCTSTR") CharBuffer lpExistingFileName,
    @Cast("LPCTSTR") CharBuffer lpNewFileName,
    @Cast("BOOL") boolean bFailIfExists
    );
public static native @Cast("BOOL") boolean CopyFile(
    @Cast("LPCTSTR") char[] lpExistingFileName,
    @Cast("LPCTSTR") char[] lpNewFileName,
    @Cast("BOOL") boolean bFailIfExists
    );
// #endif  /* _M_CEE */

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #if(_WIN32_WINNT >= 0x0400)

// #pragma region Desktop Family
// Targeting ..\windows\LPPROGRESS_ROUTINE.java



public static native @Cast("BOOL") boolean CopyFileExA(
    @Cast("LPCSTR") BytePointer lpExistingFileName,
    @Cast("LPCSTR") BytePointer lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("LPBOOL") boolean pbCancel,
    @Cast("DWORD") int dwCopyFlags
    );
public static native @Cast("BOOL") boolean CopyFileExA(
    @Cast("LPCSTR") ByteBuffer lpExistingFileName,
    @Cast("LPCSTR") ByteBuffer lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("LPBOOL") boolean pbCancel,
    @Cast("DWORD") int dwCopyFlags
    );
public static native @Cast("BOOL") boolean CopyFileExA(
    @Cast("LPCSTR") byte[] lpExistingFileName,
    @Cast("LPCSTR") byte[] lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("LPBOOL") boolean pbCancel,
    @Cast("DWORD") int dwCopyFlags
    );
public static native @Cast("BOOL") boolean CopyFileExA(
    @Cast("LPCSTR") String lpExistingFileName,
    @Cast("LPCSTR") String lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("LPBOOL") boolean pbCancel,
    @Cast("DWORD") int dwCopyFlags
    );
public static native @Cast("BOOL") boolean CopyFileExW(
    @Cast("LPCWSTR") CharPointer lpExistingFileName,
    @Cast("LPCWSTR") CharPointer lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("LPBOOL") boolean pbCancel,
    @Cast("DWORD") int dwCopyFlags
    );
public static native @Cast("BOOL") boolean CopyFileExW(
    @Cast("LPCWSTR") CharBuffer lpExistingFileName,
    @Cast("LPCWSTR") CharBuffer lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("LPBOOL") boolean pbCancel,
    @Cast("DWORD") int dwCopyFlags
    );
public static native @Cast("BOOL") boolean CopyFileExW(
    @Cast("LPCWSTR") char[] lpExistingFileName,
    @Cast("LPCWSTR") char[] lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("LPBOOL") boolean pbCancel,
    @Cast("DWORD") int dwCopyFlags
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #if _WIN32_WINNT >= 0x0600

public static native @Cast("BOOL") boolean CopyFileTransactedA(
    @Cast("LPCSTR") BytePointer lpExistingFileName,
    @Cast("LPCSTR") BytePointer lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("LPBOOL") boolean pbCancel,
    @Cast("DWORD") int dwCopyFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CopyFileTransactedA(
    @Cast("LPCSTR") ByteBuffer lpExistingFileName,
    @Cast("LPCSTR") ByteBuffer lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("LPBOOL") boolean pbCancel,
    @Cast("DWORD") int dwCopyFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CopyFileTransactedA(
    @Cast("LPCSTR") byte[] lpExistingFileName,
    @Cast("LPCSTR") byte[] lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("LPBOOL") boolean pbCancel,
    @Cast("DWORD") int dwCopyFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CopyFileTransactedA(
    @Cast("LPCSTR") String lpExistingFileName,
    @Cast("LPCSTR") String lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("LPBOOL") boolean pbCancel,
    @Cast("DWORD") int dwCopyFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CopyFileTransactedW(
    @Cast("LPCWSTR") CharPointer lpExistingFileName,
    @Cast("LPCWSTR") CharPointer lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("LPBOOL") boolean pbCancel,
    @Cast("DWORD") int dwCopyFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CopyFileTransactedW(
    @Cast("LPCWSTR") CharBuffer lpExistingFileName,
    @Cast("LPCWSTR") CharBuffer lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("LPBOOL") boolean pbCancel,
    @Cast("DWORD") int dwCopyFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CopyFileTransactedW(
    @Cast("LPCWSTR") char[] lpExistingFileName,
    @Cast("LPCWSTR") char[] lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("LPBOOL") boolean pbCancel,
    @Cast("DWORD") int dwCopyFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // _WIN32_WINNT >= 0x0600

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

//
// TODO: Win7 for now, when we roll over the version number this needs to be updated.
//

// #if _WIN32_WINNT >= 0x0601

/** enum COPYFILE2_MESSAGE_TYPE */
public static final int
     COPYFILE2_CALLBACK_NONE = 0,
     COPYFILE2_CALLBACK_CHUNK_STARTED = 1,
     COPYFILE2_CALLBACK_CHUNK_FINISHED = 2,
     COPYFILE2_CALLBACK_STREAM_STARTED = 3,
     COPYFILE2_CALLBACK_STREAM_FINISHED = 4,
     COPYFILE2_CALLBACK_POLL_CONTINUE = 5,
     COPYFILE2_CALLBACK_ERROR = 6,
     COPYFILE2_CALLBACK_MAX = 7;

/** enum COPYFILE2_MESSAGE_ACTION */
public static final int
    COPYFILE2_PROGRESS_CONTINUE = 0,
    COPYFILE2_PROGRESS_CANCEL = 1,
    COPYFILE2_PROGRESS_STOP = 2,
    COPYFILE2_PROGRESS_QUIET = 3,
    COPYFILE2_PROGRESS_PAUSE = 4;

/** enum COPYFILE2_COPY_PHASE */
public static final int
    COPYFILE2_PHASE_NONE = 0,
    COPYFILE2_PHASE_PREPARE_SOURCE = 1,
    COPYFILE2_PHASE_PREPARE_DEST = 2,
    COPYFILE2_PHASE_READ_SOURCE = 3,
    COPYFILE2_PHASE_WRITE_DESTINATION = 4,
    COPYFILE2_PHASE_SERVER_COPY = 5,
    COPYFILE2_PHASE_NAMEGRAFT_COPY = 6,
    // ... etc phases.
    COPYFILE2_PHASE_MAX = 7;

public static final long COPYFILE2_MESSAGE_COPY_OFFLOAD =     (0x00000001L);
// Targeting ..\windows\COPYFILE2_MESSAGE.java


// Targeting ..\windows\PCOPYFILE2_PROGRESS_ROUTINE.java


// Targeting ..\windows\COPYFILE2_EXTENDED_PARAMETERS.java



public static native @Cast("HRESULT") int CopyFile2(
  @Cast("PCWSTR") CharPointer pwszExistingFileName,
  @Cast("PCWSTR") CharPointer pwszNewFileName,
  COPYFILE2_EXTENDED_PARAMETERS pExtendedParameters
);
public static native @Cast("HRESULT") int CopyFile2(
  @Cast("PCWSTR") CharBuffer pwszExistingFileName,
  @Cast("PCWSTR") CharBuffer pwszNewFileName,
  COPYFILE2_EXTENDED_PARAMETERS pExtendedParameters
);
public static native @Cast("HRESULT") int CopyFile2(
  @Cast("PCWSTR") char[] pwszExistingFileName,
  @Cast("PCWSTR") char[] pwszNewFileName,
  COPYFILE2_EXTENDED_PARAMETERS pExtendedParameters
);

// #endif // _WIN32_WINNT >= 0x0601

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #endif /* _WIN32_WINNT >= 0x0400 */

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean MoveFileA(
    @Cast("LPCSTR") BytePointer lpExistingFileName,
    @Cast("LPCSTR") BytePointer lpNewFileName
    );
public static native @Cast("BOOL") boolean MoveFileA(
    @Cast("LPCSTR") ByteBuffer lpExistingFileName,
    @Cast("LPCSTR") ByteBuffer lpNewFileName
    );
public static native @Cast("BOOL") boolean MoveFileA(
    @Cast("LPCSTR") byte[] lpExistingFileName,
    @Cast("LPCSTR") byte[] lpNewFileName
    );
public static native @Cast("BOOL") boolean MoveFileA(
    @Cast("LPCSTR") String lpExistingFileName,
    @Cast("LPCSTR") String lpNewFileName
    );
public static native @Cast("BOOL") boolean MoveFileW(
    @Cast("LPCWSTR") CharPointer lpExistingFileName,
    @Cast("LPCWSTR") CharPointer lpNewFileName
    );
public static native @Cast("BOOL") boolean MoveFileW(
    @Cast("LPCWSTR") CharBuffer lpExistingFileName,
    @Cast("LPCWSTR") CharBuffer lpNewFileName
    );
public static native @Cast("BOOL") boolean MoveFileW(
    @Cast("LPCWSTR") char[] lpExistingFileName,
    @Cast("LPCWSTR") char[] lpNewFileName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #if defined(_M_CEE)
// #undef MoveFile
public static native @Cast("BOOL") boolean MoveFile(
    @Cast("LPCTSTR") CharPointer lpExistingFileName,
    @Cast("LPCTSTR") CharPointer lpNewFileName
    );
public static native @Cast("BOOL") boolean MoveFile(
    @Cast("LPCTSTR") CharBuffer lpExistingFileName,
    @Cast("LPCTSTR") CharBuffer lpNewFileName
    );
public static native @Cast("BOOL") boolean MoveFile(
    @Cast("LPCTSTR") char[] lpExistingFileName,
    @Cast("LPCTSTR") char[] lpNewFileName
    );
// #endif  /* _M_CEE */

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean MoveFileExA(
    @Cast("LPCSTR") BytePointer lpExistingFileName,
    @Cast("LPCSTR") BytePointer lpNewFileName,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOL") boolean MoveFileExA(
    @Cast("LPCSTR") ByteBuffer lpExistingFileName,
    @Cast("LPCSTR") ByteBuffer lpNewFileName,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOL") boolean MoveFileExA(
    @Cast("LPCSTR") byte[] lpExistingFileName,
    @Cast("LPCSTR") byte[] lpNewFileName,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOL") boolean MoveFileExA(
    @Cast("LPCSTR") String lpExistingFileName,
    @Cast("LPCSTR") String lpNewFileName,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOL") boolean MoveFileExW(
    @Cast("LPCWSTR") CharPointer lpExistingFileName,
    @Cast("LPCWSTR") CharPointer lpNewFileName,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOL") boolean MoveFileExW(
    @Cast("LPCWSTR") CharBuffer lpExistingFileName,
    @Cast("LPCWSTR") CharBuffer lpNewFileName,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOL") boolean MoveFileExW(
    @Cast("LPCWSTR") char[] lpExistingFileName,
    @Cast("LPCWSTR") char[] lpNewFileName,
    @Cast("DWORD") int dwFlags
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// #if (_WIN32_WINNT >= 0x0500)
public static native @Cast("BOOL") boolean MoveFileWithProgressA(
    @Cast("LPCSTR") BytePointer lpExistingFileName,
    @Cast("LPCSTR") BytePointer lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOL") boolean MoveFileWithProgressA(
    @Cast("LPCSTR") ByteBuffer lpExistingFileName,
    @Cast("LPCSTR") ByteBuffer lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOL") boolean MoveFileWithProgressA(
    @Cast("LPCSTR") byte[] lpExistingFileName,
    @Cast("LPCSTR") byte[] lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOL") boolean MoveFileWithProgressA(
    @Cast("LPCSTR") String lpExistingFileName,
    @Cast("LPCSTR") String lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOL") boolean MoveFileWithProgressW(
    @Cast("LPCWSTR") CharPointer lpExistingFileName,
    @Cast("LPCWSTR") CharPointer lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOL") boolean MoveFileWithProgressW(
    @Cast("LPCWSTR") CharBuffer lpExistingFileName,
    @Cast("LPCWSTR") CharBuffer lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOL") boolean MoveFileWithProgressW(
    @Cast("LPCWSTR") char[] lpExistingFileName,
    @Cast("LPCWSTR") char[] lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int dwFlags
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE
// #endif // (_WIN32_WINNT >= 0x0500)

// #if (_WIN32_WINNT >= 0x0600)
public static native @Cast("BOOL") boolean MoveFileTransactedA(
    @Cast("LPCSTR") BytePointer lpExistingFileName,
    @Cast("LPCSTR") BytePointer lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean MoveFileTransactedA(
    @Cast("LPCSTR") ByteBuffer lpExistingFileName,
    @Cast("LPCSTR") ByteBuffer lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean MoveFileTransactedA(
    @Cast("LPCSTR") byte[] lpExistingFileName,
    @Cast("LPCSTR") byte[] lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean MoveFileTransactedA(
    @Cast("LPCSTR") String lpExistingFileName,
    @Cast("LPCSTR") String lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean MoveFileTransactedW(
    @Cast("LPCWSTR") CharPointer lpExistingFileName,
    @Cast("LPCWSTR") CharPointer lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean MoveFileTransactedW(
    @Cast("LPCWSTR") CharBuffer lpExistingFileName,
    @Cast("LPCWSTR") CharBuffer lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean MoveFileTransactedW(
    @Cast("LPCWSTR") char[] lpExistingFileName,
    @Cast("LPCWSTR") char[] lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    @Cast("LPVOID") Pointer lpData,
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE
// #endif // (_WIN32_WINNT >= 0x0600)

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static final int MOVEFILE_REPLACE_EXISTING =       0x00000001;
public static final int MOVEFILE_COPY_ALLOWED =           0x00000002;
public static final int MOVEFILE_DELAY_UNTIL_REBOOT =     0x00000004;
public static final int MOVEFILE_WRITE_THROUGH =          0x00000008;
// #if (_WIN32_WINNT >= 0x0500)
public static final int MOVEFILE_CREATE_HARDLINK =        0x00000010;
public static final int MOVEFILE_FAIL_IF_NOT_TRACKABLE =  0x00000020;
// #endif // (_WIN32_WINNT >= 0x0500)

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #if (_WIN32_WINNT >= 0x0500)

public static native @Cast("BOOL") boolean ReplaceFileA(
    @Cast("LPCSTR") BytePointer lpReplacedFileName,
    @Cast("LPCSTR") BytePointer lpReplacementFileName,
    @Cast("LPCSTR") BytePointer lpBackupFileName,
    @Cast("DWORD") int dwReplaceFlags,
    @Cast("LPVOID") Pointer lpExclude,
    @Cast("LPVOID") Pointer lpReserved
    );
public static native @Cast("BOOL") boolean ReplaceFileA(
    @Cast("LPCSTR") ByteBuffer lpReplacedFileName,
    @Cast("LPCSTR") ByteBuffer lpReplacementFileName,
    @Cast("LPCSTR") ByteBuffer lpBackupFileName,
    @Cast("DWORD") int dwReplaceFlags,
    @Cast("LPVOID") Pointer lpExclude,
    @Cast("LPVOID") Pointer lpReserved
    );
public static native @Cast("BOOL") boolean ReplaceFileA(
    @Cast("LPCSTR") byte[] lpReplacedFileName,
    @Cast("LPCSTR") byte[] lpReplacementFileName,
    @Cast("LPCSTR") byte[] lpBackupFileName,
    @Cast("DWORD") int dwReplaceFlags,
    @Cast("LPVOID") Pointer lpExclude,
    @Cast("LPVOID") Pointer lpReserved
    );
public static native @Cast("BOOL") boolean ReplaceFileA(
    @Cast("LPCSTR") String lpReplacedFileName,
    @Cast("LPCSTR") String lpReplacementFileName,
    @Cast("LPCSTR") String lpBackupFileName,
    @Cast("DWORD") int dwReplaceFlags,
    @Cast("LPVOID") Pointer lpExclude,
    @Cast("LPVOID") Pointer lpReserved
    );
public static native @Cast("BOOL") boolean ReplaceFileW(
    @Cast("LPCWSTR") CharPointer lpReplacedFileName,
    @Cast("LPCWSTR") CharPointer lpReplacementFileName,
    @Cast("LPCWSTR") CharPointer lpBackupFileName,
    @Cast("DWORD") int dwReplaceFlags,
    @Cast("LPVOID") Pointer lpExclude,
    @Cast("LPVOID") Pointer lpReserved
    );
public static native @Cast("BOOL") boolean ReplaceFileW(
    @Cast("LPCWSTR") CharBuffer lpReplacedFileName,
    @Cast("LPCWSTR") CharBuffer lpReplacementFileName,
    @Cast("LPCWSTR") CharBuffer lpBackupFileName,
    @Cast("DWORD") int dwReplaceFlags,
    @Cast("LPVOID") Pointer lpExclude,
    @Cast("LPVOID") Pointer lpReserved
    );
public static native @Cast("BOOL") boolean ReplaceFileW(
    @Cast("LPCWSTR") char[] lpReplacedFileName,
    @Cast("LPCWSTR") char[] lpReplacementFileName,
    @Cast("LPCWSTR") char[] lpBackupFileName,
    @Cast("DWORD") int dwReplaceFlags,
    @Cast("LPVOID") Pointer lpExclude,
    @Cast("LPVOID") Pointer lpReserved
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE
// #endif // (_WIN32_WINNT >= 0x0500)


// #if (_WIN32_WINNT >= 0x0500)
//
// API call to create hard links.
//

public static native @Cast("BOOL") boolean CreateHardLinkA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("LPCSTR") BytePointer lpExistingFileName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateHardLinkA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("LPCSTR") ByteBuffer lpExistingFileName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateHardLinkA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("LPCSTR") byte[] lpExistingFileName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateHardLinkA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("LPCSTR") String lpExistingFileName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateHardLinkW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("LPCWSTR") CharPointer lpExistingFileName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateHardLinkW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("LPCWSTR") CharBuffer lpExistingFileName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("BOOL") boolean CreateHardLinkW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("LPCWSTR") char[] lpExistingFileName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // (_WIN32_WINNT >= 0x0500)

// #if (_WIN32_WINNT >= 0x0600)
//
// API call to create hard links.
//

public static native @Cast("BOOL") boolean CreateHardLinkTransactedA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("LPCSTR") BytePointer lpExistingFileName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CreateHardLinkTransactedA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("LPCSTR") ByteBuffer lpExistingFileName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CreateHardLinkTransactedA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("LPCSTR") byte[] lpExistingFileName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CreateHardLinkTransactedA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("LPCSTR") String lpExistingFileName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CreateHardLinkTransactedW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("LPCWSTR") CharPointer lpExistingFileName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CreateHardLinkTransactedW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("LPCWSTR") CharBuffer lpExistingFileName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOL") boolean CreateHardLinkTransactedW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("LPCWSTR") char[] lpExistingFileName,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("HANDLE") Pointer hTransaction
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // (_WIN32_WINNT >= 0x0600)


// #if (_WIN32_WINNT >= 0x0501)

//
// API call to enumerate for streams within a file
//

/** enum STREAM_INFO_LEVELS */
public static final int

    FindStreamInfoStandard = 0,
    FindStreamInfoMaxInfoLevel = 1;
// Targeting ..\windows\WIN32_FIND_STREAM_DATA.java



public static native @Cast("HANDLE") Pointer FindFirstStreamW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("STREAM_INFO_LEVELS") int InfoLevel,
    @Cast("LPVOID") Pointer lpFindStreamData,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("HANDLE") Pointer FindFirstStreamW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("STREAM_INFO_LEVELS") int InfoLevel,
    @Cast("LPVOID") Pointer lpFindStreamData,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("HANDLE") Pointer FindFirstStreamW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("STREAM_INFO_LEVELS") int InfoLevel,
    @Cast("LPVOID") Pointer lpFindStreamData,
    @Cast("DWORD") int dwFlags
    );

// #if _WIN32_WINNT >= 0x0600
public static native @Cast("HANDLE") Pointer FindFirstStreamTransactedW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("STREAM_INFO_LEVELS") int InfoLevel,
    @Cast("LPVOID") Pointer lpFindStreamData,
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("HANDLE") Pointer FindFirstStreamTransactedW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("STREAM_INFO_LEVELS") int InfoLevel,
    @Cast("LPVOID") Pointer lpFindStreamData,
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("HANDLE") Pointer FindFirstStreamTransactedW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("STREAM_INFO_LEVELS") int InfoLevel,
    @Cast("LPVOID") Pointer lpFindStreamData,
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
// #endif // _WIN32_WINNT >= 0x600

public static native @Cast("BOOL") boolean FindNextStreamW(
    @Cast("HANDLE") Pointer hFindStream,
    @Cast("LPVOID") Pointer lpFindStreamData
    );
// #endif // (_WIN32_WINNT >= 0x0501)

// #if _WIN32_WINNT >= 0x0600

public static native @Cast("HANDLE") Pointer FindFirstFileNameW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("DWORD") int dwFlags,
    @Cast("LPDWORD") IntPointer StringLength,
    @Cast("PWSTR") CharPointer LinkName
    );
public static native @Cast("HANDLE") Pointer FindFirstFileNameW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("DWORD") int dwFlags,
    @Cast("LPDWORD") IntBuffer StringLength,
    @Cast("PWSTR") CharBuffer LinkName
    );
public static native @Cast("HANDLE") Pointer FindFirstFileNameW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("DWORD") int dwFlags,
    @Cast("LPDWORD") int[] StringLength,
    @Cast("PWSTR") char[] LinkName
    );

public static native @Cast("BOOL") boolean FindNextFileNameW(
    @Cast("HANDLE") Pointer hFindStream,
    @Cast("LPDWORD") IntPointer StringLength,
    @Cast("PWSTR") CharPointer LinkName
    );
public static native @Cast("BOOL") boolean FindNextFileNameW(
    @Cast("HANDLE") Pointer hFindStream,
    @Cast("LPDWORD") IntBuffer StringLength,
    @Cast("PWSTR") CharBuffer LinkName
    );
public static native @Cast("BOOL") boolean FindNextFileNameW(
    @Cast("HANDLE") Pointer hFindStream,
    @Cast("LPDWORD") int[] StringLength,
    @Cast("PWSTR") char[] LinkName
    );

public static native @Cast("HANDLE") Pointer FindFirstFileNameTransactedW(
    @Cast("LPCWSTR") CharPointer lpFileName,
    @Cast("DWORD") int dwFlags,
    @Cast("LPDWORD") IntPointer StringLength,
    @Cast("PWSTR") CharPointer LinkName,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("HANDLE") Pointer FindFirstFileNameTransactedW(
    @Cast("LPCWSTR") CharBuffer lpFileName,
    @Cast("DWORD") int dwFlags,
    @Cast("LPDWORD") IntBuffer StringLength,
    @Cast("PWSTR") CharBuffer LinkName,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("HANDLE") Pointer FindFirstFileNameTransactedW(
    @Cast("LPCWSTR") char[] lpFileName,
    @Cast("DWORD") int dwFlags,
    @Cast("LPDWORD") int[] StringLength,
    @Cast("PWSTR") char[] LinkName,
    @Cast("HANDLE") Pointer hTransaction
    );

// #endif

public static native @Cast("HANDLE") Pointer CreateNamedPipeA(
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("DWORD") int dwOpenMode,
    @Cast("DWORD") int dwPipeMode,
    @Cast("DWORD") int nMaxInstances,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("DWORD") int nInBufferSize,
    @Cast("DWORD") int nDefaultTimeOut,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("HANDLE") Pointer CreateNamedPipeA(
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("DWORD") int dwOpenMode,
    @Cast("DWORD") int dwPipeMode,
    @Cast("DWORD") int nMaxInstances,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("DWORD") int nInBufferSize,
    @Cast("DWORD") int nDefaultTimeOut,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("HANDLE") Pointer CreateNamedPipeA(
    @Cast("LPCSTR") byte[] lpName,
    @Cast("DWORD") int dwOpenMode,
    @Cast("DWORD") int dwPipeMode,
    @Cast("DWORD") int nMaxInstances,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("DWORD") int nInBufferSize,
    @Cast("DWORD") int nDefaultTimeOut,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
public static native @Cast("HANDLE") Pointer CreateNamedPipeA(
    @Cast("LPCSTR") String lpName,
    @Cast("DWORD") int dwOpenMode,
    @Cast("DWORD") int dwPipeMode,
    @Cast("DWORD") int nMaxInstances,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("DWORD") int nInBufferSize,
    @Cast("DWORD") int nDefaultTimeOut,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes
    );
// #ifndef UNICODE
// #endif

public static native @Cast("BOOL") boolean GetNamedPipeHandleStateA(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPDWORD") IntPointer lpState,
    @Cast("LPDWORD") IntPointer lpCurInstances,
    @Cast("LPDWORD") IntPointer lpMaxCollectionCount,
    @Cast("LPDWORD") IntPointer lpCollectDataTimeout,
    @Cast("LPSTR") BytePointer lpUserName,
    @Cast("DWORD") int nMaxUserNameSize
    );
public static native @Cast("BOOL") boolean GetNamedPipeHandleStateA(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPDWORD") IntBuffer lpState,
    @Cast("LPDWORD") IntBuffer lpCurInstances,
    @Cast("LPDWORD") IntBuffer lpMaxCollectionCount,
    @Cast("LPDWORD") IntBuffer lpCollectDataTimeout,
    @Cast("LPSTR") ByteBuffer lpUserName,
    @Cast("DWORD") int nMaxUserNameSize
    );
public static native @Cast("BOOL") boolean GetNamedPipeHandleStateA(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPDWORD") int[] lpState,
    @Cast("LPDWORD") int[] lpCurInstances,
    @Cast("LPDWORD") int[] lpMaxCollectionCount,
    @Cast("LPDWORD") int[] lpCollectDataTimeout,
    @Cast("LPSTR") byte[] lpUserName,
    @Cast("DWORD") int nMaxUserNameSize
    );
public static native @Cast("BOOL") boolean GetNamedPipeHandleStateW(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPDWORD") IntPointer lpState,
    @Cast("LPDWORD") IntPointer lpCurInstances,
    @Cast("LPDWORD") IntPointer lpMaxCollectionCount,
    @Cast("LPDWORD") IntPointer lpCollectDataTimeout,
    @Cast("LPWSTR") CharPointer lpUserName,
    @Cast("DWORD") int nMaxUserNameSize
    );
public static native @Cast("BOOL") boolean GetNamedPipeHandleStateW(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPDWORD") IntBuffer lpState,
    @Cast("LPDWORD") IntBuffer lpCurInstances,
    @Cast("LPDWORD") IntBuffer lpMaxCollectionCount,
    @Cast("LPDWORD") IntBuffer lpCollectDataTimeout,
    @Cast("LPWSTR") CharBuffer lpUserName,
    @Cast("DWORD") int nMaxUserNameSize
    );
public static native @Cast("BOOL") boolean GetNamedPipeHandleStateW(
    @Cast("HANDLE") Pointer hNamedPipe,
    @Cast("LPDWORD") int[] lpState,
    @Cast("LPDWORD") int[] lpCurInstances,
    @Cast("LPDWORD") int[] lpMaxCollectionCount,
    @Cast("LPDWORD") int[] lpCollectDataTimeout,
    @Cast("LPWSTR") char[] lpUserName,
    @Cast("DWORD") int nMaxUserNameSize
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean CallNamedPipeA(
    @Cast("LPCSTR") BytePointer lpNamedPipeName,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") IntPointer lpBytesRead,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean CallNamedPipeA(
    @Cast("LPCSTR") ByteBuffer lpNamedPipeName,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") IntBuffer lpBytesRead,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean CallNamedPipeA(
    @Cast("LPCSTR") byte[] lpNamedPipeName,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") int[] lpBytesRead,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean CallNamedPipeA(
    @Cast("LPCSTR") String lpNamedPipeName,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") IntPointer lpBytesRead,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean CallNamedPipeA(
    @Cast("LPCSTR") BytePointer lpNamedPipeName,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") IntBuffer lpBytesRead,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean CallNamedPipeA(
    @Cast("LPCSTR") ByteBuffer lpNamedPipeName,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") int[] lpBytesRead,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean CallNamedPipeA(
    @Cast("LPCSTR") byte[] lpNamedPipeName,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") IntPointer lpBytesRead,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean CallNamedPipeA(
    @Cast("LPCSTR") String lpNamedPipeName,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") IntBuffer lpBytesRead,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean CallNamedPipeA(
    @Cast("LPCSTR") BytePointer lpNamedPipeName,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") int[] lpBytesRead,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean CallNamedPipeA(
    @Cast("LPCSTR") ByteBuffer lpNamedPipeName,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") IntPointer lpBytesRead,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean CallNamedPipeA(
    @Cast("LPCSTR") byte[] lpNamedPipeName,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") IntBuffer lpBytesRead,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean CallNamedPipeA(
    @Cast("LPCSTR") String lpNamedPipeName,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") int[] lpBytesRead,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean CallNamedPipeW(
    @Cast("LPCWSTR") CharPointer lpNamedPipeName,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") IntPointer lpBytesRead,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean CallNamedPipeW(
    @Cast("LPCWSTR") CharBuffer lpNamedPipeName,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") IntBuffer lpBytesRead,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean CallNamedPipeW(
    @Cast("LPCWSTR") char[] lpNamedPipeName,
    @Cast("LPVOID") Pointer lpInBuffer,
    @Cast("DWORD") int nInBufferSize,
    @Cast("LPVOID") Pointer lpOutBuffer,
    @Cast("DWORD") int nOutBufferSize,
    @Cast("LPDWORD") int[] lpBytesRead,
    @Cast("DWORD") int nTimeOut
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean WaitNamedPipeA(
    @Cast("LPCSTR") BytePointer lpNamedPipeName,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean WaitNamedPipeA(
    @Cast("LPCSTR") ByteBuffer lpNamedPipeName,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean WaitNamedPipeA(
    @Cast("LPCSTR") byte[] lpNamedPipeName,
    @Cast("DWORD") int nTimeOut
    );
public static native @Cast("BOOL") boolean WaitNamedPipeA(
    @Cast("LPCSTR") String lpNamedPipeName,
    @Cast("DWORD") int nTimeOut
    );
// #ifndef UNICODE
// #endif

// #if (_WIN32_WINNT >= 0x0600)


public static native @Cast("BOOL") boolean GetNamedPipeClientComputerNameA(
    @Cast("HANDLE") Pointer Pipe,
    @Cast("LPSTR") BytePointer ClientComputerName,
    @Cast("ULONG") long ClientComputerNameLength
    );
public static native @Cast("BOOL") boolean GetNamedPipeClientComputerNameA(
    @Cast("HANDLE") Pointer Pipe,
    @Cast("LPSTR") ByteBuffer ClientComputerName,
    @Cast("ULONG") long ClientComputerNameLength
    );
public static native @Cast("BOOL") boolean GetNamedPipeClientComputerNameA(
    @Cast("HANDLE") Pointer Pipe,
    @Cast("LPSTR") byte[] ClientComputerName,
    @Cast("ULONG") long ClientComputerNameLength
    );

// #ifndef UNICODE
// #endif

public static native @Cast("BOOL") boolean GetNamedPipeClientProcessId(
    @Cast("HANDLE") Pointer Pipe,
    @Cast("PULONG") long ClientProcessId
    );

public static native @Cast("BOOL") boolean GetNamedPipeClientSessionId(
    @Cast("HANDLE") Pointer Pipe,
    @Cast("PULONG") long ClientSessionId
    );

public static native @Cast("BOOL") boolean GetNamedPipeServerProcessId(
    @Cast("HANDLE") Pointer Pipe,
    @Cast("PULONG") long ServerProcessId
    );

public static native @Cast("BOOL") boolean GetNamedPipeServerSessionId(
    @Cast("HANDLE") Pointer Pipe,
    @Cast("PULONG") long ServerSessionId
    );

// #endif // (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean SetVolumeLabelA(
    @Cast("LPCSTR") BytePointer lpRootPathName,
    @Cast("LPCSTR") BytePointer lpVolumeName
    );
public static native @Cast("BOOL") boolean SetVolumeLabelA(
    @Cast("LPCSTR") ByteBuffer lpRootPathName,
    @Cast("LPCSTR") ByteBuffer lpVolumeName
    );
public static native @Cast("BOOL") boolean SetVolumeLabelA(
    @Cast("LPCSTR") byte[] lpRootPathName,
    @Cast("LPCSTR") byte[] lpVolumeName
    );
public static native @Cast("BOOL") boolean SetVolumeLabelA(
    @Cast("LPCSTR") String lpRootPathName,
    @Cast("LPCSTR") String lpVolumeName
    );
public static native @Cast("BOOL") boolean SetVolumeLabelW(
    @Cast("LPCWSTR") CharPointer lpRootPathName,
    @Cast("LPCWSTR") CharPointer lpVolumeName
    );
public static native @Cast("BOOL") boolean SetVolumeLabelW(
    @Cast("LPCWSTR") CharBuffer lpRootPathName,
    @Cast("LPCWSTR") CharBuffer lpVolumeName
    );
public static native @Cast("BOOL") boolean SetVolumeLabelW(
    @Cast("LPCWSTR") char[] lpRootPathName,
    @Cast("LPCWSTR") char[] lpVolumeName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native void SetFileApisToOEM( );

public static native void SetFileApisToANSI( );

public static native @Cast("BOOL") boolean AreFileApisANSI( );

public static native @Cast("BOOL") boolean GetVolumeInformationA(
    @Cast("LPCSTR") BytePointer lpRootPathName,
    @Cast("LPSTR") BytePointer lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") IntPointer lpVolumeSerialNumber,
    @Cast("LPDWORD") IntPointer lpMaximumComponentLength,
    @Cast("LPDWORD") IntPointer lpFileSystemFlags,
    @Cast("LPSTR") BytePointer lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );
public static native @Cast("BOOL") boolean GetVolumeInformationA(
    @Cast("LPCSTR") ByteBuffer lpRootPathName,
    @Cast("LPSTR") ByteBuffer lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") IntBuffer lpVolumeSerialNumber,
    @Cast("LPDWORD") IntBuffer lpMaximumComponentLength,
    @Cast("LPDWORD") IntBuffer lpFileSystemFlags,
    @Cast("LPSTR") ByteBuffer lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );
public static native @Cast("BOOL") boolean GetVolumeInformationA(
    @Cast("LPCSTR") byte[] lpRootPathName,
    @Cast("LPSTR") byte[] lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") int[] lpVolumeSerialNumber,
    @Cast("LPDWORD") int[] lpMaximumComponentLength,
    @Cast("LPDWORD") int[] lpFileSystemFlags,
    @Cast("LPSTR") byte[] lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );
public static native @Cast("BOOL") boolean GetVolumeInformationA(
    @Cast("LPCSTR") String lpRootPathName,
    @Cast("LPSTR") BytePointer lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") IntPointer lpVolumeSerialNumber,
    @Cast("LPDWORD") IntPointer lpMaximumComponentLength,
    @Cast("LPDWORD") IntPointer lpFileSystemFlags,
    @Cast("LPSTR") BytePointer lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );
public static native @Cast("BOOL") boolean GetVolumeInformationA(
    @Cast("LPCSTR") BytePointer lpRootPathName,
    @Cast("LPSTR") ByteBuffer lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") IntBuffer lpVolumeSerialNumber,
    @Cast("LPDWORD") IntBuffer lpMaximumComponentLength,
    @Cast("LPDWORD") IntBuffer lpFileSystemFlags,
    @Cast("LPSTR") ByteBuffer lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );
public static native @Cast("BOOL") boolean GetVolumeInformationA(
    @Cast("LPCSTR") ByteBuffer lpRootPathName,
    @Cast("LPSTR") byte[] lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") int[] lpVolumeSerialNumber,
    @Cast("LPDWORD") int[] lpMaximumComponentLength,
    @Cast("LPDWORD") int[] lpFileSystemFlags,
    @Cast("LPSTR") byte[] lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );
public static native @Cast("BOOL") boolean GetVolumeInformationA(
    @Cast("LPCSTR") byte[] lpRootPathName,
    @Cast("LPSTR") BytePointer lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") IntPointer lpVolumeSerialNumber,
    @Cast("LPDWORD") IntPointer lpMaximumComponentLength,
    @Cast("LPDWORD") IntPointer lpFileSystemFlags,
    @Cast("LPSTR") BytePointer lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );
public static native @Cast("BOOL") boolean GetVolumeInformationA(
    @Cast("LPCSTR") String lpRootPathName,
    @Cast("LPSTR") ByteBuffer lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") IntBuffer lpVolumeSerialNumber,
    @Cast("LPDWORD") IntBuffer lpMaximumComponentLength,
    @Cast("LPDWORD") IntBuffer lpFileSystemFlags,
    @Cast("LPSTR") ByteBuffer lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );
public static native @Cast("BOOL") boolean GetVolumeInformationA(
    @Cast("LPCSTR") BytePointer lpRootPathName,
    @Cast("LPSTR") byte[] lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") int[] lpVolumeSerialNumber,
    @Cast("LPDWORD") int[] lpMaximumComponentLength,
    @Cast("LPDWORD") int[] lpFileSystemFlags,
    @Cast("LPSTR") byte[] lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );
public static native @Cast("BOOL") boolean GetVolumeInformationA(
    @Cast("LPCSTR") ByteBuffer lpRootPathName,
    @Cast("LPSTR") BytePointer lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") IntPointer lpVolumeSerialNumber,
    @Cast("LPDWORD") IntPointer lpMaximumComponentLength,
    @Cast("LPDWORD") IntPointer lpFileSystemFlags,
    @Cast("LPSTR") BytePointer lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );
public static native @Cast("BOOL") boolean GetVolumeInformationA(
    @Cast("LPCSTR") byte[] lpRootPathName,
    @Cast("LPSTR") ByteBuffer lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") IntBuffer lpVolumeSerialNumber,
    @Cast("LPDWORD") IntBuffer lpMaximumComponentLength,
    @Cast("LPDWORD") IntBuffer lpFileSystemFlags,
    @Cast("LPSTR") ByteBuffer lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );
public static native @Cast("BOOL") boolean GetVolumeInformationA(
    @Cast("LPCSTR") String lpRootPathName,
    @Cast("LPSTR") byte[] lpVolumeNameBuffer,
    @Cast("DWORD") int nVolumeNameSize,
    @Cast("LPDWORD") int[] lpVolumeSerialNumber,
    @Cast("LPDWORD") int[] lpMaximumComponentLength,
    @Cast("LPDWORD") int[] lpFileSystemFlags,
    @Cast("LPSTR") byte[] lpFileSystemNameBuffer,
    @Cast("DWORD") int nFileSystemNameSize
    );

// #ifndef UNICODE
// #endif

// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean SetFileBandwidthReservation(
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int nPeriodMilliseconds,
    @Cast("DWORD") int nBytesPerPeriod,
    @Cast("BOOL") boolean bDiscardable,
    @Cast("LPDWORD") IntPointer lpTransferSize,
    @Cast("LPDWORD") IntPointer lpNumOutstandingRequests
    );
public static native @Cast("BOOL") boolean SetFileBandwidthReservation(
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int nPeriodMilliseconds,
    @Cast("DWORD") int nBytesPerPeriod,
    @Cast("BOOL") boolean bDiscardable,
    @Cast("LPDWORD") IntBuffer lpTransferSize,
    @Cast("LPDWORD") IntBuffer lpNumOutstandingRequests
    );
public static native @Cast("BOOL") boolean SetFileBandwidthReservation(
    @Cast("HANDLE") Pointer hFile,
    @Cast("DWORD") int nPeriodMilliseconds,
    @Cast("DWORD") int nBytesPerPeriod,
    @Cast("BOOL") boolean bDiscardable,
    @Cast("LPDWORD") int[] lpTransferSize,
    @Cast("LPDWORD") int[] lpNumOutstandingRequests
    );

public static native @Cast("BOOL") boolean GetFileBandwidthReservation(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") IntPointer lpPeriodMilliseconds,
    @Cast("LPDWORD") IntPointer lpBytesPerPeriod,
    @Cast("LPBOOL") boolean pDiscardable,
    @Cast("LPDWORD") IntPointer lpTransferSize,
    @Cast("LPDWORD") IntPointer lpNumOutstandingRequests
    );
public static native @Cast("BOOL") boolean GetFileBandwidthReservation(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") IntBuffer lpPeriodMilliseconds,
    @Cast("LPDWORD") IntBuffer lpBytesPerPeriod,
    @Cast("LPBOOL") boolean pDiscardable,
    @Cast("LPDWORD") IntBuffer lpTransferSize,
    @Cast("LPDWORD") IntBuffer lpNumOutstandingRequests
    );
public static native @Cast("BOOL") boolean GetFileBandwidthReservation(
    @Cast("HANDLE") Pointer hFile,
    @Cast("LPDWORD") int[] lpPeriodMilliseconds,
    @Cast("LPDWORD") int[] lpBytesPerPeriod,
    @Cast("LPBOOL") boolean pDiscardable,
    @Cast("LPDWORD") int[] lpTransferSize,
    @Cast("LPDWORD") int[] lpNumOutstandingRequests
    );

// #endif // (_WIN32_WINNT >= 0x0600)

//
// Event logging APIs
//

public static native @Cast("BOOL") boolean ClearEventLogA(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("LPCSTR") BytePointer lpBackupFileName
    );
public static native @Cast("BOOL") boolean ClearEventLogA(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("LPCSTR") ByteBuffer lpBackupFileName
    );
public static native @Cast("BOOL") boolean ClearEventLogA(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("LPCSTR") byte[] lpBackupFileName
    );
public static native @Cast("BOOL") boolean ClearEventLogA(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("LPCSTR") String lpBackupFileName
    );
public static native @Cast("BOOL") boolean ClearEventLogW(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("LPCWSTR") CharPointer lpBackupFileName
    );
public static native @Cast("BOOL") boolean ClearEventLogW(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("LPCWSTR") CharBuffer lpBackupFileName
    );
public static native @Cast("BOOL") boolean ClearEventLogW(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("LPCWSTR") char[] lpBackupFileName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean BackupEventLogA(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("LPCSTR") BytePointer lpBackupFileName
    );
public static native @Cast("BOOL") boolean BackupEventLogA(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("LPCSTR") ByteBuffer lpBackupFileName
    );
public static native @Cast("BOOL") boolean BackupEventLogA(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("LPCSTR") byte[] lpBackupFileName
    );
public static native @Cast("BOOL") boolean BackupEventLogA(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("LPCSTR") String lpBackupFileName
    );
public static native @Cast("BOOL") boolean BackupEventLogW(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("LPCWSTR") CharPointer lpBackupFileName
    );
public static native @Cast("BOOL") boolean BackupEventLogW(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("LPCWSTR") CharBuffer lpBackupFileName
    );
public static native @Cast("BOOL") boolean BackupEventLogW(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("LPCWSTR") char[] lpBackupFileName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean CloseEventLog(
    @Cast("HANDLE") Pointer hEventLog
    );

public static native @Cast("BOOL") boolean DeregisterEventSource(
    @Cast("HANDLE") Pointer hEventLog
    );

public static native @Cast("BOOL") boolean NotifyChangeEventLog(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("HANDLE") Pointer hEvent
    );

public static native @Cast("BOOL") boolean GetNumberOfEventLogRecords(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("PDWORD") IntPointer NumberOfRecords
    );
public static native @Cast("BOOL") boolean GetNumberOfEventLogRecords(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("PDWORD") IntBuffer NumberOfRecords
    );
public static native @Cast("BOOL") boolean GetNumberOfEventLogRecords(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("PDWORD") int[] NumberOfRecords
    );

public static native @Cast("BOOL") boolean GetOldestEventLogRecord(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("PDWORD") IntPointer OldestRecord
    );
public static native @Cast("BOOL") boolean GetOldestEventLogRecord(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("PDWORD") IntBuffer OldestRecord
    );
public static native @Cast("BOOL") boolean GetOldestEventLogRecord(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("PDWORD") int[] OldestRecord
    );

public static native @Cast("HANDLE") Pointer OpenEventLogA(
    @Cast("LPCSTR") BytePointer lpUNCServerName,
    @Cast("LPCSTR") BytePointer lpSourceName
    );
public static native @Cast("HANDLE") Pointer OpenEventLogA(
    @Cast("LPCSTR") ByteBuffer lpUNCServerName,
    @Cast("LPCSTR") ByteBuffer lpSourceName
    );
public static native @Cast("HANDLE") Pointer OpenEventLogA(
    @Cast("LPCSTR") byte[] lpUNCServerName,
    @Cast("LPCSTR") byte[] lpSourceName
    );
public static native @Cast("HANDLE") Pointer OpenEventLogA(
    @Cast("LPCSTR") String lpUNCServerName,
    @Cast("LPCSTR") String lpSourceName
    );
public static native @Cast("HANDLE") Pointer OpenEventLogW(
    @Cast("LPCWSTR") CharPointer lpUNCServerName,
    @Cast("LPCWSTR") CharPointer lpSourceName
    );
public static native @Cast("HANDLE") Pointer OpenEventLogW(
    @Cast("LPCWSTR") CharBuffer lpUNCServerName,
    @Cast("LPCWSTR") CharBuffer lpSourceName
    );
public static native @Cast("HANDLE") Pointer OpenEventLogW(
    @Cast("LPCWSTR") char[] lpUNCServerName,
    @Cast("LPCWSTR") char[] lpSourceName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("HANDLE") Pointer RegisterEventSourceA(
    @Cast("LPCSTR") BytePointer lpUNCServerName,
    @Cast("LPCSTR") BytePointer lpSourceName
    );
public static native @Cast("HANDLE") Pointer RegisterEventSourceA(
    @Cast("LPCSTR") ByteBuffer lpUNCServerName,
    @Cast("LPCSTR") ByteBuffer lpSourceName
    );
public static native @Cast("HANDLE") Pointer RegisterEventSourceA(
    @Cast("LPCSTR") byte[] lpUNCServerName,
    @Cast("LPCSTR") byte[] lpSourceName
    );
public static native @Cast("HANDLE") Pointer RegisterEventSourceA(
    @Cast("LPCSTR") String lpUNCServerName,
    @Cast("LPCSTR") String lpSourceName
    );
public static native @Cast("HANDLE") Pointer RegisterEventSourceW(
    @Cast("LPCWSTR") CharPointer lpUNCServerName,
    @Cast("LPCWSTR") CharPointer lpSourceName
    );
public static native @Cast("HANDLE") Pointer RegisterEventSourceW(
    @Cast("LPCWSTR") CharBuffer lpUNCServerName,
    @Cast("LPCWSTR") CharBuffer lpSourceName
    );
public static native @Cast("HANDLE") Pointer RegisterEventSourceW(
    @Cast("LPCWSTR") char[] lpUNCServerName,
    @Cast("LPCWSTR") char[] lpSourceName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("HANDLE") Pointer OpenBackupEventLogA(
    @Cast("LPCSTR") BytePointer lpUNCServerName,
    @Cast("LPCSTR") BytePointer lpFileName
    );
public static native @Cast("HANDLE") Pointer OpenBackupEventLogA(
    @Cast("LPCSTR") ByteBuffer lpUNCServerName,
    @Cast("LPCSTR") ByteBuffer lpFileName
    );
public static native @Cast("HANDLE") Pointer OpenBackupEventLogA(
    @Cast("LPCSTR") byte[] lpUNCServerName,
    @Cast("LPCSTR") byte[] lpFileName
    );
public static native @Cast("HANDLE") Pointer OpenBackupEventLogA(
    @Cast("LPCSTR") String lpUNCServerName,
    @Cast("LPCSTR") String lpFileName
    );
public static native @Cast("HANDLE") Pointer OpenBackupEventLogW(
    @Cast("LPCWSTR") CharPointer lpUNCServerName,
    @Cast("LPCWSTR") CharPointer lpFileName
    );
public static native @Cast("HANDLE") Pointer OpenBackupEventLogW(
    @Cast("LPCWSTR") CharBuffer lpUNCServerName,
    @Cast("LPCWSTR") CharBuffer lpFileName
    );
public static native @Cast("HANDLE") Pointer OpenBackupEventLogW(
    @Cast("LPCWSTR") char[] lpUNCServerName,
    @Cast("LPCWSTR") char[] lpFileName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean ReadEventLogA(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("DWORD") int dwReadFlags,
    @Cast("DWORD") int dwRecordOffset,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToRead,
    @Cast("DWORD*") IntPointer pnBytesRead,
    @Cast("DWORD*") IntPointer pnMinNumberOfBytesNeeded
    );
public static native @Cast("BOOL") boolean ReadEventLogA(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("DWORD") int dwReadFlags,
    @Cast("DWORD") int dwRecordOffset,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToRead,
    @Cast("DWORD*") IntBuffer pnBytesRead,
    @Cast("DWORD*") IntBuffer pnMinNumberOfBytesNeeded
    );
public static native @Cast("BOOL") boolean ReadEventLogA(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("DWORD") int dwReadFlags,
    @Cast("DWORD") int dwRecordOffset,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToRead,
    @Cast("DWORD*") int[] pnBytesRead,
    @Cast("DWORD*") int[] pnMinNumberOfBytesNeeded
    );
public static native @Cast("BOOL") boolean ReadEventLogW(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("DWORD") int dwReadFlags,
    @Cast("DWORD") int dwRecordOffset,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToRead,
    @Cast("DWORD*") IntPointer pnBytesRead,
    @Cast("DWORD*") IntPointer pnMinNumberOfBytesNeeded
    );
public static native @Cast("BOOL") boolean ReadEventLogW(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("DWORD") int dwReadFlags,
    @Cast("DWORD") int dwRecordOffset,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToRead,
    @Cast("DWORD*") IntBuffer pnBytesRead,
    @Cast("DWORD*") IntBuffer pnMinNumberOfBytesNeeded
    );
public static native @Cast("BOOL") boolean ReadEventLogW(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("DWORD") int dwReadFlags,
    @Cast("DWORD") int dwRecordOffset,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int nNumberOfBytesToRead,
    @Cast("DWORD*") int[] pnBytesRead,
    @Cast("DWORD*") int[] pnMinNumberOfBytesNeeded
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean ReportEventA(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("WORD") short wType,
    @Cast("WORD") short wCategory,
    @Cast("DWORD") int dwEventID,
    @Cast("PSID") Pointer lpUserSid,
    @Cast("WORD") short wNumStrings,
    @Cast("DWORD") int dwDataSize,
    @Cast("LPCSTR*") PointerPointer lpStrings,
    @Cast("LPVOID") Pointer lpRawData
    );
public static native @Cast("BOOL") boolean ReportEventW(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("WORD") short wType,
    @Cast("WORD") short wCategory,
    @Cast("DWORD") int dwEventID,
    @Cast("PSID") Pointer lpUserSid,
    @Cast("WORD") short wNumStrings,
    @Cast("DWORD") int dwDataSize,
    @Cast("LPCWSTR*") PointerPointer lpStrings,
    @Cast("LPVOID") Pointer lpRawData
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE


public static final int EVENTLOG_FULL_INFO =      0;
// Targeting ..\windows\EVENTLOG_FULL_INFORMATION.java



public static native @Cast("BOOL") boolean GetEventLogInformation(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("DWORD") int dwInfoLevel,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int cbBufSize,
    @Cast("LPDWORD") IntPointer pcbBytesNeeded
    );
public static native @Cast("BOOL") boolean GetEventLogInformation(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("DWORD") int dwInfoLevel,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int cbBufSize,
    @Cast("LPDWORD") IntBuffer pcbBytesNeeded
    );
public static native @Cast("BOOL") boolean GetEventLogInformation(
    @Cast("HANDLE") Pointer hEventLog,
    @Cast("DWORD") int dwInfoLevel,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int cbBufSize,
    @Cast("LPDWORD") int[] pcbBytesNeeded
    );

// #if (_WIN32_WINNT >= 0x0602)

// #endif // _WIN32_WINNT >= 0x0602

//
//
// Security APIs
//


public static native @Cast("BOOL") boolean AccessCheckAndAuditAlarmA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") BytePointer ObjectTypeName,
    @Cast("LPSTR") BytePointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckAndAuditAlarmA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") ByteBuffer ObjectTypeName,
    @Cast("LPSTR") ByteBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckAndAuditAlarmA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") byte[] ObjectTypeName,
    @Cast("LPSTR") byte[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckAndAuditAlarmA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") BytePointer ObjectTypeName,
    @Cast("LPSTR") BytePointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckAndAuditAlarmA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") ByteBuffer ObjectTypeName,
    @Cast("LPSTR") ByteBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckAndAuditAlarmA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") byte[] ObjectTypeName,
    @Cast("LPSTR") byte[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckAndAuditAlarmA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") BytePointer ObjectTypeName,
    @Cast("LPSTR") BytePointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckAndAuditAlarmA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") ByteBuffer ObjectTypeName,
    @Cast("LPSTR") ByteBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckAndAuditAlarmA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") byte[] ObjectTypeName,
    @Cast("LPSTR") byte[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckAndAuditAlarmA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") BytePointer ObjectTypeName,
    @Cast("LPSTR") BytePointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckAndAuditAlarmA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") ByteBuffer ObjectTypeName,
    @Cast("LPSTR") ByteBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckAndAuditAlarmA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") byte[] ObjectTypeName,
    @Cast("LPSTR") byte[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
// #ifndef UNICODE
// #endif

// #if(_WIN32_WINNT >= 0x0500)

public static native @Cast("BOOL") boolean AccessCheckByTypeAndAuditAlarmA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") BytePointer ObjectTypeName,
    @Cast("LPCSTR") BytePointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeAndAuditAlarmA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") ByteBuffer ObjectTypeName,
    @Cast("LPCSTR") ByteBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeAndAuditAlarmA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") byte[] ObjectTypeName,
    @Cast("LPCSTR") byte[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeAndAuditAlarmA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") String ObjectTypeName,
    @Cast("LPCSTR") String ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeAndAuditAlarmA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") BytePointer ObjectTypeName,
    @Cast("LPCSTR") BytePointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeAndAuditAlarmA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") ByteBuffer ObjectTypeName,
    @Cast("LPCSTR") ByteBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeAndAuditAlarmA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") byte[] ObjectTypeName,
    @Cast("LPCSTR") byte[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeAndAuditAlarmA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") String ObjectTypeName,
    @Cast("LPCSTR") String ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeAndAuditAlarmA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") BytePointer ObjectTypeName,
    @Cast("LPCSTR") BytePointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeAndAuditAlarmA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") ByteBuffer ObjectTypeName,
    @Cast("LPCSTR") ByteBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeAndAuditAlarmA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") byte[] ObjectTypeName,
    @Cast("LPCSTR") byte[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeAndAuditAlarmA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") String ObjectTypeName,
    @Cast("LPCSTR") String ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPBOOL") boolean AccessStatus,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
// #ifndef UNICODE
// #endif

public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") BytePointer ObjectTypeName,
    @Cast("LPCSTR") BytePointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPDWORD") IntPointer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") ByteBuffer ObjectTypeName,
    @Cast("LPCSTR") ByteBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPDWORD") IntBuffer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") byte[] ObjectTypeName,
    @Cast("LPCSTR") byte[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPDWORD") int[] AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") String ObjectTypeName,
    @Cast("LPCSTR") String ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPDWORD") IntPointer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") BytePointer ObjectTypeName,
    @Cast("LPCSTR") BytePointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPDWORD") IntBuffer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") ByteBuffer ObjectTypeName,
    @Cast("LPCSTR") ByteBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPDWORD") int[] AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") byte[] ObjectTypeName,
    @Cast("LPCSTR") byte[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPDWORD") IntPointer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") String ObjectTypeName,
    @Cast("LPCSTR") String ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPDWORD") IntBuffer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") BytePointer ObjectTypeName,
    @Cast("LPCSTR") BytePointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPDWORD") int[] AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") ByteBuffer ObjectTypeName,
    @Cast("LPCSTR") ByteBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPDWORD") IntPointer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") byte[] ObjectTypeName,
    @Cast("LPCSTR") byte[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPDWORD") IntBuffer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPCSTR") String ObjectTypeName,
    @Cast("LPCSTR") String ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPDWORD") int[] AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
// #ifndef UNICODE
// #endif

public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmByHandleA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("LPCSTR") BytePointer ObjectTypeName,
    @Cast("LPCSTR") BytePointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPDWORD") IntPointer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmByHandleA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("LPCSTR") ByteBuffer ObjectTypeName,
    @Cast("LPCSTR") ByteBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPDWORD") IntBuffer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmByHandleA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("LPCSTR") byte[] ObjectTypeName,
    @Cast("LPCSTR") byte[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPDWORD") int[] AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmByHandleA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("LPCSTR") String ObjectTypeName,
    @Cast("LPCSTR") String ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPDWORD") IntPointer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmByHandleA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("LPCSTR") BytePointer ObjectTypeName,
    @Cast("LPCSTR") BytePointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPDWORD") IntBuffer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmByHandleA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("LPCSTR") ByteBuffer ObjectTypeName,
    @Cast("LPCSTR") ByteBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPDWORD") int[] AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmByHandleA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("LPCSTR") byte[] ObjectTypeName,
    @Cast("LPCSTR") byte[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPDWORD") IntPointer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmByHandleA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("LPCSTR") String ObjectTypeName,
    @Cast("LPCSTR") String ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPDWORD") IntBuffer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmByHandleA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("LPCSTR") BytePointer ObjectTypeName,
    @Cast("LPCSTR") BytePointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPDWORD") int[] AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmByHandleA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("LPCSTR") ByteBuffer ObjectTypeName,
    @Cast("LPCSTR") ByteBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntPointer GrantedAccess,
    @Cast("LPDWORD") IntPointer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmByHandleA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("LPCSTR") byte[] ObjectTypeName,
    @Cast("LPCSTR") byte[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") IntBuffer GrantedAccess,
    @Cast("LPDWORD") IntBuffer AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
public static native @Cast("BOOL") boolean AccessCheckByTypeResultListAndAuditAlarmByHandleA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("LPCSTR") String ObjectTypeName,
    @Cast("LPCSTR") String ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer SecurityDescriptor,
    @Cast("PSID") Pointer PrincipalSelfSid,
    @Cast("DWORD") int DesiredAccess,
    @Cast("AUDIT_EVENT_TYPE") int AuditType,
    @Cast("DWORD") int Flags,
    @Cast("POBJECT_TYPE_LIST") OBJECT_TYPE_LIST ObjectTypeList,
    @Cast("DWORD") int ObjectTypeListLength,
    @Cast("PGENERIC_MAPPING") GENERIC_MAPPING GenericMapping,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("LPDWORD") int[] GrantedAccess,
    @Cast("LPDWORD") int[] AccessStatusList,
    @Cast("LPBOOL") boolean pfGenerateOnClose
    );
// #ifndef UNICODE
// #endif
// #endif //(_WIN32_WINNT >= 0x0500)

public static native @Cast("BOOL") boolean ObjectOpenAuditAlarmA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") BytePointer ObjectTypeName,
    @Cast("LPSTR") BytePointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("DWORD") int GrantedAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("BOOL") boolean AccessGranted,
    @Cast("LPBOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectOpenAuditAlarmA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") ByteBuffer ObjectTypeName,
    @Cast("LPSTR") ByteBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("DWORD") int GrantedAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("BOOL") boolean AccessGranted,
    @Cast("LPBOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectOpenAuditAlarmA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") byte[] ObjectTypeName,
    @Cast("LPSTR") byte[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("DWORD") int GrantedAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("BOOL") boolean AccessGranted,
    @Cast("LPBOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectOpenAuditAlarmA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") BytePointer ObjectTypeName,
    @Cast("LPSTR") BytePointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("DWORD") int GrantedAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("BOOL") boolean AccessGranted,
    @Cast("LPBOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectOpenAuditAlarmA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") ByteBuffer ObjectTypeName,
    @Cast("LPSTR") ByteBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("DWORD") int GrantedAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("BOOL") boolean AccessGranted,
    @Cast("LPBOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectOpenAuditAlarmA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") byte[] ObjectTypeName,
    @Cast("LPSTR") byte[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("DWORD") int GrantedAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("BOOL") boolean AccessGranted,
    @Cast("LPBOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectOpenAuditAlarmA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") BytePointer ObjectTypeName,
    @Cast("LPSTR") BytePointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("DWORD") int GrantedAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("BOOL") boolean AccessGranted,
    @Cast("LPBOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectOpenAuditAlarmA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") ByteBuffer ObjectTypeName,
    @Cast("LPSTR") ByteBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("DWORD") int GrantedAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("BOOL") boolean AccessGranted,
    @Cast("LPBOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectOpenAuditAlarmA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") byte[] ObjectTypeName,
    @Cast("LPSTR") byte[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("DWORD") int GrantedAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("BOOL") boolean AccessGranted,
    @Cast("LPBOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectOpenAuditAlarmA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") BytePointer ObjectTypeName,
    @Cast("LPSTR") BytePointer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("DWORD") int GrantedAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("BOOL") boolean AccessGranted,
    @Cast("LPBOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectOpenAuditAlarmA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") ByteBuffer ObjectTypeName,
    @Cast("LPSTR") ByteBuffer ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("DWORD") int GrantedAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("BOOL") boolean AccessGranted,
    @Cast("LPBOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectOpenAuditAlarmA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("LPSTR") byte[] ObjectTypeName,
    @Cast("LPSTR") byte[] ObjectName,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("DWORD") int GrantedAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean ObjectCreation,
    @Cast("BOOL") boolean AccessGranted,
    @Cast("LPBOOL") boolean GenerateOnClose
    );
// #ifndef UNICODE
// #endif

public static native @Cast("BOOL") boolean ObjectPrivilegeAuditAlarmA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean AccessGranted
    );
public static native @Cast("BOOL") boolean ObjectPrivilegeAuditAlarmA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean AccessGranted
    );
public static native @Cast("BOOL") boolean ObjectPrivilegeAuditAlarmA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean AccessGranted
    );
public static native @Cast("BOOL") boolean ObjectPrivilegeAuditAlarmA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("DWORD") int DesiredAccess,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean AccessGranted
    );
// #ifndef UNICODE
// #endif

public static native @Cast("BOOL") boolean ObjectCloseAuditAlarmA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("BOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectCloseAuditAlarmA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("BOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectCloseAuditAlarmA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("BOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectCloseAuditAlarmA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("BOOL") boolean GenerateOnClose
    );
// #ifndef UNICODE
// #endif

public static native @Cast("BOOL") boolean ObjectDeleteAuditAlarmA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("BOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectDeleteAuditAlarmA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("BOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectDeleteAuditAlarmA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("BOOL") boolean GenerateOnClose
    );
public static native @Cast("BOOL") boolean ObjectDeleteAuditAlarmA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPVOID") Pointer HandleId,
    @Cast("BOOL") boolean GenerateOnClose
    );
// #ifndef UNICODE
// #endif

public static native @Cast("BOOL") boolean PrivilegedServiceAuditAlarmA(
    @Cast("LPCSTR") BytePointer SubsystemName,
    @Cast("LPCSTR") BytePointer ServiceName,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean AccessGranted
    );
public static native @Cast("BOOL") boolean PrivilegedServiceAuditAlarmA(
    @Cast("LPCSTR") ByteBuffer SubsystemName,
    @Cast("LPCSTR") ByteBuffer ServiceName,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean AccessGranted
    );
public static native @Cast("BOOL") boolean PrivilegedServiceAuditAlarmA(
    @Cast("LPCSTR") byte[] SubsystemName,
    @Cast("LPCSTR") byte[] ServiceName,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean AccessGranted
    );
public static native @Cast("BOOL") boolean PrivilegedServiceAuditAlarmA(
    @Cast("LPCSTR") String SubsystemName,
    @Cast("LPCSTR") String ServiceName,
    @Cast("HANDLE") Pointer ClientToken,
    @Cast("PPRIVILEGE_SET") PRIVILEGE_SET Privileges,
    @Cast("BOOL") boolean AccessGranted
    );
// #ifndef UNICODE
// #endif

// #if(_WIN32_WINNT >= 0x0601)
public static native @Cast("BOOL") boolean AddConditionalAce(
    @Cast("PACL") ACL pAcl,
    @Cast("DWORD") int dwAceRevision,
    @Cast("DWORD") int AceFlags,
    @Cast("UCHAR") byte AceType,
    @Cast("DWORD") int AccessMask,
    @Cast("PSID") Pointer pSid,
    @Cast("PWCHAR") CharPointer ConditionStr,
    @Cast("DWORD*") IntPointer ReturnLength
    );
public static native @Cast("BOOL") boolean AddConditionalAce(
    @Cast("PACL") ACL pAcl,
    @Cast("DWORD") int dwAceRevision,
    @Cast("DWORD") int AceFlags,
    @Cast("UCHAR") byte AceType,
    @Cast("DWORD") int AccessMask,
    @Cast("PSID") Pointer pSid,
    @Cast("PWCHAR") CharBuffer ConditionStr,
    @Cast("DWORD*") IntBuffer ReturnLength
    );
public static native @Cast("BOOL") boolean AddConditionalAce(
    @Cast("PACL") ACL pAcl,
    @Cast("DWORD") int dwAceRevision,
    @Cast("DWORD") int AceFlags,
    @Cast("UCHAR") byte AceType,
    @Cast("DWORD") int AccessMask,
    @Cast("PSID") Pointer pSid,
    @Cast("PWCHAR") char[] ConditionStr,
    @Cast("DWORD*") int[] ReturnLength
    );
// #endif /* _WIN32_WINNT >=  0x0601 */

public static native @Cast("BOOL") boolean SetFileSecurityA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor
    );
public static native @Cast("BOOL") boolean SetFileSecurityA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor
    );
public static native @Cast("BOOL") boolean SetFileSecurityA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor
    );
public static native @Cast("BOOL") boolean SetFileSecurityA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("SECURITY_INFORMATION") int SecurityInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor
    );
// #ifndef UNICODE
// #endif

public static native @Cast("BOOL") boolean GetFileSecurityA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") IntPointer lpnLengthNeeded
    );
public static native @Cast("BOOL") boolean GetFileSecurityA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") IntBuffer lpnLengthNeeded
    );
public static native @Cast("BOOL") boolean GetFileSecurityA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") int[] lpnLengthNeeded
    );
public static native @Cast("BOOL") boolean GetFileSecurityA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") IntPointer lpnLengthNeeded
    );
public static native @Cast("BOOL") boolean GetFileSecurityA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") IntBuffer lpnLengthNeeded
    );
public static native @Cast("BOOL") boolean GetFileSecurityA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") int[] lpnLengthNeeded
    );
public static native @Cast("BOOL") boolean GetFileSecurityA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") IntPointer lpnLengthNeeded
    );
public static native @Cast("BOOL") boolean GetFileSecurityA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") IntBuffer lpnLengthNeeded
    );
public static native @Cast("BOOL") boolean GetFileSecurityA(
    @Cast("LPCSTR") BytePointer lpFileName,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") int[] lpnLengthNeeded
    );
public static native @Cast("BOOL") boolean GetFileSecurityA(
    @Cast("LPCSTR") ByteBuffer lpFileName,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") IntPointer lpnLengthNeeded
    );
public static native @Cast("BOOL") boolean GetFileSecurityA(
    @Cast("LPCSTR") byte[] lpFileName,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") IntBuffer lpnLengthNeeded
    );
public static native @Cast("BOOL") boolean GetFileSecurityA(
    @Cast("LPCSTR") String lpFileName,
    @Cast("SECURITY_INFORMATION") int RequestedInformation,
    @Cast("PSECURITY_DESCRIPTOR") Pointer pSecurityDescriptor,
    @Cast("DWORD") int nLength,
    @Cast("LPDWORD") int[] lpnLengthNeeded
    );
// #ifndef UNICODE
// #endif

// #if(_WIN32_WINNT >= 0x0400)
public static native @Cast("BOOL") boolean ReadDirectoryChangesW(
    @Cast("HANDLE") Pointer hDirectory,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int nBufferLength,
    @Cast("BOOL") boolean bWatchSubtree,
    @Cast("DWORD") int dwNotifyFilter,
    @Cast("LPDWORD") IntPointer lpBytesReturned,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
public static native @Cast("BOOL") boolean ReadDirectoryChangesW(
    @Cast("HANDLE") Pointer hDirectory,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int nBufferLength,
    @Cast("BOOL") boolean bWatchSubtree,
    @Cast("DWORD") int dwNotifyFilter,
    @Cast("LPDWORD") IntBuffer lpBytesReturned,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
public static native @Cast("BOOL") boolean ReadDirectoryChangesW(
    @Cast("HANDLE") Pointer hDirectory,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("DWORD") int nBufferLength,
    @Cast("BOOL") boolean bWatchSubtree,
    @Cast("DWORD") int dwNotifyFilter,
    @Cast("LPDWORD") int[] lpBytesReturned,
    @Cast("LPOVERLAPPED") OVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
// #endif /* _WIN32_WINNT >= 0x0400 */

// #if _WIN32_WINNT >= 0x0600

public static native @Cast("LPVOID") Pointer MapViewOfFileExNuma(
    @Cast("HANDLE") Pointer hFileMappingObject,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwFileOffsetHigh,
    @Cast("DWORD") int dwFileOffsetLow,
    @Cast("SIZE_T") long dwNumberOfBytesToMap,
    @Cast("LPVOID") Pointer lpBaseAddress,
    @Cast("DWORD") int nndPreferred
    );

// #endif // _WIN32_WINNT >= 0x0600

public static native @Cast("BOOL") boolean IsBadReadPtr(
    @Const Pointer lp,
    @Cast("UINT_PTR") long ucb
    );

public static native @Cast("BOOL") boolean IsBadWritePtr(
    @Cast("LPVOID") Pointer lp,
    @Cast("UINT_PTR") long ucb
    );

public static native @Cast("BOOL") boolean IsBadHugeReadPtr(
    @Const Pointer lp,
    @Cast("UINT_PTR") long ucb
    );

public static native @Cast("BOOL") boolean IsBadHugeWritePtr(
    @Cast("LPVOID") Pointer lp,
    @Cast("UINT_PTR") long ucb
    );

public static native @Cast("BOOL") boolean IsBadCodePtr(
    FARPROC lpfn
    );

public static native @Cast("BOOL") boolean IsBadStringPtrA(
    @Cast("LPCSTR") BytePointer lpsz,
    @Cast("UINT_PTR") long ucchMax
    );
public static native @Cast("BOOL") boolean IsBadStringPtrA(
    @Cast("LPCSTR") ByteBuffer lpsz,
    @Cast("UINT_PTR") long ucchMax
    );
public static native @Cast("BOOL") boolean IsBadStringPtrA(
    @Cast("LPCSTR") byte[] lpsz,
    @Cast("UINT_PTR") long ucchMax
    );
public static native @Cast("BOOL") boolean IsBadStringPtrA(
    @Cast("LPCSTR") String lpsz,
    @Cast("UINT_PTR") long ucchMax
    );
public static native @Cast("BOOL") boolean IsBadStringPtrW(
    @Cast("LPCWSTR") CharPointer lpsz,
    @Cast("UINT_PTR") long ucchMax
    );
public static native @Cast("BOOL") boolean IsBadStringPtrW(
    @Cast("LPCWSTR") CharBuffer lpsz,
    @Cast("UINT_PTR") long ucchMax
    );
public static native @Cast("BOOL") boolean IsBadStringPtrW(
    @Cast("LPCWSTR") char[] lpsz,
    @Cast("UINT_PTR") long ucchMax
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean LookupAccountSidA(
    @Cast("LPCSTR") BytePointer lpSystemName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPSTR") BytePointer Name,
    @Cast("LPDWORD") IntPointer cchName,
    @Cast("LPSTR") BytePointer ReferencedDomainName,
    @Cast("LPDWORD") IntPointer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntPointer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountSidA(
    @Cast("LPCSTR") ByteBuffer lpSystemName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPSTR") ByteBuffer Name,
    @Cast("LPDWORD") IntBuffer cchName,
    @Cast("LPSTR") ByteBuffer ReferencedDomainName,
    @Cast("LPDWORD") IntBuffer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntBuffer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountSidA(
    @Cast("LPCSTR") byte[] lpSystemName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPSTR") byte[] Name,
    @Cast("LPDWORD") int[] cchName,
    @Cast("LPSTR") byte[] ReferencedDomainName,
    @Cast("LPDWORD") int[] cchReferencedDomainName,
    @Cast("PSID_NAME_USE") int[] peUse
    );
public static native @Cast("BOOL") boolean LookupAccountSidA(
    @Cast("LPCSTR") String lpSystemName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPSTR") BytePointer Name,
    @Cast("LPDWORD") IntPointer cchName,
    @Cast("LPSTR") BytePointer ReferencedDomainName,
    @Cast("LPDWORD") IntPointer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntPointer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountSidA(
    @Cast("LPCSTR") BytePointer lpSystemName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPSTR") ByteBuffer Name,
    @Cast("LPDWORD") IntBuffer cchName,
    @Cast("LPSTR") ByteBuffer ReferencedDomainName,
    @Cast("LPDWORD") IntBuffer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntBuffer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountSidA(
    @Cast("LPCSTR") ByteBuffer lpSystemName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPSTR") byte[] Name,
    @Cast("LPDWORD") int[] cchName,
    @Cast("LPSTR") byte[] ReferencedDomainName,
    @Cast("LPDWORD") int[] cchReferencedDomainName,
    @Cast("PSID_NAME_USE") int[] peUse
    );
public static native @Cast("BOOL") boolean LookupAccountSidA(
    @Cast("LPCSTR") byte[] lpSystemName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPSTR") BytePointer Name,
    @Cast("LPDWORD") IntPointer cchName,
    @Cast("LPSTR") BytePointer ReferencedDomainName,
    @Cast("LPDWORD") IntPointer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntPointer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountSidA(
    @Cast("LPCSTR") String lpSystemName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPSTR") ByteBuffer Name,
    @Cast("LPDWORD") IntBuffer cchName,
    @Cast("LPSTR") ByteBuffer ReferencedDomainName,
    @Cast("LPDWORD") IntBuffer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntBuffer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountSidA(
    @Cast("LPCSTR") BytePointer lpSystemName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPSTR") byte[] Name,
    @Cast("LPDWORD") int[] cchName,
    @Cast("LPSTR") byte[] ReferencedDomainName,
    @Cast("LPDWORD") int[] cchReferencedDomainName,
    @Cast("PSID_NAME_USE") int[] peUse
    );
public static native @Cast("BOOL") boolean LookupAccountSidA(
    @Cast("LPCSTR") ByteBuffer lpSystemName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPSTR") BytePointer Name,
    @Cast("LPDWORD") IntPointer cchName,
    @Cast("LPSTR") BytePointer ReferencedDomainName,
    @Cast("LPDWORD") IntPointer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntPointer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountSidA(
    @Cast("LPCSTR") byte[] lpSystemName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPSTR") ByteBuffer Name,
    @Cast("LPDWORD") IntBuffer cchName,
    @Cast("LPSTR") ByteBuffer ReferencedDomainName,
    @Cast("LPDWORD") IntBuffer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntBuffer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountSidA(
    @Cast("LPCSTR") String lpSystemName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPSTR") byte[] Name,
    @Cast("LPDWORD") int[] cchName,
    @Cast("LPSTR") byte[] ReferencedDomainName,
    @Cast("LPDWORD") int[] cchReferencedDomainName,
    @Cast("PSID_NAME_USE") int[] peUse
    );
public static native @Cast("BOOL") boolean LookupAccountSidW(
    @Cast("LPCWSTR") CharPointer lpSystemName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPWSTR") CharPointer Name,
    @Cast("LPDWORD") IntPointer cchName,
    @Cast("LPWSTR") CharPointer ReferencedDomainName,
    @Cast("LPDWORD") IntPointer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntPointer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountSidW(
    @Cast("LPCWSTR") CharBuffer lpSystemName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPWSTR") CharBuffer Name,
    @Cast("LPDWORD") IntBuffer cchName,
    @Cast("LPWSTR") CharBuffer ReferencedDomainName,
    @Cast("LPDWORD") IntBuffer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntBuffer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountSidW(
    @Cast("LPCWSTR") char[] lpSystemName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPWSTR") char[] Name,
    @Cast("LPDWORD") int[] cchName,
    @Cast("LPWSTR") char[] ReferencedDomainName,
    @Cast("LPDWORD") int[] cchReferencedDomainName,
    @Cast("PSID_NAME_USE") int[] peUse
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean LookupAccountNameA(
    @Cast("LPCSTR") BytePointer lpSystemName,
    @Cast("LPCSTR") BytePointer lpAccountName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPDWORD") IntPointer cbSid,
    @Cast("LPSTR") BytePointer ReferencedDomainName,
    @Cast("LPDWORD") IntPointer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntPointer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountNameA(
    @Cast("LPCSTR") ByteBuffer lpSystemName,
    @Cast("LPCSTR") ByteBuffer lpAccountName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPDWORD") IntBuffer cbSid,
    @Cast("LPSTR") ByteBuffer ReferencedDomainName,
    @Cast("LPDWORD") IntBuffer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntBuffer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountNameA(
    @Cast("LPCSTR") byte[] lpSystemName,
    @Cast("LPCSTR") byte[] lpAccountName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPDWORD") int[] cbSid,
    @Cast("LPSTR") byte[] ReferencedDomainName,
    @Cast("LPDWORD") int[] cchReferencedDomainName,
    @Cast("PSID_NAME_USE") int[] peUse
    );
public static native @Cast("BOOL") boolean LookupAccountNameA(
    @Cast("LPCSTR") String lpSystemName,
    @Cast("LPCSTR") String lpAccountName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPDWORD") IntPointer cbSid,
    @Cast("LPSTR") BytePointer ReferencedDomainName,
    @Cast("LPDWORD") IntPointer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntPointer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountNameA(
    @Cast("LPCSTR") BytePointer lpSystemName,
    @Cast("LPCSTR") BytePointer lpAccountName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPDWORD") IntBuffer cbSid,
    @Cast("LPSTR") ByteBuffer ReferencedDomainName,
    @Cast("LPDWORD") IntBuffer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntBuffer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountNameA(
    @Cast("LPCSTR") ByteBuffer lpSystemName,
    @Cast("LPCSTR") ByteBuffer lpAccountName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPDWORD") int[] cbSid,
    @Cast("LPSTR") byte[] ReferencedDomainName,
    @Cast("LPDWORD") int[] cchReferencedDomainName,
    @Cast("PSID_NAME_USE") int[] peUse
    );
public static native @Cast("BOOL") boolean LookupAccountNameA(
    @Cast("LPCSTR") byte[] lpSystemName,
    @Cast("LPCSTR") byte[] lpAccountName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPDWORD") IntPointer cbSid,
    @Cast("LPSTR") BytePointer ReferencedDomainName,
    @Cast("LPDWORD") IntPointer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntPointer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountNameA(
    @Cast("LPCSTR") String lpSystemName,
    @Cast("LPCSTR") String lpAccountName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPDWORD") IntBuffer cbSid,
    @Cast("LPSTR") ByteBuffer ReferencedDomainName,
    @Cast("LPDWORD") IntBuffer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntBuffer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountNameA(
    @Cast("LPCSTR") BytePointer lpSystemName,
    @Cast("LPCSTR") BytePointer lpAccountName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPDWORD") int[] cbSid,
    @Cast("LPSTR") byte[] ReferencedDomainName,
    @Cast("LPDWORD") int[] cchReferencedDomainName,
    @Cast("PSID_NAME_USE") int[] peUse
    );
public static native @Cast("BOOL") boolean LookupAccountNameA(
    @Cast("LPCSTR") ByteBuffer lpSystemName,
    @Cast("LPCSTR") ByteBuffer lpAccountName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPDWORD") IntPointer cbSid,
    @Cast("LPSTR") BytePointer ReferencedDomainName,
    @Cast("LPDWORD") IntPointer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntPointer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountNameA(
    @Cast("LPCSTR") byte[] lpSystemName,
    @Cast("LPCSTR") byte[] lpAccountName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPDWORD") IntBuffer cbSid,
    @Cast("LPSTR") ByteBuffer ReferencedDomainName,
    @Cast("LPDWORD") IntBuffer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntBuffer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountNameA(
    @Cast("LPCSTR") String lpSystemName,
    @Cast("LPCSTR") String lpAccountName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPDWORD") int[] cbSid,
    @Cast("LPSTR") byte[] ReferencedDomainName,
    @Cast("LPDWORD") int[] cchReferencedDomainName,
    @Cast("PSID_NAME_USE") int[] peUse
    );
public static native @Cast("BOOL") boolean LookupAccountNameW(
    @Cast("LPCWSTR") CharPointer lpSystemName,
    @Cast("LPCWSTR") CharPointer lpAccountName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPDWORD") IntPointer cbSid,
    @Cast("LPWSTR") CharPointer ReferencedDomainName,
    @Cast("LPDWORD") IntPointer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntPointer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountNameW(
    @Cast("LPCWSTR") CharBuffer lpSystemName,
    @Cast("LPCWSTR") CharBuffer lpAccountName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPDWORD") IntBuffer cbSid,
    @Cast("LPWSTR") CharBuffer ReferencedDomainName,
    @Cast("LPDWORD") IntBuffer cchReferencedDomainName,
    @Cast("PSID_NAME_USE") IntBuffer peUse
    );
public static native @Cast("BOOL") boolean LookupAccountNameW(
    @Cast("LPCWSTR") char[] lpSystemName,
    @Cast("LPCWSTR") char[] lpAccountName,
    @Cast("PSID") Pointer Sid,
    @Cast("LPDWORD") int[] cbSid,
    @Cast("LPWSTR") char[] ReferencedDomainName,
    @Cast("LPDWORD") int[] cchReferencedDomainName,
    @Cast("PSID_NAME_USE") int[] peUse
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #if _WIN32_WINNT >= 0x0601



// #ifdef UNICODE
// #else
// #endif // !UNICODE



// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #else // _WIN32_WINNT >= 0x0601

// #endif // _WIN32_WINNT >= 0x0601

public static native @Cast("BOOL") boolean LookupPrivilegeValueA(
    @Cast("LPCSTR") BytePointer lpSystemName,
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("PLUID") LongPointer lpLuid
    );
public static native @Cast("BOOL") boolean LookupPrivilegeValueA(
    @Cast("LPCSTR") ByteBuffer lpSystemName,
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("PLUID") LongBuffer lpLuid
    );
public static native @Cast("BOOL") boolean LookupPrivilegeValueA(
    @Cast("LPCSTR") byte[] lpSystemName,
    @Cast("LPCSTR") byte[] lpName,
    @Cast("PLUID") long[] lpLuid
    );
public static native @Cast("BOOL") boolean LookupPrivilegeValueA(
    @Cast("LPCSTR") String lpSystemName,
    @Cast("LPCSTR") String lpName,
    @Cast("PLUID") LongPointer lpLuid
    );
public static native @Cast("BOOL") boolean LookupPrivilegeValueA(
    @Cast("LPCSTR") BytePointer lpSystemName,
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("PLUID") LongBuffer lpLuid
    );
public static native @Cast("BOOL") boolean LookupPrivilegeValueA(
    @Cast("LPCSTR") ByteBuffer lpSystemName,
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("PLUID") long[] lpLuid
    );
public static native @Cast("BOOL") boolean LookupPrivilegeValueA(
    @Cast("LPCSTR") byte[] lpSystemName,
    @Cast("LPCSTR") byte[] lpName,
    @Cast("PLUID") LongPointer lpLuid
    );
public static native @Cast("BOOL") boolean LookupPrivilegeValueA(
    @Cast("LPCSTR") String lpSystemName,
    @Cast("LPCSTR") String lpName,
    @Cast("PLUID") LongBuffer lpLuid
    );
public static native @Cast("BOOL") boolean LookupPrivilegeValueA(
    @Cast("LPCSTR") BytePointer lpSystemName,
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("PLUID") long[] lpLuid
    );
public static native @Cast("BOOL") boolean LookupPrivilegeValueA(
    @Cast("LPCSTR") ByteBuffer lpSystemName,
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("PLUID") LongPointer lpLuid
    );
public static native @Cast("BOOL") boolean LookupPrivilegeValueA(
    @Cast("LPCSTR") byte[] lpSystemName,
    @Cast("LPCSTR") byte[] lpName,
    @Cast("PLUID") LongBuffer lpLuid
    );
public static native @Cast("BOOL") boolean LookupPrivilegeValueA(
    @Cast("LPCSTR") String lpSystemName,
    @Cast("LPCSTR") String lpName,
    @Cast("PLUID") long[] lpLuid
    );
public static native @Cast("BOOL") boolean LookupPrivilegeValueW(
    @Cast("LPCWSTR") CharPointer lpSystemName,
    @Cast("LPCWSTR") CharPointer lpName,
    @Cast("PLUID") LongPointer lpLuid
    );
public static native @Cast("BOOL") boolean LookupPrivilegeValueW(
    @Cast("LPCWSTR") CharBuffer lpSystemName,
    @Cast("LPCWSTR") CharBuffer lpName,
    @Cast("PLUID") LongBuffer lpLuid
    );
public static native @Cast("BOOL") boolean LookupPrivilegeValueW(
    @Cast("LPCWSTR") char[] lpSystemName,
    @Cast("LPCWSTR") char[] lpName,
    @Cast("PLUID") long[] lpLuid
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean LookupPrivilegeNameA(
    @Cast("LPCSTR") BytePointer lpSystemName,
    @Cast("PLUID") LongPointer lpLuid,
    @Cast("LPSTR") BytePointer lpName,
    @Cast("LPDWORD") IntPointer cchName
    );
public static native @Cast("BOOL") boolean LookupPrivilegeNameA(
    @Cast("LPCSTR") ByteBuffer lpSystemName,
    @Cast("PLUID") LongBuffer lpLuid,
    @Cast("LPSTR") ByteBuffer lpName,
    @Cast("LPDWORD") IntBuffer cchName
    );
public static native @Cast("BOOL") boolean LookupPrivilegeNameA(
    @Cast("LPCSTR") byte[] lpSystemName,
    @Cast("PLUID") long[] lpLuid,
    @Cast("LPSTR") byte[] lpName,
    @Cast("LPDWORD") int[] cchName
    );
public static native @Cast("BOOL") boolean LookupPrivilegeNameA(
    @Cast("LPCSTR") String lpSystemName,
    @Cast("PLUID") LongPointer lpLuid,
    @Cast("LPSTR") BytePointer lpName,
    @Cast("LPDWORD") IntPointer cchName
    );
public static native @Cast("BOOL") boolean LookupPrivilegeNameA(
    @Cast("LPCSTR") BytePointer lpSystemName,
    @Cast("PLUID") LongBuffer lpLuid,
    @Cast("LPSTR") ByteBuffer lpName,
    @Cast("LPDWORD") IntBuffer cchName
    );
public static native @Cast("BOOL") boolean LookupPrivilegeNameA(
    @Cast("LPCSTR") ByteBuffer lpSystemName,
    @Cast("PLUID") long[] lpLuid,
    @Cast("LPSTR") byte[] lpName,
    @Cast("LPDWORD") int[] cchName
    );
public static native @Cast("BOOL") boolean LookupPrivilegeNameA(
    @Cast("LPCSTR") byte[] lpSystemName,
    @Cast("PLUID") LongPointer lpLuid,
    @Cast("LPSTR") BytePointer lpName,
    @Cast("LPDWORD") IntPointer cchName
    );
public static native @Cast("BOOL") boolean LookupPrivilegeNameA(
    @Cast("LPCSTR") String lpSystemName,
    @Cast("PLUID") LongBuffer lpLuid,
    @Cast("LPSTR") ByteBuffer lpName,
    @Cast("LPDWORD") IntBuffer cchName
    );
public static native @Cast("BOOL") boolean LookupPrivilegeNameA(
    @Cast("LPCSTR") BytePointer lpSystemName,
    @Cast("PLUID") long[] lpLuid,
    @Cast("LPSTR") byte[] lpName,
    @Cast("LPDWORD") int[] cchName
    );
public static native @Cast("BOOL") boolean LookupPrivilegeNameA(
    @Cast("LPCSTR") ByteBuffer lpSystemName,
    @Cast("PLUID") LongPointer lpLuid,
    @Cast("LPSTR") BytePointer lpName,
    @Cast("LPDWORD") IntPointer cchName
    );
public static native @Cast("BOOL") boolean LookupPrivilegeNameA(
    @Cast("LPCSTR") byte[] lpSystemName,
    @Cast("PLUID") LongBuffer lpLuid,
    @Cast("LPSTR") ByteBuffer lpName,
    @Cast("LPDWORD") IntBuffer cchName
    );
public static native @Cast("BOOL") boolean LookupPrivilegeNameA(
    @Cast("LPCSTR") String lpSystemName,
    @Cast("PLUID") long[] lpLuid,
    @Cast("LPSTR") byte[] lpName,
    @Cast("LPDWORD") int[] cchName
    );
public static native @Cast("BOOL") boolean LookupPrivilegeNameW(
    @Cast("LPCWSTR") CharPointer lpSystemName,
    @Cast("PLUID") LongPointer lpLuid,
    @Cast("LPWSTR") CharPointer lpName,
    @Cast("LPDWORD") IntPointer cchName
    );
public static native @Cast("BOOL") boolean LookupPrivilegeNameW(
    @Cast("LPCWSTR") CharBuffer lpSystemName,
    @Cast("PLUID") LongBuffer lpLuid,
    @Cast("LPWSTR") CharBuffer lpName,
    @Cast("LPDWORD") IntBuffer cchName
    );
public static native @Cast("BOOL") boolean LookupPrivilegeNameW(
    @Cast("LPCWSTR") char[] lpSystemName,
    @Cast("PLUID") long[] lpLuid,
    @Cast("LPWSTR") char[] lpName,
    @Cast("LPDWORD") int[] cchName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean LookupPrivilegeDisplayNameA(
    @Cast("LPCSTR") BytePointer lpSystemName,
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("LPSTR") BytePointer lpDisplayName,
    @Cast("LPDWORD") IntPointer cchDisplayName,
    @Cast("LPDWORD") IntPointer lpLanguageId
    );
public static native @Cast("BOOL") boolean LookupPrivilegeDisplayNameA(
    @Cast("LPCSTR") ByteBuffer lpSystemName,
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("LPSTR") ByteBuffer lpDisplayName,
    @Cast("LPDWORD") IntBuffer cchDisplayName,
    @Cast("LPDWORD") IntBuffer lpLanguageId
    );
public static native @Cast("BOOL") boolean LookupPrivilegeDisplayNameA(
    @Cast("LPCSTR") byte[] lpSystemName,
    @Cast("LPCSTR") byte[] lpName,
    @Cast("LPSTR") byte[] lpDisplayName,
    @Cast("LPDWORD") int[] cchDisplayName,
    @Cast("LPDWORD") int[] lpLanguageId
    );
public static native @Cast("BOOL") boolean LookupPrivilegeDisplayNameA(
    @Cast("LPCSTR") String lpSystemName,
    @Cast("LPCSTR") String lpName,
    @Cast("LPSTR") BytePointer lpDisplayName,
    @Cast("LPDWORD") IntPointer cchDisplayName,
    @Cast("LPDWORD") IntPointer lpLanguageId
    );
public static native @Cast("BOOL") boolean LookupPrivilegeDisplayNameA(
    @Cast("LPCSTR") BytePointer lpSystemName,
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("LPSTR") ByteBuffer lpDisplayName,
    @Cast("LPDWORD") IntBuffer cchDisplayName,
    @Cast("LPDWORD") IntBuffer lpLanguageId
    );
public static native @Cast("BOOL") boolean LookupPrivilegeDisplayNameA(
    @Cast("LPCSTR") ByteBuffer lpSystemName,
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("LPSTR") byte[] lpDisplayName,
    @Cast("LPDWORD") int[] cchDisplayName,
    @Cast("LPDWORD") int[] lpLanguageId
    );
public static native @Cast("BOOL") boolean LookupPrivilegeDisplayNameA(
    @Cast("LPCSTR") byte[] lpSystemName,
    @Cast("LPCSTR") byte[] lpName,
    @Cast("LPSTR") BytePointer lpDisplayName,
    @Cast("LPDWORD") IntPointer cchDisplayName,
    @Cast("LPDWORD") IntPointer lpLanguageId
    );
public static native @Cast("BOOL") boolean LookupPrivilegeDisplayNameA(
    @Cast("LPCSTR") String lpSystemName,
    @Cast("LPCSTR") String lpName,
    @Cast("LPSTR") ByteBuffer lpDisplayName,
    @Cast("LPDWORD") IntBuffer cchDisplayName,
    @Cast("LPDWORD") IntBuffer lpLanguageId
    );
public static native @Cast("BOOL") boolean LookupPrivilegeDisplayNameA(
    @Cast("LPCSTR") BytePointer lpSystemName,
    @Cast("LPCSTR") BytePointer lpName,
    @Cast("LPSTR") byte[] lpDisplayName,
    @Cast("LPDWORD") int[] cchDisplayName,
    @Cast("LPDWORD") int[] lpLanguageId
    );
public static native @Cast("BOOL") boolean LookupPrivilegeDisplayNameA(
    @Cast("LPCSTR") ByteBuffer lpSystemName,
    @Cast("LPCSTR") ByteBuffer lpName,
    @Cast("LPSTR") BytePointer lpDisplayName,
    @Cast("LPDWORD") IntPointer cchDisplayName,
    @Cast("LPDWORD") IntPointer lpLanguageId
    );
public static native @Cast("BOOL") boolean LookupPrivilegeDisplayNameA(
    @Cast("LPCSTR") byte[] lpSystemName,
    @Cast("LPCSTR") byte[] lpName,
    @Cast("LPSTR") ByteBuffer lpDisplayName,
    @Cast("LPDWORD") IntBuffer cchDisplayName,
    @Cast("LPDWORD") IntBuffer lpLanguageId
    );
public static native @Cast("BOOL") boolean LookupPrivilegeDisplayNameA(
    @Cast("LPCSTR") String lpSystemName,
    @Cast("LPCSTR") String lpName,
    @Cast("LPSTR") byte[] lpDisplayName,
    @Cast("LPDWORD") int[] cchDisplayName,
    @Cast("LPDWORD") int[] lpLanguageId
    );
public static native @Cast("BOOL") boolean LookupPrivilegeDisplayNameW(
    @Cast("LPCWSTR") CharPointer lpSystemName,
    @Cast("LPCWSTR") CharPointer lpName,
    @Cast("LPWSTR") CharPointer lpDisplayName,
    @Cast("LPDWORD") IntPointer cchDisplayName,
    @Cast("LPDWORD") IntPointer lpLanguageId
    );
public static native @Cast("BOOL") boolean LookupPrivilegeDisplayNameW(
    @Cast("LPCWSTR") CharBuffer lpSystemName,
    @Cast("LPCWSTR") CharBuffer lpName,
    @Cast("LPWSTR") CharBuffer lpDisplayName,
    @Cast("LPDWORD") IntBuffer cchDisplayName,
    @Cast("LPDWORD") IntBuffer lpLanguageId
    );
public static native @Cast("BOOL") boolean LookupPrivilegeDisplayNameW(
    @Cast("LPCWSTR") char[] lpSystemName,
    @Cast("LPCWSTR") char[] lpName,
    @Cast("LPWSTR") char[] lpDisplayName,
    @Cast("LPDWORD") int[] cchDisplayName,
    @Cast("LPDWORD") int[] lpLanguageId
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean BuildCommDCBA(
    @Cast("LPCSTR") BytePointer lpDef,
    @Cast("LPDCB") DCB lpDCB
    );
public static native @Cast("BOOL") boolean BuildCommDCBA(
    @Cast("LPCSTR") ByteBuffer lpDef,
    @Cast("LPDCB") DCB lpDCB
    );
public static native @Cast("BOOL") boolean BuildCommDCBA(
    @Cast("LPCSTR") byte[] lpDef,
    @Cast("LPDCB") DCB lpDCB
    );
public static native @Cast("BOOL") boolean BuildCommDCBA(
    @Cast("LPCSTR") String lpDef,
    @Cast("LPDCB") DCB lpDCB
    );
public static native @Cast("BOOL") boolean BuildCommDCBW(
    @Cast("LPCWSTR") CharPointer lpDef,
    @Cast("LPDCB") DCB lpDCB
    );
public static native @Cast("BOOL") boolean BuildCommDCBW(
    @Cast("LPCWSTR") CharBuffer lpDef,
    @Cast("LPDCB") DCB lpDCB
    );
public static native @Cast("BOOL") boolean BuildCommDCBW(
    @Cast("LPCWSTR") char[] lpDef,
    @Cast("LPDCB") DCB lpDCB
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean BuildCommDCBAndTimeoutsA(
    @Cast("LPCSTR") BytePointer lpDef,
    @Cast("LPDCB") DCB lpDCB,
    @Cast("LPCOMMTIMEOUTS") COMMTIMEOUTS lpCommTimeouts
    );
public static native @Cast("BOOL") boolean BuildCommDCBAndTimeoutsA(
    @Cast("LPCSTR") ByteBuffer lpDef,
    @Cast("LPDCB") DCB lpDCB,
    @Cast("LPCOMMTIMEOUTS") COMMTIMEOUTS lpCommTimeouts
    );
public static native @Cast("BOOL") boolean BuildCommDCBAndTimeoutsA(
    @Cast("LPCSTR") byte[] lpDef,
    @Cast("LPDCB") DCB lpDCB,
    @Cast("LPCOMMTIMEOUTS") COMMTIMEOUTS lpCommTimeouts
    );
public static native @Cast("BOOL") boolean BuildCommDCBAndTimeoutsA(
    @Cast("LPCSTR") String lpDef,
    @Cast("LPDCB") DCB lpDCB,
    @Cast("LPCOMMTIMEOUTS") COMMTIMEOUTS lpCommTimeouts
    );
public static native @Cast("BOOL") boolean BuildCommDCBAndTimeoutsW(
    @Cast("LPCWSTR") CharPointer lpDef,
    @Cast("LPDCB") DCB lpDCB,
    @Cast("LPCOMMTIMEOUTS") COMMTIMEOUTS lpCommTimeouts
    );
public static native @Cast("BOOL") boolean BuildCommDCBAndTimeoutsW(
    @Cast("LPCWSTR") CharBuffer lpDef,
    @Cast("LPDCB") DCB lpDCB,
    @Cast("LPCOMMTIMEOUTS") COMMTIMEOUTS lpCommTimeouts
    );
public static native @Cast("BOOL") boolean BuildCommDCBAndTimeoutsW(
    @Cast("LPCWSTR") char[] lpDef,
    @Cast("LPDCB") DCB lpDCB,
    @Cast("LPCOMMTIMEOUTS") COMMTIMEOUTS lpCommTimeouts
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean CommConfigDialogA(
    @Cast("LPCSTR") BytePointer lpszName,
    @Cast("HWND") Pointer hWnd,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC
    );
public static native @Cast("BOOL") boolean CommConfigDialogA(
    @Cast("LPCSTR") ByteBuffer lpszName,
    @Cast("HWND") Pointer hWnd,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC
    );
public static native @Cast("BOOL") boolean CommConfigDialogA(
    @Cast("LPCSTR") byte[] lpszName,
    @Cast("HWND") Pointer hWnd,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC
    );
public static native @Cast("BOOL") boolean CommConfigDialogA(
    @Cast("LPCSTR") String lpszName,
    @Cast("HWND") Pointer hWnd,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC
    );
public static native @Cast("BOOL") boolean CommConfigDialogW(
    @Cast("LPCWSTR") CharPointer lpszName,
    @Cast("HWND") Pointer hWnd,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC
    );
public static native @Cast("BOOL") boolean CommConfigDialogW(
    @Cast("LPCWSTR") CharBuffer lpszName,
    @Cast("HWND") Pointer hWnd,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC
    );
public static native @Cast("BOOL") boolean CommConfigDialogW(
    @Cast("LPCWSTR") char[] lpszName,
    @Cast("HWND") Pointer hWnd,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean GetDefaultCommConfigA(
    @Cast("LPCSTR") BytePointer lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") IntPointer lpdwSize
    );
public static native @Cast("BOOL") boolean GetDefaultCommConfigA(
    @Cast("LPCSTR") ByteBuffer lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") IntBuffer lpdwSize
    );
public static native @Cast("BOOL") boolean GetDefaultCommConfigA(
    @Cast("LPCSTR") byte[] lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") int[] lpdwSize
    );
public static native @Cast("BOOL") boolean GetDefaultCommConfigA(
    @Cast("LPCSTR") String lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") IntPointer lpdwSize
    );
public static native @Cast("BOOL") boolean GetDefaultCommConfigA(
    @Cast("LPCSTR") BytePointer lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") IntBuffer lpdwSize
    );
public static native @Cast("BOOL") boolean GetDefaultCommConfigA(
    @Cast("LPCSTR") ByteBuffer lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") int[] lpdwSize
    );
public static native @Cast("BOOL") boolean GetDefaultCommConfigA(
    @Cast("LPCSTR") byte[] lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") IntPointer lpdwSize
    );
public static native @Cast("BOOL") boolean GetDefaultCommConfigA(
    @Cast("LPCSTR") String lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") IntBuffer lpdwSize
    );
public static native @Cast("BOOL") boolean GetDefaultCommConfigA(
    @Cast("LPCSTR") BytePointer lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") int[] lpdwSize
    );
public static native @Cast("BOOL") boolean GetDefaultCommConfigA(
    @Cast("LPCSTR") ByteBuffer lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") IntPointer lpdwSize
    );
public static native @Cast("BOOL") boolean GetDefaultCommConfigA(
    @Cast("LPCSTR") byte[] lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") IntBuffer lpdwSize
    );
public static native @Cast("BOOL") boolean GetDefaultCommConfigA(
    @Cast("LPCSTR") String lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") int[] lpdwSize
    );
public static native @Cast("BOOL") boolean GetDefaultCommConfigW(
    @Cast("LPCWSTR") CharPointer lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") IntPointer lpdwSize
    );
public static native @Cast("BOOL") boolean GetDefaultCommConfigW(
    @Cast("LPCWSTR") CharBuffer lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") IntBuffer lpdwSize
    );
public static native @Cast("BOOL") boolean GetDefaultCommConfigW(
    @Cast("LPCWSTR") char[] lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("LPDWORD") int[] lpdwSize
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean SetDefaultCommConfigA(
    @Cast("LPCSTR") BytePointer lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("DWORD") int dwSize
    );
public static native @Cast("BOOL") boolean SetDefaultCommConfigA(
    @Cast("LPCSTR") ByteBuffer lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("DWORD") int dwSize
    );
public static native @Cast("BOOL") boolean SetDefaultCommConfigA(
    @Cast("LPCSTR") byte[] lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("DWORD") int dwSize
    );
public static native @Cast("BOOL") boolean SetDefaultCommConfigA(
    @Cast("LPCSTR") String lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("DWORD") int dwSize
    );
public static native @Cast("BOOL") boolean SetDefaultCommConfigW(
    @Cast("LPCWSTR") CharPointer lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("DWORD") int dwSize
    );
public static native @Cast("BOOL") boolean SetDefaultCommConfigW(
    @Cast("LPCWSTR") CharBuffer lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("DWORD") int dwSize
    );
public static native @Cast("BOOL") boolean SetDefaultCommConfigW(
    @Cast("LPCWSTR") char[] lpszName,
    @Cast("LPCOMMCONFIG") COMMCONFIG lpCC,
    @Cast("DWORD") int dwSize
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #ifndef _MAC
public static final int MAX_COMPUTERNAME_LENGTH = 15;
// #else
// #endif

public static native @Cast("BOOL") boolean GetComputerNameA(
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("LPDWORD") IntPointer nSize
    );
public static native @Cast("BOOL") boolean GetComputerNameA(
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("LPDWORD") IntBuffer nSize
    );
public static native @Cast("BOOL") boolean GetComputerNameA(
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("LPDWORD") int[] nSize
    );
public static native @Cast("BOOL") boolean GetComputerNameW(
    @Cast("LPWSTR") CharPointer lpBuffer,
    @Cast("LPDWORD") IntPointer nSize
    );
public static native @Cast("BOOL") boolean GetComputerNameW(
    @Cast("LPWSTR") CharBuffer lpBuffer,
    @Cast("LPDWORD") IntBuffer nSize
    );
public static native @Cast("BOOL") boolean GetComputerNameW(
    @Cast("LPWSTR") char[] lpBuffer,
    @Cast("LPDWORD") int[] nSize
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean SetComputerNameA(
    @Cast("LPCSTR") BytePointer lpComputerName
    );
public static native @Cast("BOOL") boolean SetComputerNameA(
    @Cast("LPCSTR") ByteBuffer lpComputerName
    );
public static native @Cast("BOOL") boolean SetComputerNameA(
    @Cast("LPCSTR") byte[] lpComputerName
    );
public static native @Cast("BOOL") boolean SetComputerNameA(
    @Cast("LPCSTR") String lpComputerName
    );
public static native @Cast("BOOL") boolean SetComputerNameW(
    @Cast("LPCWSTR") CharPointer lpComputerName
    );
public static native @Cast("BOOL") boolean SetComputerNameW(
    @Cast("LPCWSTR") CharBuffer lpComputerName
    );
public static native @Cast("BOOL") boolean SetComputerNameW(
    @Cast("LPCWSTR") char[] lpComputerName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE


// #if (_WIN32_WINNT >= 0x0500)

public static native @Cast("BOOL") boolean SetComputerNameExA(
    @Cast("COMPUTER_NAME_FORMAT") int NameType,
    @Cast("LPCSTR") BytePointer lpBuffer
    );
public static native @Cast("BOOL") boolean SetComputerNameExA(
    @Cast("COMPUTER_NAME_FORMAT") int NameType,
    @Cast("LPCSTR") ByteBuffer lpBuffer
    );
public static native @Cast("BOOL") boolean SetComputerNameExA(
    @Cast("COMPUTER_NAME_FORMAT") int NameType,
    @Cast("LPCSTR") byte[] lpBuffer
    );
public static native @Cast("BOOL") boolean SetComputerNameExA(
    @Cast("COMPUTER_NAME_FORMAT") int NameType,
    @Cast("LPCSTR") String lpBuffer
    );
// #ifndef UNICODE
// #endif


public static native @Cast("BOOL") boolean DnsHostnameToComputerNameA(
    @Cast("LPCSTR") BytePointer Hostname,
    @Cast("LPSTR") BytePointer ComputerName,
    @Cast("LPDWORD") IntPointer nSize
    );
public static native @Cast("BOOL") boolean DnsHostnameToComputerNameA(
    @Cast("LPCSTR") ByteBuffer Hostname,
    @Cast("LPSTR") ByteBuffer ComputerName,
    @Cast("LPDWORD") IntBuffer nSize
    );
public static native @Cast("BOOL") boolean DnsHostnameToComputerNameA(
    @Cast("LPCSTR") byte[] Hostname,
    @Cast("LPSTR") byte[] ComputerName,
    @Cast("LPDWORD") int[] nSize
    );
public static native @Cast("BOOL") boolean DnsHostnameToComputerNameA(
    @Cast("LPCSTR") String Hostname,
    @Cast("LPSTR") BytePointer ComputerName,
    @Cast("LPDWORD") IntPointer nSize
    );
public static native @Cast("BOOL") boolean DnsHostnameToComputerNameA(
    @Cast("LPCSTR") BytePointer Hostname,
    @Cast("LPSTR") ByteBuffer ComputerName,
    @Cast("LPDWORD") IntBuffer nSize
    );
public static native @Cast("BOOL") boolean DnsHostnameToComputerNameA(
    @Cast("LPCSTR") ByteBuffer Hostname,
    @Cast("LPSTR") byte[] ComputerName,
    @Cast("LPDWORD") int[] nSize
    );
public static native @Cast("BOOL") boolean DnsHostnameToComputerNameA(
    @Cast("LPCSTR") byte[] Hostname,
    @Cast("LPSTR") BytePointer ComputerName,
    @Cast("LPDWORD") IntPointer nSize
    );
public static native @Cast("BOOL") boolean DnsHostnameToComputerNameA(
    @Cast("LPCSTR") String Hostname,
    @Cast("LPSTR") ByteBuffer ComputerName,
    @Cast("LPDWORD") IntBuffer nSize
    );
public static native @Cast("BOOL") boolean DnsHostnameToComputerNameA(
    @Cast("LPCSTR") BytePointer Hostname,
    @Cast("LPSTR") byte[] ComputerName,
    @Cast("LPDWORD") int[] nSize
    );
public static native @Cast("BOOL") boolean DnsHostnameToComputerNameA(
    @Cast("LPCSTR") ByteBuffer Hostname,
    @Cast("LPSTR") BytePointer ComputerName,
    @Cast("LPDWORD") IntPointer nSize
    );
public static native @Cast("BOOL") boolean DnsHostnameToComputerNameA(
    @Cast("LPCSTR") byte[] Hostname,
    @Cast("LPSTR") ByteBuffer ComputerName,
    @Cast("LPDWORD") IntBuffer nSize
    );
public static native @Cast("BOOL") boolean DnsHostnameToComputerNameA(
    @Cast("LPCSTR") String Hostname,
    @Cast("LPSTR") byte[] ComputerName,
    @Cast("LPDWORD") int[] nSize
    );
public static native @Cast("BOOL") boolean DnsHostnameToComputerNameW(
    @Cast("LPCWSTR") CharPointer Hostname,
    @Cast("LPWSTR") CharPointer ComputerName,
    @Cast("LPDWORD") IntPointer nSize
    );
public static native @Cast("BOOL") boolean DnsHostnameToComputerNameW(
    @Cast("LPCWSTR") CharBuffer Hostname,
    @Cast("LPWSTR") CharBuffer ComputerName,
    @Cast("LPDWORD") IntBuffer nSize
    );
public static native @Cast("BOOL") boolean DnsHostnameToComputerNameW(
    @Cast("LPCWSTR") char[] Hostname,
    @Cast("LPWSTR") char[] ComputerName,
    @Cast("LPDWORD") int[] nSize
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // _WIN32_WINNT

public static native @Cast("BOOL") boolean GetUserNameA(
    @Cast("LPSTR") BytePointer lpBuffer,
    @Cast("LPDWORD") IntPointer pcbBuffer
    );
public static native @Cast("BOOL") boolean GetUserNameA(
    @Cast("LPSTR") ByteBuffer lpBuffer,
    @Cast("LPDWORD") IntBuffer pcbBuffer
    );
public static native @Cast("BOOL") boolean GetUserNameA(
    @Cast("LPSTR") byte[] lpBuffer,
    @Cast("LPDWORD") int[] pcbBuffer
    );
public static native @Cast("BOOL") boolean GetUserNameW(
    @Cast("LPWSTR") CharPointer lpBuffer,
    @Cast("LPDWORD") IntPointer pcbBuffer
    );
public static native @Cast("BOOL") boolean GetUserNameW(
    @Cast("LPWSTR") CharBuffer lpBuffer,
    @Cast("LPDWORD") IntBuffer pcbBuffer
    );
public static native @Cast("BOOL") boolean GetUserNameW(
    @Cast("LPWSTR") char[] lpBuffer,
    @Cast("LPDWORD") int[] pcbBuffer
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

//
// Logon Support APIs
//

public static final int LOGON32_LOGON_INTERACTIVE =       2;
public static final int LOGON32_LOGON_NETWORK =           3;
public static final int LOGON32_LOGON_BATCH =             4;
public static final int LOGON32_LOGON_SERVICE =           5;
public static final int LOGON32_LOGON_UNLOCK =            7;
// #if(_WIN32_WINNT >= 0x0500)
public static final int LOGON32_LOGON_NETWORK_CLEARTEXT = 8;
public static final int LOGON32_LOGON_NEW_CREDENTIALS =   9;
// #endif // (_WIN32_WINNT >= 0x0500)

public static final int LOGON32_PROVIDER_DEFAULT =    0;
public static final int LOGON32_PROVIDER_WINNT35 =    1;
// #if(_WIN32_WINNT >= 0x0400)
public static final int LOGON32_PROVIDER_WINNT40 =    2;
// #endif /* _WIN32_WINNT >= 0x0400 */
// #if(_WIN32_WINNT >= 0x0500)
public static final int LOGON32_PROVIDER_WINNT50 =    3;
// #endif // (_WIN32_WINNT >= 0x0500)
// #if(_WIN32_WINNT >= 0x0600)
public static final int LOGON32_PROVIDER_VIRTUAL =    4;
// #endif // (_WIN32_WINNT >= 0x0600)



public static native @Cast("BOOL") boolean LogonUserA(
    @Cast("LPCSTR") BytePointer lpszUsername,
    @Cast("LPCSTR") BytePointer lpszDomain,
    @Cast("LPCSTR") BytePointer lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken
    );
public static native @Cast("BOOL") boolean LogonUserA(
    @Cast("LPCSTR") ByteBuffer lpszUsername,
    @Cast("LPCSTR") ByteBuffer lpszDomain,
    @Cast("LPCSTR") ByteBuffer lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken
    );
public static native @Cast("BOOL") boolean LogonUserA(
    @Cast("LPCSTR") byte[] lpszUsername,
    @Cast("LPCSTR") byte[] lpszDomain,
    @Cast("LPCSTR") byte[] lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken
    );
public static native @Cast("BOOL") boolean LogonUserA(
    @Cast("LPCSTR") String lpszUsername,
    @Cast("LPCSTR") String lpszDomain,
    @Cast("LPCSTR") String lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken
    );
public static native @Cast("BOOL") boolean LogonUserW(
    @Cast("LPCWSTR") CharPointer lpszUsername,
    @Cast("LPCWSTR") CharPointer lpszDomain,
    @Cast("LPCWSTR") CharPointer lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken
    );
public static native @Cast("BOOL") boolean LogonUserW(
    @Cast("LPCWSTR") CharBuffer lpszUsername,
    @Cast("LPCWSTR") CharBuffer lpszDomain,
    @Cast("LPCWSTR") CharBuffer lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken
    );
public static native @Cast("BOOL") boolean LogonUserW(
    @Cast("LPCWSTR") char[] lpszUsername,
    @Cast("LPCWSTR") char[] lpszDomain,
    @Cast("LPCWSTR") char[] lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean LogonUserExA(
    @Cast("LPCSTR") BytePointer lpszUsername,
    @Cast("LPCSTR") BytePointer lpszDomain,
    @Cast("LPCSTR") BytePointer lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken,
    @Cast("PSID*") PointerPointer ppLogonSid,
    @Cast("PVOID*") PointerPointer ppProfileBuffer,
    @Cast("LPDWORD") IntPointer pdwProfileLength,
    @Cast("PQUOTA_LIMITS") QUOTA_LIMITS pQuotaLimits
    );
public static native @Cast("BOOL") boolean LogonUserExA(
    @Cast("LPCSTR") ByteBuffer lpszUsername,
    @Cast("LPCSTR") ByteBuffer lpszDomain,
    @Cast("LPCSTR") ByteBuffer lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken,
    @Cast("PSID*") PointerPointer ppLogonSid,
    @Cast("PVOID*") PointerPointer ppProfileBuffer,
    @Cast("LPDWORD") IntBuffer pdwProfileLength,
    @Cast("PQUOTA_LIMITS") QUOTA_LIMITS pQuotaLimits
    );
public static native @Cast("BOOL") boolean LogonUserExA(
    @Cast("LPCSTR") byte[] lpszUsername,
    @Cast("LPCSTR") byte[] lpszDomain,
    @Cast("LPCSTR") byte[] lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken,
    @Cast("PSID*") PointerPointer ppLogonSid,
    @Cast("PVOID*") PointerPointer ppProfileBuffer,
    @Cast("LPDWORD") int[] pdwProfileLength,
    @Cast("PQUOTA_LIMITS") QUOTA_LIMITS pQuotaLimits
    );
public static native @Cast("BOOL") boolean LogonUserExA(
    @Cast("LPCSTR") String lpszUsername,
    @Cast("LPCSTR") String lpszDomain,
    @Cast("LPCSTR") String lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken,
    @Cast("PSID*") PointerPointer ppLogonSid,
    @Cast("PVOID*") PointerPointer ppProfileBuffer,
    @Cast("LPDWORD") IntPointer pdwProfileLength,
    @Cast("PQUOTA_LIMITS") QUOTA_LIMITS pQuotaLimits
    );
public static native @Cast("BOOL") boolean LogonUserExA(
    @Cast("LPCSTR") BytePointer lpszUsername,
    @Cast("LPCSTR") BytePointer lpszDomain,
    @Cast("LPCSTR") BytePointer lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken,
    @Cast("PSID*") PointerPointer ppLogonSid,
    @Cast("PVOID*") PointerPointer ppProfileBuffer,
    @Cast("LPDWORD") IntBuffer pdwProfileLength,
    @Cast("PQUOTA_LIMITS") QUOTA_LIMITS pQuotaLimits
    );
public static native @Cast("BOOL") boolean LogonUserExA(
    @Cast("LPCSTR") ByteBuffer lpszUsername,
    @Cast("LPCSTR") ByteBuffer lpszDomain,
    @Cast("LPCSTR") ByteBuffer lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken,
    @Cast("PSID*") PointerPointer ppLogonSid,
    @Cast("PVOID*") PointerPointer ppProfileBuffer,
    @Cast("LPDWORD") int[] pdwProfileLength,
    @Cast("PQUOTA_LIMITS") QUOTA_LIMITS pQuotaLimits
    );
public static native @Cast("BOOL") boolean LogonUserExA(
    @Cast("LPCSTR") byte[] lpszUsername,
    @Cast("LPCSTR") byte[] lpszDomain,
    @Cast("LPCSTR") byte[] lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken,
    @Cast("PSID*") PointerPointer ppLogonSid,
    @Cast("PVOID*") PointerPointer ppProfileBuffer,
    @Cast("LPDWORD") IntPointer pdwProfileLength,
    @Cast("PQUOTA_LIMITS") QUOTA_LIMITS pQuotaLimits
    );
public static native @Cast("BOOL") boolean LogonUserExA(
    @Cast("LPCSTR") String lpszUsername,
    @Cast("LPCSTR") String lpszDomain,
    @Cast("LPCSTR") String lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken,
    @Cast("PSID*") PointerPointer ppLogonSid,
    @Cast("PVOID*") PointerPointer ppProfileBuffer,
    @Cast("LPDWORD") IntBuffer pdwProfileLength,
    @Cast("PQUOTA_LIMITS") QUOTA_LIMITS pQuotaLimits
    );
public static native @Cast("BOOL") boolean LogonUserExA(
    @Cast("LPCSTR") BytePointer lpszUsername,
    @Cast("LPCSTR") BytePointer lpszDomain,
    @Cast("LPCSTR") BytePointer lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken,
    @Cast("PSID*") PointerPointer ppLogonSid,
    @Cast("PVOID*") PointerPointer ppProfileBuffer,
    @Cast("LPDWORD") int[] pdwProfileLength,
    @Cast("PQUOTA_LIMITS") QUOTA_LIMITS pQuotaLimits
    );
public static native @Cast("BOOL") boolean LogonUserExA(
    @Cast("LPCSTR") ByteBuffer lpszUsername,
    @Cast("LPCSTR") ByteBuffer lpszDomain,
    @Cast("LPCSTR") ByteBuffer lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken,
    @Cast("PSID*") PointerPointer ppLogonSid,
    @Cast("PVOID*") PointerPointer ppProfileBuffer,
    @Cast("LPDWORD") IntPointer pdwProfileLength,
    @Cast("PQUOTA_LIMITS") QUOTA_LIMITS pQuotaLimits
    );
public static native @Cast("BOOL") boolean LogonUserExA(
    @Cast("LPCSTR") byte[] lpszUsername,
    @Cast("LPCSTR") byte[] lpszDomain,
    @Cast("LPCSTR") byte[] lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken,
    @Cast("PSID*") PointerPointer ppLogonSid,
    @Cast("PVOID*") PointerPointer ppProfileBuffer,
    @Cast("LPDWORD") IntBuffer pdwProfileLength,
    @Cast("PQUOTA_LIMITS") QUOTA_LIMITS pQuotaLimits
    );
public static native @Cast("BOOL") boolean LogonUserExA(
    @Cast("LPCSTR") String lpszUsername,
    @Cast("LPCSTR") String lpszDomain,
    @Cast("LPCSTR") String lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken,
    @Cast("PSID*") PointerPointer ppLogonSid,
    @Cast("PVOID*") PointerPointer ppProfileBuffer,
    @Cast("LPDWORD") int[] pdwProfileLength,
    @Cast("PQUOTA_LIMITS") QUOTA_LIMITS pQuotaLimits
    );
public static native @Cast("BOOL") boolean LogonUserExW(
    @Cast("LPCWSTR") CharPointer lpszUsername,
    @Cast("LPCWSTR") CharPointer lpszDomain,
    @Cast("LPCWSTR") CharPointer lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken,
    @Cast("PSID*") PointerPointer ppLogonSid,
    @Cast("PVOID*") PointerPointer ppProfileBuffer,
    @Cast("LPDWORD") IntPointer pdwProfileLength,
    @Cast("PQUOTA_LIMITS") QUOTA_LIMITS pQuotaLimits
    );
public static native @Cast("BOOL") boolean LogonUserExW(
    @Cast("LPCWSTR") CharBuffer lpszUsername,
    @Cast("LPCWSTR") CharBuffer lpszDomain,
    @Cast("LPCWSTR") CharBuffer lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken,
    @Cast("PSID*") PointerPointer ppLogonSid,
    @Cast("PVOID*") PointerPointer ppProfileBuffer,
    @Cast("LPDWORD") IntBuffer pdwProfileLength,
    @Cast("PQUOTA_LIMITS") QUOTA_LIMITS pQuotaLimits
    );
public static native @Cast("BOOL") boolean LogonUserExW(
    @Cast("LPCWSTR") char[] lpszUsername,
    @Cast("LPCWSTR") char[] lpszDomain,
    @Cast("LPCWSTR") char[] lpszPassword,
    @Cast("DWORD") int dwLogonType,
    @Cast("DWORD") int dwLogonProvider,
    @Cast("PHANDLE") PointerPointer phToken,
    @Cast("PSID*") PointerPointer ppLogonSid,
    @Cast("PVOID*") PointerPointer ppProfileBuffer,
    @Cast("LPDWORD") int[] pdwProfileLength,
    @Cast("PQUOTA_LIMITS") QUOTA_LIMITS pQuotaLimits
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE


// #if(_WIN32_WINNT >= 0x0600)


// #endif // (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean CreateProcessAsUserA(
    @Cast("HANDLE") Pointer hToken,
    @Cast("LPCSTR") BytePointer lpApplicationName,
    @Cast("LPSTR") BytePointer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") BytePointer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessAsUserA(
    @Cast("HANDLE") Pointer hToken,
    @Cast("LPCSTR") ByteBuffer lpApplicationName,
    @Cast("LPSTR") ByteBuffer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") ByteBuffer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessAsUserA(
    @Cast("HANDLE") Pointer hToken,
    @Cast("LPCSTR") byte[] lpApplicationName,
    @Cast("LPSTR") byte[] lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") byte[] lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessAsUserA(
    @Cast("HANDLE") Pointer hToken,
    @Cast("LPCSTR") String lpApplicationName,
    @Cast("LPSTR") BytePointer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") String lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessAsUserA(
    @Cast("HANDLE") Pointer hToken,
    @Cast("LPCSTR") BytePointer lpApplicationName,
    @Cast("LPSTR") ByteBuffer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") BytePointer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessAsUserA(
    @Cast("HANDLE") Pointer hToken,
    @Cast("LPCSTR") ByteBuffer lpApplicationName,
    @Cast("LPSTR") byte[] lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") ByteBuffer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessAsUserA(
    @Cast("HANDLE") Pointer hToken,
    @Cast("LPCSTR") byte[] lpApplicationName,
    @Cast("LPSTR") BytePointer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") byte[] lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessAsUserA(
    @Cast("HANDLE") Pointer hToken,
    @Cast("LPCSTR") String lpApplicationName,
    @Cast("LPSTR") ByteBuffer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") String lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessAsUserA(
    @Cast("HANDLE") Pointer hToken,
    @Cast("LPCSTR") BytePointer lpApplicationName,
    @Cast("LPSTR") byte[] lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") BytePointer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessAsUserA(
    @Cast("HANDLE") Pointer hToken,
    @Cast("LPCSTR") ByteBuffer lpApplicationName,
    @Cast("LPSTR") BytePointer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") ByteBuffer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessAsUserA(
    @Cast("HANDLE") Pointer hToken,
    @Cast("LPCSTR") byte[] lpApplicationName,
    @Cast("LPSTR") ByteBuffer lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") byte[] lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
public static native @Cast("BOOL") boolean CreateProcessAsUserA(
    @Cast("HANDLE") Pointer hToken,
    @Cast("LPCSTR") String lpApplicationName,
    @Cast("LPSTR") byte[] lpCommandLine,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpProcessAttributes,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpThreadAttributes,
    @Cast("BOOL") boolean bInheritHandles,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCSTR") String lpCurrentDirectory,
    @Cast("LPSTARTUPINFOA") STARTUPINFOA lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
    );
// #ifndef UNICODE
// #endif


// #if(_WIN32_WINNT >= 0x0500)

//
// LogonFlags
//
public static final int LOGON_WITH_PROFILE =              0x00000001;
public static final int LOGON_NETCREDENTIALS_ONLY =       0x00000002;
public static final int LOGON_ZERO_PASSWORD_BUFFER =      0x80000000;

public static native @Cast("BOOL") boolean CreateProcessWithLogonW(
    @Cast("LPCWSTR") CharPointer lpUsername,
    @Cast("LPCWSTR") CharPointer lpDomain,
    @Cast("LPCWSTR") CharPointer lpPassword,
    @Cast("DWORD") int dwLogonFlags,
    @Cast("LPCWSTR") CharPointer lpApplicationName,
    @Cast("LPWSTR") CharPointer lpCommandLine,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCWSTR") CharPointer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOW") STARTUPINFOW lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
      );
public static native @Cast("BOOL") boolean CreateProcessWithLogonW(
    @Cast("LPCWSTR") CharBuffer lpUsername,
    @Cast("LPCWSTR") CharBuffer lpDomain,
    @Cast("LPCWSTR") CharBuffer lpPassword,
    @Cast("DWORD") int dwLogonFlags,
    @Cast("LPCWSTR") CharBuffer lpApplicationName,
    @Cast("LPWSTR") CharBuffer lpCommandLine,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCWSTR") CharBuffer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOW") STARTUPINFOW lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
      );
public static native @Cast("BOOL") boolean CreateProcessWithLogonW(
    @Cast("LPCWSTR") char[] lpUsername,
    @Cast("LPCWSTR") char[] lpDomain,
    @Cast("LPCWSTR") char[] lpPassword,
    @Cast("DWORD") int dwLogonFlags,
    @Cast("LPCWSTR") char[] lpApplicationName,
    @Cast("LPWSTR") char[] lpCommandLine,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCWSTR") char[] lpCurrentDirectory,
    @Cast("LPSTARTUPINFOW") STARTUPINFOW lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
      );

public static native @Cast("BOOL") boolean CreateProcessWithTokenW(
    @Cast("HANDLE") Pointer hToken,
    @Cast("DWORD") int dwLogonFlags,
    @Cast("LPCWSTR") CharPointer lpApplicationName,
    @Cast("LPWSTR") CharPointer lpCommandLine,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCWSTR") CharPointer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOW") STARTUPINFOW lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
      );
public static native @Cast("BOOL") boolean CreateProcessWithTokenW(
    @Cast("HANDLE") Pointer hToken,
    @Cast("DWORD") int dwLogonFlags,
    @Cast("LPCWSTR") CharBuffer lpApplicationName,
    @Cast("LPWSTR") CharBuffer lpCommandLine,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCWSTR") CharBuffer lpCurrentDirectory,
    @Cast("LPSTARTUPINFOW") STARTUPINFOW lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
      );
public static native @Cast("BOOL") boolean CreateProcessWithTokenW(
    @Cast("HANDLE") Pointer hToken,
    @Cast("DWORD") int dwLogonFlags,
    @Cast("LPCWSTR") char[] lpApplicationName,
    @Cast("LPWSTR") char[] lpCommandLine,
    @Cast("DWORD") int dwCreationFlags,
    @Cast("LPVOID") Pointer lpEnvironment,
    @Cast("LPCWSTR") char[] lpCurrentDirectory,
    @Cast("LPSTARTUPINFOW") STARTUPINFOW lpStartupInfo,
    @Cast("LPPROCESS_INFORMATION") PROCESS_INFORMATION lpProcessInformation
      );

// #endif // (_WIN32_WINNT >= 0x0500)

public static native @Cast("BOOL") boolean IsTokenUntrusted(
    @Cast("HANDLE") Pointer TokenHandle
    );

//
// Thread pool API's
//

// #if (_WIN32_WINNT >= 0x0500)

public static native @Cast("BOOL") boolean RegisterWaitForSingleObject(
    @Cast("PHANDLE") PointerPointer phNewWaitObject,
    @Cast("HANDLE") Pointer hObject,
    @Cast("WAITORTIMERCALLBACK") WAITORTIMERCALLBACKFUNC Callback,
    @Cast("PVOID") Pointer Context,
    @Cast("ULONG") long dwMilliseconds,
    @Cast("ULONG") long dwFlags
    );

public static native @Cast("BOOL") boolean UnregisterWait(
    @Cast("HANDLE") Pointer WaitHandle
    );

public static native @Cast("BOOL") boolean BindIoCompletionCallback(
    @Cast("HANDLE") Pointer FileHandle,
    LPOVERLAPPED_COMPLETION_ROUTINE Function,
    @Cast("ULONG") long Flags
    );

public static native @Cast("HANDLE") Pointer SetTimerQueueTimer(
    @Cast("HANDLE") Pointer TimerQueue,
    @Cast("WAITORTIMERCALLBACK") WAITORTIMERCALLBACKFUNC Callback,
    @Cast("PVOID") Pointer Parameter,
    @Cast("DWORD") int DueTime,
    @Cast("DWORD") int Period,
    @Cast("BOOL") boolean PreferIo
    );

public static native @Cast("BOOL") boolean CancelTimerQueueTimer(
    @Cast("HANDLE") Pointer TimerQueue,
    @Cast("HANDLE") Pointer Timer
    );

public static native @Cast("BOOL") boolean DeleteTimerQueue(
    @Cast("HANDLE") Pointer TimerQueue
    );

// #if (_WIN32_WINNT >= 0x0600)

// #if !defined(MIDL_PASS)

public static native void InitializeThreadpoolEnvironment(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 pcbe
    );

public static native void SetThreadpoolCallbackPool(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 pcbe,
    @Cast("PTP_POOL") TP_POOL ptpp
    );

public static native void SetThreadpoolCallbackCleanupGroup(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 pcbe,
    @Cast("PTP_CLEANUP_GROUP") TP_CLEANUP_GROUP ptpcg,
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK pfng
    );

public static native void SetThreadpoolCallbackRunsLong(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 pcbe
    );

public static native void SetThreadpoolCallbackLibrary(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 pcbe,
    @Cast("PVOID") Pointer mod
    );

// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

public static native void SetThreadpoolCallbackPriority(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 pcbe,
    @Cast("TP_CALLBACK_PRIORITY") int Priority
    );

// #endif

public static native void SetThreadpoolCallbackPersistent(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 pcbe
    );

public static native void DestroyThreadpoolEnvironment(
    @Cast("PTP_CALLBACK_ENVIRON") TP_CALLBACK_ENVIRON_V3 pcbe
    );

// #endif // !defined(MIDL_PASS)

//
//  Private Namespaces support
//

public static native @Cast("HANDLE") Pointer CreatePrivateNamespaceA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
    @Cast("LPVOID") Pointer lpBoundaryDescriptor,
    @Cast("LPCSTR") BytePointer lpAliasPrefix
    );
public static native @Cast("HANDLE") Pointer CreatePrivateNamespaceA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
    @Cast("LPVOID") Pointer lpBoundaryDescriptor,
    @Cast("LPCSTR") ByteBuffer lpAliasPrefix
    );
public static native @Cast("HANDLE") Pointer CreatePrivateNamespaceA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
    @Cast("LPVOID") Pointer lpBoundaryDescriptor,
    @Cast("LPCSTR") byte[] lpAliasPrefix
    );
public static native @Cast("HANDLE") Pointer CreatePrivateNamespaceA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
    @Cast("LPVOID") Pointer lpBoundaryDescriptor,
    @Cast("LPCSTR") String lpAliasPrefix
    );

// #ifndef UNICODE
// #else
// #endif

public static native @Cast("HANDLE") Pointer OpenPrivateNamespaceA(
    @Cast("LPVOID") Pointer lpBoundaryDescriptor,
    @Cast("LPCSTR") BytePointer lpAliasPrefix
    );
public static native @Cast("HANDLE") Pointer OpenPrivateNamespaceA(
    @Cast("LPVOID") Pointer lpBoundaryDescriptor,
    @Cast("LPCSTR") ByteBuffer lpAliasPrefix
    );
public static native @Cast("HANDLE") Pointer OpenPrivateNamespaceA(
    @Cast("LPVOID") Pointer lpBoundaryDescriptor,
    @Cast("LPCSTR") byte[] lpAliasPrefix
    );
public static native @Cast("HANDLE") Pointer OpenPrivateNamespaceA(
    @Cast("LPVOID") Pointer lpBoundaryDescriptor,
    @Cast("LPCSTR") String lpAliasPrefix
    );

// #ifndef UNICODE
// #else
// #endif


//
//  Boundary descriptors support
//

public static native @Cast("HANDLE") Pointer CreateBoundaryDescriptorA(
    @Cast("LPCSTR") BytePointer Name,
    @Cast("ULONG") long Flags
    );
public static native @Cast("HANDLE") Pointer CreateBoundaryDescriptorA(
    @Cast("LPCSTR") ByteBuffer Name,
    @Cast("ULONG") long Flags
    );
public static native @Cast("HANDLE") Pointer CreateBoundaryDescriptorA(
    @Cast("LPCSTR") byte[] Name,
    @Cast("ULONG") long Flags
    );
public static native @Cast("HANDLE") Pointer CreateBoundaryDescriptorA(
    @Cast("LPCSTR") String Name,
    @Cast("ULONG") long Flags
    );

// #ifndef UNICODE
// #else
// #endif


public static native @Cast("BOOL") boolean AddIntegrityLabelToBoundaryDescriptor(
    @Cast("HANDLE*") PointerPointer BoundaryDescriptor,
    @Cast("PSID") Pointer IntegrityLabel
    );


// #endif // _WIN32_WINNT >= 0x0600

// #endif // _WIN32_WINNT >= 0x0500


// #if(_WIN32_WINNT >= 0x0400)
//
// Plug-and-Play API's
//

public static final int HW_PROFILE_GUIDLEN =         39;      // 36-characters plus NULL terminator
public static final int MAX_PROFILE_LEN =            80;

public static final int DOCKINFO_UNDOCKED =          (0x1);
public static final int DOCKINFO_DOCKED =            (0x2);
public static final int DOCKINFO_USER_SUPPLIED =     (0x4);
public static final int DOCKINFO_USER_UNDOCKED =     (DOCKINFO_USER_SUPPLIED | DOCKINFO_UNDOCKED);
public static final int DOCKINFO_USER_DOCKED =       (DOCKINFO_USER_SUPPLIED | DOCKINFO_DOCKED);
// Targeting ..\windows\HW_PROFILE_INFOA.java


// Targeting ..\windows\HW_PROFILE_INFOW.java


// #ifdef UNICODE
// #else
// #endif // UNICODE


public static native @Cast("BOOL") boolean GetCurrentHwProfileA(
    @Cast("LPHW_PROFILE_INFOA") HW_PROFILE_INFOA lpHwProfileInfo
    );
public static native @Cast("BOOL") boolean GetCurrentHwProfileW(
    @Cast("LPHW_PROFILE_INFOW") HW_PROFILE_INFOW lpHwProfileInfo
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE
// #endif /* _WIN32_WINNT >= 0x0400 */

public static native @Cast("BOOL") boolean VerifyVersionInfoA(
    @Cast("LPOSVERSIONINFOEXA") OSVERSIONINFOEXA lpVersionInformation,
    @Cast("DWORD") int dwTypeMask,
    @Cast("DWORDLONG") long dwlConditionMask
    );
public static native @Cast("BOOL") boolean VerifyVersionInfoW(
    @Cast("LPOSVERSIONINFOEXW") OSVERSIONINFOEXW lpVersionInformation,
    @Cast("DWORD") int dwTypeMask,
    @Cast("DWORDLONG") long dwlConditionMask
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// DOS and OS/2 Compatible Error Code definitions returned by the Win32 Base
// API functions.
//

// #include <winerror.h>
// #include <timezoneapi.h>

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

/* Abnormal termination codes */

public static final int TC_NORMAL =       0;
public static final int TC_HARDERR =      1;
public static final int TC_GP_TRAP =      2;
public static final int TC_SIGNAL =       3;

// #if(WINVER >= 0x0400)
//
// Power Management APIs
//

public static final int AC_LINE_OFFLINE =                 0x00;
public static final int AC_LINE_ONLINE =                  0x01;
public static final int AC_LINE_BACKUP_POWER =            0x02;
public static final int AC_LINE_UNKNOWN =                 0xFF;

public static final int BATTERY_FLAG_HIGH =               0x01;
public static final int BATTERY_FLAG_LOW =                0x02;
public static final int BATTERY_FLAG_CRITICAL =           0x04;
public static final int BATTERY_FLAG_CHARGING =           0x08;
public static final int BATTERY_FLAG_NO_BATTERY =         0x80;
public static final int BATTERY_FLAG_UNKNOWN =            0xFF;

public static final int BATTERY_PERCENTAGE_UNKNOWN =      0xFF;

public static final int BATTERY_LIFE_UNKNOWN =        0xFFFFFFFF;
// Targeting ..\windows\SYSTEM_POWER_STATUS.java



public static native @Cast("BOOL") boolean GetSystemPowerStatus(
    @Cast("LPSYSTEM_POWER_STATUS") SYSTEM_POWER_STATUS lpSystemPowerStatus
    );

public static native @Cast("BOOL") boolean SetSystemPowerState(
    @Cast("BOOL") boolean fSuspend,
    @Cast("BOOL") boolean fForce
    );

// #endif /* WINVER >= 0x0400 */

// #if (_WIN32_WINNT >= 0x0500)
//
// Very Large Memory API Subset
//

public static native @Cast("BOOL") boolean MapUserPhysicalPagesScatter(
    @Cast("PVOID*") PointerPointer VirtualAddresses,
    @Cast("ULONG_PTR") long NumberOfPages,
    @Cast("PULONG_PTR") SizeTPointer PageArray
    );

public static native @Cast("HANDLE") Pointer CreateJobObjectA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpJobAttributes,
    @Cast("LPCSTR") BytePointer lpName
    );
public static native @Cast("HANDLE") Pointer CreateJobObjectA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpJobAttributes,
    @Cast("LPCSTR") ByteBuffer lpName
    );
public static native @Cast("HANDLE") Pointer CreateJobObjectA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpJobAttributes,
    @Cast("LPCSTR") byte[] lpName
    );
public static native @Cast("HANDLE") Pointer CreateJobObjectA(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpJobAttributes,
    @Cast("LPCSTR") String lpName
    );
public static native @Cast("HANDLE") Pointer CreateJobObjectW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpJobAttributes,
    @Cast("LPCWSTR") CharPointer lpName
    );
public static native @Cast("HANDLE") Pointer CreateJobObjectW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpJobAttributes,
    @Cast("LPCWSTR") CharBuffer lpName
    );
public static native @Cast("HANDLE") Pointer CreateJobObjectW(
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpJobAttributes,
    @Cast("LPCWSTR") char[] lpName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("HANDLE") Pointer OpenJobObjectA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") BytePointer lpName
    );
public static native @Cast("HANDLE") Pointer OpenJobObjectA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") ByteBuffer lpName
    );
public static native @Cast("HANDLE") Pointer OpenJobObjectA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") byte[] lpName
    );
public static native @Cast("HANDLE") Pointer OpenJobObjectA(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCSTR") String lpName
    );
public static native @Cast("HANDLE") Pointer OpenJobObjectW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") CharPointer lpName
    );
public static native @Cast("HANDLE") Pointer OpenJobObjectW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") CharBuffer lpName
    );
public static native @Cast("HANDLE") Pointer OpenJobObjectW(
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("BOOL") boolean bInheritHandle,
    @Cast("LPCWSTR") char[] lpName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean AssignProcessToJobObject(
    @Cast("HANDLE") Pointer hJob,
    @Cast("HANDLE") Pointer hProcess
    );

public static native @Cast("BOOL") boolean TerminateJobObject(
    @Cast("HANDLE") Pointer hJob,
    @Cast("UINT") int uExitCode
    );

public static native @Cast("BOOL") boolean QueryInformationJobObject(
    @Cast("HANDLE") Pointer hJob,
    @Cast("JOBOBJECTINFOCLASS") int JobObjectInformationClass,
    @Cast("LPVOID") Pointer lpJobObjectInformation,
    @Cast("DWORD") int cbJobObjectInformationLength,
    @Cast("LPDWORD") IntPointer lpReturnLength
    );
public static native @Cast("BOOL") boolean QueryInformationJobObject(
    @Cast("HANDLE") Pointer hJob,
    @Cast("JOBOBJECTINFOCLASS") int JobObjectInformationClass,
    @Cast("LPVOID") Pointer lpJobObjectInformation,
    @Cast("DWORD") int cbJobObjectInformationLength,
    @Cast("LPDWORD") IntBuffer lpReturnLength
    );
public static native @Cast("BOOL") boolean QueryInformationJobObject(
    @Cast("HANDLE") Pointer hJob,
    @Cast("JOBOBJECTINFOCLASS") int JobObjectInformationClass,
    @Cast("LPVOID") Pointer lpJobObjectInformation,
    @Cast("DWORD") int cbJobObjectInformationLength,
    @Cast("LPDWORD") int[] lpReturnLength
    );

public static native @Cast("BOOL") boolean SetInformationJobObject(
    @Cast("HANDLE") Pointer hJob,
    @Cast("JOBOBJECTINFOCLASS") int JobObjectInformationClass,
    @Cast("LPVOID") Pointer lpJobObjectInformation,
    @Cast("DWORD") int cbJobObjectInformationLength
    );

public static native @Cast("BOOL") boolean CreateJobSet(
    @Cast("ULONG") long NumJob,
    @Cast("PJOB_SET_ARRAY") JOB_SET_ARRAY UserJobSet,
    @Cast("ULONG") long Flags);

public static native @Cast("HANDLE") Pointer FindFirstVolumeA(
    @Cast("LPSTR") BytePointer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeA(
    @Cast("LPSTR") ByteBuffer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeA(
    @Cast("LPSTR") byte[] lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
// #ifndef UNICODE
// #endif

public static native @Cast("BOOL") boolean FindNextVolumeA(
    @Cast("HANDLE") Pointer hFindVolume,
    @Cast("LPSTR") BytePointer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean FindNextVolumeA(
    @Cast("HANDLE") Pointer hFindVolume,
    @Cast("LPSTR") ByteBuffer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean FindNextVolumeA(
    @Cast("HANDLE") Pointer hFindVolume,
    @Cast("LPSTR") byte[] lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
// #ifndef UNICODE
// #endif

public static native @Cast("HANDLE") Pointer FindFirstVolumeMountPointA(
    @Cast("LPCSTR") BytePointer lpszRootPathName,
    @Cast("LPSTR") BytePointer lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeMountPointA(
    @Cast("LPCSTR") ByteBuffer lpszRootPathName,
    @Cast("LPSTR") ByteBuffer lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeMountPointA(
    @Cast("LPCSTR") byte[] lpszRootPathName,
    @Cast("LPSTR") byte[] lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeMountPointA(
    @Cast("LPCSTR") String lpszRootPathName,
    @Cast("LPSTR") BytePointer lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeMountPointA(
    @Cast("LPCSTR") BytePointer lpszRootPathName,
    @Cast("LPSTR") ByteBuffer lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeMountPointA(
    @Cast("LPCSTR") ByteBuffer lpszRootPathName,
    @Cast("LPSTR") byte[] lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeMountPointA(
    @Cast("LPCSTR") byte[] lpszRootPathName,
    @Cast("LPSTR") BytePointer lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeMountPointA(
    @Cast("LPCSTR") String lpszRootPathName,
    @Cast("LPSTR") ByteBuffer lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeMountPointA(
    @Cast("LPCSTR") BytePointer lpszRootPathName,
    @Cast("LPSTR") byte[] lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeMountPointA(
    @Cast("LPCSTR") ByteBuffer lpszRootPathName,
    @Cast("LPSTR") BytePointer lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeMountPointA(
    @Cast("LPCSTR") byte[] lpszRootPathName,
    @Cast("LPSTR") ByteBuffer lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeMountPointA(
    @Cast("LPCSTR") String lpszRootPathName,
    @Cast("LPSTR") byte[] lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeMountPointW(
    @Cast("LPCWSTR") CharPointer lpszRootPathName,
    @Cast("LPWSTR") CharPointer lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeMountPointW(
    @Cast("LPCWSTR") CharBuffer lpszRootPathName,
    @Cast("LPWSTR") CharBuffer lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("HANDLE") Pointer FindFirstVolumeMountPointW(
    @Cast("LPCWSTR") char[] lpszRootPathName,
    @Cast("LPWSTR") char[] lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean FindNextVolumeMountPointA(
    @Cast("HANDLE") Pointer hFindVolumeMountPoint,
    @Cast("LPSTR") BytePointer lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean FindNextVolumeMountPointA(
    @Cast("HANDLE") Pointer hFindVolumeMountPoint,
    @Cast("LPSTR") ByteBuffer lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean FindNextVolumeMountPointA(
    @Cast("HANDLE") Pointer hFindVolumeMountPoint,
    @Cast("LPSTR") byte[] lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean FindNextVolumeMountPointW(
    @Cast("HANDLE") Pointer hFindVolumeMountPoint,
    @Cast("LPWSTR") CharPointer lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean FindNextVolumeMountPointW(
    @Cast("HANDLE") Pointer hFindVolumeMountPoint,
    @Cast("LPWSTR") CharBuffer lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean FindNextVolumeMountPointW(
    @Cast("HANDLE") Pointer hFindVolumeMountPoint,
    @Cast("LPWSTR") char[] lpszVolumeMountPoint,
    @Cast("DWORD") int cchBufferLength
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean FindVolumeMountPointClose(
    @Cast("HANDLE") Pointer hFindVolumeMountPoint
    );

public static native @Cast("BOOL") boolean SetVolumeMountPointA(
    @Cast("LPCSTR") BytePointer lpszVolumeMountPoint,
    @Cast("LPCSTR") BytePointer lpszVolumeName
    );
public static native @Cast("BOOL") boolean SetVolumeMountPointA(
    @Cast("LPCSTR") ByteBuffer lpszVolumeMountPoint,
    @Cast("LPCSTR") ByteBuffer lpszVolumeName
    );
public static native @Cast("BOOL") boolean SetVolumeMountPointA(
    @Cast("LPCSTR") byte[] lpszVolumeMountPoint,
    @Cast("LPCSTR") byte[] lpszVolumeName
    );
public static native @Cast("BOOL") boolean SetVolumeMountPointA(
    @Cast("LPCSTR") String lpszVolumeMountPoint,
    @Cast("LPCSTR") String lpszVolumeName
    );
public static native @Cast("BOOL") boolean SetVolumeMountPointW(
    @Cast("LPCWSTR") CharPointer lpszVolumeMountPoint,
    @Cast("LPCWSTR") CharPointer lpszVolumeName
    );
public static native @Cast("BOOL") boolean SetVolumeMountPointW(
    @Cast("LPCWSTR") CharBuffer lpszVolumeMountPoint,
    @Cast("LPCWSTR") CharBuffer lpszVolumeName
    );
public static native @Cast("BOOL") boolean SetVolumeMountPointW(
    @Cast("LPCWSTR") char[] lpszVolumeMountPoint,
    @Cast("LPCWSTR") char[] lpszVolumeName
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean DeleteVolumeMountPointA(
    @Cast("LPCSTR") BytePointer lpszVolumeMountPoint
    );
public static native @Cast("BOOL") boolean DeleteVolumeMountPointA(
    @Cast("LPCSTR") ByteBuffer lpszVolumeMountPoint
    );
public static native @Cast("BOOL") boolean DeleteVolumeMountPointA(
    @Cast("LPCSTR") byte[] lpszVolumeMountPoint
    );
public static native @Cast("BOOL") boolean DeleteVolumeMountPointA(
    @Cast("LPCSTR") String lpszVolumeMountPoint
    );
// #ifndef UNICODE
// #endif

public static native @Cast("BOOL") boolean GetVolumeNameForVolumeMountPointA(
    @Cast("LPCSTR") BytePointer lpszVolumeMountPoint,
    @Cast("LPSTR") BytePointer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumeNameForVolumeMountPointA(
    @Cast("LPCSTR") ByteBuffer lpszVolumeMountPoint,
    @Cast("LPSTR") ByteBuffer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumeNameForVolumeMountPointA(
    @Cast("LPCSTR") byte[] lpszVolumeMountPoint,
    @Cast("LPSTR") byte[] lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumeNameForVolumeMountPointA(
    @Cast("LPCSTR") String lpszVolumeMountPoint,
    @Cast("LPSTR") BytePointer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumeNameForVolumeMountPointA(
    @Cast("LPCSTR") BytePointer lpszVolumeMountPoint,
    @Cast("LPSTR") ByteBuffer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumeNameForVolumeMountPointA(
    @Cast("LPCSTR") ByteBuffer lpszVolumeMountPoint,
    @Cast("LPSTR") byte[] lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumeNameForVolumeMountPointA(
    @Cast("LPCSTR") byte[] lpszVolumeMountPoint,
    @Cast("LPSTR") BytePointer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumeNameForVolumeMountPointA(
    @Cast("LPCSTR") String lpszVolumeMountPoint,
    @Cast("LPSTR") ByteBuffer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumeNameForVolumeMountPointA(
    @Cast("LPCSTR") BytePointer lpszVolumeMountPoint,
    @Cast("LPSTR") byte[] lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumeNameForVolumeMountPointA(
    @Cast("LPCSTR") ByteBuffer lpszVolumeMountPoint,
    @Cast("LPSTR") BytePointer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumeNameForVolumeMountPointA(
    @Cast("LPCSTR") byte[] lpszVolumeMountPoint,
    @Cast("LPSTR") ByteBuffer lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumeNameForVolumeMountPointA(
    @Cast("LPCSTR") String lpszVolumeMountPoint,
    @Cast("LPSTR") byte[] lpszVolumeName,
    @Cast("DWORD") int cchBufferLength
    );
// #ifndef UNICODE
// #endif

public static native @Cast("BOOL") boolean GetVolumePathNameA(
    @Cast("LPCSTR") BytePointer lpszFileName,
    @Cast("LPSTR") BytePointer lpszVolumePathName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNameA(
    @Cast("LPCSTR") ByteBuffer lpszFileName,
    @Cast("LPSTR") ByteBuffer lpszVolumePathName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNameA(
    @Cast("LPCSTR") byte[] lpszFileName,
    @Cast("LPSTR") byte[] lpszVolumePathName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNameA(
    @Cast("LPCSTR") String lpszFileName,
    @Cast("LPSTR") BytePointer lpszVolumePathName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNameA(
    @Cast("LPCSTR") BytePointer lpszFileName,
    @Cast("LPSTR") ByteBuffer lpszVolumePathName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNameA(
    @Cast("LPCSTR") ByteBuffer lpszFileName,
    @Cast("LPSTR") byte[] lpszVolumePathName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNameA(
    @Cast("LPCSTR") byte[] lpszFileName,
    @Cast("LPSTR") BytePointer lpszVolumePathName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNameA(
    @Cast("LPCSTR") String lpszFileName,
    @Cast("LPSTR") ByteBuffer lpszVolumePathName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNameA(
    @Cast("LPCSTR") BytePointer lpszFileName,
    @Cast("LPSTR") byte[] lpszVolumePathName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNameA(
    @Cast("LPCSTR") ByteBuffer lpszFileName,
    @Cast("LPSTR") BytePointer lpszVolumePathName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNameA(
    @Cast("LPCSTR") byte[] lpszFileName,
    @Cast("LPSTR") ByteBuffer lpszVolumePathName,
    @Cast("DWORD") int cchBufferLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNameA(
    @Cast("LPCSTR") String lpszFileName,
    @Cast("LPSTR") byte[] lpszVolumePathName,
    @Cast("DWORD") int cchBufferLength
    );
// #ifndef UNICODE
// #endif

// #endif

// #if(_WIN32_WINNT >= 0x0501)

public static native @Cast("BOOL") boolean GetVolumePathNamesForVolumeNameA(
    @Cast("LPCSTR") BytePointer lpszVolumeName,
    @Cast("LPCH") BytePointer lpszVolumePathNames,
    @Cast("DWORD") int cchBufferLength,
    @Cast("PDWORD") IntPointer lpcchReturnLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNamesForVolumeNameA(
    @Cast("LPCSTR") ByteBuffer lpszVolumeName,
    @Cast("LPCH") ByteBuffer lpszVolumePathNames,
    @Cast("DWORD") int cchBufferLength,
    @Cast("PDWORD") IntBuffer lpcchReturnLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNamesForVolumeNameA(
    @Cast("LPCSTR") byte[] lpszVolumeName,
    @Cast("LPCH") byte[] lpszVolumePathNames,
    @Cast("DWORD") int cchBufferLength,
    @Cast("PDWORD") int[] lpcchReturnLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNamesForVolumeNameA(
    @Cast("LPCSTR") String lpszVolumeName,
    @Cast("LPCH") BytePointer lpszVolumePathNames,
    @Cast("DWORD") int cchBufferLength,
    @Cast("PDWORD") IntPointer lpcchReturnLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNamesForVolumeNameA(
    @Cast("LPCSTR") BytePointer lpszVolumeName,
    @Cast("LPCH") ByteBuffer lpszVolumePathNames,
    @Cast("DWORD") int cchBufferLength,
    @Cast("PDWORD") IntBuffer lpcchReturnLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNamesForVolumeNameA(
    @Cast("LPCSTR") ByteBuffer lpszVolumeName,
    @Cast("LPCH") byte[] lpszVolumePathNames,
    @Cast("DWORD") int cchBufferLength,
    @Cast("PDWORD") int[] lpcchReturnLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNamesForVolumeNameA(
    @Cast("LPCSTR") byte[] lpszVolumeName,
    @Cast("LPCH") BytePointer lpszVolumePathNames,
    @Cast("DWORD") int cchBufferLength,
    @Cast("PDWORD") IntPointer lpcchReturnLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNamesForVolumeNameA(
    @Cast("LPCSTR") String lpszVolumeName,
    @Cast("LPCH") ByteBuffer lpszVolumePathNames,
    @Cast("DWORD") int cchBufferLength,
    @Cast("PDWORD") IntBuffer lpcchReturnLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNamesForVolumeNameA(
    @Cast("LPCSTR") BytePointer lpszVolumeName,
    @Cast("LPCH") byte[] lpszVolumePathNames,
    @Cast("DWORD") int cchBufferLength,
    @Cast("PDWORD") int[] lpcchReturnLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNamesForVolumeNameA(
    @Cast("LPCSTR") ByteBuffer lpszVolumeName,
    @Cast("LPCH") BytePointer lpszVolumePathNames,
    @Cast("DWORD") int cchBufferLength,
    @Cast("PDWORD") IntPointer lpcchReturnLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNamesForVolumeNameA(
    @Cast("LPCSTR") byte[] lpszVolumeName,
    @Cast("LPCH") ByteBuffer lpszVolumePathNames,
    @Cast("DWORD") int cchBufferLength,
    @Cast("PDWORD") IntBuffer lpcchReturnLength
    );
public static native @Cast("BOOL") boolean GetVolumePathNamesForVolumeNameA(
    @Cast("LPCSTR") String lpszVolumeName,
    @Cast("LPCH") byte[] lpszVolumePathNames,
    @Cast("DWORD") int cchBufferLength,
    @Cast("PDWORD") int[] lpcchReturnLength
    );

// #ifndef UNICODE
// #endif

// #endif // (_WIN32_WINNT >= 0x0501)

// #if (_WIN32_WINNT >= 0x0500) || (_WIN32_FUSION >= 0x0100) || ISOLATION_AWARE_ENABLED

public static final int ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID =    (0x00000001);
public static final int ACTCTX_FLAG_LANGID_VALID =                    (0x00000002);
public static final int ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID =        (0x00000004);
public static final int ACTCTX_FLAG_RESOURCE_NAME_VALID =             (0x00000008);
public static final int ACTCTX_FLAG_SET_PROCESS_DEFAULT =             (0x00000010);
public static final int ACTCTX_FLAG_APPLICATION_NAME_VALID =          (0x00000020);
public static final int ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF =           (0x00000040);
public static final int ACTCTX_FLAG_HMODULE_VALID =                   (0x00000080);
// Targeting ..\windows\ACTCTXA.java


// Targeting ..\windows\ACTCTXW.java


// #ifdef UNICODE
// #else
// #endif // UNICODE
// #ifdef UNICODE
// #else
// #endif // UNICODE



public static native @Cast("HANDLE") Pointer CreateActCtxA(
    @Cast("PCACTCTXA") ACTCTXA pActCtx
    );
public static native @Cast("HANDLE") Pointer CreateActCtxW(
    @Cast("PCACTCTXW") ACTCTXW pActCtx
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native void AddRefActCtx(
    @Cast("HANDLE") Pointer hActCtx
    );


public static native void ReleaseActCtx(
    @Cast("HANDLE") Pointer hActCtx
    );

public static native @Cast("BOOL") boolean ZombifyActCtx(
    @Cast("HANDLE") Pointer hActCtx
    );


public static native @Cast("BOOL") boolean ActivateActCtx(
    @Cast("HANDLE") Pointer hActCtx,
    @Cast("ULONG_PTR*") SizeTPointer lpCookie
    );


public static final int DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION = (0x00000001);

public static native @Cast("BOOL") boolean DeactivateActCtx(
    @Cast("DWORD") int dwFlags,
    @Cast("ULONG_PTR") long ulCookie
    );

public static native @Cast("BOOL") boolean GetCurrentActCtx(
    @Cast("HANDLE*") PointerPointer lphActCtx);
// Targeting ..\windows\ACTCTX_SECTION_KEYED_DATA_2600.java


// Targeting ..\windows\ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA.java


// Targeting ..\windows\ACTCTX_SECTION_KEYED_DATA.java



public static final int FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX = (0x00000001);
public static final int FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS =   (0x00000002);
public static final int FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA = (0x00000004);



public static native @Cast("BOOL") boolean FindActCtxSectionStringA(
    @Cast("DWORD") int dwFlags,
    @Const GUID lpExtensionGuid,
    @Cast("ULONG") long ulSectionId,
    @Cast("LPCSTR") BytePointer lpStringToFind,
    @Cast("PACTCTX_SECTION_KEYED_DATA") ACTCTX_SECTION_KEYED_DATA ReturnedData
    );
public static native @Cast("BOOL") boolean FindActCtxSectionStringA(
    @Cast("DWORD") int dwFlags,
    @Const GUID lpExtensionGuid,
    @Cast("ULONG") long ulSectionId,
    @Cast("LPCSTR") ByteBuffer lpStringToFind,
    @Cast("PACTCTX_SECTION_KEYED_DATA") ACTCTX_SECTION_KEYED_DATA ReturnedData
    );
public static native @Cast("BOOL") boolean FindActCtxSectionStringA(
    @Cast("DWORD") int dwFlags,
    @Const GUID lpExtensionGuid,
    @Cast("ULONG") long ulSectionId,
    @Cast("LPCSTR") byte[] lpStringToFind,
    @Cast("PACTCTX_SECTION_KEYED_DATA") ACTCTX_SECTION_KEYED_DATA ReturnedData
    );
public static native @Cast("BOOL") boolean FindActCtxSectionStringA(
    @Cast("DWORD") int dwFlags,
    @Const GUID lpExtensionGuid,
    @Cast("ULONG") long ulSectionId,
    @Cast("LPCSTR") String lpStringToFind,
    @Cast("PACTCTX_SECTION_KEYED_DATA") ACTCTX_SECTION_KEYED_DATA ReturnedData
    );
public static native @Cast("BOOL") boolean FindActCtxSectionStringW(
    @Cast("DWORD") int dwFlags,
    @Const GUID lpExtensionGuid,
    @Cast("ULONG") long ulSectionId,
    @Cast("LPCWSTR") CharPointer lpStringToFind,
    @Cast("PACTCTX_SECTION_KEYED_DATA") ACTCTX_SECTION_KEYED_DATA ReturnedData
    );
public static native @Cast("BOOL") boolean FindActCtxSectionStringW(
    @Cast("DWORD") int dwFlags,
    @Const GUID lpExtensionGuid,
    @Cast("ULONG") long ulSectionId,
    @Cast("LPCWSTR") CharBuffer lpStringToFind,
    @Cast("PACTCTX_SECTION_KEYED_DATA") ACTCTX_SECTION_KEYED_DATA ReturnedData
    );
public static native @Cast("BOOL") boolean FindActCtxSectionStringW(
    @Cast("DWORD") int dwFlags,
    @Const GUID lpExtensionGuid,
    @Cast("ULONG") long ulSectionId,
    @Cast("LPCWSTR") char[] lpStringToFind,
    @Cast("PACTCTX_SECTION_KEYED_DATA") ACTCTX_SECTION_KEYED_DATA ReturnedData
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean FindActCtxSectionGuid(
    @Cast("DWORD") int dwFlags,
    @Const GUID lpExtensionGuid,
    @Cast("ULONG") long ulSectionId,
    @Const GUID lpGuidToFind,
    @Cast("PACTCTX_SECTION_KEYED_DATA") ACTCTX_SECTION_KEYED_DATA ReturnedData
    );
// Targeting ..\windows\ACTIVATION_CONTEXT_BASIC_INFORMATION.java


// Targeting ..\windows\_ACTIVATION_CONTEXT_BASIC_INFORMATION.java



public static final int ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED = 1;

// #endif // !defined(ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED)
// #endif

public static final int QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX = (0x00000004);
public static final int QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE = (0x00000008);
public static final int QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS = (0x00000010);
public static final int QUERY_ACTCTX_FLAG_NO_ADDREF =         (0x80000000);



//
// switch (ulInfoClass)
//
//  case ActivationContextBasicInformation:
//    pvSubInstance == NULL
//    pvBuffer is of type PACTIVATION_CONTEXT_BASIC_INFORMATION
//
//  case ActivationContextDetailedInformation:
//    pvSubInstance == NULL
//    pvBuffer is of type PACTIVATION_CONTEXT_DETAILED_INFORMATION
//
//  case AssemblyDetailedInformationInActivationContext:
//    pvSubInstance is of type PULONG
//      *pvSubInstance < ACTIVATION_CONTEXT_DETAILED_INFORMATION::ulAssemblyCount
//    pvBuffer is of type PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION
//
//  case FileInformationInAssemblyOfAssemblyInActivationContext:
//    pvSubInstance is of type PACTIVATION_CONTEXT_QUERY_INDEX
//      pvSubInstance->ulAssemblyIndex < ACTIVATION_CONTEXT_DETAILED_INFORMATION::ulAssemblyCount
//      pvSubInstance->ulFileIndexInAssembly < ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION::ulFileCount
//    pvBuffer is of type PASSEMBLY_FILE_DETAILED_INFORMATION
//
//  case RunlevelInformationInActivationContext :
//    pvSubInstance == NULL
//    pvBuffer is of type PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION
//
// String are placed after the structs.
//
public static native @Cast("BOOL") boolean QueryActCtxW(
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hActCtx,
    @Cast("PVOID") Pointer pvSubInstance,
    @Cast("ULONG") long ulInfoClass,
    @Cast("PVOID") Pointer pvBuffer,
    @Cast("SIZE_T") long cbBuffer,
    @Cast("SIZE_T*") SizeTPointer pcbWrittenOrRequired
    );
// Targeting ..\windows\PQUERYACTCTXW_FUNC.java



// #endif // (_WIN32_WINNT > 0x0500) || (_WIN32_FUSION >= 0x0100) || ISOLATION_AWARE_ENABLED


// #if _WIN32_WINNT >= 0x0501

public static native @Cast("DWORD") int WTSGetActiveConsoleSessionId(
    );

// #endif // (_WIN32_WINNT >= 0x0501)

// #if _WIN32_WINNT >= 0x0601

public static native @Cast("WORD") short GetActiveProcessorGroupCount(
    );

public static native @Cast("WORD") short GetMaximumProcessorGroupCount(
    );

public static native @Cast("DWORD") int GetActiveProcessorCount(
    @Cast("WORD") short GroupNumber
    );

public static native @Cast("DWORD") int GetMaximumProcessorCount(
    @Cast("WORD") short GroupNumber
    );

// #endif // (_WIN32_WINNT >=0x0601)

//
// NUMA Information routines.
//

public static native @Cast("BOOL") boolean GetNumaProcessorNode(
    @Cast("UCHAR") byte Processor,
    @Cast("PUCHAR") BytePointer NodeNumber
    );
public static native @Cast("BOOL") boolean GetNumaProcessorNode(
    @Cast("UCHAR") byte Processor,
    @Cast("PUCHAR") ByteBuffer NodeNumber
    );
public static native @Cast("BOOL") boolean GetNumaProcessorNode(
    @Cast("UCHAR") byte Processor,
    @Cast("PUCHAR") byte[] NodeNumber
    );

// #if _WIN32_WINNT >= 0x0601

public static native @Cast("BOOL") boolean GetNumaNodeNumberFromHandle(
    @Cast("HANDLE") Pointer hFile,
    @Cast("PUSHORT") short NodeNumber
    );

// #endif // (_WIN32_WINNT >=0x0601)

// #if _WIN32_WINNT >= 0x0601

public static native @Cast("BOOL") boolean GetNumaProcessorNodeEx(
    @Cast("PPROCESSOR_NUMBER") PROCESSOR_NUMBER Processor,
    @Cast("PUSHORT") short NodeNumber
    );

// #endif // (_WIN32_WINNT >=0x0601)

public static native @Cast("BOOL") boolean GetNumaNodeProcessorMask(
    @Cast("UCHAR") byte Node,
    @Cast("PULONGLONG") LongPointer ProcessorMask
    );
public static native @Cast("BOOL") boolean GetNumaNodeProcessorMask(
    @Cast("UCHAR") byte Node,
    @Cast("PULONGLONG") LongBuffer ProcessorMask
    );
public static native @Cast("BOOL") boolean GetNumaNodeProcessorMask(
    @Cast("UCHAR") byte Node,
    @Cast("PULONGLONG") long[] ProcessorMask
    );

public static native @Cast("BOOL") boolean GetNumaAvailableMemoryNode(
    @Cast("UCHAR") byte Node,
    @Cast("PULONGLONG") LongPointer AvailableBytes
    );
public static native @Cast("BOOL") boolean GetNumaAvailableMemoryNode(
    @Cast("UCHAR") byte Node,
    @Cast("PULONGLONG") LongBuffer AvailableBytes
    );
public static native @Cast("BOOL") boolean GetNumaAvailableMemoryNode(
    @Cast("UCHAR") byte Node,
    @Cast("PULONGLONG") long[] AvailableBytes
    );

// #if _WIN32_WINNT >= 0x0601

public static native @Cast("BOOL") boolean GetNumaAvailableMemoryNodeEx(
    @Cast("USHORT") short Node,
    @Cast("PULONGLONG") LongPointer AvailableBytes
    );
public static native @Cast("BOOL") boolean GetNumaAvailableMemoryNodeEx(
    @Cast("USHORT") short Node,
    @Cast("PULONGLONG") LongBuffer AvailableBytes
    );
public static native @Cast("BOOL") boolean GetNumaAvailableMemoryNodeEx(
    @Cast("USHORT") short Node,
    @Cast("PULONGLONG") long[] AvailableBytes
    );

// #endif // (_WIN32_WINNT >=0x0601)

// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean GetNumaProximityNode(
    @Cast("ULONG") long ProximityId,
    @Cast("PUCHAR") BytePointer NodeNumber
    );
public static native @Cast("BOOL") boolean GetNumaProximityNode(
    @Cast("ULONG") long ProximityId,
    @Cast("PUCHAR") ByteBuffer NodeNumber
    );
public static native @Cast("BOOL") boolean GetNumaProximityNode(
    @Cast("ULONG") long ProximityId,
    @Cast("PUCHAR") byte[] NodeNumber
    );

// #endif

// #if _WIN32_WINNT >= 0x0601

public static native @Cast("BOOL") boolean GetNumaProximityNodeEx(
    @Cast("ULONG") long ProximityId,
    @Cast("PUSHORT") short NodeNumber
    );
// Targeting ..\windows\APPLICATION_RECOVERY_CALLBACK.java



//
// Max length of commandline in characters (including the NULL character that can be registered for restart)
//
public static final int RESTART_MAX_CMD_LINE =    1024;

//
// Do not restart the process for termination due to application crashes
//
public static final int RESTART_NO_CRASH =        1;

//
// Do not restart the process for termination due to application hangs
//
public static final int RESTART_NO_HANG =         2;

//
// Do not restart the process for termination due to patch installations
//
public static final int RESTART_NO_PATCH =        4;

//
// Do not restart the process when the system is rebooted due to patch installations
//
public static final int RESTART_NO_REBOOT =        8;

public static final int RECOVERY_DEFAULT_PING_INTERVAL =  5000;
public static final int RECOVERY_MAX_PING_INTERVAL =      (5 * 60 * 1000);

// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("HRESULT") int RegisterApplicationRecoveryCallback(
    APPLICATION_RECOVERY_CALLBACK pRecoveyCallback,
    @Cast("PVOID") Pointer pvParameter,
    @Cast("DWORD") int dwPingInterval,
    @Cast("DWORD") int dwFlags
    );

public static native @Cast("HRESULT") int UnregisterApplicationRecoveryCallback();

public static native @Cast("HRESULT") int RegisterApplicationRestart(
    @Cast("PCWSTR") CharPointer pwzCommandline,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("HRESULT") int RegisterApplicationRestart(
    @Cast("PCWSTR") CharBuffer pwzCommandline,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("HRESULT") int RegisterApplicationRestart(
    @Cast("PCWSTR") char[] pwzCommandline,
    @Cast("DWORD") int dwFlags
    );

public static native @Cast("HRESULT") int UnregisterApplicationRestart();

public static native @Cast("HRESULT") int GetApplicationRecoveryCallback(
    @Cast("HANDLE") Pointer hProcess,
    @ByPtrPtr APPLICATION_RECOVERY_CALLBACK pRecoveryCallback,
    @Cast("PVOID*") PointerPointer ppvParameter,
    @Cast("PDWORD") IntPointer pdwPingInterval,
    @Cast("PDWORD") IntPointer pdwFlags
    );
public static native @Cast("HRESULT") int GetApplicationRecoveryCallback(
    @Cast("HANDLE") Pointer hProcess,
    @ByPtrPtr APPLICATION_RECOVERY_CALLBACK pRecoveryCallback,
    @Cast("PVOID*") PointerPointer ppvParameter,
    @Cast("PDWORD") IntBuffer pdwPingInterval,
    @Cast("PDWORD") IntBuffer pdwFlags
    );
public static native @Cast("HRESULT") int GetApplicationRecoveryCallback(
    @Cast("HANDLE") Pointer hProcess,
    @ByPtrPtr APPLICATION_RECOVERY_CALLBACK pRecoveryCallback,
    @Cast("PVOID*") PointerPointer ppvParameter,
    @Cast("PDWORD") int[] pdwPingInterval,
    @Cast("PDWORD") int[] pdwFlags
    );

public static native @Cast("HRESULT") int GetApplicationRestartSettings(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PWSTR") CharPointer pwzCommandline,
    @Cast("PDWORD") IntPointer pcchSize,
    @Cast("PDWORD") IntPointer pdwFlags
    );
public static native @Cast("HRESULT") int GetApplicationRestartSettings(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PWSTR") CharBuffer pwzCommandline,
    @Cast("PDWORD") IntBuffer pcchSize,
    @Cast("PDWORD") IntBuffer pdwFlags
    );
public static native @Cast("HRESULT") int GetApplicationRestartSettings(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PWSTR") char[] pwzCommandline,
    @Cast("PDWORD") int[] pcchSize,
    @Cast("PDWORD") int[] pdwFlags
    );

public static native @Cast("HRESULT") int ApplicationRecoveryInProgress(
    @Cast("PBOOL") boolean pbCancelled
    );

public static native void ApplicationRecoveryFinished(
    @Cast("BOOL") boolean bSuccess
    );

// #endif // _WIN32_WINNT >= 0x0600

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #if (_WIN32_WINNT >= 0x0600)

// #pragma region Application Family
// Targeting ..\windows\FILE_BASIC_INFO.java


// Targeting ..\windows\FILE_STANDARD_INFO.java


// Targeting ..\windows\FILE_NAME_INFO.java


// Targeting ..\windows\FILE_RENAME_INFO.java


// Targeting ..\windows\FILE_ALLOCATION_INFO.java


// Targeting ..\windows\FILE_END_OF_FILE_INFO.java


// Targeting ..\windows\FILE_STREAM_INFO.java


// Targeting ..\windows\FILE_COMPRESSION_INFO.java


// Targeting ..\windows\FILE_ATTRIBUTE_TAG_INFO.java


// Targeting ..\windows\FILE_DISPOSITION_INFO.java


// Targeting ..\windows\FILE_ID_BOTH_DIR_INFO.java


// Targeting ..\windows\FILE_FULL_DIR_INFO.java



/** enum PRIORITY_HINT */
public static final int
      IoPriorityHintVeryLow = 0,
      IoPriorityHintLow = 1,
      IoPriorityHintNormal = 2,
      MaximumIoPriorityHintType = 3;
// Targeting ..\windows\FILE_IO_PRIORITY_HINT_INFO.java



// Structure and constants must match those in ntioapi_x.w

// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)

// #endif

//
// File Remote protocol info (FileRemoteProtocolInfo)
//

// Protocol generic flags.

public static final int REMOTE_PROTOCOL_INFO_FLAG_LOOPBACK =              0x00000001;
public static final int REMOTE_PROTOCOL_INFO_FLAG_OFFLINE =               0x00000002;
// Targeting ..\windows\FILE_REMOTE_PROTOCOL_INFO.java



public static native @Cast("BOOL") boolean GetFileInformationByHandleEx(
    @Cast("HANDLE") Pointer hFile,
    @Cast("FILE_INFO_BY_HANDLE_CLASS") int FileInformationClass,
    @Cast("LPVOID") Pointer lpFileInformation,
    @Cast("DWORD") int dwBufferSize
);

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

/** enum FILE_ID_TYPE */
public static final int
      FileIdType = 0,
      ObjectIdType = 1,
      ExtendedFileIdType = 2,
      MaximumFileIdType = 3;
// Targeting ..\windows\FILE_ID_DESCRIPTOR.java



public static native @Cast("HANDLE") Pointer OpenFileById(
    @Cast("HANDLE") Pointer hVolumeHint,
    @Cast("LPFILE_ID_DESCRIPTOR") FILE_ID_DESCRIPTOR lpFileId,
    @Cast("DWORD") int dwDesiredAccess,
    @Cast("DWORD") int dwShareMode,
    @Cast("LPSECURITY_ATTRIBUTES") SECURITY_ATTRIBUTES lpSecurityAttributes,
    @Cast("DWORD") int dwFlagsAndAttributes
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

// #if (_WIN32_WINNT >= 0x0600)

//
//  Flags to be passed into CREATE_SYMBOLIC_LINK
//

public static final int SYMBOLIC_LINK_FLAG_DIRECTORY =            (0x1);

public static final int VALID_SYMBOLIC_LINK_FLAGS =  SYMBOLIC_LINK_FLAG_DIRECTORY; // & whatever other flags we think of!

public static native @Cast("BOOLEAN") boolean CreateSymbolicLinkA(
    @Cast("LPCSTR") BytePointer lpSymlinkFileName,
    @Cast("LPCSTR") BytePointer lpTargetFileName,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOLEAN") boolean CreateSymbolicLinkA(
    @Cast("LPCSTR") ByteBuffer lpSymlinkFileName,
    @Cast("LPCSTR") ByteBuffer lpTargetFileName,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOLEAN") boolean CreateSymbolicLinkA(
    @Cast("LPCSTR") byte[] lpSymlinkFileName,
    @Cast("LPCSTR") byte[] lpTargetFileName,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOLEAN") boolean CreateSymbolicLinkA(
    @Cast("LPCSTR") String lpSymlinkFileName,
    @Cast("LPCSTR") String lpTargetFileName,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOLEAN") boolean CreateSymbolicLinkW(
    @Cast("LPCWSTR") CharPointer lpSymlinkFileName,
    @Cast("LPCWSTR") CharPointer lpTargetFileName,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOLEAN") boolean CreateSymbolicLinkW(
    @Cast("LPCWSTR") CharBuffer lpSymlinkFileName,
    @Cast("LPCWSTR") CharBuffer lpTargetFileName,
    @Cast("DWORD") int dwFlags
    );
public static native @Cast("BOOLEAN") boolean CreateSymbolicLinkW(
    @Cast("LPCWSTR") char[] lpSymlinkFileName,
    @Cast("LPCWSTR") char[] lpTargetFileName,
    @Cast("DWORD") int dwFlags
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOLEAN") boolean CreateSymbolicLinkTransactedA(
    @Cast("LPCSTR") BytePointer lpSymlinkFileName,
    @Cast("LPCSTR") BytePointer lpTargetFileName,
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOLEAN") boolean CreateSymbolicLinkTransactedA(
    @Cast("LPCSTR") ByteBuffer lpSymlinkFileName,
    @Cast("LPCSTR") ByteBuffer lpTargetFileName,
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOLEAN") boolean CreateSymbolicLinkTransactedA(
    @Cast("LPCSTR") byte[] lpSymlinkFileName,
    @Cast("LPCSTR") byte[] lpTargetFileName,
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOLEAN") boolean CreateSymbolicLinkTransactedA(
    @Cast("LPCSTR") String lpSymlinkFileName,
    @Cast("LPCSTR") String lpTargetFileName,
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOLEAN") boolean CreateSymbolicLinkTransactedW(
    @Cast("LPCWSTR") CharPointer lpSymlinkFileName,
    @Cast("LPCWSTR") CharPointer lpTargetFileName,
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOLEAN") boolean CreateSymbolicLinkTransactedW(
    @Cast("LPCWSTR") CharBuffer lpSymlinkFileName,
    @Cast("LPCWSTR") CharBuffer lpTargetFileName,
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
public static native @Cast("BOOLEAN") boolean CreateSymbolicLinkTransactedW(
    @Cast("LPCWSTR") char[] lpSymlinkFileName,
    @Cast("LPCWSTR") char[] lpTargetFileName,
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hTransaction
    );
// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #endif // (_WIN32_WINNT >= 0x0600)


// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean QueryActCtxSettingsW(
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hActCtx,
    @Cast("PCWSTR") CharPointer settingsNameSpace,
    @Cast("PCWSTR") CharPointer settingName,
    @Cast("PWSTR") CharPointer pvBuffer,
    @Cast("SIZE_T") long dwBuffer,
    @Cast("SIZE_T*") SizeTPointer pdwWrittenOrRequired
    );
public static native @Cast("BOOL") boolean QueryActCtxSettingsW(
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hActCtx,
    @Cast("PCWSTR") CharBuffer settingsNameSpace,
    @Cast("PCWSTR") CharBuffer settingName,
    @Cast("PWSTR") CharBuffer pvBuffer,
    @Cast("SIZE_T") long dwBuffer,
    @Cast("SIZE_T*") SizeTPointer pdwWrittenOrRequired
    );
public static native @Cast("BOOL") boolean QueryActCtxSettingsW(
    @Cast("DWORD") int dwFlags,
    @Cast("HANDLE") Pointer hActCtx,
    @Cast("PCWSTR") char[] settingsNameSpace,
    @Cast("PCWSTR") char[] settingName,
    @Cast("PWSTR") char[] pvBuffer,
    @Cast("SIZE_T") long dwBuffer,
    @Cast("SIZE_T*") SizeTPointer pdwWrittenOrRequired
    );

// #endif

// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean ReplacePartitionUnit(
    @Cast("PWSTR") CharPointer TargetPartition,
    @Cast("PWSTR") CharPointer SparePartition,
    @Cast("ULONG") long Flags
    );
public static native @Cast("BOOL") boolean ReplacePartitionUnit(
    @Cast("PWSTR") CharBuffer TargetPartition,
    @Cast("PWSTR") CharBuffer SparePartition,
    @Cast("ULONG") long Flags
    );
public static native @Cast("BOOL") boolean ReplacePartitionUnit(
    @Cast("PWSTR") char[] TargetPartition,
    @Cast("PWSTR") char[] SparePartition,
    @Cast("ULONG") long Flags
    );

// #endif


// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean AddSecureMemoryCacheCallback(
    PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack
    );

public static native @Cast("BOOL") boolean RemoveSecureMemoryCacheCallback(
    PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack
    );

// #endif

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #if (NTDDI_VERSION >= NTDDI_WIN7SP1)

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean CopyContext(
    @Cast("PCONTEXT") CONTEXT Destination,
    @Cast("DWORD") int ContextFlags,
    @Cast("PCONTEXT") CONTEXT Source
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("BOOL") boolean InitializeContext(
    @Cast("PVOID") Pointer Buffer,
    @Cast("DWORD") int ContextFlags,
    @Cast("PCONTEXT*") PointerPointer Context,
    @Cast("PDWORD") IntPointer ContextLength
    );
public static native @Cast("BOOL") boolean InitializeContext(
    @Cast("PVOID") Pointer Buffer,
    @Cast("DWORD") int ContextFlags,
    @Cast("PCONTEXT*") PointerPointer Context,
    @Cast("PDWORD") IntBuffer ContextLength
    );
public static native @Cast("BOOL") boolean InitializeContext(
    @Cast("PVOID") Pointer Buffer,
    @Cast("DWORD") int ContextFlags,
    @Cast("PCONTEXT*") PointerPointer Context,
    @Cast("PDWORD") int[] ContextLength
    );
// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #if defined(_AMD64_) || defined(_X86_)

// #pragma region Application Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

public static native @Cast("DWORD64") long GetEnabledXStateFeatures(
    );

public static native @Cast("BOOL") boolean GetXStateFeaturesMask(
    @Cast("PCONTEXT") CONTEXT Context,
    @Cast("PDWORD64") LongPointer FeatureMask
    );
public static native @Cast("BOOL") boolean GetXStateFeaturesMask(
    @Cast("PCONTEXT") CONTEXT Context,
    @Cast("PDWORD64") LongBuffer FeatureMask
    );
public static native @Cast("BOOL") boolean GetXStateFeaturesMask(
    @Cast("PCONTEXT") CONTEXT Context,
    @Cast("PDWORD64") long[] FeatureMask
    );

public static native @Cast("PVOID") Pointer LocateXStateFeature(
    @Cast("PCONTEXT") CONTEXT Context,
    @Cast("DWORD") int FeatureId,
    @Cast("PDWORD") IntPointer Length
    );
public static native @Cast("PVOID") Pointer LocateXStateFeature(
    @Cast("PCONTEXT") CONTEXT Context,
    @Cast("DWORD") int FeatureId,
    @Cast("PDWORD") IntBuffer Length
    );
public static native @Cast("PVOID") Pointer LocateXStateFeature(
    @Cast("PCONTEXT") CONTEXT Context,
    @Cast("DWORD") int FeatureId,
    @Cast("PDWORD") int[] Length
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean SetXStateFeaturesMask(
    @Cast("PCONTEXT") CONTEXT Context,
    @Cast("DWORD64") long FeatureMask
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif /* defined(_AMD64_) || defined(_X86_) */

// #endif /* (NTDDI_VERSION >= NTDDI_WIN7SP1) */

// #if (_WIN32_WINNT >= 0x0601)

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("DWORD") int EnableThreadProfiling(
    @Cast("HANDLE") Pointer ThreadHandle,
    @Cast("DWORD") int Flags,
    @Cast("DWORD64") long HardwareCounters,
    @Cast("HANDLE*") PointerPointer PerformanceDataHandle
    );

public static native @Cast("DWORD") int DisableThreadProfiling(
    @Cast("HANDLE") Pointer PerformanceDataHandle
    );

public static native @Cast("DWORD") int QueryThreadProfiling(
    @Cast("HANDLE") Pointer ThreadHandle,
    @Cast("PBOOLEAN") BoolPointer Enabled
    );
public static native @Cast("DWORD") int QueryThreadProfiling(
    @Cast("HANDLE") Pointer ThreadHandle,
    @Cast("PBOOLEAN") boolean[] Enabled
    );

public static native @Cast("DWORD") int ReadThreadProfilingData(
    @Cast("HANDLE") Pointer PerformanceDataHandle,
    @Cast("DWORD") int Flags,
    @Cast("PPERFORMANCE_DATA") PERFORMANCE_DATA PerformanceData
    );

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif /* (_WIN32_WINNT >= 0x0601) */



// #if !defined(RC_INVOKED) /* RC complains about long symbols in #ifs */
// #if defined(ISOLATION_AWARE_ENABLED) && (ISOLATION_AWARE_ENABLED != 0)
// #include "winbase.inl"
// #endif /* ISOLATION_AWARE_ENABLED */
// #endif /* RC */

// #ifdef __cplusplus
// #endif

// #if defined (_MSC_VER)
// #if _MSC_VER >= 1200
// #pragma warning(pop)
// #else
// #pragma warning(default:4001) /* nonstandard extension : single line comment */
// #pragma warning(default:4201) /* nonstandard extension used : nameless struct/union */
// #pragma warning(default:4214) /* nonstandard extension used : bit field types other then int */
// #endif
// #endif



// #endif // _WINBASE_

// #if !defined(RC_INVOKED)
// #if !defined(NOWINBASEINTERLOCK)
// #if !defined(_NTOS_)
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winbase_interlockedcplusplus.h

Abstract:

    C++ function overloads in place of "manual name mangling".
    This file is meant to be #included by winbase.h or any other file declaring the signed interlocked functions.

Author:

    Jay Krell (JayKrell) April 2002

--*/

// #if !defined(RC_INVOKED) /* { */

// #if !defined(MICROSOFT_WINDOWS_WINBASE_INTERLOCKED_CPLUSPLUS_H_INCLUDED) /* { */
// #define MICROSOFT_WINDOWS_WINBASE_INTERLOCKED_CPLUSPLUS_H_INCLUDED
// #if _MSC_VER > 1000
// #pragma once
// #endif

// #if !defined(MIDL_PASS) /* { */

/*
To turn off/hide the contents of this file:
 #define MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS 0
*/

// #if !defined(MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS)
// #define MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS (_WIN32_WINNT >= 0x0502 || !defined(_WINBASE_))
// #endif

// #if MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS  /* { */

// #endif /* } MICROSOFT_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS */

// #undef MICROSOFT_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS
public static final int MICROSOFT_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS = 0;

// #endif /* } MIDL_PASS */
// #endif /* } MICROSOFT_WINDOWS_WINBASE_INTERLOCKED_CPLUSPLUS_H_INCLUDED */
// #endif /* } RC_INVOKED */
// #endif /* _NTOS_ */
// #endif /* NOWINBASEINTERLOCK */
// #endif /* RC_INVOKED */


// Parsed from timezoneapi.h

 
// begin_1_0
/********************************************************************************
*                                                                               *
* timezoneapi.h -- ApiSet Contract for api-ms-win-core-timezone-l1              *
*                                                                               *
* Copyright (c) Microsoft Corporation. All rights reserved.                     *
*                                                                               *
********************************************************************************/

// #ifdef _MSC_VER
// #pragma once
// #endif // _MSC_VER

// #ifndef _TIMEZONEAPI_H_
// #define _TIMEZONEAPI_H_

// #include <apiset.h>
// #include <apisetcconv.h>
// #include <minwindef.h>
// #include <minwinbase.h>

/* APISET_NAME: api-ms-win-core-timezone-l1 */

// #ifndef _APISET_TIMEZONE_VER
// #ifdef _APISET_MINWIN_VERSION
// #if _APISET_MINWIN_VERSION > 0x0100
public static final int _APISET_TIMEZONE_VER = 0x0100;
// #endif
// #endif
// #endif

// #ifdef __cplusplus
// #endif

// end_1_0

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)

// begin_1_0

public static final int TIME_ZONE_ID_INVALID = ((int)0xFFFFFFFF);
// Targeting ..\windows\TIME_ZONE_INFORMATION.java


// Targeting ..\windows\DYNAMIC_TIME_ZONE_INFORMATION.java



public static native @Cast("BOOL") boolean SystemTimeToTzSpecificLocalTime(
    @Const TIME_ZONE_INFORMATION lpTimeZoneInformation,
    @Const SYSTEMTIME lpUniversalTime,
    @Cast("LPSYSTEMTIME") SYSTEMTIME lpLocalTime
    );


public static native @Cast("BOOL") boolean TzSpecificLocalTimeToSystemTime(
    @Const TIME_ZONE_INFORMATION lpTimeZoneInformation,
    @Const SYSTEMTIME lpLocalTime,
    @Cast("LPSYSTEMTIME") SYSTEMTIME lpUniversalTime
    );


public static native @Cast("BOOL") boolean FileTimeToSystemTime(
    @Const FILETIME lpFileTime,
    @Cast("LPSYSTEMTIME") SYSTEMTIME lpSystemTime
    );


public static native @Cast("BOOL") boolean SystemTimeToFileTime(
    @Const SYSTEMTIME lpSystemTime,
    @Cast("LPFILETIME") FILETIME lpFileTime
    );


public static native @Cast("DWORD") int GetTimeZoneInformation(
    @Cast("LPTIME_ZONE_INFORMATION") TIME_ZONE_INFORMATION lpTimeZoneInformation
    );


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// #pragma region Desktop Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)

public static native @Cast("BOOL") boolean SetTimeZoneInformation(
    @Const TIME_ZONE_INFORMATION lpTimeZoneInformation
    );



// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("BOOL") boolean SetDynamicTimeZoneInformation(
    @Const DYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation
    );


// #endif // _WIN32_WINNT >= 0x0600

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #pragma region Application Family

// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)


// #if (_WIN32_WINNT >= 0x0600)

public static native @Cast("DWORD") int GetDynamicTimeZoneInformation(
    @Cast("PDYNAMIC_TIME_ZONE_INFORMATION") DYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation
    );


// #endif // _WIN32_WINNT >= 0x0600


// #if (_WIN32_WINNT >= 0x0601)

public static native @Cast("BOOL") boolean GetTimeZoneInformationForYear(
    @Cast("USHORT") short wYear,
    @Cast("PDYNAMIC_TIME_ZONE_INFORMATION") DYNAMIC_TIME_ZONE_INFORMATION pdtzi,
    @Cast("LPTIME_ZONE_INFORMATION") TIME_ZONE_INFORMATION ptzi
    );


// #endif // _WIN32_WINNT >= 0x0601

// end_1_0


// #if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)


// #endif /* (_WIN32_WINNT >= _WIN32_WINNT_WIN8) */

// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) */
// #pragma endregion

// begin_1_0

// #ifdef __cplusplus
// #endif

// #endif // _TIMEZONEAPI_H_
// end_1_0


// Parsed from Psapi.h

/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1994-1999  Microsoft Corporation

Module Name:

    psapi.h

Abstract:

    Include file for APIs provided by PSAPI.DLL

Author:

    Richard Shupak   [richards]  06-Jan-1994

Revision History:

--*/

// #ifndef _PSAPI_H_
// #define _PSAPI_H_

// #if _MSC_VER > 1000
// #pragma once
// #endif
// #include <winapifamily.h>

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #ifdef __cplusplus
// #endif

public static final int LIST_MODULES_DEFAULT = 0x0;  // This is the default one app would get without any flag.
public static final int LIST_MODULES_32BIT =   0x01;  // list 32bit modules in the target process.
public static final int LIST_MODULES_64BIT =   0x02;  // list all 64bit modules. 32bit exe will be stripped off.

// list all the modules
public static final int LIST_MODULES_ALL =   (LIST_MODULES_32BIT | LIST_MODULES_64BIT);

//
// Give teams a choice of using a downlevel version of psapi.h for an OS versions.
// Teams can set C_DEFINES=$(C_DEFINES) -DPSAPI_VERSION=1 for downlevel psapi
// on windows 7 and higher.  We found that test code needs this capability.
//
// #ifndef PSAPI_VERSION
// #if (NTDDI_VERSION >= NTDDI_WIN7)
public static final int PSAPI_VERSION = 2;
// #else
// #endif
// #endif

// #if (PSAPI_VERSION > 1)
// #endif

public static native @Cast("BOOL") boolean EnumProcesses(
    @Cast("DWORD*") IntPointer lpidProcess,
    @Cast("DWORD") int cb,
    @Cast("LPDWORD") IntPointer lpcbNeeded
    );
public static native @Cast("BOOL") boolean EnumProcesses(
    @Cast("DWORD*") IntBuffer lpidProcess,
    @Cast("DWORD") int cb,
    @Cast("LPDWORD") IntBuffer lpcbNeeded
    );
public static native @Cast("BOOL") boolean EnumProcesses(
    @Cast("DWORD*") int[] lpidProcess,
    @Cast("DWORD") int cb,
    @Cast("LPDWORD") int[] lpcbNeeded
    );

public static native @Cast("BOOL") boolean EnumProcessModules(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE*") PointerPointer lphModule,
    @Cast("DWORD") int cb,
    @Cast("LPDWORD") IntPointer lpcbNeeded
    );
public static native @Cast("BOOL") boolean EnumProcessModules(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE*") PointerPointer lphModule,
    @Cast("DWORD") int cb,
    @Cast("LPDWORD") IntBuffer lpcbNeeded
    );
public static native @Cast("BOOL") boolean EnumProcessModules(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE*") PointerPointer lphModule,
    @Cast("DWORD") int cb,
    @Cast("LPDWORD") int[] lpcbNeeded
    );

public static native @Cast("BOOL") boolean EnumProcessModulesEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE*") PointerPointer lphModule,
    @Cast("DWORD") int cb,
    @Cast("LPDWORD") IntPointer lpcbNeeded,
    @Cast("DWORD") int dwFilterFlag
    );
public static native @Cast("BOOL") boolean EnumProcessModulesEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE*") PointerPointer lphModule,
    @Cast("DWORD") int cb,
    @Cast("LPDWORD") IntBuffer lpcbNeeded,
    @Cast("DWORD") int dwFilterFlag
    );
public static native @Cast("BOOL") boolean EnumProcessModulesEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE*") PointerPointer lphModule,
    @Cast("DWORD") int cb,
    @Cast("LPDWORD") int[] lpcbNeeded,
    @Cast("DWORD") int dwFilterFlag
    );

public static native @Cast("DWORD") int GetModuleBaseNameA(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPSTR") BytePointer lpBaseName,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetModuleBaseNameA(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPSTR") ByteBuffer lpBaseName,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetModuleBaseNameA(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPSTR") byte[] lpBaseName,
    @Cast("DWORD") int nSize
    );

public static native @Cast("DWORD") int GetModuleBaseNameW(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPWSTR") CharPointer lpBaseName,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetModuleBaseNameW(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPWSTR") CharBuffer lpBaseName,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetModuleBaseNameW(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPWSTR") char[] lpBaseName,
    @Cast("DWORD") int nSize
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE


public static native @Cast("DWORD") int GetModuleFileNameExA(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPSTR") BytePointer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetModuleFileNameExA(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPSTR") ByteBuffer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetModuleFileNameExA(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPSTR") byte[] lpFilename,
    @Cast("DWORD") int nSize
    );

public static native @Cast("DWORD") int GetModuleFileNameExW(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPWSTR") CharPointer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetModuleFileNameExW(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPWSTR") CharBuffer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetModuleFileNameExW(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPWSTR") char[] lpFilename,
    @Cast("DWORD") int nSize
    );
// Targeting ..\windows\MODULEINFO.java




public static native @Cast("BOOL") boolean GetModuleInformation(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("HMODULE") Pointer hModule,
    @Cast("LPMODULEINFO") MODULEINFO lpmodinfo,
    @Cast("DWORD") int cb
    );


public static native @Cast("BOOL") boolean EmptyWorkingSet(
    @Cast("HANDLE") Pointer hProcess
    );

//
// Working set information structures. All non-specified bits are reserved.
//

// #if _MSC_VER >= 1200
// #pragma warning(push)
// #endif
// #pragma warning(disable:4201)   // unnamed struct
// #pragma warning(disable:4214)
// Targeting ..\windows\PSAPI_WORKING_SET_BLOCK.java


// Targeting ..\windows\PSAPI_WORKING_SET_INFORMATION.java


// Targeting ..\windows\PSAPI_WORKING_SET_EX_BLOCK.java


// Targeting ..\windows\PSAPI_WORKING_SET_EX_INFORMATION.java



// #if _MSC_VER >= 1200
// #pragma warning(pop)
// #else
// #pragma warning(default:4214)
// #pragma warning(default:4201)
// #endif

public static native @Cast("BOOL") boolean QueryWorkingSet(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PVOID") Pointer pv,
    @Cast("DWORD") int cb
    );

public static native @Cast("BOOL") boolean QueryWorkingSetEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PVOID") Pointer pv,
    @Cast("DWORD") int cb
    );

public static native @Cast("BOOL") boolean InitializeProcessForWsWatch(
    @Cast("HANDLE") Pointer hProcess
    );
// Targeting ..\windows\PSAPI_WS_WATCH_INFORMATION.java


// Targeting ..\windows\PSAPI_WS_WATCH_INFORMATION_EX.java



public static native @Cast("BOOL") boolean GetWsChanges(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PPSAPI_WS_WATCH_INFORMATION") PSAPI_WS_WATCH_INFORMATION lpWatchInfo,
    @Cast("DWORD") int cb
    );

public static native @Cast("BOOL") boolean GetWsChangesEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PPSAPI_WS_WATCH_INFORMATION_EX") PSAPI_WS_WATCH_INFORMATION_EX lpWatchInfoEx,
    @Cast("PDWORD") IntPointer cb
    );
public static native @Cast("BOOL") boolean GetWsChangesEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PPSAPI_WS_WATCH_INFORMATION_EX") PSAPI_WS_WATCH_INFORMATION_EX lpWatchInfoEx,
    @Cast("PDWORD") IntBuffer cb
    );
public static native @Cast("BOOL") boolean GetWsChangesEx(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("PPSAPI_WS_WATCH_INFORMATION_EX") PSAPI_WS_WATCH_INFORMATION_EX lpWatchInfoEx,
    @Cast("PDWORD") int[] cb
    );

public static native @Cast("DWORD") int GetMappedFileNameW(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPVOID") Pointer lpv,
    @Cast("LPWSTR") CharPointer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetMappedFileNameW(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPVOID") Pointer lpv,
    @Cast("LPWSTR") CharBuffer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetMappedFileNameW(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPVOID") Pointer lpv,
    @Cast("LPWSTR") char[] lpFilename,
    @Cast("DWORD") int nSize
    );

public static native @Cast("DWORD") int GetMappedFileNameA(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPVOID") Pointer lpv,
    @Cast("LPSTR") BytePointer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetMappedFileNameA(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPVOID") Pointer lpv,
    @Cast("LPSTR") ByteBuffer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetMappedFileNameA(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPVOID") Pointer lpv,
    @Cast("LPSTR") byte[] lpFilename,
    @Cast("DWORD") int nSize
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

public static native @Cast("BOOL") boolean EnumDeviceDrivers(
    @Cast("LPVOID*") PointerPointer lpImageBase,
    @Cast("DWORD") int cb,
    @Cast("LPDWORD") IntPointer lpcbNeeded
    );
public static native @Cast("BOOL") boolean EnumDeviceDrivers(
    @Cast("LPVOID*") PointerPointer lpImageBase,
    @Cast("DWORD") int cb,
    @Cast("LPDWORD") IntBuffer lpcbNeeded
    );
public static native @Cast("BOOL") boolean EnumDeviceDrivers(
    @Cast("LPVOID*") PointerPointer lpImageBase,
    @Cast("DWORD") int cb,
    @Cast("LPDWORD") int[] lpcbNeeded
    );


public static native @Cast("DWORD") int GetDeviceDriverBaseNameA(
    @Cast("LPVOID") Pointer ImageBase,
    @Cast("LPSTR") BytePointer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetDeviceDriverBaseNameA(
    @Cast("LPVOID") Pointer ImageBase,
    @Cast("LPSTR") ByteBuffer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetDeviceDriverBaseNameA(
    @Cast("LPVOID") Pointer ImageBase,
    @Cast("LPSTR") byte[] lpFilename,
    @Cast("DWORD") int nSize
    );

public static native @Cast("DWORD") int GetDeviceDriverBaseNameW(
    @Cast("LPVOID") Pointer ImageBase,
    @Cast("LPWSTR") CharPointer lpBaseName,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetDeviceDriverBaseNameW(
    @Cast("LPVOID") Pointer ImageBase,
    @Cast("LPWSTR") CharBuffer lpBaseName,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetDeviceDriverBaseNameW(
    @Cast("LPVOID") Pointer ImageBase,
    @Cast("LPWSTR") char[] lpBaseName,
    @Cast("DWORD") int nSize
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE


public static native @Cast("DWORD") int GetDeviceDriverFileNameA(
    @Cast("LPVOID") Pointer ImageBase,
    @Cast("LPSTR") BytePointer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetDeviceDriverFileNameA(
    @Cast("LPVOID") Pointer ImageBase,
    @Cast("LPSTR") ByteBuffer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetDeviceDriverFileNameA(
    @Cast("LPVOID") Pointer ImageBase,
    @Cast("LPSTR") byte[] lpFilename,
    @Cast("DWORD") int nSize
    );

public static native @Cast("DWORD") int GetDeviceDriverFileNameW(
    @Cast("LPVOID") Pointer ImageBase,
    @Cast("LPWSTR") CharPointer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetDeviceDriverFileNameW(
    @Cast("LPVOID") Pointer ImageBase,
    @Cast("LPWSTR") CharBuffer lpFilename,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetDeviceDriverFileNameW(
    @Cast("LPVOID") Pointer ImageBase,
    @Cast("LPWSTR") char[] lpFilename,
    @Cast("DWORD") int nSize
    );
// Targeting ..\windows\PROCESS_MEMORY_COUNTERS.java


// Targeting ..\windows\PROCESS_MEMORY_COUNTERS_EX.java



// #endif

public static native @Cast("BOOL") boolean GetProcessMemoryInfo(
    @Cast("HANDLE") Pointer Process,
    @Cast("PPROCESS_MEMORY_COUNTERS") PROCESS_MEMORY_COUNTERS ppsmemCounters,
    @Cast("DWORD") int cb
    );
// Targeting ..\windows\PERFORMANCE_INFORMATION.java



public static native @Cast("BOOL") boolean GetPerformanceInfo(
    @Cast("PPERFORMANCE_INFORMATION") PERFORMANCE_INFORMATION pPerformanceInformation,
    @Cast("DWORD") int cb
    );
// Targeting ..\windows\ENUM_PAGE_FILE_INFORMATION.java


// Targeting ..\windows\PENUM_PAGE_FILE_CALLBACKW.java


// Targeting ..\windows\PENUM_PAGE_FILE_CALLBACKA.java



public static native @Cast("BOOL") boolean EnumPageFilesW(
    PENUM_PAGE_FILE_CALLBACKW pCallBackRoutine,
    @Cast("LPVOID") Pointer pContext
    );

public static native @Cast("BOOL") boolean EnumPageFilesA(
    PENUM_PAGE_FILE_CALLBACKA pCallBackRoutine,
    @Cast("LPVOID") Pointer pContext
    );

// #ifdef UNICODE
// #define PENUM_PAGE_FILE_CALLBACK PENUM_PAGE_FILE_CALLBACKW
// #else
// #endif // !UNICODE

public static native @Cast("DWORD") int GetProcessImageFileNameA(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPSTR") BytePointer lpImageFileName,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProcessImageFileNameA(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPSTR") ByteBuffer lpImageFileName,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProcessImageFileNameA(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPSTR") byte[] lpImageFileName,
    @Cast("DWORD") int nSize
    );

public static native @Cast("DWORD") int GetProcessImageFileNameW(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPWSTR") CharPointer lpImageFileName,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProcessImageFileNameW(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPWSTR") CharBuffer lpImageFileName,
    @Cast("DWORD") int nSize
    );
public static native @Cast("DWORD") int GetProcessImageFileNameW(
    @Cast("HANDLE") Pointer hProcess,
    @Cast("LPWSTR") char[] lpImageFileName,
    @Cast("DWORD") int nSize
    );

// #ifdef UNICODE
// #else
// #endif // !UNICODE

// #ifdef __cplusplus
// #endif


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif


// Parsed from TlHelp32.h

/*****************************************************************************\
*                                                                             *
* tlhelp32.h -  WIN32 tool help functions, types, and definitions             *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* NOTE: windows.h/winbase.h must be #included first                           *
*                                                                             *
* Copyright (c) Microsoft Corp.  All rights reserved.                         *
*                                                                             *
\*****************************************************************************/

// #ifndef _INC_TOOLHELP32
// #define _INC_TOOLHELP32

// #if _MSC_VER > 1000
// #pragma once
// #endif
// #include <winapifamily.h>

// #pragma region Desktop Family
// #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)


// #ifdef __cplusplus            /* Assume C declarations for C++ */
// #endif  /* __cplusplus */

public static final int MAX_MODULE_NAME32 = 255;

/****** Shapshot function **********************************************/

public static native @Cast("HANDLE") Pointer CreateToolhelp32Snapshot(
    @Cast("DWORD") int dwFlags,
    @Cast("DWORD") int th32ProcessID
    );

//
// The th32ProcessID argument is only used if TH32CS_SNAPHEAPLIST or
// TH32CS_SNAPMODULE is specified. th32ProcessID == 0 means the current
// process.
//
// NOTE that all of the snapshots are global except for the heap and module
//      lists which are process specific. To enumerate the heap or module
//      state for all WIN32 processes call with TH32CS_SNAPALL and the
//      current process. Then for each process in the TH32CS_SNAPPROCESS
//      list that isn't the current process, do a call with just
//      TH32CS_SNAPHEAPLIST and/or TH32CS_SNAPMODULE.
//
// dwFlags
//
public static final int TH32CS_SNAPHEAPLIST = 0x00000001;
public static final int TH32CS_SNAPPROCESS =  0x00000002;
public static final int TH32CS_SNAPTHREAD =   0x00000004;
public static final int TH32CS_SNAPMODULE =   0x00000008;
public static final int TH32CS_SNAPMODULE32 = 0x00000010;
public static final int TH32CS_SNAPALL =      (TH32CS_SNAPHEAPLIST | TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD | TH32CS_SNAPMODULE);
public static final int TH32CS_INHERIT =      0x80000000;
// Targeting ..\windows\HEAPLIST32.java


//
// dwFlags
//
public static final int HF32_DEFAULT =      1;  // process's default heap
public static final int HF32_SHARED =       2;  // is shared heap

public static native @Cast("BOOL") boolean Heap32ListFirst(
    @Cast("HANDLE") Pointer hSnapshot,
    @Cast("LPHEAPLIST32") HEAPLIST32 lphl
    );

public static native @Cast("BOOL") boolean Heap32ListNext(
    @Cast("HANDLE") Pointer hSnapshot,
    @Cast("LPHEAPLIST32") HEAPLIST32 lphl
    );
// Targeting ..\windows\HEAPENTRY32.java


//
// dwFlags
//
public static final int LF32_FIXED =    0x00000001;
public static final int LF32_FREE =     0x00000002;
public static final int LF32_MOVEABLE = 0x00000004;

public static native @Cast("BOOL") boolean Heap32First(
    @Cast("LPHEAPENTRY32") HEAPENTRY32 lphe,
    @Cast("DWORD") int th32ProcessID,
    @Cast("ULONG_PTR") long th32HeapID
    );

public static native @Cast("BOOL") boolean Heap32Next(
    @Cast("LPHEAPENTRY32") HEAPENTRY32 lphe
    );

public static native @Cast("BOOL") boolean Toolhelp32ReadProcessMemory(
    @Cast("DWORD") int th32ProcessID,
    LPCVOID lpBaseAddress,
    @Cast("LPVOID") Pointer lpBuffer,
    @Cast("SIZE_T") long cbRead,
    @Cast("SIZE_T*") SizeTPointer lpNumberOfBytesRead
    );
// Targeting ..\windows\PROCESSENTRY32W.java



public static native @Cast("BOOL") boolean Process32FirstW(
    @Cast("HANDLE") Pointer hSnapshot,
    @Cast("LPPROCESSENTRY32W") PROCESSENTRY32W lppe
    );

public static native @Cast("BOOL") boolean Process32NextW(
    @Cast("HANDLE") Pointer hSnapshot,
    @Cast("LPPROCESSENTRY32W") PROCESSENTRY32W lppe
    );
// Targeting ..\windows\PROCESSENTRY32.java



public static native @Cast("BOOL") boolean Process32First(
    @Cast("HANDLE") Pointer hSnapshot,
    @Cast("LPPROCESSENTRY32") PROCESSENTRY32 lppe
    );

public static native @Cast("BOOL") boolean Process32Next(
    @Cast("HANDLE") Pointer hSnapshot,
    @Cast("LPPROCESSENTRY32") PROCESSENTRY32 lppe
    );
// Targeting ..\windows\THREADENTRY32.java



public static native @Cast("BOOL") boolean Thread32First(
    @Cast("HANDLE") Pointer hSnapshot,
    @Cast("LPTHREADENTRY32") THREADENTRY32 lpte
    );

public static native @Cast("BOOL") boolean Thread32Next(
    @Cast("HANDLE") Pointer hSnapshot,
    @Cast("LPTHREADENTRY32") THREADENTRY32 lpte
    );
// Targeting ..\windows\MODULEENTRY32W.java



public static native @Cast("BOOL") boolean Module32FirstW(
    @Cast("HANDLE") Pointer hSnapshot,
    @Cast("LPMODULEENTRY32W") MODULEENTRY32W lpme
    );

public static native @Cast("BOOL") boolean Module32NextW(
    @Cast("HANDLE") Pointer hSnapshot,
    @Cast("LPMODULEENTRY32W") MODULEENTRY32W lpme
    );
// Targeting ..\windows\MODULEENTRY32.java



//
// NOTE CAREFULLY that the modBaseAddr and hModule fields are valid ONLY
// in th32ProcessID's process context.
//

public static native @Cast("BOOL") boolean Module32First(
    @Cast("HANDLE") Pointer hSnapshot,
    @Cast("LPMODULEENTRY32") MODULEENTRY32 lpme
    );

public static native @Cast("BOOL") boolean Module32Next(
    @Cast("HANDLE") Pointer hSnapshot,
    @Cast("LPMODULEENTRY32") MODULEENTRY32 lpme
    );

// #ifdef UNICODE
// #endif  // !UNICODE


// #ifdef __cplusplus
// #endif


// #endif /* WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) */
// #pragma endregion

// #endif // _INC_TOOLHELP32


}
