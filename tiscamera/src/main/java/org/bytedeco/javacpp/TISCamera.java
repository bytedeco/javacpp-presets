// Targeted by JavaCPP version 1.4.1-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class TISCamera extends org.bytedeco.javacpp.presets.TISCamera {
    static { Loader.load(); }

public static class sink_callback extends FunctionPointer {
    static { Loader.load(); }
    public    sink_callback(Pointer p) { super(p); }
    protected sink_callback() { allocate(); }
    private native void allocate();
    public native void call(@ByRef @Cast("tcam::MemoryBuffer*") MemoryBuffer arg0, Pointer arg1);
}

@Name("std::map<std::string,int>") public static class StringIntMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringIntMap(Pointer p) { super(p); }
    public StringIntMap()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef StringIntMap put(@ByRef StringIntMap x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index public native int get(@StdString BytePointer i);
    public native StringIntMap put(@StdString BytePointer i, int value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter @StdString BytePointer first();
        public native @Name("operator*().second") @MemberGetter int second();
    }
}

@Name("std::vector<tcam::Property*>") public static class PropertyVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PropertyVector(Pointer p) { super(p); }
    public PropertyVector(Property value) { this(1); put(0, value); }
    public PropertyVector(Property ... array) { this(array.length); put(array); }
    public PropertyVector()       { allocate();  }
    public PropertyVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef PropertyVector put(@ByRef PropertyVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index public native Property get(@Cast("size_t") long i);
    public native PropertyVector put(@Cast("size_t") long i, Property value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") Property get();
    }

    public Property pop_back() {
        long size = size();
        Property value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public PropertyVector push_back(Property value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public PropertyVector put(Property value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public PropertyVector put(Property ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<std::shared_ptr<tcam::MemoryBuffer> >") public static class SharedMemoryBufferVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SharedMemoryBufferVector(Pointer p) { super(p); }
    public SharedMemoryBufferVector(MemoryBuffer value) { this(1); put(0, value); }
    public SharedMemoryBufferVector(MemoryBuffer ... array) { this(array.length); put(array); }
    public SharedMemoryBufferVector()       { allocate();  }
    public SharedMemoryBufferVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef SharedMemoryBufferVector put(@ByRef SharedMemoryBufferVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index public native @SharedPtr MemoryBuffer get(@Cast("size_t") long i);
    public native SharedMemoryBufferVector put(@Cast("size_t") long i, MemoryBuffer value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @SharedPtr MemoryBuffer get();
    }

    public MemoryBuffer pop_back() {
        long size = size();
        MemoryBuffer value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public SharedMemoryBufferVector push_back(MemoryBuffer value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public SharedMemoryBufferVector put(MemoryBuffer value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public SharedMemoryBufferVector put(MemoryBuffer ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<std::shared_ptr<tcam::Property> >") public static class SharedPropertyVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SharedPropertyVector(Pointer p) { super(p); }
    public SharedPropertyVector(Property value) { this(1); put(0, value); }
    public SharedPropertyVector(Property ... array) { this(array.length); put(array); }
    public SharedPropertyVector()       { allocate();  }
    public SharedPropertyVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef SharedPropertyVector put(@ByRef SharedPropertyVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index public native @SharedPtr Property get(@Cast("size_t") long i);
    public native SharedPropertyVector put(@Cast("size_t") long i, Property value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @SharedPtr Property get();
    }

    public Property pop_back() {
        long size = size();
        Property value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public SharedPropertyVector push_back(Property value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public SharedPropertyVector put(Property value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public SharedPropertyVector put(Property ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

// Parsed from property_identifications.h

/*
 * Copyright 2015 The Imaging Source Europe GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #ifndef TCAM_PROPERTY_IDENTIFICATIONS_H
// #define TCAM_PROPERTY_IDENTIFICATIONS_H

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_INVALID();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_EXPOSURE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_EXPOSURE_AUTO();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_EXPOSURE_AUTO_REFERENCE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_HIGHLIGHT_REDUCTION();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_AUTO_REFERENCE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_EXPOSURE_AUTO_UPPER_LIMIT_AUTO();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_EXPOSURE_AUTO_UPPER_LIMIT();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_EXPOSURE_AUTO_LOWER_LIMIT();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_GAIN();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_GAIN_RED();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_GAIN_GREEN();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_GAIN_BLUE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_GAIN_AUTO();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TRIGGER_MODE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TRIGGER_SOURCE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TRIGGER_ACTIVATION();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_SOFTWARETRIGGER();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TRIGGER_DENOISE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TRIGGER_MASK();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TRIGGER_DEBOUNCER();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TRIGGER_DELAY();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TRIGGER_SELECTOR();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TRIGGER_OPERATION();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TRIGGER_POLARITY();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TRIGGER_EXPOSURE_MODE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TRIGGER_BURST_COUNT();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TRIGGER_DEBOUNCE_TIME_US();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TRIGGER_MASK_TIME_US();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TRIGGER_NOISE_SURPRESSION_TIME_US();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_GPIO();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_GPIN();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_GPOUT();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_OFFSET_X();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_OFFSET_Y();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_OFFSET_AUTO();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_BRIGHTNESS();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_CONTRAST();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_SATURATION();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_HUE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_GAMMA();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_IRCUT();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_IRIS();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_IRIS_AUTO();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_FOCUS();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_FOCUS_AUTO();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_FOCUS_ONE_PUSH();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_ZOOM();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_STROBE_ENABLE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_STROBE_OPERATION();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_STROBE_POLARITY();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_STROBE_DELAY();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_STROBE_DURATION();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_STROBE_EXPOSURE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_STROBE_MODE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_STROBE_DURATION_SECOND();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_STROBE_EXPOSURE_SECOND();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_STROBE_DELAY_SECOND();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_REVERSE_X();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_REVERSE_Y();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_BLACKLEVEL();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_CHUNK_MODE_ACTIVE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_SHUTTER();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_HDR();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_OIS_MODE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_OIS_POS_X();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_OIS_POS_Y();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_WB();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_WB_AUTO();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_WB_RED();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_WB_GREEN();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_WB_BLUE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_WB_ONCE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_WB_MODE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_WB_PRESET();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_BALANCERATIO_SELECTOR();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_BALANCERATIO();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_BALANCE_WHITE_AUTO_PRESET();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_BALANCE_WHITE_TEMPERATURE_PRESET();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_WB_TEMPERATURE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_WB_AUTO_PRESET();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_GREEN_PATTERN_FIX();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TONEMAPPING();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TONEMAPPING_CONTRAST();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TONEMAPPING_INTENSITY();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TONEMAPPING_AUTO();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_SKIPPING();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_BINNING();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_BINNING_VERTICAL();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_BINNING_HORIZONTAL();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_SHARPNESS();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_STREAM_CHANNEL_COUNT();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_STREAM_CHANNEL_SELECTOR();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_STREAM_CHANNEL_TYPE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_STREAM_CHANNEL_LINK();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_STREAM_CHANNEL_ENDIANNESS();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_STREAM_CHANNEL_PACKET_SIZE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_EVENT_CHANNEL_COUNT();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_PAYLOAD_SIZE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_PAYLOAD_PER_FRAME();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_PAYLOAD_PER_PACKET();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_TOTAL_PACKET_SIZE();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_PACKETS_PER_FRAME();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_PACKET_TIME_US();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_FACE_DETECTION();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_NOISE_REDUCTION();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_IMAGE_STABILIZATION();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_CHUNK_IMX174_FRAME_ID();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_CHUNK_IMX174_FRAME_SET();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_IMX174_WDR_SHUTTER2();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_IMX174_HARDWARE_WDR_ENABLE();

@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_AUTO_FUNCTIONS_ROI_CONTROL();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_AUTO_FUNCTIONS_ROI_LEFT();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_AUTO_FUNCTIONS_ROI_TOP();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_AUTO_FUNCTIONS_ROI_WIDTH();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_AUTO_FUNCTIONS_ROI_HEIGHT();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_AUTO_FUNCTIONS_ROI_PRESET();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_GAIN_AUTO_UPPER_LIMIT();
@MemberGetter public static native @Cast("const TCAM_PROPERTY_ID") int TCAM_PROPERTY_GAIN_AUTO_LOWER_LIMIT();

// #endif /* TCAM_PROPERTY_IDENTIFICATIONS_H */


// Parsed from base_types.h

/*
 * Copyright 2014 The Imaging Source Europe GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #ifndef TCAM_BASE_TYPES_H
// #define TCAM_BASE_TYPES_H

/**
 * \addtogroup API
 * \{
*/

// #include <stdint.h>
// #include <stdbool.h>

// #include "property_identifications.h"
// #include "image_fourcc.h"

/**
* \name TCAM_PIPELINE_STATUS
* \brief overview over possible pipeline states
*/
/** enum TCAM_PIPELINE_STATUS */
public static final int
    TCAM_PIPELINE_UNDEFINED = 0,
    TCAM_PIPELINE_STOPPED = 1,
    TCAM_PIPELINE_PAUSED = 2,
    TCAM_PIPELINE_PLAYING = 3,
    TCAM_PIPELINE_ERROR = 4;


/**
 * Supported camera types
 */
/** enum TCAM_DEVICE_TYPE */
public static final int
    /** Unknown device type*/
    TCAM_DEVICE_TYPE_UNKNOWN = 0,
    /** device that uses the v4l2 API */
    TCAM_DEVICE_TYPE_V4L2 = 1,
    /** currently through aravis */
    TCAM_DEVICE_TYPE_ARAVIS = 2,
    /** libusb backends */
    TCAM_DEVICE_TYPE_LIBUSB = 3;


/**
 * \name tcam_device_info
 * Simple device description containing all information to uniquely identify a device
 */
public static class tcam_device_info extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public tcam_device_info() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public tcam_device_info(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public tcam_device_info(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public tcam_device_info position(long position) {
        return (tcam_device_info)super.position(position);
    }

    /** type of camera connection */
    public native @Cast("TCAM_DEVICE_TYPE") int type(); public native tcam_device_info type(int type);
    /** Camera name (e.g. DFK 23UP031) */
    public native @Cast("char") byte name(int i); public native tcam_device_info name(int i, byte name);
    @MemberGetter public native @Cast("char*") BytePointer name();
    /** identifier used for camera interaction (e.g. /dev/video0) */
    public native @Cast("char") byte identifier(int i); public native tcam_device_info identifier(int i, byte identifier);
    @MemberGetter public native @Cast("char*") BytePointer identifier();
    /** unique identifier */
    public native @Cast("char") byte serial_number(int i); public native tcam_device_info serial_number(int i, byte serial_number);
    @MemberGetter public native @Cast("char*") BytePointer serial_number();
    /** additional information for identification of camera model / must not be required by user*/
    public native @Cast("char") byte additional_identifier(int i); public native tcam_device_info additional_identifier(int i, byte additional_identifier);
    @MemberGetter public native @Cast("char*") BytePointer additional_identifier();
}


/**
 * \name device_lost_callback
 *
 */
public static class tcam_device_lost_callback extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    tcam_device_lost_callback(Pointer p) { super(p); }
    protected tcam_device_lost_callback() { allocate(); }
    private native void allocate();
    public native void call(@Const tcam_device_info info, Pointer user_data);
}


/**
 * \name tcam_image_size
 */
public static class tcam_image_size extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public tcam_image_size() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public tcam_image_size(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public tcam_image_size(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public tcam_image_size position(long position) {
        return (tcam_image_size)super.position(position);
    }

    public native @Cast("uint32_t") int width(); public native tcam_image_size width(int width);
    public native @Cast("uint32_t") int height(); public native tcam_image_size height(int height);
}


/** enum TCAM_RESOLUTION_TYPE */
public static final int
    TCAM_RESOLUTION_TYPE_RANGE = 0,
    TCAM_RESOLUTION_TYPE_FIXED = 1;


public static class tcam_resolution_description extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public tcam_resolution_description() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public tcam_resolution_description(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public tcam_resolution_description(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public tcam_resolution_description position(long position) {
        return (tcam_resolution_description)super.position(position);
    }

    public native @Cast("TCAM_RESOLUTION_TYPE") int type(); public native tcam_resolution_description type(int type);

    // these are identical if type is FIXED
    /** smallest available resolution */
    public native @ByRef tcam_image_size min_size(); public native tcam_resolution_description min_size(tcam_image_size min_size);
    /** biggest available resolution */
    public native @ByRef tcam_image_size max_size(); public native tcam_resolution_description max_size(tcam_image_size max_size);

    /** number of framerates this resolution supports */
    public native @Cast("uint32_t") int framerate_count(); public native tcam_resolution_description framerate_count(int framerate_count);
}


/**
 * \name tcam_video_format_description
 * \brief generic format description
 */
public static class tcam_video_format_description extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public tcam_video_format_description() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public tcam_video_format_description(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public tcam_video_format_description(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public tcam_video_format_description position(long position) {
        return (tcam_video_format_description)super.position(position);
    }

    /** pixel format that is used e.g. RGB32 or Y800 */
    public native @Cast("uint32_t") int fourcc(); public native tcam_video_format_description fourcc(int fourcc);
    public native @Cast("char") byte description(int i); public native tcam_video_format_description description(int i, byte description);
    @MemberGetter public native @Cast("char*") BytePointer description();
    public native @Cast("uint32_t") int binning(); public native tcam_video_format_description binning(int binning);
    public native @Cast("uint32_t") int skipping(); public native tcam_video_format_description skipping(int skipping);

    /** number of resolutions this format supports */
    public native @Cast("uint32_t") int resolution_count(); public native tcam_video_format_description resolution_count(int resolution_count);
}


/**
 * \name tcam_video_format
 * \brief description of a specific video format
 */
public static class tcam_video_format extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public tcam_video_format() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public tcam_video_format(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public tcam_video_format(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public tcam_video_format position(long position) {
        return (tcam_video_format)super.position(position);
    }

    /** pixel format that is used e.g. RGB32 or Y800 */
    public native @Cast("uint32_t") int fourcc(); public native tcam_video_format fourcc(int fourcc);
    public native @Cast("uint32_t") int binning(); public native tcam_video_format binning(int binning);
    public native @Cast("uint32_t") int skipping(); public native tcam_video_format skipping(int skipping);
    public native @Cast("uint32_t") int width(); public native tcam_video_format width(int width);
    public native @Cast("uint32_t") int height(); public native tcam_video_format height(int height);
    public native double framerate(); public native tcam_video_format framerate(double framerate);
}


/**
 * Statistic container for additional image_buffer descriptions
 */
public static class tcam_stream_statistics extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public tcam_stream_statistics() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public tcam_stream_statistics(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public tcam_stream_statistics(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public tcam_stream_statistics position(long position) {
        return (tcam_stream_statistics)super.position(position);
    }

    /** current frame number */
    public native @Cast("uint64_t") long frame_count(); public native tcam_stream_statistics frame_count(long frame_count);
    /** number of frames that where not delivered */
    public native @Cast("uint64_t") long frames_dropped(); public native tcam_stream_statistics frames_dropped(long frames_dropped);
    /** capture time reported by lib */
    public native @Cast("uint64_t") long capture_time_ns(); public native tcam_stream_statistics capture_time_ns(long capture_time_ns);
    /** capture time reported by camera; empty if not supported */
    public native @Cast("uint64_t") long camera_time_ns(); public native tcam_stream_statistics camera_time_ns(long camera_time_ns);
    /** in contrast to selected one */
    public native double framerate(); public native tcam_stream_statistics framerate(double framerate);
}

/**
 * \name tcam_image_buffer
 * \brief container for image transfer
 */
public static class tcam_image_buffer extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public tcam_image_buffer() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public tcam_image_buffer(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public tcam_image_buffer(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public tcam_image_buffer position(long position) {
        return (tcam_image_buffer)super.position(position);
    }

    /** pointer to actual image buffer */
    public native @Cast("unsigned char*") BytePointer pData(); public native tcam_image_buffer pData(BytePointer pData);
    /** size of image in bytes */
    public native @Cast("unsigned int") int length(); public native tcam_image_buffer length(int length);
    /** size of image buffer in bytes */
    public native @Cast("unsigned int") int size(); public native tcam_image_buffer size(int size);
    /** tcam_video_format the image buffer has */
    public native @ByRef tcam_video_format format(); public native tcam_image_buffer format(tcam_video_format format);
    /** length of single image line in bytes */
    public native @Cast("unsigned int") int pitch(); public native tcam_image_buffer pitch(int pitch);
    public native @ByRef tcam_stream_statistics statistics(); public native tcam_image_buffer statistics(tcam_stream_statistics statistics);

    public native @Cast("uint32_t") int lock_count(); public native tcam_image_buffer lock_count(int lock_count);

    public native Pointer user_data(); public native tcam_image_buffer user_data(Pointer user_data);
}


/**
 * \enum TCAM_PROPERTY_TYPE
 * Available property types
*/
/** enum TCAM_PROPERTY_TYPE */
public static final int
    TCAM_PROPERTY_TYPE_UNKNOWN      = 0,
    TCAM_PROPERTY_TYPE_BOOLEAN      = 1,
    TCAM_PROPERTY_TYPE_INTEGER      = 2,
    TCAM_PROPERTY_TYPE_DOUBLE       = 3,
    TCAM_PROPERTY_TYPE_STRING       = 4,
    TCAM_PROPERTY_TYPE_ENUMERATION  = 5,
    /** the button type is just a command
                                            to trigger some functionality
                                            which doesn't care about parameters
                                            because that is actually not necessary.
                                            For instance, "adjusting white balance"
                                            button in digital camera could
                                            be a good example which is performing
                                            adjustment of white balance for
                                            one time and no need for any kind of
                                            parameter for this but needs to
                                            be triggered. */
    TCAM_PROPERTY_TYPE_BUTTON       = 6;


public static class tcam_value_int extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public tcam_value_int() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public tcam_value_int(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public tcam_value_int(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public tcam_value_int position(long position) {
        return (tcam_value_int)super.position(position);
    }

    public native @Cast("int64_t") long min(); public native tcam_value_int min(long min);
    public native @Cast("int64_t") long max(); public native tcam_value_int max(long max);
    public native @Cast("int64_t") long step(); public native tcam_value_int step(long step);         /* 0 if steps not possible */
    public native @Cast("int64_t") long default_value(); public native tcam_value_int default_value(long default_value);
    public native @Cast("int64_t") long value(); public native tcam_value_int value(long value);
}


public static class tcam_value_double extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public tcam_value_double() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public tcam_value_double(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public tcam_value_double(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public tcam_value_double position(long position) {
        return (tcam_value_double)super.position(position);
    }

    public native double min(); public native tcam_value_double min(double min);
    public native double max(); public native tcam_value_double max(double max);
    public native double step(); public native tcam_value_double step(double step);         /* 0.0 if steps not possible */
    public native double default_value(); public native tcam_value_double default_value(double default_value);
    public native double value(); public native tcam_value_double value(double value);
}


public static class tcam_value_string extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public tcam_value_string() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public tcam_value_string(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public tcam_value_string(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public tcam_value_string position(long position) {
        return (tcam_value_string)super.position(position);
    }

    public native @Cast("char") byte value(int i); public native tcam_value_string value(int i, byte value);
    @MemberGetter public native @Cast("char*") BytePointer value();
    public native @Cast("char") byte default_value(int i); public native tcam_value_string default_value(int i, byte default_value);
    @MemberGetter public native @Cast("char*") BytePointer default_value();
}


public static class tcam_value_bool extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public tcam_value_bool() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public tcam_value_bool(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public tcam_value_bool(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public tcam_value_bool position(long position) {
        return (tcam_value_bool)super.position(position);
    }

    public native @Cast("bool") boolean value(); public native tcam_value_bool value(boolean value);
    public native @Cast("bool") boolean default_value(); public native tcam_value_bool default_value(boolean default_value);
}


/**
 * Categorization of properties works by
 * assigning every property a category and group.
 * A group is defined by the property id of the leading member
 * e.g. TCAM_PROPERTY_EXPOSURE_AUTO is a member of the group TCAM_PROPERTY_EXPOSURE.
 * The resulting tree structure allows for a
 */

/**
 * \enum TCAM_PROPERTY_CATEGORY
 * available property categories
 */
/** enum TCAM_PROPERTY_CATEGORY */
public static final int
    TCAM_PROPERTY_CATEGORY_UNKNOWN = 0,
    TCAM_PROPERTY_CATEGORY_EXPOSURE = 1,
    TCAM_PROPERTY_CATEGORY_COLOR = 2,
    TCAM_PROPERTY_CATEGORY_LENS = 3,
    TCAM_PROPERTY_CATEGORY_SPECIAL = 4,
    TCAM_PROPERTY_CATEGORY_PARTIAL_SCAN = 5,
    TCAM_PROPERTY_CATEGORY_IMAGE = 6,
    TCAM_PROPERTY_CATEGORY_AUTO_ROI = 7,
    TCAM_PROPERTY_CATEGORY_WDR = 8;


/**
 * \struct tcam_property_group
 * grouping description for properties
 */
public static class tcam_property_group extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public tcam_property_group() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public tcam_property_group(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public tcam_property_group(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public tcam_property_group position(long position) {
        return (tcam_property_group)super.position(position);
    }

    /** category of the property */
    public native @Cast("TCAM_PROPERTY_CATEGORY") int property_category(); public native tcam_property_group property_category(int property_category);
    /** group of the property
                                                          if property_group and tcam_device_property.id
                                                          are identical the property should be considered
                                                          the group master */
    public native @Cast("TCAM_PROPERTY_ID") int property_group(); public native tcam_property_group property_group(int property_group);
}


/**
 * \struct tcam_device_property
 * \brief unified property description
 */
public static class tcam_device_property extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public tcam_device_property() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public tcam_device_property(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public tcam_device_property(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public tcam_device_property position(long position) {
        return (tcam_device_property)super.position(position);
    }

    /** unique identifier */
    public native @Cast("TCAM_PROPERTY_ID") int id(); public native tcam_device_property id(int id);
    /** string identifier */
    public native @Cast("char") byte name(int i); public native tcam_device_property name(int i, byte name);
    @MemberGetter public native @Cast("char*") BytePointer name();

    /** grouping; if you simply want to
                                              iterate properties you can ignore this */
    public native @ByRef tcam_property_group group(); public native tcam_device_property group(tcam_property_group group);

    /** type the property has */
    public native @Cast("TCAM_PROPERTY_TYPE") int type(); public native tcam_device_property type(int type);
        @Name("value.i") public native @ByRef tcam_value_int value_i(); public native tcam_device_property value_i(tcam_value_int value_i);
        @Name("value.d") public native @ByRef tcam_value_double value_d(); public native tcam_device_property value_d(tcam_value_double value_d);
        @Name("value.s") public native @ByRef tcam_value_string value_s(); public native tcam_device_property value_s(tcam_value_string value_s);
        @Name("value.b") public native @ByRef tcam_value_bool value_b(); public native tcam_device_property value_b(tcam_value_bool value_b);

    /** bit flags */
    public native @Cast("uint32_t") int flags(); public native tcam_device_property flags(int flags);
}


/**
 * used property flags
 */
/** enum TCAM_PROPERTY_FLAGS */
public static final int
    /** This control is permanently disabled and
                                                should be ignored by the application. Any
                                                attempt to change the control will
                                                result in an EINVAL error code. */
    TCAM_PROPERTY_FLAG_DISABLED =  0x0001,

    /** This control is temporarily unchangeable,
                                                for example because another application
                                                took over control of the respective
                                                resource. Such controls may be displayed
                                                specially in a user interface. Attempts to
                                                change the control may result in an EBUSY error code. */
    TCAM_PROPERTY_FLAG_GRABBED =  0x0002,

    /** This control is permanently readable only.
                                                Any attempt to change the control will result
                                                in an EINVAL error code. */
    TCAM_PROPERTY_FLAG_READ_ONLY =  0x0004,

    /** This control is realized through library
                                                 code and is not available in the camera */
    TCAM_PROPERTY_FLAG_EXTERNAL =  0x0008,

    /** This control is not applicable to the
                                                current configuration and should be displayed
                                                accordingly in a user interface. For example
                                                the flag may be set on a MPEG audio level 2
                                                bitrate control when MPEG audio encoding
                                                level 1 was selected with another control. */
    TCAM_PROPERTY_FLAG_INACTIVE =  0x0010,

    /** This control is permanently writable only.
                                                Any attempt to read the control will result
                                                in an EACCES error code error code. This flag
                                                is typically present for relative controls
                                                or action controls where writing a value will
                                                cause the device to carry out a given action
                                                (e. g. motor control) but no meaningful
                                                value can be returned. */
    TCAM_PROPERTY_FLAG_WRITE_ONLY =  0x0020;

/** \} */

// #endif /* TCAM_BASE_TYPES_H */


// Parsed from public_utils.h

/*
 * Copyright 2014 The Imaging Source Europe GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #ifndef TCAM_PUBLIC_UTILS_H
// #define TCAM_PUBLIC_UTILS_H

// #include <stdint.h>

// #include <stddef.h> /* size_t */

// #include "base_types.h"
// #include <vector>
// #include <string>

@Namespace("tcam") public static native @Cast("const char*") BytePointer fourcc_to_description(@Cast("uint32_t") int fourcc);


@Namespace("tcam") public static native @Cast("uint32_t") int description_to_fourcc(@Cast("const char*") BytePointer description);
@Namespace("tcam") public static native @Cast("uint32_t") int description_to_fourcc(String description);


@Namespace("tcam") public static native @StdString BytePointer category2string(@Cast("TCAM_PROPERTY_CATEGORY") int arg0);

@Namespace("tcam") public static native @StdString BytePointer property_id_to_string(@Cast("TCAM_PROPERTY_ID") int arg0);

@Namespace("tcam") public static native @StdString BytePointer property_type_to_string(@Cast("TCAM_PROPERTY_TYPE") int arg0);

@Namespace("tcam") public static native @Cast("uint64_t") long get_image_size(@Cast("uint32_t") int fourcc,
                         @Cast("unsigned int") int width,
                         @Cast("unsigned int") int height);

/**
 * @param format - format description that shall be used
 * @param n_buffers - number of buffers that shall be allocated
 * @return pointer to the first image buffer
 */
@Namespace("tcam") public static native tcam_image_buffer allocate_image_buffers(@Const tcam_video_format format,
                                                  @Cast("size_t") long n_buffers);

/**
 * @param ptr - pointer to the first buffer that shall be freed
 * @param n_buffers - number of buffers that shall be freed
 */
@Namespace("tcam") public static native void free_image_buffers(tcam_image_buffer ptr, @Cast("size_t") long n_buffer);


/**
 * Check if buffer has correct length
 * @param buffer that shall be checked
 * @return true if buffer has correct length or is large enough for the image
 */
@Namespace("tcam") public static native @Cast("bool") boolean is_image_buffer_complete(@Const tcam_image_buffer buffer);

/**
 *
 */
@Namespace("tcam") public static native @StdVector tcam_image_size get_standard_resolutions(@Const @ByRef tcam_image_size min,
                                                              @Const @ByRef tcam_image_size max);

 /* namespace tcam */

// #endif /* TCAM_PUBLIC_UTILS_H */


// Parsed from PropertyImpl.h

/*
 * Copyright 2014 The Imaging Source Europe GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #ifndef TCAM_PROPERTYIMPL_H
// #define TCAM_PROPERTYIMPL_H

/**
 * Interface used by property implementations
 */
@Namespace("tcam") public static class PropertyImpl extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PropertyImpl(Pointer p) { super(p); }


    /**
     * Set internal properties to the values described in parameter
     * @return true is given property values where successfully applied; else false
     */
    public native @Cast("bool") boolean set_property(@Const @ByRef Property arg0);

    /**
     * Fill given property with the currently used values
     * @return true if property was successfully filled; else false
     */
    public native @Cast("bool") boolean get_property(@ByRef Property arg0);
}

 /* namespace tcam */

// #endif /* TCAM_PROPERTYIMPL_H */


// Parsed from Property.h

/*
 * Copyright 2014 The Imaging Source Europe GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #ifndef TCAM_PROPERTY_H
// #define TCAM_PROPERTY_H


// #include "base_types.h"
// #include "PropertyImpl.h"

// #include <memory>
// #include <string>
// #include <vector>
// #include <map>

@Namespace("tcam") @NoOffset public static class Property extends PropertyImpl {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Property(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Property(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Property position(long position) {
        return (Property)super.position(position);
    }

    /** enum tcam::Property::VALUE_TYPE */
    public static final int
        UNDEFINED = 0,
        BOOLEAN = 1,
        STRING = 2,
        ENUM = 3,
        INTEGER = 4,
        INTSWISSKNIFE = 5,
        FLOAT = 6,
        COMMAND = 7,
        BUTTON = 8;

    public Property() { super((Pointer)null); allocate(); }
    private native void allocate();

    public Property(@Const @ByRef tcam_device_property arg0, @Cast("tcam::Property::VALUE_TYPE") int arg1) { super((Pointer)null); allocate(arg0, arg1); }
    private native void allocate(@Const @ByRef tcam_device_property arg0, @Cast("tcam::Property::VALUE_TYPE") int arg1);

    public Property(@Const @ByRef tcam_device_property arg0,
                  @Const @ByRef StringIntMap arg1,
                  @Cast("tcam::Property::VALUE_TYPE") int arg2) { super((Pointer)null); allocate(arg0, arg1, arg2); }
    private native void allocate(@Const @ByRef tcam_device_property arg0,
                  @Const @ByRef StringIntMap arg1,
                  @Cast("tcam::Property::VALUE_TYPE") int arg2);

    public native @ByRef @Name("operator =") Property put(@Const @ByRef Property arg0);

    public native void reset();

    /**
     * \brief update the property so that it will hold up to date information
     * @return true on success
     */
    public native @Cast("bool") boolean update();

    /**
     * @return TCAM_PROPERTY_ID of the property
     */
    public native @Cast("TCAM_PROPERTY_ID") int get_ID();

    /**
     *
     */
    public native @StdString BytePointer get_name();

    /**
     *
     */
    public native @Cast("TCAM_PROPERTY_TYPE") int get_type();


    /**
     * Convenience check for read-only and disabled
     */
    public native @Cast("bool") boolean can_be_changed();

    /**
     * @return true if property can not be written
     */
    public native @Cast("bool") boolean is_read_only();

    /**
     * @return true if property can not be read
     */
    public native @Cast("bool") boolean is_write_only();

    /**
     *
     */
    public native @Cast("bool") boolean is_disabled();


    public native @Cast("bool") boolean is_external();

    /**
     *
     */
    public native @Cast("uint32_t") int get_flags();


    public native @ByVal tcam_device_property get_struct();

    public native @Cast("bool") boolean set_value(@Const @ByRef tcam_device_property arg0);

    public native @Cast("bool") boolean set_value(@Cast("const int64_t") long value, @Cast("bool") boolean notify_impl/*=true*/);
    public native @Cast("bool") boolean set_value(@Cast("const int64_t") long value);
    public native @Cast("bool") boolean set_value(double value, @Cast("bool") boolean notify_impl/*=true*/);
    public native @Cast("bool") boolean set_value(double value);
    public native @Cast("bool") boolean set_value(@Cast("const bool") boolean value, @Cast("bool") boolean notify_impl/*=true*/);
    public native @Cast("bool") boolean set_value(@Cast("const bool") boolean value);
    public native @Cast("bool") boolean set_value(@StdString BytePointer value, @Cast("bool") boolean notify_impl/*=true*/);
    public native @Cast("bool") boolean set_value(@StdString BytePointer value);
    public native @Cast("bool") boolean set_value(@StdString String value, @Cast("bool") boolean notify_impl/*=true*/);
    public native @Cast("bool") boolean set_value(@StdString String value);
    public native @Cast("bool") boolean set_value();

    public native @Cast("bool") boolean set_flags(); // ??????




    public native @Cast("bool") boolean set_struct(@Const @ByRef tcam_device_property arg0);

    /**
     * Set value from given tcam_device_property
     * @return true on success
     */
    public native void set_struct_value(@Const @ByRef tcam_device_property arg0);
    public native void get_struct_value(@ByRef tcam_device_property p);
    public native @Cast("tcam::Property::VALUE_TYPE") int get_value_type();


    public native @StdString BytePointer to_string();

    public native @Cast("bool") boolean from_string(@StdString BytePointer arg0);
    public native @Cast("bool") boolean from_string(@StdString String arg0);


    public native @Cast("bool") boolean set_property(@Const @ByRef Property arg0);
    public native @Cast("bool") boolean set_property_from_struct(@Const @ByRef tcam_device_property arg0);
    public native @Cast("bool") boolean get_property(@ByRef Property arg0);
    public native @Cast("bool") boolean get_property_from_struct(@ByRef tcam_device_property arg0);
}

@Namespace("tcam") public static native @Cast("TCAM_PROPERTY_TYPE") int value_type_to_ctrl_type(@Cast("const tcam::Property::VALUE_TYPE") int t);

 /* namespace tcam */

// #endif /* TCAM_PROPERTY_H */


// Parsed from DeviceInfo.h

/*
 * Copyright 2014 The Imaging Source Europe GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #ifndef TCAM_DEVICEINFO_H
// #define TCAM_DEVICEINFO_H

// #include "base_types.h"

// #include <vector>
// #include <memory>

/**
 * \addtogroup API
 * \{
 */

/**
 * \class DeviceInfo
 * Contains a unique device description
 */
@Namespace("tcam") @NoOffset public static class DeviceInfo extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DeviceInfo(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public DeviceInfo(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public DeviceInfo position(long position) {
        return (DeviceInfo)super.position(position);
    }



    public DeviceInfo(@Const @ByRef tcam_device_info arg0) { super((Pointer)null); allocate(arg0); }
    private native void allocate(@Const @ByRef tcam_device_info arg0);

    /**
     * \brief Creates an invalid device
     */
    public DeviceInfo() { super((Pointer)null); allocate(); }
    private native void allocate();

    public native @ByRef @Name("operator =") DeviceInfo put(@Const @ByRef DeviceInfo arg0);

    /**
     * \name get_info
     * \brief returns a struct version of the device description
     * @return struct tcam_device_info
     */
    public native @ByVal tcam_device_info get_info();

    /**
     * Description for get_name.
     * @return string containing the device model
     */
    public native @StdString BytePointer get_name();

    /**
     * @return string containing the serial number of the device
     */
    public native @StdString BytePointer get_serial();

    /**
     * returns identifier used for communication
     * with underlying system (e.g. /dev/video0)
     * @return string containing the identifier
     */
    public native @StdString BytePointer get_identifier();

    /**
     * @return TCAM_DEVICE_TYPE of the device
     */
    public native @Cast("TCAM_DEVICE_TYPE") int get_device_type();

    /**
     * \brief returns \TCAM_DEVICE_TYPE string representation
     * @return std::string
     */
    public native @StdString BytePointer get_device_type_as_string();

} /* class DeviceInfo */

 /* namespace tcam */

/** \} */

// #endif /* TCAM_DEVICEINFO_H */


// Parsed from BackendLoader.h

/*
 * Copyright 2014 The Imaging Source Europe GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #ifndef TCAM_BACKEND_LOADER_H
// #define TCAM_BACKEND_LOADER_H


// #include <vector>
// #include <string>
// #include <memory>
// #include <functional>

// #include "base_types.h"

// #include "DeviceInterface.h"

@Namespace("tcam") @NoOffset public static class BackendLoader extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public BackendLoader(Pointer p) { super(p); }


    public static native @ByRef BackendLoader getInstance();

    public native @SharedPtr DeviceInterface open_device(@Const @ByRef DeviceInfo arg0);

    public native @StdVector DeviceInfo get_device_list_all_backends();

    public native @StdVector DeviceInfo get_device_list(@Cast("TCAM_DEVICE_TYPE") int arg0);

} /* class BackendLoader*/


 /* namespace tcam */

// #endif /* TCAM_BACKEND_LOADER_H */



// Parsed from VideoFormat.h

/*
 * Copyright 2014 The Imaging Source Europe GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #ifndef TCAM_VIDEOFORMAT_H
// #define TCAM_VIDEOFORMAT_H

// #include "base_types.h"

// #include <string>

/**
 * \class VideoFormat
 * Description of a specific format
 */
@Namespace("tcam") @NoOffset public static class VideoFormat extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VideoFormat(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public VideoFormat(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public VideoFormat position(long position) {
        return (VideoFormat)super.position(position);
    }


    public VideoFormat() { super((Pointer)null); allocate(); }
    private native void allocate();

    public VideoFormat(@Const @ByRef tcam_video_format arg0) { super((Pointer)null); allocate(arg0); }
    private native void allocate(@Const @ByRef tcam_video_format arg0);

    public VideoFormat(@Const @ByRef VideoFormat arg0) { super((Pointer)null); allocate(arg0); }
    private native void allocate(@Const @ByRef VideoFormat arg0);

    public native @ByRef @Name("operator =") VideoFormat put(@Const @ByRef VideoFormat arg0);

    public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef VideoFormat arg0);

    public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef VideoFormat other);


    /**
     * Returns a struct representation of the format
     * @return tcam_video_format
     */
    public native @ByVal tcam_video_format get_struct();

    /**
     * Returns the used pixel format
     * @return uint32 containing the fourcc
     */
    public native @Cast("uint32_t") int get_fourcc();

    public native void set_fourcc(@Cast("uint32_t") int arg0);

    /**
     * @return framerate in frames/second
     */
    public native double get_framerate();

    public native void set_framerate(double arg0);

    public native @ByVal tcam_image_size get_size();

    public native void set_size(@Cast("unsigned int") int width, @Cast("unsigned int") int height);

    public native @StdString BytePointer to_string();

    public native @Cast("bool") boolean from_string(@StdString BytePointer arg0);
    public native @Cast("bool") boolean from_string(@StdString String arg0);

    /**
     * Description for getRequiredBufferSize.
     * @return size in bytes an image with this format will have
     */
    public native @Cast("uint64_t") long get_required_buffer_size();

    /**
     * Description for getPitchSize.
     * @return the size og an image line
     */
    public native @Cast("uint32_t") int get_pitch_size();

}


 /*namespace tcam */

// #endif /* TCAM_VIDEOFORMAT_H */


// Parsed from VideoFormatDescription.h

/*
 * Copyright 2014 The Imaging Source Europe GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #ifndef TCAM_VIDEOFORMATDESCRIPTION_H
// #define TCAM_VIDEOFORMATDESCRIPTION_H

// #include "base_types.h"

// #include "VideoFormat.h"

// #include <vector>
// #include <memory>

// forward declarations

@Namespace("tcam") public static class framerate_mapping extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public framerate_mapping() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public framerate_mapping(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public framerate_mapping(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public framerate_mapping position(long position) {
        return (framerate_mapping)super.position(position);
    }

    public native @ByRef tcam_resolution_description resolution(); public native framerate_mapping resolution(tcam_resolution_description resolution);

    public native @StdVector DoublePointer framerates(); public native framerate_mapping framerates(DoublePointer framerates);
}


@Namespace("tcam") @NoOffset public static class VideoFormatDescription extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VideoFormatDescription(Pointer p) { super(p); }


    

    public VideoFormatDescription(@SharedPtr FormatHandlerInterface handler,
                                @Const @ByRef tcam_video_format_description arg1,
                                @StdVector framerate_mapping arg2) { super((Pointer)null); allocate(handler, arg1, arg2); }
    private native void allocate(@SharedPtr FormatHandlerInterface handler,
                                @Const @ByRef tcam_video_format_description arg1,
                                @StdVector framerate_mapping arg2);

    public VideoFormatDescription(@Const @ByRef VideoFormatDescription arg0) { super((Pointer)null); allocate(arg0); }
    private native void allocate(@Const @ByRef VideoFormatDescription arg0);


    public VideoFormatDescription(@Const @ByRef tcam_video_format_description arg0) { super((Pointer)null); allocate(arg0); }
    private native void allocate(@Const @ByRef tcam_video_format_description arg0);


    public native @ByRef @Name("operator =") VideoFormatDescription put(@Const @ByRef VideoFormatDescription arg0);

    public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef VideoFormatDescription other);
    public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef VideoFormatDescription other);

    public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef tcam_video_format_description other);
    public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef tcam_video_format_description other);

    /**
     * Returns a struct representation of the format description
     * @return tcam_video_format_description
     */
    public native @ByVal tcam_video_format_description get_struct();

    /**
     * Returns the pixel format used
     * @return uint32 containging the fourcc
     */
    public native @Cast("uint32_t") int get_fourcc();

    /**
     * Returns the binning used
     * @return uint32 containging the fourcc
     */
    public native @Cast("uint32_t") int get_binning();

    /**
     * Returns the skipping used
     */
    public native @Cast("uint32_t") int get_skipping();


    public native @StdVector tcam_resolution_description get_resolutions();

    public native @StdVector DoublePointer get_frame_rates(@Const @ByRef tcam_resolution_description size);

    public native @StdVector DoublePointer get_framerates(@Const @ByRef tcam_image_size s);


    public native @ByVal VideoFormat create_video_format(@Cast("unsigned int") int width,
                                         @Cast("unsigned int") int height,
                                         double framerate);

}

 /* namespace tcam */

// #endif /* TCAM_VIDEOFORMATDESCRIPTION_H */


// Parsed from MemoryBuffer.h

/*
 * Copyright 2014 The Imaging Source Europe GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #ifndef TCAM_MEMORYBUFFER_H
// #define TCAM_MEMORYBUFFER_H

// #include "base_types.h"

// #include "VideoFormat.h"

/**
 * \addtogroup API
 * \{
 */

@Namespace("tcam") @NoOffset public static class MemoryBuffer extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MemoryBuffer(Pointer p) { super(p); }


    // will not take ownership of memory given in tcam_image_buffer
    public MemoryBuffer(@Const @ByRef tcam_image_buffer arg0, @Cast("bool") boolean owns_memory/*=false*/) { super((Pointer)null); allocate(arg0, owns_memory); }
    private native void allocate(@Const @ByRef tcam_image_buffer arg0, @Cast("bool") boolean owns_memory/*=false*/);
    public MemoryBuffer(@Const @ByRef tcam_image_buffer arg0) { super((Pointer)null); allocate(arg0); }
    private native void allocate(@Const @ByRef tcam_image_buffer arg0);

    // will allocate buffer memory
    public MemoryBuffer(@Const @ByRef VideoFormat arg0, @Cast("bool") boolean owns_memory/*=false*/) { super((Pointer)null); allocate(arg0, owns_memory); }
    private native void allocate(@Const @ByRef VideoFormat arg0, @Cast("bool") boolean owns_memory/*=false*/);
    public MemoryBuffer(@Const @ByRef VideoFormat arg0) { super((Pointer)null); allocate(arg0); }
    private native void allocate(@Const @ByRef VideoFormat arg0);

    

    /**
     *
     */
    public native @ByVal tcam_image_buffer getImageBuffer();

    public native void set_image_buffer(@ByVal tcam_image_buffer arg0);

    /**
     * @return Pointer to actual image data
     */
    public native @Cast("unsigned char*") BytePointer get_data();

    public native @Cast("size_t") long get_buffer_size();
    public native @Cast("size_t") long get_image_size();


    public native @ByVal tcam_stream_statistics get_statistics();

    public native @Cast("bool") boolean set_statistics(@Const @ByRef tcam_stream_statistics arg0);

    public native @Cast("bool") boolean set_data(@Cast("const unsigned char*") BytePointer data, @Cast("size_t") long size, @Cast("unsigned int") int offset/*=0*/);
    public native @Cast("bool") boolean set_data(@Cast("const unsigned char*") BytePointer data, @Cast("size_t") long size);
    public native @Cast("bool") boolean set_data(@Cast("const unsigned char*") ByteBuffer data, @Cast("size_t") long size, @Cast("unsigned int") int offset/*=0*/);
    public native @Cast("bool") boolean set_data(@Cast("const unsigned char*") ByteBuffer data, @Cast("size_t") long size);
    public native @Cast("bool") boolean set_data(@Cast("const unsigned char*") byte[] data, @Cast("size_t") long size, @Cast("unsigned int") int offset/*=0*/);
    public native @Cast("bool") boolean set_data(@Cast("const unsigned char*") byte[] data, @Cast("size_t") long size);

    public native @Cast("bool") boolean lock();

    public native @Cast("bool") boolean unlock();

    public native @Cast("bool") boolean is_locked();

    public native @Cast("bool") boolean is_complete();

    public native void set_user_data(Pointer data);

    public native Pointer get_user_data();

    /**
     * \brief Fills MemoryBuffer with 0
     */
    public native void clear();

}


 /* namespace tcam*/

/** \} */

// #endif /* TCAM_MEMORYBUFFER_H */


// Parsed from SinkInterface.h

/*
 * Copyright 2014 The Imaging Source Europe GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #ifndef TCAM_SINKINTERFACE_H
// #define TCAM_SINKINTERFACE_H

// #include "MemoryBuffer.h"

// #include "VideoFormat.h"

// #include <memory>
// #include <vector>

@Namespace("tcam") public static class SinkInterface extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SinkInterface(Pointer p) { super(p); }


    public native @Cast("bool") boolean set_status(@Cast("TCAM_PIPELINE_STATUS") int arg0);

    public native @Cast("TCAM_PIPELINE_STATUS") int get_status();

    public native @Cast("bool") boolean setVideoFormat(@Const @ByRef VideoFormat arg0);

    public native @ByVal VideoFormat getVideoFormat();

    public native void push_image(@SharedPtr @ByVal MemoryBuffer arg0);

    public native void requeue_buffer(@SharedPtr @ByVal MemoryBuffer arg0);


    

}

 /* namespace tcam */

// #endif /* TCAM_SINKINTERFACE_H */


// Parsed from DeviceInterface.h

/*
 * Copyright 2014 The Imaging Source Europe GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #ifndef TCAM_CAPTUREINTERFACE_H
// #define TCAM_CAPTUREINTERFACE_H

// #include "DeviceInfo.h"
// #include "Properties.h"
// #include "PropertyImpl.h"

// #include "VideoFormat.h"
// #include "VideoFormatDescription.h"

// #include "MemoryBuffer.h"
// #include "SinkInterface.h"

// #include <vector>
// #include <memory>

// #include "compiler_defines.h"

@Namespace("tcam") @NoOffset public static class DeviceInterface extends PropertyImpl {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DeviceInterface(Pointer p) { super(p); }


    /**
     * @return the DeviceInfo describing the device
     */
    public native @ByVal DeviceInfo get_device_description();

    /**
     * \brief Returns all device properties
     */
    public native @ByVal SharedPropertyVector getProperties();

    public native @Cast("bool") boolean set_property(@Const @ByRef Property arg0);

    public native @Cast("bool") boolean get_property(@ByRef Property arg0);

    /**
     * \brief Set Format in he actual device
     * @return True on success; False on error or invalid format
     */
    public native @Cast("bool") boolean set_video_format(@Const @ByRef VideoFormat arg0);

    /**
     * @return The current VideoFormat that is set in the device
     */
    public native @ByVal VideoFormat get_active_video_format();

    /**
     * Retrieve all formats the device supports
     * @return vector containing all supported formats; empty on error
     */
    public native @StdVector VideoFormatDescription get_available_video_formats();

    /**
     * Set the ImageSource to which new images shall be delivered
     * This overwrites previously defined Sinks
     * @return true on successful registration; else false
     */
    public native @Cast("bool") boolean set_sink(@SharedPtr SinkInterface arg0);

    /**
     * @return true on successfull allocation/registration; else false
     */
    public native @Cast("bool") boolean initialize_buffers(@ByVal SharedMemoryBufferVector arg0);

    /**
     * \brief Delete all internal references to used memorybuffers
     */
    public native @Cast("bool") boolean release_buffers();

    public native void requeue_buffer(@SharedPtr @ByPtr MemoryBuffer arg0);
    public native void requeue_buffer_ptr(@ByPtr MemoryBuffer arg0);

    /**
     * Start image retrieval and wait for new images
     * A SinkInterface has to be given via \set_sink
     * @return true on success; else false
     */
    public native @Cast("bool") boolean start_stream();

    /**
     * Stop image retrieval
     * @return true on success; else false
     */
    public native @Cast("bool") boolean stop_stream();

    public native @Cast("bool") boolean register_device_lost_callback(tcam_device_lost_callback callback, Pointer user_data);

} /* class Camera_Interface */


/**
 * \brief open the device for the given DeviceInfo
 * @param device - device description for which an interface shall be created
 * @return shared_ptr containing the device; nullptr on error
 */
@Namespace("tcam") public static native @SharedPtr DeviceInterface openDeviceInterface(@Const @ByRef DeviceInfo device);

 /* namespace tcam */

// #endif /* TCAM_CAPTUREINTERFACE_H */



// Parsed from DeviceInterface.cpp

/*
 * Copyright 2014 The Imaging Source Europe GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #include "DeviceInterface.h"
// #include "logging.h"

// #include "BackendLoader.h"

// #include <algorithm>
// #include <memory>





// Parsed from BackendLoader.cpp

/*
 * Copyright 2014 The Imaging Source Europe GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #include "BackendLoader.h"

// #include <dlfcn.h>

// #include <string>

// #include "internal.h"
// #include "devicelibrary.h"




























// Parsed from CaptureDevice.h

/*
 * Copyright 2014 The Imaging Source Europe GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #ifndef TCAM_CAPTUREDEVICE_H
// #define TCAM_CAPTUREDEVICE_H

// #include "DeviceIndex.h"
// #include "DeviceInfo.h"
// #include "Properties.h"
// #include "VideoFormat.h"
// #include "SinkInterface.h"
// #include "VideoFormatDescription.h"
// #include "standard_properties.h"

// #include <string>
// #include <vector>
// #include <memory>

/**
 * \addtogroup API
 * \{
 */

@Namespace("tcam") @Opaque public static class CaptureDeviceImpl extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public CaptureDeviceImpl() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CaptureDeviceImpl(Pointer p) { super(p); }
}

@Namespace("tcam") @NoOffset public static class CaptureDevice extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CaptureDevice(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public CaptureDevice(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public CaptureDevice position(long position) {
        return (CaptureDevice)super.position(position);
    }


    public CaptureDevice() { super((Pointer)null); allocate(); }
    private native void allocate();
    public CaptureDevice(@Const @ByRef DeviceInfo arg0) { super((Pointer)null); allocate(arg0); }
    private native void allocate(@Const @ByRef DeviceInfo arg0);

    

    

    /**
     * \brief Load xml configuration and apply it to device
     * @param filename - string containing the filename of the xml description
     * @return true on success; on error Error will be set
     */
    public native @Cast("bool") boolean load_configuration(@StdString BytePointer filename);
    public native @Cast("bool") boolean load_configuration(@StdString String filename);


    /**
     * \brief Store current device configuration in xml
     * @param filename - string containing the filename under which the xml shall be saved
     * @return true on success; on error Error will be set
     */
    public native @Cast("bool") boolean save_configuration(@StdString BytePointer filename);
    public native @Cast("bool") boolean save_configuration(@StdString String filename);

    // device related:

    /**
     * Check if device is currently open
     * @return true if a device is open
     */
    public native @Cast("bool") boolean is_device_open();

    /**
     * Return description of current device
     * @return description of the currently open device. empty if no device is open
     */
    public native @ByVal DeviceInfo get_device();


    public native @Cast("bool") boolean register_device_lost_callback(tcam_device_lost_callback callback, Pointer user_data);


    // property related:

    /**
     * @return vector containing all available properties
     */
    public native @ByVal PropertyVector get_available_properties();


    public native Property get_property(@Cast("TCAM_PROPERTY_ID") int id);
    public native Property get_property_by_name(@StdString BytePointer name);
    public native Property get_property_by_name(@StdString String name);


    /**
     *
     */


    public native @Cast("bool") boolean set_property(@Cast("TCAM_PROPERTY_ID") int arg0, @Cast("const int64_t") long value);
    public native @Cast("bool") boolean set_property(@Cast("TCAM_PROPERTY_ID") int arg0, double value);
    public native @Cast("bool") boolean set_property(@Cast("TCAM_PROPERTY_ID") int arg0, @Cast("const bool") boolean value);
    public native @Cast("bool") boolean set_property(@Cast("TCAM_PROPERTY_ID") int arg0, @StdString BytePointer value);
    public native @Cast("bool") boolean set_property(@Cast("TCAM_PROPERTY_ID") int arg0, @StdString String value);

    // videoformat related:


    /**
     * @return vector containing all available video format settings
     */
    public native @StdVector VideoFormatDescription get_available_video_formats();


    /**
     * Description for set_video_format.
     * @param new_format - format the device shall use
     * @return true if device accepted the given VideoFormat
     */
    public native @Cast("bool") boolean set_video_format(@Const @ByRef VideoFormat new_format);


    /**
     * @return Currently used video format
     */
    public native @ByVal VideoFormat get_active_video_format();

    // playback related:

    /**
     * \brief Start a new stream
     * @param sink - SinkInterface that shall be called for new images
     * @return true if stream could successfully be initialized
     */
    public native @Cast("bool") boolean start_stream(@SharedPtr SinkInterface sink);


    /**
     * \brief Stop currently running stream
     * @return true if stream could successfully be stopped
     */
    public native @Cast("bool") boolean stop_stream();

} /* class CaptureDevice */

@Namespace("tcam") public static native @SharedPtr CaptureDevice open_device(@StdString BytePointer serial);
@Namespace("tcam") public static native @SharedPtr CaptureDevice open_device(@StdString String serial);

 /* namespace tcam */

/** \} */

// #endif /* TCAM_CAPTUREDEVICE_H */


// Parsed from ImageSink.h

/*
 * Copyright 2014 The Imaging Source Europe GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #ifndef TCAM_IMAGESINK_H
// #define TCAM_IMAGESINK_H

// #include "base_types.h"
// #include "SinkInterface.h"

// #include <memory>
// #include <vector>

/**
 * \addtogroup API
 * \{
 * Main header
 */

@Namespace("tcam") @NoOffset public static class ImageSink extends SinkInterface {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ImageSink(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ImageSink(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ImageSink position(long position) {
        return (ImageSink)super.position(position);
    }


    public ImageSink() { super((Pointer)null); allocate(); }
    private native void allocate();

    public native @Cast("bool") boolean set_status(@Cast("TCAM_PIPELINE_STATUS") int arg0);
    public native @Cast("TCAM_PIPELINE_STATUS") int get_status();

    public native @Cast("bool") boolean setVideoFormat(@Const @ByRef VideoFormat arg0);

    public native @ByVal VideoFormat getVideoFormat();

    
    public native @Cast("bool") boolean registerCallback(@Cast("sink_callback") sink_callback arg0, Pointer arg1);
    

    public native void push_image(@SharedPtr @ByVal MemoryBuffer arg0);

    public native void requeue_buffer(@SharedPtr @ByVal MemoryBuffer arg0);

    public native @Cast("bool") boolean set_buffer_number(@Cast("size_t") long arg0);

    

    

    public native @Cast("bool") boolean delete_buffer_collection();

    /**
     * used to set the pipelinemanager instance that is called
     * for things like requeue_buffer
     */
    

}

 /* namespace tcam */

/** \} */

// #endif /* TCAM_IMAGESINK_H */


// Parsed from FormatHandlerInterface.h

/*
 * Copyright 2016 The Imaging Source Europe GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #ifndef TCAM_FORMATHANDLERINTERFACE_H
// #define TCAM_FORMATHANDLERINTERFACE_H

// #include "compiler_defines.h"
// #include "base_types.h"

// #include <vector>

@Namespace("tcam") public static class FormatHandlerInterface extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FormatHandlerInterface(Pointer p) { super(p); }


    public native @StdVector DoublePointer get_framerates(@Const @ByRef tcam_image_size arg0, int pixelformat/*=0*/);
    public native @StdVector DoublePointer get_framerates(@Const @ByRef tcam_image_size arg0);
}

 /* namespace tcam */

// #endif /* TCAM_FORMATHANDLERINTERFACE_H */



}
