// Targeted by JavaCPP version 1.5.13-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.onnxruntime;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.opencl.*;
import static org.bytedeco.opencl.global.OpenCL.*;
import org.bytedeco.dnnl.*;
import static org.bytedeco.dnnl.global.dnnl.*;

import static org.bytedeco.onnxruntime.global.onnxruntime.*;


/** <summary>
 *  Provide access to per-node attributes and input shapes, so one could compute and set output shapes.
 *  </summary> */
@Namespace("Ort") @NoOffset @Properties(inherit = org.bytedeco.onnxruntime.presets.onnxruntime.class)
public class ShapeInferContext extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ShapeInferContext(Pointer p) { super(p); }

  @NoOffset public static class SymbolicInteger extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public SymbolicInteger(Pointer p) { super(p); }
  
    public SymbolicInteger(@Cast("int64_t") long i) { super((Pointer)null); allocate(i); }
    private native void allocate(@Cast("int64_t") long i);
    public SymbolicInteger(@Cast("const char*") BytePointer s) { super((Pointer)null); allocate(s); }
    private native void allocate(@Cast("const char*") BytePointer s);
    public SymbolicInteger(String s) { super((Pointer)null); allocate(s); }
    private native void allocate(String s);
    public SymbolicInteger(@Const @ByRef SymbolicInteger arg0) { super((Pointer)null); allocate(arg0); }
    private native void allocate(@Const @ByRef SymbolicInteger arg0);

    public native @ByRef @Name("operator =") SymbolicInteger put(@Const @ByRef SymbolicInteger arg0);

    public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef SymbolicInteger dim);

    public native @Cast("bool") boolean IsInt();
    public native @Cast("int64_t") long AsInt();
    public native @Cast("const char*") BytePointer AsSym();

    @MemberGetter public static native int INVALID_INT_DIM();
    public static final int INVALID_INT_DIM = INVALID_INT_DIM();
  }

  public ShapeInferContext(@Const OrtApi ort_api, OrtShapeInferContext ctx) { super((Pointer)null); allocate(ort_api, ctx); }
  private native void allocate(@Const OrtApi ort_api, OrtShapeInferContext ctx);

  public native @StdVector SymbolicInteger GetInputShape(@Cast("size_t") long indice);

  public native @Cast("size_t") long GetInputCount();

  public native @ByVal Status SetOutputShape(@Cast("size_t") long indice, @StdVector SymbolicInteger shape, @Cast("ONNXTensorElementDataType") int type/*=ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT*/);
  public native @ByVal Status SetOutputShape(@Cast("size_t") long indice, @StdVector SymbolicInteger shape);

  public native @Cast("int64_t") long GetAttrInt(@Cast("const char*") BytePointer attr_name);
  public native @Cast("int64_t") long GetAttrInt(String attr_name);
  public native @ByVal LongVector GetAttrInts(@Cast("const char*") BytePointer attr_name);
  public native @ByVal LongVector GetAttrInts(String attr_name);

  public native float GetAttrFloat(@Cast("const char*") BytePointer attr_name);
  public native float GetAttrFloat(String attr_name);
  public native @ByVal FloatVector GetAttrFloats(@Cast("const char*") BytePointer attr_name);
  public native @ByVal FloatVector GetAttrFloats(String attr_name);

  public native @StdString BytePointer GetAttrString(@Cast("const char*") BytePointer attr_name);
  public native @StdString String GetAttrString(String attr_name);
  public native @ByVal @Cast("Ort::ShapeInferContext::Strings*") StringVector GetAttrStrings(@Cast("const char*") BytePointer attr_name);
  public native @ByVal @Cast("Ort::ShapeInferContext::Strings*") StringVector GetAttrStrings(String attr_name);
}
