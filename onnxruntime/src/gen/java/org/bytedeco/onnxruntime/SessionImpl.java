// Targeted by JavaCPP version 1.5.10: DO NOT EDIT THIS FILE

package org.bytedeco.onnxruntime;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.opencl.*;
import static org.bytedeco.opencl.global.OpenCL.*;
import org.bytedeco.dnnl.*;
import static org.bytedeco.dnnl.global.dnnl.*;

import static org.bytedeco.onnxruntime.global.onnxruntime.*;


@Name("Ort::detail::SessionImpl<OrtSession>") @Properties(inherit = org.bytedeco.onnxruntime.presets.onnxruntime.class)
public class SessionImpl extends ConstSessionImpl {
    static { Loader.load(); }
    /** Default native constructor. */
    public SessionImpl() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public SessionImpl(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SessionImpl(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public SessionImpl position(long position) {
        return (SessionImpl)super.position(position);
    }
    @Override public SessionImpl getPointer(long i) {
        return new SessionImpl((Pointer)this).offsetAddress(i);
    }


  /** \brief Run the model returning results in an Ort allocated vector.
   *
   * Wraps OrtApi::Run
   *
   * The caller provides a list of inputs and a list of the desired outputs to return.
   *
   * See the output logs for more information on warnings/errors that occur while processing the model.
   * Common errors are.. (TODO)
   *
   * @param run_options [in]
   * @param input_names [in] Array of null terminated strings of length input_count that is the list of input names
   * @param input_values [in] Array of Value objects of length input_count that is the list of input values
   * @param input_count [in] Number of inputs (the size of the input_names & input_values arrays)
   * @param output_names [in] Array of C style strings of length output_count that is the list of output names
   * @param output_count [in] Number of outputs (the size of the output_names array)
   * @return A std::vector of Value objects that directly maps to the output_names array (eg. output_name[0] is the first entry of the returned vector)
   */
  public native @StdMove ValueVector Run(@Const @ByRef RunOptions run_options, @Cast("const char*const*") PointerPointer input_names, @Const Value input_values, @Cast("size_t") long input_count,
                           @Cast("const char*const*") PointerPointer output_names, @Cast("size_t") long output_count);
  public native @StdMove ValueVector Run(@Const @ByRef RunOptions run_options, @Cast("const char*const*") @ByPtrPtr BytePointer input_names, @Const Value input_values, @Cast("size_t") long input_count,
                           @Cast("const char*const*") @ByPtrPtr BytePointer output_names, @Cast("size_t") long output_count);
  public native @StdMove ValueVector Run(@Const @ByRef RunOptions run_options, @Cast("const char*const*") @ByPtrPtr ByteBuffer input_names, @Const Value input_values, @Cast("size_t") long input_count,
                           @Cast("const char*const*") @ByPtrPtr ByteBuffer output_names, @Cast("size_t") long output_count);
  public native @StdMove ValueVector Run(@Const @ByRef RunOptions run_options, @Cast("const char*const*") @ByPtrPtr byte[] input_names, @Const Value input_values, @Cast("size_t") long input_count,
                           @Cast("const char*const*") @ByPtrPtr byte[] output_names, @Cast("size_t") long output_count);

  /** \brief Run the model returning results in user provided outputs
   * Same as Run(const RunOptions&, const char* const*, const Value*, size_t,const char* const*, size_t)
   */
  public native void Run(@Const @ByRef RunOptions run_options, @Cast("const char*const*") PointerPointer input_names, @Const Value input_values, @Cast("size_t") long input_count,
             @Cast("const char*const*") PointerPointer output_names, Value output_values, @Cast("size_t") long output_count);
  public native void Run(@Const @ByRef RunOptions run_options, @Cast("const char*const*") @ByPtrPtr BytePointer input_names, @Const Value input_values, @Cast("size_t") long input_count,
             @Cast("const char*const*") @ByPtrPtr BytePointer output_names, Value output_values, @Cast("size_t") long output_count);
  public native void Run(@Const @ByRef RunOptions run_options, @Cast("const char*const*") @ByPtrPtr ByteBuffer input_names, @Const Value input_values, @Cast("size_t") long input_count,
             @Cast("const char*const*") @ByPtrPtr ByteBuffer output_names, Value output_values, @Cast("size_t") long output_count);
  public native void Run(@Const @ByRef RunOptions run_options, @Cast("const char*const*") @ByPtrPtr byte[] input_names, @Const Value input_values, @Cast("size_t") long input_count,
             @Cast("const char*const*") @ByPtrPtr byte[] output_names, Value output_values, @Cast("size_t") long output_count);

  /** Wraps OrtApi::RunWithBinding */
  public native void Run(@Const @ByRef RunOptions run_options, @Const @ByRef IoBinding arg1);

  /** \brief Run the model asynchronously in a thread owned by intra op thread pool
   *
   * Wraps OrtApi::RunAsync
   *
   * @param run_options [in]
   * @param input_names [in] Array of null terminated UTF8 encoded strings of the input names
   * @param input_values [in] Array of Value objects of length input_count
   * @param input_count [in] Number of elements in the input_names and inputs arrays
   * @param output_names [in] Array of null terminated UTF8 encoded strings of the output names
   * @param output_values [out] Array of provided Values to be filled with outputs.
   *             On calling RunAsync, output_values[i] could either be initialized by a null pointer or a preallocated OrtValue*.
   *             Later, on invoking the callback, each output_values[i] of null will be filled with an OrtValue* allocated by onnxruntime.
   *             Then, an OrtValue** pointer will be casted from output_values, and pass to the callback.
   *             NOTE: it is customer's duty to finally release output_values and each of its member,
   *             regardless of whether the member (Ort::Value) is allocated by onnxruntime or preallocated by the customer.
   * @param output_count [in] Number of elements in the output_names and outputs array
   * @param callback [in] Callback function on model run completion
   * @param user_data [in] User data that pass back to the callback
   */
  public native void RunAsync(@Const @ByRef RunOptions run_options, @Cast("const char*const*") PointerPointer input_names, @Const Value input_values, @Cast("size_t") long input_count,
                  @Cast("const char*const*") PointerPointer output_names, Value output_values, @Cast("size_t") long output_count, RunAsyncCallbackFn callback, Pointer user_data);
  public native void RunAsync(@Const @ByRef RunOptions run_options, @Cast("const char*const*") @ByPtrPtr BytePointer input_names, @Const Value input_values, @Cast("size_t") long input_count,
                  @Cast("const char*const*") @ByPtrPtr BytePointer output_names, Value output_values, @Cast("size_t") long output_count, RunAsyncCallbackFn callback, Pointer user_data);
  public native void RunAsync(@Const @ByRef RunOptions run_options, @Cast("const char*const*") @ByPtrPtr ByteBuffer input_names, @Const Value input_values, @Cast("size_t") long input_count,
                  @Cast("const char*const*") @ByPtrPtr ByteBuffer output_names, Value output_values, @Cast("size_t") long output_count, RunAsyncCallbackFn callback, Pointer user_data);
  public native void RunAsync(@Const @ByRef RunOptions run_options, @Cast("const char*const*") @ByPtrPtr byte[] input_names, @Const Value input_values, @Cast("size_t") long input_count,
                  @Cast("const char*const*") @ByPtrPtr byte[] output_names, Value output_values, @Cast("size_t") long output_count, RunAsyncCallbackFn callback, Pointer user_data);

  /** \brief End profiling and return a copy of the profiling file name.
   *
   * @param allocator to allocate memory for the copy of the string returned
   * @return a instance of smart pointer that would deallocate the buffer when out of scope.
   *  The OrtAllocator instances must be valid at the point of memory release.
   */
  /** Wraps OrtApi::SessionEndProfiling */
  public native @UniquePtr("char, Ort::detail::AllocatedFree") @Cast("char*") BytePointer EndProfilingAllocated(OrtAllocator allocator);
}
