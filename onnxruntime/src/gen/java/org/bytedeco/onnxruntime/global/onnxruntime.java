// Targeted by JavaCPP version 1.5.12-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.onnxruntime.global;

import org.bytedeco.onnxruntime.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.opencl.*;
import static org.bytedeco.opencl.global.OpenCL.*;
import org.bytedeco.dnnl.*;
import static org.bytedeco.dnnl.global.dnnl.*;

public class onnxruntime extends org.bytedeco.onnxruntime.presets.onnxruntime {
    static { Loader.load(); }

// Targeting ../FloatVector.java


// Targeting ../LongVector.java


// Targeting ../StringVector.java


// Targeting ../ValueVector.java


// Targeting ../StringStringMap.java


// Parsed from onnxruntime/core/session/onnxruntime_c_api.h

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// See docs\c_cxx\README.md on generating the Doxygen documentation from this file

/** \mainpage ONNX Runtime
 *
 * ONNX Runtime is a high-performance inference and training graph execution engine for deep learning models.
 *
 * ONNX Runtime's C, C++ APIs offer an easy to use interface to onboard and execute onnx models.
 * - \subpage c_cpp_api "Core C, C++ APIs"
 * - \subpage training_c_cpp_api "Training C, C++ APIs for on-device training"
 *
 * \page c_cpp_api Core C, C++ APIs
 * <h1>C</h1>
 *
 * ::OrtApi - Click here to go to the structure with all C API functions.
 *
 * <h1>C++</h1>
 *
 * ::Ort - Click here to go to the namespace holding all of the C++ wrapper classes
 *
 * It is a set of header only wrapper classes around the C API. The goal is to turn the C style return value error codes into C++ exceptions, and to
 * automate memory management through standard C++ RAII principles.
 *
 * \addtogroup Global
 * ONNX Runtime C API
 * \{
 */

// #pragma once
// #include <stdbool.h>
// #include <stdint.h>
// #include <stdlib.h>
// #include <string.h>

/** \brief The API version defined in this header
 *
 * This value is used by some API functions to behave as this version of the header expects.
 */
public static final int ORT_API_VERSION = 21;

// #ifdef __cplusplus
// #endif

/** \} */
// SAL2 Definitions
// #ifndef _MSC_VER
// #define _In_
// #define _In_z_
// #define _In_opt_
// #define _In_opt_z_
// #define _Out_
// #define _Outptr_
// #define _Out_opt_
// #define _Inout_
// #define _Inout_opt_
// #define _Frees_ptr_opt_
// #define _Ret_maybenull_
// #define _Ret_notnull_
// #define _Check_return_
// #define _Outptr_result_maybenull_
// #define _In_reads_(X)
// #define _Inout_updates_(X)
// #define _Out_writes_(X)
// #define _Inout_updates_all_(X)
// #define _Out_writes_bytes_all_(X)
// #define _Out_writes_all_(X)
// #define _Success_(X)
// #define _Outptr_result_buffer_maybenull_(X)
// #define ORT_ALL_ARGS_NONNULL __attribute__((nonnull))
// #else
// #include <specstrings.h>
// #define ORT_ALL_ARGS_NONNULL
// #endif

// #ifdef _WIN32
// Define ORT_DLL_IMPORT if your program is dynamically linked to Ort.
// dllexport is not used, we use a .def file.
// #ifdef ORT_DLL_IMPORT
// #define ORT_EXPORT __declspec(dllimport)
// #else
// #define ORT_EXPORT
// #endif
// #define ORT_API_CALL _stdcall
// #define ORT_MUST_USE_RESULT
// #define ORTCHAR_T wchar_t
// #else
// To make symbols visible on macOS/iOS
// #ifdef __APPLE__
// #define ORT_EXPORT __attribute__((visibility("default")))
// #else
// #define ORT_EXPORT
// #endif
// #define ORT_API_CALL
// #define ORT_MUST_USE_RESULT __attribute__((warn_unused_result))
// #define ORTCHAR_T char
// #endif

/** ORTCHAR_T, ORT_TSTR are reserved specifically for path handling.
 *  All other strings are UTF-8 encoded, use char and std::string */
// #ifndef ORT_TSTR
// #ifdef _WIN32
// #define ORT_TSTR(X) L##X
// When X is a macro, L##X is not defined. In this case, we need to use ORT_TSTR_ON_MACRO.
// #define ORT_TSTR_ON_MACRO(X) L"" X
// #else
// #define ORT_TSTR(X) X
// #define ORT_TSTR_ON_MACRO(X) X
// #endif
// #endif

// On Windows, ORT_FILE is a wchar_t version of the __FILE__ macro.
// Otherwise, ORT_FILE is equivalent to __FILE__.
// #ifndef ORT_FILE
// #define ORT_FILE_INTERNAL(x) ORT_TSTR(x)
// #define ORT_FILE ORT_FILE_INTERNAL(__FILE__)
// #endif

// Any pointer marked with _In_ or _Out_, cannot be NULL.

// Windows users should use unicode paths when possible to bypass the MAX_PATH limitation
// Every pointer marked with _In_ or _Out_, cannot be NULL. Caller should ensure that.
// for ReleaseXXX(...) functions, they can accept NULL pointer.

// #ifdef __cplusplus
// For any compiler with C++11 support, MSVC 2015 and greater, or Clang version supporting noexcept.
// Such complex condition is needed because compilers set __cplusplus value differently.
// #ifndef __has_feature
// #define __has_feature(x) 0
// #endif
// #if ((__cplusplus >= 201103L) || (_MSC_VER >= 1900) || (defined(__has_feature) && __has_feature(cxx_noexcept)))
// #define NO_EXCEPTION
// #else
// #define NO_EXCEPTION throw()
// #endif
// #else
// #define NO_EXCEPTION
// #endif

// __VA_ARGS__ on Windows and Linux are different
// #define ORT_API(RETURN_TYPE, NAME, ...) RETURN_TYPE ORT_API_CALL NAME(__VA_ARGS__) NO_EXCEPTION

// #define ORT_API_STATUS(NAME, ...)
//   _Success_(return == 0) _Check_return_ _Ret_maybenull_ OrtStatusPtr ORT_API_CALL NAME(__VA_ARGS__)
//   NO_EXCEPTION ORT_MUST_USE_RESULT

// XXX: Unfortunately, SAL annotations are known to not work with function pointers
// #define ORT_API2_STATUS(NAME, ...)
//   _Check_return_ _Ret_maybenull_ OrtStatusPtr(ORT_API_CALL* NAME)(__VA_ARGS__) NO_EXCEPTION ORT_MUST_USE_RESULT

// Used in *.cc files. Almost as same as ORT_API_STATUS, except without ORT_MUST_USE_RESULT and ORT_EXPORT
// #define ORT_API_STATUS_IMPL(NAME, ...)
//   _Success_(return == 0) _Check_return_ _Ret_maybenull_ OrtStatusPtr ORT_API_CALL NAME(__VA_ARGS__) NO_EXCEPTION

// #define ORT_CLASS_RELEASE(X) void(ORT_API_CALL * Release##X)(_Frees_ptr_opt_ Ort##X * input)

// #ifdef __DOXYGEN__
// #undef ORT_API_STATUS
// #define ORT_API_STATUS(NAME, ...) OrtStatus* NAME(__VA_ARGS__)
// #undef ORT_API2_STATUS
// #define ORT_API2_STATUS(NAME, ...) OrtStatus* NAME(__VA_ARGS__)
// #undef ORT_CLASS_RELEASE
// #define ORT_CLASS_RELEASE(X) void Release##X(Ort##X* input)
// #undef NO_EXCEPTION
// #define NO_EXCEPTION
// #endif
/** \addtogroup Global
 * ONNX Runtime C API
 * \{
 */

/** Copied from TensorProto::DataType
 * Currently, Ort doesn't support complex64, complex128
 */
/** enum ONNXTensorElementDataType */
public static final int
  ONNX_TENSOR_ELEMENT_DATA_TYPE_UNDEFINED = 0,
  ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT = 1,   // maps to c type float
  ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT8 = 2,   // maps to c type uint8_t
  ONNX_TENSOR_ELEMENT_DATA_TYPE_INT8 = 3,    // maps to c type int8_t
  ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT16 = 4,  // maps to c type uint16_t
  ONNX_TENSOR_ELEMENT_DATA_TYPE_INT16 = 5,   // maps to c type int16_t
  ONNX_TENSOR_ELEMENT_DATA_TYPE_INT32 = 6,   // maps to c type int32_t
  ONNX_TENSOR_ELEMENT_DATA_TYPE_INT64 = 7,   // maps to c type int64_t
  ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING = 8,  // maps to c++ type std::string
  ONNX_TENSOR_ELEMENT_DATA_TYPE_BOOL = 9,
  ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT16 = 10,
  ONNX_TENSOR_ELEMENT_DATA_TYPE_DOUBLE = 11,      // maps to c type double
  ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT32 = 12,      // maps to c type uint32_t
  ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT64 = 13,      // maps to c type uint64_t
  ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX64 = 14,   // complex with float32 real and imaginary components
  ONNX_TENSOR_ELEMENT_DATA_TYPE_COMPLEX128 = 15,  // complex with float64 real and imaginary components
  ONNX_TENSOR_ELEMENT_DATA_TYPE_BFLOAT16 = 16,    // Non-IEEE floating-point format based on IEEE754 single-precision
  // float 8 types were introduced in onnx 1.14, see https://onnx.ai/onnx/technical/float8.html
  ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FN = 17,    // Non-IEEE floating-point format based on IEEE754 single-precision
  ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E4M3FNUZ = 18,  // Non-IEEE floating-point format based on IEEE754 single-precision
  ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2 = 19,      // Non-IEEE floating-point format based on IEEE754 single-precision
  ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT8E5M2FNUZ = 20,  // Non-IEEE floating-point format based on IEEE754 single-precision
  // Int4 types were introduced in ONNX 1.16. See https://onnx.ai/onnx/technical/int4.html
  ONNX_TENSOR_ELEMENT_DATA_TYPE_UINT4 = 21,  // maps to a pair of packed uint4 values (size == 1 byte)
  ONNX_TENSOR_ELEMENT_DATA_TYPE_INT4 = 22;    // maps to a pair of packed int4 values (size == 1 byte)

// Synced with onnx TypeProto oneof
/** enum ONNXType */
public static final int
  ONNX_TYPE_UNKNOWN = 0,
  ONNX_TYPE_TENSOR = 1,
  ONNX_TYPE_SEQUENCE = 2,
  ONNX_TYPE_MAP = 3,
  ONNX_TYPE_OPAQUE = 4,
  ONNX_TYPE_SPARSETENSOR = 5,
  ONNX_TYPE_OPTIONAL = 6;

// These types are synced with internal
// SparseFormatFlags
/** enum OrtSparseFormat */
public static final int
  ORT_SPARSE_UNDEFINED = 0,
  ORT_SPARSE_COO = 0x1,
  ORT_SPARSE_CSRC = 0x2,
  ORT_SPARSE_BLOCK_SPARSE = 0x4;

// Enum allows to query sparse tensor indices
public enum OrtSparseIndicesFormat {
  ORT_SPARSE_COO_INDICES(0),
  ORT_SPARSE_CSR_INNER_INDICES(1),
  ORT_SPARSE_CSR_OUTER_INDICES(2),
  ORT_SPARSE_BLOCK_SPARSE_INDICES(3);

    public final int value;
    private OrtSparseIndicesFormat(int v) { this.value = v; }
    private OrtSparseIndicesFormat(OrtSparseIndicesFormat e) { this.value = e.value; }
    public OrtSparseIndicesFormat intern() { for (OrtSparseIndicesFormat e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/** \brief Logging severity levels
 *
 * In typical API usage, specifying a logging severity level specifies the minimum severity of log messages to show.
 */
/** enum OrtLoggingLevel */
public static final int
  /** Verbose informational messages (least severe). */
  ORT_LOGGING_LEVEL_VERBOSE = 0,
  /** Informational messages. */
  ORT_LOGGING_LEVEL_INFO = 1,
  /** Warning messages. */
  ORT_LOGGING_LEVEL_WARNING = 2,
  /** Error messages. */
  ORT_LOGGING_LEVEL_ERROR = 3,
  /** Fatal error messages (most severe). */
  ORT_LOGGING_LEVEL_FATAL = 4;

/** enum OrtErrorCode */
public static final int
  ORT_OK = 0,
  ORT_FAIL = 1,
  ORT_INVALID_ARGUMENT = 2,
  ORT_NO_SUCHFILE = 3,
  ORT_NO_MODEL = 4,
  ORT_ENGINE_ERROR = 5,
  ORT_RUNTIME_EXCEPTION = 6,
  ORT_INVALID_PROTOBUF = 7,
  ORT_MODEL_LOADED = 8,
  ORT_NOT_IMPLEMENTED = 9,
  ORT_INVALID_GRAPH = 10,
  ORT_EP_FAIL = 11;

/** enum OrtOpAttrType */
public static final int
  ORT_OP_ATTR_UNDEFINED = 0,
  ORT_OP_ATTR_INT = 1,
  ORT_OP_ATTR_INTS = 2,
  ORT_OP_ATTR_FLOAT = 3,
  ORT_OP_ATTR_FLOATS = 4,
  ORT_OP_ATTR_STRING = 5,
  ORT_OP_ATTR_STRINGS = 6;

/** \} */
// #define ORT_RUNTIME_CLASS(X)
//   struct Ort##X;
//   typedef struct Ort##X Ort##X
// Targeting ../OrtEnv.java


// Targeting ../OrtStatus.java


// Targeting ../OrtMemoryInfo.java


// Targeting ../OrtIoBinding.java


// Targeting ../OrtSession.java


// Targeting ../OrtValue.java


// Targeting ../OrtRunOptions.java


// Targeting ../OrtTypeInfo.java


// Targeting ../OrtTensorTypeAndShapeInfo.java


// Targeting ../OrtMapTypeInfo.java


// Targeting ../OrtSequenceTypeInfo.java


// Targeting ../OrtOptionalTypeInfo.java


// Targeting ../OrtSessionOptions.java


// Targeting ../OrtCustomOpDomain.java


// Targeting ../OrtModelMetadata.java


// Targeting ../OrtThreadPoolParams.java


// Targeting ../OrtThreadingOptions.java


// Targeting ../OrtArenaCfg.java


// Targeting ../OrtPrepackedWeightsContainer.java


// Targeting ../OrtTensorRTProviderOptionsV2.java


// Targeting ../OrtCUDAProviderOptionsV2.java


// Targeting ../OrtCANNProviderOptions.java


// Targeting ../OrtOp.java


// Targeting ../OrtOpAttr.java


// Targeting ../OrtLogger.java


// Targeting ../OrtShapeInferContext.java


// Targeting ../OrtLoraAdapter.java



// #ifdef _WIN32
// #else
// Targeting ../OrtAllocator.java


// Targeting ../OrtLoggingFunction.java



/** \brief Graph optimization level
 *
 * Refer to https://www.onnxruntime.ai/docs/performance/graph-optimizations.html#graph-optimization-levels
 * for an in-depth understanding of the Graph Optimization Levels.
 */
/** enum GraphOptimizationLevel */
public static final int
  ORT_DISABLE_ALL = 0,
  ORT_ENABLE_BASIC = 1,
  ORT_ENABLE_EXTENDED = 2,
  ORT_ENABLE_ALL = 99;

/** enum ExecutionMode */
public static final int
  ORT_SEQUENTIAL = 0,
  ORT_PARALLEL = 1;

/** \brief Language projection identifiers
 * /see OrtApi::SetLanguageProjection
 */
/** enum OrtLanguageProjection */
public static final int
  ORT_PROJECTION_C = 0,
  ORT_PROJECTION_CPLUSPLUS = 1,
  ORT_PROJECTION_CSHARP = 2,
  ORT_PROJECTION_PYTHON = 3,
  ORT_PROJECTION_JAVA = 4,
  ORT_PROJECTION_WINML = 5,
  ORT_PROJECTION_NODEJS = 6;
// Targeting ../OrtKernelInfo.java


// Targeting ../OrtKernelContext.java



/** enum OrtAllocatorType */
public static final int
  OrtInvalidAllocator = -1,
  OrtDeviceAllocator = 0,
  OrtArenaAllocator = 1;

/** \brief Memory types for allocated memory, execution provider specific types should be extended in each provider.
 */
// Whenever this struct is updated, please also update the MakeKey function in onnxruntime / core / framework / execution_provider.cc
/** enum OrtMemType */
public static final int
  /** Any CPU memory used by non-CPU execution provider */
  OrtMemTypeCPUInput = -2,
  /** CPU accessible memory outputted by non-CPU execution provider, i.e. CUDA_PINNED */
  OrtMemTypeCPUOutput = -1,
  /** Temporary CPU accessible memory allocated by non-CPU execution provider, i.e. CUDA_PINNED */
  OrtMemTypeCPU = OrtMemTypeCPUOutput,
  /** The default allocator for execution provider */
  OrtMemTypeDefault = 0;

/** \brief This mimics OrtDevice type constants so they can be returned in the API
 */
/** enum OrtMemoryInfoDeviceType */
public static final int
  OrtMemoryInfoDeviceType_CPU = 0,
  OrtMemoryInfoDeviceType_GPU = 1,
  OrtMemoryInfoDeviceType_FPGA = 2;

/** \brief Algorithm to use for cuDNN Convolution Op
 */
/** enum OrtCudnnConvAlgoSearch */
public static final int
  OrtCudnnConvAlgoSearchExhaustive = 0,  // expensive exhaustive benchmarking using cudnnFindConvolutionForwardAlgorithmEx
  OrtCudnnConvAlgoSearchHeuristic = 1,   // lightweight heuristic based search using cudnnGetConvolutionForwardAlgorithm_v7
  OrtCudnnConvAlgoSearchDefault = 2;     // default algorithm using CUDNN_CONVOLUTION_FWD_ALGO_IMPLICIT_PRECOMP_GEMM
// Targeting ../OrtCUDAProviderOptions.java


// Targeting ../OrtROCMProviderOptions.java


// Targeting ../OrtTensorRTProviderOptions.java


// Targeting ../OrtMIGraphXProviderOptions.java


// Targeting ../OrtOpenVINOProviderOptions.java


// Targeting ../OrtTrainingApi.java


// Targeting ../OrtApiBase.java



/** \brief The Onnxruntime library's entry point to access the C API
 *
 * Call this to get the a pointer to an ::OrtApiBase
 */
public static native @Const OrtApiBase OrtGetApiBase();
// Targeting ../OrtThreadWorkerFn.java


// Targeting ../OrtCustomHandleType.java


// Targeting ../OrtCustomCreateThreadFn.java


// Targeting ../OrtCustomJoinThreadFn.java


// Targeting ../RegisterCustomOpsFn.java


// Targeting ../RunAsyncCallbackFn.java


// Targeting ../OrtApi.java



/*
 * Steps to use a custom op:
 *   1 Create an OrtCustomOpDomain with the domain name used by the custom ops
 *   2 Create an OrtCustomOp structure for each op and add them to the domain
 *   3 Call OrtAddCustomOpDomain to add the custom domain of ops to the session options
 */

// Specifies some characteristics of inputs/outputs of custom ops:
// Specify if the inputs/outputs are one of:
// 1) Non-optional (input/output must be present in the node)
// 2) Optional (input/output may be absent in the node)
// 3) Variadic: A variadic input or output specifies N (i.e., the minimum arity) or more operands.
//              Only the last input or output of a custom op may be marked as variadic.
//              The homogeneity of the variadic input or output determines whether all operands must be of the same
//              tensor element type.
/** enum OrtCustomOpInputOutputCharacteristic */
public static final int
  INPUT_OUTPUT_REQUIRED = 0,
  INPUT_OUTPUT_OPTIONAL = 1,
  INPUT_OUTPUT_VARIADIC = 2;
// Targeting ../OrtCustomOp.java



/*
 * This is the old way to add the CUDA provider to the session, please use SessionOptionsAppendExecutionProvider_CUDA above to access the latest functionality
 * This function always exists, but will only succeed if Onnxruntime was built with CUDA support and the CUDA provider shared library exists
 *
 * \param device_id CUDA device id, starts from zero.
 */
public static native @Platform(extension="-gpu") OrtStatus OrtSessionOptionsAppendExecutionProvider_CUDA( OrtSessionOptions options, int device_id);

/*
 * This is the old way to add the ROCm provider to the session, please use
 * SessionOptionsAppendExecutionProvider_ROCM above to access the latest functionality
 * This function always exists, but will only succeed if Onnxruntime was built with
 * HIP support and the ROCm provider shared library exists
 *
 * \param device_id HIP device id, starts from zero.
 */


/*
 * This is the old way to add the MIGraphX provider to the session, please use
 * SessionOptionsAppendExecutionProvider_MIGraphX above to access the latest functionality
 * This function always exists, but will only succeed if Onnxruntime was built with
 * HIP support and the MIGraphX provider shared library exists
 *
 * \param device_id HIP device id, starts from zero.
 */


/*
 * This is the old way to add the oneDNN provider to the session, please use
 * SessionOptionsAppendExecutionProvider_oneDNN above to access the latest functionality
 * This function always exists, but will only succeed if Onnxruntime was built with
 * oneDNN support and the oneDNN provider shared library exists
 *
 * \param use_arena zero: false. non-zero: true.
 */
public static native OrtStatus OrtSessionOptionsAppendExecutionProvider_Dnnl( OrtSessionOptions options, int use_arena);

/*
 * This is the old way to add the TensorRT provider to the session, please use SessionOptionsAppendExecutionProvider_TensorRT_V2 above to access the latest functionality
 * This function always exists, but will only succeed if Onnxruntime was built with TensorRT support and the TensorRT provider shared library exists
 *
 * \param device_id CUDA device id, starts from zero.
 */


// #ifdef __cplusplus
// #endif
/** \} */


// Parsed from onnxruntime/core/session/onnxruntime_cxx_api.h

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// Summary: The Ort C++ API is a header only wrapper around the Ort C API.
//
// The C++ API simplifies usage by returning values directly instead of error codes, throwing exceptions on errors
// and automatically releasing resources in the destructors. The primary purpose of C++ API is exception safety so
// all the resources follow RAII and do not leak memory.
//
// Each of the C++ wrapper classes holds only a pointer to the C internal object. Treat them like smart pointers.
// To create an empty object, pass 'nullptr' to the constructor (for example, Env e{nullptr};). However, you can't use them
// until you assign an instance that actually holds an underlying object.
//
// For Ort objects only move assignment between objects is allowed, there are no copy constructors.
// Some objects have explicit 'Clone' methods for this purpose.
//
// ConstXXXX types are copyable since they do not own the underlying C object, so you can pass them to functions as arguments
// by value or by reference. ConstXXXX types are restricted to const only interfaces.
//
// UnownedXXXX are similar to ConstXXXX but also allow non-const interfaces.
//
// The lifetime of the corresponding owning object must eclipse the lifetimes of the ConstXXXX/UnownedXXXX types. They exists so you do not
// have to fallback to C types and the API with the usual pitfalls. In general, do not use C API from your C++ code.

// #pragma once
// #include "onnxruntime_c_api.h"
// #include "onnxruntime_float16.h"

// #include <cstddef>
// #include <cstdio>
// #include <array>
// #include <memory>
// #include <stdexcept>
// #include <string>
// #include <vector>
// #include <unordered_map>
// #include <utility>
// #include <type_traits>

// #ifdef ORT_NO_EXCEPTIONS
// #include <iostream>
// #endif

/** \brief All C++ Onnxruntime APIs are defined inside this namespace
 *
 */
// Targeting ../OrtException.java



// #ifdef ORT_NO_EXCEPTIONS
// The #ifndef is for the very special case where the user of this library wants to define their own way of handling errors.
// NOTE: This header expects control flow to not continue after calling ORT_CXX_API_THROW
// #ifndef ORT_CXX_API_THROW
// #define ORT_CXX_API_THROW(string, code)
//   do {
//     std::cerr << Ort::Exception(string, code)
//                      .what()
//               << std::endl;
//     abort();
//   } while (false)
// #endif
// #else
// #define ORT_CXX_API_THROW(string, code)
//   throw Ort::Exception(string, code)
// #endif

// This is used internally by the C++ API. This class holds the global variable that points to the OrtApi,
//  it's in a template so that we can define a global variable in a header and make
// it transparent to the users of the API.

// If macro ORT_API_MANUAL_INIT is defined, no static initialization will be performed. Instead, user must call InitApi() before using it.
// #pragma warning(push)
// "Global initializer calls a non-constexpr function." Therefore you can't use ORT APIs in the other global initializers.
// Please define ORT_API_MANUAL_INIT if it conerns you.
// #pragma warning(disable : 26426)
// #endif

// #if defined(_MSC_VER) && !defined(__clang__)
// #pragma warning(pop)
// #endif
// #endif

/** This returns a reference to the OrtApi interface in use */
@Namespace("Ort") public static native @Const @ByRef @NoException(true) OrtApi GetApi();

/** <summary>
 *  This function returns the onnxruntime version string
 *  </summary>
 *  <returns>version string major.minor.rev</returns> */
@Namespace("Ort") public static native @StdString BytePointer GetVersionString();

/** <summary>
 *  This function returns the onnxruntime build information: including git branch,
 *  git commit id, build type(Debug/Release/RelWithDebInfo) and cmake cpp flags.
 *  </summary>
 *  <returns>string</returns> */
@Namespace("Ort") public static native @StdString BytePointer GetBuildInfoString();

/** <summary>
 *  This is a C++ wrapper for OrtApi::GetAvailableProviders() and
 *  returns a vector of strings representing the available execution providers.
 *  </summary>
 *  <returns>vector of strings</returns> */
@Namespace("Ort") public static native @ByVal StringVector GetAvailableProviders();
// Targeting ../Float16_t.java


// Targeting ../BFloat16_t.java


// Targeting ../Float8E4M3FN_t.java


// Targeting ../Float8E4M3FNUZ_t.java


// Targeting ../Float8E5M2_t.java


// Targeting ../Float8E5M2FNUZ_t.java


// This is used internally by the C++ API. This macro is to make it easy to generate overloaded methods for all of the various OrtRelease* functions for every Ort* type
// This can't be done in the C API since C doesn't have function overloading.
// #define ORT_DEFINE_RELEASE(NAME)
//   inline void OrtRelease(Ort##NAME* ptr) { GetApi().Release##NAME(ptr); }

@Namespace("Ort::detail") public static native void OrtRelease(OrtAllocator ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtMemoryInfo ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtCustomOpDomain ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtThreadingOptions ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtEnv ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtRunOptions ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtLoraAdapter ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtSession ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtSessionOptions ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtTensorTypeAndShapeInfo ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtSequenceTypeInfo ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtMapTypeInfo ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtTypeInfo ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtValue ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtModelMetadata ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtIoBinding ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtArenaCfg ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtStatus ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtOpAttr ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtOp ptr);
@Namespace("Ort::detail") public static native void OrtRelease(OrtKernelInfo ptr);

// #undef ORT_DEFINE_RELEASE
// Targeting ../UnownedAllocator.java


// Targeting ../UnownedMemoryInfo.java


// Targeting ../UnownedTensorTypeAndShapeInfo.java


// Targeting ../UnownedSequenceTypeInfo.java


// Targeting ../UnownedMapTypeInfo.java


// Targeting ../BaseConstValue.java


// Targeting ../BaseConstSessionOptions.java


// Targeting ../BaseConstSession.java


// Targeting ../BaseConstMapTypeInfo.java


// Targeting ../BaseConstIoBinding.java


// Targeting ../BaseConstTensorTypeAndShapeInfo.java


// Targeting ../BaseAllocatorWithDefaultOptions.java


// Targeting ../BaseArenaCfg.java


// Targeting ../BaseAllocator.java


// Targeting ../BaseIoBinding.java


// Targeting ../BaseMemoryInfo.java


// Targeting ../BaseModelMetadata.java


// Targeting ../BaseCustomOpDomain.java


// Targeting ../BaseEnv.java


// Targeting ../BaseRunOptions.java


// Targeting ../BaseSession.java


// Targeting ../BaseSessionOptions.java


// Targeting ../BaseTensorTypeAndShapeInfo.java


// Targeting ../BaseSequenceTypeInfo.java


// Targeting ../BaseMapTypeInfo.java


// Targeting ../BaseTypeInfo.java


// Targeting ../BaseValue.java


// Targeting ../BaseOrtOp.java


// Targeting ../BaseOpAttr.java


// Targeting ../BaseStatus.java


// Targeting ../BaseKernelInfo.java


// Targeting ../BaseThreadingOptions.java


// Targeting ../BaseOrtLoraAdapter.java



// Undefined. For const types use Base<Unowned<const T>>

/** <summary>
 *  Covers unowned pointers owned by either the ORT
 *  or some other instance of CPP wrappers.
 *  Used for ConstXXX and UnownedXXXX types that are copyable.
 *  Also convenient to wrap raw OrtXX pointers .
 *  </summary>
 *  <typeparam name="T"></typeparam> */
// Targeting ../AllocatedFree.java



  // namespace detail

/** \brief unique_ptr typedef used to own strings allocated by OrtAllocators
 *  and release them at the end of the scope. The lifespan of the given allocator
 *  must eclipse the lifespan of AllocatedStringPtr instance
 */
// Targeting ../Status.java


// Targeting ../ThreadingOptions.java


// Targeting ../Env.java


// Targeting ../CustomOpDomain.java


// Targeting ../LoraAdapter.java


// Targeting ../RunOptions.java


// Utility function that returns a SessionOption config entry key for a specific custom operator.
// Ex: custom_op.[custom_op_name].[config]
@Namespace("Ort::detail") public static native @StdString BytePointer MakeCustomOpConfigEntryKey(@Cast("const char*") BytePointer custom_op_name, @Cast("const char*") BytePointer config);
@Namespace("Ort::detail") public static native @StdString String MakeCustomOpConfigEntryKey(String custom_op_name, String config);

// Targeting ../CustomOpConfigs.java



/** \brief Options object used when creating a new Session object
 *
 * Wraps ::OrtSessionOptions object and methods
 */
// Targeting ../ConstSessionOptions.java


// Targeting ../ConstSessionOptionsImpl.java


// Targeting ../SessionOptionsImpl.java


  // namespace detail
// Targeting ../SessionOptions.java


// Targeting ../ModelMetadata.java


// Targeting ../ConstSession.java


// Targeting ../ConstSessionImpl.java


// Targeting ../SessionImpl.java



  // namespace detail
// Targeting ../Session.java


// Targeting ../MemoryInfoImpl.java


  // namespace detail

// Const object holder that does not own the underlying object
// Targeting ../MemoryInfo.java


// Targeting ../ConstTensorTypeAndShapeInfo.java


// Targeting ../TensorTypeAndShapeInfoImpl.java



  // namespace detail
// Targeting ../TensorTypeAndShapeInfo.java


// Targeting ../BaseSequenceTypeInfoImpl.java



  // namespace detail
// Targeting ../SequenceTypeInfo.java


// Targeting ../OptionalTypeInfoImpl.java



  // namespace detail

// This is always owned by the TypeInfo and can only be obtained from it.
// Targeting ../ConstMapTypeInfo.java


// Targeting ../MapTypeInfoImpl.java



  // namespace detail
// Targeting ../MapTypeInfo.java


// Targeting ../TypeInfoImpl.java


  // namespace detail

/** <summary>
 *  Contains a constant, unowned OrtTypeInfo that can be copied and passed around by value.
 *  Provides access to const OrtTypeInfo APIs.
 *  </summary> */
// Targeting ../TypeInfo.java


// Targeting ../OrtSparseValuesParam.java


// Targeting ../Shape.java


// Targeting ../ConstValue.java


// Targeting ../ConstValueImpl.java


// Targeting ../ValueImpl.java



  // namespace detail
// Targeting ../Value.java


// Targeting ../MemoryAllocation.java


// Targeting ../AllocatorWithDefaultOptionsImpl.java


// Targeting ../AllocatorImpl.java




// Targeting ../AllocatorWithDefaultOptions.java


// Targeting ../Allocator.java


// Bring these out of template
@Namespace("Ort::detail::binding_utils") public static native @ByVal StringVector GetOutputNamesHelper(@Const OrtIoBinding binding, OrtAllocator arg1);
@Namespace("Ort::detail::binding_utils") public static native @StdMove ValueVector GetOutputValuesHelper(@Const OrtIoBinding binding, OrtAllocator arg1);

// Targeting ../ConstIoBinding.java


// Targeting ../ConstIoBindingImpl.java


// Targeting ../IoBindingImpl.java



  // namespace detail
// Targeting ../IoBinding.java


// Targeting ../ArenaCfg.java


// Targeting ../OpAttr.java



/**
 * Macro that logs a message using the provided logger. Throws an exception if OrtApi::Logger_LogMessage fails.
 * Example: ORT_CXX_LOG(logger, ORT_LOGGING_LEVEL_INFO, "Log a message");
 *
 * @param logger The Ort::Logger instance to use. Must be a value or reference.
 * @param message_severity The logging severity level of the message.
 * @param message A null-terminated UTF-8 message to log.
 */
// #define ORT_CXX_LOG(logger, message_severity, message)
//   do {
//     if (message_severity >= logger.GetLoggingSeverityLevel()) {
//       Ort::ThrowOnError(logger.ogMessage(message_severity, ORT_FILE, __LINE__,
//                                           static_cast<const char*>(__FUNCTION__), message));
//     }
//   } while (false)

/**
 * Macro that logs a message using the provided logger. Can be used in noexcept code since errors are silently ignored.
 * Example: ORT_CXX_LOG_NOEXCEPT(logger, ORT_LOGGING_LEVEL_INFO, "Log a message");
 *
 * @param logger The Ort::Logger instance to use. Must be a value or reference.
 * @param message_severity The logging severity level of the message.
 * @param message A null-terminated UTF-8 message to log.
 */
// #define ORT_CXX_LOG_NOEXCEPT(logger, message_severity, message)
//   do {
//     if (message_severity >= logger.GetLoggingSeverityLevel()) {
//       static_cast<void>(logger.ogMessage(message_severity, ORT_FILE, __LINE__,
//                                           static_cast<const char*>(__FUNCTION__), message));
//     }
//   } while (false)

/**
 * Macro that logs a printf-like formatted message using the provided logger. Throws an exception if
 * OrtApi::Logger_LogMessage fails or if a formatting error occurs.
 * Example: ORT_CXX_LOGF(logger, ORT_LOGGING_LEVEL_INFO, "Log an int: %d", 12);
 *
 * @param logger The Ort::Logger instance to use. Must be a value or reference.
 * @param message_severity The logging severity level of the message.
 * @param format A null-terminated UTF-8 format string forwarded to a printf-like function.
 *               Refer to https://en.cppreference.com/w/cpp/io/c/fprintf for information on valid formats.
 * @param ... Zero or more variadic arguments referenced by the format string.
 */
// #define ORT_CXX_LOGF(logger, message_severity, /*format,*/...)
//   do {
//     if (message_severity >= logger.GetLoggingSeverityLevel()) {
//       Ort::ThrowOnError(logger.ogFormattedMessage(message_severity, ORT_FILE, __LINE__,
//                                                    static_cast<const char*>(__FUNCTION__), __VA_ARGS__));
//     }
//   } while (false)

/**
 * Macro that logs a printf-like formatted message using the provided logger. Can be used in noexcept code since errors
 * are silently ignored.
 * Example: ORT_CXX_LOGF_NOEXCEPT(logger, ORT_LOGGING_LEVEL_INFO, "Log an int: %d", 12);
 *
 * @param logger The Ort::Logger instance to use. Must be a value or reference.
 * @param message_severity The logging severity level of the message.
 * @param format A null-terminated UTF-8 format string forwarded to a printf-like function.
 *               Refer to https://en.cppreference.com/w/cpp/io/c/fprintf for information on valid formats.
 * @param ... Zero or more variadic arguments referenced by the format string.
 */

///
///
// #define ORT_CXX_LOGF_NOEXCEPT(logger, message_severity, /*format,*/...)
//   do {
//     if (message_severity >= logger.GetLoggingSeverityLevel()) {
//       static_cast<void>(logger.ogFormattedMessage(message_severity, ORT_FILE, __LINE__,
//                                                    static_cast<const char*>(__FUNCTION__), __VA_ARGS__));
//     }
//   } while (false)
// Targeting ../Logger.java


// Targeting ../KernelContext.java


@Namespace("Ort::detail::attr_utils") public static native void GetAttr(@Const OrtKernelInfo p, @Cast("const char*") BytePointer name, @ByRef FloatPointer arg2);
@Namespace("Ort::detail::attr_utils") public static native void GetAttr(@Const OrtKernelInfo p, String name, @ByRef FloatBuffer arg2);
@Namespace("Ort::detail::attr_utils") public static native void GetAttr(@Const OrtKernelInfo p, @Cast("const char*") BytePointer name, @ByRef float[] arg2);
@Namespace("Ort::detail::attr_utils") public static native void GetAttr(@Const OrtKernelInfo p, String name, @ByRef FloatPointer arg2);
@Namespace("Ort::detail::attr_utils") public static native void GetAttr(@Const OrtKernelInfo p, @Cast("const char*") BytePointer name, @ByRef FloatBuffer arg2);
@Namespace("Ort::detail::attr_utils") public static native void GetAttr(@Const OrtKernelInfo p, String name, @ByRef float[] arg2);
@Namespace("Ort::detail::attr_utils") public static native void GetAttr(@Const OrtKernelInfo p, @Cast("const char*") BytePointer name, @Cast("int64_t*") @ByRef LongPointer arg2);
@Namespace("Ort::detail::attr_utils") public static native void GetAttr(@Const OrtKernelInfo p, String name, @Cast("int64_t*") @ByRef LongBuffer arg2);
@Namespace("Ort::detail::attr_utils") public static native void GetAttr(@Const OrtKernelInfo p, @Cast("const char*") BytePointer name, @Cast("int64_t*") @ByRef long[] arg2);
@Namespace("Ort::detail::attr_utils") public static native void GetAttr(@Const OrtKernelInfo p, String name, @Cast("int64_t*") @ByRef LongPointer arg2);
@Namespace("Ort::detail::attr_utils") public static native void GetAttr(@Const OrtKernelInfo p, @Cast("const char*") BytePointer name, @Cast("int64_t*") @ByRef LongBuffer arg2);
@Namespace("Ort::detail::attr_utils") public static native void GetAttr(@Const OrtKernelInfo p, String name, @Cast("int64_t*") @ByRef long[] arg2);
@Namespace("Ort::detail::attr_utils") public static native void GetAttr(@Const OrtKernelInfo p, @Cast("const char*") BytePointer name, @StdString @ByRef BytePointer arg2);
@Namespace("Ort::detail::attr_utils") public static native void GetAttr(@Const OrtKernelInfo p, String name, @StdString @ByRef BytePointer arg2);
@Namespace("Ort::detail::attr_utils") public static native void GetAttrs(@Const OrtKernelInfo p, @Cast("const char*") BytePointer name, @ByRef FloatVector arg2);
@Namespace("Ort::detail::attr_utils") public static native void GetAttrs(@Const OrtKernelInfo p, String name, @ByRef FloatVector arg2);
@Namespace("Ort::detail::attr_utils") public static native void GetAttrs(@Const OrtKernelInfo p, @Cast("const char*") BytePointer name, @ByRef LongVector arg2);
@Namespace("Ort::detail::attr_utils") public static native void GetAttrs(@Const OrtKernelInfo p, String name, @ByRef LongVector arg2);

// Targeting ../KernelInfoImpl.java



  // namespace detail
// Targeting ../KernelInfo.java


// Targeting ../Op.java


// Targeting ../ShapeInferContext.java



public static final long MAX_CUSTOM_OP_END_VER = (1L << 31) - 1;

  // namespace Ort

// #include "onnxruntime_cxx_inline.h"


// Parsed from onnxruntime/core/providers/cpu/cpu_provider_factory.h

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// #include "onnxruntime_c_api.h"

// #ifdef __cplusplus
// #endif

/**
 * @param use_arena zero: false. non-zero: true.
 */
public static native OrtStatus OrtSessionOptionsAppendExecutionProvider_CPU( OrtSessionOptions options, int use_arena);

// #ifdef __cplusplus
// #endif


// Parsed from onnxruntime/core/providers/dnnl/dnnl_provider_options.h

// Copyright(C) 2022 Intel Corporation
// Licensed under the MIT License
// #pragma once
// Targeting ../OrtDnnlProviderOptions.java



}
