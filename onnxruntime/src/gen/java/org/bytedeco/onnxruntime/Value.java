// Targeted by JavaCPP version 1.5.7: DO NOT EDIT THIS FILE

package org.bytedeco.onnxruntime;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.opencl.*;
import static org.bytedeco.opencl.global.OpenCL.*;
import org.bytedeco.dnnl.*;
import static org.bytedeco.dnnl.global.dnnl.*;

import static org.bytedeco.onnxruntime.global.onnxruntime.*;


@Namespace("Ort") @Properties(inherit = org.bytedeco.onnxruntime.presets.onnxruntime.class)
public class Value extends BaseValue {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Value(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Value(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Value position(long position) {
        return (Value)super.position(position);
    }
    @Override public Value getPointer(long i) {
        return new Value((Pointer)this).offsetAddress(i);
    }

  // This structure is used to feed  sparse tensor values
  // information for use with FillSparseTensor<Format>() API
  // if the data type for the sparse tensor values is numeric
  // use data.p_data, otherwise, use data.str pointer to feed
  // values. data.str is an array of const char* that are zero terminated.
  // number of strings in the array must match shape size.
  // For fully sparse tensors use shape {0} and set p_data/str
  // to nullptr.
  public static class OrtSparseValuesParam extends Pointer {
      static { Loader.load(); }
      /** Default native constructor. */
      public OrtSparseValuesParam() { super((Pointer)null); allocate(); }
      /** Native array allocator. Access with {@link Pointer#position(long)}. */
      public OrtSparseValuesParam(long size) { super((Pointer)null); allocateArray(size); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public OrtSparseValuesParam(Pointer p) { super(p); }
      private native void allocate();
      private native void allocateArray(long size);
      @Override public OrtSparseValuesParam position(long position) {
          return (OrtSparseValuesParam)super.position(position);
      }
      @Override public OrtSparseValuesParam getPointer(long i) {
          return new OrtSparseValuesParam((Pointer)this).offsetAddress(i);
      }
  
    public native @Cast("const int64_t*") LongPointer values_shape(); public native OrtSparseValuesParam values_shape(LongPointer setter);
    public native @Cast("size_t") long values_shape_len(); public native OrtSparseValuesParam values_shape_len(long setter);
      @Name("data.p_data") public native @Const Pointer data_p_data(); public native OrtSparseValuesParam data_p_data(Pointer setter);
      @Name("data.str") public native @Cast("const char*") BytePointer data_str(int i); public native OrtSparseValuesParam data_str(int i, BytePointer setter);
      @Name("data.str") @MemberGetter public native @Cast("const char**") PointerPointer data_str();
  }

  // Provides a way to pass shape in a single
  // argument
  public static class Shape extends Pointer {
      static { Loader.load(); }
      /** Default native constructor. */
      public Shape() { super((Pointer)null); allocate(); }
      /** Native array allocator. Access with {@link Pointer#position(long)}. */
      public Shape(long size) { super((Pointer)null); allocateArray(size); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public Shape(Pointer p) { super(p); }
      private native void allocate();
      private native void allocateArray(long size);
      @Override public Shape position(long position) {
          return (Shape)super.position(position);
      }
      @Override public Shape getPointer(long i) {
          return new Shape((Pointer)this).offsetAddress(i);
      }
  
    public native @Cast("const int64_t*") LongPointer shape(); public native Shape shape(LongPointer setter);
    public native @Cast("size_t") long shape_len(); public native Shape shape_len(long setter);
  }

  /** \brief Wraps OrtApi::CreateTensorWithDataAsOrtValue */
  public static native @Name("CreateTensor<float>") @StdMove Value CreateTensorFloat(@Const OrtMemoryInfo info, FloatPointer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<float>") @StdMove Value CreateTensorFloat(@Const OrtMemoryInfo info, FloatBuffer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<float>") @StdMove Value CreateTensorFloat(@Const OrtMemoryInfo info, float[] p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<double>") @StdMove Value CreateTensorDouble(@Const OrtMemoryInfo info, DoublePointer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<double>") @StdMove Value CreateTensorDouble(@Const OrtMemoryInfo info, DoubleBuffer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<double>") @StdMove Value CreateTensorDouble(@Const OrtMemoryInfo info, double[] p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int8_t>") @StdMove Value CreateTensorByte(@Const OrtMemoryInfo info, BytePointer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int8_t>") @StdMove Value CreateTensorByte(@Const OrtMemoryInfo info, ByteBuffer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int8_t>") @StdMove Value CreateTensorByte(@Const OrtMemoryInfo info, byte[] p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int16_t>") @StdMove Value CreateTensorShort(@Const OrtMemoryInfo info, ShortPointer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int16_t>") @StdMove Value CreateTensorShort(@Const OrtMemoryInfo info, ShortBuffer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int16_t>") @StdMove Value CreateTensorShort(@Const OrtMemoryInfo info, short[] p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int32_t>") @StdMove Value CreateTensorInt(@Const OrtMemoryInfo info, IntPointer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int32_t>") @StdMove Value CreateTensorInt(@Const OrtMemoryInfo info, IntBuffer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int32_t>") @StdMove Value CreateTensorInt(@Const OrtMemoryInfo info, int[] p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int64_t>") @StdMove Value CreateTensorLong(@Const OrtMemoryInfo info, @Cast("int64_t*") LongPointer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int64_t>") @StdMove Value CreateTensorLong(@Const OrtMemoryInfo info, @Cast("int64_t*") LongBuffer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int64_t>") @StdMove Value CreateTensorLong(@Const OrtMemoryInfo info, @Cast("int64_t*") long[] p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint8_t>") @StdMove Value CreateTensorUByte(@Const OrtMemoryInfo info, @Cast("uint8_t*") BytePointer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint8_t>") @StdMove Value CreateTensorUByte(@Const OrtMemoryInfo info, @Cast("uint8_t*") ByteBuffer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint8_t>") @StdMove Value CreateTensorUByte(@Const OrtMemoryInfo info, @Cast("uint8_t*") byte[] p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint16_t>") @StdMove Value CreateTensorUShort(@Const OrtMemoryInfo info, @Cast("uint16_t*") ShortPointer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint16_t>") @StdMove Value CreateTensorUShort(@Const OrtMemoryInfo info, @Cast("uint16_t*") ShortBuffer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint16_t>") @StdMove Value CreateTensorUShort(@Const OrtMemoryInfo info, @Cast("uint16_t*") short[] p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint32_t>") @StdMove Value CreateTensorUInt(@Const OrtMemoryInfo info, @Cast("uint32_t*") IntPointer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint32_t>") @StdMove Value CreateTensorUInt(@Const OrtMemoryInfo info, @Cast("uint32_t*") IntBuffer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint32_t>") @StdMove Value CreateTensorUInt(@Const OrtMemoryInfo info, @Cast("uint32_t*") int[] p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint64_t>") @StdMove Value CreateTensorULong(@Const OrtMemoryInfo info, @Cast("uint64_t*") LongPointer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint64_t>") @StdMove Value CreateTensorULong(@Const OrtMemoryInfo info, @Cast("uint64_t*") LongBuffer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint64_t>") @StdMove Value CreateTensorULong(@Const OrtMemoryInfo info, @Cast("uint64_t*") long[] p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<bool>") @StdMove Value CreateTensorBool(@Const OrtMemoryInfo info, @Cast("bool*") BoolPointer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<bool>") @StdMove Value CreateTensorBool(@Const OrtMemoryInfo info, @Cast("bool*") boolean[] p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<bool>") @StdMove Value CreateTensorBool(@Const OrtMemoryInfo info, @Cast("bool*") BoolPointer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<bool>") @StdMove Value CreateTensorBool(@Const OrtMemoryInfo info, @Cast("bool*") boolean[] p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<bool>") @StdMove Value CreateTensorBool(@Const OrtMemoryInfo info, @Cast("bool*") BoolPointer p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<bool>") @StdMove Value CreateTensorBool(@Const OrtMemoryInfo info, @Cast("bool*") boolean[] p_data, @Cast("size_t") long p_data_element_count, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  /** \brief Wraps OrtApi::CreateTensorWithDataAsOrtValue */
  public static native @StdMove Value CreateTensor(@Const OrtMemoryInfo info, Pointer p_data, @Cast("size_t") long p_data_byte_count, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len,
                              @Cast("ONNXTensorElementDataType") int type);
  public static native @StdMove Value CreateTensor(@Const OrtMemoryInfo info, Pointer p_data, @Cast("size_t") long p_data_byte_count, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len,
                              @Cast("ONNXTensorElementDataType") int type);
  public static native @StdMove Value CreateTensor(@Const OrtMemoryInfo info, Pointer p_data, @Cast("size_t") long p_data_byte_count, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len,
                              @Cast("ONNXTensorElementDataType") int type);

// #if !defined(DISABLE_SPARSE_TENSORS)
  /** <summary>
   *  This is a simple forwarding method to the other overload that helps deducing
   *  data type enum value from the type of the buffer.
   *  </summary>
   *  <typeparam name="T">numeric datatype. This API is not suitable for strings.</typeparam>
   *  <param name="info">Memory description where the user buffers reside (CPU vs GPU etc)</param>
   *  <param name="p_data">pointer to the user supplied buffer, use nullptr for fully sparse tensors</param>
   *  <param name="dense_shape">a would be dense shape of the tensor</param>
   *  <param name="values_shape">non zero values shape. Use a single 0 shape for fully sparse tensors.</param>
   *  <returns></returns> */

  /** <summary>
   *  Creates an OrtValue instance containing SparseTensor. This constructs
   *  a sparse tensor that makes use of user allocated buffers. It does not make copies
   *  of the user provided data and does not modify it. The lifespan of user provided buffers should
   *  eclipse the life span of the resulting OrtValue. This call constructs an instance that only contain
   *  a pointer to non-zero values. To fully populate the sparse tensor call Use<Format>Indices() API below
   *  to supply a sparse format specific indices.
   *  This API is not suitable for string data. Use CreateSparseTensor() with allocator specified so strings
   *  can be properly copied into the allocated buffer.
   *  </summary>
   *  <param name="info">Memory description where the user buffers reside (CPU vs GPU etc)</param>
   *  <param name="p_data">pointer to the user supplied buffer, use nullptr for fully sparse tensors</param>
   *  <param name="dense_shape">a would be dense shape of the tensor</param>
   *  <param name="values_shape">non zero values shape. Use a single 0 shape for fully sparse tensors.</param>
   *  <param name="type">data type</param>
   *  <returns>Ort::Value instance containing SparseTensor</returns> */
  public static native @StdMove Value CreateSparseTensor(@Const OrtMemoryInfo info, Pointer p_data, @Const @ByRef Shape dense_shape,
                                    @Const @ByRef Shape values_shape, @Cast("ONNXTensorElementDataType") int type);

  /** <summary>
   *  Supplies COO format specific indices and marks the contained sparse tensor as being a COO format tensor.
   *  Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user
   *  allocated buffers lifespan must eclipse that of the OrtValue.
   *  The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time.
   *  </summary>
   *  <param name="indices_data">pointer to the user allocated buffer with indices. Use nullptr for fully sparse tensors.</param>
   *  <param name="indices_num">number of indices entries. Use 0 for fully sparse tensors</param> */
  public native void UseCooIndices(@Cast("int64_t*") LongPointer indices_data, @Cast("size_t") long indices_num);
  public native void UseCooIndices(@Cast("int64_t*") LongBuffer indices_data, @Cast("size_t") long indices_num);
  public native void UseCooIndices(@Cast("int64_t*") long[] indices_data, @Cast("size_t") long indices_num);

  /** <summary>
   *  Supplies CSR format specific indices and marks the contained sparse tensor as being a CSR format tensor.
   *  Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user
   *  allocated buffers lifespan must eclipse that of the OrtValue.
   *  The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time.
   *  </summary>
   *  <param name="inner_data">pointer to the user allocated buffer with inner indices or nullptr for fully sparse tensors</param>
   *  <param name="inner_num">number of csr inner indices or 0 for fully sparse tensors</param>
   *  <param name="outer_data">pointer to the user allocated buffer with outer indices or nullptr for fully sparse tensors</param>
   *  <param name="outer_num">number of csr outer indices or 0 for fully sparse tensors</param> */
  public native void UseCsrIndices(@Cast("int64_t*") LongPointer inner_data, @Cast("size_t") long inner_num, @Cast("int64_t*") LongPointer outer_data, @Cast("size_t") long outer_num);
  public native void UseCsrIndices(@Cast("int64_t*") LongBuffer inner_data, @Cast("size_t") long inner_num, @Cast("int64_t*") LongBuffer outer_data, @Cast("size_t") long outer_num);
  public native void UseCsrIndices(@Cast("int64_t*") long[] inner_data, @Cast("size_t") long inner_num, @Cast("int64_t*") long[] outer_data, @Cast("size_t") long outer_num);

  /** <summary>
   *  Supplies BlockSparse format specific indices and marks the contained sparse tensor as being a BlockSparse format tensor.
   *  Values are supplied with a CreateSparseTensor() API. The supplied indices are not copied and the user
   *  allocated buffers lifespan must eclipse that of the OrtValue.
   *  The location of the indices is assumed to be the same as specified by OrtMemoryInfo argument at the creation time.
   *  </summary>
   *  <param name="indices_shape">indices shape or a {0} for fully sparse</param>
   *  <param name="indices_data">user allocated buffer with indices or nullptr for fully spare tensors</param> */
  public native void UseBlockSparseIndices(@Const @ByRef Shape indices_shape, IntPointer indices_data);
  public native void UseBlockSparseIndices(@Const @ByRef Shape indices_shape, IntBuffer indices_data);
  public native void UseBlockSparseIndices(@Const @ByRef Shape indices_shape, int[] indices_data);

// #endif  // !defined(DISABLE_SPARSE_TENSORS)

  // \brief Wraps OrtApi::CreateTensorAsOrtValue
  public static native @Name("CreateTensor<float>") @StdMove Value CreateTensorFloat(OrtAllocator allocator, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<float>") @StdMove Value CreateTensorFloat(OrtAllocator allocator, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<float>") @StdMove Value CreateTensorFloat(OrtAllocator allocator, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<double>") @StdMove Value CreateTensorDouble(OrtAllocator allocator, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<double>") @StdMove Value CreateTensorDouble(OrtAllocator allocator, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<double>") @StdMove Value CreateTensorDouble(OrtAllocator allocator, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int8_t>") @StdMove Value CreateTensorByte(OrtAllocator allocator, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int8_t>") @StdMove Value CreateTensorByte(OrtAllocator allocator, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int8_t>") @StdMove Value CreateTensorByte(OrtAllocator allocator, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int16_t>") @StdMove Value CreateTensorShort(OrtAllocator allocator, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int16_t>") @StdMove Value CreateTensorShort(OrtAllocator allocator, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int16_t>") @StdMove Value CreateTensorShort(OrtAllocator allocator, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int32_t>") @StdMove Value CreateTensorInt(OrtAllocator allocator, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int32_t>") @StdMove Value CreateTensorInt(OrtAllocator allocator, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int32_t>") @StdMove Value CreateTensorInt(OrtAllocator allocator, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int64_t>") @StdMove Value CreateTensorLong(OrtAllocator allocator, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int64_t>") @StdMove Value CreateTensorLong(OrtAllocator allocator, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<int64_t>") @StdMove Value CreateTensorLong(OrtAllocator allocator, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint8_t>") @StdMove Value CreateTensorUByte(OrtAllocator allocator, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint8_t>") @StdMove Value CreateTensorUByte(OrtAllocator allocator, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint8_t>") @StdMove Value CreateTensorUByte(OrtAllocator allocator, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint16_t>") @StdMove Value CreateTensorUShort(OrtAllocator allocator, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint16_t>") @StdMove Value CreateTensorUShort(OrtAllocator allocator, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint16_t>") @StdMove Value CreateTensorUShort(OrtAllocator allocator, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint32_t>") @StdMove Value CreateTensorUInt(OrtAllocator allocator, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint32_t>") @StdMove Value CreateTensorUInt(OrtAllocator allocator, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint32_t>") @StdMove Value CreateTensorUInt(OrtAllocator allocator, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint64_t>") @StdMove Value CreateTensorULong(OrtAllocator allocator, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint64_t>") @StdMove Value CreateTensorULong(OrtAllocator allocator, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<uint64_t>") @StdMove Value CreateTensorULong(OrtAllocator allocator, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<bool>") @StdMove Value CreateTensorBool(OrtAllocator allocator, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<bool>") @StdMove Value CreateTensorBool(OrtAllocator allocator, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len);
  public static native @Name("CreateTensor<bool>") @StdMove Value CreateTensorBool(OrtAllocator allocator, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len);
  // \brief Wraps OrtApi::CreateTensorAsOrtValue
  public static native @StdMove Value CreateTensor(OrtAllocator allocator, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len, @Cast("ONNXTensorElementDataType") int type);
  public static native @StdMove Value CreateTensor(OrtAllocator allocator, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len, @Cast("ONNXTensorElementDataType") int type);
  public static native @StdMove Value CreateTensor(OrtAllocator allocator, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len, @Cast("ONNXTensorElementDataType") int type);

// #if !defined(DISABLE_SPARSE_TENSORS)
  /** <summary>
   *  This is a simple forwarding method the below CreateSparseTensor.
   *  This helps to specify data type enum in terms of C++ data type.
   *  Use CreateSparseTensor<T>
   *  </summary>
   *  <typeparam name="T">numeric data type only. String data enum must be specified explicitly.</typeparam>
   *  <param name="allocator">allocator to use</param>
   *  <param name="dense_shape">a would be dense shape of the tensor</param>
   *  <returns>Ort::Value</returns> */

  /** <summary>
   *  Creates an instance of OrtValue containing sparse tensor. The created instance has no data.
   *  The data must be supplied by on of the FillSparseTensor<Format>() methods that take both non-zero values
   *  and indices. The data will be copied into a buffer that would be allocated using the supplied allocator.
   *  Use this API to create OrtValues that contain sparse tensors with all supported data types including
   *  strings.
   *  </summary>
   *  <param name="allocator">allocator to use. The allocator lifespan must eclipse that of the resulting OrtValue</param>
   *  <param name="dense_shape">a would be dense shape of the tensor</param>
   *  <param name="type">data type</param>
   *  <returns>an instance of Ort::Value</returns> */
  public static native @StdMove Value CreateSparseTensor(OrtAllocator allocator, @Const @ByRef Shape dense_shape, @Cast("ONNXTensorElementDataType") int type);

  /** <summary>
   *  The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API
   *  and copy the values and COO indices into it. If data_mem_info specifies that the data is located
   *  at difference device than the allocator, a X-device copy will be performed if possible.
   *  </summary>
   *  <param name="data_mem_info">specified buffer memory description</param>
   *  <param name="values_param">values buffer information.</param>
   *  <param name="indices_data">coo indices buffer or nullptr for fully sparse data</param>
   *  <param name="indices_num">number of COO indices or 0 for fully sparse data</param> */
  public native void FillSparseTensorCoo(@Const OrtMemoryInfo data_mem_info, @Const @ByRef OrtSparseValuesParam values_param,
                             @Cast("const int64_t*") LongPointer indices_data, @Cast("size_t") long indices_num);
  public native void FillSparseTensorCoo(@Const OrtMemoryInfo data_mem_info, @Const @ByRef OrtSparseValuesParam values_param,
                             @Cast("const int64_t*") LongBuffer indices_data, @Cast("size_t") long indices_num);
  public native void FillSparseTensorCoo(@Const OrtMemoryInfo data_mem_info, @Const @ByRef OrtSparseValuesParam values_param,
                             @Cast("const int64_t*") long[] indices_data, @Cast("size_t") long indices_num);

  /** <summary>
   *  The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API
   *  and copy the values and CSR indices into it. If data_mem_info specifies that the data is located
   *  at difference device than the allocator, a X-device copy will be performed if possible.
   *  </summary>
   *  <param name="data_mem_info">specified buffer memory description</param>
   *  <param name="values">values buffer information</param>
   *  <param name="inner_indices_data">csr inner indices pointer or nullptr for fully sparse tensors</param>
   *  <param name="inner_indices_num">number of csr inner indices or 0 for fully sparse tensors</param>
   *  <param name="outer_indices_data">pointer to csr indices data or nullptr for fully sparse tensors</param>
   *  <param name="outer_indices_num">number of csr outer indices or 0</param> */
  public native void FillSparseTensorCsr(@Const OrtMemoryInfo data_mem_info,
                             @Const @ByRef OrtSparseValuesParam values,
                             @Cast("const int64_t*") LongPointer inner_indices_data, @Cast("size_t") long inner_indices_num,
                             @Cast("const int64_t*") LongPointer outer_indices_data, @Cast("size_t") long outer_indices_num);
  public native void FillSparseTensorCsr(@Const OrtMemoryInfo data_mem_info,
                             @Const @ByRef OrtSparseValuesParam values,
                             @Cast("const int64_t*") LongBuffer inner_indices_data, @Cast("size_t") long inner_indices_num,
                             @Cast("const int64_t*") LongBuffer outer_indices_data, @Cast("size_t") long outer_indices_num);
  public native void FillSparseTensorCsr(@Const OrtMemoryInfo data_mem_info,
                             @Const @ByRef OrtSparseValuesParam values,
                             @Cast("const int64_t*") long[] inner_indices_data, @Cast("size_t") long inner_indices_num,
                             @Cast("const int64_t*") long[] outer_indices_data, @Cast("size_t") long outer_indices_num);

  /** <summary>
   *  The API will allocate memory using the allocator instance supplied to the CreateSparseTensor() API
   *  and copy the values and BlockSparse indices into it. If data_mem_info specifies that the data is located
   *  at difference device than the allocator, a X-device copy will be performed if possible.
   *  </summary>
   *  <param name="data_mem_info">specified buffer memory description</param>
   *  <param name="values">values buffer information</param>
   *  <param name="indices_shape">indices shape. use {0} for fully sparse tensors</param>
   *  <param name="indices_data">pointer to indices data or nullptr for fully sparse tensors</param> */
  public native void FillSparseTensorBlockSparse(@Const OrtMemoryInfo data_mem_info,
                                     @Const @ByRef OrtSparseValuesParam values,
                                     @Const @ByRef Shape indices_shape,
                                     @Const IntPointer indices_data);
  public native void FillSparseTensorBlockSparse(@Const OrtMemoryInfo data_mem_info,
                                     @Const @ByRef OrtSparseValuesParam values,
                                     @Const @ByRef Shape indices_shape,
                                     @Const IntBuffer indices_data);
  public native void FillSparseTensorBlockSparse(@Const OrtMemoryInfo data_mem_info,
                                     @Const @ByRef OrtSparseValuesParam values,
                                     @Const @ByRef Shape indices_shape,
                                     @Const int[] indices_data);

  /** <summary>
   *  The API returns the sparse data format this OrtValue holds in a sparse tensor.
   *  If the sparse tensor was not fully constructed, i.e. Use*() or Fill*() API were not used
   *  the value returned is ORT_SPARSE_UNDEFINED.
   *  </summary>
   *  <returns>Format enum</returns> */
  public native @Cast("OrtSparseFormat") int GetSparseFormat();

  /** <summary>
   *  The API returns type and shape information for stored non-zero values of the
   *  sparse tensor. Use GetSparseTensorValues() to obtain values buffer pointer.
   *  </summary>
   *  <returns>TensorTypeAndShapeInfo values information</returns> */
  public native @ByVal TensorTypeAndShapeInfo GetSparseTensorValuesTypeAndShapeInfo();

  /** <summary>
   *  The API returns type and shape information for the specified indices. Each supported
   *  indices have their own enum values even if a give format has more than one kind of indices.
   *  Use GetSparseTensorIndicesData() to obtain pointer to indices buffer.
   *  </summary>
   *  <param name="format">enum requested</param>
   *  <returns>type and shape information</returns> */
  public native @ByVal TensorTypeAndShapeInfo GetSparseTensorIndicesTypeShapeInfo(OrtSparseIndicesFormat format);
  public native @ByVal TensorTypeAndShapeInfo GetSparseTensorIndicesTypeShapeInfo(@Cast("OrtSparseIndicesFormat") int format);

  /** <summary>
   *  The API retrieves a pointer to the internal indices buffer. The API merely performs
   *  a convenience data type casting on the return type pointer. Make sure you are requesting
   *  the right type, use GetSparseTensorIndicesTypeShapeInfo();
   *  </summary>
   *  <typeparam name="T">type to cast to</typeparam>
   *  <param name="indices_format">requested indices kind</param>
   *  <param name="num_indices">number of indices entries</param>
   *  <returns>Pinter to the internal sparse tensor buffer containing indices. Do not free this pointer.</returns> */

// #endif  // !defined(DISABLE_SPARSE_TENSORS)

  /** Wraps OrtApi::CreateValue */
  public static native @StdMove Value CreateMap(@ByRef Value keys, @ByRef Value values);
  /** Wraps OrtApi::CreateValue */
  public static native @StdMove Value CreateSequence(@ByRef ValueVector values);

  /** Create an empty Value object, must be assigned a valid one to be used */
  public Value() { super((Pointer)null); allocate(); }
  private native void allocate();
  /** Used for interop with the C API */
  public Value(OrtValue p) { super((Pointer)null); allocate(p); }
  private native void allocate(OrtValue p);
  public Value(@StdMove Value arg0) { super((Pointer)null); allocate(arg0); }
  private native void allocate(@StdMove Value arg0);
  public native @ByRef @Name("operator =") Value put(@StdMove Value arg0);

  /** Returns true if Value is a tensor, false for other types like map/sequence/etc */
  public native @Cast("bool") boolean IsTensor();
  public native @Cast("bool") boolean HasValue();  /** < Return true if OrtValue contains data and returns false if the OrtValue is a None */

// #if !defined(DISABLE_SPARSE_TENSORS)
  /** <summary>
  /** Returns true if the OrtValue contains a sparse tensor
  /** </summary>
  /** <returns></returns> */
  public native @Cast("bool") boolean IsSparseTensor();
// #endif

  public native @Cast("size_t") long GetCount();  // If a non tensor, returns 2 for map and N for sequence, where N is the number of elements
  public native @StdMove Value GetValue(int index, OrtAllocator allocator);

  /** <summary>
   *  This API returns a full length of string data contained within either a tensor or a sparse Tensor.
   *  For sparse tensor it returns a full length of stored non-empty strings (values). The API is useful
   *  for allocating necessary memory and calling GetStringTensorContent().
   *  </summary>
   *  <returns>total length of UTF-8 encoded bytes contained. No zero terminators counted.</returns> */
  
  ///
  public native @Cast("size_t") long GetStringTensorDataLength();

  /** <summary>
   *  The API copies all of the UTF-8 encoded string data contained within a tensor or a sparse tensor
   *  into a supplied buffer. Use GetStringTensorDataLength() to find out the length of the buffer to allocate.
   *  The user must also allocate offsets buffer with the number of entries equal to that of the contained
   *  strings.
   * 
   *  Strings are always assumed to be on CPU, no X-device copy.
   *  </summary>
   *  <param name="buffer">user allocated buffer</param>
   *  <param name="buffer_length">length in bytes of the allocated buffer</param>
   *  <param name="offsets">a pointer to the offsets user allocated buffer</param>
   *  <param name="offsets_count">count of offsets, must be equal to the number of strings contained.
   *    that can be obtained from the shape of the tensor or from GetSparseTensorValuesTypeAndShapeInfo()
   *    for sparse tensors</param> */
  public native void GetStringTensorContent(Pointer buffer, @Cast("size_t") long buffer_length, @Cast("size_t*") SizeTPointer offsets, @Cast("size_t") long offsets_count);

  /** Wraps OrtApi::GetTensorMutableData */
  public native @Name("GetTensorMutableData<float>") FloatPointer GetTensorMutableDataFloat();

  /** Wraps OrtApi::GetTensorMutableData */
  public native @Name("GetTensorMutableData<double>") DoublePointer GetTensorMutableDataDouble();

  /** Wraps OrtApi::GetTensorMutableData */
  public native @Name("GetTensorMutableData<int8_t>") BytePointer GetTensorMutableDataByte();

  /** Wraps OrtApi::GetTensorMutableData */
  public native @Name("GetTensorMutableData<int16_t>") ShortPointer GetTensorMutableDataShort();

  /** Wraps OrtApi::GetTensorMutableData */
  public native @Name("GetTensorMutableData<int32_t>") IntPointer GetTensorMutableDataInt();

  /** Wraps OrtApi::GetTensorMutableData */
  public native @Cast("int64_t*") @Name("GetTensorMutableData<int64_t>") LongPointer GetTensorMutableDataLong();

  /** Wraps OrtApi::GetTensorMutableData */
  public native @Cast("uint8_t*") @Name("GetTensorMutableData<uint8_t>") BytePointer GetTensorMutableDataUByte();

  /** Wraps OrtApi::GetTensorMutableData */
  public native @Cast("uint16_t*") @Name("GetTensorMutableData<uint16_t>") ShortPointer GetTensorMutableDataUShort();

  /** Wraps OrtApi::GetTensorMutableData */
  public native @Cast("uint32_t*") @Name("GetTensorMutableData<uint32_t>") IntPointer GetTensorMutableDataUInt();

  /** Wraps OrtApi::GetTensorMutableData */
  public native @Cast("uint64_t*") @Name("GetTensorMutableData<uint64_t>") LongPointer GetTensorMutableDataULong();

  /** Wraps OrtApi::GetTensorMutableData */
  public native @Cast("bool*") @Name("GetTensorMutableData<bool>") BoolPointer GetTensorMutableDataBool();

// #if !defined(DISABLE_SPARSE_TENSORS)
  /** <summary>
   *  The API returns a pointer to an internal buffer of the sparse tensor
   *  containing non-zero values. The API merely does casting. Make sure you
   *  are requesting the right data type by calling GetSparseTensorValuesTypeAndShapeInfo()
   *  first.
   *  </summary>
   *  <typeparam name="T">numeric data types only. Use GetStringTensor*() to retrieve strings.</typeparam>
   *  <returns>a pointer to the internal values buffer. Do not free this pointer.</returns> */
// #endif

  /** <summary>
   *  The API returns type information for data contained in a tensor. For sparse
   *  tensors it returns type information for contained non-zero values.
   *  It returns dense shape for sparse tensors.
   *  </summary>
   *  <returns>TypeInfo</returns> */
  public native @ByVal TypeInfo GetTypeInfo();

  /** <summary>
   *  The API returns type information for data contained in a tensor. For sparse
   *  tensors it returns type information for contained non-zero values.
   *  It returns dense shape for sparse tensors.
   *  </summary>
   *  <returns>TensorTypeAndShapeInfo</returns> */
  public native @ByVal TensorTypeAndShapeInfo GetTensorTypeAndShapeInfo();

  /** <summary>
   *  The API returns a byte length of UTF-8 encoded string element
   *  contained in either a tensor or a spare tensor values.
   *  </summary>
   *  <param name="element_index"></param>
   *  <returns>byte length for the specified string element</returns> */
  public native @Cast("size_t") long GetStringTensorElementLength(@Cast("size_t") long element_index);

  /** <summary>
   *  The API copies UTF-8 encoded bytes for the requested string element
   *  contained within a tensor or a sparse tensor into a provided buffer.
   *  Use GetStringTensorElementLength() to obtain the length of the buffer to allocate.
   *  </summary>
   *  <param name="buffer_length"></param>
   *  <param name="element_index"></param>
   *  <param name="buffer"></param> */
  public native void GetStringTensorElement(@Cast("size_t") long buffer_length, @Cast("size_t") long element_index, Pointer buffer);

  public native void FillStringTensor(@Cast("const char*const*") PointerPointer s, @Cast("size_t") long s_len);
  public native void FillStringTensor(@Cast("const char*const*") @ByPtrPtr BytePointer s, @Cast("size_t") long s_len);
  public native void FillStringTensor(@Cast("const char*const*") @ByPtrPtr ByteBuffer s, @Cast("size_t") long s_len);
  public native void FillStringTensor(@Cast("const char*const*") @ByPtrPtr byte[] s, @Cast("size_t") long s_len);
  public native void FillStringTensorElement(@Cast("const char*") BytePointer s, @Cast("size_t") long index);
  public native void FillStringTensorElement(String s, @Cast("size_t") long index);
}
