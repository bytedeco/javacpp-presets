// Targeted by JavaCPP version 1.5.7: DO NOT EDIT THIS FILE

package org.bytedeco.onnxruntime;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.opencl.*;
import static org.bytedeco.opencl.global.OpenCL.*;
import org.bytedeco.dnnl.*;
import static org.bytedeco.dnnl.global.dnnl.*;

import static org.bytedeco.onnxruntime.global.onnxruntime.*;


/** \brief The C API
*
* All C API functions are defined inside this structure as pointers to functions.
* Call OrtApiBase::GetApi to get a pointer to it
*
* \nosubgrouping
*/
@Properties(inherit = org.bytedeco.onnxruntime.presets.onnxruntime.class)
public class OrtApi extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OrtApi() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OrtApi(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OrtApi(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OrtApi position(long position) {
        return (OrtApi)super.position(position);
    }
    @Override public OrtApi getPointer(long i) {
        return new OrtApi((Pointer)this).offsetAddress(i);
    }

  /** \name OrtStatus
   *  \{
  <p>
  /**
  * \brief Create an OrtStatus from a null terminated string
  *
  * @param code [in]
  * @param msg [in] A null-terminated string. Its contents will be copied.
  * @return A new OrtStatus object, must be destroyed with OrtApi::ReleaseStatus
  */
  public static class CreateStatus_int_BytePointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    CreateStatus_int_BytePointer(Pointer p) { super(p); }
      protected CreateStatus_int_BytePointer() { allocate(); }
      private native void allocate();
      public native OrtStatus call(@Cast("OrtErrorCode") int code, @Cast("const char*") BytePointer msg);
  }
  public native CreateStatus_int_BytePointer CreateStatus(); public native OrtApi CreateStatus(CreateStatus_int_BytePointer setter);

  /** \brief Get OrtErrorCode from OrtStatus
  *
  * @param status [in]
  * @return OrtErrorCode that \p status was created with
  */
  public static class GetErrorCode_OrtStatus extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    GetErrorCode_OrtStatus(Pointer p) { super(p); }
      protected GetErrorCode_OrtStatus() { allocate(); }
      private native void allocate();
      public native @Cast("OrtErrorCode") int call(@Const OrtStatus status);
  }
  public native GetErrorCode_OrtStatus GetErrorCode(); public native OrtApi GetErrorCode(GetErrorCode_OrtStatus setter);

  /** \brief Get error string from OrtStatus
  *
  * @param status [in]
  * @return The error message inside the {@code status}. Do not free the returned value.
  */
  public static class GetErrorMessage_OrtStatus extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    GetErrorMessage_OrtStatus(Pointer p) { super(p); }
      protected GetErrorMessage_OrtStatus() { allocate(); }
      private native void allocate();
      public native @Cast("const char*") BytePointer call(@Const OrtStatus status);
  }
  public native GetErrorMessage_OrtStatus GetErrorMessage(); public native OrtApi GetErrorMessage(GetErrorMessage_OrtStatus setter);

  /** \}
   *  \name OrtEnv
   *  \{
  <p>
  /** \brief Create an OrtEnv
  *
  * @param log_severity_level [in] The log severity level.
  * @param logid [in] The log identifier.
  * @param out [out] Returned newly created OrtEnv. Must be freed with OrtApi::ReleaseEnv
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateEnv( @Cast("OrtLoggingLevel") int log_severity_level, @Cast("const char*") BytePointer logid, @Cast("OrtEnv**") PointerPointer out);
  public native OrtStatus CreateEnv( @Cast("OrtLoggingLevel") int log_severity_level, @Cast("const char*") BytePointer logid, @ByPtrPtr OrtEnv out);
  public native OrtStatus CreateEnv( @Cast("OrtLoggingLevel") int log_severity_level, String logid, @ByPtrPtr OrtEnv out);

  /** \brief Create an OrtEnv
  *
  * @param logging_function [in] A pointer to a logging function.
  * @param logger_param [in] A pointer to arbitrary data passed as the ::OrtLoggingFunction {@code param} parameter to
  *                         {@code logging_function}.
  * @param log_severity_level [in] The log severity level.
  * @param logid [in] The log identifier.
  * @param out [out] Returned newly created OrtEnv. Must be freed with OrtApi::ReleaseEnv
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateEnvWithCustomLogger( OrtLoggingFunction logging_function, Pointer logger_param,
                    @Cast("OrtLoggingLevel") int log_severity_level, @Cast("const char*") BytePointer logid, @Cast("OrtEnv**") PointerPointer out);
  public native OrtStatus CreateEnvWithCustomLogger( OrtLoggingFunction logging_function, Pointer logger_param,
                    @Cast("OrtLoggingLevel") int log_severity_level, @Cast("const char*") BytePointer logid, @ByPtrPtr OrtEnv out);
  public native OrtStatus CreateEnvWithCustomLogger( OrtLoggingFunction logging_function, Pointer logger_param,
                    @Cast("OrtLoggingLevel") int log_severity_level, String logid, @ByPtrPtr OrtEnv out);

  /** \brief Enable Telemetry
  *
  * \note Telemetry events are on by default since they are lightweight
  * @param env [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus EnableTelemetryEvents( @Const OrtEnv env);
  /** \brief Disable Telemetry
  *
  * @see OrtApi::EnableTelemetryEvents
  * @param env [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus DisableTelemetryEvents( @Const OrtEnv env);

  /** \}
   *  \name OrtSession
   *  \{
  <p>
  /** \brief Create an OrtSession from a model file
  *
  * @param env [in]
  * @param model_path [in]
  * @param options [in]
  * @param out [out] Returned newly created OrtSession. Must be freed with OrtApi::ReleaseSession
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  // TODO: document the path separator convention? '/' vs '\' */
  // TODO: should specify the access characteristics of model_path. Is this read only during the
  // execution of CreateSession, or does the OrtSession retain a handle to the file/directory
  // and continue to access throughout the OrtSession lifetime?
  //  What sort of access is needed to model_path : read or read/write?
  public native OrtStatus CreateSession( @Const OrtEnv env, @Cast("const ORTCHAR_T*") Pointer model_path,
                    @Const OrtSessionOptions options, @Cast("OrtSession**") PointerPointer out);
  public native OrtStatus CreateSession( @Const OrtEnv env, @Cast("const ORTCHAR_T*") Pointer model_path,
                    @Const OrtSessionOptions options, @ByPtrPtr OrtSession out);

  /** \brief Create an OrtSession from memory
  *
  * @param env [in]
  * @param model_data [in]
  * @param model_data_length [in]
  * @param options [in]
  * @param out [out] Returned newly created OrtSession. Must be freed with OrtApi::ReleaseSession
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateSessionFromArray( @Const OrtEnv env, @Const Pointer model_data, @Cast("size_t") long model_data_length,
                    @Const OrtSessionOptions options, @Cast("OrtSession**") PointerPointer out);
  public native OrtStatus CreateSessionFromArray( @Const OrtEnv env, @Const Pointer model_data, @Cast("size_t") long model_data_length,
                    @Const OrtSessionOptions options, @ByPtrPtr OrtSession out);

  /** \brief Run the model in an ::OrtSession
  *
  * Will not return until the model run has completed. Multiple threads might be used to run the model based on
  * the options in the ::OrtSession and settings used when creating the ::OrtEnv
  *
  * @param session [in]
  * @param run_options [in] If nullptr, will use a default ::OrtRunOptions
  * @param input_names [in] Array of null terminated UTF8 encoded strings of the input names
  * @param inputs [in] Array of ::OrtValue%s of the input values
  * @param input_len [in] Number of elements in the input_names and inputs arrays
  * @param output_names [in] Array of null terminated UTF8 encoded strings of the output names
  * @param output_names_len [in] Number of elements in the output_names and outputs array
  * @param outputs [out] Array of ::OrtValue%s that the outputs are stored in. This can also be
  *     an array of nullptr values, in this case ::OrtValue objects will be allocated and pointers
  *     to them will be set into the {@code outputs} array.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus Run( OrtSession session, @Const OrtRunOptions run_options,
                    @Cast("const char*const*") PointerPointer input_names,
                    @Cast("const OrtValue*const*") PointerPointer inputs, @Cast("size_t") long input_len,
                    @Cast("const char*const*") PointerPointer output_names, @Cast("size_t") long output_names_len,
                    @Cast("OrtValue**") PointerPointer outputs);
  public native OrtStatus Run( OrtSession session, @Const OrtRunOptions run_options,
                    @Cast("const char*const*") @ByPtrPtr BytePointer input_names,
                    @Const @ByPtrPtr OrtValue inputs, @Cast("size_t") long input_len,
                    @Cast("const char*const*") @ByPtrPtr BytePointer output_names, @Cast("size_t") long output_names_len,
                    @ByPtrPtr OrtValue outputs);
  public native OrtStatus Run( OrtSession session, @Const OrtRunOptions run_options,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer input_names,
                    @Const @ByPtrPtr OrtValue inputs, @Cast("size_t") long input_len,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer output_names, @Cast("size_t") long output_names_len,
                    @ByPtrPtr OrtValue outputs);
  public native OrtStatus Run( OrtSession session, @Const OrtRunOptions run_options,
                    @Cast("const char*const*") @ByPtrPtr byte[] input_names,
                    @Const @ByPtrPtr OrtValue inputs, @Cast("size_t") long input_len,
                    @Cast("const char*const*") @ByPtrPtr byte[] output_names, @Cast("size_t") long output_names_len,
                    @ByPtrPtr OrtValue outputs);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Create an ::OrtSessionOptions object
  *
  * To use additional providers, you must build ORT with the extra providers enabled. Then call one of these
  * functions to enable them in the session:<br>
  *   OrtSessionOptionsAppendExecutionProvider_CPU<br>
  *   OrtSessionOptionsAppendExecutionProvider_CUDA<br>
  *   OrtSessionOptionsAppendExecutionProvider_(remaining providers...)<br>
  * The order they are called indicates the preference order as well. In other words call this method
  * on your most preferred execution provider first followed by the less preferred ones.
  * If none are called Ort will use its internal CPU execution provider.
  *
  * @param options [out] The newly created OrtSessionOptions. Must be freed with OrtApi::ReleaseSessionOptions
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateSessionOptions( @Cast("OrtSessionOptions**") PointerPointer options);
  public native OrtStatus CreateSessionOptions( @ByPtrPtr OrtSessionOptions options);

  /** \brief Set filepath to save optimized model after graph level transformations
  *
  * @param options [in]
  * @param optimized_model_filepath [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetOptimizedModelFilePath( OrtSessionOptions options,
                    @Cast("const ORTCHAR_T*") Pointer optimized_model_filepath);

  /** \brief Create a copy of an existing ::OrtSessionOptions
  *
  * @param in_options [in] OrtSessionOptions to copy
  * @param out_options [out] Returned newly created ::OrtSessionOptions. Must be freed with OrtApi::ReleaseSessionOptions
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CloneSessionOptions( @Const OrtSessionOptions in_options,
                    @Cast("OrtSessionOptions**") PointerPointer out_options);
  public native OrtStatus CloneSessionOptions( @Const OrtSessionOptions in_options,
                    @ByPtrPtr OrtSessionOptions out_options);

  /** \brief Set execution mode
  *
  * Controls whether you want to execute operators in your graph sequentially or in parallel. Usually when the model
  *  has many branches, setting this option to ExecutionMode.ORT_PARALLEL will give you better performance.
  *  See [docs/ONNX_Runtime_Perf_Tuning.md] for more details.
  *
  * @param options [in]
  * @param execution_mode [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetSessionExecutionMode( OrtSessionOptions options, @Cast("ExecutionMode") int execution_mode);

  /** \brief Enable profiling for a session
  *
  * @param options [in]
  * @param profile_file_prefix [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus EnableProfiling( OrtSessionOptions options, @Cast("const ORTCHAR_T*") Pointer profile_file_prefix);

  /** \brief Disable profiling for a session
  *
  * @param options [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus DisableProfiling( OrtSessionOptions options);

  /** \brief Enable the memory pattern optimization
  *
  * The idea is if the input shapes are the same, we could trace the internal memory allocation
  * and generate a memory pattern for future request. So next time we could just do one allocation
  * with a big chunk for all the internal memory allocation.
  * \note Memory pattern optimization is only available when Sequential Execution mode is enabled (see OrtApi::SetSessionExecutionMode)
  *
  * @see OrtApi::DisableMemPattern
  *
  * @param options [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus EnableMemPattern( OrtSessionOptions options);

  /** \brief Disable the memory pattern optimization
  *
  * @see OrtApi::EnableMemPattern
  *
  * @param options [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus DisableMemPattern( OrtSessionOptions options);

  /** \brief Enable the memory arena on CPU
  *
  * Arena may pre-allocate memory for future usage.
  *
  * @param options [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus EnableCpuMemArena( OrtSessionOptions options);

  /** \brief Disable the memory arena on CPU
  *
  * @param options [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus DisableCpuMemArena( OrtSessionOptions options);

  /** \brief Set session log id
  *
  * @param options [in]
  * @param logid [in] The log identifier.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetSessionLogId( OrtSessionOptions options, @Cast("const char*") BytePointer logid);
  public native OrtStatus SetSessionLogId( OrtSessionOptions options, String logid);

  /** \brief Set session log verbosity level
  *
  * Applies to session load, initialization, etc
  *
  * @param options [in]
  * @param session_log_verbosity_level [in] \snippet{doc} snippets.dox Log Verbosity Level
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetSessionLogVerbosityLevel( OrtSessionOptions options, int session_log_verbosity_level);

  /** \brief Set session log severity level
  *
  * @param options [in]
  * @param session_log_severity_level [in] The log severity level (refer to ::OrtLoggingLevel for possible values).
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetSessionLogSeverityLevel( OrtSessionOptions options, int session_log_severity_level);

  /** \brief Set the optimization level to apply when loading a graph
  *
  * Please see https://www.onnxruntime.ai/docs/resources/graph-optimizations.html for an in-depth explanation
  * @param options [in,out] The session options object
  * @param graph_optimization_level [in] The optimization level
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetSessionGraphOptimizationLevel( OrtSessionOptions options,
                    @Cast("GraphOptimizationLevel") int graph_optimization_level);

  /** \brief Sets the number of threads used to parallelize the execution within nodes
  *
  * When running a single node operation, ex. add, this sets the maximum number of threads to use.
  *
  * \note If built with OpenMP, this has no effect on the number of threads used. In this case
  *       use the OpenMP env variables to configure the number of intra op num threads.
  *
  * @param options [in]
  * @param intra_op_num_threads [in] Number of threads to use<br>
  *   A value of 0 will use the default number of threads<br>
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetIntraOpNumThreads( OrtSessionOptions options, int intra_op_num_threads);

  /** \brief Sets the number of threads used to parallelize the execution of the graph
  *
  * If nodes can be run in parallel, this sets the maximum number of threads to use to run them in parallel.
  *
  * \note If sequential execution is enabled this value is ignored, it acts as if it was set to 1.
  *
  * @param options [in]
  * @param inter_op_num_threads [in] Number of threads to use<br>
  *   A value of 0 will use the default number of threads<br>
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetInterOpNumThreads( OrtSessionOptions options, int inter_op_num_threads);

  /** \}
   *  \name OrtCustomOpDomain
   *  \{
  <p>
  /** \brief Create a custom op domain
  *
  * @param domain [in]
  * @param out [out] Newly created domain. Must be freed with OrtApi::ReleaseCustomOpDomain
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateCustomOpDomain( @Cast("const char*") BytePointer domain, @Cast("OrtCustomOpDomain**") PointerPointer out);
  public native OrtStatus CreateCustomOpDomain( @Cast("const char*") BytePointer domain, @ByPtrPtr OrtCustomOpDomain out);
  public native OrtStatus CreateCustomOpDomain( String domain, @ByPtrPtr OrtCustomOpDomain out);

  /** \brief Add a custom op to a custom op domain
  *
  * \note The OrtCustomOp* pointer must remain valid until the ::OrtCustomOpDomain using it is released
  *
  * @param custom_op_domain [in]
  * @param op [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CustomOpDomain_Add( OrtCustomOpDomain custom_op_domain, @Const OrtCustomOp op);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Add custom op domain to a session options
  *
  * \note The OrtCustomOpDomain* must not be deleted until all sessions using it are released
  *
  * @param options [in]
  * @param custom_op_domain [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus AddCustomOpDomain( OrtSessionOptions options, OrtCustomOpDomain custom_op_domain);

  /** \brief Register custom ops from a shared library
  *
  * Loads a shared library (dll on windows, so on linux, etc) named 'library_path' and looks for this entry point:
  *		OrtStatus* RegisterCustomOps(OrtSessionOptions * options, const OrtApiBase* api);
  * It then passes in the provided session options to this function along with the api base.
  * The handle to the loaded library is returned in library_handle. It can be freed by the caller after all sessions using the passed in
  * session options are destroyed, or if an error occurs and it is non null.
  *
  * @param options [in]
  * @param library_path [in]
  * @param library_handle [out] OS specific handle to the loaded library (Use FreeLibrary on Windows, dlclose on Linux, etc.. to unload)
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus RegisterCustomOpsLibrary( OrtSessionOptions options, @Cast("const char*") BytePointer library_path, @Cast("void**") PointerPointer library_handle);
  public native OrtStatus RegisterCustomOpsLibrary( OrtSessionOptions options, @Cast("const char*") BytePointer library_path, @Cast("void**") @ByPtrPtr Pointer library_handle);
  public native OrtStatus RegisterCustomOpsLibrary( OrtSessionOptions options, String library_path, @Cast("void**") @ByPtrPtr Pointer library_handle);

  /** \}
   *  \name OrtSession
   *  \{
  <p>
  /** \brief Get input count for a session
  *
  * This number must also match the number of inputs passed to OrtApi::Run
  *
  * @see OrtApi::SessionGetInputTypeInfo, OrtApi::SessionGetInputName, OrtApi::Session
  *
  * @param session [in]
  * @param out [out] Number of inputs
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionGetInputCount( @Const OrtSession session, @Cast("size_t*") SizeTPointer out);

  /** \brief Get output count for a session
  *
  * This number must also match the number of outputs returned by OrtApi::Run
  *
  * @see OrtApi::SessionGetOutputTypeInfo, OrtApi::SessionGetOutputName, OrtApi::Session
  *
  * @param session [in]
  * @param out [out] Number of outputs
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionGetOutputCount( @Const OrtSession session, @Cast("size_t*") SizeTPointer out);

  /** \brief Get overridable initializer count
  *
  * @see OrtApi::SessionGetOverridableInitializerTypeInfo, OrtApi::SessionGetOverridableInitializerName
  *
  * @param session [in]
  * @param out [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionGetOverridableInitializerCount( @Const OrtSession session, @Cast("size_t*") SizeTPointer out);

  /** \brief Get input type information
  *
  * @param session [in]
  * @param index [in] Must be between 0 (inclusive) and what OrtApi::SessionGetInputCount returns (exclusive)
  * @param type_info [out] Must be freed with OrtApi::ReleaseTypeInfo
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionGetInputTypeInfo( @Const OrtSession session, @Cast("size_t") long index, @Cast("OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus SessionGetInputTypeInfo( @Const OrtSession session, @Cast("size_t") long index, @ByPtrPtr OrtTypeInfo type_info);

  /** \brief Get output type information
  *
  * @param session [in]
  * @param index [in] Must be between 0 (inclusive) and what OrtApi::SessionGetOutputCount returns (exclusive)
  * @param type_info [out] Must be freed with OrtApi::ReleaseTypeInfo
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionGetOutputTypeInfo( @Const OrtSession session, @Cast("size_t") long index, @Cast("OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus SessionGetOutputTypeInfo( @Const OrtSession session, @Cast("size_t") long index, @ByPtrPtr OrtTypeInfo type_info);

  /** \brief Get overridable initializer type information
  *
  * @param session [in]
  * @param index [in] Must be between 0 (inclusive) and what OrtApi::SessionGetOverridableInitializerCount returns (exclusive)
  * @param type_info [out] Must be freed with OrtApi::ReleaseTypeInfo
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionGetOverridableInitializerTypeInfo( @Const OrtSession session, @Cast("size_t") long index, @Cast("OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus SessionGetOverridableInitializerTypeInfo( @Const OrtSession session, @Cast("size_t") long index, @ByPtrPtr OrtTypeInfo type_info);

  /** \brief Get input name
  *
  * @param session [in]
  * @param index [in] Must be between 0 (inclusive) and what OrtApi::SessionGetInputCount returns (exclusive)
  * @param allocator [in]
  * @param value [out] Set to a null terminated UTF-8 encoded string allocated using {@code allocator}. Must be freed using {@code allocator}.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionGetInputName( @Const OrtSession session, @Cast("size_t") long index, OrtAllocator allocator, @Cast("char**") PointerPointer value);
  public native OrtStatus SessionGetInputName( @Const OrtSession session, @Cast("size_t") long index, OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus SessionGetInputName( @Const OrtSession session, @Cast("size_t") long index, OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus SessionGetInputName( @Const OrtSession session, @Cast("size_t") long index, OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] value);

  /** \brief Get output name
  *
  * @param session [in]
  * @param index [in] Must be between 0 (inclusive) and what OrtApi::SessionGetOutputCount returns (exclusive)
  * @param allocator [in]
  * @param value [out] Set to a null terminated UTF-8 encoded string allocated using {@code allocator}. Must be freed using {@code allocator}.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionGetOutputName( @Const OrtSession session, @Cast("size_t") long index, OrtAllocator allocator, @Cast("char**") PointerPointer value);
  public native OrtStatus SessionGetOutputName( @Const OrtSession session, @Cast("size_t") long index, OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus SessionGetOutputName( @Const OrtSession session, @Cast("size_t") long index, OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus SessionGetOutputName( @Const OrtSession session, @Cast("size_t") long index, OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] value);

  /** \brief Get overridable initializer name
  *
  * @param session [in]
  * @param index [in] Must be between 0 (inclusive) and what OrtApi::SessionGetOverridableInitializerCount returns (exclusive)
  * @param allocator [in]
  * @param value [out] Set to a null terminated UTF-8 encoded string allocated using {@code allocator}. Must be freed using {@code allocator}.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionGetOverridableInitializerName( @Const OrtSession session, @Cast("size_t") long index,
                    OrtAllocator allocator, @Cast("char**") PointerPointer value);
  public native OrtStatus SessionGetOverridableInitializerName( @Const OrtSession session, @Cast("size_t") long index,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus SessionGetOverridableInitializerName( @Const OrtSession session, @Cast("size_t") long index,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus SessionGetOverridableInitializerName( @Const OrtSession session, @Cast("size_t") long index,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] value);

  /** \}
   *  \name OrtRunOptions
   *  \{
  <p>
  /** \brief Create an OrtRunOptions
  *
  * @param out [out] Returned newly created ::OrtRunOptions. Must be freed with OrtApi::ReleaseRunOptions
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateRunOptions( @Cast("OrtRunOptions**") PointerPointer out);
  public native OrtStatus CreateRunOptions( @ByPtrPtr OrtRunOptions out);

  /** \brief Set per-run log verbosity level
   *
   * @see OrtApi::RunOptionsGetRunLogVerbosityLevel
   *
   * @param options [in]
   * @param log_verbosity_level [in] \snippet{doc} snippets.dox Log Verbosity Level
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus RunOptionsSetRunLogVerbosityLevel( OrtRunOptions options, int log_verbosity_level);

  /** \brief Set per-run log severity level
   *
   * @see OrtApi::RunOptionsGetRunLogSeverityLevel
   *
   * @param options [in]
   * @param log_severity_level [in] The log severity level (refer to ::OrtLoggingLevel for possible values).
   */
  public native OrtStatus RunOptionsSetRunLogSeverityLevel( OrtRunOptions options, int log_severity_level);

  /** \brief Set per-run tag
   *
   * This is used in a per-run log identifier.
   *
   * @see OrtApi::RunOptionsGetRunTag
   *
   * @param options [in]
   * @param run_tag [in] The run tag.
   */
  public native OrtStatus RunOptionsSetRunTag( OrtRunOptions options, @Cast("const char*") BytePointer run_tag);
  public native OrtStatus RunOptionsSetRunTag( OrtRunOptions options, String run_tag);

  /** \brief Get per-run log verbosity level
   *
   * @see OrtApi::RunOptionsSetRunLogVerbosityLevel
   *
   * @param options [in]
   * @param log_verbosity_level [out] \snippet{doc} snippets.dox Log Verbosity Level
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus RunOptionsGetRunLogVerbosityLevel( @Const OrtRunOptions options,
                    IntPointer log_verbosity_level);
  public native OrtStatus RunOptionsGetRunLogVerbosityLevel( @Const OrtRunOptions options,
                    IntBuffer log_verbosity_level);
  public native OrtStatus RunOptionsGetRunLogVerbosityLevel( @Const OrtRunOptions options,
                    int[] log_verbosity_level);

  /** \brief Get per-run log severity level
   *
   * @see OrtApi::RunOptionsSetRunLogSeverityLevel
   *
   * @param options [in]
   * @param log_severity_level [out] The log severity level (refer to ::OrtLoggingLevel for possible values).
   */
  public native OrtStatus RunOptionsGetRunLogSeverityLevel( @Const OrtRunOptions options, IntPointer log_severity_level);
  public native OrtStatus RunOptionsGetRunLogSeverityLevel( @Const OrtRunOptions options, IntBuffer log_severity_level);
  public native OrtStatus RunOptionsGetRunLogSeverityLevel( @Const OrtRunOptions options, int[] log_severity_level);

  /** \brief Get per-run tag
   *
   * This is used in a per-run log identifier.
   *
   * @see OrtApi::RunOptionsSetRunTag
   *
   * @param options [in]
   * @param run_tag [out] The run tag.
   *                     Do not free this value, it is owned by {@code options}. It will be invalidated if the run tag
   *                     changes (i.e., with OrtApi::RunOptionsSetRunTag) or {@code options} is freed.
   */
  public native OrtStatus RunOptionsGetRunTag( @Const OrtRunOptions options, @Cast("const char**") PointerPointer run_tag);
  public native OrtStatus RunOptionsGetRunTag( @Const OrtRunOptions options, @Cast("const char**") @ByPtrPtr BytePointer run_tag);
  public native OrtStatus RunOptionsGetRunTag( @Const OrtRunOptions options, @Cast("const char**") @ByPtrPtr ByteBuffer run_tag);
  public native OrtStatus RunOptionsGetRunTag( @Const OrtRunOptions options, @Cast("const char**") @ByPtrPtr byte[] run_tag);

  /** \brief Set terminate flag
  *
  * If a currently executing session needs to be force terminated, this can be called from another thread to force it to fail with an error.
  *
  * @param options [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus RunOptionsSetTerminate( OrtRunOptions options);

  /** \brief Clears the terminate flag
  *
  * Used so the OrtRunOptions instance can be used in a new OrtApi::Run call without it instantly terminating
  *
  * @param options [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus RunOptionsUnsetTerminate( OrtRunOptions options);

  /** \}
   *  \name OrtValue
   *  \{
  <p>
  /** \brief Create a tensor
  *
  * Create a tensor using a supplied ::OrtAllocator
  *
  * @param allocator [in]
  * @param shape [in] Tensor shape
  * @param shape_len [in] Number of elements in {@code shape}
  * @param type [in]
  * @param out [out] Returns newly created ::OrtValue. Must be freed with OrtApi::ReleaseValue
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateTensorAsOrtValue( OrtAllocator allocator, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len,
                    @Cast("ONNXTensorElementDataType") int type, @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus CreateTensorAsOrtValue( OrtAllocator allocator, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len,
                    @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);
  public native OrtStatus CreateTensorAsOrtValue( OrtAllocator allocator, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len,
                    @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);
  public native OrtStatus CreateTensorAsOrtValue( OrtAllocator allocator, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len,
                    @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);

  /** \brief Create a tensor backed by a user supplied buffer
   *
   * Create a tensor with user's buffer. You can fill the buffer either before calling this function or after.
   * p_data is owned by caller. ReleaseValue won't release p_data.
   *
   * @param info [in]
   * @param p_data [in]
   * @param p_data_len [in]
   * @param shape [in]
   * @param shape_len [in]
   * @param type [in]
   * @param out [out] Returns newly created ::OrtValue. Must be freed with OrtApi::ReleaseValue
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateTensorWithDataAsOrtValue( @Const OrtMemoryInfo info, Pointer p_data,
                    @Cast("size_t") long p_data_len, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len, @Cast("ONNXTensorElementDataType") int type,
                    @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus CreateTensorWithDataAsOrtValue( @Const OrtMemoryInfo info, Pointer p_data,
                    @Cast("size_t") long p_data_len, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len, @Cast("ONNXTensorElementDataType") int type,
                    @ByPtrPtr OrtValue out);
  public native OrtStatus CreateTensorWithDataAsOrtValue( @Const OrtMemoryInfo info, Pointer p_data,
                    @Cast("size_t") long p_data_len, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len, @Cast("ONNXTensorElementDataType") int type,
                    @ByPtrPtr OrtValue out);
  public native OrtStatus CreateTensorWithDataAsOrtValue( @Const OrtMemoryInfo info, Pointer p_data,
                    @Cast("size_t") long p_data_len, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len, @Cast("ONNXTensorElementDataType") int type,
                    @ByPtrPtr OrtValue out);

  /** \brief Return if an ::OrtValue is a tensor type
  *
  * @param value [in] A tensor type (string tensors are not supported)
  * @param out [out] Set to 1 iff ::OrtValue is a tensor, 0 otherwise
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus IsTensor( @Const OrtValue value, IntPointer out);
  public native OrtStatus IsTensor( @Const OrtValue value, IntBuffer out);
  public native OrtStatus IsTensor( @Const OrtValue value, int[] out);

  /** \brief Get a pointer to the raw data inside a tensor
  *
  * Used to read/write/modify the internal tensor data directly.
  * \note The returned pointer is valid until the \p value is destroyed.
  *
  * @param value [in] A tensor type (string tensors are not supported)
  * @param out [out] Filled in with a pointer to the internal storage
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetTensorMutableData( OrtValue value, @Cast("void**") PointerPointer out);
  public native OrtStatus GetTensorMutableData( OrtValue value, @Cast("void**") @ByPtrPtr Pointer out);

  /** \brief Set all strings at once in a string tensor
  *
  * @param value [in,out] A tensor of type ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING
  * @param s [in] An array of strings. Each string in this array must be null terminated.
  * @param s_len [in] Count of strings in s (Must match the size of \p value's tensor shape)
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus FillStringTensor( OrtValue value, @Cast("const char*const*") PointerPointer s, @Cast("size_t") long s_len);
  public native OrtStatus FillStringTensor( OrtValue value, @Cast("const char*const*") @ByPtrPtr BytePointer s, @Cast("size_t") long s_len);
  public native OrtStatus FillStringTensor( OrtValue value, @Cast("const char*const*") @ByPtrPtr ByteBuffer s, @Cast("size_t") long s_len);
  public native OrtStatus FillStringTensor( OrtValue value, @Cast("const char*const*") @ByPtrPtr byte[] s, @Cast("size_t") long s_len);

  /** \brief Get total byte length for all strings in a string tensor
  *
  * Typically used with OrtApi::GetStringTensorContent
  *
  * @param value [in] A tensor of type ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING
  * @param len [out] Total byte length of all strings (does not include trailing nulls)
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetStringTensorDataLength( @Const OrtValue value, @Cast("size_t*") SizeTPointer len);

  /** \brief Get all strings from a string tensor
  *
  * An example of the results:<br>
  * Given \p value is a string tensor with the strings { "This" "is" "a" "test" }<br>
  * \p s must have a size of 11 bytes<br>
  * \p offsets must have 4 elements<br>
  * After the call, these values will be filled in:<br>
  * \p s will contain "Thisisatest"<br>
  * \p offsets will contain { 0, 4, 6, 7 }<br>
  * The length of the last string is just s_len - offsets[last]
  *
  * @param value [in] A tensor of type ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING
  * @param s [in] Buffer to sequentially write all tensor strings to. Each string is NOT null-terminated.
  * @param s_len [in] Number of bytes of buffer pointed to by \p s (Get it from OrtApi::GetStringTensorDataLength)
  * @param offsets [out] Array of start offsets into the strings written to \p s
  * @param offsets_len [in] Number of elements in offsets
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetStringTensorContent( @Const OrtValue value, Pointer s,
                    @Cast("size_t") long s_len, @Cast("size_t*") SizeTPointer offsets, @Cast("size_t") long offsets_len);

  /** \}
   *  \name OrtTypeInfo
   *  \{
  <p>
  /** \brief Get ::OrtTensorTypeAndShapeInfo from an ::OrtTypeInfo
  *
  * @param type_info [in]
  * @param out [out] Do not free this value, it will be valid until type_info is freed.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CastTypeInfoToTensorInfo( @Const OrtTypeInfo type_info,
                    @Cast("const OrtTensorTypeAndShapeInfo**") PointerPointer out);
  public native OrtStatus CastTypeInfoToTensorInfo( @Const OrtTypeInfo type_info,
                    @Const @ByPtrPtr OrtTensorTypeAndShapeInfo out);

  /** \brief Get ::ONNXType from ::OrtTypeInfo
  *
  * @param type_info [in]
  * @param out [out]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetOnnxTypeFromTypeInfo( @Const OrtTypeInfo type_info, @Cast("ONNXType*") IntPointer out);
  public native OrtStatus GetOnnxTypeFromTypeInfo( @Const OrtTypeInfo type_info, @Cast("ONNXType*") IntBuffer out);
  public native OrtStatus GetOnnxTypeFromTypeInfo( @Const OrtTypeInfo type_info, @Cast("ONNXType*") int[] out);

  /** \}
   *  \name OrtTensorTypeAndShapeInfo
   *  \{
  <p>
  /** \brief Create an ::OrtTensorTypeAndShapeInfo object
  *
  * @param out [out] Returns newly created ::OrtTensorTypeAndShapeInfo. Must be freed with OrtApi::ReleaseTensorTypeAndShapeInfo
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateTensorTypeAndShapeInfo( @Cast("OrtTensorTypeAndShapeInfo**") PointerPointer out);
  public native OrtStatus CreateTensorTypeAndShapeInfo( @ByPtrPtr OrtTensorTypeAndShapeInfo out);

  /** \brief Set element type in ::OrtTensorTypeAndShapeInfo
  *
  * @param info [in]
  * @param type [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetTensorElementType( OrtTensorTypeAndShapeInfo info, @Cast("ONNXTensorElementDataType") int type);

  /** \brief Set shape information in ::OrtTensorTypeAndShapeInfo
  *
  * @param info [in]
  * @param dim_values [in] Array with {@code dim_count} elements. Can contain negative values.
  * @param dim_count [in] Number of elements in {@code dim_values}
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetDimensions( OrtTensorTypeAndShapeInfo info, @Cast("const int64_t*") LongPointer dim_values, @Cast("size_t") long dim_count);
  public native OrtStatus SetDimensions( OrtTensorTypeAndShapeInfo info, @Cast("const int64_t*") LongBuffer dim_values, @Cast("size_t") long dim_count);
  public native OrtStatus SetDimensions( OrtTensorTypeAndShapeInfo info, @Cast("const int64_t*") long[] dim_values, @Cast("size_t") long dim_count);

  /** \brief Get element type in ::OrtTensorTypeAndShapeInfo
  *
  * @see OrtApi::SetTensorElementType
  *
  * @param info [in]
  * @param out [out]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetTensorElementType( @Const OrtTensorTypeAndShapeInfo info,
                    @Cast("ONNXTensorElementDataType*") IntPointer out);
  public native OrtStatus GetTensorElementType( @Const OrtTensorTypeAndShapeInfo info,
                    @Cast("ONNXTensorElementDataType*") IntBuffer out);
  public native OrtStatus GetTensorElementType( @Const OrtTensorTypeAndShapeInfo info,
                    @Cast("ONNXTensorElementDataType*") int[] out);

  /** \brief Get dimension count in ::OrtTensorTypeAndShapeInfo
  *
  * @see OrtApi::GetDimensions
  *
  * @param info [in]
  * @param out [out]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetDimensionsCount( @Const OrtTensorTypeAndShapeInfo info, @Cast("size_t*") SizeTPointer out);

  /** \brief Get dimensions in ::OrtTensorTypeAndShapeInfo
  *
  * @param info [in]
  * @param dim_values [out] Array with {@code dim_values_length} elements. On return, filled with the dimensions stored in the ::OrtTensorTypeAndShapeInfo
  * @param dim_values_length [in] Number of elements in {@code dim_values}. Use OrtApi::GetDimensionsCount to get this value
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetDimensions( @Const OrtTensorTypeAndShapeInfo info, @Cast("int64_t*") LongPointer dim_values,
                    @Cast("size_t") long dim_values_length);
  public native OrtStatus GetDimensions( @Const OrtTensorTypeAndShapeInfo info, @Cast("int64_t*") LongBuffer dim_values,
                    @Cast("size_t") long dim_values_length);
  public native OrtStatus GetDimensions( @Const OrtTensorTypeAndShapeInfo info, @Cast("int64_t*") long[] dim_values,
                    @Cast("size_t") long dim_values_length);

  /** \brief Get symbolic dimension names in ::OrtTensorTypeAndShapeInfo
  *
  * @param info [in]
  * @param dim_params [in] Array with {@code dim_params_length} elements. On return filled with pointers to null terminated strings of the dimension names
  * @param dim_params_length [in] Number of elements in {@code dim_params}. Use OrtApi::GetDimensionsCount to get this value
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetSymbolicDimensions( @Const OrtTensorTypeAndShapeInfo info,
                    @Cast("const char**") PointerPointer dim_params, @Cast("size_t") long dim_params_length);
  public native OrtStatus GetSymbolicDimensions( @Const OrtTensorTypeAndShapeInfo info,
                    @Cast("const char**") @ByPtrPtr BytePointer dim_params, @Cast("size_t") long dim_params_length);
  public native OrtStatus GetSymbolicDimensions( @Const OrtTensorTypeAndShapeInfo info,
                    @Cast("const char**") @ByPtrPtr ByteBuffer dim_params, @Cast("size_t") long dim_params_length);
  public native OrtStatus GetSymbolicDimensions( @Const OrtTensorTypeAndShapeInfo info,
                    @Cast("const char**") @ByPtrPtr byte[] dim_params, @Cast("size_t") long dim_params_length);

  /** \brief Get total number of elements in a tensor shape from an ::OrtTensorTypeAndShapeInfo
  *
  * Return the number of elements specified by the tensor shape (all dimensions multiplied by each other).
  * For 0 dimensions, 1 is returned. If any dimension is less than 0, the result is always -1.
  *
  * Examples:<br>
  * [] = 1<br>
  * [1,3,4] = 12<br>
  * [2,0,4] = 0<br>
  * [-1,3,4] = -1<br>
  *
  * @param info [in]
  * @param out [out] Number of elements
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetTensorShapeElementCount( @Const OrtTensorTypeAndShapeInfo info, @Cast("size_t*") SizeTPointer out);

  /** \}
   *  \name OrtValue
   *  \{
  <p>
  /** \brief Get type and shape information from a tensor ::OrtValue
  *
  * @param value [in] Must be a tensor (not a map/sequence/etc) or will return failure
  * @param out [out] Newly created ::OrtTensorTypeAndShapeInfo. Must be freed with OrtApi::ReleaseTensorTypeAndShapeInfo
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetTensorTypeAndShape( @Const OrtValue value, @Cast("OrtTensorTypeAndShapeInfo**") PointerPointer out);
  public native OrtStatus GetTensorTypeAndShape( @Const OrtValue value, @ByPtrPtr OrtTensorTypeAndShapeInfo out);

  /** \brief Get type information of an OrtValue
  *
  * @param value [in]
  * @param out [out] Newly created ::OrtTypeInfo. Must be freed with OrtApi::ReleaseTypeInfo
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetTypeInfo( @Const OrtValue value, @Cast("OrtTypeInfo**") PointerPointer out);
  public native OrtStatus GetTypeInfo( @Const OrtValue value, @ByPtrPtr OrtTypeInfo out);

  /** \brief Get ONNXType of an ::OrtValue
  *
  * @param value [in]
  * @param out [out]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetValueType( @Const OrtValue value, @Cast("ONNXType*") IntPointer out);
  public native OrtStatus GetValueType( @Const OrtValue value, @Cast("ONNXType*") IntBuffer out);
  public native OrtStatus GetValueType( @Const OrtValue value, @Cast("ONNXType*") int[] out);

  /** \}
   *  \name OrtMemoryInfo
   *  \{
  <p>
  /** \brief Create an ::OrtMemoryInfo
  *
  * @param name [in]
  * @param type [in]
  * @param id [in]
  * @param mem_type [in]
  * @param out [out] Newly created ::OrtMemoryInfo. Must be freed with OrtAPi::ReleaseMemoryInfo
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateMemoryInfo( @Cast("const char*") BytePointer name, @Cast("OrtAllocatorType") int type, int id,
                    @Cast("OrtMemType") int mem_type, @Cast("OrtMemoryInfo**") PointerPointer out);
  public native OrtStatus CreateMemoryInfo( @Cast("const char*") BytePointer name, @Cast("OrtAllocatorType") int type, int id,
                    @Cast("OrtMemType") int mem_type, @ByPtrPtr OrtMemoryInfo out);
  public native OrtStatus CreateMemoryInfo( String name, @Cast("OrtAllocatorType") int type, int id,
                    @Cast("OrtMemType") int mem_type, @ByPtrPtr OrtMemoryInfo out);

  /** \brief Create an ::OrtMemoryInfo for CPU memory
  *
  * Special case version of OrtApi::CreateMemoryInfo for CPU based memory. Same as using OrtApi::CreateMemoryInfo with name = "Cpu" and id = 0.
  *
  * @param type [in]
  * @param mem_type [in]
  * @param out [out]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateCpuMemoryInfo( @Cast("OrtAllocatorType") int type, @Cast("OrtMemType") int mem_type,
                    @Cast("OrtMemoryInfo**") PointerPointer out);
  public native OrtStatus CreateCpuMemoryInfo( @Cast("OrtAllocatorType") int type, @Cast("OrtMemType") int mem_type,
                    @ByPtrPtr OrtMemoryInfo out);

  /** \brief Compare ::OrtMemoryInfo objects for equality
  *
  * Compares all settings of each ::OrtMemoryInfo for equality
  *
  * @param info [in] 1
  * @param info [in] 2
  * @param out [out] Set to 0 if equal, -1 if not equal
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CompareMemoryInfo( @Const OrtMemoryInfo info1, @Const OrtMemoryInfo info2, IntPointer out);
  public native OrtStatus CompareMemoryInfo( @Const OrtMemoryInfo info1, @Const OrtMemoryInfo info2, IntBuffer out);
  public native OrtStatus CompareMemoryInfo( @Const OrtMemoryInfo info1, @Const OrtMemoryInfo info2, int[] out);

  /** \brief Get name from ::OrtMemoryInfo
  *
  * @param ptr [in]
  * @param out [out] Writes null terminated string to this pointer. Do NOT free the returned pointer. It is valid for the lifetime of the ::OrtMemoryInfo
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus MemoryInfoGetName( @Const OrtMemoryInfo ptr, @Cast("const char**") PointerPointer out);
  public native OrtStatus MemoryInfoGetName( @Const OrtMemoryInfo ptr, @Cast("const char**") @ByPtrPtr BytePointer out);
  public native OrtStatus MemoryInfoGetName( @Const OrtMemoryInfo ptr, @Cast("const char**") @ByPtrPtr ByteBuffer out);
  public native OrtStatus MemoryInfoGetName( @Const OrtMemoryInfo ptr, @Cast("const char**") @ByPtrPtr byte[] out);

  /** \brief Get the id from ::OrtMemoryInfo
  */
  public native OrtStatus MemoryInfoGetId( @Const OrtMemoryInfo ptr, IntPointer out);
  public native OrtStatus MemoryInfoGetId( @Const OrtMemoryInfo ptr, IntBuffer out);
  public native OrtStatus MemoryInfoGetId( @Const OrtMemoryInfo ptr, int[] out);

  /** \brief Get the ::OrtMemType from ::OrtMemoryInfo
  */
  public native OrtStatus MemoryInfoGetMemType( @Const OrtMemoryInfo ptr, @Cast("OrtMemType*") IntPointer out);
  public native OrtStatus MemoryInfoGetMemType( @Const OrtMemoryInfo ptr, @Cast("OrtMemType*") IntBuffer out);
  public native OrtStatus MemoryInfoGetMemType( @Const OrtMemoryInfo ptr, @Cast("OrtMemType*") int[] out);

  /** \brief Get the ::OrtAllocatorType from ::OrtMemoryInfo
  */
  public native OrtStatus MemoryInfoGetType( @Const OrtMemoryInfo ptr, @Cast("OrtAllocatorType*") IntPointer out);
  public native OrtStatus MemoryInfoGetType( @Const OrtMemoryInfo ptr, @Cast("OrtAllocatorType*") IntBuffer out);
  public native OrtStatus MemoryInfoGetType( @Const OrtMemoryInfo ptr, @Cast("OrtAllocatorType*") int[] out);

  /** \}
   *  \name OrtAllocator
   *  \{
   <p>
   *  \brief Calls OrtAllocator::Alloc function */
  public native OrtStatus AllocatorAlloc( OrtAllocator ort_allocator, @Cast("size_t") long size, @Cast("void**") PointerPointer out);
  public native OrtStatus AllocatorAlloc( OrtAllocator ort_allocator, @Cast("size_t") long size, @Cast("void**") @ByPtrPtr Pointer out);
  /** \brief Calls OrtAllocator::Free function */
  public native OrtStatus AllocatorFree( OrtAllocator ort_allocator, Pointer p);
  /** \brief Calls OrtAllocator::Info function */
  public native OrtStatus AllocatorGetInfo( @Const OrtAllocator ort_allocator, @Cast("const OrtMemoryInfo**") PointerPointer out);
  public native OrtStatus AllocatorGetInfo( @Const OrtAllocator ort_allocator, @Const @ByPtrPtr OrtMemoryInfo out);

  /** \brief Get the default allocator
  *
  * The default allocator is a CPU based, non-arena. Always returns the same pointer to the same default allocator.
  *
  * @param out [out] Returned value should NOT be freed
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetAllocatorWithDefaultOptions( @Cast("OrtAllocator**") PointerPointer out);
  public native OrtStatus GetAllocatorWithDefaultOptions( @ByPtrPtr OrtAllocator out);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Override session symbolic dimensions
  *
  * Override symbolic dimensions (by specific denotation strings) with actual values if known at session initialization time to enable
  * optimizations that can take advantage of fixed values (such as memory planning, etc)
  *
  * @param options [in]
  * @param dim_denotation [in]
  * @param dim_value [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus AddFreeDimensionOverride( OrtSessionOptions options, @Cast("const char*") BytePointer dim_denotation,
                    @Cast("int64_t") long dim_value);
  public native OrtStatus AddFreeDimensionOverride( OrtSessionOptions options, String dim_denotation,
                    @Cast("int64_t") long dim_value);

  /** \}
   *  \name OrtValue
   *  \{ */

  /* Internal information (not seen in Doxygen)
  *
  * APIs to support non-tensor types - map and sequence.
  * Currently only the following types are supported
  * Note: the following types should be kept in sync with data_types.h
  * Map types
  * =========
  * std::map<std::string, std::string>
  * std::map<std::string, int64_t>
  * std::map<std::string, float>
  * std::map<std::string, double>
  * std::map<int64_t, std::string>
  * std::map<int64_t, int64_t>
  * std::map<int64_t, float>
  * std::map<int64_t, double>
  *
  * Sequence types
  * ==============
  * std::vector<std::string>
  * std::vector<int64_t>
  * std::vector<float>
  * std::vector<double>
  * std::vector<std::map<std::string, float>>
  * std::vector<std::map<int64_t, float>
  */

  /** \brief Get non tensor data from an ::OrtValue
  *
  * If {@code value} is of type ONNX_TYPE_MAP, you need to retrieve the keys and values
  * separately. Use index=0 to retrieve keys and index=1 to retrieve values.
  * If {@code value} is of type ONNX_TYPE_SEQUENCE, use index to retrieve the index'th element
  * of the sequence.
  *
  * @param value [in]
  * @param index [in] See above for usage based on {@code value} type
  * @param allocator [in] Allocator used to allocate ::OrtValue
  * @param out [out] Created ::OrtValue that holds the element requested. Must be freed with OrtApi::ReleaseValue
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetValue( @Const OrtValue value, int index, OrtAllocator allocator,
                    @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus GetValue( @Const OrtValue value, int index, OrtAllocator allocator,
                    @ByPtrPtr OrtValue out);

  /** \brief Get non tensor value count from an ::OrtValue
  *
  * If {@code value} is of type ONNX_TYPE_MAP 2 will always be returned. For ONNX_TYPE_SEQUENCE
  * the number of elements in the sequence will be returned
  *
  * @param value [in]
  * @param out [out]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetValueCount( @Const OrtValue value, @Cast("size_t*") SizeTPointer out);

  /** \brief Create a map or sequence ::OrtValue
  *
  * To construct a map (ONNX_TYPE_MAP), use num_values = 2 and {@code in} should be an array of 2 ::OrtValue%s
  * representing keys and values.<br>
  *
  * To construct a sequence (ONNX_TYPE_SEQUENCE), use num_values = N where N is the number of the elements in the
  * sequence. 'in' should be an array of N ::OrtValue%s.
  *
  * @param in [in] See above for details
  * @param num_values [in]
  * @param value_type [in] Must be either ONNX_TYPE_MAP or ONNX_TYPE_SEQUENCE
  * @param out [out] Newly created ::OrtValue. Must be freed with OrtApi::ReleaseValue
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateValue( @Cast("const OrtValue*const*") PointerPointer in, @Cast("size_t") long num_values,
                    @Cast("ONNXType") int value_type, @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus CreateValue( @Const @ByPtrPtr OrtValue in, @Cast("size_t") long num_values,
                    @Cast("ONNXType") int value_type, @ByPtrPtr OrtValue out);

  /** \brief Create an opaque (custom user defined type) ::OrtValue
  *
  * Constructs an ::OrtValue that contains a value of non-standard type created for
  * experiments or while awaiting standardization. ::OrtValue in this case would contain
  * an internal representation of the Opaque type. Opaque types are distinguished from
  * each other by two strings 1) domain and 2) type name. The combination of the two
  * must be unique, so the type representation is properly identified internally. The combination
  * must be properly registered from within ORT at both compile/run time or by another API.
  *
  * To construct the ::OrtValue pass domain and type names, also a pointer to a data container
  * the type of which must be known to both ORT and the client program. That data container may or may
  * not match the internal representation of the Opaque type. The sizeof(data_container) is passed for
  * verification purposes.
  *
  * @param domain_name [in] Null terminated string of the domain name
  * @param type_name [in] Null terminated string of the type name
  * @param data_container [in] User pointer Data to populate ::OrtValue
  * @param data_container_size [in] Size in bytes of what {@code data_container} points to
  * @param out [out] Newly created ::OrtValue. Must be freed with OrtApi::ReleaseValue
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateOpaqueValue( @Cast("const char*") BytePointer domain_name, @Cast("const char*") BytePointer type_name,
                    @Const Pointer data_container, @Cast("size_t") long data_container_size, @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus CreateOpaqueValue( @Cast("const char*") BytePointer domain_name, @Cast("const char*") BytePointer type_name,
                    @Const Pointer data_container, @Cast("size_t") long data_container_size, @ByPtrPtr OrtValue out);
  public native OrtStatus CreateOpaqueValue( String domain_name, String type_name,
                    @Const Pointer data_container, @Cast("size_t") long data_container_size, @ByPtrPtr OrtValue out);

  /** \brief Get internal data from an opaque (custom user defined type) ::OrtValue
  *
  * Copies internal data from an opaque value into a user provided buffer
  *
  * @see OrtApi::CreateOpaqueValue
  *
  * @param domain_name [in] Null terminated string of the domain name
  * @param type_name [in] Null terminated string of the type name
  * @param in [in] The opaque ::OrtValue
  * @param data_container [out] Buffer to copy data into
  * @param data_container_size [out] Size in bytes of the buffer pointed to by data_container. Must match the size of the internal buffer.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetOpaqueValue( @Cast("const char*") BytePointer domain_name, @Cast("const char*") BytePointer type_name, @Const OrtValue in,
                    Pointer data_container, @Cast("size_t") long data_container_size);
  public native OrtStatus GetOpaqueValue( String domain_name, String type_name, @Const OrtValue in,
                    Pointer data_container, @Cast("size_t") long data_container_size);

  /** \}
   *  \name OrtKernelInfo
   *  \{
  <p>
  /** \brief Get a float stored as an attribute in the graph node
  *
  * @param info [in] ::OrtKernelInfo instance
  * @param name [in] Null terminated string of the name of the attribute
  * @param out [out] Pointer to memory where the attribute will be stored
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus KernelInfoGetAttribute_float( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    FloatPointer out);
  public native OrtStatus KernelInfoGetAttribute_float( @Const OrtKernelInfo info, String name,
                    FloatBuffer out);
  public native OrtStatus KernelInfoGetAttribute_float( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    float[] out);
  public native OrtStatus KernelInfoGetAttribute_float( @Const OrtKernelInfo info, String name,
                    FloatPointer out);
  public native OrtStatus KernelInfoGetAttribute_float( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    FloatBuffer out);
  public native OrtStatus KernelInfoGetAttribute_float( @Const OrtKernelInfo info, String name,
                    float[] out);

  /** \brief Fetch a 64-bit int stored as an attribute in the graph node
  *
  * @param info [in] ::OrtKernelInfo instance
  * @param name [in] Null terminated string of the name of the attribute
  * @param out [out] Pointer to memory where the attribute will be stored
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus KernelInfoGetAttribute_int64( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    @Cast("int64_t*") LongPointer out);
  public native OrtStatus KernelInfoGetAttribute_int64( @Const OrtKernelInfo info, String name,
                    @Cast("int64_t*") LongBuffer out);
  public native OrtStatus KernelInfoGetAttribute_int64( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    @Cast("int64_t*") long[] out);
  public native OrtStatus KernelInfoGetAttribute_int64( @Const OrtKernelInfo info, String name,
                    @Cast("int64_t*") LongPointer out);
  public native OrtStatus KernelInfoGetAttribute_int64( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    @Cast("int64_t*") LongBuffer out);
  public native OrtStatus KernelInfoGetAttribute_int64( @Const OrtKernelInfo info, String name,
                    @Cast("int64_t*") long[] out);

  /** \brief Fetch a string stored as an attribute in the graph node
  *
  * If {@code out} is nullptr, the value of {@code size} is set to the true size of the string
  * attribute, and a success status is returned.
  *
  * If the {@code size} parameter is greater than or equal to the actual string attribute's size,
  * the value of {@code size} is set to the true size of the string attribute, the provided memory
  * is filled with the attribute's contents, and a success status is returned.
  *
  * If the {@code size} parameter is less than the actual string attribute's size and {@code out}
  * is not nullptr, the value of {@code size} is set to the true size of the string attribute
  * and a failure status is returned.)
  *
  * @param info [in] ::OrtKernelInfo instance
  * @param name [in] Null terminated string of the name of the attribute
  * @param out [out] Pointer to memory where the attribute will be stored
  * @param size [in,out] See above comments for details
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus KernelInfoGetAttribute_string( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name, @Cast("char*") BytePointer out,
                    @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttribute_string( @Const OrtKernelInfo info, String name, @Cast("char*") ByteBuffer out,
                    @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttribute_string( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name, @Cast("char*") byte[] out,
                    @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttribute_string( @Const OrtKernelInfo info, String name, @Cast("char*") BytePointer out,
                    @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttribute_string( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name, @Cast("char*") ByteBuffer out,
                    @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttribute_string( @Const OrtKernelInfo info, String name, @Cast("char*") byte[] out,
                    @Cast("size_t*") SizeTPointer size);

  /** \}
   *  \name OrtKernelContext
   *  \{
  <p>
  /** \brief Used for custom operators, get the input count of a kernel
  *
  * @see ::OrtCustomOp
  */
  public native OrtStatus KernelContext_GetInputCount( @Const OrtKernelContext context, @Cast("size_t*") SizeTPointer out);

  /** \brief Used for custom operators, get the output count of a kernel
  *
  * @see ::OrtCustomOp
  */
  public native OrtStatus KernelContext_GetOutputCount( @Const OrtKernelContext context, @Cast("size_t*") SizeTPointer out);

  /** \brief Used for custom operators, get an input of a kernel
  *
  * @see ::OrtCustomOp
  */
  public native OrtStatus KernelContext_GetInput( @Const OrtKernelContext context, @Cast("size_t") long index,
                    @Cast("const OrtValue**") PointerPointer out);
  public native OrtStatus KernelContext_GetInput( @Const OrtKernelContext context, @Cast("size_t") long index,
                    @Const @ByPtrPtr OrtValue out);

  /** \brief Used for custom operators, get an output of a kernel
  *
  * @see ::OrtCustomOp
  */
  public native OrtStatus KernelContext_GetOutput( OrtKernelContext context, @Cast("size_t") long index,
                    @Cast("const int64_t*") LongPointer dim_values, @Cast("size_t") long dim_count, @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus KernelContext_GetOutput( OrtKernelContext context, @Cast("size_t") long index,
                    @Cast("const int64_t*") LongPointer dim_values, @Cast("size_t") long dim_count, @ByPtrPtr OrtValue out);
  public native OrtStatus KernelContext_GetOutput( OrtKernelContext context, @Cast("size_t") long index,
                    @Cast("const int64_t*") LongBuffer dim_values, @Cast("size_t") long dim_count, @ByPtrPtr OrtValue out);
  public native OrtStatus KernelContext_GetOutput( OrtKernelContext context, @Cast("size_t") long index,
                    @Cast("const int64_t*") long[] dim_values, @Cast("size_t") long dim_count, @ByPtrPtr OrtValue out);

  /** \}
   *  \name OrtEnv
   *  \{ */
  public native void ReleaseEnv(OrtEnv input);
  /** \}
   *  \name OrtStatus
   *  \{ */
  public native void ReleaseStatus(OrtStatus input);
  /** \}
   *  \name OrtMemoryInfo
   *  \{ */
  public native void ReleaseMemoryInfo(OrtMemoryInfo input);
  /** \}
   *  \name OrtSession
   *  \{ */
  public native void ReleaseSession(OrtSession input);  //Don't call ReleaseSession from Dllmain (because session owns a thread pool)
  /** \}
   *  \name OrtValue
   *  \{ */
  public native void ReleaseValue(OrtValue input);
  /** \}
   *  \name OrtRunOptions
   *  \{ */
  public native void ReleaseRunOptions(OrtRunOptions input);
  /** \}
   *  \name OrtTypeInfo
   *  \{ */
  public native void ReleaseTypeInfo(OrtTypeInfo input);
  /** \}
   *  \name OrtTensorTypeAndShapeInfo
   *  \{ */
  public native void ReleaseTensorTypeAndShapeInfo(OrtTensorTypeAndShapeInfo input);
  /** \}
   *  \name OrtSessionOptions
   *  \{ */
  public native void ReleaseSessionOptions(OrtSessionOptions input);
  /** \}
   *  \name OrtCustomOpDomain
   *  \{ */
  public native void ReleaseCustomOpDomain(OrtCustomOpDomain input);

  /** \}
   *  \name OrtTypeInfo
   *  \{
  <p>
  /** \brief Get denotation from type information
  *
  * Augments ::OrtTypeInfo to return denotations on the type.
  *
  * This is used by WinML to determine if an input/output is intended to be an Image or a Tensor.
  *
  * @param type_info [in]
  * @param denotation [out] Pointer to the null terminated denotation string is written to this pointer. This pointer is valid until the object is destroyed or the name is changed, do not free.
  * @param len [out] Length in bytes of the string returned in {@code denotation}
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetDenotationFromTypeInfo( @Const OrtTypeInfo type_info, @Cast("const char**const") PointerPointer denotation,
                    @Cast("size_t*") SizeTPointer len);
  public native OrtStatus GetDenotationFromTypeInfo( @Const OrtTypeInfo type_info, @Cast("const char**const") @ByPtrPtr BytePointer denotation,
                    @Cast("size_t*") SizeTPointer len);
  public native OrtStatus GetDenotationFromTypeInfo( @Const OrtTypeInfo type_info, @Cast("const char**const") @ByPtrPtr ByteBuffer denotation,
                    @Cast("size_t*") SizeTPointer len);
  public native OrtStatus GetDenotationFromTypeInfo( @Const OrtTypeInfo type_info, @Cast("const char**const") @ByPtrPtr byte[] denotation,
                    @Cast("size_t*") SizeTPointer len);

  /** \brief Get detailed map information from an ::OrtTypeInfo
  *
  * This augments ::OrtTypeInfo to return an ::OrtMapTypeInfo when the type is a map.
  * The OrtMapTypeInfo has additional information about the map's key type and value type.
  *
  * This is used by WinML to support model reflection APIs.
  *
  * @param type_info [out]
  * @param out [out] A pointer to the ::OrtMapTypeInfo. Do not free this value
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CastTypeInfoToMapTypeInfo( @Const OrtTypeInfo type_info,
                    @Cast("const OrtMapTypeInfo**") PointerPointer out);
  public native OrtStatus CastTypeInfoToMapTypeInfo( @Const OrtTypeInfo type_info,
                    @Const @ByPtrPtr OrtMapTypeInfo out);

  /** \brief Cast ::OrtTypeInfo to an ::OrtSequenceTypeInfo
  *
  * This api augments ::OrtTypeInfo to return an ::OrtSequenceTypeInfo when the type is a sequence.
	* The ::OrtSequenceTypeInfo has additional information about the sequence's element type.
  *
  * This is used by WinML to support model reflection APIs.
	*
  * @param type_info [in]
	* @param out [out] A pointer to the OrtSequenceTypeInfo. Do not free this value
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CastTypeInfoToSequenceTypeInfo( @Const OrtTypeInfo type_info,
                    @Cast("const OrtSequenceTypeInfo**") PointerPointer out);
  public native OrtStatus CastTypeInfoToSequenceTypeInfo( @Const OrtTypeInfo type_info,
                    @Const @ByPtrPtr OrtSequenceTypeInfo out);

  /** \}
   *  \name OrtMapTypeInfo
   *  \{
  <p>
  /** \brief Get key type from an ::OrtMapTypeInfo
  *
  * Key types are restricted to being scalar types.
  *
  * This is used by WinML to support model reflection APIs.
  *
  * @param map_type_info [in]
  * @param out [out]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetMapKeyType( @Const OrtMapTypeInfo map_type_info, @Cast("ONNXTensorElementDataType*") IntPointer out);
  public native OrtStatus GetMapKeyType( @Const OrtMapTypeInfo map_type_info, @Cast("ONNXTensorElementDataType*") IntBuffer out);
  public native OrtStatus GetMapKeyType( @Const OrtMapTypeInfo map_type_info, @Cast("ONNXTensorElementDataType*") int[] out);

  /** \brief Get the value type from an ::OrtMapTypeInfo
  *
  * @param map_type_info [in]
  * @param type_info [out]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetMapValueType( @Const OrtMapTypeInfo map_type_info, @Cast("OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus GetMapValueType( @Const OrtMapTypeInfo map_type_info, @ByPtrPtr OrtTypeInfo type_info);

  /** \}
   *  \name OrtSequenceTypeInfo
   *  \{
  <p>
  /** \brief Get element type from an ::OrtSequenceTypeInfo
  *
  * This is used by WinML to support model reflection APIs.
  *
  * @param sequence_type_info [in]
  * @param type_info [out]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetSequenceElementType( @Const OrtSequenceTypeInfo sequence_type_info,
                    @Cast("OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus GetSequenceElementType( @Const OrtSequenceTypeInfo sequence_type_info,
                    @ByPtrPtr OrtTypeInfo type_info);

  /** \}
   *  \name OrtMapTypeInfo
   *  \{ */
  public native void ReleaseMapTypeInfo(OrtMapTypeInfo input);
  /** \}
   *  \name OrtSequenceTypeInfo
   *  \{ */
  public native void ReleaseSequenceTypeInfo(OrtSequenceTypeInfo input);

  /** \}
   *  \name OrtSession
   *  \{
  <p>
  /** \brief End profiling and return filename of the profile data
  *
  * Profiling is turned on through OrtApi::EnableProfiling
  *
  * @param session [in]
  * @param allocator [in]
  * @param out [out] Null terminated string of the filename, allocated using {@code allocator}. Must be freed using {@code allocator}
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionEndProfiling( OrtSession session, OrtAllocator allocator, @Cast("char**") PointerPointer out);
  public native OrtStatus SessionEndProfiling( OrtSession session, OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer out);
  public native OrtStatus SessionEndProfiling( OrtSession session, OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer out);
  public native OrtStatus SessionEndProfiling( OrtSession session, OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] out);

  /** \brief Get ::OrtModelMetadata from an ::OrtSession
  *
  * @param session [in]
  * @param out [out] Newly created ::OrtModelMetadata. Must be freed using OrtApi::ReleaseModelMetadata
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionGetModelMetadata( @Const OrtSession session, @Cast("OrtModelMetadata**") PointerPointer out);
  public native OrtStatus SessionGetModelMetadata( @Const OrtSession session, @ByPtrPtr OrtModelMetadata out);

  /** \}
   *  \name OrtModelMetadata
   *  \{
  <p>
  /** \brief Get {@code producer name} from an ::OrtModelMetadata
  *
  * @param model_metadata [in]
  * @param allocator [in]
  * @param value [out] Set to a null terminated string allocated using {@code allocator}. Must be freed using {@code allocator}
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus ModelMetadataGetProducerName( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") PointerPointer value);
  public native OrtStatus ModelMetadataGetProducerName( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus ModelMetadataGetProducerName( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus ModelMetadataGetProducerName( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] value);

  /** \brief Get {@code graph name} from an ::OrtModelMetadata
  *
  * @param model_metadata [in]
  * @param allocator [in]
  * @param value [out] Set to a null terminated string allocated using {@code allocator}. Must be freed using {@code allocator}
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus ModelMetadataGetGraphName( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") PointerPointer value);
  public native OrtStatus ModelMetadataGetGraphName( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus ModelMetadataGetGraphName( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus ModelMetadataGetGraphName( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] value);

  /** \brief Get {@code domain} from an ::OrtModelMetadata
  *
  * @param model_metadata [in]
  * @param allocator [in]
  * @param value [out] Set to a null terminated string allocated using {@code allocator}. Must be freed using {@code allocator}
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus ModelMetadataGetDomain( @Const OrtModelMetadata model_metadata, OrtAllocator allocator,
                    @Cast("char**") PointerPointer value);
  public native OrtStatus ModelMetadataGetDomain( @Const OrtModelMetadata model_metadata, OrtAllocator allocator,
                    @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus ModelMetadataGetDomain( @Const OrtModelMetadata model_metadata, OrtAllocator allocator,
                    @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus ModelMetadataGetDomain( @Const OrtModelMetadata model_metadata, OrtAllocator allocator,
                    @Cast("char**") @ByPtrPtr byte[] value);

  /** \brief Get {@code description} from an ::OrtModelMetadata
  *
  * @param model_metadata [in]
  * @param allocator [in]
  * @param value [out] Set to a null terminated string allocated using {@code allocator}. Must be freed using {@code allocator}
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus ModelMetadataGetDescription( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") PointerPointer value);
  public native OrtStatus ModelMetadataGetDescription( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus ModelMetadataGetDescription( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus ModelMetadataGetDescription( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] value);

  /** \brief Return data for a key in the custom metadata map in an ::OrtModelMetadata
  *
  * @param model_metadata [in]
  * @param allocator [in]
  * @param key [in] Null terminated string
  * @param value [out] Set to a null terminated string allocated using {@code allocator}. Must be freed using {@code allocator}
  * {@code value} will be set to nullptr if the given key is not found in the custom metadata map.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus ModelMetadataLookupCustomMetadataMap( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("const char*") BytePointer key, @Cast("char**") PointerPointer value);
  public native OrtStatus ModelMetadataLookupCustomMetadataMap( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("const char*") BytePointer key, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus ModelMetadataLookupCustomMetadataMap( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, String key, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus ModelMetadataLookupCustomMetadataMap( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("const char*") BytePointer key, @Cast("char**") @ByPtrPtr byte[] value);
  public native OrtStatus ModelMetadataLookupCustomMetadataMap( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, String key, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus ModelMetadataLookupCustomMetadataMap( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("const char*") BytePointer key, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus ModelMetadataLookupCustomMetadataMap( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, String key, @Cast("char**") @ByPtrPtr byte[] value);

  /** \brief Get version number from an ::OrtModelMetadata
  *
  * @param model_metadata [in]
  * @param value [out] Set to the version number
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus ModelMetadataGetVersion( @Const OrtModelMetadata model_metadata, @Cast("int64_t*") LongPointer value);
  public native OrtStatus ModelMetadataGetVersion( @Const OrtModelMetadata model_metadata, @Cast("int64_t*") LongBuffer value);
  public native OrtStatus ModelMetadataGetVersion( @Const OrtModelMetadata model_metadata, @Cast("int64_t*") long[] value);

  public native void ReleaseModelMetadata(OrtModelMetadata input);

  /** \}
   *  \name OrtEnv
   *  \{
  <p>
  /** \brief Create an OrtEnv
  *
  * Create an environment with global threadpools that will be shared across sessions.
  * Use this in conjunction with OrtApi::DisablePerSessionThreads or else the session will use
  * its own thread pools.
  *
  * @param log_severity_level [in] The log severity level.
  * @param logid [in] The log identifier.
  * @param tp_options [in]
  * @param out [out] Returned newly created OrtEnv. Must be freed with OrtApi::ReleaseEnv
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateEnvWithGlobalThreadPools( @Cast("OrtLoggingLevel") int log_severity_level, @Cast("const char*") BytePointer logid,
                    @Const OrtThreadingOptions tp_options, @Cast("OrtEnv**") PointerPointer out);
  public native OrtStatus CreateEnvWithGlobalThreadPools( @Cast("OrtLoggingLevel") int log_severity_level, @Cast("const char*") BytePointer logid,
                    @Const OrtThreadingOptions tp_options, @ByPtrPtr OrtEnv out);
  public native OrtStatus CreateEnvWithGlobalThreadPools( @Cast("OrtLoggingLevel") int log_severity_level, String logid,
                    @Const OrtThreadingOptions tp_options, @ByPtrPtr OrtEnv out);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Use global thread pool on a session
  *
  * Disable using per session thread pool and use the shared global threadpool.
  * This should be used in conjunction with OrtApi::CreateEnvWithGlobalThreadPools.
  *
  * @param options [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus DisablePerSessionThreads( OrtSessionOptions options);

  /** \}
   *  \name OrtThreadingOptions
   *  \{
  <p>
  /** \brief Create an ::OrtThreadingOptions
  *
  * @param out [out] Newly created ::OrtThreadingOptions. Must be freed with OrtApi::ReleaseThreadingOptions
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateThreadingOptions( @Cast("OrtThreadingOptions**") PointerPointer out);
  public native OrtStatus CreateThreadingOptions( @ByPtrPtr OrtThreadingOptions out);

  public native void ReleaseThreadingOptions(OrtThreadingOptions input);

  /** \}
   *  \name OrtModelMetadata
   *  \{
  <p>
  /**
  *
  * @param model_metadata [in]
  * @param allocator [in]
  * @param keys [out] Array of null terminated strings (array count = num_keys) allocated using {@code allocator}.
  *  The strings and the pointer array must be freed using {@code allocator}
  *  {@code keys} will be set to nullptr if the custom metadata map is empty.
  * @param num_keys [out] Set to the number of elements in the {@code keys} array
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus ModelMetadataGetCustomMetadataMapKeys( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char***") @ByPtrPtr PointerPointer keys, @Cast("int64_t*") LongPointer num_keys);
  public native OrtStatus ModelMetadataGetCustomMetadataMapKeys( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char***") @ByPtrPtr PointerPointer keys, @Cast("int64_t*") LongBuffer num_keys);
  public native OrtStatus ModelMetadataGetCustomMetadataMapKeys( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char***") @ByPtrPtr PointerPointer keys, @Cast("int64_t*") long[] num_keys);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /**
  *
  * Override symbolic dimensions (by specific name strings) with actual values
  * if known at session initialization time to enable optimizations that can
  * take advantage of fixed values (such as memory planning, etc)
  *
  */
  public native OrtStatus AddFreeDimensionOverrideByName(
                    OrtSessionOptions options, @Cast("const char*") BytePointer dim_name,
                    @Cast("int64_t") long dim_value);
  public native OrtStatus AddFreeDimensionOverrideByName(
                    OrtSessionOptions options, String dim_name,
                    @Cast("int64_t") long dim_value);

  /** \}
   *  \name Misc
   *  \{
  <p>
  /** \brief Get the names of all available providers
  *
  * \note The providers in the list are not guaranteed to be usable. They may fail to load due to missing system dependencies.
  *    For example, if the CUDA/cuDNN libraries are not installed, the CUDA provider will report an error when it is added to the session options.
  *
  * @param out_ptr [out] Set to a pointer to an array of null terminated strings of the available providers. The entries and the
  *    array itself must be freed using OrtApi::ReleaseAvailableProviders
  * @param provider_length [out] Set to the number of entries in the {@code out_ptr} array
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetAvailableProviders( @Cast("char***") @ByPtrPtr PointerPointer out_ptr, IntPointer provider_length);
  public native OrtStatus GetAvailableProviders( @Cast("char***") @ByPtrPtr PointerPointer out_ptr, IntBuffer provider_length);
  public native OrtStatus GetAvailableProviders( @Cast("char***") @ByPtrPtr PointerPointer out_ptr, int[] provider_length);

  /** \brief Release data from OrtApi::GetAvailableProviders
  *
  * @param ptr [in] The {@code out_ptr} result from OrtApi::GetAvailableProviders.
  * @param providers_length [in] The {@code provider_length} result from OrtApi::GetAvailableProviders
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus ReleaseAvailableProviders( @Cast("char**") PointerPointer ptr,
                    int providers_length);
  public native OrtStatus ReleaseAvailableProviders( @Cast("char**") @ByPtrPtr BytePointer ptr,
                    int providers_length);
  public native OrtStatus ReleaseAvailableProviders( @Cast("char**") @ByPtrPtr ByteBuffer ptr,
                    int providers_length);
  public native OrtStatus ReleaseAvailableProviders( @Cast("char**") @ByPtrPtr byte[] ptr,
                    int providers_length);

  /** \}
   *  \name OrtValue
   *  \{
  <p>
  /** \brief Get the length of a single string in a string tensor
  *
  * @param value [in] A string tensor
  * @param index [in] Index of the string in the tensor
  * @param out [out] Set to number of bytes of the string element
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetStringTensorElementLength( @Const OrtValue value, @Cast("size_t") long index, @Cast("size_t*") SizeTPointer out);

  /** \brief Get a single string from a string tensor
  *
  * @param value [in] A string tensor
  * @param s_len [in] Number of bytes in the {@code s} buffer. Must match the value returned by OrtApi::GetStringTensorElementLength.
  * @param index [in] Index of the string in the tensor
  * @param s [out] The string element contents in UTF-8 encoding. The string is NOT null-terminated.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetStringTensorElement( @Const OrtValue value, @Cast("size_t") long s_len, @Cast("size_t") long index, Pointer s);

  /** \brief Set a single string in a string tensor
  *
  * @param value [in] A string tensor
  * @param s [in] A null terminated UTF-8 encoded string
  * @param index [in] Index of the string in the tensor to set
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus FillStringTensorElement( OrtValue value, @Cast("const char*") BytePointer s, @Cast("size_t") long index);
  public native OrtStatus FillStringTensorElement( OrtValue value, String s, @Cast("size_t") long index);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Set a session configuration entry as a pair of strings
  *
  * If a configuration with same key exists, this will overwrite the configuration with the given config_value.
  *
  * The config_key and the format of config_value are defined in onnxruntime_session_options_config_keys.h
  *
  * @param options [in]
  * @param config_key [in] A null terminated string representation of the config key
  * @param config_value [in] A null terminated string representation of the config value
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus AddSessionConfigEntry( OrtSessionOptions options,
                    @Cast("const char*") BytePointer config_key, @Cast("const char*") BytePointer config_value);
  public native OrtStatus AddSessionConfigEntry( OrtSessionOptions options,
                    String config_key, String config_value);

  /** \}
   *  \name OrtAllocator
   *  \{
  <p>
  /** \brief Create an allocator for an ::OrtSession following an ::OrtMemoryInfo
  *
  * @param session [in]
  * @param mem_info [in] valid ::OrtMemoryInfo instance
  * @param out [out] Newly created ::OrtAllocator. Must be freed with OrtApi::ReleaseAllocator
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateAllocator( @Const OrtSession session, @Const OrtMemoryInfo mem_info,
                    @Cast("OrtAllocator**") PointerPointer out);
  public native OrtStatus CreateAllocator( @Const OrtSession session, @Const OrtMemoryInfo mem_info,
                    @ByPtrPtr OrtAllocator out);

  /** \brief Release an ::OrtAllocator obtained from OrtApi::CreateAllocator
  */
  public native void ReleaseAllocator(OrtAllocator input);

  /** \}
   *  \name OrtSession
   *  \{
  <p>
  /** \brief Run a model using Io Bindings for the inputs & outputs
  *
  * @see OrtApi::Run
  *
  * @param session [in]
  * @param run_options [in]
  * @param binding_ptr [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus RunWithBinding( OrtSession session, @Const OrtRunOptions run_options, @Const OrtIoBinding binding_ptr);

  /** \brief Create an ::OrtIoBinding instance
  *
  * An IoBinding object allows one to bind pre-allocated ::OrtValue%s to input names.
  * Thus if you want to use a raw on device buffer as input or output you can avoid
  * extra copy during runtime.
  *
  * @param session [in]
  * @param out [out] Newly created ::OrtIoBinding. Must be freed with OrtApi::ReleaseIoBinding
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateIoBinding( OrtSession session, @Cast("OrtIoBinding**") PointerPointer out);
  public native OrtStatus CreateIoBinding( OrtSession session, @ByPtrPtr OrtIoBinding out);

  /** \}
   *  \name OrtIoBinding
   *  \{
  <p>
  /** \brief Release an ::OrtIoBinding obtained from OrtApi::CreateIoBinding
  */
  public native void ReleaseIoBinding(OrtIoBinding input);

  /** \brief Bind an ::OrtValue to an ::OrtIoBinding input
  *
  * When using OrtApi::RunWithBinding this value is used for the named input
  *
  * @param binding_ptr [in]
  * @param name [in] Name for the model input
  * @param val_ptr [in] ::OrtValue of Tensor type.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus BindInput( OrtIoBinding binding_ptr, @Cast("const char*") BytePointer name, @Const OrtValue val_ptr);
  public native OrtStatus BindInput( OrtIoBinding binding_ptr, String name, @Const OrtValue val_ptr);

  /** \brief Bind an ::OrtValue to an ::OrtIoBinding output
  *
  * When using OrtApi::RunWithBinding this value is used for the named output
  *
  * @param binding_ptr [in]
  * @param name [in] Null terminated string of the model output name
  * @param val_ptr [in] ::OrtValue of Tensor type.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus BindOutput( OrtIoBinding binding_ptr, @Cast("const char*") BytePointer name, @Const OrtValue val_ptr);
  public native OrtStatus BindOutput( OrtIoBinding binding_ptr, String name, @Const OrtValue val_ptr);

  /** \brief Bind an ::OrtIoBinding output to a device
  *
  * Binds the ::OrtValue to a device which is specified by ::OrtMemoryInfo.
  * You can either create an instance of ::OrtMemoryInfo with a device id or obtain one from the allocator that you have created/are using
  * This is useful when one or more outputs have dynamic shapes and, it is hard to pre-allocate and bind a chunk of
  * memory within ::OrtValue ahead of time.
  *
  * @see OrtApi::RunWithBinding
  *
  * @param binding_ptr [in]
  * @param name [in] Null terminated string of the device name
  * @param mem_info_ptr [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus BindOutputToDevice( OrtIoBinding binding_ptr, @Cast("const char*") BytePointer name, @Const OrtMemoryInfo mem_info_ptr);
  public native OrtStatus BindOutputToDevice( OrtIoBinding binding_ptr, String name, @Const OrtMemoryInfo mem_info_ptr);

  /** \brief Get the names of an ::OrtIoBinding's outputs
  *
  * Returns the names of the outputs in the order they were bound. This is useful after running the model
  * with bound outputs because the returned names are in order in which output ::OrtValue are returned. This is useful if
  * the order of outputs and their names is not known.
  *
  * @param binding_ptr [in]
  * @param allocator [in] Allocator used to allocate continuous buffers for output strings and lengths.
  * @param buffer [out] Returns an array of non-null terminated UTF-8 strings. The number of strings stored is returned in the count parameter.
  *   This buffer is allocated using {@code allocator} and must be freed using it.
  * @param lengths [out] Returns an array of {@code count} lengths of the strings returned in {@code buffer}
  *   This buffer is allocated using {@code allocator} and must be freed using it.
  * @param count [out] Number of strings returned. If {@code binding_ptr} has no bound outputs, zero is returned,
  *              no memory allocation is performed and buffer and lengths are set to nullptr.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetBoundOutputNames( @Const OrtIoBinding binding_ptr, OrtAllocator allocator,
                    @Cast("char**") PointerPointer buffer, @Cast("size_t**") PointerPointer lengths, @Cast("size_t*") SizeTPointer count);
  public native OrtStatus GetBoundOutputNames( @Const OrtIoBinding binding_ptr, OrtAllocator allocator,
                    @Cast("char**") @ByPtrPtr BytePointer buffer, @Cast("size_t**") @ByPtrPtr SizeTPointer lengths, @Cast("size_t*") SizeTPointer count);
  public native OrtStatus GetBoundOutputNames( @Const OrtIoBinding binding_ptr, OrtAllocator allocator,
                    @Cast("char**") @ByPtrPtr ByteBuffer buffer, @Cast("size_t**") @ByPtrPtr SizeTPointer lengths, @Cast("size_t*") SizeTPointer count);
  public native OrtStatus GetBoundOutputNames( @Const OrtIoBinding binding_ptr, OrtAllocator allocator,
                    @Cast("char**") @ByPtrPtr byte[] buffer, @Cast("size_t**") @ByPtrPtr SizeTPointer lengths, @Cast("size_t*") SizeTPointer count);

  /** \brief Get the output ::OrtValue objects from an ::OrtIoBinding
  *
  * Returns an array of pointers to individually allocated ::OrtValue%s that contain results of a model execution with OrtApi::RunWithBinding
  * The array contains the same number of ::OrtValue%s and they are in the same order as they were bound with OrtApi::BindOutput
  * or OrtApi::BindOutputToDevice.
  *
  * The returned ::OrtValue%s must be released using OrtApi::ReleaseValue after they are no longer needed.
  * The array is allocated using the specified instance of the allocator and must be freed using the same allocator after
  * all the ::OrtValue%s contained therein are individually released.
  *
  * @param binding_ptr [in]
  * @param allocator [in] Allocator used to allocate output array
  * @param output [out] Set to the allocated array of allocated ::OrtValue outputs. Set to nullptr if there are 0 outputs.
  * @param output_count [out] Set to number of ::OrtValue%s returned
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetBoundOutputValues( @Const OrtIoBinding binding_ptr, OrtAllocator allocator,
                    @Cast("OrtValue***") @ByPtrPtr PointerPointer output, @Cast("size_t*") SizeTPointer output_count);

  /** \brief Clears any previously set Inputs for an ::OrtIoBinding
   */
  public static class ClearBoundInputs_OrtIoBinding extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    ClearBoundInputs_OrtIoBinding(Pointer p) { super(p); }
      protected ClearBoundInputs_OrtIoBinding() { allocate(); }
      private native void allocate();
      public native void call(OrtIoBinding binding_ptr);
  }
  public native ClearBoundInputs_OrtIoBinding ClearBoundInputs(); public native OrtApi ClearBoundInputs(ClearBoundInputs_OrtIoBinding setter);

  /** \brief Clears any previously set Outputs for an ::OrtIoBinding
   */
  public static class ClearBoundOutputs_OrtIoBinding extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    ClearBoundOutputs_OrtIoBinding(Pointer p) { super(p); }
      protected ClearBoundOutputs_OrtIoBinding() { allocate(); }
      private native void allocate();
      public native void call(OrtIoBinding binding_ptr);
  }
  public native ClearBoundOutputs_OrtIoBinding ClearBoundOutputs(); public native OrtApi ClearBoundOutputs(ClearBoundOutputs_OrtIoBinding setter);

  /** \}
   *  \name OrtValue
   *  \{
  <p>
  /** \brief Direct memory access to a specified tensor element
  *
  * For example, given a tensor with shape of [3,224,224], a pointer to the element at location [2,150,128] can be retrieved
  *
  * This function only works for numeric type tensors (No strings, etc).
  * This is a no-copy method whose returned pointer is valid until the passed in ::OrtValue is free'd.
  *
  * @param value [in]
  * @param location_values [in] Pointer to an array of index values that specify an element's location relative to its shape
  * @param location_values_count [in] Number of elements in location_values. Must match the number of elements in the tensor's shape.
  * @param out [out] Set to a pointer to the element specified
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus TensorAt( OrtValue value, @Cast("const int64_t*") LongPointer location_values, @Cast("size_t") long location_values_count, @Cast("void**") PointerPointer out);
  public native OrtStatus TensorAt( OrtValue value, @Cast("const int64_t*") LongPointer location_values, @Cast("size_t") long location_values_count, @Cast("void**") @ByPtrPtr Pointer out);
  public native OrtStatus TensorAt( OrtValue value, @Cast("const int64_t*") LongBuffer location_values, @Cast("size_t") long location_values_count, @Cast("void**") @ByPtrPtr Pointer out);
  public native OrtStatus TensorAt( OrtValue value, @Cast("const int64_t*") long[] location_values, @Cast("size_t") long location_values_count, @Cast("void**") @ByPtrPtr Pointer out);

  /** \}
   *  \name OrtEnv
   *  \{
  <p>
  /** \brief Create an allocator and register it with the ::OrtEnv
  *
  * Enables sharing the allocator between multiple sessions that use the same env instance.
  * Lifetime of the created allocator will be valid for the duration of the environment.
  * Returns an error if an allocator with the same ::OrtMemoryInfo is already registered.
  *
  * See https://onnxruntime.ai/docs/reference/api/c-api.html for details.
  *
  * @param env [in] ::OrtEnv instance
  * @param mem_info [in]
  * @param arena_cfg [in] Pass nullptr for defaults
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateAndRegisterAllocator( OrtEnv env, @Const OrtMemoryInfo mem_info,
                    @Const OrtArenaCfg arena_cfg);

  /** \brief Set language projection
  *
  * Set the language projection for collecting telemetry data when Env is created.
  *
  * The default is ORT_PROJECTION_C, which means it will classify the language not in the list to C also.
  *
  * @param ort_env [in]
  * @param projection [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetLanguageProjection( @Const OrtEnv ort_env, @Cast("OrtLanguageProjection") int projection);

  /** \}
   *  \name OrtSession
   *  \{
  <p>
  /** \brief Return the time that profiling was started
  *
  * \note The timer precision varies per platform. On Windows and MacOS, the precision will be ~100ns
  *
  * @param session [in]
  * @param out [out] nanoseconds of profiling's start time
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionGetProfilingStartTimeNs( @Const OrtSession session, @Cast("uint64_t*") LongPointer out);
  public native OrtStatus SessionGetProfilingStartTimeNs( @Const OrtSession session, @Cast("uint64_t*") LongBuffer out);
  public native OrtStatus SessionGetProfilingStartTimeNs( @Const OrtSession session, @Cast("uint64_t*") long[] out);

  /** \}
   *  \name OrtThreadingOptions
   *  \{
  <p>
  /** \brief Set global intra-op thread count
  *
  * This configures the global thread pool options to be used in the call to OrtApi::CreateEnvWithGlobalThreadPools
  *
  * @param tp_options [in]
  * @param intra_op_num_threads [in] Number of threads, special values:<br>
  *    0 = Use default thread count<br>
  *    1 = The invoking thread will be used; no threads will be created in the thread pool.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetGlobalIntraOpNumThreads( OrtThreadingOptions tp_options, int intra_op_num_threads);

  /** \brief Set global inter-op thread count
  *
  * This configures the global thread pool options to be used in the call to OrtApi::CreateEnvWithGlobalThreadPools
  *
  * @param tp_options [in]
  * @param inter_op_num_threads [in] Number of threads, special values:<br>
  *    0 = Use default thread count<br>
  *    1 = The invoking thread will be used; no threads will be created in the thread pool.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetGlobalInterOpNumThreads( OrtThreadingOptions tp_options, int inter_op_num_threads);

  /** \brief Set global spin control options
  *
  * This will configure the global thread pool options to be used in the call to OrtApi::CreateEnvWithGlobalThreadPools.
  * Allow spinning of thread pools when their queues are empty. This will set the value for both
  * inter_op and intra_op threadpools.
  *
  * @param tp_options [in]
  * @param allow_spinning [in] Valid values are 0 or 1.<br>
  *   0 = It won't spin (recommended if CPU usage is high)<br>
  *   1 = Threadpool will spin to wait for queue to become non-empty
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetGlobalSpinControl( OrtThreadingOptions tp_options, int allow_spinning);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Add a pre-allocated initializer to a session
  *
  * If a model contains an initializer with a name that is same as the name passed to this call,
  * ORT will use this initializer instance instead of deserializing one from the model file. This
  * is useful when you want to share the same initializer across sessions.
  *
  * @param options [in]
  * @param name [in] Null terminated string of the initializer name
  * @param val [in] ::OrtValue containing the initializer. Its lifetime and the underlying initializer buffer must be
  *   managed by the user (created using the OrtApi::CreateTensorWithDataAsOrtValue) and it must outlive the session object
  *   to which it is added.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus AddInitializer( OrtSessionOptions options, @Cast("const char*") BytePointer name,
                    @Const OrtValue val);
  public native OrtStatus AddInitializer( OrtSessionOptions options, String name,
                    @Const OrtValue val);

  /** \}
   *  \name OrtEnv
   *  \{
  <p>
  /**
  * Create a custom environment with global threadpools and logger that will be shared across sessions.
  * Use this in conjunction with OrtApi::DisablePerSessionThreads or else the session will use
  * its own thread pools.
  *
  * @param logging_function [in] A pointer to a logging function.
  * @param logger_param [in] A pointer to arbitrary data passed as the ::OrtLoggingFunction {@code param} parameter to
  *                         {@code logging_function}.
  * @param log_severity_level [in] The log severity level.
  * @param logid [in] The log identifier.
  * @param tp_options [in]
  * @param out [out] Newly created OrtEnv. Must be freed with OrtApi::ReleaseEnv
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateEnvWithCustomLoggerAndGlobalThreadPools( OrtLoggingFunction logging_function, Pointer logger_param, @Cast("OrtLoggingLevel") int log_severity_level,
                    @Cast("const char*") BytePointer logid, @Const OrtThreadingOptions tp_options, @Cast("OrtEnv**") PointerPointer out);
  public native OrtStatus CreateEnvWithCustomLoggerAndGlobalThreadPools( OrtLoggingFunction logging_function, Pointer logger_param, @Cast("OrtLoggingLevel") int log_severity_level,
                    @Cast("const char*") BytePointer logid, @Const OrtThreadingOptions tp_options, @ByPtrPtr OrtEnv out);
  public native OrtStatus CreateEnvWithCustomLoggerAndGlobalThreadPools( OrtLoggingFunction logging_function, Pointer logger_param, @Cast("OrtLoggingLevel") int log_severity_level,
                    String logid, @Const OrtThreadingOptions tp_options, @ByPtrPtr OrtEnv out);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Append CUDA provider to session options
  *
  * If CUDA is not available (due to a non CUDA enabled build, or if CUDA is not installed on the system), this function will return failure.
  *
  * @param options [in]
  * @param cuda_options [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionOptionsAppendExecutionProvider_CUDA(
                    OrtSessionOptions options, @Const OrtCUDAProviderOptions cuda_options);

  /** \brief Append ROCM execution provider to the session options
  *
  * If ROCM is not available (due to a non ROCM enabled build, or if ROCM is not installed on the system), this function will return failure.
  *
  * @param options [in]
  * @param rocm_options [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionOptionsAppendExecutionProvider_ROCM(
                    OrtSessionOptions options, @Const OrtROCMProviderOptions rocm_options);

  /** \brief Append OpenVINO execution provider to the session options
  *
  * If OpenVINO is not available (due to a non OpenVINO enabled build, or if OpenVINO is not installed on the system), this function will fail.
  *
  * @param options [in]
  * @param provider_options [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionOptionsAppendExecutionProvider_OpenVINO(
                    OrtSessionOptions options, @Const OrtOpenVINOProviderOptions provider_options);

  /** \}
   *  \name OrtThreadingOptions
   *  \{
  <p>
  /** \brief Set threading flush-to-zero and denormal-as-zero
  *
  * Sets global thread pool options to be used in the call to OrtApi::CreateEnvWithGlobalThreadPools.
  * Flush-to-zero and denormal-as-zero are applied to threads in both intra and inter global thread pool.
  * \note This option is not needed if the models used have no denormals. Having no denormals is recommended as this option may hurt model accuracy.
  *
  * @param tp_options [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetGlobalDenormalAsZero( OrtThreadingOptions tp_options);

  /** \}
   *  \name OrtArenaCfg
   *  \{
  <p>
  /** @deprecated Use OrtApi::CreateArenaCfgV2
  *
  * This will create the configuration of an arena that can eventually be used to define an arena based allocator's behavior
  *
  * @param max_mem [in] Use 0 to allow ORT to choose the default
  * @param arena_extend_strategy [in] Use -1 to allow ORT to choose the default, 0 = kNextPowerOfTwo, 1 = kSameAsRequested
  * @param initial_chunk_size_bytes [in] Use -1 to allow ORT to choose the default
  * @param max_dead_bytes_per_chunk [in] Use -1 to allow ORT to choose the default
  * @param out [in] A pointer to an OrtArenaCfg instance
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateArenaCfg( @Cast("size_t") long max_mem, int arena_extend_strategy, int initial_chunk_size_bytes,
                    int max_dead_bytes_per_chunk, @Cast("OrtArenaCfg**") PointerPointer out);
  public native OrtStatus CreateArenaCfg( @Cast("size_t") long max_mem, int arena_extend_strategy, int initial_chunk_size_bytes,
                    int max_dead_bytes_per_chunk, @ByPtrPtr OrtArenaCfg out);

  public native void ReleaseArenaCfg(OrtArenaCfg input);

  /** \}
   *  \name OrtModelMetadata
   *  \{
  <p>
  /**
  * Use this to obtain the description of the graph present in the model
  * (doc_string field of the GraphProto message within the ModelProto message).
  * If it doesn't exist, an empty string will be returned.
  *
  * @param model_metadata [in] An instance of ::OrtModelMetadata
  * @param allocator [in] Allocator used to allocate the string that will be returned back
  * @param value [out] Set to a null terminated string allocated using {@code allocator}.  The caller is responsible for freeing it using {@code allocator}
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus ModelMetadataGetGraphDescription( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") PointerPointer value);
  public native OrtStatus ModelMetadataGetGraphDescription( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus ModelMetadataGetGraphDescription( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus ModelMetadataGetGraphDescription( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] value);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Append TensorRT provider to session options
  *
  * If TensorRT is not available (due to a non TensorRT enabled build, or if TensorRT is not installed on the system), this function will return failure.
  *
  * @param options [in]
  * @param tensorrt_options [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionOptionsAppendExecutionProvider_TensorRT(
                    OrtSessionOptions options, @Const OrtTensorRTProviderOptions tensorrt_options);

  /** \}
   *  \name Misc
   *  \{
  <p>
  /** \brief Set current GPU device ID
  *
  * Set the current device id of the GPU execution provider (CUDA/tensorrt/rocm). The device id should be less
  * than the total number of devices available. This is only useful when multiple-GPUs are installed and it is
  * required to restrict execution to a single GPU.
  *
  * @param device_id [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetCurrentGpuDeviceId( int device_id);

  /** \brief Get current GPU device ID
  *
  * Get the current device id of the GPU execution provider (CUDA/tensorrt/rocm).
  *
  * @see OrtApi::SetCurrentGpuDeviceId
  *
  * @param device_id [out]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetCurrentGpuDeviceId( IntPointer device_id);
  public native OrtStatus GetCurrentGpuDeviceId( IntBuffer device_id);
  public native OrtStatus GetCurrentGpuDeviceId( int[] device_id);

  /** \}
   *  \name OrtKernelInfo
   *  \{
  <p>
  /** \brief Fetch an array of int64_t values stored as an attribute in the graph node
  *
  *
  * If {@code out} is nullptr, the value of {@code size} is set to the true size of the attribute
  * array's size, and a success status is returned.
  *
  * If the {@code size} parameter is greater than or equal to the actual attribute array's size,
  * the value of {@code size} is set to the true size of the attribute array's size,
  * the provided memory is filled with the attribute's contents,
  * and a success status is returned.
  *
  * If the {@code size} parameter is less than the actual attribute array's size and {@code out}
  * is not nullptr, the value of {@code size} is set to the true size of the attribute array's size
  * and a failure status is returned.)
  *
  * @param info [in] instance
  * @param name [in] name of the attribute to be parsed
  * @param out [out] pointer to memory where the attribute's contents are to be stored
  * @param size [in, out] actual size of attribute array
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus KernelInfoGetAttributeArray_float( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    FloatPointer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_float( @Const OrtKernelInfo info, String name,
                    FloatBuffer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_float( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    float[] out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_float( @Const OrtKernelInfo info, String name,
                    FloatPointer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_float( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    FloatBuffer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_float( @Const OrtKernelInfo info, String name,
                    float[] out, @Cast("size_t*") SizeTPointer size);

  /** \brief Fetch an array of int64_t values stored as an attribute in the graph node
  *
  * If {@code out} is nullptr, the value of {@code size} is set to the true size of the attribute
  * array's size, and a success status is returned.
  *
  * If the {@code size} parameter is greater than or equal to the actual attribute array's size,
  * the value of {@code size} is set to the true size of the attribute array's size,
  * the provided memory is filled with the attribute's contents,
  * and a success status is returned.
  *
  * If the {@code size} parameter is less than the actual attribute array's size and {@code out}
  * is not nullptr, the value of {@code size} is set to the true size of the attribute array's size
  * and a failure status is returned.)
  *
  * @param info [in] instance
  * @param name [in] name of the attribute to be parsed
  * @param out [out] pointer to memory where the attribute's contents are to be stored
  * @param size [in, out] actual size of attribute array
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus KernelInfoGetAttributeArray_int64( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    @Cast("int64_t*") LongPointer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_int64( @Const OrtKernelInfo info, String name,
                    @Cast("int64_t*") LongBuffer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_int64( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    @Cast("int64_t*") long[] out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_int64( @Const OrtKernelInfo info, String name,
                    @Cast("int64_t*") LongPointer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_int64( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    @Cast("int64_t*") LongBuffer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_int64( @Const OrtKernelInfo info, String name,
                    @Cast("int64_t*") long[] out, @Cast("size_t*") SizeTPointer size);

  /** \}
   *  \name OrtArenaCfg
   *  \{
  <p>
  /** \brief Create an ::OrtArenaCfg
  *
  * Create the configuration of an arena that can eventually be used to define an arena based allocator's behavior.
  *
  * Supported keys are (See https://onnxruntime.ai/docs/reference/api/c-api.html for details on what the
  * following parameters mean and how to choose these values.):
  * "max_mem": Maximum memory that can be allocated by the arena based allocator.
  *  Use 0 for ORT to pick the best value. Default is 0.
  * "arena_extend_strategy": 0 = kNextPowerOfTwo, 1 = kSameAsRequested.
  *  Use -1 to allow ORT to choose the default.
  * "initial_chunk_size_bytes": (Possible) Size of the first allocation in the arena.
  *  Only relevant if arena strategy is {@code kNextPowerOfTwo}. Use -1 to allow ORT to choose the default.
  *  Ultimately, the first allocation size is determined by the allocation memory request.
  * "max_dead_bytes_per_chunk": Threshold of unused memory in an allocated chunk of arena memory after
  *  crossing which the current chunk is chunked into 2.
  * "initial_growth_chunk_size_bytes": (Possible) Size of the second allocation in the arena.
  *  Only relevant if arena strategy is {@code kNextPowerOfTwo}. Use -1 to allow ORT to choose the default.
  *  Ultimately, the allocation size is determined by the allocation memory request.
  *  Further allocation sizes are governed by the arena extend strategy.
  *
  * @param arena_config_keys [in] Keys to configure the arena
  * @param arena_config_values [in] Values to configure the arena
  * @param num_keys [in] Number of keys in {@code arena_config_keys} and {@code arena_config_values}
  * @param out [out] Newly created ::OrtArenaCfg. Must be freed with OrtApi::ReleaseArenaCfg
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateArenaCfgV2( @Cast("const char*const*") PointerPointer arena_config_keys,
                    @Cast("const size_t*") SizeTPointer arena_config_values, @Cast("size_t") long num_keys,
                    @Cast("OrtArenaCfg**") PointerPointer out);
  public native OrtStatus CreateArenaCfgV2( @Cast("const char*const*") @ByPtrPtr BytePointer arena_config_keys,
                    @Cast("const size_t*") SizeTPointer arena_config_values, @Cast("size_t") long num_keys,
                    @ByPtrPtr OrtArenaCfg out);
  public native OrtStatus CreateArenaCfgV2( @Cast("const char*const*") @ByPtrPtr ByteBuffer arena_config_keys,
                    @Cast("const size_t*") SizeTPointer arena_config_values, @Cast("size_t") long num_keys,
                    @ByPtrPtr OrtArenaCfg out);
  public native OrtStatus CreateArenaCfgV2( @Cast("const char*const*") @ByPtrPtr byte[] arena_config_keys,
                    @Cast("const size_t*") SizeTPointer arena_config_values, @Cast("size_t") long num_keys,
                    @ByPtrPtr OrtArenaCfg out);

  /** \}
   *  \name OrtRunOptions
   *  \{
  <p>
  /** \brief Set a single run configuration entry as a pair of strings
  *
  * If a configuration with same key exists, this will overwrite the configuration with the given config_value
  *
  * The config_key and the format of config_value are defined in onnxruntime_run_options_config_keys.h
  *
  * @param options [in]
  * @param config_key [in] A null terminated string representation of the config key
  * @param config_value [in]  A null terminated string representation of the config value
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus AddRunConfigEntry( OrtRunOptions options,
                    @Cast("const char*") BytePointer config_key, @Cast("const char*") BytePointer config_value);
  public native OrtStatus AddRunConfigEntry( OrtRunOptions options,
                    String config_key, String config_value);

  /** \}
   *  \name OrtPrepackedWeightsContainer
   *  \{
  <p>
  /** \brief Create an ::OrtPrepackedWeightsContainer
  *
  * This container will hold pre-packed buffers of shared initializers for sharing between sessions
  * (i.e.) if there are shared initializers that can be shared between sessions, the pre-packed buffers
  * of these (if any) may possibly be shared to provide memory footprint savings. Pass this container
  * to sessions that you would like to share pre-packed buffers of shared initializers at session
  * creation time.
  *
  *  @param out [out] Newly created ::OrtPrepackedWeightsContainer. Must be freed with OrtApi::ReleasePrepackedWeightsContainer
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreatePrepackedWeightsContainer( @Cast("OrtPrepackedWeightsContainer**") PointerPointer out);
  public native OrtStatus CreatePrepackedWeightsContainer( @ByPtrPtr OrtPrepackedWeightsContainer out);

  /** \brief Release OrtPrepackedWeightsContainer instance
  *
  * \note instance must not be released until the sessions using it are released
  */
  public native void ReleasePrepackedWeightsContainer(OrtPrepackedWeightsContainer input);

  /** \}
   *  \name OrtSession
   *  \{
  <p>
  /** \brief Create session with prepacked weights container
  *
  * Same functionality offered by OrtApi::CreateSession except that a container that contains
  * pre-packed weights' buffers is written into/read from by the created session.
  * This is useful when used in conjunction with OrtApi::AddInitializer which injects
  * shared initializer info into sessions. Wherever possible, the pre-packed versions of these
  * shared initializers are cached in this container so that multiple sessions can just re-use
  * these instead of duplicating these in memory.
  *
  * @param env [in] OrtEnv instance instance
  * @param model_path [in] Null terminated string of the path (wchar on Windows, char otherwise)
  * @param options [in]
  * @param prepacked_weights_container [in]
  * @param out [out] Newly created ::OrtSession. Must be freed with OrtApi::ReleaseSession
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateSessionWithPrepackedWeightsContainer( @Const OrtEnv env, @Cast("const ORTCHAR_T*") Pointer model_path,
                    @Const OrtSessionOptions options, OrtPrepackedWeightsContainer prepacked_weights_container,
                    @Cast("OrtSession**") PointerPointer out);
  public native OrtStatus CreateSessionWithPrepackedWeightsContainer( @Const OrtEnv env, @Cast("const ORTCHAR_T*") Pointer model_path,
                    @Const OrtSessionOptions options, OrtPrepackedWeightsContainer prepacked_weights_container,
                    @ByPtrPtr OrtSession out);

  /** \brief Create session from memory with prepacked weights container
  *
  * Same functionality offered by OrtApi::CreateSessionFromArray except that a container that contains
  * pre-packed weights' buffers is written into/read from by the created session.
  * This is useful when used in conjunction with OrtApi::AddInitializer which injects
  * shared initializer info into sessions. Wherever possible, the pre-packed versions of these
  * shared initializers are cached in this container so that multiple sessions can just re-use
  * these instead of duplicating these in memory.
  *
  * @param env [in]
  * @param model_data [in] Array of bytes holding the model
  * @param model_data_length [in] Number of bytes in {@code model_data_model}
  * @param options [in]
  * @param prepacked_weights_container [in]
  * @param out [out] Newly created ::OrtSession. Must be freed with OrtApi::ReleaseSession
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateSessionFromArrayWithPrepackedWeightsContainer( @Const OrtEnv env,
                    @Const Pointer model_data, @Cast("size_t") long model_data_length,
                    @Const OrtSessionOptions options, OrtPrepackedWeightsContainer prepacked_weights_container,
                    @Cast("OrtSession**") PointerPointer out);
  public native OrtStatus CreateSessionFromArrayWithPrepackedWeightsContainer( @Const OrtEnv env,
                    @Const Pointer model_data, @Cast("size_t") long model_data_length,
                    @Const OrtSessionOptions options, OrtPrepackedWeightsContainer prepacked_weights_container,
                    @ByPtrPtr OrtSession out);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Append TensorRT execution provider to the session options
  *
  * If TensorRT is not available (due to a non TensorRT enabled build), this function will return failure.
  *
  * This is slightly different from OrtApi::SessionOptionsAppendExecutionProvider_TensorRT, it takes an
  * ::OrtTensorRTProviderOptions which is publicly defined. This takes an opaque ::OrtTensorRTProviderOptionsV2
  * which must be created with OrtApi::CreateTensorRTProviderOptions.
  *
  * For OrtApi::SessionOptionsAppendExecutionProvider_TensorRT, the user needs to instantiate ::OrtTensorRTProviderOptions
  * as well as allocate/release buffers for some members of ::OrtTensorRTProviderOptions.
  * Here, OrtApi::CreateTensorRTProviderOptions and Ortapi::ReleaseTensorRTProviderOptions will do the memory management for you.
  *
  * @param options [in]
  * @param tensorrt_options [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionOptionsAppendExecutionProvider_TensorRT_V2(
                    OrtSessionOptions options, @Const OrtTensorRTProviderOptionsV2 tensorrt_options);

  /** \}
   *  \name OrtTensorRTProviderOptionsV2
   *  \{
  <p>
  /** \brief Create an OrtTensorRTProviderOptionsV2
  *
  * @param out [out] Newly created ::OrtTensorRTProviderOptionsV2. Must be released with OrtApi::ReleaseTensorRTProviderOptions
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateTensorRTProviderOptions( @Cast("OrtTensorRTProviderOptionsV2**") PointerPointer out);
  public native OrtStatus CreateTensorRTProviderOptions( @ByPtrPtr OrtTensorRTProviderOptionsV2 out);

  /** \brief Set options in a TensorRT Execution Provider.
  *
  * Please refer to https://www.onnxruntime.ai/docs/reference/execution-providers/TensorRT-ExecutionProvider.html#c-api-example
  * to know the available keys and values. Key should be in null terminated string format of the member of ::OrtTensorRTProviderOptionsV2
  * and value should be its related range.
  *
  * For example, key="trt_max_workspace_size" and value="2147483648"
  *
  * @param tensorrt_options [in]
  * @param provider_options_keys [in] Array of UTF-8 null-terminated string for provider options keys
  * @param provider_options_values [in] Array of UTF-8 null-terminated string for provider options values
  * @param num_keys [in] Number of elements in the {@code provider_option_keys} and {@code provider_options_values} arrays
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus UpdateTensorRTProviderOptions( OrtTensorRTProviderOptionsV2 tensorrt_options,
                    @Cast("const char*const*") PointerPointer provider_options_keys,
                    @Cast("const char*const*") PointerPointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateTensorRTProviderOptions( OrtTensorRTProviderOptionsV2 tensorrt_options,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateTensorRTProviderOptions( OrtTensorRTProviderOptionsV2 tensorrt_options,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateTensorRTProviderOptions( OrtTensorRTProviderOptionsV2 tensorrt_options,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_values,
                    @Cast("size_t") long num_keys);

  /** \brief Get serialized TensorRT provider options string.
  *
  * For example, "trt_max_workspace_size=2147483648;trt_max_partition_iterations=10;trt_int8_enable=1;......"
  *
  * @param tensorrt_options - OrTensorRTProviderOptionsV2 instance
  * @param allocator - a ptr to an instance of OrtAllocator obtained with OrtApi::CreateAllocator or OrtApi::GetAllocatorWithDefaultOptions
  *                      the specified allocator will be used to allocate continuous buffers for output strings and lengths.
  * @param ptr - is a UTF-8 null terminated string allocated using 'allocator'. The caller is responsible for using the same allocator to free it.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetTensorRTProviderOptionsAsString( @Const OrtTensorRTProviderOptionsV2 tensorrt_options, OrtAllocator allocator, @Cast("char**") PointerPointer ptr);
  public native OrtStatus GetTensorRTProviderOptionsAsString( @Const OrtTensorRTProviderOptionsV2 tensorrt_options, OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer ptr);
  public native OrtStatus GetTensorRTProviderOptionsAsString( @Const OrtTensorRTProviderOptionsV2 tensorrt_options, OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer ptr);
  public native OrtStatus GetTensorRTProviderOptionsAsString( @Const OrtTensorRTProviderOptionsV2 tensorrt_options, OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] ptr);

  /** \brief Release an ::OrtTensorRTProviderOptionsV2
  *
  * \note This is an exception in the naming convention of other Release* functions, as the name of the method does not have the V2 suffix, but the type does
  */
  public static class ReleaseTensorRTProviderOptions_OrtTensorRTProviderOptionsV2 extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    ReleaseTensorRTProviderOptions_OrtTensorRTProviderOptionsV2(Pointer p) { super(p); }
      protected ReleaseTensorRTProviderOptions_OrtTensorRTProviderOptionsV2() { allocate(); }
      private native void allocate();
      public native void call(OrtTensorRTProviderOptionsV2 input);
  }
  public native ReleaseTensorRTProviderOptions_OrtTensorRTProviderOptionsV2 ReleaseTensorRTProviderOptions(); public native OrtApi ReleaseTensorRTProviderOptions(ReleaseTensorRTProviderOptions_OrtTensorRTProviderOptionsV2 setter);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Enable custom operators
  *
  * See onnxruntime-extensions: https://github.com/microsoft/onnxruntime-extensions.git
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus EnableOrtCustomOps( OrtSessionOptions options);

  /** \}
   *  \name OrtAllocator
   *  \{
  <p>
  /** \brief Register a custom allocator
  *
  * Enables sharing between multiple sessions that use the same env instance.
  * Returns an error if an allocator with the same ::OrtMemoryInfo is already registered.
  *
  * The behavior of this is exactly the same as OrtApi::CreateAndRegisterAllocator except
  * instead of ORT creating an allocator based on provided info, in this case
  * ORT uses the user-provided custom allocator.
  * See https://onnxruntime.ai/docs/reference/api/c-api.html for details.
  *
  * @param env [in]
  * @param allocator [in] User provided allocator
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus RegisterAllocator( OrtEnv env, OrtAllocator allocator);

  /** \brief Unregister a custom allocator
  *
  * It is an error if you provide an ::OrtMemoryInfo not corresponding to any
  * registered allocators for sharing.
  *
  * @param env [in]
  * @param mem_info [in]
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus UnregisterAllocator( OrtEnv env,
                    @Const OrtMemoryInfo mem_info);

  /** \}
   *  \name OrtValue
   *  \{
  <p>
  /** \brief Sets *out to 1 iff an ::OrtValue is a SparseTensor, and 0 otherwise
  *
  * @param value [in] existing ::OrtValue
  * @param out [out] unless an error occurs, contains 1 iff the value contains an instance
  *  of sparse tensor or 0 otherwise.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus IsSparseTensor( @Const OrtValue value, IntPointer out);
  public native OrtStatus IsSparseTensor( @Const OrtValue value, IntBuffer out);
  public native OrtStatus IsSparseTensor( @Const OrtValue value, int[] out);

  /** \brief Create an ::OrtValue with a sparse tensor that is empty.
  *
  * Use FillSparseTensor<Format>() functions to populate sparse tensor with non-zero values and
  * format specific indices data.
  * Use ReleaseValue to destroy the sparse tensor, this will also release the buffer inside the output value
  * if any was allocated.
  * @param allocator [in,out] allocator to use when performing an allocation. Allocation will be performed
  *   by FillSparseTensor<Format>() APIs. The lifespan of the allocator instance must eclipse the lifespan
  *   this sparse tensor instance as the same allocator will be used to free memory.
  * @param dense_shape [in] shape of the original dense tensor
  * @param dense_shape_len [in] number of shape dimensions being passed
  * @param type [in] must be one of TENSOR_ELEMENT_DATA_TYPE_xxxx
  * @param out [out] Should be freed by calling ReleaseValue
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateSparseTensorAsOrtValue( OrtAllocator allocator, @Cast("const int64_t*") LongPointer dense_shape,
                    @Cast("size_t") long dense_shape_len, @Cast("ONNXTensorElementDataType") int type, @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus CreateSparseTensorAsOrtValue( OrtAllocator allocator, @Cast("const int64_t*") LongPointer dense_shape,
                    @Cast("size_t") long dense_shape_len, @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);
  public native OrtStatus CreateSparseTensorAsOrtValue( OrtAllocator allocator, @Cast("const int64_t*") LongBuffer dense_shape,
                    @Cast("size_t") long dense_shape_len, @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);
  public native OrtStatus CreateSparseTensorAsOrtValue( OrtAllocator allocator, @Cast("const int64_t*") long[] dense_shape,
                    @Cast("size_t") long dense_shape_len, @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);

  /**
  * This fills populates an empty tensor that was created using OrtApi::CreateSparseTensorAsOrtValue.
  * This will allocate required memory and copy the supplied NNZ values and COO indices into that memory allocation.
  * Memory allocation is performed using the allocator that was specified with OrtApi::CreateSparseTensorAsOrtValue.
  *
  * @param ort_value [in,out] ::OrtValue to populate with data
  * @param data_mem_info [in] serves to identify the location of the data to be copied. If the allocator specified
  *  at the creation time has memory info that is not the same as mem_info argument to this function a X-device copy will be performed.
  *  String data is assumed to be on CPU and will only be copied into a CPU allocated buffer.
  * @param values_shape [in] pointer to values shape array
  * @param values_shape_len [in] length of the values_shape
  * @param values [in] pointer to an array of values. For strings, pass const char**.
  * @param indices_data [in] pointer to a location of COO indices
  * @param indices_num [in] number of COO indices
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus FillSparseTensorCoo( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") LongPointer values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") LongPointer indices_data, @Cast("size_t") long indices_num);
  public native OrtStatus FillSparseTensorCoo( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") LongBuffer values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") LongBuffer indices_data, @Cast("size_t") long indices_num);
  public native OrtStatus FillSparseTensorCoo( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") long[] values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") long[] indices_data, @Cast("size_t") long indices_num);

  /**
  * This fills populates an empty tensor that was created using OrtApi::CreateSparseTensorAsOrtValue.
  * This will allocate required memory and copy the supplied NNZ values and CSR indices into that memory allocation.
  * Memory allocation is performed using the allocator that was specified with OrtApi::CreateSparseTensorAsOrtValue.
  *
  * @param ort_value [in,out] ::OrtValue to populate with data
  * @param data_mem_info [in] serves to identify the location of the data to be copied. If the allocator specified
  *  at the creation time has memory info that is not the same as mem_info argument to this function a X-device copy will be performed.
  *  String data is assumed to be on CPU and will only be copied into a CPU allocated buffer.
  * @param values_shape [in] pointer to values shape array
  * @param values_shape_len [in] length of the values_shape
  * @param values [in] - pointer to an array of values. For strings, pass const char**.
  * @param inner_indices_data [in] pointer to a location of CSR inner indices
  * @param inner_indices_num [in] number of CSR inner indices
  * @param outer_indices_data [in] pointer to a location of CSR outer indices
  * @param outer_indices_num [in] number of CSR outer indices
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus FillSparseTensorCsr( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") LongPointer values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") LongPointer inner_indices_data, @Cast("size_t") long inner_indices_num,
                    @Cast("const int64_t*") LongPointer outer_indices_data, @Cast("size_t") long outer_indices_num);
  public native OrtStatus FillSparseTensorCsr( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") LongBuffer values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") LongBuffer inner_indices_data, @Cast("size_t") long inner_indices_num,
                    @Cast("const int64_t*") LongBuffer outer_indices_data, @Cast("size_t") long outer_indices_num);
  public native OrtStatus FillSparseTensorCsr( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") long[] values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") long[] inner_indices_data, @Cast("size_t") long inner_indices_num,
                    @Cast("const int64_t*") long[] outer_indices_data, @Cast("size_t") long outer_indices_num);

  /**
  * This fills populates an empty tensor that was created using OrtApi::CreateSparseTensorAsOrtValue.
  * This will allocate required memory and copy the supplied NNZ values and BlockSparse indices into that memory allocation.
  * Memory allocation is performed using the allocator that was specified with OrtApi::CreateSparseTensorAsOrtValue.
  *
  * @param ort_value [in,out] ::OrtValue to populate with data
  * @param data_mem_info [in] serves to identify the location of the data to be copied. If the allocator specified
  *  at the creation time has memory info that is not the same as mem_info argument to this function a X-device copy will be performed.
  *  String data is assumed to be on CPU and will only be copied into a CPU allocated buffer.
  * @param values_shape [in]
  * @param values_shape_len [in]
  * @param values [in] structure with values information
  * @param indices_shape_data [in] pointer to a location of indices shape
  * @param indices_shape_len [in] length of the block sparse indices shape
  * @param indices_data [in] pointer to a location of indices data. Shape will determine the length of the indices data.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus FillSparseTensorBlockSparse( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") LongPointer values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") LongPointer indices_shape_data, @Cast("size_t") long indices_shape_len,
                    @Const IntPointer indices_data);
  public native OrtStatus FillSparseTensorBlockSparse( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") LongBuffer values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") LongBuffer indices_shape_data, @Cast("size_t") long indices_shape_len,
                    @Const IntBuffer indices_data);
  public native OrtStatus FillSparseTensorBlockSparse( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") long[] values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") long[] indices_shape_data, @Cast("size_t") long indices_shape_len,
                    @Const int[] indices_data);

  /**
  * Create an ::OrtValue with a sparse tensor. This is the first step.
  * Next, use Use<Format>Indices() functions to supply sparse tensor with
  * format specific indices data and set its sparse format to a specific enum value.
  * This will not perform memory allocations. It will
  * use supplied user buffer which should outlive the created sparse tensor.
  * Use OrtApi::ReleaseValue to destroy the sparse tensor. It would not release the supplied values buffer.
  * This function can not be used to map strings from the user allocated memory. Strings must always be copied
  * and have UTF-8 encoding. Therefore, use OrtApi::CreateSparseTensorAsOrtValue above and then fill it with data
  * using appropriate Make*() function.
  *
  * @param info [in] memory info where sparse values reside.
  * @param p_data [in,out] pointer to a user allocated buffer with values. To create a full sparse tensor with no non-zero
  *   values, pass nullptr
  * @param dense_shape [in] shape of the original dense tensor
  * @param dense_shape_len [in] number of shape dimensions being passed
  * @param values_shape [in] shape of the values data. To create a fully sparse tensor with no non-zero values,
  *   pass {0} shape.
  * @param values_shape_len [in] number of values shape dimensions
  * @param type [in] must be one of TENSOR_ELEMENT_DATA_TYPE_xxxx
  * @param out [out] Should be freed by calling ReleaseValue
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus CreateSparseTensorWithValuesAsOrtValue( @Const OrtMemoryInfo info, Pointer p_data,
                    @Cast("const int64_t*") LongPointer dense_shape, @Cast("size_t") long dense_shape_len,
                    @Cast("const int64_t*") LongPointer values_shape, @Cast("size_t") long values_shape_len,
                    @Cast("ONNXTensorElementDataType") int type, @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus CreateSparseTensorWithValuesAsOrtValue( @Const OrtMemoryInfo info, Pointer p_data,
                    @Cast("const int64_t*") LongPointer dense_shape, @Cast("size_t") long dense_shape_len,
                    @Cast("const int64_t*") LongPointer values_shape, @Cast("size_t") long values_shape_len,
                    @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);
  public native OrtStatus CreateSparseTensorWithValuesAsOrtValue( @Const OrtMemoryInfo info, Pointer p_data,
                    @Cast("const int64_t*") LongBuffer dense_shape, @Cast("size_t") long dense_shape_len,
                    @Cast("const int64_t*") LongBuffer values_shape, @Cast("size_t") long values_shape_len,
                    @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);
  public native OrtStatus CreateSparseTensorWithValuesAsOrtValue( @Const OrtMemoryInfo info, Pointer p_data,
                    @Cast("const int64_t*") long[] dense_shape, @Cast("size_t") long dense_shape_len,
                    @Cast("const int64_t*") long[] values_shape, @Cast("size_t") long values_shape_len,
                    @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);

  /**
  * This assigns Coo format indices to the SparseTensor that was created by
  * OrtApi::CreateSparseTensorWithValuesAsOrtValue above. It also sets OrtSparseFormat to
  * ORT_SPARSE_COO. This will not allocate any additional memory for data. The life span of
  * indices_data buffer should eclipse the life span of this ::OrtValue.
  *
  * @param ort_value [in,out] ::OrtValue instance constructed with OrtApi::CreateSparseTensorWithValuesAsOrtValue
  * @param indices_data [in,out] pointer to a user pre-allocated buffer or nullptr for fully sparse tensors.
  * @param indices_num [in]  number of COO indices. Should either be 0 for fully sparse tensors, be equal
  *  to the number of nnz values specified to OrtApi::CreateSparseTensorWithValuesAsOrtValue for 1-D {nnz} indices or
  *  be twice as number of nnz values for a  2-D indices {nnz, 2}
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus UseCooIndices( OrtValue ort_value, @Cast("int64_t*") LongPointer indices_data, @Cast("size_t") long indices_num);
  public native OrtStatus UseCooIndices( OrtValue ort_value, @Cast("int64_t*") LongBuffer indices_data, @Cast("size_t") long indices_num);
  public native OrtStatus UseCooIndices( OrtValue ort_value, @Cast("int64_t*") long[] indices_data, @Cast("size_t") long indices_num);

  /**
  * The assigns CSR format indices to the SparseTensor that was created by
  * OrtApi::CreateSparseTensorWithValuesAsOrtValue above. It also sets OrtSparseFormat to
  * ORT_SPARSE_CSRC. This will not allocate any additional memory for data. The life spans of
  * inner_data and outer_data buffers should eclipse the life span of this ::OrtValue.
  *
  * @param ort_value [in,out] ::OrtValue instance constructed with OrtApi::CreateSparseTensorWithValuesAsOrtValue
  * @param inner_data [in,out] pointer to a user pre-allocated buffer or nullptr for fully sparse tensors.
  * @param inner_num [in]  number of inner CSR indices. Should either be 0 for fully sparse tensors or be equal
  * to the number of nnz values specified to OrtApi::CreateSparseTensorWithValuesAsOrtValue.
  * @param outer_data [in,out] pointer to user pre-allocated buffer or nullptr for fully sparse tensors.
  * @param outer_num [in] number of CSR outer indices. Should either be 0 for fully sparse tensors or
  * equal to rows + 1 of the dense shape.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus UseCsrIndices( OrtValue ort_value, @Cast("int64_t*") LongPointer inner_data, @Cast("size_t") long inner_num,
                    @Cast("int64_t*") LongPointer outer_data, @Cast("size_t") long outer_num);
  public native OrtStatus UseCsrIndices( OrtValue ort_value, @Cast("int64_t*") LongBuffer inner_data, @Cast("size_t") long inner_num,
                    @Cast("int64_t*") LongBuffer outer_data, @Cast("size_t") long outer_num);
  public native OrtStatus UseCsrIndices( OrtValue ort_value, @Cast("int64_t*") long[] inner_data, @Cast("size_t") long inner_num,
                    @Cast("int64_t*") long[] outer_data, @Cast("size_t") long outer_num);

  /**
  * The assigns BlockSparse format indices to the SparseTensor that was created by
  * OrtApi::CreateSparseTensorWithValuesAsOrtValue above. It also sets OrtSparseFormat to
  * ORT_SPARSE_BLOCK_SPARSE. This will not allocate any additional memory for data. The life span of
  * indices_data buffer must eclipse the lifespan of this ::OrtValue.
  *
  * @param ort_value [in,out] OrtValue instance constructed with OrtApi::CreateSparseTensorWithValuesAsOrtValue
  * @param indices_shape [in] pointer to indices shape. Use {0} for fully sparse tensors
  * @param indices_shape_len [in] length of the indices shape
  * @param indices_data [in,out] pointer to user pre-allocated buffer or nullptr for fully sparse tensors.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus UseBlockSparseIndices( OrtValue ort_value, @Cast("const int64_t*") LongPointer indices_shape, @Cast("size_t") long indices_shape_len, IntPointer indices_data);
  public native OrtStatus UseBlockSparseIndices( OrtValue ort_value, @Cast("const int64_t*") LongBuffer indices_shape, @Cast("size_t") long indices_shape_len, IntBuffer indices_data);
  public native OrtStatus UseBlockSparseIndices( OrtValue ort_value, @Cast("const int64_t*") long[] indices_shape, @Cast("size_t") long indices_shape_len, int[] indices_data);

  /** \brief Returns sparse tensor format enum iff a given ort value contains an instance of sparse tensor.
  *
  * @param ort_value [in] ::OrtValue that contains an instance of sparse tensor
  * @param out [out] pointer to out parameter
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetSparseTensorFormat( @Const OrtValue ort_value, @Cast("OrtSparseFormat*") IntPointer out);
  public native OrtStatus GetSparseTensorFormat( @Const OrtValue ort_value, @Cast("OrtSparseFormat*") IntBuffer out);
  public native OrtStatus GetSparseTensorFormat( @Const OrtValue ort_value, @Cast("OrtSparseFormat*") int[] out);

  /** \brief Returns data type and shape of sparse tensor values (nnz) iff ::OrtValue contains a SparseTensor.
  *
  * @param ort_value [in] An ::OrtValue that contains a fully constructed sparse tensor
  * @param out [out] Must be freed by OrtApi::ReleaseTensorTypeAndShapeInfo
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetSparseTensorValuesTypeAndShape( @Const OrtValue ort_value, @Cast("OrtTensorTypeAndShapeInfo**") PointerPointer out);
  public native OrtStatus GetSparseTensorValuesTypeAndShape( @Const OrtValue ort_value, @ByPtrPtr OrtTensorTypeAndShapeInfo out);

  /** \brief Returns numeric data for sparse tensor values (nnz). For string values use GetStringTensor*().
  *
  * @param ort_value [in] an instance of ::OrtValue containing sparse tensor
  * @param out [out] returns a pointer to values data.  Do not attempt to free this ptr.
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetSparseTensorValues( @Const OrtValue ort_value, @Cast("const void**") PointerPointer out);
  public native OrtStatus GetSparseTensorValues( @Const OrtValue ort_value, @Cast("const void**") @ByPtrPtr Pointer out);

  /** \brief Returns data type, shape for the type of indices specified by indices_format.
  *
  * @param ort_value [in] ::OrtValue containing sparse tensor.
  * @param indices_format [in] One of the indices formats. It is an error to request a format that the sparse
  * tensor does not contain.
  * @param out [out] an instance of ::OrtTensorTypeAndShapeInfo. Must be freed by OrtApi::ReleaseTensorTypeAndShapeInfo
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetSparseTensorIndicesTypeShape( @Const OrtValue ort_value, OrtSparseIndicesFormat indices_format, @Cast("OrtTensorTypeAndShapeInfo**") PointerPointer out);
  public native OrtStatus GetSparseTensorIndicesTypeShape( @Const OrtValue ort_value, OrtSparseIndicesFormat indices_format, @ByPtrPtr OrtTensorTypeAndShapeInfo out);
  public native OrtStatus GetSparseTensorIndicesTypeShape( @Const OrtValue ort_value, @Cast("OrtSparseIndicesFormat") int indices_format, @ByPtrPtr OrtTensorTypeAndShapeInfo out);

  /** \brief Returns indices data for the type of the indices specified by indices_format
  *
  * @param ort_value [in] ::OrtValue containing sparse tensor.
  * @param indices_format [in] One of the indices formats. It is an error to request a format that the sparse tensor does not contain.
  * @param num_indices [out] Pointer to where the number of indices entries is returned
  * @param indices [out] Returned pointer to the indices data. Do not free the returned pointer as it refers to internal data owned by the ::OrtValue
  *
  * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus GetSparseTensorIndices( @Const OrtValue ort_value, OrtSparseIndicesFormat indices_format, @Cast("size_t*") SizeTPointer num_indices, @Cast("const void**") PointerPointer indices);
  public native OrtStatus GetSparseTensorIndices( @Const OrtValue ort_value, OrtSparseIndicesFormat indices_format, @Cast("size_t*") SizeTPointer num_indices, @Cast("const void**") @ByPtrPtr Pointer indices);
  public native OrtStatus GetSparseTensorIndices( @Const OrtValue ort_value, @Cast("OrtSparseIndicesFormat") int indices_format, @Cast("size_t*") SizeTPointer num_indices, @Cast("const void**") @ByPtrPtr Pointer indices);

  /**
   * \brief Sets out to 1 iff an optional type OrtValue has an element, 0 otherwise (OrtValue is None)
   * Use this API to find if the optional type OrtValue is None or not.
   * If the optional type OrtValue is not None, use the OrtValue just like any other OrtValue.
   * For example, if you get an OrtValue that corresponds to Optional(tensor) and 
   * if HasValue() returns true, use it as tensor and so on.
   <p>
   * @param value [in] Input OrtValue.
   * @param out [out] indicating if the input OrtValue contains data (1) or if it is a None (0)
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus HasValue( @Const OrtValue value, IntPointer out);
  public native OrtStatus HasValue( @Const OrtValue value, IntBuffer out);
  public native OrtStatus HasValue( @Const OrtValue value, int[] out);
  /** \}
   *  \name OrtKernelContext
   *  \{
  /** \brief Used for custom operators, gets the GPU compute stream to use to launch the custom a GPU kernel     
  *   @see ::OrtCustomOp
  * @param OrtKernelContext [context] instance
  * @param Returns [out] pointer to a GPU compute stream that can be used to launch the custom GPU kernel.
  *             If retrieving the GPU compute stream is not relevant (GPU not enabled in the build, kernel partitioned to
  *             some other EP), then a nullptr is returned as the output param.
  *             Do not free or mutate the returned pointer as it refers to internal data owned by the underlying session.
  *             Only use it for custom kernel launching.
  */
  public native OrtStatus KernelContext_GetGPUComputeStream( @Const OrtKernelContext context, @Cast("void**") PointerPointer out);
  public native OrtStatus KernelContext_GetGPUComputeStream( @Const OrtKernelContext context, @Cast("void**") @ByPtrPtr Pointer out);

  /** \}
   *  \name GetTensorMemoryInfo
   *  \{
  /** \brief Returns a pointer to the ::OrtMemoryInfo of a Tensor
   * @param ort_value [in] ::OrtValue containing tensor.
   * @param mem_info [out] ::OrtMemoryInfo of the tensor. Do NOT free the returned pointer. It is valid for the lifetime of the ::OrtValue
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetTensorMemoryInfo( @Const OrtValue value, @Cast("const OrtMemoryInfo**") PointerPointer mem_info);
  public native OrtStatus GetTensorMemoryInfo( @Const OrtValue value, @Const @ByPtrPtr OrtMemoryInfo mem_info);

  /** \}
   *  \name GetExecutionProviderApi
   *  \{
  /** \brief Get a pointer to the requested version of the Execution Provider specific
   * API extensions to the OrtApi 
   * @param provider_name [in] The name of the execution provider name. Currently only the following
   * values are supported: "DML".
   * @param version [in] Must be ::ORT_API_VERSION.
   * @param provider_api [out] A void pointer containing a reference to the execution provider versioned api structure.
   * For example, the provider_api pointer can be cast to the OrtDmlApi* when the provider_name is "DML".
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetExecutionProviderApi( @Cast("const char*") BytePointer provider_name, @Cast("uint32_t") int version, @Cast("const void**") PointerPointer provider_api);
  public native OrtStatus GetExecutionProviderApi( @Cast("const char*") BytePointer provider_name, @Cast("uint32_t") int version, @Cast("const void**") @ByPtrPtr Pointer provider_api);
  public native OrtStatus GetExecutionProviderApi( String provider_name, @Cast("uint32_t") int version, @Cast("const void**") @ByPtrPtr Pointer provider_api);

  /** \}
   <p>
   *  \name SessionOptions
   *  \{
  /** \brief Set custom thread creation function
  *
  * @param session [in] options
  * @param custom [in] thread creation function
  * 
  * * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionOptionsSetCustomCreateThreadFn( OrtSessionOptions options, OrtCustomCreateThreadFn ort_custom_create_thread_fn);

  /** \brief Set creation options for custom thread 
  *
  * @param session [in] options
  * @param custom [in] thread creation options (can be nullptr)
  * 
  * * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionOptionsSetCustomThreadCreationOptions( OrtSessionOptions options, Pointer ort_custom_thread_creation_options);

  /** \brief Set custom thread join function
  *
  * @param session [in] options
  * @param custom [in] join thread function, must not be nullptr when ort_custom_create_thread_fn is set
  * 
  * * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SessionOptionsSetCustomJoinThreadFn( OrtSessionOptions options, OrtCustomJoinThreadFn ort_custom_join_thread_fn);
  /** \}
   <p>
   *  \name OrtThreadingOptions
   *  \{
  /** \brief Set custom thread creation function for global thread pools
  *
  * @param tp_options [inout]
  * @param custom [in] thread creation function
  * 
  * * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetGlobalCustomCreateThreadFn( OrtThreadingOptions tp_options, OrtCustomCreateThreadFn ort_custom_create_thread_fn);

  /** \brief Set custom thread creation options for global thread pools
  *
  * @param tp_options [inout]
  * @param custom [in] thread creation options (can be nullptr)
  * 
  * * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetGlobalCustomThreadCreationOptions( OrtThreadingOptions tp_options, Pointer ort_custom_thread_creation_options);

  /** \brief Set custom thread join function for global thread pools
  *
  * @param tp_options [inout]
  * @param custom [in] thread join function, must not be nullptr when global ort_custom_create_thread_fn is set
  * 
  * * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SetGlobalCustomJoinThreadFn( OrtThreadingOptions tp_options, OrtCustomJoinThreadFn ort_custom_join_thread_fn);
  /** \}
  <p>
  /** \brief Synchronize bound inputs. The call may be necessary for some providers, such as cuda,
  *   in case the system that allocated bound memory operated on a different stream. However, the
  *   operation is provider specific and could be a no-op.
  *
  * @param binding_ptr [inout]
  * 
  * * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SynchronizeBoundInputs( OrtIoBinding binding_ptr);

  /** \brief Synchronize bound outputs. The call may be necessary for some providers, such as cuda,
  *   in case the system that allocated bound memory operated on a different stream. However, the
  *   operation is provider specific and could be a no-op.
  *
  * @param binding_ptr [inout]
  * 
  * * \snippet{doc} snippets.dox OrtStatus Return Value
  */
  public native OrtStatus SynchronizeBoundOutputs( OrtIoBinding binding_ptr);
}
