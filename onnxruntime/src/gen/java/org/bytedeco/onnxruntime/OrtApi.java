// Targeted by JavaCPP version 1.5.13-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.onnxruntime;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.opencl.*;
import static org.bytedeco.opencl.global.OpenCL.*;
import org.bytedeco.dnnl.*;
import static org.bytedeco.dnnl.global.dnnl.*;

import static org.bytedeco.onnxruntime.global.onnxruntime.*;


@Properties(inherit = org.bytedeco.onnxruntime.presets.onnxruntime.class)
public class OrtApi extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OrtApi(Pointer p) { super(p); }

  /** \name OrtStatus
   *  \{
  <p>
  /**
   * \brief Create an OrtStatus from a null terminated string
   *
   * @param code [in]
   * @param msg [in] A null-terminated string. Its contents will be copied.
   * @return A new OrtStatus object, must be destroyed with OrtApi::ReleaseStatus
   */
  public static class CreateStatus_int_BytePointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    CreateStatus_int_BytePointer(Pointer p) { super(p); }
      protected CreateStatus_int_BytePointer() { allocate(); }
      private native void allocate();
      public native OrtStatus call(@Cast("OrtErrorCode") int code, @Cast("const char*") BytePointer msg);
  }
  public native CreateStatus_int_BytePointer CreateStatus(); public native OrtApi CreateStatus(CreateStatus_int_BytePointer setter);

  /** \brief Get OrtErrorCode from OrtStatus
   *
   * @param status [in]
   * @return OrtErrorCode that \p status was created with
   */
  public static class GetErrorCode_OrtStatus extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    GetErrorCode_OrtStatus(Pointer p) { super(p); }
      protected GetErrorCode_OrtStatus() { allocate(); }
      private native void allocate();
      public native @Cast("OrtErrorCode") int call(@Const OrtStatus status);
  }
  public native GetErrorCode_OrtStatus GetErrorCode(); public native OrtApi GetErrorCode(GetErrorCode_OrtStatus setter);

  /** \brief Get error string from OrtStatus
   *
   * @param status [in]
   * @return The error message inside the {@code status}. Do not free the returned value.
   */
  public static class GetErrorMessage_OrtStatus extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    GetErrorMessage_OrtStatus(Pointer p) { super(p); }
      protected GetErrorMessage_OrtStatus() { allocate(); }
      private native void allocate();
      public native @Cast("const char*") BytePointer call(@Const OrtStatus status);
  }
  public native GetErrorMessage_OrtStatus GetErrorMessage(); public native OrtApi GetErrorMessage(GetErrorMessage_OrtStatus setter);

  /** \}
   *  \name OrtEnv
   *  \{
  <p>
  /** \brief Create an OrtEnv
   *
   * \note Invoking this function will return the same instance of the environment as that returned by a previous call
   * to another env creation function; all arguments to this function will be ignored.
   * @param log_severity_level [in] The log severity level.
   * @param logid [in] The log identifier.
   * @param out [out] Returned newly created OrtEnv. Must be freed with OrtApi::ReleaseEnv
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateEnv( @Cast("OrtLoggingLevel") int log_severity_level, @Cast("const char*") BytePointer logid, @Cast("OrtEnv**") PointerPointer out);
  public native OrtStatus CreateEnv( @Cast("OrtLoggingLevel") int log_severity_level, @Cast("const char*") BytePointer logid, @ByPtrPtr OrtEnv out);
  public native OrtStatus CreateEnv( @Cast("OrtLoggingLevel") int log_severity_level, String logid, @ByPtrPtr OrtEnv out);

  /** \brief Create an OrtEnv
   *
   * \note Invoking this function will return the same instance of the environment as that returned by a previous call
   * to another env creation function; all arguments to this function will be ignored. If you want to provide your
   * own logging function, consider setting it using the SetUserLoggingFunction API instead.
   * @param logging_function [in] A pointer to a logging function.
   * @param logger_param [in] A pointer to arbitrary data passed as the ::OrtLoggingFunction {@code param} parameter to
   *                         {@code logging_function}. This parameter is optional.
   * @param log_severity_level [in] The log severity level.
   * @param logid [in] The log identifier.
   * @param out [out] Returned newly created OrtEnv. Must be freed with OrtApi::ReleaseEnv
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateEnvWithCustomLogger( OrtLoggingFunction logging_function, Pointer logger_param,
                    @Cast("OrtLoggingLevel") int log_severity_level, @Cast("const char*") BytePointer logid, @Cast("OrtEnv**") PointerPointer out);
  public native OrtStatus CreateEnvWithCustomLogger( OrtLoggingFunction logging_function, Pointer logger_param,
                    @Cast("OrtLoggingLevel") int log_severity_level, @Cast("const char*") BytePointer logid, @ByPtrPtr OrtEnv out);
  public native OrtStatus CreateEnvWithCustomLogger( OrtLoggingFunction logging_function, Pointer logger_param,
                    @Cast("OrtLoggingLevel") int log_severity_level, String logid, @ByPtrPtr OrtEnv out);

  /** \brief Enable Telemetry
   *
   * \note Telemetry events are on by default since they are lightweight
   * @param env [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus EnableTelemetryEvents( @Const OrtEnv env);
  /** \brief Disable Telemetry
   *
   * @see OrtApi::EnableTelemetryEvents
   * @param env [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus DisableTelemetryEvents( @Const OrtEnv env);

  /** \}
   *  \name OrtSession
   *  \{
  <p>
  /** \brief Create an OrtSession from a model file
   *
   * @param env [in]
   * @param model_path [in]
   * @param options [in]
   * @param out [out] Returned newly created OrtSession. Must be freed with OrtApi::ReleaseSession
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  // TODO: document the path separator convention? '/' vs '\' */
  // TODO: should specify the access characteristics of model_path. Is this read only during the
  // execution of CreateSession, or does the OrtSession retain a handle to the file/directory
  // and continue to access throughout the OrtSession lifetime?
  //  What sort of access is needed to model_path : read or read/write?
  public native OrtStatus CreateSession( @Const OrtEnv env, @Cast("const ORTCHAR_T*") Pointer model_path,
                    @Const OrtSessionOptions options, @Cast("OrtSession**") PointerPointer out);
  public native OrtStatus CreateSession( @Const OrtEnv env, @Cast("const ORTCHAR_T*") Pointer model_path,
                    @Const OrtSessionOptions options, @ByPtrPtr OrtSession out);

  /** \brief Create an OrtSession from memory
   *
   * @param env [in]
   * @param model_data [in]
   * @param model_data_length [in]
   * @param options [in]
   * @param out [out] Returned newly created OrtSession. Must be freed with OrtApi::ReleaseSession
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateSessionFromArray( @Const OrtEnv env,
                    @Const Pointer model_data, @Cast("size_t") long model_data_length,
                    @Const OrtSessionOptions options, @Cast("OrtSession**") PointerPointer out);
  public native OrtStatus CreateSessionFromArray( @Const OrtEnv env,
                    @Const Pointer model_data, @Cast("size_t") long model_data_length,
                    @Const OrtSessionOptions options, @ByPtrPtr OrtSession out);

  /** \brief Run the model in an ::OrtSession
   *
   * Will not return until the model run has completed. Multiple threads might be used to run the model based on
   * the options in the ::OrtSession and settings used when creating the ::OrtEnv
   *
   * @param session [in]
   * @param run_options [in] If nullptr, will use a default ::OrtRunOptions
   * @param input_names [in] Array of null terminated UTF8 encoded strings of the input names
   * @param inputs [in] Array of ::OrtValue%s of the input values
   * @param input_len [in] Number of elements in the input_names and inputs arrays
   * @param output_names [in] Array of null terminated UTF8 encoded strings of the output names
   * @param output_names_len [in] Number of elements in the output_names and outputs array
   * @param outputs [out] Array of ::OrtValue%s that the outputs are stored in. This can also be
   *     an array of nullptr values, in this case ::OrtValue objects will be allocated and pointers
   *     to them will be set into the {@code outputs} array.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus Run( OrtSession session, @Const OrtRunOptions run_options,
                    @Cast("const char*const*") PointerPointer input_names,
                    @Cast("const OrtValue*const*") PointerPointer inputs, @Cast("size_t") long input_len,
                    @Cast("const char*const*") PointerPointer output_names, @Cast("size_t") long output_names_len,
                    @Cast("OrtValue**") PointerPointer outputs);
  public native OrtStatus Run( OrtSession session, @Const OrtRunOptions run_options,
                    @Cast("const char*const*") @ByPtrPtr BytePointer input_names,
                    @Const @ByPtrPtr OrtValue inputs, @Cast("size_t") long input_len,
                    @Cast("const char*const*") @ByPtrPtr BytePointer output_names, @Cast("size_t") long output_names_len,
                    @ByPtrPtr OrtValue outputs);
  public native OrtStatus Run( OrtSession session, @Const OrtRunOptions run_options,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer input_names,
                    @Const @ByPtrPtr OrtValue inputs, @Cast("size_t") long input_len,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer output_names, @Cast("size_t") long output_names_len,
                    @ByPtrPtr OrtValue outputs);
  public native OrtStatus Run( OrtSession session, @Const OrtRunOptions run_options,
                    @Cast("const char*const*") @ByPtrPtr byte[] input_names,
                    @Const @ByPtrPtr OrtValue inputs, @Cast("size_t") long input_len,
                    @Cast("const char*const*") @ByPtrPtr byte[] output_names, @Cast("size_t") long output_names_len,
                    @ByPtrPtr OrtValue outputs);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Create an ::OrtSessionOptions object
   *
   * To use additional providers, you must build ORT with the extra providers enabled. Then call one of these
   * functions to enable them in the session:<br>
   *   OrtSessionOptionsAppendExecutionProvider_CPU<br>
   *   OrtSessionOptionsAppendExecutionProvider_CUDA<br>
   *   OrtSessionOptionsAppendExecutionProvider_(remaining providers...)<br>
   * The order they are called indicates the preference order as well. In other words call this method
   * on your most preferred execution provider first followed by the less preferred ones.
   * If none are called Ort will use its internal CPU execution provider.
   *
   * @param options [out] The newly created OrtSessionOptions. Must be freed with OrtApi::ReleaseSessionOptions
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateSessionOptions( @Cast("OrtSessionOptions**") PointerPointer options);
  public native OrtStatus CreateSessionOptions( @ByPtrPtr OrtSessionOptions options);

  /** \brief Set filepath to save optimized model after graph level transformations
   *
   * @param options [in]
   * @param optimized_model_filepath [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetOptimizedModelFilePath( OrtSessionOptions options,
                    @Cast("const ORTCHAR_T*") Pointer optimized_model_filepath);

  /** \brief Create a copy of an existing ::OrtSessionOptions
   *
   * @param in_options [in] OrtSessionOptions to copy
   * @param out_options [out] Returned newly created ::OrtSessionOptions. Must be freed with OrtApi::ReleaseSessionOptions
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CloneSessionOptions( @Const OrtSessionOptions in_options,
                    @Cast("OrtSessionOptions**") PointerPointer out_options);
  public native OrtStatus CloneSessionOptions( @Const OrtSessionOptions in_options,
                    @ByPtrPtr OrtSessionOptions out_options);

  /** \brief Set execution mode
   *
   * Controls whether you want to execute operators in your graph sequentially or in parallel. Usually when the model
   *  has many branches, setting this option to ExecutionMode.ORT_PARALLEL will give you better performance.
   *  See [docs/ONNX_Runtime_Perf_Tuning.md] for more details.
   *
   * @param options [in]
   * @param execution_mode [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetSessionExecutionMode( OrtSessionOptions options, @Cast("ExecutionMode") int execution_mode);

  /** \brief Enable profiling for a session
   *
   * @param options [in]
   * @param profile_file_prefix [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus EnableProfiling( OrtSessionOptions options, @Cast("const ORTCHAR_T*") Pointer profile_file_prefix);

  /** \brief Disable profiling for a session
   *
   * @param options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus DisableProfiling( OrtSessionOptions options);

  /** \brief Enable the memory pattern optimization
   *
   * The idea is if the input shapes are the same, we could trace the internal memory allocation
   * and generate a memory pattern for future request. So next time we could just do one allocation
   * with a big chunk for all the internal memory allocation.
   * \note Memory pattern optimization is only available when Sequential Execution mode is enabled (see OrtApi::SetSessionExecutionMode)
   *
   * @see OrtApi::DisableMemPattern
   *
   * @param options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus EnableMemPattern( OrtSessionOptions options);

  /** \brief Disable the memory pattern optimization
   *
   * @see OrtApi::EnableMemPattern
   *
   * @param options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus DisableMemPattern( OrtSessionOptions options);

  /** \brief Enable the memory arena on CPU
   *
   * Arena may pre-allocate memory for future usage.
   *
   * @param options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus EnableCpuMemArena( OrtSessionOptions options);

  /** \brief Disable the memory arena on CPU
   *
   * @param options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus DisableCpuMemArena( OrtSessionOptions options);

  /** \brief Set session log id
   *
   * @param options [in]
   * @param logid [in] The log identifier.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetSessionLogId( OrtSessionOptions options, @Cast("const char*") BytePointer logid);
  public native OrtStatus SetSessionLogId( OrtSessionOptions options, String logid);

  /** \brief Set session log verbosity level
   *
   * Applies to session load, initialization, etc
   *
   * @param options [in]
   * @param session_log_verbosity_level [in] \snippet{doc} snippets.dox Log Verbosity Level
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetSessionLogVerbosityLevel( OrtSessionOptions options, int session_log_verbosity_level);

  /** \brief Set session log severity level
   *
   * @param options [in]
   * @param session_log_severity_level [in] The log severity level (refer to ::OrtLoggingLevel for possible values).
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetSessionLogSeverityLevel( OrtSessionOptions options, int session_log_severity_level);

  /** \brief Set the optimization level to apply when loading a graph
   *
   * Please see https://onnxruntime.ai/docs/performance/model-optimizations/graph-optimizations.html for an in-depth explanation
   * @param options [in,out] The session options object
   * @param graph_optimization_level [in] The optimization level
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetSessionGraphOptimizationLevel( OrtSessionOptions options,
                    @Cast("GraphOptimizationLevel") int graph_optimization_level);

  /** \brief Sets the number of threads used to parallelize the execution within nodes
   *
   * When running a single node operation, ex. add, this sets the maximum number of threads to use.
   *
   * \note If built with OpenMP, this has no effect on the number of threads used. In this case
   *       use the OpenMP env variables to configure the number of intra op num threads.
   *
   * @param options [in]
   * @param intra_op_num_threads [in] Number of threads to use<br>
   *   A value of 0 will use the default number of threads<br>
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetIntraOpNumThreads( OrtSessionOptions options, int intra_op_num_threads);

  /** \brief Sets the number of threads used to parallelize the execution of the graph
   *
   * If nodes can be run in parallel, this sets the maximum number of threads to use to run them in parallel.
   *
   * \note If sequential execution is enabled this value is ignored, it acts as if it was set to 1.
   *
   * @param options [in]
   * @param inter_op_num_threads [in] Number of threads to use<br>
   *   A value of 0 will use the default number of threads<br>
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetInterOpNumThreads( OrtSessionOptions options, int inter_op_num_threads);

  /** \}
   *  \name OrtCustomOpDomain
   *  \{
  <p>
  /** \brief Create a custom op domain
   *
   * @param domain [in]
   * @param out [out] Newly created domain. Must be freed with OrtApi::ReleaseCustomOpDomain
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateCustomOpDomain( @Cast("const char*") BytePointer domain, @Cast("OrtCustomOpDomain**") PointerPointer out);
  public native OrtStatus CreateCustomOpDomain( @Cast("const char*") BytePointer domain, @ByPtrPtr OrtCustomOpDomain out);
  public native OrtStatus CreateCustomOpDomain( String domain, @ByPtrPtr OrtCustomOpDomain out);

  /** \brief Add a custom op to a custom op domain
   *
   * \note The OrtCustomOp* pointer must remain valid until the ::OrtCustomOpDomain using it is released
   *
   * @param custom_op_domain [in]
   * @param op [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CustomOpDomain_Add( OrtCustomOpDomain custom_op_domain, @Const OrtCustomOp op);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Add custom op domain to a session options
   *
   * \note The OrtCustomOpDomain* must not be deleted until all sessions using it are released
   *
   * @param options [in]
   * @param custom_op_domain [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus AddCustomOpDomain( OrtSessionOptions options, OrtCustomOpDomain custom_op_domain);

  /** @deprecated Use OrtApi::RegisterCustomOpsLibrary_V2.
   *
   * Registers custom ops from a shared library.
   *
   * Loads a shared library (dll on windows, so on linux, etc) named 'library_path' and looks for this entry point:
   *		OrtStatus* RegisterCustomOps(OrtSessionOptions * options, const OrtApiBase* api);
   * It then passes in the provided session options to this function along with the api base.
   * The handle to the loaded library is returned in library_handle. It can be freed by the caller after all sessions using the passed in
   * session options are destroyed, or if an error occurs and it is non null.
   *
   * @param options [in]
   * @param library_path [in]
   * @param library_handle [out] OS specific handle to the loaded library (Use FreeLibrary on Windows, dlclose on Linux, etc.. to unload)
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus RegisterCustomOpsLibrary( OrtSessionOptions options, @Cast("const char*") BytePointer library_path, @Cast("void**") PointerPointer library_handle);
  public native OrtStatus RegisterCustomOpsLibrary( OrtSessionOptions options, @Cast("const char*") BytePointer library_path, @Cast("void**") @ByPtrPtr Pointer library_handle);
  public native OrtStatus RegisterCustomOpsLibrary( OrtSessionOptions options, String library_path, @Cast("void**") @ByPtrPtr Pointer library_handle);

  /** \}
   *  \name OrtSession
   *  \{
  <p>
  /** \brief Get input count for a session
   *
   * This number must also match the number of inputs passed to OrtApi::Run
   *
   * @see OrtApi::SessionGetInputTypeInfo, OrtApi::SessionGetInputName, OrtApi::Session
   *
   * @param session [in]
   * @param out [out] Number of inputs
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionGetInputCount( @Const OrtSession session, @Cast("size_t*") SizeTPointer out);

  /** \brief Get output count for a session
   *
   * This number must also match the number of outputs returned by OrtApi::Run
   *
   * @see OrtApi::SessionGetOutputTypeInfo, OrtApi::SessionGetOutputName, OrtApi::Session
   *
   * @param session [in]
   * @param out [out] Number of outputs
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionGetOutputCount( @Const OrtSession session, @Cast("size_t*") SizeTPointer out);

  /** \brief Get overridable initializer count
   *
   * @see OrtApi::SessionGetOverridableInitializerTypeInfo, OrtApi::SessionGetOverridableInitializerName
   *
   * @param session [in]
   * @param out [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionGetOverridableInitializerCount( @Const OrtSession session, @Cast("size_t*") SizeTPointer out);

  /** \brief Get input type information
   *
   * @param session [in]
   * @param index [in] Must be between 0 (inclusive) and what OrtApi::SessionGetInputCount returns (exclusive)
   * @param type_info [out] Must be freed with OrtApi::ReleaseTypeInfo
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionGetInputTypeInfo( @Const OrtSession session, @Cast("size_t") long index, @Cast("OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus SessionGetInputTypeInfo( @Const OrtSession session, @Cast("size_t") long index, @ByPtrPtr OrtTypeInfo type_info);

  /** \brief Get output type information
   *
   * @param session [in]
   * @param index [in] Must be between 0 (inclusive) and what OrtApi::SessionGetOutputCount returns (exclusive)
   * @param type_info [out] Must be freed with OrtApi::ReleaseTypeInfo
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionGetOutputTypeInfo( @Const OrtSession session, @Cast("size_t") long index, @Cast("OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus SessionGetOutputTypeInfo( @Const OrtSession session, @Cast("size_t") long index, @ByPtrPtr OrtTypeInfo type_info);

  /** \brief Get overridable initializer type information
   *
   * @param session [in]
   * @param index [in] Must be between 0 (inclusive) and what OrtApi::SessionGetOverridableInitializerCount returns (exclusive)
   * @param type_info [out] Must be freed with OrtApi::ReleaseTypeInfo
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionGetOverridableInitializerTypeInfo( @Const OrtSession session, @Cast("size_t") long index, @Cast("OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus SessionGetOverridableInitializerTypeInfo( @Const OrtSession session, @Cast("size_t") long index, @ByPtrPtr OrtTypeInfo type_info);

  /** \brief Get input name
   *
   * @param session [in]
   * @param index [in] Must be between 0 (inclusive) and what OrtApi::SessionGetInputCount returns (exclusive)
   * @param allocator [in]
   * @param value [out] Set to a null terminated UTF-8 encoded string allocated using {@code allocator}. Must be freed using {@code allocator}.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionGetInputName( @Const OrtSession session, @Cast("size_t") long index, OrtAllocator allocator, @Cast("char**") PointerPointer value);
  public native OrtStatus SessionGetInputName( @Const OrtSession session, @Cast("size_t") long index, OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus SessionGetInputName( @Const OrtSession session, @Cast("size_t") long index, OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus SessionGetInputName( @Const OrtSession session, @Cast("size_t") long index, OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] value);

  /** \brief Get output name
   *
   * @param session [in]
   * @param index [in] Must be between 0 (inclusive) and what OrtApi::SessionGetOutputCount returns (exclusive)
   * @param allocator [in]
   * @param value [out] Set to a null terminated UTF-8 encoded string allocated using {@code allocator}. Must be freed using {@code allocator}.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionGetOutputName( @Const OrtSession session, @Cast("size_t") long index, OrtAllocator allocator, @Cast("char**") PointerPointer value);
  public native OrtStatus SessionGetOutputName( @Const OrtSession session, @Cast("size_t") long index, OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus SessionGetOutputName( @Const OrtSession session, @Cast("size_t") long index, OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus SessionGetOutputName( @Const OrtSession session, @Cast("size_t") long index, OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] value);

  /** \brief Get overridable initializer name
   *
   * @param session [in]
   * @param index [in] Must be between 0 (inclusive) and what OrtApi::SessionGetOverridableInitializerCount returns (exclusive)
   * @param allocator [in]
   * @param value [out] Set to a null terminated UTF-8 encoded string allocated using {@code allocator}. Must be freed using {@code allocator}.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionGetOverridableInitializerName( @Const OrtSession session, @Cast("size_t") long index,
                    OrtAllocator allocator, @Cast("char**") PointerPointer value);
  public native OrtStatus SessionGetOverridableInitializerName( @Const OrtSession session, @Cast("size_t") long index,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus SessionGetOverridableInitializerName( @Const OrtSession session, @Cast("size_t") long index,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus SessionGetOverridableInitializerName( @Const OrtSession session, @Cast("size_t") long index,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] value);

  /** \}
   *  \name OrtRunOptions
   *  \{
  <p>
  /** \brief Create an OrtRunOptions
   *
   * @param out [out] Returned newly created ::OrtRunOptions. Must be freed with OrtApi::ReleaseRunOptions
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateRunOptions( @Cast("OrtRunOptions**") PointerPointer out);
  public native OrtStatus CreateRunOptions( @ByPtrPtr OrtRunOptions out);

  /** \brief Set per-run log verbosity level
   *
   * @see OrtApi::RunOptionsGetRunLogVerbosityLevel
   *
   * @param options [in]
   * @param log_verbosity_level [in] \snippet{doc} snippets.dox Log Verbosity Level
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus RunOptionsSetRunLogVerbosityLevel( OrtRunOptions options, int log_verbosity_level);

  /** \brief Set per-run log severity level
   *
   * @see OrtApi::RunOptionsGetRunLogSeverityLevel
   *
   * @param options [in]
   * @param log_severity_level [in] The log severity level (refer to ::OrtLoggingLevel for possible values).
   */
  public native OrtStatus RunOptionsSetRunLogSeverityLevel( OrtRunOptions options, int log_severity_level);

  /** \brief Set per-run tag
   *
   * This is used in a per-run log identifier.
   *
   * @see OrtApi::RunOptionsGetRunTag
   *
   * @param options [in]
   * @param run_tag [in] The run tag.
   */
  public native OrtStatus RunOptionsSetRunTag( OrtRunOptions options, @Cast("const char*") BytePointer run_tag);
  public native OrtStatus RunOptionsSetRunTag( OrtRunOptions options, String run_tag);

  /** \brief Get per-run log verbosity level
   *
   * @see OrtApi::RunOptionsSetRunLogVerbosityLevel
   *
   * @param options [in]
   * @param log_verbosity_level [out] \snippet{doc} snippets.dox Log Verbosity Level
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus RunOptionsGetRunLogVerbosityLevel( @Const OrtRunOptions options,
                    IntPointer log_verbosity_level);
  public native OrtStatus RunOptionsGetRunLogVerbosityLevel( @Const OrtRunOptions options,
                    IntBuffer log_verbosity_level);
  public native OrtStatus RunOptionsGetRunLogVerbosityLevel( @Const OrtRunOptions options,
                    int[] log_verbosity_level);

  /** \brief Get per-run log severity level
   *
   * @see OrtApi::RunOptionsSetRunLogSeverityLevel
   *
   * @param options [in]
   * @param log_severity_level [out] The log severity level (refer to ::OrtLoggingLevel for possible values).
   */
  public native OrtStatus RunOptionsGetRunLogSeverityLevel( @Const OrtRunOptions options, IntPointer log_severity_level);
  public native OrtStatus RunOptionsGetRunLogSeverityLevel( @Const OrtRunOptions options, IntBuffer log_severity_level);
  public native OrtStatus RunOptionsGetRunLogSeverityLevel( @Const OrtRunOptions options, int[] log_severity_level);

  /** \brief Get per-run tag
   *
   * This is used in a per-run log identifier.
   *
   * @see OrtApi::RunOptionsSetRunTag
   *
   * @param options [in]
   * @param run_tag [out] The run tag.
   *                     Do not free this value, it is owned by {@code options}. It will be invalidated if the run tag
   *                     changes (i.e., with OrtApi::RunOptionsSetRunTag) or {@code options} is freed.
   */
  public native OrtStatus RunOptionsGetRunTag( @Const OrtRunOptions options, @Cast("const char**") PointerPointer run_tag);
  public native OrtStatus RunOptionsGetRunTag( @Const OrtRunOptions options, @Cast("const char**") @ByPtrPtr BytePointer run_tag);
  public native OrtStatus RunOptionsGetRunTag( @Const OrtRunOptions options, @Cast("const char**") @ByPtrPtr ByteBuffer run_tag);
  public native OrtStatus RunOptionsGetRunTag( @Const OrtRunOptions options, @Cast("const char**") @ByPtrPtr byte[] run_tag);

  /** \brief Set terminate flag
   *
   * If a currently executing session needs to be force terminated, this can be called from another thread to force it to fail with an error.
   *
   * @param options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus RunOptionsSetTerminate( OrtRunOptions options);

  /** \brief Clears the terminate flag
   *
   * Used so the OrtRunOptions instance can be used in a new OrtApi::Run call without it instantly terminating
   *
   * @param options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus RunOptionsUnsetTerminate( OrtRunOptions options);

  /** \}
   *  \name OrtValue
   *  \{
  <p>
  /** \brief Create a tensor
   *
   * Create a tensor using a supplied ::OrtAllocator
   *
   * @param allocator [in]
   * @param shape [in] Pointer to the tensor shape dimensions.
   * @param shape_len [in] The number of tensor shape dimensions.
   * @param type [in]
   * @param out [out] Returns newly created ::OrtValue. Must be freed with OrtApi::ReleaseValue
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateTensorAsOrtValue( OrtAllocator allocator, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len,
                    @Cast("ONNXTensorElementDataType") int type, @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus CreateTensorAsOrtValue( OrtAllocator allocator, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len,
                    @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);
  public native OrtStatus CreateTensorAsOrtValue( OrtAllocator allocator, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len,
                    @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);
  public native OrtStatus CreateTensorAsOrtValue( OrtAllocator allocator, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len,
                    @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);

  /** \brief Create a tensor backed by a user supplied buffer
   *
   * Create a tensor with user's buffer. You can fill the buffer either before calling this function or after.
   * p_data is owned by caller. ReleaseValue won't release p_data.
   *
   * If you wish to transfer ownership of p_data to ORT use CreateTensorWithDataAndDeleterAsOrtValue.
   *
   * @param info [in] Memory description of where the p_data buffer resides (CPU vs GPU etc).
   * @param p_data [in] Pointer to the data buffer.
   * @param p_data_len [in] The number of bytes in the data buffer.
   * @param shape [in] Pointer to the tensor shape dimensions.
   * @param shape_len [in] The number of tensor shape dimensions.
   * @param type [in] The data type.
   * @param out [out] Returns newly created ::OrtValue. Must be freed with OrtApi::ReleaseValue
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateTensorWithDataAsOrtValue( @Const OrtMemoryInfo info, Pointer p_data,
                    @Cast("size_t") long p_data_len, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len, @Cast("ONNXTensorElementDataType") int type,
                    @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus CreateTensorWithDataAsOrtValue( @Const OrtMemoryInfo info, Pointer p_data,
                    @Cast("size_t") long p_data_len, @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len, @Cast("ONNXTensorElementDataType") int type,
                    @ByPtrPtr OrtValue out);
  public native OrtStatus CreateTensorWithDataAsOrtValue( @Const OrtMemoryInfo info, Pointer p_data,
                    @Cast("size_t") long p_data_len, @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len, @Cast("ONNXTensorElementDataType") int type,
                    @ByPtrPtr OrtValue out);
  public native OrtStatus CreateTensorWithDataAsOrtValue( @Const OrtMemoryInfo info, Pointer p_data,
                    @Cast("size_t") long p_data_len, @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len, @Cast("ONNXTensorElementDataType") int type,
                    @ByPtrPtr OrtValue out);

  /** \brief Return if an ::OrtValue is a tensor type
   *
   * @param value [in] A tensor type (string tensors are not supported)
   * @param out [out] Set to 1 iff ::OrtValue is a tensor, 0 otherwise
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus IsTensor( @Const OrtValue value, IntPointer out);
  public native OrtStatus IsTensor( @Const OrtValue value, IntBuffer out);
  public native OrtStatus IsTensor( @Const OrtValue value, int[] out);

  /** \brief Get a pointer to the raw data inside a tensor
   *
   * Used to read/write/modify the internal tensor data directly.
   * \note The returned pointer is valid until the \p value is destroyed.
   *
   * @param value [in] A tensor type (string tensors are not supported)
   * @param out [out] Filled in with a pointer to the internal storage
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetTensorMutableData( OrtValue value, @Cast("void**") PointerPointer out);
  public native OrtStatus GetTensorMutableData( OrtValue value, @Cast("void**") @ByPtrPtr Pointer out);

  /** \brief Set all strings at once in a string tensor
   *
   * @param value [in,out] A tensor of type ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING
   * @param s [in] An array of strings. Each string in this array must be null terminated.
   * @param s_len [in] Count of strings in s (Must match the size of \p value's tensor shape)
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus FillStringTensor( OrtValue value, @Cast("const char*const*") PointerPointer s, @Cast("size_t") long s_len);
  public native OrtStatus FillStringTensor( OrtValue value, @Cast("const char*const*") @ByPtrPtr BytePointer s, @Cast("size_t") long s_len);
  public native OrtStatus FillStringTensor( OrtValue value, @Cast("const char*const*") @ByPtrPtr ByteBuffer s, @Cast("size_t") long s_len);
  public native OrtStatus FillStringTensor( OrtValue value, @Cast("const char*const*") @ByPtrPtr byte[] s, @Cast("size_t") long s_len);

  /** \brief Get total byte length for all strings in a string tensor
   *
   * Typically used with OrtApi::GetStringTensorContent
   *
   * @param value [in] A tensor of type ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING
   * @param len [out] Total byte length of all strings (does not include trailing nulls)
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetStringTensorDataLength( @Const OrtValue value, @Cast("size_t*") SizeTPointer len);

  /** \brief Get all strings from a string tensor
   *
   * An example of the results:<br>
   * Given \p value is a string tensor with the strings { "This" "is" "a" "test" }<br>
   * \p s must have a size of 11 bytes<br>
   * \p offsets must have 4 elements<br>
   * After the call, these values will be filled in:<br>
   * \p s will contain "Thisisatest"<br>
   * \p offsets will contain { 0, 4, 6, 7 }<br>
   * The length of the last string is just s_len - offsets[last]
   *
   * @param value [in] A tensor of type ONNX_TENSOR_ELEMENT_DATA_TYPE_STRING
   * @param s [in] Buffer to sequentially write all tensor strings to. Each string is NOT null-terminated.
   * @param s_len [in] Number of bytes of buffer pointed to by \p s (Get it from OrtApi::GetStringTensorDataLength)
   * @param offsets [out] Array of start offsets into the strings written to \p s
   * @param offsets_len [in] Number of elements in offsets
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetStringTensorContent( @Const OrtValue value, Pointer s,
                    @Cast("size_t") long s_len, @Cast("size_t*") SizeTPointer offsets, @Cast("size_t") long offsets_len);

  /** \}
   *  \name OrtTypeInfo
   *  \{
  <p>
  /** \brief Get ::OrtTensorTypeAndShapeInfo from an ::OrtTypeInfo
   *
   * @param type_info [in]
   * @param out [out] Do not free this value, it will be valid until type_info is freed.
   *             If type_info does not represent tensor, this value will be set to nullptr.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CastTypeInfoToTensorInfo( @Const OrtTypeInfo type_info,
                    @Cast("const OrtTensorTypeAndShapeInfo**") PointerPointer out);
  public native OrtStatus CastTypeInfoToTensorInfo( @Const OrtTypeInfo type_info,
                    @Const @ByPtrPtr OrtTensorTypeAndShapeInfo out);

  /** \brief Get ::ONNXType from ::OrtTypeInfo
   *
   * @param type_info [in]
   * @param out [out]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetOnnxTypeFromTypeInfo( @Const OrtTypeInfo type_info, @Cast("ONNXType*") IntPointer out);
  public native OrtStatus GetOnnxTypeFromTypeInfo( @Const OrtTypeInfo type_info, @Cast("ONNXType*") IntBuffer out);
  public native OrtStatus GetOnnxTypeFromTypeInfo( @Const OrtTypeInfo type_info, @Cast("ONNXType*") int[] out);

  /** \}
   *  \name OrtTensorTypeAndShapeInfo
   *  \{
  <p>
  /** \brief Create an ::OrtTensorTypeAndShapeInfo object
   *
   * @param out [out] Returns newly created ::OrtTensorTypeAndShapeInfo. Must be freed with OrtApi::ReleaseTensorTypeAndShapeInfo
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateTensorTypeAndShapeInfo( @Cast("OrtTensorTypeAndShapeInfo**") PointerPointer out);
  public native OrtStatus CreateTensorTypeAndShapeInfo( @ByPtrPtr OrtTensorTypeAndShapeInfo out);

  /** \brief Set element type in ::OrtTensorTypeAndShapeInfo
   *
   * @param info [in]
   * @param type [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetTensorElementType( OrtTensorTypeAndShapeInfo info, @Cast("ONNXTensorElementDataType") int type);

  /** \brief Set shape information in ::OrtTensorTypeAndShapeInfo
   *
   * @param info [in]
   * @param dim_values [in] Array with {@code dim_count} elements. Can contain negative values.
   * @param dim_count [in] Number of elements in {@code dim_values}
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetDimensions( OrtTensorTypeAndShapeInfo info, @Cast("const int64_t*") LongPointer dim_values, @Cast("size_t") long dim_count);
  public native OrtStatus SetDimensions( OrtTensorTypeAndShapeInfo info, @Cast("const int64_t*") LongBuffer dim_values, @Cast("size_t") long dim_count);
  public native OrtStatus SetDimensions( OrtTensorTypeAndShapeInfo info, @Cast("const int64_t*") long[] dim_values, @Cast("size_t") long dim_count);

  /** \brief Get element type in ::OrtTensorTypeAndShapeInfo
   *
   * @see OrtApi::SetTensorElementType
   *
   * @param info [in]
   * @param out [out]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetTensorElementType( @Const OrtTensorTypeAndShapeInfo info,
                    @Cast("ONNXTensorElementDataType*") IntPointer out);
  public native OrtStatus GetTensorElementType( @Const OrtTensorTypeAndShapeInfo info,
                    @Cast("ONNXTensorElementDataType*") IntBuffer out);
  public native OrtStatus GetTensorElementType( @Const OrtTensorTypeAndShapeInfo info,
                    @Cast("ONNXTensorElementDataType*") int[] out);

  /** \brief Get dimension count in ::OrtTensorTypeAndShapeInfo
   *
   * @see OrtApi::GetDimensions
   *
   * @param info [in]
   * @param out [out]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetDimensionsCount( @Const OrtTensorTypeAndShapeInfo info, @Cast("size_t*") SizeTPointer out);

  /** \brief Get dimensions in ::OrtTensorTypeAndShapeInfo
   *
   * @param info [in]
   * @param dim_values [out] Array with {@code dim_values_length} elements. On return, filled with the dimensions stored in the ::OrtTensorTypeAndShapeInfo
   * @param dim_values_length [in] Number of elements in {@code dim_values}. Use OrtApi::GetDimensionsCount to get this value
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetDimensions( @Const OrtTensorTypeAndShapeInfo info, @Cast("int64_t*") LongPointer dim_values,
                    @Cast("size_t") long dim_values_length);
  public native OrtStatus GetDimensions( @Const OrtTensorTypeAndShapeInfo info, @Cast("int64_t*") LongBuffer dim_values,
                    @Cast("size_t") long dim_values_length);
  public native OrtStatus GetDimensions( @Const OrtTensorTypeAndShapeInfo info, @Cast("int64_t*") long[] dim_values,
                    @Cast("size_t") long dim_values_length);

  /** \brief Get symbolic dimension names in ::OrtTensorTypeAndShapeInfo
   *
   * @param info [in]
   * @param dim_params [in] Array with {@code dim_params_length} elements. On return filled with pointers to null terminated strings of the dimension names
   * @param dim_params_length [in] Number of elements in {@code dim_params}. Use OrtApi::GetDimensionsCount to get this value
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetSymbolicDimensions( @Const OrtTensorTypeAndShapeInfo info,
                    @Cast("const char**") PointerPointer dim_params, @Cast("size_t") long dim_params_length);
  public native OrtStatus GetSymbolicDimensions( @Const OrtTensorTypeAndShapeInfo info,
                    @Cast("const char**") @ByPtrPtr BytePointer dim_params, @Cast("size_t") long dim_params_length);
  public native OrtStatus GetSymbolicDimensions( @Const OrtTensorTypeAndShapeInfo info,
                    @Cast("const char**") @ByPtrPtr ByteBuffer dim_params, @Cast("size_t") long dim_params_length);
  public native OrtStatus GetSymbolicDimensions( @Const OrtTensorTypeAndShapeInfo info,
                    @Cast("const char**") @ByPtrPtr byte[] dim_params, @Cast("size_t") long dim_params_length);

  /** \brief Get total number of elements in a tensor shape from an ::OrtTensorTypeAndShapeInfo
   *
   * Return the number of elements specified by the tensor shape (all dimensions multiplied by each other).
   * For 0 dimensions, 1 is returned. If any dimension is less than 0, the result is always -1.
   *
   * Examples:<br>
   * [] = 1<br>
   * [1,3,4] = 12<br>
   * [2,0,4] = 0<br>
   * [-1,3,4] = -1<br>
   *
   * @param info [in]
   * @param out [out] Number of elements
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetTensorShapeElementCount( @Const OrtTensorTypeAndShapeInfo info, @Cast("size_t*") SizeTPointer out);

  /** \}
   *  \name OrtValue
   *  \{
  <p>
  /** \brief Get type and shape information from a tensor ::OrtValue
   *
   * @param value [in] Must be a tensor (not a map/sequence/etc) or will return failure
   * @param out [out] Newly created ::OrtTensorTypeAndShapeInfo. Must be freed with OrtApi::ReleaseTensorTypeAndShapeInfo
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetTensorTypeAndShape( @Const OrtValue value, @Cast("OrtTensorTypeAndShapeInfo**") PointerPointer out);
  public native OrtStatus GetTensorTypeAndShape( @Const OrtValue value, @ByPtrPtr OrtTensorTypeAndShapeInfo out);

  /** \brief Get type information of an OrtValue
   *
   * @param value [in]
   * @param out [out] Newly created ::OrtTypeInfo. Must be freed with OrtApi::ReleaseTypeInfo
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetTypeInfo( @Const OrtValue value, @Cast("OrtTypeInfo**") PointerPointer out);
  public native OrtStatus GetTypeInfo( @Const OrtValue value, @ByPtrPtr OrtTypeInfo out);

  /** \brief Get ONNXType of an ::OrtValue
   *
   * @param value [in]
   * @param out [out]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetValueType( @Const OrtValue value, @Cast("ONNXType*") IntPointer out);
  public native OrtStatus GetValueType( @Const OrtValue value, @Cast("ONNXType*") IntBuffer out);
  public native OrtStatus GetValueType( @Const OrtValue value, @Cast("ONNXType*") int[] out);

  /** \}
   *  \name OrtMemoryInfo
   *  \{
  <p>
  /** \brief Create an ::OrtMemoryInfo
   *
   * @param name [in]
   * @param type [in]
   * @param id [in]
   * @param mem_type [in]
   * @param out [out] Newly created ::OrtMemoryInfo. Must be freed with OrtAPi::ReleaseMemoryInfo
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateMemoryInfo( @Cast("const char*") BytePointer name, @Cast("OrtAllocatorType") int type, int id,
                    @Cast("OrtMemType") int mem_type, @Cast("OrtMemoryInfo**") PointerPointer out);
  public native OrtStatus CreateMemoryInfo( @Cast("const char*") BytePointer name, @Cast("OrtAllocatorType") int type, int id,
                    @Cast("OrtMemType") int mem_type, @ByPtrPtr OrtMemoryInfo out);
  public native OrtStatus CreateMemoryInfo( String name, @Cast("OrtAllocatorType") int type, int id,
                    @Cast("OrtMemType") int mem_type, @ByPtrPtr OrtMemoryInfo out);

  /** \brief Create an ::OrtMemoryInfo for CPU memory
   *
   * Special case version of OrtApi::CreateMemoryInfo for CPU based memory. Same as using OrtApi::CreateMemoryInfo with name = "Cpu" and id = 0.
   *
   * @param type [in]
   * @param mem_type [in]
   * @param out [out]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateCpuMemoryInfo( @Cast("OrtAllocatorType") int type, @Cast("OrtMemType") int mem_type,
                    @Cast("OrtMemoryInfo**") PointerPointer out);
  public native OrtStatus CreateCpuMemoryInfo( @Cast("OrtAllocatorType") int type, @Cast("OrtMemType") int mem_type,
                    @ByPtrPtr OrtMemoryInfo out);

  /** \brief Compare ::OrtMemoryInfo objects for equality
   *
   * Compares all settings of each ::OrtMemoryInfo for equality
   *
   * @param info [in] 1
   * @param info [in] 2
   * @param out [out] Set to 0 if equal, -1 if not equal
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CompareMemoryInfo( @Const OrtMemoryInfo info1, @Const OrtMemoryInfo info2, IntPointer out);
  public native OrtStatus CompareMemoryInfo( @Const OrtMemoryInfo info1, @Const OrtMemoryInfo info2, IntBuffer out);
  public native OrtStatus CompareMemoryInfo( @Const OrtMemoryInfo info1, @Const OrtMemoryInfo info2, int[] out);

  /** \brief Get name from ::OrtMemoryInfo
   *
   * @param ptr [in]
   * @param out [out] Writes null terminated string to this pointer. Do NOT free the returned pointer. It is valid for the lifetime of the ::OrtMemoryInfo
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus MemoryInfoGetName( @Const OrtMemoryInfo ptr, @Cast("const char**") PointerPointer out);
  public native OrtStatus MemoryInfoGetName( @Const OrtMemoryInfo ptr, @Cast("const char**") @ByPtrPtr BytePointer out);
  public native OrtStatus MemoryInfoGetName( @Const OrtMemoryInfo ptr, @Cast("const char**") @ByPtrPtr ByteBuffer out);
  public native OrtStatus MemoryInfoGetName( @Const OrtMemoryInfo ptr, @Cast("const char**") @ByPtrPtr byte[] out);

  /** \brief Get the device id from ::OrtMemoryInfo
   */
  public native OrtStatus MemoryInfoGetId( @Const OrtMemoryInfo ptr, IntPointer out);
  public native OrtStatus MemoryInfoGetId( @Const OrtMemoryInfo ptr, IntBuffer out);
  public native OrtStatus MemoryInfoGetId( @Const OrtMemoryInfo ptr, int[] out);

  /** \brief Get the ::OrtMemType from ::OrtMemoryInfo
   */
  public native OrtStatus MemoryInfoGetMemType( @Const OrtMemoryInfo ptr, @Cast("OrtMemType*") IntPointer out);
  public native OrtStatus MemoryInfoGetMemType( @Const OrtMemoryInfo ptr, @Cast("OrtMemType*") IntBuffer out);
  public native OrtStatus MemoryInfoGetMemType( @Const OrtMemoryInfo ptr, @Cast("OrtMemType*") int[] out);

  /** \brief Get the ::OrtAllocatorType from ::OrtMemoryInfo
   */
  public native OrtStatus MemoryInfoGetType( @Const OrtMemoryInfo ptr, @Cast("OrtAllocatorType*") IntPointer out);
  public native OrtStatus MemoryInfoGetType( @Const OrtMemoryInfo ptr, @Cast("OrtAllocatorType*") IntBuffer out);
  public native OrtStatus MemoryInfoGetType( @Const OrtMemoryInfo ptr, @Cast("OrtAllocatorType*") int[] out);

  /** \}
   *  \name OrtAllocator
   *  \{
   <p>
   *  \brief Calls OrtAllocator::Alloc function */
  public native OrtStatus AllocatorAlloc( OrtAllocator ort_allocator, @Cast("size_t") long size, @Cast("void**") PointerPointer out);
  public native OrtStatus AllocatorAlloc( OrtAllocator ort_allocator, @Cast("size_t") long size, @Cast("void**") @ByPtrPtr Pointer out);
  /** \brief Calls OrtAllocator::Free function */
  public native OrtStatus AllocatorFree( OrtAllocator ort_allocator, Pointer p);
  /** \brief Calls OrtAllocator::Info function */
  public native OrtStatus AllocatorGetInfo( @Const OrtAllocator ort_allocator, @Cast("const OrtMemoryInfo**") PointerPointer out);
  public native OrtStatus AllocatorGetInfo( @Const OrtAllocator ort_allocator, @Const @ByPtrPtr OrtMemoryInfo out);

  /** \brief Get the default allocator
   *
   * The default allocator is a CPU based, non-arena. Always returns the same pointer to the same default allocator.
   *
   * @param out [out] Returned value should NOT be freed
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetAllocatorWithDefaultOptions( @Cast("OrtAllocator**") PointerPointer out);
  public native OrtStatus GetAllocatorWithDefaultOptions( @ByPtrPtr OrtAllocator out);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Override session symbolic dimensions
   *
   * Override symbolic dimensions (by specific denotation strings) with actual values if known at session initialization time to enable
   * optimizations that can take advantage of fixed values (such as memory planning, etc)
   *
   * @param options [in]
   * @param dim_denotation [in]
   * @param dim_value [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus AddFreeDimensionOverride( OrtSessionOptions options, @Cast("const char*") BytePointer dim_denotation,
                    @Cast("int64_t") long dim_value);
  public native OrtStatus AddFreeDimensionOverride( OrtSessionOptions options, String dim_denotation,
                    @Cast("int64_t") long dim_value);

  /** \}
   *  \name OrtValue
   *  \{ */

  /* Internal information (not seen in Doxygen)
   *
   * APIs to support non-tensor types - map and sequence.
   * Currently only the following types are supported
   * Note: the following types should be kept in sync with data_types.h
   * Map types
   * =========
   * std::map<std::string, std::string>
   * std::map<std::string, int64_t>
   * std::map<std::string, float>
   * std::map<std::string, double>
   * std::map<int64_t, std::string>
   * std::map<int64_t, int64_t>
   * std::map<int64_t, float>
   * std::map<int64_t, double>
   *
   * Sequence types
   * ==============
   * std::vector<std::string>
   * std::vector<int64_t>
   * std::vector<float>
   * std::vector<double>
   * std::vector<std::map<std::string, float>>
   * std::vector<std::map<int64_t, float>
   */

  /** \brief Get non tensor data from an ::OrtValue
   *
   * If {@code value} is of type ONNX_TYPE_MAP, you need to retrieve the keys and values
   * separately. Use index=0 to retrieve keys and index=1 to retrieve values.
   * If {@code value} is of type ONNX_TYPE_SEQUENCE, use index to retrieve the index'th element
   * of the sequence.
   *
   * @param value [in]
   * @param index [in] See above for usage based on {@code value} type
   * @param allocator [in] Allocator used to allocate ::OrtValue
   * @param out [out] Created ::OrtValue that holds the element requested. Must be freed with OrtApi::ReleaseValue
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetValue( @Const OrtValue value, int index, OrtAllocator allocator,
                    @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus GetValue( @Const OrtValue value, int index, OrtAllocator allocator,
                    @ByPtrPtr OrtValue out);

  /** \brief Get non tensor value count from an ::OrtValue
   *
   * If {@code value} is of type ONNX_TYPE_MAP 2 will always be returned. For ONNX_TYPE_SEQUENCE
   * the number of elements in the sequence will be returned
   *
   * @param value [in]
   * @param out [out]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetValueCount( @Const OrtValue value, @Cast("size_t*") SizeTPointer out);

  /** \brief Create a map or sequence ::OrtValue
   *
   * To construct a map (ONNX_TYPE_MAP), use num_values = 2 and {@code in} should be an array of 2 ::OrtValue%s
   * representing keys and values.<br>
   *
   * To construct a sequence (ONNX_TYPE_SEQUENCE), use num_values = N where N is the number of the elements in the
   * sequence. 'in' should be an array of N ::OrtValue%s.
   *
   * @param in [in] See above for details
   * @param num_values [in]
   * @param value_type [in] Must be either ONNX_TYPE_MAP or ONNX_TYPE_SEQUENCE
   * @param out [out] Newly created ::OrtValue. Must be freed with OrtApi::ReleaseValue
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateValue( @Cast("const OrtValue*const*") PointerPointer in, @Cast("size_t") long num_values,
                    @Cast("ONNXType") int value_type, @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus CreateValue( @Const @ByPtrPtr OrtValue in, @Cast("size_t") long num_values,
                    @Cast("ONNXType") int value_type, @ByPtrPtr OrtValue out);

  /** \brief Create an opaque (custom user defined type) ::OrtValue
   *
   * Constructs an ::OrtValue that contains a value of non-standard type created for
   * experiments or while awaiting standardization. ::OrtValue in this case would contain
   * an internal representation of the Opaque type. Opaque types are distinguished from
   * each other by two strings 1) domain and 2) type name. The combination of the two
   * must be unique, so the type representation is properly identified internally. The combination
   * must be properly registered from within ORT at both compile/run time or by another API.
   *
   * To construct the ::OrtValue pass domain and type names, also a pointer to a data container
   * the type of which must be known to both ORT and the client program. That data container may or may
   * not match the internal representation of the Opaque type. The sizeof(data_container) is passed for
   * verification purposes.
   *
   * @param domain_name [in] Null terminated string of the domain name
   * @param type_name [in] Null terminated string of the type name
   * @param data_container [in] User pointer Data to populate ::OrtValue
   * @param data_container_size [in] Size in bytes of what {@code data_container} points to
   * @param out [out] Newly created ::OrtValue. Must be freed with OrtApi::ReleaseValue
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateOpaqueValue( @Cast("const char*") BytePointer domain_name, @Cast("const char*") BytePointer type_name,
                    @Const Pointer data_container, @Cast("size_t") long data_container_size, @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus CreateOpaqueValue( @Cast("const char*") BytePointer domain_name, @Cast("const char*") BytePointer type_name,
                    @Const Pointer data_container, @Cast("size_t") long data_container_size, @ByPtrPtr OrtValue out);
  public native OrtStatus CreateOpaqueValue( String domain_name, String type_name,
                    @Const Pointer data_container, @Cast("size_t") long data_container_size, @ByPtrPtr OrtValue out);

  /** \brief Get internal data from an opaque (custom user defined type) ::OrtValue
   *
   * Copies internal data from an opaque value into a user provided buffer
   *
   * @see OrtApi::CreateOpaqueValue
   *
   * @param domain_name [in] Null terminated string of the domain name
   * @param type_name [in] Null terminated string of the type name
   * @param in [in] The opaque ::OrtValue
   * @param data_container [out] Buffer to copy data into
   * @param data_container_size [out] Size in bytes of the buffer pointed to by data_container. Must match the size of the internal buffer.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetOpaqueValue( @Cast("const char*") BytePointer domain_name, @Cast("const char*") BytePointer type_name, @Const OrtValue in,
                    Pointer data_container, @Cast("size_t") long data_container_size);
  public native OrtStatus GetOpaqueValue( String domain_name, String type_name, @Const OrtValue in,
                    Pointer data_container, @Cast("size_t") long data_container_size);

  /** \}
   *  \name OrtKernelInfo
   *  Custom operator APIs.
   *  \{
  <p>
  /** \brief Get a float stored as an attribute in the graph node
   *
   * @param info [in] ::OrtKernelInfo instance
   * @param name [in] Null terminated string of the name of the attribute
   * @param out [out] Pointer to memory where the attribute will be stored
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus KernelInfoGetAttribute_float( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    FloatPointer out);
  public native OrtStatus KernelInfoGetAttribute_float( @Const OrtKernelInfo info, String name,
                    FloatBuffer out);
  public native OrtStatus KernelInfoGetAttribute_float( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    float[] out);
  public native OrtStatus KernelInfoGetAttribute_float( @Const OrtKernelInfo info, String name,
                    FloatPointer out);
  public native OrtStatus KernelInfoGetAttribute_float( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    FloatBuffer out);
  public native OrtStatus KernelInfoGetAttribute_float( @Const OrtKernelInfo info, String name,
                    float[] out);

  /** \brief Fetch a 64-bit int stored as an attribute in the graph node
   *
   * @param info [in] ::OrtKernelInfo instance
   * @param name [in] Null terminated string of the name of the attribute
   * @param out [out] Pointer to memory where the attribute will be stored
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus KernelInfoGetAttribute_int64( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    @Cast("int64_t*") LongPointer out);
  public native OrtStatus KernelInfoGetAttribute_int64( @Const OrtKernelInfo info, String name,
                    @Cast("int64_t*") LongBuffer out);
  public native OrtStatus KernelInfoGetAttribute_int64( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    @Cast("int64_t*") long[] out);
  public native OrtStatus KernelInfoGetAttribute_int64( @Const OrtKernelInfo info, String name,
                    @Cast("int64_t*") LongPointer out);
  public native OrtStatus KernelInfoGetAttribute_int64( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    @Cast("int64_t*") LongBuffer out);
  public native OrtStatus KernelInfoGetAttribute_int64( @Const OrtKernelInfo info, String name,
                    @Cast("int64_t*") long[] out);

  /** \brief Fetch a string stored as an attribute in the graph node
   *
   * If {@code out} is nullptr, the value of {@code size} is set to the true size of the string
   * attribute, and a success status is returned.
   *
   * If the {@code size} parameter is greater than or equal to the actual string attribute's size,
   * the value of {@code size} is set to the true size of the string attribute, the provided memory
   * is filled with the attribute's contents, and a success status is returned.
   *
   * If the {@code size} parameter is less than the actual string attribute's size and {@code out}
   * is not nullptr, the value of {@code size} is set to the true size of the string attribute
   * and a failure status is returned.)
   *
   * @param info [in] ::OrtKernelInfo instance
   * @param name [in] Null terminated string of the name of the attribute
   * @param out [out] Pointer to memory where the attribute will be stored
   * @param size [in,out] See above comments for details
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus KernelInfoGetAttribute_string( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name, @Cast("char*") BytePointer out,
                    @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttribute_string( @Const OrtKernelInfo info, String name, @Cast("char*") ByteBuffer out,
                    @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttribute_string( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name, @Cast("char*") byte[] out,
                    @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttribute_string( @Const OrtKernelInfo info, String name, @Cast("char*") BytePointer out,
                    @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttribute_string( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name, @Cast("char*") ByteBuffer out,
                    @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttribute_string( @Const OrtKernelInfo info, String name, @Cast("char*") byte[] out,
                    @Cast("size_t*") SizeTPointer size);

  /** \}
   *  \name OrtKernelContext
   *  Custom operator APIs.
   *  \{
  <p>
  /** \brief Used for custom operators, get the input count of a kernel
   *
   * @see ::OrtCustomOp
   */
  public native OrtStatus KernelContext_GetInputCount( @Const OrtKernelContext context, @Cast("size_t*") SizeTPointer out);

  /** \brief Used for custom operators, get the output count of a kernel
   *
   * @see ::OrtCustomOp
   */
  public native OrtStatus KernelContext_GetOutputCount( @Const OrtKernelContext context, @Cast("size_t*") SizeTPointer out);

  /** \brief Used for custom operators, get an input of a kernel
   *
   * The function attempts fetches the input of the kernel. If the input is optional
   * and not present, the function returns success and out is set to nullptr.
   *
   * @param context [in] ::OrtKernelContext instance
   * @param index [in] See KernelContext_GetInputCount for boundaries check.
   * @param out [out] OrtValue if the input is present otherwise is set nullptr
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus KernelContext_GetInput( @Const OrtKernelContext context, @Cast("size_t") long index,
                    @Cast("const OrtValue**") PointerPointer out);
  public native OrtStatus KernelContext_GetInput( @Const OrtKernelContext context, @Cast("size_t") long index,
                    @Const @ByPtrPtr OrtValue out);

  /** \brief Used for custom operators, get an output of a kernel
   *
   * The function attempts fetches the output of the kernel. If the output is optional
   * and not present, the function returns success and out is set to nullptr.
   *
   * @param context [in] ::OrtKernelContext instance
   * @param index [in] See KernelContext_GetOutputCount for boundaries check.
   * @param dim_values [in] output dimensions
   * @param dim_count [in] number of dimensions
   * @param out [out] a ptr to OrtValue to output otherwise set to nullptr
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus KernelContext_GetOutput( OrtKernelContext context, @Cast("size_t") long index,
                    @Cast("const int64_t*") LongPointer dim_values, @Cast("size_t") long dim_count, @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus KernelContext_GetOutput( OrtKernelContext context, @Cast("size_t") long index,
                    @Cast("const int64_t*") LongPointer dim_values, @Cast("size_t") long dim_count, @ByPtrPtr OrtValue out);
  public native OrtStatus KernelContext_GetOutput( OrtKernelContext context, @Cast("size_t") long index,
                    @Cast("const int64_t*") LongBuffer dim_values, @Cast("size_t") long dim_count, @ByPtrPtr OrtValue out);
  public native OrtStatus KernelContext_GetOutput( OrtKernelContext context, @Cast("size_t") long index,
                    @Cast("const int64_t*") long[] dim_values, @Cast("size_t") long dim_count, @ByPtrPtr OrtValue out);

  /** \}
   *  \name OrtEnv
   *  \{ */
  public native void ReleaseEnv(OrtEnv input);
  /** \}
   *  \name OrtStatus
   *  \{ */
  public native void ReleaseStatus(OrtStatus input);
  /** \}
   *  \name OrtMemoryInfo
   *  \{ */
  public native void ReleaseMemoryInfo(OrtMemoryInfo input);
  /** \}
   *  \name OrtSession
   *  \{ */
  public native void ReleaseSession(OrtSession input);  // Don't call ReleaseSession from Dllmain (because session owns a thread pool)
  /** \}
   *  \name OrtValue
   *  \{ */
  public native void ReleaseValue(OrtValue input);
  /** \}
   *  \name OrtRunOptions
   *  \{ */
  public native void ReleaseRunOptions(OrtRunOptions input);
  /** \}
   *  \name OrtTypeInfo
   *  \{ */
  public native void ReleaseTypeInfo(OrtTypeInfo input);
  /** \}
   *  \name OrtTensorTypeAndShapeInfo
   *  \{ */
  public native void ReleaseTensorTypeAndShapeInfo(OrtTensorTypeAndShapeInfo input);
  /** \}
   *  \name OrtSessionOptions
   *  \{ */
  public native void ReleaseSessionOptions(OrtSessionOptions input);
  /** \}
   *  \name OrtCustomOpDomain
   *  \{ */
  public native void ReleaseCustomOpDomain(OrtCustomOpDomain input);

  /** \}
   *  \name OrtTypeInfo
   *  \{
  <p>
  /** \brief Get denotation from type information
   *
   * Augments ::OrtTypeInfo to return denotations on the type.
   *
   * This is used by WinML to determine if an input/output is intended to be an Image or a Tensor.
   *
   * @param type_info [in]
   * @param denotation [out] Pointer to the null terminated denotation string is written to this pointer. This pointer is valid until the object is destroyed or the name is changed, do not free.
   * @param len [out] Length in bytes of the string returned in {@code denotation}
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetDenotationFromTypeInfo( @Const OrtTypeInfo type_info, @Cast("const char**const") PointerPointer denotation,
                    @Cast("size_t*") SizeTPointer len);
  public native OrtStatus GetDenotationFromTypeInfo( @Const OrtTypeInfo type_info, @Cast("const char**const") @ByPtrPtr BytePointer denotation,
                    @Cast("size_t*") SizeTPointer len);
  public native OrtStatus GetDenotationFromTypeInfo( @Const OrtTypeInfo type_info, @Cast("const char**const") @ByPtrPtr ByteBuffer denotation,
                    @Cast("size_t*") SizeTPointer len);
  public native OrtStatus GetDenotationFromTypeInfo( @Const OrtTypeInfo type_info, @Cast("const char**const") @ByPtrPtr byte[] denotation,
                    @Cast("size_t*") SizeTPointer len);

  /** \brief Get detailed map information from an ::OrtTypeInfo
   *
   * This augments ::OrtTypeInfo to return an ::OrtMapTypeInfo when the type is a map.
   * The OrtMapTypeInfo has additional information about the map's key type and value type.
   *
   * This is used by WinML to support model reflection APIs.
   *
   * @param type_info [out]
   * @param out [out] A pointer to the ::OrtMapTypeInfo. Do not free this value. If type_info
   *             does not contain a map, this value will be set to nullptr.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CastTypeInfoToMapTypeInfo( @Const OrtTypeInfo type_info,
                    @Cast("const OrtMapTypeInfo**") PointerPointer out);
  public native OrtStatus CastTypeInfoToMapTypeInfo( @Const OrtTypeInfo type_info,
                    @Const @ByPtrPtr OrtMapTypeInfo out);

  /** \brief Cast ::OrtTypeInfo to an ::OrtSequenceTypeInfo
   *
   * This api augments ::OrtTypeInfo to return an ::OrtSequenceTypeInfo when the type is a sequence.
   * The ::OrtSequenceTypeInfo has additional information about the sequence's element type.
   *
   * This is used by WinML to support model reflection APIs.
   *
   * @param type_info [in]
   * @param out [out] A pointer to the OrtSequenceTypeInfo. Do not free this value. If type_info
   *             doesn not contain a sequence, this value will be set to nullptr.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CastTypeInfoToSequenceTypeInfo( @Const OrtTypeInfo type_info,
                    @Cast("const OrtSequenceTypeInfo**") PointerPointer out);
  public native OrtStatus CastTypeInfoToSequenceTypeInfo( @Const OrtTypeInfo type_info,
                    @Const @ByPtrPtr OrtSequenceTypeInfo out);

  /** \}
   *  \name OrtMapTypeInfo
   *  \{
  <p>
  /** \brief Get key type from an ::OrtMapTypeInfo
   *
   * Key types are restricted to being scalar types.
   *
   * This is used by WinML to support model reflection APIs.
   *
   * @param map_type_info [in]
   * @param out [out]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetMapKeyType( @Const OrtMapTypeInfo map_type_info, @Cast("ONNXTensorElementDataType*") IntPointer out);
  public native OrtStatus GetMapKeyType( @Const OrtMapTypeInfo map_type_info, @Cast("ONNXTensorElementDataType*") IntBuffer out);
  public native OrtStatus GetMapKeyType( @Const OrtMapTypeInfo map_type_info, @Cast("ONNXTensorElementDataType*") int[] out);

  /** \brief Get the value type from an ::OrtMapTypeInfo
   *
   * @param map_type_info [in]
   * @param type_info [out] A copy of the OrtTypeInfo for the map value type.
   *                       The user must free this value with ReleaseTypeInfo.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetMapValueType( @Const OrtMapTypeInfo map_type_info, @Cast("OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus GetMapValueType( @Const OrtMapTypeInfo map_type_info, @ByPtrPtr OrtTypeInfo type_info);

  /** \}
   *  \name OrtSequenceTypeInfo
   *  \{
  <p>
  /** \brief Get element type from an ::OrtSequenceTypeInfo
   *
   * This is used by WinML to support model reflection APIs.
   *
   * @param sequence_type_info [in]
   * @param type_info [out] A copy of the OrtTypeInfo for the sequence element type.
   *                       The user must free this value with ReleaseTypeInfo.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetSequenceElementType( @Const OrtSequenceTypeInfo sequence_type_info,
                    @Cast("OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus GetSequenceElementType( @Const OrtSequenceTypeInfo sequence_type_info,
                    @ByPtrPtr OrtTypeInfo type_info);

  /** \}
   *  \name OrtMapTypeInfo
   *  \{ */
  public native void ReleaseMapTypeInfo(OrtMapTypeInfo input);
  /** \}
   *  \name OrtSequenceTypeInfo
   *  \{ */
  public native void ReleaseSequenceTypeInfo(OrtSequenceTypeInfo input);

  /** \}
   *  \name OrtSession
   *  \{
  <p>
  /** \brief End profiling and return filename of the profile data
   *
   * Profiling is turned on through OrtApi::EnableProfiling
   *
   * @param session [in]
   * @param allocator [in]
   * @param out [out] Null terminated string of the filename, allocated using {@code allocator}. Must be freed using {@code allocator}
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionEndProfiling( OrtSession session, OrtAllocator allocator, @Cast("char**") PointerPointer out);
  public native OrtStatus SessionEndProfiling( OrtSession session, OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer out);
  public native OrtStatus SessionEndProfiling( OrtSession session, OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer out);
  public native OrtStatus SessionEndProfiling( OrtSession session, OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] out);

  /** \brief Get ::OrtModelMetadata from an ::OrtSession
   *
   * @param session [in]
   * @param out [out] Newly created ::OrtModelMetadata. Must be freed using OrtApi::ReleaseModelMetadata
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionGetModelMetadata( @Const OrtSession session, @Cast("OrtModelMetadata**") PointerPointer out);
  public native OrtStatus SessionGetModelMetadata( @Const OrtSession session, @ByPtrPtr OrtModelMetadata out);

  /** \}
   *  \name OrtModelMetadata
   *  \{
  <p>
  /** \brief Get {@code producer name} from an ::OrtModelMetadata
   *
   * @param model_metadata [in]
   * @param allocator [in]
   * @param value [out] Set to a null terminated string allocated using {@code allocator}. Must be freed using {@code allocator}
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus ModelMetadataGetProducerName( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") PointerPointer value);
  public native OrtStatus ModelMetadataGetProducerName( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus ModelMetadataGetProducerName( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus ModelMetadataGetProducerName( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] value);

  /** \brief Get {@code graph name} from an ::OrtModelMetadata
   *
   * @param model_metadata [in]
   * @param allocator [in]
   * @param value [out] Set to a null terminated string allocated using {@code allocator}. Must be freed using {@code allocator}
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus ModelMetadataGetGraphName( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") PointerPointer value);
  public native OrtStatus ModelMetadataGetGraphName( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus ModelMetadataGetGraphName( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus ModelMetadataGetGraphName( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] value);

  /** \brief Get {@code domain} from an ::OrtModelMetadata
   *
   * @param model_metadata [in]
   * @param allocator [in]
   * @param value [out] Set to a null terminated string allocated using {@code allocator}. Must be freed using {@code allocator}
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus ModelMetadataGetDomain( @Const OrtModelMetadata model_metadata, OrtAllocator allocator,
                    @Cast("char**") PointerPointer value);
  public native OrtStatus ModelMetadataGetDomain( @Const OrtModelMetadata model_metadata, OrtAllocator allocator,
                    @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus ModelMetadataGetDomain( @Const OrtModelMetadata model_metadata, OrtAllocator allocator,
                    @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus ModelMetadataGetDomain( @Const OrtModelMetadata model_metadata, OrtAllocator allocator,
                    @Cast("char**") @ByPtrPtr byte[] value);

  /** \brief Get {@code description} from an ::OrtModelMetadata
   *
   * @param model_metadata [in]
   * @param allocator [in]
   * @param value [out] Set to a null terminated string allocated using {@code allocator}. Must be freed using {@code allocator}
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus ModelMetadataGetDescription( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") PointerPointer value);
  public native OrtStatus ModelMetadataGetDescription( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus ModelMetadataGetDescription( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus ModelMetadataGetDescription( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] value);

  /** \brief Return data for a key in the custom metadata map in an ::OrtModelMetadata
   *
   * @param model_metadata [in]
   * @param allocator [in]
   * @param key [in] Null terminated string
   * @param value [out] Set to a null terminated string allocated using {@code allocator}. Must be freed using {@code allocator}
   * {@code value} will be set to nullptr if the given key is not found in the custom metadata map.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus ModelMetadataLookupCustomMetadataMap( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("const char*") BytePointer key, @Cast("char**") PointerPointer value);
  public native OrtStatus ModelMetadataLookupCustomMetadataMap( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("const char*") BytePointer key, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus ModelMetadataLookupCustomMetadataMap( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, String key, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus ModelMetadataLookupCustomMetadataMap( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("const char*") BytePointer key, @Cast("char**") @ByPtrPtr byte[] value);
  public native OrtStatus ModelMetadataLookupCustomMetadataMap( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, String key, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus ModelMetadataLookupCustomMetadataMap( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("const char*") BytePointer key, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus ModelMetadataLookupCustomMetadataMap( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, String key, @Cast("char**") @ByPtrPtr byte[] value);

  /** \brief Get version number from an ::OrtModelMetadata
   *
   * @param model_metadata [in]
   * @param value [out] Set to the version number
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus ModelMetadataGetVersion( @Const OrtModelMetadata model_metadata, @Cast("int64_t*") LongPointer value);
  public native OrtStatus ModelMetadataGetVersion( @Const OrtModelMetadata model_metadata, @Cast("int64_t*") LongBuffer value);
  public native OrtStatus ModelMetadataGetVersion( @Const OrtModelMetadata model_metadata, @Cast("int64_t*") long[] value);

  public native void ReleaseModelMetadata(OrtModelMetadata input);

  /** \}
   *  \name OrtEnv
   *  \{
  <p>
  /** \brief Create an OrtEnv
   *
   * Create an environment with global threadpools that will be shared across sessions.
   * Use this in conjunction with OrtApi::DisablePerSessionThreads or else the session will use
   * its own thread pools.
   *
   * @param log_severity_level [in] The log severity level.
   * @param logid [in] The log identifier.
   * @param tp_options [in]
   * @param out [out] Returned newly created OrtEnv. Must be freed with OrtApi::ReleaseEnv
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateEnvWithGlobalThreadPools( @Cast("OrtLoggingLevel") int log_severity_level, @Cast("const char*") BytePointer logid,
                    @Const OrtThreadingOptions tp_options, @Cast("OrtEnv**") PointerPointer out);
  public native OrtStatus CreateEnvWithGlobalThreadPools( @Cast("OrtLoggingLevel") int log_severity_level, @Cast("const char*") BytePointer logid,
                    @Const OrtThreadingOptions tp_options, @ByPtrPtr OrtEnv out);
  public native OrtStatus CreateEnvWithGlobalThreadPools( @Cast("OrtLoggingLevel") int log_severity_level, String logid,
                    @Const OrtThreadingOptions tp_options, @ByPtrPtr OrtEnv out);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Use global thread pool on a session
   *
   * Disable using per session thread pool and use the shared global threadpool.
   * This should be used in conjunction with OrtApi::CreateEnvWithGlobalThreadPools.
   *
   * @param options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus DisablePerSessionThreads( OrtSessionOptions options);

  /** \}
   *  \name OrtThreadingOptions
   *  \{
  <p>
  /** \brief Create an ::OrtThreadingOptions
   *
   * @param out [out] Newly created ::OrtThreadingOptions. Must be freed with OrtApi::ReleaseThreadingOptions
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateThreadingOptions( @Cast("OrtThreadingOptions**") PointerPointer out);
  public native OrtStatus CreateThreadingOptions( @ByPtrPtr OrtThreadingOptions out);

  public native void ReleaseThreadingOptions(OrtThreadingOptions input);

  /** \}
   *  \name OrtModelMetadata
   *  \{
  <p>
  /**
   *
   * @param model_metadata [in]
   * @param allocator [in]
   * @param keys [out] Array of null terminated strings (array count = num_keys) allocated using {@code allocator}.
   *  The strings and the pointer array must be freed using {@code allocator}
   *  {@code keys} will be set to nullptr if the custom metadata map is empty.
   * @param num_keys [out] Set to the number of elements in the {@code keys} array
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus ModelMetadataGetCustomMetadataMapKeys( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char***") @ByPtrPtr PointerPointer keys, @Cast("int64_t*") LongPointer num_keys);
  public native OrtStatus ModelMetadataGetCustomMetadataMapKeys( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char***") @ByPtrPtr PointerPointer keys, @Cast("int64_t*") LongBuffer num_keys);
  public native OrtStatus ModelMetadataGetCustomMetadataMapKeys( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char***") @ByPtrPtr PointerPointer keys, @Cast("int64_t*") long[] num_keys);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /**
   *
   * Override symbolic dimensions (by specific name strings) with actual values
   * if known at session initialization time to enable optimizations that can
   * take advantage of fixed values (such as memory planning, etc)
   *
   */
  public native OrtStatus AddFreeDimensionOverrideByName(
                    OrtSessionOptions options, @Cast("const char*") BytePointer dim_name,
                    @Cast("int64_t") long dim_value);
  public native OrtStatus AddFreeDimensionOverrideByName(
                    OrtSessionOptions options, String dim_name,
                    @Cast("int64_t") long dim_value);

  /** \}
   *  \name Misc
   *  \{
  <p>
  /** \brief Get the names of all available providers
   *
   * \note The providers in the list are not guaranteed to be usable. They may fail to load due to missing system dependencies.
   *    For example, if the CUDA/cuDNN libraries are not installed, the CUDA provider will report an error when it is added to the session options.
   *
   * @param out_ptr [out] Set to a pointer to an array of null terminated strings of the available providers. The entries and the
   *    array itself must be freed using OrtApi::ReleaseAvailableProviders
   * @param provider_length [out] Set to the number of entries in the {@code out_ptr} array
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetAvailableProviders( @Cast("char***") @ByPtrPtr PointerPointer out_ptr, IntPointer provider_length);
  public native OrtStatus GetAvailableProviders( @Cast("char***") @ByPtrPtr PointerPointer out_ptr, IntBuffer provider_length);
  public native OrtStatus GetAvailableProviders( @Cast("char***") @ByPtrPtr PointerPointer out_ptr, int[] provider_length);

  /** \brief Release data from OrtApi::GetAvailableProviders. This API will never fail
   * so you can rely on it in a noexcept code.
   *
   * @param ptr [in] The {@code out_ptr} result from OrtApi::GetAvailableProviders.
   * @param providers_length [in] The {@code provider_length} result from OrtApi::GetAvailableProviders
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus ReleaseAvailableProviders( @Cast("char**") PointerPointer ptr,
                    int providers_length);
  public native OrtStatus ReleaseAvailableProviders( @Cast("char**") @ByPtrPtr BytePointer ptr,
                    int providers_length);
  public native OrtStatus ReleaseAvailableProviders( @Cast("char**") @ByPtrPtr ByteBuffer ptr,
                    int providers_length);
  public native OrtStatus ReleaseAvailableProviders( @Cast("char**") @ByPtrPtr byte[] ptr,
                    int providers_length);

  /** \}
   *  \name OrtValue
   *  \{
  <p>
  /** \brief Get the length of a single string in a string tensor
   *
   * @param value [in] A string tensor
   * @param index [in] Index of the string in the tensor
   * @param out [out] Set to number of bytes of the string element
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetStringTensorElementLength( @Const OrtValue value, @Cast("size_t") long index, @Cast("size_t*") SizeTPointer out);

  /** \brief Get a single string from a string tensor
   *
   * @param value [in] A string tensor
   * @param s_len [in] Number of bytes in the {@code s} buffer. Must match the value returned by OrtApi::GetStringTensorElementLength.
   * @param index [in] Index of the string in the tensor
   * @param s [out] The string element contents in UTF-8 encoding. The string is NOT null-terminated.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetStringTensorElement( @Const OrtValue value, @Cast("size_t") long s_len, @Cast("size_t") long index, Pointer s);

  /** \brief Set a single string in a string tensor
   *
   * @param value [in] A string tensor
   * @param s [in] A null terminated UTF-8 encoded string
   * @param index [in] Index of the string in the tensor to set
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus FillStringTensorElement( OrtValue value, @Cast("const char*") BytePointer s, @Cast("size_t") long index);
  public native OrtStatus FillStringTensorElement( OrtValue value, String s, @Cast("size_t") long index);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Set a session configuration entry as a pair of strings
   *
   * If a configuration with same key exists, this will overwrite the configuration with the given config_value.
   *
   * The config_key and the format of config_value are defined in onnxruntime_session_options_config_keys.h
   *
   * @param options [in]
   * @param config_key [in] A null terminated string representation of the config key
   * @param config_value [in] A null terminated string representation of the config value
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus AddSessionConfigEntry( OrtSessionOptions options,
                    @Cast("const char*") BytePointer config_key, @Cast("const char*") BytePointer config_value);
  public native OrtStatus AddSessionConfigEntry( OrtSessionOptions options,
                    String config_key, String config_value);

  /** \}
   *  \name OrtAllocator
   *  \{
  <p>
  /** \brief Create an allocator for an ::OrtSession following an ::OrtMemoryInfo
   *
   * The allocator wraps the internal allocator from the OrtSession and becomes invalid when the session does.
   *
   * @param session [in]
   * @param mem_info [in] valid ::OrtMemoryInfo instance
   * @param out [out] Newly created ::OrtAllocator. Must be freed with OrtApi::ReleaseAllocator
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateAllocator( @Const OrtSession session, @Const OrtMemoryInfo mem_info,
                    @Cast("OrtAllocator**") PointerPointer out);
  public native OrtStatus CreateAllocator( @Const OrtSession session, @Const OrtMemoryInfo mem_info,
                    @ByPtrPtr OrtAllocator out);

  /** \brief Release an ::OrtAllocator obtained from OrtApi::CreateAllocator
   */
  public native void ReleaseAllocator(OrtAllocator input);

  /** \}
   *  \name OrtSession
   *  \{
  <p>
  /** \brief Run a model using Io Bindings for the inputs & outputs
   *
   * @see OrtApi::Run
   *
   * @param session [in]
   * @param run_options [in]
   * @param binding_ptr [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus RunWithBinding( OrtSession session, @Const OrtRunOptions run_options, @Const OrtIoBinding binding_ptr);

  /** \brief Create an ::OrtIoBinding instance
   *
   * An IoBinding object allows one to bind pre-allocated ::OrtValue%s to input names.
   * Thus if you want to use a raw on device buffer as input or output you can avoid
   * extra copy during runtime.
   *
   * @param session [in]
   * @param out [out] Newly created ::OrtIoBinding. Must be freed with OrtApi::ReleaseIoBinding
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateIoBinding( OrtSession session, @Cast("OrtIoBinding**") PointerPointer out);
  public native OrtStatus CreateIoBinding( OrtSession session, @ByPtrPtr OrtIoBinding out);

  /** \}
   *  \name OrtIoBinding
   *  \{
  <p>
  /** \brief Release an ::OrtIoBinding obtained from OrtApi::CreateIoBinding
   */
  public native void ReleaseIoBinding(OrtIoBinding input);

  /** \brief Bind an ::OrtValue to an ::OrtIoBinding input
   *
   * When using OrtApi::RunWithBinding this value is used for the named input
   *
   * @param binding_ptr [in]
   * @param name [in] Name for the model input
   * @param val_ptr [in] ::OrtValue of Tensor type.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus BindInput( OrtIoBinding binding_ptr, @Cast("const char*") BytePointer name, @Const OrtValue val_ptr);
  public native OrtStatus BindInput( OrtIoBinding binding_ptr, String name, @Const OrtValue val_ptr);

  /** \brief Bind an ::OrtValue to an ::OrtIoBinding output
   *
   * When using OrtApi::RunWithBinding this value is used for the named output
   *
   * @param binding_ptr [in]
   * @param name [in] Null terminated string of the model output name
   * @param val_ptr [in] ::OrtValue of Tensor type.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus BindOutput( OrtIoBinding binding_ptr, @Cast("const char*") BytePointer name, @Const OrtValue val_ptr);
  public native OrtStatus BindOutput( OrtIoBinding binding_ptr, String name, @Const OrtValue val_ptr);

  /** \brief Bind an ::OrtIoBinding output to a device
   *
   * Binds the ::OrtValue to a device which is specified by ::OrtMemoryInfo.
   * You can either create an instance of ::OrtMemoryInfo with a device id or obtain one from the allocator that you have created/are using
   * This is useful when one or more outputs have dynamic shapes and, it is hard to pre-allocate and bind a chunk of
   * memory within ::OrtValue ahead of time.
   *
   * @see OrtApi::RunWithBinding
   *
   * @param binding_ptr [in]
   * @param name [in] Null terminated string of the device name
   * @param mem_info_ptr [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus BindOutputToDevice( OrtIoBinding binding_ptr, @Cast("const char*") BytePointer name, @Const OrtMemoryInfo mem_info_ptr);
  public native OrtStatus BindOutputToDevice( OrtIoBinding binding_ptr, String name, @Const OrtMemoryInfo mem_info_ptr);

  /** \brief Get the names of an ::OrtIoBinding's outputs
   *
   * Returns the names of the outputs in the order they were bound. This is useful after running the model
   * with bound outputs because the returned names are in order in which output ::OrtValue are returned. This is useful if
   * the order of outputs and their names is not known.
   *
   * @param binding_ptr [in]
   * @param allocator [in] Allocator used to allocate continuous buffers for output strings and lengths.
   * @param buffer [out] Returns an array of non-null terminated UTF-8 strings. The number of strings stored is returned in the count parameter.
   *   This buffer is allocated using {@code allocator} and must be freed using it.
   * @param lengths [out] Returns an array of {@code count} lengths of the strings returned in {@code buffer}
   *   This buffer is allocated using {@code allocator} and must be freed using it.
   * @param count [out] Number of strings returned. If {@code binding_ptr} has no bound outputs, zero is returned,
   *              no memory allocation is performed and buffer and lengths are set to nullptr.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetBoundOutputNames( @Const OrtIoBinding binding_ptr, OrtAllocator allocator,
                    @Cast("char**") PointerPointer buffer, @Cast("size_t**") PointerPointer lengths, @Cast("size_t*") SizeTPointer count);
  public native OrtStatus GetBoundOutputNames( @Const OrtIoBinding binding_ptr, OrtAllocator allocator,
                    @Cast("char**") @ByPtrPtr BytePointer buffer, @Cast("size_t**") @ByPtrPtr SizeTPointer lengths, @Cast("size_t*") SizeTPointer count);
  public native OrtStatus GetBoundOutputNames( @Const OrtIoBinding binding_ptr, OrtAllocator allocator,
                    @Cast("char**") @ByPtrPtr ByteBuffer buffer, @Cast("size_t**") @ByPtrPtr SizeTPointer lengths, @Cast("size_t*") SizeTPointer count);
  public native OrtStatus GetBoundOutputNames( @Const OrtIoBinding binding_ptr, OrtAllocator allocator,
                    @Cast("char**") @ByPtrPtr byte[] buffer, @Cast("size_t**") @ByPtrPtr SizeTPointer lengths, @Cast("size_t*") SizeTPointer count);

  /** \brief Get the output ::OrtValue objects from an ::OrtIoBinding
   *
   * Returns an array of pointers to individually allocated ::OrtValue%s that contain results of a model execution with OrtApi::RunWithBinding
   * The array contains the same number of ::OrtValue%s and they are in the same order as they were bound with OrtApi::BindOutput
   * or OrtApi::BindOutputToDevice.
   *
   * The returned ::OrtValue%s must be released using OrtApi::ReleaseValue after they are no longer needed.
   * The array is allocated using the specified instance of the allocator and must be freed using the same allocator after
   * all the ::OrtValue%s contained therein are individually released.
   *
   * @param binding_ptr [in]
   * @param allocator [in] Allocator used to allocate output array
   * @param output [out] Set to the allocated array of allocated ::OrtValue outputs. Set to nullptr if there are 0 outputs.
   * @param output_count [out] Set to number of ::OrtValue%s returned
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetBoundOutputValues( @Const OrtIoBinding binding_ptr, OrtAllocator allocator,
                    @Cast("OrtValue***") @ByPtrPtr PointerPointer output, @Cast("size_t*") SizeTPointer output_count);

  /** \brief Clears any previously set Inputs for an ::OrtIoBinding
   */
  public static class ClearBoundInputs_OrtIoBinding extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    ClearBoundInputs_OrtIoBinding(Pointer p) { super(p); }
      protected ClearBoundInputs_OrtIoBinding() { allocate(); }
      private native void allocate();
      public native void call(OrtIoBinding binding_ptr);
  }
  public native ClearBoundInputs_OrtIoBinding ClearBoundInputs(); public native OrtApi ClearBoundInputs(ClearBoundInputs_OrtIoBinding setter);

  /** \brief Clears any previously set Outputs for an ::OrtIoBinding
   */
  public static class ClearBoundOutputs_OrtIoBinding extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    ClearBoundOutputs_OrtIoBinding(Pointer p) { super(p); }
      protected ClearBoundOutputs_OrtIoBinding() { allocate(); }
      private native void allocate();
      public native void call(OrtIoBinding binding_ptr);
  }
  public native ClearBoundOutputs_OrtIoBinding ClearBoundOutputs(); public native OrtApi ClearBoundOutputs(ClearBoundOutputs_OrtIoBinding setter);

  /** \}
   *  \name OrtValue
   *  \{
  <p>
  /** \brief Direct memory access to a specified tensor element
   *
   * For example, given a tensor with shape of [3,224,224], a pointer to the element at location [2,150,128] can be retrieved
   *
   * This function only works for numeric type tensors (No strings, etc).
   * This is a no-copy method whose returned pointer is valid until the passed in ::OrtValue is free'd.
   *
   * @param value [in]
   * @param location_values [in] Pointer to an array of index values that specify an element's location relative to its shape
   * @param location_values_count [in] Number of elements in location_values. Must match the number of elements in the tensor's shape.
   * @param out [out] Set to a pointer to the element specified
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus TensorAt( OrtValue value, @Cast("const int64_t*") LongPointer location_values, @Cast("size_t") long location_values_count, @Cast("void**") PointerPointer out);
  public native OrtStatus TensorAt( OrtValue value, @Cast("const int64_t*") LongPointer location_values, @Cast("size_t") long location_values_count, @Cast("void**") @ByPtrPtr Pointer out);
  public native OrtStatus TensorAt( OrtValue value, @Cast("const int64_t*") LongBuffer location_values, @Cast("size_t") long location_values_count, @Cast("void**") @ByPtrPtr Pointer out);
  public native OrtStatus TensorAt( OrtValue value, @Cast("const int64_t*") long[] location_values, @Cast("size_t") long location_values_count, @Cast("void**") @ByPtrPtr Pointer out);

  /** \}
   *  \name OrtEnv
   *  \{
  <p>
  /** \brief Create an allocator and register it with the ::OrtEnv
   *
   * Enables sharing the allocator between multiple sessions that use the same env instance.
   * Lifetime of the created allocator will be valid for the duration of the environment.
   * Returns an error if an allocator with the same ::OrtMemoryInfo is already registered.
   *
   * See https://onnxruntime.ai/docs/get-started/with-c.html for details.
   *
   * @param env [in] ::OrtEnv instance
   * @param mem_info [in]
   * @param arena_cfg [in] Pass nullptr for defaults
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateAndRegisterAllocator( OrtEnv env, @Const OrtMemoryInfo mem_info,
                    @Const OrtArenaCfg arena_cfg);

  /** \brief Set language projection
   *
   * Set the language projection for collecting telemetry data when Env is created.
   *
   * The default is ORT_PROJECTION_C, which means it will classify the language not in the list to C also.
   *
   * @param ort_env [in]
   * @param projection [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetLanguageProjection( @Const OrtEnv ort_env, @Cast("OrtLanguageProjection") int projection);

  /** \}
   *  \name OrtSession
   *  \{
  <p>
  /** \brief Return the time that profiling was started
   *
   * \note The timer precision varies per platform. On Windows and MacOS, the precision will be ~100ns
   *
   * @param session [in]
   * @param out [out] nanoseconds of profiling's start time
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionGetProfilingStartTimeNs( @Const OrtSession session, @Cast("uint64_t*") LongPointer out);
  public native OrtStatus SessionGetProfilingStartTimeNs( @Const OrtSession session, @Cast("uint64_t*") LongBuffer out);
  public native OrtStatus SessionGetProfilingStartTimeNs( @Const OrtSession session, @Cast("uint64_t*") long[] out);

  /** \}
   *  \name OrtThreadingOptions
   *  \{
  <p>
  /** \brief Set global intra-op thread count
   *
   * This configures the global thread pool options to be used in the call to OrtApi::CreateEnvWithGlobalThreadPools
   *
   * @param tp_options [in]
   * @param intra_op_num_threads [in] Number of threads, special values:<br>
   *    0 = Use default thread count<br>
   *    1 = The invoking thread will be used; no threads will be created in the thread pool.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetGlobalIntraOpNumThreads( OrtThreadingOptions tp_options, int intra_op_num_threads);

  /** \brief Set global inter-op thread count
   *
   * This configures the global thread pool options to be used in the call to OrtApi::CreateEnvWithGlobalThreadPools
   *
   * @param tp_options [in]
   * @param inter_op_num_threads [in] Number of threads, special values:<br>
   *    0 = Use default thread count<br>
   *    1 = The invoking thread will be used; no threads will be created in the thread pool.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetGlobalInterOpNumThreads( OrtThreadingOptions tp_options, int inter_op_num_threads);

  /** \brief Set global spin control options
   *
   * This will configure the global thread pool options to be used in the call to OrtApi::CreateEnvWithGlobalThreadPools.
   * Allow spinning of thread pools when their queues are empty. This will set the value for both
   * inter_op and intra_op threadpools.
   *
   * @param tp_options [in]
   * @param allow_spinning [in] Valid values are 0 or 1.<br>
   *   0 = It won't spin (recommended if CPU usage is high)<br>
   *   1 = Threadpool will spin to wait for queue to become non-empty
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetGlobalSpinControl( OrtThreadingOptions tp_options, int allow_spinning);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Add a pre-allocated initializer to a session
   *
   * If a model contains an initializer with a name that is same as the name passed to this call,
   * ORT will use this initializer instance instead of deserializing one from the model file. This
   * is useful when you want to share the same initializer across sessions.
   *
   * @param options [in]
   * @param name [in] Null terminated string of the initializer name
   * @param val [in] ::OrtValue containing the initializer. Its lifetime and the underlying initializer buffer must be
   *   managed by the user (created using the OrtApi::CreateTensorWithDataAsOrtValue) and it must outlive the session object
   *   to which it is added.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus AddInitializer( OrtSessionOptions options, @Cast("const char*") BytePointer name,
                    @Const OrtValue val);
  public native OrtStatus AddInitializer( OrtSessionOptions options, String name,
                    @Const OrtValue val);

  /** \}
   *  \name OrtEnv
   *  \{
  <p>
  /**
   * Create a custom environment with global threadpools and logger that will be shared across sessions.
   * Use this in conjunction with OrtApi::DisablePerSessionThreads or else the session will use
   * its own thread pools.
   *
   * @param logging_function [in] A pointer to a logging function.
   * @param logger_param [in] A pointer to arbitrary data passed as the ::OrtLoggingFunction {@code param} parameter to
   *                         {@code logging_function}.
   * @param log_severity_level [in] The log severity level.
   * @param logid [in] The log identifier.
   * @param tp_options [in]
   * @param out [out] Newly created OrtEnv. Must be freed with OrtApi::ReleaseEnv
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateEnvWithCustomLoggerAndGlobalThreadPools( OrtLoggingFunction logging_function, Pointer logger_param, @Cast("OrtLoggingLevel") int log_severity_level,
                    @Cast("const char*") BytePointer logid, @Const OrtThreadingOptions tp_options, @Cast("OrtEnv**") PointerPointer out);
  public native OrtStatus CreateEnvWithCustomLoggerAndGlobalThreadPools( OrtLoggingFunction logging_function, Pointer logger_param, @Cast("OrtLoggingLevel") int log_severity_level,
                    @Cast("const char*") BytePointer logid, @Const OrtThreadingOptions tp_options, @ByPtrPtr OrtEnv out);
  public native OrtStatus CreateEnvWithCustomLoggerAndGlobalThreadPools( OrtLoggingFunction logging_function, Pointer logger_param, @Cast("OrtLoggingLevel") int log_severity_level,
                    String logid, @Const OrtThreadingOptions tp_options, @ByPtrPtr OrtEnv out);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Append CUDA provider to session options
   *
   * If CUDA is not available (due to a non CUDA enabled build, or if CUDA is not installed on the system), this function will return failure.
   *
   * @param options [in]
   * @param cuda_options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionOptionsAppendExecutionProvider_CUDA(
                    OrtSessionOptions options, @Const OrtCUDAProviderOptions cuda_options);

  /** \brief Append ROCM execution provider to the session options
   *
   * If ROCM is not available (due to a non ROCM enabled build, or if ROCM is not installed on the system), this function will return failure.
   *
   * @param options [in]
   * @param rocm_options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionOptionsAppendExecutionProvider_ROCM(
                    OrtSessionOptions options, @Const OrtROCMProviderOptions rocm_options);

  /** \brief Append OpenVINO execution provider to the session options
   *
   * If OpenVINO is not available (due to a non OpenVINO enabled build, or if OpenVINO is not installed on the system), this function will fail.
   *
   * @param options [in]
   * @param provider_options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionOptionsAppendExecutionProvider_OpenVINO(
                    OrtSessionOptions options, @Const OrtOpenVINOProviderOptions provider_options);

  /** \}
   *  \name OrtThreadingOptions
   *  \{
  <p>
  /** \brief Set threading flush-to-zero and denormal-as-zero
   *
   * Sets global thread pool options to be used in the call to OrtApi::CreateEnvWithGlobalThreadPools.
   * Flush-to-zero and denormal-as-zero are applied to threads in both intra and inter global thread pool.
   * \note This option is not needed if the models used have no denormals. Having no denormals is recommended as this option may hurt model accuracy.
   *
   * @param tp_options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetGlobalDenormalAsZero( OrtThreadingOptions tp_options);

  /** \}
   *  \name OrtArenaCfg
   *  \{
  <p>
  /** @deprecated Use OrtApi::CreateArenaCfgV2
   *
   * This will create the configuration of an arena that can eventually be used to define an arena based allocator's behavior
   *
   * @param max_mem [in] Use 0 to allow ORT to choose the default
   * @param arena_extend_strategy [in] Use -1 to allow ORT to choose the default, 0 = kNextPowerOfTwo, 1 = kSameAsRequested
   * @param initial_chunk_size_bytes [in] Use -1 to allow ORT to choose the default
   * @param max_dead_bytes_per_chunk [in] Use -1 to allow ORT to choose the default
   * @param out [in] A pointer to an OrtArenaCfg instance
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateArenaCfg( @Cast("size_t") long max_mem, int arena_extend_strategy, int initial_chunk_size_bytes,
                    int max_dead_bytes_per_chunk, @Cast("OrtArenaCfg**") PointerPointer out);
  public native OrtStatus CreateArenaCfg( @Cast("size_t") long max_mem, int arena_extend_strategy, int initial_chunk_size_bytes,
                    int max_dead_bytes_per_chunk, @ByPtrPtr OrtArenaCfg out);

  public native void ReleaseArenaCfg(OrtArenaCfg input);

  /** \}
   *  \name OrtModelMetadata
   *  \{
  <p>
  /**
   * Use this to obtain the description of the graph present in the model
   * (doc_string field of the GraphProto message within the ModelProto message).
   * If it doesn't exist, an empty string will be returned.
   *
   * @param model_metadata [in] An instance of ::OrtModelMetadata
   * @param allocator [in] Allocator used to allocate the string that will be returned back
   * @param value [out] Set to a null terminated string allocated using {@code allocator}.  The caller is responsible for freeing it using {@code allocator}
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus ModelMetadataGetGraphDescription( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") PointerPointer value);
  public native OrtStatus ModelMetadataGetGraphDescription( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer value);
  public native OrtStatus ModelMetadataGetGraphDescription( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer value);
  public native OrtStatus ModelMetadataGetGraphDescription( @Const OrtModelMetadata model_metadata,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] value);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Append TensorRT provider to session options
   *
   * If TensorRT is not available (due to a non TensorRT enabled build, or if TensorRT is not installed on the system), this function will return failure.
   *
   * @param options [in]
   * @param tensorrt_options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionOptionsAppendExecutionProvider_TensorRT(
                    OrtSessionOptions options, @Const OrtTensorRTProviderOptions tensorrt_options);

  /** \}
   *  \name Misc
   *  \{
  <p>
  /** \brief Set current GPU device ID
   *
   * Set the current device id of the GPU execution provider (CUDA/tensorrt/rocm). The device id should be less
   * than the total number of devices available. This is only useful when multiple-GPUs are installed and it is
   * required to restrict execution to a single GPU.
   *
   * @param device_id [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetCurrentGpuDeviceId( int device_id);

  /** \brief Get current GPU device ID
   *
   * Get the current device id of the GPU execution provider (CUDA/tensorrt/rocm).
   *
   * @see OrtApi::SetCurrentGpuDeviceId
   *
   * @param device_id [out]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetCurrentGpuDeviceId( IntPointer device_id);
  public native OrtStatus GetCurrentGpuDeviceId( IntBuffer device_id);
  public native OrtStatus GetCurrentGpuDeviceId( int[] device_id);

  /** \}
   *  \name OrtKernelInfo
   *  Custom operator APIs.
   *  \{
  <p>
  /** \brief Fetch an array of int64_t values stored as an attribute in the graph node
   *
   *
   * If {@code out} is nullptr, the value of {@code size} is set to the true size of the attribute
   * array's size, and a success status is returned.
   *
   * If the {@code size} parameter is greater than or equal to the actual attribute array's size,
   * the value of {@code size} is set to the true size of the attribute array's size,
   * the provided memory is filled with the attribute's contents,
   * and a success status is returned.
   *
   * If the {@code size} parameter is less than the actual attribute array's size and {@code out}
   * is not nullptr, the value of {@code size} is set to the true size of the attribute array's size
   * and a failure status is returned.)
   *
   * @param info [in] instance
   * @param name [in] name of the attribute to be parsed
   * @param out [out] pointer to memory where the attribute's contents are to be stored
   * @param size [in, out] actual size of attribute array
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus KernelInfoGetAttributeArray_float( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    FloatPointer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_float( @Const OrtKernelInfo info, String name,
                    FloatBuffer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_float( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    float[] out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_float( @Const OrtKernelInfo info, String name,
                    FloatPointer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_float( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    FloatBuffer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_float( @Const OrtKernelInfo info, String name,
                    float[] out, @Cast("size_t*") SizeTPointer size);

  /** \brief Fetch an array of int64_t values stored as an attribute in the graph node
   *
   * If {@code out} is nullptr, the value of {@code size} is set to the true size of the attribute
   * array's size, and a success status is returned.
   *
   * If the {@code size} parameter is greater than or equal to the actual attribute array's size,
   * the value of {@code size} is set to the true size of the attribute array's size,
   * the provided memory is filled with the attribute's contents,
   * and a success status is returned.
   *
   * If the {@code size} parameter is less than the actual attribute array's size and {@code out}
   * is not nullptr, the value of {@code size} is set to the true size of the attribute array's size
   * and a failure status is returned.)
   *
   * @param info [in] instance
   * @param name [in] name of the attribute to be parsed
   * @param out [out] pointer to memory where the attribute's contents are to be stored
   * @param size [in, out] actual size of attribute array
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus KernelInfoGetAttributeArray_int64( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    @Cast("int64_t*") LongPointer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_int64( @Const OrtKernelInfo info, String name,
                    @Cast("int64_t*") LongBuffer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_int64( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    @Cast("int64_t*") long[] out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_int64( @Const OrtKernelInfo info, String name,
                    @Cast("int64_t*") LongPointer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_int64( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    @Cast("int64_t*") LongBuffer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfoGetAttributeArray_int64( @Const OrtKernelInfo info, String name,
                    @Cast("int64_t*") long[] out, @Cast("size_t*") SizeTPointer size);

  /** \}
   *  \name OrtArenaCfg
   *  \{
  <p>
  /** \brief Create an ::OrtArenaCfg
   *
   * Create the configuration of an arena that can eventually be used to define an arena based allocator's behavior.
   *
   * Supported keys are (See https://onnxruntime.ai/docs/get-started/with-c.html for details on what the
   * following parameters mean and how to choose these values.):
   * "max_mem": Maximum memory that can be allocated by the arena based allocator.
   *  Use 0 for ORT to pick the best value. Default is 0.
   * "arena_extend_strategy": 0 = kNextPowerOfTwo, 1 = kSameAsRequested.
   *  Use -1 to allow ORT to choose the default.
   * "initial_chunk_size_bytes": (Possible) Size of the first allocation in the arena.
   *  Only relevant if arena strategy is {@code kNextPowerOfTwo}. Use -1 to allow ORT to choose the default.
   *  Ultimately, the first allocation size is determined by the allocation memory request.
   * "max_dead_bytes_per_chunk": Threshold of unused memory in an allocated chunk of arena memory after
   *  crossing which the current chunk is chunked into 2.
   * "initial_growth_chunk_size_bytes": (Possible) Size of the second allocation in the arena.
   *  Only relevant if arena strategy is {@code kNextPowerOfTwo}. Use -1 to allow ORT to choose the default.
   * "max_power_of_two_extend_bytes": The maximum extend size if arena strategy is {@code kNextPowerOfTwo}.
   *  It is not an allocation limit, it is only a limit for extension when requested byte is less than the limit.
   *  When requested bytes is more than the limit, allocator will still return as requested.
   *  Use -1 to allow ORT to choose the default 1GB for max_power_of_two_extend_bytes.
   *  Ultimately, the allocation size is determined by the allocation memory request.
   *  Further allocation sizes are governed by the arena extend strategy.
   *
   * @param arena_config_keys [in] Keys to configure the arena
   * @param arena_config_values [in] Values to configure the arena
   * @param num_keys [in] Number of keys in {@code arena_config_keys} and {@code arena_config_values}
   * @param out [out] Newly created ::OrtArenaCfg. Must be freed with OrtApi::ReleaseArenaCfg
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateArenaCfgV2( @Cast("const char*const*") PointerPointer arena_config_keys,
                    @Cast("const size_t*") SizeTPointer arena_config_values, @Cast("size_t") long num_keys,
                    @Cast("OrtArenaCfg**") PointerPointer out);
  public native OrtStatus CreateArenaCfgV2( @Cast("const char*const*") @ByPtrPtr BytePointer arena_config_keys,
                    @Cast("const size_t*") SizeTPointer arena_config_values, @Cast("size_t") long num_keys,
                    @ByPtrPtr OrtArenaCfg out);
  public native OrtStatus CreateArenaCfgV2( @Cast("const char*const*") @ByPtrPtr ByteBuffer arena_config_keys,
                    @Cast("const size_t*") SizeTPointer arena_config_values, @Cast("size_t") long num_keys,
                    @ByPtrPtr OrtArenaCfg out);
  public native OrtStatus CreateArenaCfgV2( @Cast("const char*const*") @ByPtrPtr byte[] arena_config_keys,
                    @Cast("const size_t*") SizeTPointer arena_config_values, @Cast("size_t") long num_keys,
                    @ByPtrPtr OrtArenaCfg out);

  /** \}
   *  \name OrtRunOptions
   *  \{
  <p>
  /** \brief Set a single run configuration entry as a pair of strings
   *
   * If a configuration with same key exists, this will overwrite the configuration with the given config_value
   *
   * The config_key and the format of config_value are defined in onnxruntime_run_options_config_keys.h
   *
   * @param options [in]
   * @param config_key [in] A null terminated string representation of the config key
   * @param config_value [in]  A null terminated string representation of the config value
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus AddRunConfigEntry( OrtRunOptions options,
                    @Cast("const char*") BytePointer config_key, @Cast("const char*") BytePointer config_value);
  public native OrtStatus AddRunConfigEntry( OrtRunOptions options,
                    String config_key, String config_value);

  /** \}
   *  \name OrtPrepackedWeightsContainer
   *  \{
  <p>
  /** \brief Create an ::OrtPrepackedWeightsContainer
   *
   * This container will hold pre-packed buffers of shared initializers for sharing between sessions
   * (i.e.) if there are shared initializers that can be shared between sessions, the pre-packed buffers
   * of these (if any) may possibly be shared to provide memory footprint savings. Pass this container
   * to sessions that you would like to share pre-packed buffers of shared initializers at session
   * creation time.
   *
   *  @param out [out] Newly created ::OrtPrepackedWeightsContainer. Must be freed with OrtApi::ReleasePrepackedWeightsContainer
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreatePrepackedWeightsContainer( @Cast("OrtPrepackedWeightsContainer**") PointerPointer out);
  public native OrtStatus CreatePrepackedWeightsContainer( @ByPtrPtr OrtPrepackedWeightsContainer out);

  /** \brief Release OrtPrepackedWeightsContainer instance
   *
   * \note instance must not be released until the sessions using it are released
   */
  public native void ReleasePrepackedWeightsContainer(OrtPrepackedWeightsContainer input);

  /** \}
   *  \name OrtSession
   *  \{
  <p>
  /** \brief Create session with prepacked weights container
   *
   * Same functionality offered by OrtApi::CreateSession except that a container that contains
   * pre-packed weights' buffers is written into/read from by the created session.
   * This is useful when used in conjunction with OrtApi::AddInitializer which injects
   * shared initializer info into sessions. Wherever possible, the pre-packed versions of these
   * shared initializers are cached in this container so that multiple sessions can just re-use
   * these instead of duplicating these in memory.
   *
   * @param env [in] OrtEnv instance instance
   * @param model_path [in] Null terminated string of the path (wchar on Windows, char otherwise)
   * @param options [in]
   * @param prepacked_weights_container [in]
   * @param out [out] Newly created ::OrtSession. Must be freed with OrtApi::ReleaseSession
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateSessionWithPrepackedWeightsContainer( @Const OrtEnv env, @Cast("const ORTCHAR_T*") Pointer model_path,
                    @Const OrtSessionOptions options,
                    OrtPrepackedWeightsContainer prepacked_weights_container,
                    @Cast("OrtSession**") PointerPointer out);
  public native OrtStatus CreateSessionWithPrepackedWeightsContainer( @Const OrtEnv env, @Cast("const ORTCHAR_T*") Pointer model_path,
                    @Const OrtSessionOptions options,
                    OrtPrepackedWeightsContainer prepacked_weights_container,
                    @ByPtrPtr OrtSession out);

  /** \brief Create session from memory with prepacked weights container
   *
   * Same functionality offered by OrtApi::CreateSessionFromArray except that a container that contains
   * pre-packed weights' buffers is written into/read from by the created session.
   * This is useful when used in conjunction with OrtApi::AddInitializer which injects
   * shared initializer info into sessions. Wherever possible, the pre-packed versions of these
   * shared initializers are cached in this container so that multiple sessions can just re-use
   * these instead of duplicating these in memory.
   *
   * @param env [in]
   * @param model_data [in] Array of bytes holding the model
   * @param model_data_length [in] Number of bytes in {@code model_data_model}
   * @param options [in]
   * @param prepacked_weights_container [in]
   * @param out [out] Newly created ::OrtSession. Must be freed with OrtApi::ReleaseSession
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateSessionFromArrayWithPrepackedWeightsContainer( @Const OrtEnv env,
                    @Const Pointer model_data, @Cast("size_t") long model_data_length,
                    @Const OrtSessionOptions options,
                    OrtPrepackedWeightsContainer prepacked_weights_container,
                    @Cast("OrtSession**") PointerPointer out);
  public native OrtStatus CreateSessionFromArrayWithPrepackedWeightsContainer( @Const OrtEnv env,
                    @Const Pointer model_data, @Cast("size_t") long model_data_length,
                    @Const OrtSessionOptions options,
                    OrtPrepackedWeightsContainer prepacked_weights_container,
                    @ByPtrPtr OrtSession out);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Append TensorRT execution provider to the session options
   *
   * If TensorRT is not available (due to a non TensorRT enabled build), this function will return failure.
   *
   * This is slightly different from OrtApi::SessionOptionsAppendExecutionProvider_TensorRT, it takes an
   * ::OrtTensorRTProviderOptions which is publicly defined. This takes an opaque ::OrtTensorRTProviderOptionsV2
   * which must be created with OrtApi::CreateTensorRTProviderOptions.
   *
   * For OrtApi::SessionOptionsAppendExecutionProvider_TensorRT, the user needs to instantiate ::OrtTensorRTProviderOptions
   * as well as allocate/release buffers for some members of ::OrtTensorRTProviderOptions.
   * Here, OrtApi::CreateTensorRTProviderOptions and Ortapi::ReleaseTensorRTProviderOptions will do the memory management for you.
   *
   * @param options [in]
   * @param tensorrt_options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionOptionsAppendExecutionProvider_TensorRT_V2(
                    OrtSessionOptions options, @Const OrtTensorRTProviderOptionsV2 tensorrt_options);

  /** \}
   *  \name OrtTensorRTProviderOptionsV2
   *  \{
  <p>
  /** \brief Create an OrtTensorRTProviderOptionsV2
   *
   * @param out [out] Newly created ::OrtTensorRTProviderOptionsV2. Must be released with OrtApi::ReleaseTensorRTProviderOptions
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateTensorRTProviderOptions( @Cast("OrtTensorRTProviderOptionsV2**") PointerPointer out);
  public native OrtStatus CreateTensorRTProviderOptions( @ByPtrPtr OrtTensorRTProviderOptionsV2 out);

  /** \brief Set options in a TensorRT Execution Provider.
   *
   * Please refer to https://onnxruntime.ai/docs/execution-providers/TensorRT-ExecutionProvider.html#cc
   * to know the available keys and values. Key should be in null terminated string format of the member of ::OrtTensorRTProviderOptionsV2
   * and value should be its related range. Recreates the options and only sets the supplied values.
   *
   * For example, key="trt_max_workspace_size" and value="2147483648"
   *
   * @param tensorrt_options [in]
   * @param provider_options_keys [in] Array of UTF-8 null-terminated string for provider options keys
   * @param provider_options_values [in] Array of UTF-8 null-terminated string for provider options values
   * @param num_keys [in] Number of elements in the {@code provider_option_keys} and {@code provider_options_values} arrays
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus UpdateTensorRTProviderOptions( OrtTensorRTProviderOptionsV2 tensorrt_options,
                    @Cast("const char*const*") PointerPointer provider_options_keys,
                    @Cast("const char*const*") PointerPointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateTensorRTProviderOptions( OrtTensorRTProviderOptionsV2 tensorrt_options,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateTensorRTProviderOptions( OrtTensorRTProviderOptionsV2 tensorrt_options,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateTensorRTProviderOptions( OrtTensorRTProviderOptionsV2 tensorrt_options,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_values,
                    @Cast("size_t") long num_keys);

  /** \brief Get serialized TensorRT provider options string.
   *
   * For example, "trt_max_workspace_size=2147483648;trt_max_partition_iterations=10;trt_int8_enable=1;......"
   *
   * @param tensorrt_options - OrtTensorRTProviderOptionsV2 instance
   * @param allocator - a ptr to an instance of OrtAllocator obtained with OrtApi::CreateAllocator or OrtApi::GetAllocatorWithDefaultOptions
   *                      the specified allocator will be used to allocate continuous buffers for output strings and lengths.
   * @param ptr - is a UTF-8 null terminated string allocated using 'allocator'. The caller is responsible for using the same allocator to free it.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetTensorRTProviderOptionsAsString( @Const OrtTensorRTProviderOptionsV2 tensorrt_options, OrtAllocator allocator, @Cast("char**") PointerPointer ptr);
  public native OrtStatus GetTensorRTProviderOptionsAsString( @Const OrtTensorRTProviderOptionsV2 tensorrt_options, OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer ptr);
  public native OrtStatus GetTensorRTProviderOptionsAsString( @Const OrtTensorRTProviderOptionsV2 tensorrt_options, OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer ptr);
  public native OrtStatus GetTensorRTProviderOptionsAsString( @Const OrtTensorRTProviderOptionsV2 tensorrt_options, OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] ptr);

  /** \brief Release an ::OrtTensorRTProviderOptionsV2
   *
   * \note This is an exception in the naming convention of other Release* functions, as the name of the method does not have the V2 suffix, but the type does
   */
  public static class ReleaseTensorRTProviderOptions_OrtTensorRTProviderOptionsV2 extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    ReleaseTensorRTProviderOptions_OrtTensorRTProviderOptionsV2(Pointer p) { super(p); }
      protected ReleaseTensorRTProviderOptions_OrtTensorRTProviderOptionsV2() { allocate(); }
      private native void allocate();
      public native void call(OrtTensorRTProviderOptionsV2 input);
  }
  public native ReleaseTensorRTProviderOptions_OrtTensorRTProviderOptionsV2 ReleaseTensorRTProviderOptions(); public native OrtApi ReleaseTensorRTProviderOptions(ReleaseTensorRTProviderOptions_OrtTensorRTProviderOptionsV2 setter);

  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Enable custom operators
   *
   * See onnxruntime-extensions: https://github.com/microsoft/onnxruntime-extensions.git
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus EnableOrtCustomOps( OrtSessionOptions options);

  /** \}
   *  \name OrtAllocator
   *  \{
  <p>
  /** \brief Register a custom allocator
   *
   * Enables sharing between multiple sessions that use the same env instance.
   * Returns an error if an allocator with the same ::OrtMemoryInfo is already registered.
   *
   * The behavior of this is exactly the same as OrtApi::CreateAndRegisterAllocator except
   * instead of ORT creating an allocator based on provided info, in this case
   * ORT uses the user-provided custom allocator.
   * See https://onnxruntime.ai/docs/get-started/with-c.html for details.
   *
   * @param env [in]
   * @param allocator [in] User provided allocator
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus RegisterAllocator( OrtEnv env, OrtAllocator allocator);

  /** \brief Unregister a custom allocator
   *
   * It is an error if you provide an ::OrtMemoryInfo not corresponding to any
   * registered allocators for sharing.
   *
   * @param env [in]
   * @param mem_info [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus UnregisterAllocator( OrtEnv env,
                    @Const OrtMemoryInfo mem_info);

  /** \}
   *  \name OrtValue
   *  \{
  <p>
  /** \brief Sets *out to 1 iff an ::OrtValue is a SparseTensor, and 0 otherwise
   *
   * @param value [in] existing ::OrtValue
   * @param out [out] unless an error occurs, contains 1 iff the value contains an instance
   *  of sparse tensor or 0 otherwise.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus IsSparseTensor( @Const OrtValue value, IntPointer out);
  public native OrtStatus IsSparseTensor( @Const OrtValue value, IntBuffer out);
  public native OrtStatus IsSparseTensor( @Const OrtValue value, int[] out);

  /** \brief Create an ::OrtValue with a sparse tensor that is empty.
   *
   * Use FillSparseTensor<Format>() functions to populate sparse tensor with non-zero values and
   * format specific indices data.
   * Use ReleaseValue to destroy the sparse tensor, this will also release the buffer inside the output value
   * if any was allocated.
   * @param allocator [in,out] allocator to use when performing an allocation. Allocation will be performed
   *   by FillSparseTensor<Format>() APIs. The lifespan of the allocator instance must eclipse the lifespan
   *   this sparse tensor instance as the same allocator will be used to free memory.
   * @param dense_shape [in] shape of the original dense tensor
   * @param dense_shape_len [in] number of shape dimensions being passed
   * @param type [in] must be one of TENSOR_ELEMENT_DATA_TYPE_xxxx
   * @param out [out] Should be freed by calling ReleaseValue
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateSparseTensorAsOrtValue( OrtAllocator allocator, @Cast("const int64_t*") LongPointer dense_shape,
                    @Cast("size_t") long dense_shape_len, @Cast("ONNXTensorElementDataType") int type, @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus CreateSparseTensorAsOrtValue( OrtAllocator allocator, @Cast("const int64_t*") LongPointer dense_shape,
                    @Cast("size_t") long dense_shape_len, @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);
  public native OrtStatus CreateSparseTensorAsOrtValue( OrtAllocator allocator, @Cast("const int64_t*") LongBuffer dense_shape,
                    @Cast("size_t") long dense_shape_len, @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);
  public native OrtStatus CreateSparseTensorAsOrtValue( OrtAllocator allocator, @Cast("const int64_t*") long[] dense_shape,
                    @Cast("size_t") long dense_shape_len, @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);

  /**
   * This fills populates an empty tensor that was created using OrtApi::CreateSparseTensorAsOrtValue.
   * This will allocate required memory and copy the supplied NNZ values and COO indices into that memory allocation.
   * Memory allocation is performed using the allocator that was specified with OrtApi::CreateSparseTensorAsOrtValue.
   *
   * @param ort_value [in,out] ::OrtValue to populate with data
   * @param data_mem_info [in] serves to identify the location of the data to be copied. If the allocator specified
   *  at the creation time has memory info that is not the same as mem_info argument to this function a X-device copy will be performed.
   *  String data is assumed to be on CPU and will only be copied into a CPU allocated buffer.
   * @param values_shape [in] pointer to values shape array
   * @param values_shape_len [in] length of the values_shape
   * @param values [in] pointer to an array of values. For strings, pass const char**.
   * @param indices_data [in] pointer to a location of COO indices
   * @param indices_num [in] number of COO indices
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus FillSparseTensorCoo( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") LongPointer values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") LongPointer indices_data, @Cast("size_t") long indices_num);
  public native OrtStatus FillSparseTensorCoo( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") LongBuffer values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") LongBuffer indices_data, @Cast("size_t") long indices_num);
  public native OrtStatus FillSparseTensorCoo( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") long[] values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") long[] indices_data, @Cast("size_t") long indices_num);

  /**
   * This fills populates an empty tensor that was created using OrtApi::CreateSparseTensorAsOrtValue.
   * This will allocate required memory and copy the supplied NNZ values and CSR indices into that memory allocation.
   * Memory allocation is performed using the allocator that was specified with OrtApi::CreateSparseTensorAsOrtValue.
   *
   * @param ort_value [in,out] ::OrtValue to populate with data
   * @param data_mem_info [in] serves to identify the location of the data to be copied. If the allocator specified
   *  at the creation time has memory info that is not the same as mem_info argument to this function a X-device copy will be performed.
   *  String data is assumed to be on CPU and will only be copied into a CPU allocated buffer.
   * @param values_shape [in] pointer to values shape array
   * @param values_shape_len [in] length of the values_shape
   * @param values [in] - pointer to an array of values. For strings, pass const char**.
   * @param inner_indices_data [in] pointer to a location of CSR inner indices
   * @param inner_indices_num [in] number of CSR inner indices
   * @param outer_indices_data [in] pointer to a location of CSR outer indices
   * @param outer_indices_num [in] number of CSR outer indices
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus FillSparseTensorCsr( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") LongPointer values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") LongPointer inner_indices_data, @Cast("size_t") long inner_indices_num,
                    @Cast("const int64_t*") LongPointer outer_indices_data, @Cast("size_t") long outer_indices_num);
  public native OrtStatus FillSparseTensorCsr( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") LongBuffer values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") LongBuffer inner_indices_data, @Cast("size_t") long inner_indices_num,
                    @Cast("const int64_t*") LongBuffer outer_indices_data, @Cast("size_t") long outer_indices_num);
  public native OrtStatus FillSparseTensorCsr( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") long[] values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") long[] inner_indices_data, @Cast("size_t") long inner_indices_num,
                    @Cast("const int64_t*") long[] outer_indices_data, @Cast("size_t") long outer_indices_num);

  /**
   * This fills populates an empty tensor that was created using OrtApi::CreateSparseTensorAsOrtValue.
   * This will allocate required memory and copy the supplied NNZ values and BlockSparse indices into that memory allocation.
   * Memory allocation is performed using the allocator that was specified with OrtApi::CreateSparseTensorAsOrtValue.
   *
   * @param ort_value [in,out] ::OrtValue to populate with data
   * @param data_mem_info [in] serves to identify the location of the data to be copied. If the allocator specified
   *  at the creation time has memory info that is not the same as mem_info argument to this function a X-device copy will be performed.
   *  String data is assumed to be on CPU and will only be copied into a CPU allocated buffer.
   * @param values_shape [in]
   * @param values_shape_len [in]
   * @param values [in] structure with values information
   * @param indices_shape_data [in] pointer to a location of indices shape
   * @param indices_shape_len [in] length of the block sparse indices shape
   * @param indices_data [in] pointer to a location of indices data. Shape will determine the length of the indices data.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus FillSparseTensorBlockSparse( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") LongPointer values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") LongPointer indices_shape_data, @Cast("size_t") long indices_shape_len,
                    @Const IntPointer indices_data);
  public native OrtStatus FillSparseTensorBlockSparse( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") LongBuffer values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") LongBuffer indices_shape_data, @Cast("size_t") long indices_shape_len,
                    @Const IntBuffer indices_data);
  public native OrtStatus FillSparseTensorBlockSparse( OrtValue ort_value, @Const OrtMemoryInfo data_mem_info,
                    @Cast("const int64_t*") long[] values_shape, @Cast("size_t") long values_shape_len, @Const Pointer values,
                    @Cast("const int64_t*") long[] indices_shape_data, @Cast("size_t") long indices_shape_len,
                    @Const int[] indices_data);

  /**
   * Create an ::OrtValue with a sparse tensor. This is the first step.
   * Next, use Use<Format>Indices() functions to supply sparse tensor with
   * format specific indices data and set its sparse format to a specific enum value.
   * This will not perform memory allocations. It will
   * use supplied user buffer which should outlive the created sparse tensor.
   * Use OrtApi::ReleaseValue to destroy the sparse tensor. It would not release the supplied values buffer.
   * This function can not be used to map strings from the user allocated memory. Strings must always be copied
   * and have UTF-8 encoding. Therefore, use OrtApi::CreateSparseTensorAsOrtValue above and then fill it with data
   * using appropriate Make*() function.
   *
   * @param info [in] memory info where sparse values reside.
   * @param p_data [in,out] pointer to a user allocated buffer with values. To create a full sparse tensor with no non-zero
   *   values, pass nullptr
   * @param dense_shape [in] shape of the original dense tensor
   * @param dense_shape_len [in] number of shape dimensions being passed
   * @param values_shape [in] shape of the values data. To create a fully sparse tensor with no non-zero values,
   *   pass {0} shape.
   * @param values_shape_len [in] number of values shape dimensions
   * @param type [in] must be one of TENSOR_ELEMENT_DATA_TYPE_xxxx
   * @param out [out] Should be freed by calling ReleaseValue
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus CreateSparseTensorWithValuesAsOrtValue( @Const OrtMemoryInfo info, Pointer p_data,
                    @Cast("const int64_t*") LongPointer dense_shape, @Cast("size_t") long dense_shape_len,
                    @Cast("const int64_t*") LongPointer values_shape, @Cast("size_t") long values_shape_len,
                    @Cast("ONNXTensorElementDataType") int type, @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus CreateSparseTensorWithValuesAsOrtValue( @Const OrtMemoryInfo info, Pointer p_data,
                    @Cast("const int64_t*") LongPointer dense_shape, @Cast("size_t") long dense_shape_len,
                    @Cast("const int64_t*") LongPointer values_shape, @Cast("size_t") long values_shape_len,
                    @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);
  public native OrtStatus CreateSparseTensorWithValuesAsOrtValue( @Const OrtMemoryInfo info, Pointer p_data,
                    @Cast("const int64_t*") LongBuffer dense_shape, @Cast("size_t") long dense_shape_len,
                    @Cast("const int64_t*") LongBuffer values_shape, @Cast("size_t") long values_shape_len,
                    @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);
  public native OrtStatus CreateSparseTensorWithValuesAsOrtValue( @Const OrtMemoryInfo info, Pointer p_data,
                    @Cast("const int64_t*") long[] dense_shape, @Cast("size_t") long dense_shape_len,
                    @Cast("const int64_t*") long[] values_shape, @Cast("size_t") long values_shape_len,
                    @Cast("ONNXTensorElementDataType") int type, @ByPtrPtr OrtValue out);

  /**
   * This assigns Coo format indices to the SparseTensor that was created by
   * OrtApi::CreateSparseTensorWithValuesAsOrtValue above. It also sets OrtSparseFormat to
   * ORT_SPARSE_COO. This will not allocate any additional memory for data. The life span of
   * indices_data buffer should eclipse the life span of this ::OrtValue.
   *
   * @param ort_value [in,out] ::OrtValue instance constructed with OrtApi::CreateSparseTensorWithValuesAsOrtValue
   * @param indices_data [in,out] pointer to a user pre-allocated buffer or nullptr for fully sparse tensors.
   * @param indices_num [in]  number of COO indices. Should either be 0 for fully sparse tensors, be equal
   *  to the number of nnz values specified to OrtApi::CreateSparseTensorWithValuesAsOrtValue for 1-D {nnz} indices or
   *  be twice as number of nnz values for a  2-D indices {nnz, 2}
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus UseCooIndices( OrtValue ort_value, @Cast("int64_t*") LongPointer indices_data, @Cast("size_t") long indices_num);
  public native OrtStatus UseCooIndices( OrtValue ort_value, @Cast("int64_t*") LongBuffer indices_data, @Cast("size_t") long indices_num);
  public native OrtStatus UseCooIndices( OrtValue ort_value, @Cast("int64_t*") long[] indices_data, @Cast("size_t") long indices_num);

  /**
   * The assigns CSR format indices to the SparseTensor that was created by
   * OrtApi::CreateSparseTensorWithValuesAsOrtValue above. It also sets OrtSparseFormat to
   * ORT_SPARSE_CSRC. This will not allocate any additional memory for data. The life spans of
   * inner_data and outer_data buffers should eclipse the life span of this ::OrtValue.
   *
   * @param ort_value [in,out] ::OrtValue instance constructed with OrtApi::CreateSparseTensorWithValuesAsOrtValue
   * @param inner_data [in,out] pointer to a user pre-allocated buffer or nullptr for fully sparse tensors.
   * @param inner_num [in]  number of inner CSR indices. Should either be 0 for fully sparse tensors or be equal
   * to the number of nnz values specified to OrtApi::CreateSparseTensorWithValuesAsOrtValue.
   * @param outer_data [in,out] pointer to user pre-allocated buffer or nullptr for fully sparse tensors.
   * @param outer_num [in] number of CSR outer indices. Should either be 0 for fully sparse tensors or
   * equal to rows + 1 of the dense shape.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus UseCsrIndices( OrtValue ort_value, @Cast("int64_t*") LongPointer inner_data, @Cast("size_t") long inner_num,
                    @Cast("int64_t*") LongPointer outer_data, @Cast("size_t") long outer_num);
  public native OrtStatus UseCsrIndices( OrtValue ort_value, @Cast("int64_t*") LongBuffer inner_data, @Cast("size_t") long inner_num,
                    @Cast("int64_t*") LongBuffer outer_data, @Cast("size_t") long outer_num);
  public native OrtStatus UseCsrIndices( OrtValue ort_value, @Cast("int64_t*") long[] inner_data, @Cast("size_t") long inner_num,
                    @Cast("int64_t*") long[] outer_data, @Cast("size_t") long outer_num);

  /**
   * The assigns BlockSparse format indices to the SparseTensor that was created by
   * OrtApi::CreateSparseTensorWithValuesAsOrtValue above. It also sets OrtSparseFormat to
   * ORT_SPARSE_BLOCK_SPARSE. This will not allocate any additional memory for data. The life span of
   * indices_data buffer must eclipse the lifespan of this ::OrtValue.
   *
   * @param ort_value [in,out] OrtValue instance constructed with OrtApi::CreateSparseTensorWithValuesAsOrtValue
   * @param indices_shape [in] pointer to indices shape. Use {0} for fully sparse tensors
   * @param indices_shape_len [in] length of the indices shape
   * @param indices_data [in,out] pointer to user pre-allocated buffer or nullptr for fully sparse tensors.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus UseBlockSparseIndices( OrtValue ort_value, @Cast("const int64_t*") LongPointer indices_shape, @Cast("size_t") long indices_shape_len, IntPointer indices_data);
  public native OrtStatus UseBlockSparseIndices( OrtValue ort_value, @Cast("const int64_t*") LongBuffer indices_shape, @Cast("size_t") long indices_shape_len, IntBuffer indices_data);
  public native OrtStatus UseBlockSparseIndices( OrtValue ort_value, @Cast("const int64_t*") long[] indices_shape, @Cast("size_t") long indices_shape_len, int[] indices_data);

  /** \brief Returns sparse tensor format enum iff a given ort value contains an instance of sparse tensor.
   *
   * @param ort_value [in] ::OrtValue that contains an instance of sparse tensor
   * @param out [out] pointer to out parameter
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetSparseTensorFormat( @Const OrtValue ort_value, @Cast("OrtSparseFormat*") IntPointer out);
  public native OrtStatus GetSparseTensorFormat( @Const OrtValue ort_value, @Cast("OrtSparseFormat*") IntBuffer out);
  public native OrtStatus GetSparseTensorFormat( @Const OrtValue ort_value, @Cast("OrtSparseFormat*") int[] out);

  /** \brief Returns data type and shape of sparse tensor values (nnz) iff ::OrtValue contains a SparseTensor.
   *
   * @param ort_value [in] An ::OrtValue that contains a fully constructed sparse tensor
   * @param out [out] Must be freed by OrtApi::ReleaseTensorTypeAndShapeInfo
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetSparseTensorValuesTypeAndShape( @Const OrtValue ort_value, @Cast("OrtTensorTypeAndShapeInfo**") PointerPointer out);
  public native OrtStatus GetSparseTensorValuesTypeAndShape( @Const OrtValue ort_value, @ByPtrPtr OrtTensorTypeAndShapeInfo out);

  /** \brief Returns numeric data for sparse tensor values (nnz). For string values use GetStringTensor*().
   *
   * @param ort_value [in] an instance of ::OrtValue containing sparse tensor
   * @param out [out] returns a pointer to values data.  Do not attempt to free this ptr.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetSparseTensorValues( @Const OrtValue ort_value, @Cast("const void**") PointerPointer out);
  public native OrtStatus GetSparseTensorValues( @Const OrtValue ort_value, @Cast("const void**") @ByPtrPtr Pointer out);

  /** \brief Returns data type, shape for the type of indices specified by indices_format.
   *
   * @param ort_value [in] ::OrtValue containing sparse tensor.
   * @param indices_format [in] One of the indices formats. It is an error to request a format that the sparse
   * tensor does not contain.
   * @param out [out] an instance of ::OrtTensorTypeAndShapeInfo. Must be freed by OrtApi::ReleaseTensorTypeAndShapeInfo
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetSparseTensorIndicesTypeShape( @Const OrtValue ort_value, OrtSparseIndicesFormat indices_format, @Cast("OrtTensorTypeAndShapeInfo**") PointerPointer out);
  public native OrtStatus GetSparseTensorIndicesTypeShape( @Const OrtValue ort_value, OrtSparseIndicesFormat indices_format, @ByPtrPtr OrtTensorTypeAndShapeInfo out);
  public native OrtStatus GetSparseTensorIndicesTypeShape( @Const OrtValue ort_value, @Cast("OrtSparseIndicesFormat") int indices_format, @ByPtrPtr OrtTensorTypeAndShapeInfo out);

  /** \brief Returns indices data for the type of the indices specified by indices_format
   *
   * @param ort_value [in] ::OrtValue containing sparse tensor.
   * @param indices_format [in] One of the indices formats. It is an error to request a format that the sparse tensor does not contain.
   * @param num_indices [out] Pointer to where the number of indices entries is returned
   * @param indices [out] Returned pointer to the indices data. Do not free the returned pointer as it refers to internal data owned by the ::OrtValue
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetSparseTensorIndices( @Const OrtValue ort_value, OrtSparseIndicesFormat indices_format, @Cast("size_t*") SizeTPointer num_indices, @Cast("const void**") PointerPointer indices);
  public native OrtStatus GetSparseTensorIndices( @Const OrtValue ort_value, OrtSparseIndicesFormat indices_format, @Cast("size_t*") SizeTPointer num_indices, @Cast("const void**") @ByPtrPtr Pointer indices);
  public native OrtStatus GetSparseTensorIndices( @Const OrtValue ort_value, @Cast("OrtSparseIndicesFormat") int indices_format, @Cast("size_t*") SizeTPointer num_indices, @Cast("const void**") @ByPtrPtr Pointer indices);
  /** \}
   *  \name OrtSessionOptions
   *  \{
  <p>
  /**
   * \brief Sets out to 1 iff an optional type OrtValue has an element, 0 otherwise (OrtValue is None)
   * Use this API to find if the optional type OrtValue is None or not.
   * If the optional type OrtValue is not None, use the OrtValue just like any other OrtValue.
   * For example, if you get an OrtValue that corresponds to Optional(tensor) and
   * if HasValue() returns true, use it as tensor and so on.
   <p>
   * @param value [in] Input OrtValue.
   * @param out [out] indicating if the input OrtValue contains data (1) or if it is a None (0)
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus HasValue( @Const OrtValue value, IntPointer out);
  public native OrtStatus HasValue( @Const OrtValue value, IntBuffer out);
  public native OrtStatus HasValue( @Const OrtValue value, int[] out);

  /** \}
   *  \name OrtKernelContext
   *  Custom operator APIs.
   *  \{
  <p>
  /** \brief Used for custom operators, gets the GPU compute stream to use to launch the custom a GPU kernel
   *   @see ::OrtCustomOp
   * @param context [in] OrtKernelContext instance
   * @param out [out] Returns pointer to a GPU compute stream that can be used to launch the custom GPU kernel.
   *             If retrieving the GPU compute stream is not relevant (GPU not enabled in the build, kernel partitioned to
   *             some other EP), then a nullptr is returned as the output param.
   *             Do not free or mutate the returned pointer as it refers to internal data owned by the underlying session.
   *             Only use it for custom kernel launching.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus KernelContext_GetGPUComputeStream( @Const OrtKernelContext context, @Cast("void**") PointerPointer out);
  public native OrtStatus KernelContext_GetGPUComputeStream( @Const OrtKernelContext context, @Cast("void**") @ByPtrPtr Pointer out);

  /** \}
   *  \name GetTensorMemoryInfo
   *  \{
  /** \brief Returns a pointer to the ::OrtMemoryInfo of a Tensor
   * @param value [in] ::OrtValue containing tensor.
   * @param mem_info [out] ::OrtMemoryInfo of the tensor. Do NOT free the returned pointer. It is valid for the lifetime of the ::OrtValue
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetTensorMemoryInfo( @Const OrtValue value, @Cast("const OrtMemoryInfo**") PointerPointer mem_info);
  public native OrtStatus GetTensorMemoryInfo( @Const OrtValue value, @Const @ByPtrPtr OrtMemoryInfo mem_info);

  /** \}
   *  \name GetExecutionProviderApi
   *  \{
  /** \brief Get a pointer to the requested version of the Execution Provider specific
   * API extensions to the OrtApi
   * @param provider_name [in] The name of the execution provider name. Currently only the following
   * values are supported: "DML".
   * @param version [in] Must be ::ORT_API_VERSION.
   * @param provider_api [out] A void pointer containing a reference to the execution provider versioned api structure.
   * For example, the provider_api pointer can be cast to the OrtDmlApi* when the provider_name is "DML".
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetExecutionProviderApi( @Cast("const char*") BytePointer provider_name, @Cast("uint32_t") int version, @Cast("const void**") PointerPointer provider_api);
  public native OrtStatus GetExecutionProviderApi( @Cast("const char*") BytePointer provider_name, @Cast("uint32_t") int version, @Cast("const void**") @ByPtrPtr Pointer provider_api);
  public native OrtStatus GetExecutionProviderApi( String provider_name, @Cast("uint32_t") int version, @Cast("const void**") @ByPtrPtr Pointer provider_api);

  /** \}
   <p>
   *  \name SessionOptions
   *  \{
  /** \brief Set custom thread creation function
   *
   * @param options [in] Session options
   * @param ort_custom_create_thread_fn [in] Custom thread creation function
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionOptionsSetCustomCreateThreadFn( OrtSessionOptions options, OrtCustomCreateThreadFn ort_custom_create_thread_fn);

  /** \brief Set creation options for custom thread
   *
   * @param options [in] Session options
   * @param ort_custom_thread_creation_options [in] Custom thread creation options (can be nullptr)
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionOptionsSetCustomThreadCreationOptions( OrtSessionOptions options, Pointer ort_custom_thread_creation_options);

  /** \brief Set custom thread join function
   *
   * @param options [in] Session options
   * @param ort_custom_join_thread_fn [in] Custom join thread function, must not be nullptr when ort_custom_create_thread_fn is set
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SessionOptionsSetCustomJoinThreadFn( OrtSessionOptions options, OrtCustomJoinThreadFn ort_custom_join_thread_fn);
  /** \}
   <p>
   *  \name OrtThreadingOptions
   *  \{
  /** \brief Set custom thread creation function for global thread pools
   *
   * @param tp_options [inout]
   * @param ort_custom_create_thread_fn [in] Custom thread creation function
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetGlobalCustomCreateThreadFn( OrtThreadingOptions tp_options, OrtCustomCreateThreadFn ort_custom_create_thread_fn);

  /** \brief Set custom thread creation options for global thread pools
   *
   * @param tp_options [inout]
   * @param ort_custom_thread_creation_options [in] Custom thread creation options (can be nullptr)
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetGlobalCustomThreadCreationOptions( OrtThreadingOptions tp_options, Pointer ort_custom_thread_creation_options);

  /** \brief Set custom thread join function for global thread pools
   *
   * @param tp_options [inout]
   * @param ort_custom_join_thread_fn [in] Custom thread join function, must not be nullptr when global ort_custom_create_thread_fn is set
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SetGlobalCustomJoinThreadFn( OrtThreadingOptions tp_options, OrtCustomJoinThreadFn ort_custom_join_thread_fn);
  /** \}
  <p>
  /** \brief Synchronize bound inputs. The call may be necessary for some providers, such as cuda,
   *   in case the system that allocated bound memory operated on a different stream. However, the
   *   operation is provider specific and could be a no-op.
   *
   * @param binding_ptr [inout]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SynchronizeBoundInputs( OrtIoBinding binding_ptr);

  /** \brief Synchronize bound outputs. The call may be necessary for some providers, such as cuda,
   *   in case the system that allocated bound memory operated on a different stream. However, the
   *   operation is provider specific and could be a no-op.
   *
   * @param binding_ptr [inout]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus SynchronizeBoundOutputs( OrtIoBinding binding_ptr);

  /** \name OrtSessionOptions
   *  \{
  <p>
  /** \brief Append CUDA execution provider to the session options
   *
   * If CUDA is not available (due to a non CUDA enabled build), this function will return failure.
   *
   * This is slightly different from OrtApi::SessionOptionsAppendExecutionProvider_CUDA, it takes an
   * ::OrtCUDAProviderOptions which is publicly defined. This takes an opaque ::OrtCUDAProviderOptionsV2
   * which must be created with OrtApi::CreateCUDAProviderOptions.
   *
   * For OrtApi::SessionOptionsAppendExecutionProvider_CUDA, the user needs to instantiate ::OrtCUDAProviderOptions
   * as well as allocate/release buffers for some members of ::OrtCUDAProviderOptions.
   * Here, OrtApi::CreateCUDAProviderOptions and Ortapi::ReleaseCUDAProviderOptions will do the memory management for you.
   *
   * @param options [in]
   * @param cuda_options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.11.
   */
  public native OrtStatus SessionOptionsAppendExecutionProvider_CUDA_V2(
                    OrtSessionOptions options, @Const OrtCUDAProviderOptionsV2 cuda_options);

  /** \}
   *  \name OrtCUDAProviderOptionsV2
   *  \{
  <p>
  /** \brief Create an OrtCUDAProviderOptionsV2
   *
   * @param out [out] Newly created ::OrtCUDAProviderOptionsV2. Must be released with OrtApi::ReleaseCudaProviderOptions
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.11.
   */
  public native OrtStatus CreateCUDAProviderOptions( @Cast("OrtCUDAProviderOptionsV2**") PointerPointer out);
  public native OrtStatus CreateCUDAProviderOptions( @ByPtrPtr OrtCUDAProviderOptionsV2 out);

  /** \brief Set options in a CUDA Execution Provider.
   *
   * Please refer to https://onnxruntime.ai/docs/execution-providers/CUDA-ExecutionProvider.html#configuration-options
   * to know the available keys and values. Key should be in null terminated string format of the member of ::OrtCUDAProviderOptionsV2
   * and value should be its related range. Recreates the options and only sets the supplied values.
   *
   * For example, key="device_id" and value="0"
   *
   * @param cuda_options [in]
   * @param provider_options_keys [in] Array of UTF-8 null-terminated string for provider options keys
   * @param provider_options_values [in] Array of UTF-8 null-terminated string for provider options values
   * @param num_keys [in] Number of elements in the {@code provider_option_keys} and {@code provider_options_values} arrays
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.11.
   */
  public native OrtStatus UpdateCUDAProviderOptions( OrtCUDAProviderOptionsV2 cuda_options,
                    @Cast("const char*const*") PointerPointer provider_options_keys,
                    @Cast("const char*const*") PointerPointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateCUDAProviderOptions( OrtCUDAProviderOptionsV2 cuda_options,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateCUDAProviderOptions( OrtCUDAProviderOptionsV2 cuda_options,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateCUDAProviderOptions( OrtCUDAProviderOptionsV2 cuda_options,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_values,
                    @Cast("size_t") long num_keys);

  /**
   * Get serialized CUDA provider options string.
   *
   * For example, "device_id=0;arena_extend_strategy=0;......"
   *
   * @param cuda_options - OrtCUDAProviderOptionsV2 instance
   * @param allocator - a ptr to an instance of OrtAllocator obtained with CreateAllocator() or GetAllocatorWithDefaultOptions()
   *                      the specified allocator will be used to allocate continuous buffers for output strings and lengths.
   * @param ptr - is a UTF-8 null terminated string allocated using 'allocator'. The caller is responsible for using the same allocator to free it.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.11.
   */
  public native OrtStatus GetCUDAProviderOptionsAsString( @Const OrtCUDAProviderOptionsV2 cuda_options, OrtAllocator allocator, @Cast("char**") PointerPointer ptr);
  public native OrtStatus GetCUDAProviderOptionsAsString( @Const OrtCUDAProviderOptionsV2 cuda_options, OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer ptr);
  public native OrtStatus GetCUDAProviderOptionsAsString( @Const OrtCUDAProviderOptionsV2 cuda_options, OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer ptr);
  public native OrtStatus GetCUDAProviderOptionsAsString( @Const OrtCUDAProviderOptionsV2 cuda_options, OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] ptr);

  /** \brief Release an ::OrtCUDAProviderOptionsV2
   *
   * \note This is an exception in the naming convention of other Release* functions, as the name of the method does not have the V2 suffix, but the type does
   *
   * @since Version 1.11.
   */
  public static class ReleaseCUDAProviderOptions_OrtCUDAProviderOptionsV2 extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    ReleaseCUDAProviderOptions_OrtCUDAProviderOptionsV2(Pointer p) { super(p); }
      protected ReleaseCUDAProviderOptions_OrtCUDAProviderOptionsV2() { allocate(); }
      private native void allocate();
      public native void call(OrtCUDAProviderOptionsV2 input);
  }
  public native ReleaseCUDAProviderOptions_OrtCUDAProviderOptionsV2 ReleaseCUDAProviderOptions(); public native OrtApi ReleaseCUDAProviderOptions(ReleaseCUDAProviderOptions_OrtCUDAProviderOptionsV2 setter);

  /** \}
  <p>
  /** \brief Append MIGraphX provider to session options
   *
   * If MIGraphX is not available (due to a non MIGraphX enabled build, or if MIGraphX is not installed on the system), this function will return failure.
   *
   * @param options [in]
   * @param migraphx_options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.11.
   */
  public native OrtStatus SessionOptionsAppendExecutionProvider_MIGraphX(
                    OrtSessionOptions options, @Const OrtMIGraphXProviderOptions migraphx_options);

  /** \brief Replace initialized Tensors with external data with the data provided in initializers.
   *
   * The function will find the initialized TensorProtos with external data in the graph with the provided names and
   * replace them with the provided tensors. The API verifies that the TensorProto being replaced
   * has an external data reference and has the same name, dimensions and data type as its replacement. The replacement
   * will occur before any of the optimizations take place. The data will be copied into the graph
   * since TensorProto can't refer to the user provided buffers.
   *
   * Once the model has been loaded, the OrtValue(s) added to SessionOptions instance will be removed
   * from the internal SessionOptions copy to save memory, the user provided buffers can then be deallocated
   * and the SessionOptions instance that refers to them can be destroyed.
   *
   * @param options [in]
   * @param initializer_names [in] Array of null terminated UTF-8 encoded strings of the initializers names.
   * @param initializers [in] Array of ::OrtValue type
   * @param num_initializers [in] Number of elements in the initializer_names and initializers
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.12.
   */
  public native OrtStatus AddExternalInitializers( OrtSessionOptions options,
                    @Cast("const char*const*") PointerPointer initializer_names,
                    @Cast("const OrtValue*const*") PointerPointer initializers, @Cast("size_t") long num_initializers);
  public native OrtStatus AddExternalInitializers( OrtSessionOptions options,
                    @Cast("const char*const*") @ByPtrPtr BytePointer initializer_names,
                    @Const @ByPtrPtr OrtValue initializers, @Cast("size_t") long num_initializers);
  public native OrtStatus AddExternalInitializers( OrtSessionOptions options,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer initializer_names,
                    @Const @ByPtrPtr OrtValue initializers, @Cast("size_t") long num_initializers);
  public native OrtStatus AddExternalInitializers( OrtSessionOptions options,
                    @Cast("const char*const*") @ByPtrPtr byte[] initializer_names,
                    @Const @ByPtrPtr OrtValue initializers, @Cast("size_t") long num_initializers);

  /** \brief: Create attribute of onnxruntime operator
   *
   * @param name [in] Name of the attribute
   * @param data [in] Data content of the attribute
   * @param len [in] Number of bytes stored in data for ORT_OP_ATTR_STRING.
                    Number of elements if data represents an array (e.g., ORT_OP_ATTR_INTS). Otherwise, set to 1.
   * @param type [in] Data type
   * @param op_attr [out] Attribute that has been created, which must be released by OrtApi::ReleaseOpAttr
   *
   * @since Version 1.12.
   */
  public native OrtStatus CreateOpAttr(
                    @Cast("const char*") BytePointer name,
                    @Const Pointer data,
                    int len,
                    @Cast("OrtOpAttrType") int type,
                    @Cast("OrtOpAttr**") PointerPointer op_attr);
  public native OrtStatus CreateOpAttr(
                    @Cast("const char*") BytePointer name,
                    @Const Pointer data,
                    int len,
                    @Cast("OrtOpAttrType") int type,
                    @ByPtrPtr OrtOpAttr op_attr);
  public native OrtStatus CreateOpAttr(
                    String name,
                    @Const Pointer data,
                    int len,
                    @Cast("OrtOpAttrType") int type,
                    @ByPtrPtr OrtOpAttr op_attr);

  /* \brief: Release op attribute
   *
   * \param[in] opAttr Attribute created by OrtApi::CreateOpAttr
   *
   * \since Version 1.12.
   */
  public native void ReleaseOpAttr(OrtOpAttr input);

  /** \brief: Create onnxruntime native operator
   *
   * @param info [in] Kernel info
   * @param op_name [in] Operator name
   * @param domain [in] Operator domain
   * @param version [in] Operator opset version
   * @param type_constraint_names [in] Name of the type constraints, such as "T" or "T1"
   * @param type_constraint_values [in] Type of each constraints
   * @param type_constraint_count [in] Number of constraints
   * @param attr_values [in] Attributes used to initialize the operator
   * @param attr_count [in] Number of the attributes
   * @param input_count [in] Number of inputs
   * @param output_count [in] Number of outputs
   * @param ort_op [out] Operator that has been created
   *
   * @since Version 1.12.
   */
  public native OrtStatus CreateOp(
                    @Const OrtKernelInfo info,
                    @Cast("const char*") BytePointer op_name,
                    @Cast("const char*") BytePointer domain,
                    int version,
                    @Cast("const char**") PointerPointer type_constraint_names,
                    @Cast("const ONNXTensorElementDataType*") IntPointer type_constraint_values,
                    int type_constraint_count,
                    @Cast("const OrtOpAttr*const*") PointerPointer attr_values,
                    int attr_count,
                    int input_count,
                    int output_count,
                    @Cast("OrtOp**") PointerPointer ort_op);
  public native OrtStatus CreateOp(
                    @Const OrtKernelInfo info,
                    @Cast("const char*") BytePointer op_name,
                    @Cast("const char*") BytePointer domain,
                    int version,
                    @Cast("const char**") @ByPtrPtr BytePointer type_constraint_names,
                    @Cast("const ONNXTensorElementDataType*") IntPointer type_constraint_values,
                    int type_constraint_count,
                    @Const @ByPtrPtr OrtOpAttr attr_values,
                    int attr_count,
                    int input_count,
                    int output_count,
                    @ByPtrPtr OrtOp ort_op);
  public native OrtStatus CreateOp(
                    @Const OrtKernelInfo info,
                    String op_name,
                    String domain,
                    int version,
                    @Cast("const char**") @ByPtrPtr ByteBuffer type_constraint_names,
                    @Cast("const ONNXTensorElementDataType*") IntBuffer type_constraint_values,
                    int type_constraint_count,
                    @Const @ByPtrPtr OrtOpAttr attr_values,
                    int attr_count,
                    int input_count,
                    int output_count,
                    @ByPtrPtr OrtOp ort_op);
  public native OrtStatus CreateOp(
                    @Const OrtKernelInfo info,
                    @Cast("const char*") BytePointer op_name,
                    @Cast("const char*") BytePointer domain,
                    int version,
                    @Cast("const char**") @ByPtrPtr byte[] type_constraint_names,
                    @Cast("const ONNXTensorElementDataType*") int[] type_constraint_values,
                    int type_constraint_count,
                    @Const @ByPtrPtr OrtOpAttr attr_values,
                    int attr_count,
                    int input_count,
                    int output_count,
                    @ByPtrPtr OrtOp ort_op);
  public native OrtStatus CreateOp(
                    @Const OrtKernelInfo info,
                    String op_name,
                    String domain,
                    int version,
                    @Cast("const char**") @ByPtrPtr BytePointer type_constraint_names,
                    @Cast("const ONNXTensorElementDataType*") IntPointer type_constraint_values,
                    int type_constraint_count,
                    @Const @ByPtrPtr OrtOpAttr attr_values,
                    int attr_count,
                    int input_count,
                    int output_count,
                    @ByPtrPtr OrtOp ort_op);
  public native OrtStatus CreateOp(
                    @Const OrtKernelInfo info,
                    @Cast("const char*") BytePointer op_name,
                    @Cast("const char*") BytePointer domain,
                    int version,
                    @Cast("const char**") @ByPtrPtr ByteBuffer type_constraint_names,
                    @Cast("const ONNXTensorElementDataType*") IntBuffer type_constraint_values,
                    int type_constraint_count,
                    @Const @ByPtrPtr OrtOpAttr attr_values,
                    int attr_count,
                    int input_count,
                    int output_count,
                    @ByPtrPtr OrtOp ort_op);
  public native OrtStatus CreateOp(
                    @Const OrtKernelInfo info,
                    String op_name,
                    String domain,
                    int version,
                    @Cast("const char**") @ByPtrPtr byte[] type_constraint_names,
                    @Cast("const ONNXTensorElementDataType*") int[] type_constraint_values,
                    int type_constraint_count,
                    @Const @ByPtrPtr OrtOpAttr attr_values,
                    int attr_count,
                    int input_count,
                    int output_count,
                    @ByPtrPtr OrtOp ort_op);

  /** \brief: Invoke the operator created by OrtApi::CreateOp
   * The inputs must follow the order as specified in onnx specification
   *
   * @param context [in] Kernel context
   * @param ort_op [in] Operator that has been created
   * @param input_values [in] Array of inputs
   * @param input_count [in] Number of inputs
   * @param output_values [in] Array of outputs
   * @param output_count [in] Number of outputs
   *
   * @since Version 1.12.
   */
  public native OrtStatus InvokeOp(
                    @Const OrtKernelContext context,
                    @Const OrtOp ort_op,
                    @Cast("const OrtValue*const*") PointerPointer input_values,
                    int input_count,
                    @Cast("OrtValue*const*") PointerPointer output_values,
                    int output_count);
  public native OrtStatus InvokeOp(
                    @Const OrtKernelContext context,
                    @Const OrtOp ort_op,
                    @Const @ByPtrPtr OrtValue input_values,
                    int input_count,
                    @ByPtrPtr OrtValue output_values,
                    int output_count);

  /* \brief: Release an onnxruntime operator
   *
   * \param[in] Op Operator created by OrtApi::CreateOp
   *
   * \since Version 1.12.
   */
  public native void ReleaseOp(OrtOp input);

  /** \brief: Append execution provider to the session options.
   * @param options [in]
   * @param provider_name [in] - provider to add.
   * @param provider_options_keys [in] - keys to configure the provider options
   * @param provider_options_values [in] - values to configure the provider options
   * @param num_keys [in] - number of keys passed in
   *
   * Currently supported provider names:
   *   QNNExecutionProvider (or QNN)
   *   OpenVINOExecutionProvider (or OpenVINO)
   *   XnnpackExecutionProvider (or XNNPACK)
   *   WebNNExecutionProvider (or WEBNN)
   *   WebGpuExecutionProvider (or WebGPU)
   *   AzureExecutionProvider (or AZURE)
   *   JsExecutionProvider (or JS)
   *   VitisAIExecutionProvider (or VitisAI)
   *   CoreMLExecutionProvider (or CoreML)
   *
   * Note: If an execution provider has a dedicated SessionOptionsAppendExecutionProvider_<provider name> function
   *       that should be used to add it.
   *
   * QNN supported keys:
   *   "backend_type": Type of QNN backend. Specifies a backend path that is the associated QNN backend library file
   *      name. E.g., given backend type "htp", on Windows, the backend path would be "QnnHtp.dll", and on other
   *      platforms, it would be "libQnnHtp.so". Mutually exclusive with "backend_path".
   *      Available options:
   *      -# "cpu"
   *      -# "gpu"
   *      -# "htp": Default.
   *      -# "saver"
   *      -# "ir"
   *   "backend_path": File path to QNN backend library. Mutually exclusive with "backend_type".
   *   "profiling_level": QNN profiling level.
   *      Available options:
   *      -# "off": Default.
   *      -# "basic"
   *      -# "detailed"
   *   "profiling_file_path": QNN profiling file path if ETW not enabled.
   *   "rpc_control_latency": QNN RPC control latency.
   *   "vtcm_mb": QNN VTCM size in MB. default to 0(not set).
   *   "htp_performance_mode": QNN performance mode.
   *      Available options:
   *      -# "burst"
   *      -# "balanced"
   *      -# "default": Default.
   *      -# "high_performance"
   *      -# "high_power_saver"
   *      -# "low_balanced"
   *      -# "extreme_power_saver"
   *      -# "low_power_saver"
   *      -# "power_saver"
   *      -# "sustained_high_performance"
   *   "dump_qnn_ir_dlc": Use the QnnIr backend library to write .dlc files for each subgraph dispatched to QNN. When
   *       enabled, inference results will be incorrect. Use only for debugging.
   *      -# "0": Default: disabled
   *      -# "1": enabled
   *   "dump_qnn_ir_dlc_dir": Set the directory into which QnnIr will be configured to write QNN graphs as .dlc files.
   *      Default is current working directory.
   *   "qnn_ir_backend_path": File path to the QnnIr backend library. If "dump_qnn_ir_dlc" is enabled, use this path
   *      instead of looking for the Ir backend in the standard location.
   *   "qnn_saver_path": File path to the QNN Saver backend library. If specified, QNN Saver will be enabled and will
   *      dump QNN API calls to disk for replay/debugging. QNN Saver produces incorrect model inference results and
   *      may alter model/EP partitioning. Use only for debugging.
   *   "qnn_context_priority": QNN context priority.
   *      Available options:
   *      -# "low"
   *      -# "normal": Default.
   *      -# "normal_high"
   *      -# "high"
   *   "htp_graph_finalization_optimization_mode": Set the optimization mode for graph finalization on the HTP backend.
   *      Available options:
   *      -# "0": Default.
   *      -# "1": Faster preparation time, less optimal graph.
   *      -# "2": Longer preparation time, more optimal graph.
   *      -# "3": Longest preparation time, most likely even more optimal graph. See QNN SDK documentation for specific
   *        details.
   *   "soc_model": The SoC model number. Refer to the QNN SDK documentation for valid values.
   *      Defaults to "0" (unknown).
   *   "htp_arch": The minimum HTP architecture the driver will use to select compatible QNN operators.
   *      Available options:
   *      -# "0": Default (none).
   *      -# "68"
   *      -# "69"
   *      -# "73"
   *      -# "75"
   *   "device_id": The ID of the device to use when setting 'htp_arch'. Defaults to "0" (for single device).
   *   "enable_htp_fp16_precision": Used for float32 model for HTP backend.
   *      Enable the float32 model to be inferenced with fp16 precision. Otherwise, it will be fp32 precision.
   *      -# "0": With fp32 precision.
   *      -# "1": Default. With fp16 precision.
   *   "offload_graph_io_quantization": Offload graph input quantization and graph output dequantization to another
   *      execution provider (typically CPU EP).
   *      -# "0": Disabled. QNN EP will handle quantization and dequantization of graph I/O.
   *      -# "1": Enabled. This is the default value.
   *   "enable_htp_spill_fill_buffer": Enable HTP spill fill buffer setting. The flag is used while generating context
   *      binary.
   *      -# "0": Default. Disabled.
   *      -# "1": Enabled.
   *   "enable_htp_shared_memory_allocator": Enable the QNN HTP shared memory allocator. Requires libcdsprpc.so/dll to
   *      be available.
   *      -# "0": Default. Disabled.
   *      -# "1": Enabled.
   *   "dump_json_qnn_graph": Set to "1" to dump QNN graphs generated by QNN EP as JSON files. Each graph partition
   *      assigned to QNN EP is dumped to a separate file.
   *   "json_qnn_graph_dir": Directory in which to dump QNN JSON graphs. If not specified, QNN graphs are dumped in the
   *      program's current working directory. Ignored if "dump_json_qnn_graph" is not set.
   *   "op_packages": QNN UDO op_package for QNN EP, allowed format:
   *     "<op_type>:<op_package_path>:<interface>[:<target>],<op_type2>:<op_package_path2>:<interface2>[:<target>]",
   *     where op_type is the name of the operation, op_package_path is the path to the op package shared library,
   *     interface is the symbol name to register the op life cycle functions, and target is the backend type. For more
   *     details, refer to: https://docs.qualcomm.com/bundle/publicresource/topics/80-63442-50/op_packages.html
   *
   * XNNPACK supported keys:
   *   "intra_op_num_threads": number of thread-pool size to use for XNNPACK execution provider.
   *      default value is 0, which means to use the session thread-pool size.
   *
   * @since Version 1.12.
   */
  public native OrtStatus SessionOptionsAppendExecutionProvider( OrtSessionOptions options,
                    @Cast("const char*") BytePointer provider_name,
                    @Cast("const char*const*") PointerPointer provider_options_keys,
                    @Cast("const char*const*") PointerPointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus SessionOptionsAppendExecutionProvider( OrtSessionOptions options,
                    @Cast("const char*") BytePointer provider_name,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus SessionOptionsAppendExecutionProvider( OrtSessionOptions options,
                    String provider_name,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus SessionOptionsAppendExecutionProvider( OrtSessionOptions options,
                    @Cast("const char*") BytePointer provider_name,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus SessionOptionsAppendExecutionProvider( OrtSessionOptions options,
                    String provider_name,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus SessionOptionsAppendExecutionProvider( OrtSessionOptions options,
                    @Cast("const char*") BytePointer provider_name,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus SessionOptionsAppendExecutionProvider( OrtSessionOptions options,
                    String provider_name,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_values,
                    @Cast("size_t") long num_keys);

  /* \brief: Get a copy of kernel info
   *
   * \param[in] info Kernel info
   * \param[out] info_copy Copy of kernel info
   *
   * \since Version 1.12.
   */
  public native OrtStatus CopyKernelInfo(
                    @Const OrtKernelInfo info,
                    @Cast("OrtKernelInfo**") PointerPointer info_copy);
  public native OrtStatus CopyKernelInfo(
                    @Const OrtKernelInfo info,
                    @ByPtrPtr OrtKernelInfo info_copy);

  /* \brief: Release kernel info
   *
   * \param[in] KernelInfo A copy of kernel info returned by CopyKernelInfo
   *
   * \since Version 1.12.
   */
  public native void ReleaseKernelInfo(OrtKernelInfo input);

  /** \name Ort Training
   *  \{
  /** \brief Gets the Training C Api struct
   *
   * Call this function to access the ::OrtTrainingApi structure that holds pointers to functions that enable
   * training with onnxruntime.
   * \note A NULL pointer will be returned and no error message will be printed if the training api
   * is not supported with this build. A NULL pointer will be returned and an error message will be
   * printed if the provided version is unsupported, for example when using a runtime older than the
   * version created with this header file.
   *
   * @param version [in] Must be ::ORT_API_VERSION
   * @return The ::OrtTrainingApi struct for the version requested.
   *
   * @since Version 1.13
   */
  public static class GetTrainingApi_int extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    GetTrainingApi_int(Pointer p) { super(p); }
      protected GetTrainingApi_int() { allocate(); }
      private native void allocate();
      public native @Const OrtTrainingApi call(@Cast("uint32_t") int version);
  }
  public native GetTrainingApi_int GetTrainingApi(); public native OrtApi GetTrainingApi(GetTrainingApi_int setter);

  /** \}
  <p>
  /** \brief Append CANN provider to session options
   *
   * If CANN is not available (due to a non CANN enabled build, or if CANN is not installed on the system), this function will return failure.
   *
   * @param options [in]
   * @param cann_options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.13.
   */
  public native OrtStatus SessionOptionsAppendExecutionProvider_CANN(
                    OrtSessionOptions options, @Const OrtCANNProviderOptions cann_options);

  /** \brief Create an OrtCANNProviderOptions
   *
   * @param out [out] created ::OrtCANNProviderOptions. Must be released with OrtApi::ReleaseCANNProviderOptions
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.13.
   */
  public native OrtStatus CreateCANNProviderOptions( @Cast("OrtCANNProviderOptions**") PointerPointer out);
  public native OrtStatus CreateCANNProviderOptions( @ByPtrPtr OrtCANNProviderOptions out);

  /** \brief Set options in a CANN Execution Provider.
   *
   * @param cann_options [in]
   * @param provider_options_keys [in] Array of UTF-8 null-terminated string for provider options keys
   * @param provider_options_values [in] Array of UTF-8 null-terminated string for provider options values
   * @param num_keys [in] Number of elements in the {@code provider_option_keys} and {@code provider_options_values} arrays
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.13.
   */
  public native OrtStatus UpdateCANNProviderOptions( OrtCANNProviderOptions cann_options,
                    @Cast("const char*const*") PointerPointer provider_options_keys,
                    @Cast("const char*const*") PointerPointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateCANNProviderOptions( OrtCANNProviderOptions cann_options,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateCANNProviderOptions( OrtCANNProviderOptions cann_options,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateCANNProviderOptions( OrtCANNProviderOptions cann_options,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_values,
                    @Cast("size_t") long num_keys);

  /** \brief Get serialized CANN provider options string.
   *
   * @param cann_options [in] OrtCANNProviderOptions instance
   * @param allocator [in] a ptr to an instance of OrtAllocator obtained with CreateAllocator()
   *                      or GetAllocatorWithDefaultOptions(), the specified allocator will be used to allocate
   *                      continuous buffers for output strings and lengths.
   * @param ptr [out] is a UTF-8 null terminated string allocated using 'allocator'.
   *                 The caller is responsible for using the same allocator to free it.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.13.
   */
  public native OrtStatus GetCANNProviderOptionsAsString( @Const OrtCANNProviderOptions cann_options,
                    OrtAllocator allocator, @Cast("char**") PointerPointer ptr);
  public native OrtStatus GetCANNProviderOptionsAsString( @Const OrtCANNProviderOptions cann_options,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer ptr);
  public native OrtStatus GetCANNProviderOptionsAsString( @Const OrtCANNProviderOptions cann_options,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer ptr);
  public native OrtStatus GetCANNProviderOptionsAsString( @Const OrtCANNProviderOptions cann_options,
                    OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] ptr);

  /** \brief Release an OrtCANNProviderOptions
   *
   * @param input [in] The pointer of OrtCANNProviderOptions which will been deleted
   *
   * @since Version 1.13.
   */
  public static class ReleaseCANNProviderOptions_OrtCANNProviderOptions extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    ReleaseCANNProviderOptions_OrtCANNProviderOptions(Pointer p) { super(p); }
      protected ReleaseCANNProviderOptions_OrtCANNProviderOptions() { allocate(); }
      private native void allocate();
      public native void call(OrtCANNProviderOptions input);
  }
  public native ReleaseCANNProviderOptions_OrtCANNProviderOptions ReleaseCANNProviderOptions(); public native OrtApi ReleaseCANNProviderOptions(ReleaseCANNProviderOptions_OrtCANNProviderOptions setter);

  /*  \brief Get OrtDevice type from MemoryInfo
   *
   *  \since Version 1.14
   */
  public static class MemoryInfoGetDeviceType_OrtMemoryInfo_IntPointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    MemoryInfoGetDeviceType_OrtMemoryInfo_IntPointer(Pointer p) { super(p); }
      protected MemoryInfoGetDeviceType_OrtMemoryInfo_IntPointer() { allocate(); }
      private native void allocate();
      public native void call(@Const OrtMemoryInfo ptr, @Cast("OrtMemoryInfoDeviceType*") IntPointer out);
  }
  public native MemoryInfoGetDeviceType_OrtMemoryInfo_IntPointer MemoryInfoGetDeviceType(); public native OrtApi MemoryInfoGetDeviceType(MemoryInfoGetDeviceType_OrtMemoryInfo_IntPointer setter);

  /* \brief Update the OrtEnv instance with custom log severity level
   *
   * \param[in] ort_env The OrtEnv instance being used
   * \param[in] log_severity_level The log severity level.
   *
   * \since Version 1.14.
   */
  public native OrtStatus UpdateEnvWithCustomLogLevel( OrtEnv ort_env, @Cast("OrtLoggingLevel") int log_severity_level);

  /*  \brief Set affinities for intra op threads
   *
   * Affinity string follows format:
   * logical_processor_id,logical_processor_id;logical_processor_id,logical_processor_id
   * Semicolon isolates configurations among threads, while comma split processors where ith thread expected to attach to.
   * e.g. 1,2,3;4,5
   * specifies affinities for two threads, with the 1st thread attach to the 1st, 2nd, and 3rd processor, and 2nd thread to the 4th and 5th.
   * To ease the configuration, an "interval" is also allowed:
   * e.g. 1-8;8-16;17-24
   * orders that the 1st thread runs on first eight processors, 2nd thread runs on next eight processors, and so forth.
   * Note:
   * 1. Once set, the number of thread affinities must equal to intra_op_num_threads - 1,
   *    ort does not set affinity on the main thread which is started and managed by the calling app;
   * 2. For windows, ort will infer the group id from a logical processor id, for example, assuming there are two groups with each has 64 logical processors,
   *    an id of 64 will be inferred as the last processor of the 1st group, while 65 will be interpreted as the 1st processor of the second group.
   *    Hence 64-65 is an invalid configuration, because a windows thread cannot be attached to processors across group boundary.
   *
   *  \since Version 1.14
   */
  public native OrtStatus SetGlobalIntraOpThreadAffinity( OrtThreadingOptions tp_options, @Cast("const char*") BytePointer affinity_string);
  public native OrtStatus SetGlobalIntraOpThreadAffinity( OrtThreadingOptions tp_options, String affinity_string);

  /** \brief Register custom ops from a shared library.
   *
   * Loads a shared library (.dll on windows, .so on linux, etc) named 'library_name' and looks for this entry point:
   *		OrtStatus* RegisterCustomOps(OrtSessionOptions * options, const OrtApiBase* api);
   * It then passes in the provided session options to this function along with the api base.
   *
   * The handle to the loaded library is automatically released by ORT when the last OrtSession that references the
   * library handle is released. If no OrtSession is created, then the library handle is released when the provided
   * OrtSessionOptions is released.
   *
   * @param options [in] The session options.
   * @param library_name [in] The name of the shared library to load and register. Refer to OS-specific dynamic library
   *                         loading utilities (e.g., LoadLibraryEx on Windows or dlopen on Linux/MacOS) for information
   *                         on the format of library names and search paths.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.14
   */
  public native OrtStatus RegisterCustomOpsLibrary_V2( OrtSessionOptions options, @Cast("const ORTCHAR_T*") Pointer library_name);

  /** \brief Register custom ops by calling a RegisterCustomOpsFn function.
   *
   * Searches for registration_func_name and if found calls it.
   *
   * The library containing the function must either be linked against or previously loaded by the executable.
   *
   * If you want ONNX Runtime to load the library and manage its lifetime, use RegisterCustomOpsLibrary_V2.
   *
   * RegisterCustomOpsUsingFunction can be used in scenarios where it may not be possible for ONNX Runtime to load
   * the library from a path. e.g. mobile platforms where the library must be linked into the app.
   *
   * The registration function must have the signature of RegisterCustomOpsFn:
   *    OrtStatus* (*fn)(OrtSessionOptions* options, const OrtApiBase* api);
   *
   * See https://onnxruntime.ai/docs/reference/operators/add-custom-op.html for details on how the registration
   * function should be implemented.
   *
   * @param options [in] OrtSessionOptions that is passed through as the first argument in the call to the
   *                    registration function.
   * @param registration_func_name [in] Name of registration function to use.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.14
   */
  public native OrtStatus RegisterCustomOpsUsingFunction( OrtSessionOptions options,
                    @Cast("const char*") BytePointer registration_func_name);
  public native OrtStatus RegisterCustomOpsUsingFunction( OrtSessionOptions options,
                    String registration_func_name);

  /** \name OrtKernelInfo
   *  Custom operator APIs.
   *  \{
  <p>
  /** \brief Get the number of inputs from ::OrtKernelInfo.
   *
   * Used in the CreateKernel callback of an OrtCustomOp to query the number of inputs
   * during kernel/session creation.
   *
   * @param info [in] Instance of ::OrtKernelInfo.
   * @param out [out] Pointer to variable assigned with the result on success.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.14
   */
  public native OrtStatus KernelInfo_GetInputCount( @Const OrtKernelInfo info, @Cast("size_t*") SizeTPointer out);

  /** \brief Get the number of outputs from ::OrtKernelInfo.
   *
   * Used in the CreateKernel callback of an OrtCustomOp to query the number of outputs
   * during kernel/session creation.
   *
   * @param info [in] Instance of ::OrtKernelInfo.
   * @param out [out] Pointer to variable assigned with the result on success.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.14
   */
  public native OrtStatus KernelInfo_GetOutputCount( @Const OrtKernelInfo info, @Cast("size_t*") SizeTPointer out);

  /** \brief Get the name of a ::OrtKernelInfo's input.
   *
   * Used in the CreateKernel callback of an OrtCustomOp to query an input's name
   * during kernel/session creation.
   *
   * If {@code out} is nullptr, the value of {@code size} is set to the size of the name
   * string (including null-terminator), and a success status is returned.
   *
   * If the {@code size} parameter is greater than or equal to the name string's size,
   * the value of {@code size} is set to the true size of the string (including null-terminator),
   * the provided memory is filled with the string's contents, and a success status is returned.
   *
   * If the {@code size} parameter is less than the actual string's size and {@code out}
   * is not nullptr, the value of {@code size} is set to the true size of the string
   * and a failure status is returned.
   *
   * @param info [in] An instance of ::OrtKernelInfo.
   * @param index [in] The index of the input name to get. Returns a failure status if out-of-bounds.
   * @param out [out] Memory location into which to write the UTF-8 null-terminated string representing the input's name.
   * @param size [in,out] Pointer to the size of the {@code out} buffer. See above comments for details.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.14
   */
  public native OrtStatus KernelInfo_GetInputName( @Const OrtKernelInfo info, @Cast("size_t") long index, @Cast("char*") BytePointer out,
                    @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfo_GetInputName( @Const OrtKernelInfo info, @Cast("size_t") long index, @Cast("char*") ByteBuffer out,
                    @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfo_GetInputName( @Const OrtKernelInfo info, @Cast("size_t") long index, @Cast("char*") byte[] out,
                    @Cast("size_t*") SizeTPointer size);

  /** \brief Get the name of a ::OrtKernelInfo's output.
   *
   * Used in the CreateKernel callback of an OrtCustomOp to query an output's name
   * during kernel/session creation.
   *
   * If {@code out} is nullptr, the value of {@code size} is set to the size of the name
   * string (including null-terminator), and a success status is returned.
   *
   * If the {@code size} parameter is greater than or equal to the name string's size,
   * the value of {@code size} is set to the true size of the string (including null-terminator),
   * the provided memory is filled with the string's contents, and a success status is returned.
   *
   * If the {@code size} parameter is less than the actual string's size and {@code out}
   * is not nullptr, the value of {@code size} is set to the true size of the string
   * and a failure status is returned.
   *
   * @param info [in] An instance of ::OrtKernelInfo.
   * @param index [in] The index of the output name to get. Returns a failure status if out-of-bounds.
   * @param out [out] Memory location into which to write the UTF-8 null-terminated string representing the output's
   *                 name.
   * @param size [in,out] Pointer to the size of the {@code out} buffer. See above comments for details.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.14
   */
  public native OrtStatus KernelInfo_GetOutputName( @Const OrtKernelInfo info, @Cast("size_t") long index, @Cast("char*") BytePointer out,
                    @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfo_GetOutputName( @Const OrtKernelInfo info, @Cast("size_t") long index, @Cast("char*") ByteBuffer out,
                    @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfo_GetOutputName( @Const OrtKernelInfo info, @Cast("size_t") long index, @Cast("char*") byte[] out,
                    @Cast("size_t*") SizeTPointer size);

  /** \brief Get the type information for a ::OrtKernelInfo's input.
   *
   * Used in the CreateKernel callback of an OrtCustomOp to query the shape and type information
   * of an input during kernel/session creation.
   *
   * @param info [in] An instance of ::OrtKernelInfo.
   * @param index [in] Which input to get the type information for
   * @param type_info [out] Pointer set to the resulting ::OrtTypeInfo. Must be freed with OrtApi::ReleaseTypeInfo.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.14
   */
  public native OrtStatus KernelInfo_GetInputTypeInfo( @Const OrtKernelInfo info, @Cast("size_t") long index,
                    @Cast("OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus KernelInfo_GetInputTypeInfo( @Const OrtKernelInfo info, @Cast("size_t") long index,
                    @ByPtrPtr OrtTypeInfo type_info);

  /** \brief Get the type information for a ::OrtKernelInfo's output.
   *
   * Used in the CreateKernel callback of an OrtCustomOp to query the shape and type information
   * of an output during kernel/session creation.
   *
   * @param info [in] An instance of ::OrtKernelInfo.
   * @param index [in] Which input to get the type information for
   * @param type_info [out] Pointer set to the resulting ::OrtTypeInfo. Must be freed with OrtApi::ReleaseTypeInfo.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.14
   */
  public native OrtStatus KernelInfo_GetOutputTypeInfo( @Const OrtKernelInfo info, @Cast("size_t") long index,
                    @Cast("OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus KernelInfo_GetOutputTypeInfo( @Const OrtKernelInfo info, @Cast("size_t") long index,
                    @ByPtrPtr OrtTypeInfo type_info);

  /** \brief Get a ::OrtValue tensor stored as an attribute in the graph node.
   *
   * Used in the CreateKernel callback of an OrtCustomOp to get a tensor attribute.
   *
   * @param info [in] ::OrtKernelInfo instance.
   * @param name [in] UTF-8 null-terminated string representing the attribute's name.
   * @param allocator [in] Allocator used to allocate the internal tensor state.
   * @param out [out] Returns newly created ::OrtValue. Must be freed with OrtApi::ReleaseValue,
   *                 which will also free internal tensor state allocated with the provided allocator.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus KernelInfoGetAttribute_tensor( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    OrtAllocator allocator, @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus KernelInfoGetAttribute_tensor( @Const OrtKernelInfo info, @Cast("const char*") BytePointer name,
                    OrtAllocator allocator, @ByPtrPtr OrtValue out);
  public native OrtStatus KernelInfoGetAttribute_tensor( @Const OrtKernelInfo info, String name,
                    OrtAllocator allocator, @ByPtrPtr OrtValue out);

  /** \}
   *  \name OrtSessionOptions
   *  Custom operator APIs
   *  \{
  <p>
  /** \brief Checks if the given session configuration entry exists.
   *
   * The config_key formats are defined in onnxruntime_session_options_config_keys.h
   *
   * Can be used in a custom operator library to check for session configuration entries
   * that target one or more custom operators in the library. Example: The config entry
   * custom_op.myop.some_key targets a custom op named "myop".
   *
   * @param options [in] The ::OrtSessionOptions instance.
   * @param config_key [in] A null-terminated UTF-8 string representation of the configuration key.
   * @param out [out] Pointer set to 1 if the entry exists and 0 otherwise.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.14
   */
  public native OrtStatus HasSessionConfigEntry( @Const OrtSessionOptions options,
                    @Cast("const char*") BytePointer config_key, IntPointer out);
  public native OrtStatus HasSessionConfigEntry( @Const OrtSessionOptions options,
                    String config_key, IntBuffer out);
  public native OrtStatus HasSessionConfigEntry( @Const OrtSessionOptions options,
                    @Cast("const char*") BytePointer config_key, int[] out);
  public native OrtStatus HasSessionConfigEntry( @Const OrtSessionOptions options,
                    String config_key, IntPointer out);
  public native OrtStatus HasSessionConfigEntry( @Const OrtSessionOptions options,
                    @Cast("const char*") BytePointer config_key, IntBuffer out);
  public native OrtStatus HasSessionConfigEntry( @Const OrtSessionOptions options,
                    String config_key, int[] out);

  /** \brief Get a session configuration value.
   *
   * Returns a failure status if the configuration key does not exist.
   * The config_key and the format of config_value are defined in onnxruntime_session_options_config_keys.h
   *
   * If {@code config_value} is nullptr, the value of {@code size} is set to the true size of the string
   * value (including null-terminator), and a success status is returned.
   *
   * If the {@code size} parameter is greater than or equal to the actual string value's size,
   * the value of {@code size} is set to the true size of the string value, the provided memory
   * is filled with the value's contents, and a success status is returned.
   *
   * If the {@code size} parameter is less than the actual string value's size and {@code config_value}
   * is not nullptr, the value of {@code size} is set to the true size of the string value
   * and a failure status is returned.
   *
   * Can be used in a custom operator library to get session configuration entries
   * that target one or more custom operators in the library. Example: The config entry
   * custom_op.myop.some_key targets a custom op named "myop".
   *
   * @param options [in] The session options.
   * @param config_key [in] A null-terminated UTF-8 string representation of the config key.
   * @param config_value [in] Pointer to memory where the null-terminated UTF-8 string value will be stored.
   * @param size [in,out] Pointer to the size of the {@code config_value} buffer. See above comments for details.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.14
   */
  public native OrtStatus GetSessionConfigEntry( @Const OrtSessionOptions options,
                    @Cast("const char*") BytePointer config_key, @Cast("char*") BytePointer config_value, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus GetSessionConfigEntry( @Const OrtSessionOptions options,
                    String config_key, @Cast("char*") ByteBuffer config_value, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus GetSessionConfigEntry( @Const OrtSessionOptions options,
                    @Cast("const char*") BytePointer config_key, @Cast("char*") byte[] config_value, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus GetSessionConfigEntry( @Const OrtSessionOptions options,
                    String config_key, @Cast("char*") BytePointer config_value, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus GetSessionConfigEntry( @Const OrtSessionOptions options,
                    @Cast("const char*") BytePointer config_key, @Cast("char*") ByteBuffer config_value, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus GetSessionConfigEntry( @Const OrtSessionOptions options,
                    String config_key, @Cast("char*") byte[] config_value, @Cast("size_t*") SizeTPointer size);

  /** \}
  <p>
  /** \brief Append dnnl provider to session options
   *
   * If oneDNN is not available, this function will return failure.
   *
   * @param options [in]
   * @param dnnl_options [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.15.
   */
  public native OrtStatus SessionOptionsAppendExecutionProvider_Dnnl(
                    OrtSessionOptions options, @Const OrtDnnlProviderOptions dnnl_options);

  /** \brief Create an OrtDnnlProviderOptions
   *
   * @param out [out] Newly created ::OrtDnnlProviderOptions. Must be released with OrtApi::ReleaseDnnlProviderOptions
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.15.
   */
  public native OrtStatus CreateDnnlProviderOptions( @Cast("OrtDnnlProviderOptions**") PointerPointer out);
  public native OrtStatus CreateDnnlProviderOptions( @ByPtrPtr OrtDnnlProviderOptions out);

  /** \brief Set options in a oneDNN Execution Provider.
   *
   * Key should be in null terminated string format of the member of ::OrtDnnlProviderOptions
   * and value should be its related range.
   *
   * For example, key="use_arena" and value="1"
   *
   * @param dnnl_options [in]
   * @param provider_options_keys [in] Array of UTF-8 null-terminated string for provider options keys
   * @param provider_options_values [in] Array of UTF-8 null-terminated string for provider options values
   * @param num_keys [in] Number of elements in the {@code provider_option_keys} and {@code provider_options_values} arrays
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.15.
   */
  public native OrtStatus UpdateDnnlProviderOptions( OrtDnnlProviderOptions dnnl_options,
                    @Cast("const char*const*") PointerPointer provider_options_keys,
                    @Cast("const char*const*") PointerPointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateDnnlProviderOptions( OrtDnnlProviderOptions dnnl_options,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateDnnlProviderOptions( OrtDnnlProviderOptions dnnl_options,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateDnnlProviderOptions( OrtDnnlProviderOptions dnnl_options,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_values,
                    @Cast("size_t") long num_keys);

  /**
   * Get serialized oneDNN provider options string.
   *
   * For example, "use_arena=1;......"
   *
   * @param dnnl_options - OrtDnnlProviderOptions instance
   * @param allocator - a ptr to an instance of OrtAllocator obtained with CreateAllocator() or GetAllocatorWithDefaultOptions()
   *                      the specified allocator will be used to allocate continuous buffers for output strings and lengths.
   * @param ptr - is a UTF-8 null terminated string allocated using 'allocator'. The caller is responsible for using the same allocator to free it.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.15.
   */
  public native OrtStatus GetDnnlProviderOptionsAsString( @Const OrtDnnlProviderOptions dnnl_options, OrtAllocator allocator, @Cast("char**") PointerPointer ptr);
  public native OrtStatus GetDnnlProviderOptionsAsString( @Const OrtDnnlProviderOptions dnnl_options, OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer ptr);
  public native OrtStatus GetDnnlProviderOptionsAsString( @Const OrtDnnlProviderOptions dnnl_options, OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer ptr);
  public native OrtStatus GetDnnlProviderOptionsAsString( @Const OrtDnnlProviderOptions dnnl_options, OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] ptr);

  /** \brief Release an ::OrtDnnlProviderOptions
   *
   * @since Version 1.15.
   */
  public static class ReleaseDnnlProviderOptions_OrtDnnlProviderOptions extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    ReleaseDnnlProviderOptions_OrtDnnlProviderOptions(Pointer p) { super(p); }
      protected ReleaseDnnlProviderOptions_OrtDnnlProviderOptions() { allocate(); }
      private native void allocate();
      public native void call(OrtDnnlProviderOptions input);
  }
  public native ReleaseDnnlProviderOptions_OrtDnnlProviderOptions ReleaseDnnlProviderOptions(); public native OrtApi ReleaseDnnlProviderOptions(ReleaseDnnlProviderOptions_OrtDnnlProviderOptions setter);

  /** \name OrtKernelInfo
   *  Custom operator APIs.
   *  \{
  <p>
  /** \brief Get the graph node name from ::OrtKernelInfo.
   *
   * If {@code out} is nullptr, the value of {@code size} is set to the size of the name
   * string (including null-terminator), and a success status is returned.
   *
   * If the {@code size} parameter is greater than or equal to the name string's size,
   * the value of {@code size} is set to the true size of the string (including null-terminator),
   * the provided memory is filled with the string's contents, and a success status is returned.
   *
   * If the {@code size} parameter is less than the actual string's size and {@code out}
   * is not nullptr, the value of {@code size} is set to the true size of the string
   * and a failure status is returned.
   *
   * Can be used in a custom operator's CreateKernel callback to get the name of the operator's node name in the graph.
   *
   * @param info [in] An instance of ::OrtKernelInfo.
   * @param out [out] Memory location into which to write the UTF-8 null-terminated string representing the name.
   * @param size [in,out] Pointer to the size of the {@code out} buffer. See above comments for details.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.15
   */
  public native OrtStatus KernelInfo_GetNodeName( @Const OrtKernelInfo info, @Cast("char*") BytePointer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfo_GetNodeName( @Const OrtKernelInfo info, @Cast("char*") ByteBuffer out, @Cast("size_t*") SizeTPointer size);
  public native OrtStatus KernelInfo_GetNodeName( @Const OrtKernelInfo info, @Cast("char*") byte[] out, @Cast("size_t*") SizeTPointer size);

  /** \brief Get the session logger from ::OrtKernelInfo.
   *
   * Used in the CreateKernel callback of an OrtCustomOp to get a logger that can be used to log
   * messages.
   *
   * @param info [in] An instance of ::OrtKernelInfo.
   * @param logger [out] Pointer set to the session's ::OrtLogger. Owned by ONNX Runtime, so do not free.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.15
   */
  public native OrtStatus KernelInfo_GetLogger( @Const OrtKernelInfo info, @Cast("const OrtLogger**") PointerPointer logger);
  public native OrtStatus KernelInfo_GetLogger( @Const OrtKernelInfo info, @Const @ByPtrPtr OrtLogger logger);

  /** \}
   *  \name OrtKernelContext
   *  Custom operator APIs.
   *  \{
  <p>
  /** \brief Get the runtime logger from ::OrtKernelContext.
   *
   * Used in the KernelCompute callback of an OrtCustomOp to get a logger that can be used to log
   * messages during inference.
   *
   * @param context [in] An instance of ::OrtKernelContext.
   * @param logger [out] Pointer set to the kernel context's ::OrtLogger. Owned by ONNX Runtime, so do not free.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.15
   */
  public native OrtStatus KernelContext_GetLogger( @Const OrtKernelContext context, @Cast("const OrtLogger**") PointerPointer logger);
  public native OrtStatus KernelContext_GetLogger( @Const OrtKernelContext context, @Const @ByPtrPtr OrtLogger logger);

  /** \}
   *  \name OrtLogger
   *  Custom operator APIs.
   *  \{
  <p>
  /** \brief Logs a message at the given severity level using the provided ::OrtLogger.
   *
   * Only messages with a severity level equal or greater than the ::OrtLogger's logging severity level
   * are logged. Use OrtApi::Logger_GetLoggingSeverityLevel to get the ::OrtLogger's logging severity
   * level.
   *
   * Can be used in custom operators to log messages with the logger retrieved via OrtApi::KernelInfo_GetLogger.
   *
   * @param logger [in] The ::OrtLogger instance.
   * @param log_severity_level [in] The message's severity level.
   * @param message [in] The message to log.
   * @param file_path [in] The filepath of the file in which the message is logged. Usually the value of ORT_FILE.
   * @param line_number [in] The file line number in which the message is logged. Usually the value of __LINE__.
   * @param func_name [in] The name of the function in which the message is logged. Usually the value of __FUNCTION__.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.15
   */
  public native OrtStatus Logger_LogMessage( @Const OrtLogger logger, @Cast("OrtLoggingLevel") int log_severity_level,
                    @Cast("const char*") BytePointer message, @Cast("const ORTCHAR_T*") Pointer file_path, int line_number,
                    @Cast("const char*") BytePointer func_name);
  public native OrtStatus Logger_LogMessage( @Const OrtLogger logger, @Cast("OrtLoggingLevel") int log_severity_level,
                    String message, @Cast("const ORTCHAR_T*") Pointer file_path, int line_number,
                    String func_name);

  /** \brief Get the logging severity level of the ::OrtLogger.
   *
   * Can be used in a custom operator to get the logging severity level of the ::OrtLogger associated with
   * the ::OrtKernelInfo.
   *
   * @param logger [in] The ::OrtLogger instance.
   * @param out [out] Pointer to variable assigned with the logging severity level on success.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.15
   */
  public native OrtStatus Logger_GetLoggingSeverityLevel( @Const OrtLogger logger, @Cast("OrtLoggingLevel*") IntPointer out);
  public native OrtStatus Logger_GetLoggingSeverityLevel( @Const OrtLogger logger, @Cast("OrtLoggingLevel*") IntBuffer out);
  public native OrtStatus Logger_GetLoggingSeverityLevel( @Const OrtLogger logger, @Cast("OrtLoggingLevel*") int[] out);

  /** \}
  <p>
  /** \brief Get a ::OrtValue tensor stored as a constant initializer in the graph node.
   *
   * Used in the CreateKernel callback of an OrtCustomOp to get a tensor value.
   *
   * @param info [in] ::OrtKernelInfo instance.
   * @param index [in] The node index.
   * @param is_constant [out] Is it a constant node input or not.
   * @param out [out] The OrtValue tensor value.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.15.
   */
  public native OrtStatus KernelInfoGetConstantInput_tensor( @Const OrtKernelInfo info, @Cast("size_t") long index, IntPointer is_constant, @Cast("const OrtValue**") PointerPointer out);
  public native OrtStatus KernelInfoGetConstantInput_tensor( @Const OrtKernelInfo info, @Cast("size_t") long index, IntPointer is_constant, @Const @ByPtrPtr OrtValue out);
  public native OrtStatus KernelInfoGetConstantInput_tensor( @Const OrtKernelInfo info, @Cast("size_t") long index, IntBuffer is_constant, @Const @ByPtrPtr OrtValue out);
  public native OrtStatus KernelInfoGetConstantInput_tensor( @Const OrtKernelInfo info, @Cast("size_t") long index, int[] is_constant, @Const @ByPtrPtr OrtValue out);

  /** \brief Get Optional Type information from an ::OrtTypeInfo
   *
   * This augments ::OrtTypeInfo to return an ::OrtOptionalTypeInfo when the type is optional.
   * The OrtOptionalTypeInfo also has a nested ::OrtTypeInfo that describes the type of the optional value.
   * ::OrtOptionalTypeInfo type can only appear within model metadata to describe inputs/outputs.
   * The actual OrtValues that are supplied in place of optional type inputs should contain
   * specific type that is described by ::OrtOptionalTypeInfo.
   *
   * So the picture: ::OrtTypeInfo -> ::OrtOptionalTypeInfo -> ::OrtTypeInfo (describes the type that can be supplied
   * in place of the optional type when creating the actual ::OrtValue).
   *
   * @param type_info [in]
   * @param out [out] A pointer to the ::OrtOptionalTypeInfo. Do not free this value,
   *                 it is owned by OrtTypeInfo instance. When the type_info does not represent
   *                 optional type, nullptr is returned in out.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.15.
   */
  public native OrtStatus CastTypeInfoToOptionalTypeInfo( @Const OrtTypeInfo type_info,
                    @Cast("const OrtOptionalTypeInfo**") PointerPointer out);
  public native OrtStatus CastTypeInfoToOptionalTypeInfo( @Const OrtTypeInfo type_info,
                    @Const @ByPtrPtr OrtOptionalTypeInfo out);

  /** \brief Get OrtTypeInfo for the allowed contained type from an ::OrtOptionalTypeInfo.
   *
   * This augments ::OrtOptionalTypeInfo to return an ::OrtTypeInfo for the contained type.
   * The OrtOptionalTypeInfo has a nested ::OrtTypeInfo that describes the type of the optional value.
   * ::OrtOptionalTypeInfo type can only appear within model metadata to describe inputs/outputs.
   * The actual OrtValues that are supplied in place of optional type inputs should contain
   * specific type that is described by the returned ::OrtTypeInfo.
   *
   * @param optional_type_info [in]
   * @param out [out] A copy of ::OrtTypeInfo for what the optional value could be.
   *                 The user must free this value with ReleaseTypeInfo.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.15.
   */
  public native OrtStatus GetOptionalContainedTypeInfo( @Const OrtOptionalTypeInfo optional_type_info,
                    @Cast("OrtTypeInfo**") PointerPointer out);
  public native OrtStatus GetOptionalContainedTypeInfo( @Const OrtOptionalTypeInfo optional_type_info,
                    @ByPtrPtr OrtTypeInfo out);

  /** \brief Set a single string in a string tensor
   *  Do not zero terminate the string data.
   *
   * @param value [in] A string tensor
   * @param index [in] - flat index of the element
   * @param length_in_bytes [in] length of the buffer in utf-8 bytes (without the null terminator)
   * @param buffer [inout] - address of return value
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   */
  public native OrtStatus GetResizedStringTensorElementBuffer( OrtValue value, @Cast("size_t") long index, @Cast("size_t") long length_in_bytes, @Cast("char**") PointerPointer buffer);
  public native OrtStatus GetResizedStringTensorElementBuffer( OrtValue value, @Cast("size_t") long index, @Cast("size_t") long length_in_bytes, @Cast("char**") @ByPtrPtr BytePointer buffer);
  public native OrtStatus GetResizedStringTensorElementBuffer( OrtValue value, @Cast("size_t") long index, @Cast("size_t") long length_in_bytes, @Cast("char**") @ByPtrPtr ByteBuffer buffer);
  public native OrtStatus GetResizedStringTensorElementBuffer( OrtValue value, @Cast("size_t") long index, @Cast("size_t") long length_in_bytes, @Cast("char**") @ByPtrPtr byte[] buffer);

  /** \brief Get Allocator from KernelContext for a specific memoryInfo. Please use C API ReleaseAllocator to release out object
   *
   * @param context [in] OrtKernelContext instance
   * @param mem_info [in] OrtMemoryInfo instance
   * @param out [out] A pointer to OrtAllocator.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.15.
   */
  public native OrtStatus KernelContext_GetAllocator( @Const OrtKernelContext context, @Const OrtMemoryInfo mem_info, @Cast("OrtAllocator**") PointerPointer out);
  public native OrtStatus KernelContext_GetAllocator( @Const OrtKernelContext context, @Const OrtMemoryInfo mem_info, @ByPtrPtr OrtAllocator out);

  /** \brief Returns a null terminated string of the build info including git info and cxx flags
   *
   * @return UTF-8 encoded version string. Do not deallocate the returned buffer.
   *
   * @since Version 1.15.
   */
  public static class BytePointer_GetBuildInfoString extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    BytePointer_GetBuildInfoString(Pointer p) { super(p); }
      protected BytePointer_GetBuildInfoString() { allocate(); }
      private native void allocate();
      public native @Cast("const char*") BytePointer call();
  }
  public native BytePointer_GetBuildInfoString GetBuildInfoString(); public native OrtApi GetBuildInfoString(BytePointer_GetBuildInfoString setter);

  /** \name OrtROCMProviderOptions
   *  \{
  <p>
  /** \brief Create an OrtROCMProviderOptions
   *
   * @param out [out] Newly created ::OrtROCMProviderOptions. Must be released with OrtApi::ReleaseROCMProviderOptions
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.16.
   */
  public native OrtStatus CreateROCMProviderOptions( @Cast("OrtROCMProviderOptions**") PointerPointer out);
  public native OrtStatus CreateROCMProviderOptions( @ByPtrPtr OrtROCMProviderOptions out);

  /** \brief Set options in a ROCm Execution Provider.
   *
   * Please refer to https://onnxruntime.ai/docs/execution-providers/ROCm-ExecutionProvider.html
   * to know the available keys and values. Key should be in null terminated string format of the member of
   * ::OrtROCMProviderOptions and value should be its related range.
   *
   * For example, key="device_id" and value="0"
   *
   * @param rocm_options [in]
   * @param provider_options_keys [in] Array of UTF-8 null-terminated string for provider options keys
   * @param provider_options_values [in] Array of UTF-8 null-terminated string for provider options values
   * @param num_keys [in] Number of elements in the {@code provider_option_keys} and {@code provider_options_values} arrays
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.16.
   */
  public native OrtStatus UpdateROCMProviderOptions( OrtROCMProviderOptions rocm_options,
                    @Cast("const char*const*") PointerPointer provider_options_keys,
                    @Cast("const char*const*") PointerPointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateROCMProviderOptions( OrtROCMProviderOptions rocm_options,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateROCMProviderOptions( OrtROCMProviderOptions rocm_options,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus UpdateROCMProviderOptions( OrtROCMProviderOptions rocm_options,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_values,
                    @Cast("size_t") long num_keys);

  /**
   * Get serialized ROCm provider options string.
   *
   * For example, "device_id=0;arena_extend_strategy=0;......"
   *
   * @param rocm_options - OrtROCMProviderOptions instance
   * @param allocator - a ptr to an instance of OrtAllocator obtained with CreateAllocator() or GetAllocatorWithDefaultOptions()
   *                      the specified allocator will be used to allocate continuous buffers for output strings and lengths.
   * @param ptr - is a UTF-8 null terminated string allocated using 'allocator'. The caller is responsible for using the same allocator to free it.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.16.
   */
  public native OrtStatus GetROCMProviderOptionsAsString( @Const OrtROCMProviderOptions rocm_options, OrtAllocator allocator, @Cast("char**") PointerPointer ptr);
  public native OrtStatus GetROCMProviderOptionsAsString( @Const OrtROCMProviderOptions rocm_options, OrtAllocator allocator, @Cast("char**") @ByPtrPtr BytePointer ptr);
  public native OrtStatus GetROCMProviderOptionsAsString( @Const OrtROCMProviderOptions rocm_options, OrtAllocator allocator, @Cast("char**") @ByPtrPtr ByteBuffer ptr);
  public native OrtStatus GetROCMProviderOptionsAsString( @Const OrtROCMProviderOptions rocm_options, OrtAllocator allocator, @Cast("char**") @ByPtrPtr byte[] ptr);

  /** \brief Release an ::OrtROCMProviderOptions
   *
   * \note This is an exception in the naming convention of other Release* functions, as the name of the method does not have the V2 suffix, but the type does
   *
   * @since Version 1.16.
   */
  public static class ReleaseROCMProviderOptions_OrtROCMProviderOptions extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    ReleaseROCMProviderOptions_OrtROCMProviderOptions(Pointer p) { super(p); }
      protected ReleaseROCMProviderOptions_OrtROCMProviderOptions() { allocate(); }
      private native void allocate();
      public native void call(OrtROCMProviderOptions input);
  }
  public native ReleaseROCMProviderOptions_OrtROCMProviderOptions ReleaseROCMProviderOptions(); public native OrtApi ReleaseROCMProviderOptions(ReleaseROCMProviderOptions_OrtROCMProviderOptions setter);

  /** \brief Create an allocator with specific type and register it with the ::OrtEnv
   *  This API enhance CreateAndRegisterAllocator that it can create an allocator with specific type, not just CPU allocator
   *  Enables sharing the allocator between multiple sessions that use the same env instance.
   *  Lifetime of the created allocator will be valid for the duration of the environment.
   *  Returns an error if an allocator with the same ::OrtMemoryInfo is already registered.
   *  @param env [in] OrtEnv instance
   *  @param provider_type [in] ExecutionProvider type
   *  @param mem_info [in] OrtMemoryInfo instance
   *  @param arena_cfg [in] Arena configuration
   *  @param provider_options_keys [in] key of the provider options map
   *  @param provider_options_values [in] value of the provider options map
   *  @param num_keys [in] Length of the provider options map
   */
  public native OrtStatus CreateAndRegisterAllocatorV2( OrtEnv env, @Cast("const char*") BytePointer provider_type,
                    @Const OrtMemoryInfo mem_info, @Const OrtArenaCfg arena_cfg,
                    @Cast("const char*const*") PointerPointer provider_options_keys, @Cast("const char*const*") PointerPointer provider_options_values, @Cast("size_t") long num_keys);
  public native OrtStatus CreateAndRegisterAllocatorV2( OrtEnv env, @Cast("const char*") BytePointer provider_type,
                    @Const OrtMemoryInfo mem_info, @Const OrtArenaCfg arena_cfg,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_keys, @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_values, @Cast("size_t") long num_keys);
  public native OrtStatus CreateAndRegisterAllocatorV2( OrtEnv env, String provider_type,
                    @Const OrtMemoryInfo mem_info, @Const OrtArenaCfg arena_cfg,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_keys, @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_values, @Cast("size_t") long num_keys);
  public native OrtStatus CreateAndRegisterAllocatorV2( OrtEnv env, @Cast("const char*") BytePointer provider_type,
                    @Const OrtMemoryInfo mem_info, @Const OrtArenaCfg arena_cfg,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_keys, @Cast("const char*const*") @ByPtrPtr byte[] provider_options_values, @Cast("size_t") long num_keys);
  public native OrtStatus CreateAndRegisterAllocatorV2( OrtEnv env, String provider_type,
                    @Const OrtMemoryInfo mem_info, @Const OrtArenaCfg arena_cfg,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_keys, @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_values, @Cast("size_t") long num_keys);
  public native OrtStatus CreateAndRegisterAllocatorV2( OrtEnv env, @Cast("const char*") BytePointer provider_type,
                    @Const OrtMemoryInfo mem_info, @Const OrtArenaCfg arena_cfg,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_keys, @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_values, @Cast("size_t") long num_keys);
  public native OrtStatus CreateAndRegisterAllocatorV2( OrtEnv env, String provider_type,
                    @Const OrtMemoryInfo mem_info, @Const OrtArenaCfg arena_cfg,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_keys, @Cast("const char*const*") @ByPtrPtr byte[] provider_options_values, @Cast("size_t") long num_keys);

  /** \brief Run the model asynchronously in a thread owned by intra op thread pool
   *
   * @param session [in]
   * @param run_options [in] If nullptr, will use a default ::OrtRunOptions
   * @param input_names [in] Array of null terminated UTF8 encoded strings of the input names
   * @param input [in] Array of ::OrtValue%s of the input values
   * @param input_len [in] Number of elements in the input_names and inputs arrays
   * @param output_names [in] Array of null terminated UTF8 encoded strings of the output names
   * @param output_names_len [in] Number of elements in the output_names and outputs array
   * @param output [out] OrtValue* array of size output_names_len.
   *             On calling RunAsync, output[i] could either be a null or a pointer to a preallocated OrtValue.
   *             Later, the output array will be passed to run_async_callback with all null(s) filled with valid
   *             OrtValue pointer(s) allocated by onnxruntime.
   *             NOTE: it is customer's duty to finally release the output array and each of its member,
   *             regardless of whether the member (OrtValue*) is allocated by onnxruntime or preallocated by the customer.
   * @param run_async_callback [in] Callback function on model run completion
   * @param user_data [in] User data that pass back to run_async_callback
   */
  public native OrtStatus RunAsync( OrtSession session, @Const OrtRunOptions run_options,
                    @Cast("const char*const*") PointerPointer input_names,
                    @Cast("const OrtValue*const*") PointerPointer input, @Cast("size_t") long input_len,
                    @Cast("const char*const*") PointerPointer output_names, @Cast("size_t") long output_names_len,
                    @Cast("OrtValue**") PointerPointer output,
                    RunAsyncCallbackFn run_async_callback, Pointer user_data);
  public native OrtStatus RunAsync( OrtSession session, @Const OrtRunOptions run_options,
                    @Cast("const char*const*") @ByPtrPtr BytePointer input_names,
                    @Const @ByPtrPtr OrtValue input, @Cast("size_t") long input_len,
                    @Cast("const char*const*") @ByPtrPtr BytePointer output_names, @Cast("size_t") long output_names_len,
                    @ByPtrPtr OrtValue output,
                    RunAsyncCallbackFn run_async_callback, Pointer user_data);
  public native OrtStatus RunAsync( OrtSession session, @Const OrtRunOptions run_options,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer input_names,
                    @Const @ByPtrPtr OrtValue input, @Cast("size_t") long input_len,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer output_names, @Cast("size_t") long output_names_len,
                    @ByPtrPtr OrtValue output,
                    RunAsyncCallbackFn run_async_callback, Pointer user_data);
  public native OrtStatus RunAsync( OrtSession session, @Const OrtRunOptions run_options,
                    @Cast("const char*const*") @ByPtrPtr byte[] input_names,
                    @Const @ByPtrPtr OrtValue input, @Cast("size_t") long input_len,
                    @Cast("const char*const*") @ByPtrPtr byte[] output_names, @Cast("size_t") long output_names_len,
                    @ByPtrPtr OrtValue output,
                    RunAsyncCallbackFn run_async_callback, Pointer user_data);

  /**
   * Update TensorRT EP provider option where its data type is pointer, for example 'user_compute_stream'.
   * If the data type of the provider option can be represented by string please use UpdateTensorRTProviderOptions.
   *
   * Note: It's caller's responsibility to properly manage the lifetime of the instance pointed by this pointer.
   *
   * @param tensorrt_options - OrtTensorRTProviderOptionsV2 instance
   * @param key - Name of the provider option
   * @param value - A pointer to the instance that will be assigned to this provider option
   *
   * @since Version 1.16.
   */
  public native OrtStatus UpdateTensorRTProviderOptionsWithValue( OrtTensorRTProviderOptionsV2 tensorrt_options, @Cast("const char*") BytePointer key, Pointer value);
  public native OrtStatus UpdateTensorRTProviderOptionsWithValue( OrtTensorRTProviderOptionsV2 tensorrt_options, String key, Pointer value);

  /**
   * Get TensorRT EP provider option where its data type is pointer.
   * If the data type of the provider option can be represented by string please use GetTensorRTProviderOptionsAsString.
   *
   * @param tensorrt_options - OrtTensorRTProviderOptionsV2 instance
   * @param key - Name of the provider option
   * @param ptr - A pointer to the instance that is kept by the provider option
   *
   * @since Version 1.16.
   */
  public native OrtStatus GetTensorRTProviderOptionsByName( @Const OrtTensorRTProviderOptionsV2 tensorrt_options, @Cast("const char*") BytePointer key, @Cast("void**") PointerPointer ptr);
  public native OrtStatus GetTensorRTProviderOptionsByName( @Const OrtTensorRTProviderOptionsV2 tensorrt_options, @Cast("const char*") BytePointer key, @Cast("void**") @ByPtrPtr Pointer ptr);
  public native OrtStatus GetTensorRTProviderOptionsByName( @Const OrtTensorRTProviderOptionsV2 tensorrt_options, String key, @Cast("void**") @ByPtrPtr Pointer ptr);

  /**
   * Update CUDA EP provider option where its data type is pointer, for example 'user_compute_stream'.
   * If the data type of the provider option can be represented by string please use UpdateCUDAProviderOptions.
   *
   * Note: It's caller's responsibility to properly manage the lifetime of the instance pointed by this pointer.
   *
   * @param cuda_options - OrtCUDAProviderOptionsV2 instance
   * @param key - Name of the provider option
   * @param value - A pointer to the instance that will be assigned to this provider option
   *
   * @since Version 1.16.
   */
  public native OrtStatus UpdateCUDAProviderOptionsWithValue( OrtCUDAProviderOptionsV2 cuda_options, @Cast("const char*") BytePointer key, Pointer value);
  public native OrtStatus UpdateCUDAProviderOptionsWithValue( OrtCUDAProviderOptionsV2 cuda_options, String key, Pointer value);

  /**
   * Get CUDA EP provider option where its data type is pointer.
   * If the data type of the provider option can be represented by string please use GetCUDAProviderOptionsAsString.
   *
   * @param cuda_options - OrtCUDAProviderOptionsV2 instance
   * @param key - Name of the provider option
   * @param ptr - A pointer to the instance that is kept by the provider option
   *
   * @since Version 1.16.
   */
  public native OrtStatus GetCUDAProviderOptionsByName( @Const OrtCUDAProviderOptionsV2 cuda_options, @Cast("const char*") BytePointer key, @Cast("void**") PointerPointer ptr);
  public native OrtStatus GetCUDAProviderOptionsByName( @Const OrtCUDAProviderOptionsV2 cuda_options, @Cast("const char*") BytePointer key, @Cast("void**") @ByPtrPtr Pointer ptr);
  public native OrtStatus GetCUDAProviderOptionsByName( @Const OrtCUDAProviderOptionsV2 cuda_options, String key, @Cast("void**") @ByPtrPtr Pointer ptr);

  /**
   * Get a EP resource.
   * E.g. a cuda stream or a cublas handle
   *
   * @param context - Kernel context
   * @param resource_version - Version of the resource
   * @param resource_id - Type of resource
   * @param resource - A pointer to returned resource
   *
   * @since Version 1.16.
   */
  public native OrtStatus KernelContext_GetResource( @Const OrtKernelContext context, int resource_version,
                    int resource_id, @Cast("void**") PointerPointer resource);
  public native OrtStatus KernelContext_GetResource( @Const OrtKernelContext context, int resource_version,
                    int resource_id, @Cast("void**") @ByPtrPtr Pointer resource);

  /** \brief Set user logging function
   *
   *  By default the logger created by the CreateEnv* functions is used to create the session logger as well.
   *  This function allows a user to override this default session logger with a logger of their own choosing. This way
   *  the user doesn't have to create a separate environment with a custom logger. This addresses the problem when
   *  the user already created an env but now wants to use a different logger for a specific session (for debugging or
   *  other reasons).
   *
   * @param options [in]
   * @param user_logging_function [in] A pointer to a logging function.
   * @param user_logging_param [in] A pointer to arbitrary data passed as the ::OrtLoggingFunction {@code param} parameter to
   *                         {@code user_logging_function}. This parameter is optional.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.17.
   */
  public native OrtStatus SetUserLoggingFunction( OrtSessionOptions options,
                    OrtLoggingFunction user_logging_function, Pointer user_logging_param);

  /**
   * Get number of input from OrtShapeInferContext
   *
   * @param context [in]
   * @param out [out] The number of inputs
   *
   * @since Version 1.17.
   */
  public native OrtStatus ShapeInferContext_GetInputCount( @Const OrtShapeInferContext context, @Cast("size_t*") SizeTPointer out);

  /**
   * Get type and shape info of an input
   *
   * @param context [in]
   * @param index [in] The index of the input
   * @param info [out] Type shape info of the input
   *
   * @since Version 1.17.
   */
  public native OrtStatus ShapeInferContext_GetInputTypeShape( @Const OrtShapeInferContext context, @Cast("size_t") long index, @Cast("OrtTensorTypeAndShapeInfo**") PointerPointer info);
  public native OrtStatus ShapeInferContext_GetInputTypeShape( @Const OrtShapeInferContext context, @Cast("size_t") long index, @ByPtrPtr OrtTensorTypeAndShapeInfo info);

  /**
   * Get attribute from OrtShapeInferContext. Note that OrtShapeInferContext is a per-node context, one could only read attribute from current node.
   *
   * @param context [in]
   * @param attr_name [in] Name of the attribute
   * @param attr [out] Handle of the attribute fetched
   *
   * @since Version 1.17.
   */
  public native OrtStatus ShapeInferContext_GetAttribute( @Const OrtShapeInferContext context, @Cast("const char*") BytePointer attr_name, @Cast("const OrtOpAttr**") PointerPointer attr);
  public native OrtStatus ShapeInferContext_GetAttribute( @Const OrtShapeInferContext context, @Cast("const char*") BytePointer attr_name, @Const @ByPtrPtr OrtOpAttr attr);
  public native OrtStatus ShapeInferContext_GetAttribute( @Const OrtShapeInferContext context, String attr_name, @Const @ByPtrPtr OrtOpAttr attr);

  /**
   * Set type and shape info of an output
   *
   * @param context [in]
   * @param index [in] The index of the output
   * @param info [out] Type shape info of the output
   *
   * @since Version 1.17.
   */
  public native OrtStatus ShapeInferContext_SetOutputTypeShape( @Const OrtShapeInferContext context, @Cast("size_t") long index, @Const OrtTensorTypeAndShapeInfo info);

  /**
   * Set symbolic shape to type shape info
   *
   * @param info [in] Type shape info
   * @param dim_params [in] Symbolic strings
   * @param dim_params_length [in] Number of strings
   *
   * @since Version 1.17.
   */
  public native OrtStatus SetSymbolicDimensions( OrtTensorTypeAndShapeInfo info, @Cast("const char**") PointerPointer dim_params, @Cast("size_t") long dim_params_length);
  public native OrtStatus SetSymbolicDimensions( OrtTensorTypeAndShapeInfo info, @Cast("const char**") @ByPtrPtr BytePointer dim_params, @Cast("size_t") long dim_params_length);
  public native OrtStatus SetSymbolicDimensions( OrtTensorTypeAndShapeInfo info, @Cast("const char**") @ByPtrPtr ByteBuffer dim_params, @Cast("size_t") long dim_params_length);
  public native OrtStatus SetSymbolicDimensions( OrtTensorTypeAndShapeInfo info, @Cast("const char**") @ByPtrPtr byte[] dim_params, @Cast("size_t") long dim_params_length);

  /**
   * Read contents of an attribute to data
   *
   * @param op_attr [in]
   * @param type [in] Attribute type
   * @param data [out] Memory address to save raw content of the attribute
   * @param len [in] Number of bytes allowed to store in data
   * @param out [out] Number of bytes required to save the data when the call failed, or the real number of bytes saved to data on success
   *
   * \note Does not support reading graph attributes. Refer to Node_GetSubgraphs.
   *
   * @since Version 1.17.
   */
  public native OrtStatus ReadOpAttr( @Const OrtOpAttr op_attr, @Cast("OrtOpAttrType") int type, Pointer data, @Cast("size_t") long len, @Cast("size_t*") SizeTPointer out);

  /** \brief Set whether to use deterministic compute.
   *
   * Default is false. If set to true, this will enable deterministic compute for GPU kernels where possible.
   * Note that this most likely will have a performance cost.
   *
   * @param options [in]
   * @param value [in]
   *
   * @since Version 1.17.
   */
  public native OrtStatus SetDeterministicCompute( OrtSessionOptions options, @Cast("bool") boolean value);

  /**
   * Run fn in parallel
   *
   * @param context [in]
   * @param fn [in] Function accepting usr_data and an integer as iterator
   * @param total [in] The number of times fn is to be invoked
   * @param num_batch [in] Number of batches by which the "total" is to be divided in maximum. When zero, there is no limit
   * @param usr_data [in] User data to be passed back to fn
   *
   * @since Version 1.17.
   */
  public static class Fn_Pointer_long extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Fn_Pointer_long(Pointer p) { super(p); }
      protected Fn_Pointer_long() { allocate(); }
      private native void allocate();
      public native void call(Pointer arg0, @Cast("size_t") long arg1);
  }
  public native OrtStatus KernelContext_ParallelFor( @Const OrtKernelContext context, Fn_Pointer_long fn, @Cast("size_t") long total, @Cast("size_t") long num_batch, Pointer usr_data);

  /** \brief Append OpenVINO execution provider to the session options
   *
   * If OpenVINO is not available (due to a non OpenVINO enabled build, or if OpenVINO is not installed on the system), this function will fail.
   *
   * @param options [in]
   * @param provider_options_keys [in]
   * @param provider_options_values [in]
   * @param num_keys [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.17.
   */
  public native OrtStatus SessionOptionsAppendExecutionProvider_OpenVINO_V2(
                    OrtSessionOptions options,
                    @Cast("const char*const*") PointerPointer provider_options_keys,
                    @Cast("const char*const*") PointerPointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus SessionOptionsAppendExecutionProvider_OpenVINO_V2(
                    OrtSessionOptions options,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus SessionOptionsAppendExecutionProvider_OpenVINO_V2(
                    OrtSessionOptions options,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus SessionOptionsAppendExecutionProvider_OpenVINO_V2(
                    OrtSessionOptions options,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_values,
                    @Cast("size_t") long num_keys);

  /** \brief Append VitisAI provider to session options
   *
   * If VitisAI is not available (due to a non VitisAI enabled build, or if VitisAI is not installed on the system), this function will return failure.
   *
   * @param options [in]
   * @param provider_options_keys [in]
   * @param provider_options_values [in]
   * @param num_keys [in]
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.18.
   */
  public native OrtStatus SessionOptionsAppendExecutionProvider_VitisAI(
                    OrtSessionOptions options,
                    @Cast("const char*const*") PointerPointer provider_options_keys,
                    @Cast("const char*const*") PointerPointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus SessionOptionsAppendExecutionProvider_VitisAI(
                    OrtSessionOptions options,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr BytePointer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus SessionOptionsAppendExecutionProvider_VitisAI(
                    OrtSessionOptions options,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer provider_options_values,
                    @Cast("size_t") long num_keys);
  public native OrtStatus SessionOptionsAppendExecutionProvider_VitisAI(
                    OrtSessionOptions options,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_keys,
                    @Cast("const char*const*") @ByPtrPtr byte[] provider_options_values,
                    @Cast("size_t") long num_keys);

  /** \brief Get scratch buffer from the corresponding allocator under the specific OrtMemoryInfo object.
   *         NOTE: callers are responsible to release this scratch buffer from the corresponding allocator
   *  @param context [in] OrtKernelContext instance
   *  @param mem_info [in] OrtMemoryInfo instance
   *  @param count_or_bytes [in] How many bytes is this scratch buffer
   *  @param out [out] A pointer to the scratch buffer
   *
   *  \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.18.
   */
  public native OrtStatus KernelContext_GetScratchBuffer( @Const OrtKernelContext context, @Const OrtMemoryInfo mem_info, @Cast("size_t") long count_or_bytes, @Cast("void**") PointerPointer out);
  public native OrtStatus KernelContext_GetScratchBuffer( @Const OrtKernelContext context, @Const OrtMemoryInfo mem_info, @Cast("size_t") long count_or_bytes, @Cast("void**") @ByPtrPtr Pointer out);

  /** \brief Get allocator from KernelInfo for a specific memory type. Please use C API ReleaseAllocator to release out object
   *
   * @param info [in] OrtKernelInfo instance
   * @param mem_type [in] OrtMemType object
   * @param out [out] A pointer to OrtAllocator
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.18.
   */
  public native OrtStatus KernelInfoGetAllocator( @Const OrtKernelInfo info, @Cast("OrtMemType") int mem_type, @Cast("OrtAllocator**") PointerPointer out);
  public native OrtStatus KernelInfoGetAllocator( @Const OrtKernelInfo info, @Cast("OrtMemType") int mem_type, @ByPtrPtr OrtAllocator out);

  /** \brief Replace initialized Tensors with external data with the provided files in memory
   *
   * The function will find the initialized TensorProtos with external data in the graph with the provided
   * external file names and the file content in memory. The API gets the external file name, offset, data length
   * from TensorProto, and locate the tensor data from the file in memory buffer.
   * It creates a Tensor to replace the existing Tensor in graph. The replacement
   * will occur before any of the optimizations take place. The data will be copied into the graph
   * since TensorProto can't refer to the user provided buffers.
   *
   * @param options [in]
   * @param external_initializer_file_names [in] Array of null terminated UTF-8 encoded strings of the file names
   *            which holds the external initializers.
   * @param external_initializer_file_buffer_array [in] Array of pointers to the buffer of the file content.
   *            The buffer can be freed after session creation.
   * @param external_initializer_file_lengths [in] Array of size_t to indicate the length of file content
   * @param num_external_initializer_files [in] Number of external files
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.18.
   */
  public native OrtStatus AddExternalInitializersFromFilesInMemory( OrtSessionOptions options,
                    @Cast("const ORTCHAR_T*const*") PointerPointer external_initializer_file_names,
                    @Cast("char*const*") PointerPointer external_initializer_file_buffer_array,
                    @Cast("const size_t*") SizeTPointer external_initializer_file_lengths,
                    @Cast("size_t") long num_external_initializer_files);
  public native OrtStatus AddExternalInitializersFromFilesInMemory( OrtSessionOptions options,
                    @Cast("const ORTCHAR_T*const*") @ByPtrPtr Pointer external_initializer_file_names,
                    @Cast("char*const*") @ByPtrPtr BytePointer external_initializer_file_buffer_array,
                    @Cast("const size_t*") SizeTPointer external_initializer_file_lengths,
                    @Cast("size_t") long num_external_initializer_files);
  public native OrtStatus AddExternalInitializersFromFilesInMemory( OrtSessionOptions options,
                    @Cast("const ORTCHAR_T*const*") @ByPtrPtr Pointer external_initializer_file_names,
                    @Cast("char*const*") @ByPtrPtr ByteBuffer external_initializer_file_buffer_array,
                    @Cast("const size_t*") SizeTPointer external_initializer_file_lengths,
                    @Cast("size_t") long num_external_initializer_files);
  public native OrtStatus AddExternalInitializersFromFilesInMemory( OrtSessionOptions options,
                    @Cast("const ORTCHAR_T*const*") @ByPtrPtr Pointer external_initializer_file_names,
                    @Cast("char*const*") @ByPtrPtr byte[] external_initializer_file_buffer_array,
                    @Cast("const size_t*") SizeTPointer external_initializer_file_lengths,
                    @Cast("size_t") long num_external_initializer_files);

  /** \brief Create an OrtLoraAdapter
   *
   * The function attempts to locate file specified by adapter_file_path, read it and create an OrtLoraAdapter
   * instance. The adapter_file_path should be a valid path to a file that contains a valid Lora Adapter
   * format. The function attempts to validate the format at load time. The file will always be memory mapped, unless
   * the platform does not support memory mapping, in which case the file will be read into memory.
   *
   * @param adapter_file_path [in] adapter file path.
   * @param allocator [in] optional pointer to a device allocator. If specified
   *            data is copied to the device at some point before Run() is invoked. If nullptr, data stays on CPU.
   *            The data would still be copied to device if required by the model at inference time.
   * @param out [out] A pointer to a newly created OrtLoraAdapter instance. Must be released with
   *                  OrtApi::ReleaseLoraAdapter.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.20.
   */
  public native OrtStatus CreateLoraAdapter( @Cast("const ORTCHAR_T*") Pointer adapter_file_path, OrtAllocator allocator,
                    @Cast("OrtLoraAdapter**") PointerPointer out);
  public native OrtStatus CreateLoraAdapter( @Cast("const ORTCHAR_T*") Pointer adapter_file_path, OrtAllocator allocator,
                    @ByPtrPtr OrtLoraAdapter out);

  /** \brief Create an OrtLoraAdapter
   *
   * The function copies the bytes from the array and creates an OrtLoraAdapter instance.
   *
   *
   * @param bytes [in] pointer to a valid Lora Adapter format buffer.
   * @param num_bytes [in] length of bytes buffer.
   * @param allocator [in] optional pointer to a device allocator. If specified
   *            data is copied to the device at some point before Run() is invoked. If nullptr, data stays on CPU.
   *            The data would still be copied to device if required by the model at inference time.
   * @param out [out] A pointer to a newly created OrtLoraAdapter instance. Must be released with
   *                  OrtApi::ReleaseLoraAdapter.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.20.
   */
  public native OrtStatus CreateLoraAdapterFromArray( @Const Pointer bytes, @Cast("size_t") long num_bytes, OrtAllocator allocator,
                    @Cast("OrtLoraAdapter**") PointerPointer out);
  public native OrtStatus CreateLoraAdapterFromArray( @Const Pointer bytes, @Cast("size_t") long num_bytes, OrtAllocator allocator,
                    @ByPtrPtr OrtLoraAdapter out);

  /** \brief Release an ::OrtLoraAdapter obtained from OrtApi::CreateLoraAdapter
   */
  public native void ReleaseLoraAdapter(OrtLoraAdapter input);

  /** \brief Add the Lora Adapter to the list of active adapters.
   *
   * The function adds the Lora Adapter to the list of active adapters. The Lora Adapter must be created with
   * OrtApi::CreateLoraAdapter or FromArray. The Lora Adapter will be used by the session to run the model.
   * The instance of the OrtRunOptions can then be used to customize the Run() calls.
   * More than one OrtLoraAdapter can be active at the same time. Lora Parameters that belong to different
   * Lora adapters that will be active at the same time must not overlap.
   * This setting does not affect RunWithBinding.
   *
   * @param options [in] OrtRunOptions instance
   * @param adapter [in] OrtLoraAdapter instance
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.20.
   */
  public native OrtStatus RunOptionsAddActiveLoraAdapter( OrtRunOptions options, @Const OrtLoraAdapter adapter);

  /** \}
   *  \name OrtEpDynamicOptions
   *  \{
  <p>
  /** \brief Set DynamicOptions for EPs (Execution Providers)
   *
   * Valid options can be found in {@code include\onnxruntime\core\session\onnxruntime_session_options_config_keys.h}
   * Look for {@code kOrtEpDynamicOptions}
   *
   * @param sess [in] OrtSession
   * @param keys [in] Array of null terminated UTF8 encoded strings of EP dynamic option keys
   * @param values [in] Array of null terminated UTF8 encoded string of EP dynamic option values
   * @param kv_len [in] Number of elements in the keys and values arrays
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.20.
   */
  public native OrtStatus SetEpDynamicOptions( OrtSession sess, @Cast("const char*const*") PointerPointer keys,
                    @Cast("const char*const*") PointerPointer values, @Cast("size_t") long kv_len);
  public native OrtStatus SetEpDynamicOptions( OrtSession sess, @Cast("const char*const*") @ByPtrPtr BytePointer keys,
                    @Cast("const char*const*") @ByPtrPtr BytePointer values, @Cast("size_t") long kv_len);
  public native OrtStatus SetEpDynamicOptions( OrtSession sess, @Cast("const char*const*") @ByPtrPtr ByteBuffer keys,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer values, @Cast("size_t") long kv_len);
  public native OrtStatus SetEpDynamicOptions( OrtSession sess, @Cast("const char*const*") @ByPtrPtr byte[] keys,
                    @Cast("const char*const*") @ByPtrPtr byte[] values, @Cast("size_t") long kv_len);

  /** \}
  <p>
  /** \brief Release an OrtValueInfo instance if it was not added to an OrtGraph.
   * @since Version 1.22.
   */
  public native void ReleaseValueInfo(OrtValueInfo input);

  /** \brief Release an OrtNode if it was not added to an OrtGraph.
   * @since Version 1.22.
   */
  public native void ReleaseNode(OrtNode input);

  /** \brief Release an OrtGraph.
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.22.
   */
  public native void ReleaseGraph(OrtGraph input);

  /** \brief Release an OrtModel.
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.22.
   */
  public native void ReleaseModel(OrtModel input);

  /** \brief Get the value name from an OrtValueInfo instance.
   * @param value_info [in] The OrtValueInfo instance.
   * @param name [out] The name of the OrtValueInfo
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.22.
   */
  public native OrtStatus GetValueInfoName( @Const OrtValueInfo value_info, @Cast("const char**") PointerPointer name);
  public native OrtStatus GetValueInfoName( @Const OrtValueInfo value_info, @Cast("const char**") @ByPtrPtr BytePointer name);
  public native OrtStatus GetValueInfoName( @Const OrtValueInfo value_info, @Cast("const char**") @ByPtrPtr ByteBuffer name);
  public native OrtStatus GetValueInfoName( @Const OrtValueInfo value_info, @Cast("const char**") @ByPtrPtr byte[] name);

  /** \brief Get the type information from an OrtValueInfo instance.
   * @param value_info [in] The OrtValueInfo instance.
   * @param type_info [out] The type info of the OrtValueInfo
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.22.
   */
  public native OrtStatus GetValueInfoTypeInfo( @Const OrtValueInfo value_info, @Cast("const OrtTypeInfo**") PointerPointer type_info);
  public native OrtStatus GetValueInfoTypeInfo( @Const OrtValueInfo value_info, @Const @ByPtrPtr OrtTypeInfo type_info);

  /** \brief Get the Model Editor API instance
   *
   * Get the Model Editor API instance to create a new model or augment an existing model.
   *
   * @return Model Editor API struct
   *
   * @since Version 1.22.
   */
  public static class OrtModelEditorApi_GetModelEditorApi extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    OrtModelEditorApi_GetModelEditorApi(Pointer p) { super(p); }
      protected OrtModelEditorApi_GetModelEditorApi() { allocate(); }
      private native void allocate();
      public native @Const OrtModelEditorApi call();
  }
  public native OrtModelEditorApi_GetModelEditorApi GetModelEditorApi(); public native OrtApi GetModelEditorApi(OrtModelEditorApi_GetModelEditorApi setter);

  /** \brief Create an OrtValue for a Tensor that uses pre-existing memory.
   *
   * ORT will take ownership of the memory and free it using the provided deleter when no longer in use.
   *
   * @param deleter [in] OrtAllocator instance that will be used to free the memory.
   *                    Only the OrtAllocator:Info and OrtAllocator::Release functions are required.
   *                    The OrtMemoryInfo returned by OrtAllocator::Info must match the location of p_data.
   * @param p_data [in] Pointer to the memory that will be used by the Tensor. ORT will take ownership of the memory.
   * @param p_data_len [in] Length of the memory in bytes.
   * @param shape [in] Dimensions of the Tensor. All values should be > 0.
   * @param shape_len [in] Number of dimensions in the shape array.
   * @param type [in] Data type of the Tensor.
   * @param out [out] Newly created ::OrtValue. Must be freed with OrtApi::ReleaseValue
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus CreateTensorWithDataAndDeleterAsOrtValue( OrtAllocator deleter,
                    Pointer p_data, @Cast("size_t") long p_data_len,
                    @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len,
                    @Cast("ONNXTensorElementDataType") int type,
                    @Cast("OrtValue**") PointerPointer out);
  public native OrtStatus CreateTensorWithDataAndDeleterAsOrtValue( OrtAllocator deleter,
                    Pointer p_data, @Cast("size_t") long p_data_len,
                    @Cast("const int64_t*") LongPointer shape, @Cast("size_t") long shape_len,
                    @Cast("ONNXTensorElementDataType") int type,
                    @ByPtrPtr OrtValue out);
  public native OrtStatus CreateTensorWithDataAndDeleterAsOrtValue( OrtAllocator deleter,
                    Pointer p_data, @Cast("size_t") long p_data_len,
                    @Cast("const int64_t*") LongBuffer shape, @Cast("size_t") long shape_len,
                    @Cast("ONNXTensorElementDataType") int type,
                    @ByPtrPtr OrtValue out);
  public native OrtStatus CreateTensorWithDataAndDeleterAsOrtValue( OrtAllocator deleter,
                    Pointer p_data, @Cast("size_t") long p_data_len,
                    @Cast("const int64_t*") long[] shape, @Cast("size_t") long shape_len,
                    @Cast("ONNXTensorElementDataType") int type,
                    @ByPtrPtr OrtValue out);

  /** \brief sets load cancellation flag to abort session loading process.
   *
   * @param options [in] instance that was passed to the session at creation time.
   * @param cancel [in] setting this to true after model loading process was initiated will
   *            attempt to cancel the loading process. If cancellation is successful, CreateSession()
   *            CreateSessionFromArray() or any other session creation API that take session options as an
   *            argument will return an OrtStatus indicating that session loading was canceled at user request,
   *            error code ORT_MODEL_LOAD_CANCELED.
   *            The APIs above would not return any valid Session instance. This is the best case effort and the result
   *            is not guaranteed. The session may have already been created and initialized
   *            before the cancellation request was issued.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus SessionOptionsSetLoadCancellationFlag( OrtSessionOptions options,
                    @Cast("bool") boolean cancel);

  /** \brief Get the Compile API instance.
   *
   * Get the Compile API instance to compile ONNX models. Execution providers that support compilation fuse a subgraph
   * into an EPContext node that wraps a provider-specific binary representation of the subgraph.
   * For more details about the EPContext design, refer to:
   *  \htmlonly
   *  <a href="https://onnxruntime.ai/docs/execution-providers/EP-Context-Design.html">EPContext design document.</a>
   *  \endhtmlonly
   *
   * @return Compile API struct instance.
   *
   * @since Version 1.22.
   */
  public static class OrtCompileApi_GetCompileApi extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    OrtCompileApi_GetCompileApi(Pointer p) { super(p); }
      protected OrtCompileApi_GetCompileApi() { allocate(); }
      private native void allocate();
      public native @Const OrtCompileApi call();
  }
  public native OrtCompileApi_GetCompileApi GetCompileApi(); public native OrtApi GetCompileApi(OrtCompileApi_GetCompileApi setter);

  //
  // OrtKeyValuePairs
  //

  /** \brief Create an OrtKeyValuePairs instance.
   *
   * @param out [out] A pointer to a newly created OrtKeyValuePairs instance.
   *
   * \note Must be released by calling ReleaseKeyValuePairs.
   *
   * @since Version 1.22.
   */
  public static class CreateKeyValuePairs_PointerPointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    CreateKeyValuePairs_PointerPointer(Pointer p) { super(p); }
      protected CreateKeyValuePairs_PointerPointer() { allocate(); }
      private native void allocate();
      public native void call(@Cast("OrtKeyValuePairs**") PointerPointer out);
  }
  public native CreateKeyValuePairs_PointerPointer CreateKeyValuePairs(); public native OrtApi CreateKeyValuePairs(CreateKeyValuePairs_PointerPointer setter);

  /** \brief Add a key-value pair to the OrtKeyValuePairs instance.
   *
   * If a pair with the same key already exists, it is overwritten.
   *
   * @param kvps [in] OrtKeyValuePairs instance.
   * @param key [in] Key to be added.
   * @param value [in] Value to be added.
   *
   * \note The {@code key} and {@code value} are copied internally.
   *
   * @since Version 1.22.
   */

  public static class AddKeyValuePair_OrtKeyValuePairs_BytePointer_BytePointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    AddKeyValuePair_OrtKeyValuePairs_BytePointer_BytePointer(Pointer p) { super(p); }
      protected AddKeyValuePair_OrtKeyValuePairs_BytePointer_BytePointer() { allocate(); }
      private native void allocate();
      public native void call(OrtKeyValuePairs kvps, @Cast("const char*") BytePointer key, @Cast("const char*") BytePointer value);
  }
  public native AddKeyValuePair_OrtKeyValuePairs_BytePointer_BytePointer AddKeyValuePair(); public native OrtApi AddKeyValuePair(AddKeyValuePair_OrtKeyValuePairs_BytePointer_BytePointer setter);

  /** \brief Get the value associated with a key in the OrtKeyValuePairs instance.
   *
   * @param kvps [in] OrtKeyValuePairs instance.
   * @param key [in] Key to be searched.
   *
   * @return The value associated with the key, or nullptr if the key does not exist.
   *
   * @since Version 1.22.
   */
  public static class GetKeyValue_OrtKeyValuePairs_BytePointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    GetKeyValue_OrtKeyValuePairs_BytePointer(Pointer p) { super(p); }
      protected GetKeyValue_OrtKeyValuePairs_BytePointer() { allocate(); }
      private native void allocate();
      public native @Cast("const char*") BytePointer call(@Const OrtKeyValuePairs kvps, @Cast("const char*") BytePointer key);
  }
  public native GetKeyValue_OrtKeyValuePairs_BytePointer GetKeyValue(); public native OrtApi GetKeyValue(GetKeyValue_OrtKeyValuePairs_BytePointer setter);

  /** \brief Get all the key-value pairs from the OrtKeyValuePairs instance.
   *
   * @param kvps [in] OrtKeyValuePairs instance.
   * @param keys [out] Array of keys from {@code kvps}.
   * @param values [out] Array of values from {@code kvps}.
   * @param num_entries [out] Number of entries in {@code keys} and {@code values}.
   *
   * @since Version 1.22.
   */
  public static class GetKeyValuePairs_OrtKeyValuePairs_PointerPointer_PointerPointer_SizeTPointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    GetKeyValuePairs_OrtKeyValuePairs_PointerPointer_PointerPointer_SizeTPointer(Pointer p) { super(p); }
      protected GetKeyValuePairs_OrtKeyValuePairs_PointerPointer_PointerPointer_SizeTPointer() { allocate(); }
      private native void allocate();
      public native void call(@Const OrtKeyValuePairs kvps,
                                         @Cast("const char*const**") @ByPtrPtr PointerPointer keys, @Cast("const char*const**") @ByPtrPtr PointerPointer values,
                                         @Cast("size_t*") SizeTPointer num_entries);
  }
  public native GetKeyValuePairs_OrtKeyValuePairs_PointerPointer_PointerPointer_SizeTPointer GetKeyValuePairs(); public native OrtApi GetKeyValuePairs(GetKeyValuePairs_OrtKeyValuePairs_PointerPointer_PointerPointer_SizeTPointer setter);

  /** \brief Remove a key-value pair from the OrtKeyValuePairs instance.
   *
   * @param kvps [in] OrtKeyValuePairs instance.
   * @param key [in] Key to be removed. No error if not found.
   *
   * @since Version 1.22.
   */
  public static class RemoveKeyValuePair_OrtKeyValuePairs_BytePointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    RemoveKeyValuePair_OrtKeyValuePairs_BytePointer(Pointer p) { super(p); }
      protected RemoveKeyValuePair_OrtKeyValuePairs_BytePointer() { allocate(); }
      private native void allocate();
      public native void call(OrtKeyValuePairs kvps, @Cast("const char*") BytePointer key);
  }
  public native RemoveKeyValuePair_OrtKeyValuePairs_BytePointer RemoveKeyValuePair(); public native OrtApi RemoveKeyValuePair(RemoveKeyValuePair_OrtKeyValuePairs_BytePointer setter);

  /** \brief Release an OrtKeyValuePairs instance.
   *
   * @param input [in] OrtKeyValuePairs instance to be released.
   *
   * @since Version 1.22.
   */
  public native void ReleaseKeyValuePairs(OrtKeyValuePairs input);

  /** \brief Register an execution provider library with ORT.
   *
   * The library must export 'CreateEpFactories' and 'ReleaseEpFactory' functions.
   * See OrtEpApi for more details.
   *
   * @param env [in] The OrtEnv instance to register the library in.
   * @param registration_name [in] The name to register the execution provider library under.
   * @param path [in] The path to the execution provider library.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus RegisterExecutionProviderLibrary( OrtEnv env, @Cast("const char*") BytePointer registration_name,
                    @Cast("const ORTCHAR_T*") Pointer path);
  public native OrtStatus RegisterExecutionProviderLibrary( OrtEnv env, String registration_name,
                    @Cast("const ORTCHAR_T*") Pointer path);

  /** \brief Unregister an execution provider library with ORT.
   *
   * ORT will call ReleaseEpFactory for all factories created by the library, and unload the library.
   *
   * You <b>MUST</b> ensure there are no Session instances using execution providers created by the library
   * before calling this function.
   *
   * @param env [in] The OrtEnv instance to unregister the library from.
   * @param registration_name [in] The name the execution provider library was registered under.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus UnregisterExecutionProviderLibrary( OrtEnv env, @Cast("const char*") BytePointer registration_name);
  public native OrtStatus UnregisterExecutionProviderLibrary( OrtEnv env, String registration_name);

  /** \brief Get the list of available OrtEpDevice instances.
   *
   * Each OrtEpDevice instance contains details of the execution provider and the device it will use.
   *
   * @param env [in] The OrtEnv instance to query.
   * @param ep_devices [out] The OrtEpDevice instances that the execution provider will use.
   * @param num_ep_devices [out] The number of OrtEpDevice instances returned.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus GetEpDevices( @Const OrtEnv env,
                    @Cast("const OrtEpDevice*const**") @ByPtrPtr PointerPointer ep_devices, @Cast("size_t*") SizeTPointer num_ep_devices);

  /** \brief Append the execution provider that is responsible for the selected OrtEpDevice instances
   *         to the session options.
   *
   * @param session_options [in] Session options to add execution provider to.
   * @param env [in] Environment that execution providers were registered with.
   * @param ep_devices [in] One or more OrtEpDevice instances to create an execution provider for.
   *                       Obtain from GetEpDevices. All OrtEpDevice instances must be from the same execution
   *                       provider. It is only necessary to provide multiple OrtEpDevices if you want to use the
   *                       same execution provider for multiple devices.
   *                       e.g. the EP is capable of running on GPU and NPU.
   * @param num_ep_devices [in] Number of OrtEpDevice instances.
   * @param ep_option_keys [in] Optional keys to configure the execution provider.
   * @param ep_option_vals [in] Optional values to configure the execution provider.
   * @param num_ep_options [in] Number of execution provide options to add.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.22.
   */
  public native OrtStatus SessionOptionsAppendExecutionProvider_V2( OrtSessionOptions session_options,
                    OrtEnv env,
                    @Cast("const OrtEpDevice*const*") PointerPointer ep_devices, @Cast("size_t") long num_ep_devices,
                    @Cast("const char*const*") PointerPointer ep_option_keys,
                    @Cast("const char*const*") PointerPointer ep_option_vals,
                    @Cast("size_t") long num_ep_options);
  public native OrtStatus SessionOptionsAppendExecutionProvider_V2( OrtSessionOptions session_options,
                    OrtEnv env,
                    @Const @ByPtrPtr OrtEpDevice ep_devices, @Cast("size_t") long num_ep_devices,
                    @Cast("const char*const*") @ByPtrPtr BytePointer ep_option_keys,
                    @Cast("const char*const*") @ByPtrPtr BytePointer ep_option_vals,
                    @Cast("size_t") long num_ep_options);
  public native OrtStatus SessionOptionsAppendExecutionProvider_V2( OrtSessionOptions session_options,
                    OrtEnv env,
                    @Const @ByPtrPtr OrtEpDevice ep_devices, @Cast("size_t") long num_ep_devices,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer ep_option_keys,
                    @Cast("const char*const*") @ByPtrPtr ByteBuffer ep_option_vals,
                    @Cast("size_t") long num_ep_options);
  public native OrtStatus SessionOptionsAppendExecutionProvider_V2( OrtSessionOptions session_options,
                    OrtEnv env,
                    @Const @ByPtrPtr OrtEpDevice ep_devices, @Cast("size_t") long num_ep_devices,
                    @Cast("const char*const*") @ByPtrPtr byte[] ep_option_keys,
                    @Cast("const char*const*") @ByPtrPtr byte[] ep_option_vals,
                    @Cast("size_t") long num_ep_options);

  /** \brief Set the execution provider selection policy for the session.
   *
   * Allows users to specify a device selection policy for automatic execution provider (EP) selection.
   * If custom selection is required please use SessionOptionsSetEpSelectionPolicyDelegate instead.
   *
   * @param session_options [in] The OrtSessionOptions instance.
   * @param policy [in] The device selection policy to use (see OrtExecutionProviderDevicePolicy).
   *
   * @since Version 1.22
   */
  public native OrtStatus SessionOptionsSetEpSelectionPolicy( OrtSessionOptions session_options,
                    @Cast("OrtExecutionProviderDevicePolicy") int policy);

  /** \brief Set the execution provider selection policy delegate for the session.
   *
   * Allows users to provide a custom device selection policy for automatic execution provider (EP) selection.
   *
   * @param session_options [in] The OrtSessionOptions instance.
   * @param delegate [in] Delegate callback for custom selection.
   * @param delegate_state [in] Optional state that will be passed to the delegate callback. nullptr if not required.
   *
   * @since Version 1.22
   */
  public native OrtStatus SessionOptionsSetEpSelectionPolicyDelegate( OrtSessionOptions session_options,
                    EpSelectionDelegate delegate,
                    Pointer delegate_state);

  /** \brief Get the hardware device type.
   *
   * @param device [in] The OrtHardwareDevice instance to query.
   * @return The hardware device type.
   *
   * @since Version 1.22.
   */
  public static class HardwareDevice_Type_OrtHardwareDevice extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    HardwareDevice_Type_OrtHardwareDevice(Pointer p) { super(p); }
      protected HardwareDevice_Type_OrtHardwareDevice() { allocate(); }
      private native void allocate();
      public native @Cast("OrtHardwareDeviceType") int call(@Const OrtHardwareDevice device);
  }
  public native HardwareDevice_Type_OrtHardwareDevice HardwareDevice_Type(); public native OrtApi HardwareDevice_Type(HardwareDevice_Type_OrtHardwareDevice setter);

  /** \brief Get the hardware device's vendor identifier.
   *
   * @param device [in] The OrtHardwareDevice instance to query.
   * @return The hardware device vendor identifier.
   *
   * @since Version 1.22.
   */
  public static class HardwareDevice_VendorId_OrtHardwareDevice extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    HardwareDevice_VendorId_OrtHardwareDevice(Pointer p) { super(p); }
      protected HardwareDevice_VendorId_OrtHardwareDevice() { allocate(); }
      private native void allocate();
      public native @Cast("uint32_t") int call(@Const OrtHardwareDevice device);
  }
  public native HardwareDevice_VendorId_OrtHardwareDevice HardwareDevice_VendorId(); public native OrtApi HardwareDevice_VendorId(HardwareDevice_VendorId_OrtHardwareDevice setter);

  /** \brief Get the hardware device's vendor name.
   *
   * @param device [in] The OrtHardwareDevice instance to query.
   * @return The hardware device's vendor name.
   *
   * @since Version 1.22.
   */
  public static class HardwareDevice_Vendor_OrtHardwareDevice extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    HardwareDevice_Vendor_OrtHardwareDevice(Pointer p) { super(p); }
      protected HardwareDevice_Vendor_OrtHardwareDevice() { allocate(); }
      private native void allocate();
      public native @Cast("const char*") BytePointer call(@Const OrtHardwareDevice device);
  }
  public native HardwareDevice_Vendor_OrtHardwareDevice HardwareDevice_Vendor(); public native OrtApi HardwareDevice_Vendor(HardwareDevice_Vendor_OrtHardwareDevice setter);

  /** \brief Get the hardware device's unique identifier.
   *
   * @param device [in] The OrtHardwareDevice instance to query.
   * @return The device id.
   *
   * \note This is not a unique identifier. It identifies the hardware type when combined with vendor id.
   * @since Version 1.22.
   */
  public static class HardwareDevice_DeviceId_OrtHardwareDevice extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    HardwareDevice_DeviceId_OrtHardwareDevice(Pointer p) { super(p); }
      protected HardwareDevice_DeviceId_OrtHardwareDevice() { allocate(); }
      private native void allocate();
      public native @Cast("uint32_t") int call(@Const OrtHardwareDevice device);
  }
  public native HardwareDevice_DeviceId_OrtHardwareDevice HardwareDevice_DeviceId(); public native OrtApi HardwareDevice_DeviceId(HardwareDevice_DeviceId_OrtHardwareDevice setter);

  /** \brief Get hardware device metadata.
   *
   * @param device [in] The OrtHardwareDevice instance to query.
   * @return An OrtKeyValuePairs instance containing the metadata for the device.
   *         Note: ORT owns the instance so the user must not call ReleaseKeyValuePairs with it.
   *
   * @since Version 1.22.
   */
  public static class HardwareDevice_Metadata_OrtHardwareDevice extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    HardwareDevice_Metadata_OrtHardwareDevice(Pointer p) { super(p); }
      protected HardwareDevice_Metadata_OrtHardwareDevice() { allocate(); }
      private native void allocate();
      public native @Const OrtKeyValuePairs call(@Const OrtHardwareDevice device);
  }
  public native HardwareDevice_Metadata_OrtHardwareDevice HardwareDevice_Metadata(); public native OrtApi HardwareDevice_Metadata(HardwareDevice_Metadata_OrtHardwareDevice setter);

  /** \brief Get the execution provider name.
   *
   * @param ep_device [in] The OrtEpDevice instance to query.
   * @return The execution provider name.
   *
   * @since Version 1.22.
   */
  public static class EpDevice_EpName_OrtEpDevice extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    EpDevice_EpName_OrtEpDevice(Pointer p) { super(p); }
      protected EpDevice_EpName_OrtEpDevice() { allocate(); }
      private native void allocate();
      public native @Cast("const char*") BytePointer call(@Const OrtEpDevice ep_device);
  }
  public native EpDevice_EpName_OrtEpDevice EpDevice_EpName(); public native OrtApi EpDevice_EpName(EpDevice_EpName_OrtEpDevice setter);

  /** \brief Get the execution provider's vendor name.
   *
   * @param ep_device [in] The OrtEpDevice instance to query.
   * @return The execution provider's vendor name.
   *
   * @since Version 1.22.
   */
  public static class EpDevice_EpVendor_OrtEpDevice extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    EpDevice_EpVendor_OrtEpDevice(Pointer p) { super(p); }
      protected EpDevice_EpVendor_OrtEpDevice() { allocate(); }
      private native void allocate();
      public native @Cast("const char*") BytePointer call(@Const OrtEpDevice ep_device);
  }
  public native EpDevice_EpVendor_OrtEpDevice EpDevice_EpVendor(); public native OrtApi EpDevice_EpVendor(EpDevice_EpVendor_OrtEpDevice setter);

  /** \brief Get the metadata for the OrtEpDevice.
   *
   * @param ep_device [in] The OrtEpDevice instance to query.
   * @return An OrtKeyValuePairs instance containing the metadata for the device.
   *
   * @since Version 1.22.
   */
  public static class EpDevice_EpMetadata_OrtEpDevice extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    EpDevice_EpMetadata_OrtEpDevice(Pointer p) { super(p); }
      protected EpDevice_EpMetadata_OrtEpDevice() { allocate(); }
      private native void allocate();
      public native @Const OrtKeyValuePairs call(@Const OrtEpDevice ep_device);
  }
  public native EpDevice_EpMetadata_OrtEpDevice EpDevice_EpMetadata(); public native OrtApi EpDevice_EpMetadata(EpDevice_EpMetadata_OrtEpDevice setter);

  /** \brief Get the execution provider options for the OrtEpDevice.
   *
   * @param ep_device [in] The OrtEpDevice instance to query.
   * @return An OrtKeyValuePairs instance containing the execution provider options for the device.
   *
   * @since Version 1.22.
   */
  public static class EpDevice_EpOptions_OrtEpDevice extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    EpDevice_EpOptions_OrtEpDevice(Pointer p) { super(p); }
      protected EpDevice_EpOptions_OrtEpDevice() { allocate(); }
      private native void allocate();
      public native @Const OrtKeyValuePairs call(@Const OrtEpDevice ep_device);
  }
  public native EpDevice_EpOptions_OrtEpDevice EpDevice_EpOptions(); public native OrtApi EpDevice_EpOptions(EpDevice_EpOptions_OrtEpDevice setter);

  /** \brief Get the OrtHardwareDevice instance for the OrtEpDevice.
   *
   * @param ep_device [in] The OrtEpDevice instance to query.
   * @return The OrtHardwareDevice instance for the device.
   *
   * @since Version 1.22.
   */
  public static class EpDevice_Device_OrtEpDevice extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    EpDevice_Device_OrtEpDevice(Pointer p) { super(p); }
      protected EpDevice_Device_OrtEpDevice() { allocate(); }
      private native void allocate();
      public native @Const OrtHardwareDevice call(@Const OrtEpDevice ep_device);
  }
  public native EpDevice_Device_OrtEpDevice EpDevice_Device(); public native OrtApi EpDevice_Device(EpDevice_Device_OrtEpDevice setter);

  /** \brief Get the OrtEpApi instance for implementing an execution provider.
   *
   * @since Version 1.22.
   */
  public static class OrtEpApi_GetEpApi extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    OrtEpApi_GetEpApi(Pointer p) { super(p); }
      protected OrtEpApi_GetEpApi() { allocate(); }
      private native void allocate();
      public native @Const OrtEpApi call();
  }
  public native OrtEpApi_GetEpApi GetEpApi(); public native OrtApi GetEpApi(OrtEpApi_GetEpApi setter);

  /** \brief Compute total size in bytes of the tensor data contained in an OrtValue.
   *
   * Returns the total number of bytes used to store the tensor data. For numeric tensors,
   * this is sizeof(element_type) * total_element_count. OrtValues that are not tensors or
   * that are tensors that contain strings will cause an error to be returned.
   *
   * @param ort_value [in] OrtValue instance containing a tensor
   * @param size [out] The total size of the tensor data in bytes
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23
   */
  public native OrtStatus GetTensorSizeInBytes( @Const OrtValue ort_value, @Cast("size_t*") SizeTPointer size);

  /** \brief Calls OrtAllocator::GetStats function
   *
   * Return a pointer to the OrtKeyValuePairs structure that contains the statistics of the allocator
   * and the user should call OrtApi::ReleaseKeyValuePairs.
   *
   * NOTE: If the allocator does not implement this function, the OrtKeyValuePairs instance will be empty.
   *
   * @param ort_allocator [in] The allocator to get stats from
   * @param out [out] A pointer to the OrtKeyValuePairs instance that contains the stats
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus AllocatorGetStats( @Const OrtAllocator ort_allocator, @Cast("OrtKeyValuePairs**") PointerPointer out);
  public native OrtStatus AllocatorGetStats( @Const OrtAllocator ort_allocator, @ByPtrPtr OrtKeyValuePairs out);

  /** \brief Create an ::OrtMemoryInfo
   *
   * @param name [in] Arbitrary name.
   * @param device_type [in] Device type.
   * @param vendor_id [in] PCI Vendor ID. Use 0 for a generic allocator (e.g. WebGPU).
   * @param device_id [in] Device ID if there are multiple devices of the same type. e.g. 2 GPU devices.
   * @param mem_type [in] Memory type. Use OrtDeviceMemoryType_DEFAULT for device memory, and
   *                     OrtDeviceMemoryType_HOST_ACCESSIBLE (if applicable) for memory used to transfer between the
   *                     device and the CPU. Use the device_type and device_id of the GPU/NPU that the memory is also
   *                     accessible to.
   * @param alignment [in] Alignment of the memory if required. Pass 0 for default alignment.
   * @param allocator_type [in] Allocator type. If OrtAllocatorType::OrtArenaAllocator, the ORT arena will be used.
   *                           Caveat: Support for OrtArenaAllocator is currently limited to usage of internal ORT
   *                           allocators via CreateAllocator/CreateAndRegisterAllocator/CreateAndRegisterAllocatorV2.
   * @param out [out] Newly created ::OrtMemoryInfo. Must be freed with OrtApi::ReleaseMemoryInfo
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23
   */
  public native OrtStatus CreateMemoryInfo_V2( @Cast("const char*") BytePointer name, @Cast("OrtMemoryInfoDeviceType") int device_type,
                    @Cast("uint32_t") int vendor_id, int device_id, @Cast("OrtDeviceMemoryType") int mem_type,
                    @Cast("size_t") long alignment, @Cast("OrtAllocatorType") int allocator_type,
                    @Cast("OrtMemoryInfo**") PointerPointer out);
  public native OrtStatus CreateMemoryInfo_V2( @Cast("const char*") BytePointer name, @Cast("OrtMemoryInfoDeviceType") int device_type,
                    @Cast("uint32_t") int vendor_id, int device_id, @Cast("OrtDeviceMemoryType") int mem_type,
                    @Cast("size_t") long alignment, @Cast("OrtAllocatorType") int allocator_type,
                    @ByPtrPtr OrtMemoryInfo out);
  public native OrtStatus CreateMemoryInfo_V2( String name, @Cast("OrtMemoryInfoDeviceType") int device_type,
                    @Cast("uint32_t") int vendor_id, int device_id, @Cast("OrtDeviceMemoryType") int mem_type,
                    @Cast("size_t") long alignment, @Cast("OrtAllocatorType") int allocator_type,
                    @ByPtrPtr OrtMemoryInfo out);

  /** \brief Get the device memory type from ::OrtMemoryInfo
   *
   * @param ptr [in] The OrtMemoryInfo instance to query.
   * @return The device memory type.
   *
   * @since Version 1.23
   */
  public static class MemoryInfoGetDeviceMemType_OrtMemoryInfo extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    MemoryInfoGetDeviceMemType_OrtMemoryInfo(Pointer p) { super(p); }
      protected MemoryInfoGetDeviceMemType_OrtMemoryInfo() { allocate(); }
      private native void allocate();
      public native @Cast("OrtDeviceMemoryType") int call( @Const OrtMemoryInfo ptr);
  }
  public native MemoryInfoGetDeviceMemType_OrtMemoryInfo MemoryInfoGetDeviceMemType(); public native OrtApi MemoryInfoGetDeviceMemType(MemoryInfoGetDeviceMemType_OrtMemoryInfo setter);

  /** \brief Get the vendor id from ::OrtMemoryInfo
   *
   * @param ptr [in] The OrtMemoryInfo instance to query.
   * @return The vendor id.
   *
   * @since Version 1.23
   */
  public static class MemoryInfoGetVendorId_OrtMemoryInfo extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    MemoryInfoGetVendorId_OrtMemoryInfo(Pointer p) { super(p); }
      protected MemoryInfoGetVendorId_OrtMemoryInfo() { allocate(); }
      private native void allocate();
      public native @Cast("uint32_t") int call( @Const OrtMemoryInfo ptr);
  }
  public native MemoryInfoGetVendorId_OrtMemoryInfo MemoryInfoGetVendorId(); public native OrtApi MemoryInfoGetVendorId(MemoryInfoGetVendorId_OrtMemoryInfo setter);

  /** \name OrtValueInfo
   *  \{
  <p>
  /** \brief Get the OrtNode that produces the value represented by the given OrtValueInfo.
   * Optionally returns the associated output index.
   *
   * @param value_info [in] The OrtValueInfo instance.
   * @param producer_node [out] Output parameter set to the OrtNode that produces the OrtValueInfo.
   * @param producer_output_index [out] Optional output parameter set to the OrtNode instance's output index
   *                                   that produces the value. Ignored if set to NULL.
   * \snippet{doc} snippets.dox OrtStatus Return Value
   * @since Version 1.23.
   */
  public native OrtStatus ValueInfo_GetValueProducer( @Const OrtValueInfo value_info,
                    @Cast("const OrtNode**") PointerPointer producer_node, @Cast("size_t*") SizeTPointer producer_output_index);
  public native OrtStatus ValueInfo_GetValueProducer( @Const OrtValueInfo value_info,
                    @Const @ByPtrPtr OrtNode producer_node, @Cast("size_t*") SizeTPointer producer_output_index);

  /** \brief Get the number of consumers of a value as a node input.
   *
   * Only nodes are considered "consumers" by this function. To check if an OrtValueInfo is a graph output,
   * call ValueInfo_IsGraphOutput().
   *
   * A single OrtNode may use a single value for more than one input (e.g., Mul(x, x)), so the returned
   * {@code num_consumers} may be larger than the number of unique OrtNode instances that consume the value.
   *
   * @param value_info [in] The OrtValueInfo instance.
   * @param num_consumers [out] Output parameter set to the number of consumers of the value.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus ValueInfo_GetValueNumConsumers( @Const OrtValueInfo value_info, @Cast("size_t*") SizeTPointer num_consumers);

  /** \brief Returns information (OrtNode and input index) for all consumer nodes that use the value as an input.
   *
   * Only nodes are considered "consumers" by this function.
   *
   * Caller provides 2 pre-allocated arrays that will be filled with the OrtNode and input index values.
   * Use ValueInfo_GetValueNumConsumers() to get the number of consumers of the value.
   *
   * An OrtNode instance may appear multiple times if it uses the given value more than once.
   * Example: For a node MulNode(x, x) that consumes the value 'x' twice, the following is returned:
   *   - nodes: [MulNode, MulNode]
   *   - input_indices: [0, 1]
   *
   * @param value_info [in] The OrtValueInfo instance.
   * @param nodes [out] Pre-allocated array of size {@code num_consumers} that is filled with OrtNode instances.
   * @param input_indices [out] Pre-allocated array of {@code num_consumers} elements that is filled
   *                           with input indices. Index is set to -1 for an "implicit" input to a consumer node
   *                           that contains a subgraph (e.g., If, Loop) with nodes that use the value internally.
   * @param num_consumers [in] The size of the {@code consumer_nodes} and {@code consumer_input_indices} arrays.
   *                          Typical usage sets this to the value of ValueInfo_GetValueNumConsumers().
   *                          An error status is returned if {@code num_consumers} is less than the number of actual
   *                          consumers.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus ValueInfo_GetValueConsumers( @Const OrtValueInfo value_info,
                    @Cast("const OrtNode**") PointerPointer nodes,
                    @Cast("int64_t*") LongPointer input_indices,
                    @Cast("size_t") long num_consumers);
  public native OrtStatus ValueInfo_GetValueConsumers( @Const OrtValueInfo value_info,
                    @Const @ByPtrPtr OrtNode nodes,
                    @Cast("int64_t*") LongPointer input_indices,
                    @Cast("size_t") long num_consumers);
  public native OrtStatus ValueInfo_GetValueConsumers( @Const OrtValueInfo value_info,
                    @Const @ByPtrPtr OrtNode nodes,
                    @Cast("int64_t*") LongBuffer input_indices,
                    @Cast("size_t") long num_consumers);
  public native OrtStatus ValueInfo_GetValueConsumers( @Const OrtValueInfo value_info,
                    @Const @ByPtrPtr OrtNode nodes,
                    @Cast("int64_t*") long[] input_indices,
                    @Cast("size_t") long num_consumers);

  /** \brief Get the underlying initializer value, as an OrtValue, from the given OrtValueInfo.
   *
   * Sets the output parameter to NULL if the given OrtValueInfo does not represent an initializer.
   * Does not return an error status in this case.
   *
   * Supports initializers defined in an outer scope (i.e., a parent graph).
   *
   * Supports initializers stored in an external file. For external initializers, ORT memory maps
   * the initializer data on the first call to this function. If caller needs custom memory mapping,
   * use ValueInfo_GetExternalInitializerInfo to get the location of the initializer data.
   *
   * @param value_info [in] The OrtValueInfo instance.
   * @param initializer_value [out] Output parameter set to the initializer value or NULL. Do not cache the OrtValue
   *                               as it is released when the owning OrtGraph is released.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus ValueInfo_GetInitializerValue( @Const OrtValueInfo value_info,
                    @Cast("const OrtValue**") PointerPointer initializer_value);
  public native OrtStatus ValueInfo_GetInitializerValue( @Const OrtValueInfo value_info,
                    @Const @ByPtrPtr OrtValue initializer_value);

  /** \brief Get information about an external initializer (e.g., filepath, file offset, byte size).
   *
   * Sets the output parameter {@code info} to NULL if the given OrtValueInfo does not represent an initializer
   * with external data. In this case, a NULL status (non-error) is returned.
   *
   * @param value_info [in] The OrtValueInfo instance.
   * @param info [out] Output parameter set to an OrtExternalInitializerInfo instance that can be used to query
   *                  file path, file offset, etc. ORT sets this to NULL if the OrtValueInfo does not represent
   *                  an external initializer.
   *                  Must release with ReleaseExternalInitializerInfo.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus ValueInfo_GetExternalInitializerInfo( @Const OrtValueInfo value_info,
                    @Cast("OrtExternalInitializerInfo**") PointerPointer info);
  public native OrtStatus ValueInfo_GetExternalInitializerInfo( @Const OrtValueInfo value_info,
                    @ByPtrPtr OrtExternalInitializerInfo info);

  /** \brief Returns a boolean indicating if the given value is a required graph input.
   *
   * For ONNX IR version < 4, all graph inputs without a matching initializer are required.
   *
   * For ONNX IR version >=4, a graph input with a matching initializer is an optional graph input
   * with the initializer serving as the default value.
   *
   * @param value_info [in] The OrtValueInfo instance representing the graph value.
   * @param is_required_graph_input [out] Output parameter set to true if the graph value is a required graph input.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus ValueInfo_IsRequiredGraphInput( @Const OrtValueInfo value_info,
                    @Cast("bool*") BoolPointer is_required_graph_input);
  public native OrtStatus ValueInfo_IsRequiredGraphInput( @Const OrtValueInfo value_info,
                    @Cast("bool*") boolean[] is_required_graph_input);

  /** \brief Returns a boolean indicating if the given value is an optional graph input.
   *
   * Optional graph inputs were introduced in ONNX IR version 4. For ONNX IR version >=4, a graph input with a
   * matching initializer is an optional graph input with the initializer serving as the default value.
   * The matching initializer is also known as a non-constant initializer.
   *
   * @param value_info [in] The OrtValueInfo instance representing the graph value.
   * @param is_optional_graph_input [out] Output parameter set to true if the graph value is an optional graph input.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus ValueInfo_IsOptionalGraphInput( @Const OrtValueInfo value_info,
                    @Cast("bool*") BoolPointer is_optional_graph_input);
  public native OrtStatus ValueInfo_IsOptionalGraphInput( @Const OrtValueInfo value_info,
                    @Cast("bool*") boolean[] is_optional_graph_input);

  /** \brief Returns a boolean indicating if the given value is a graph output.
   *
   * @param value_info [in] The OrtValueInfo instance representing the graph value.
   * @param is_graph_output [out] Output parameter set to true if the graph value is a graph output.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus ValueInfo_IsGraphOutput( @Const OrtValueInfo value_info, @Cast("bool*") BoolPointer is_graph_output);
  public native OrtStatus ValueInfo_IsGraphOutput( @Const OrtValueInfo value_info, @Cast("bool*") boolean[] is_graph_output);

  /** \brief Returns a boolean indicating if the given value is a constant initializer.
   *
   * For ONNX IR version < 4, all initializers are constant.
   *
   * For ONNX IR version >=4, an initializer that serves as the default value for a matching graph input is not a
   * constant initializer.
   *
   * @param value_info [in] The OrtValueInfo instance representing the graph value.
   * @param is_constant_initializer [out] Output parameter set to true if the graph value is a constant initializer.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus ValueInfo_IsConstantInitializer( @Const OrtValueInfo value_info,
                    @Cast("bool*") BoolPointer is_constant_initializer);
  public native OrtStatus ValueInfo_IsConstantInitializer( @Const OrtValueInfo value_info,
                    @Cast("bool*") boolean[] is_constant_initializer);

  /** \brief Returns a boolean indicating if the given value is defined in an outer scope.
   *
   * Certain operator types (e.g., If and Loop) contain nested subgraphs. This function enables
   * determining whether a value is defined in a parent node's graph.
   *
   * @param value_info [in] The OrtValueInfo instance representing the graph value.
   * @param is_from_outer_scope [out] Output parameter set to true if the value is defined in an outer
   *                                 scope (i.e., a parent graph).
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus ValueInfo_IsFromOuterScope( @Const OrtValueInfo value_info,
                    @Cast("bool*") BoolPointer is_from_outer_scope);
  public native OrtStatus ValueInfo_IsFromOuterScope( @Const OrtValueInfo value_info,
                    @Cast("bool*") boolean[] is_from_outer_scope);

  /** \}
   <p>
   *  \name OrtGraph
   *  \{
  <p>
  /** \brief Returns a graph's name.
   *
   * @param graph [in] The OrtGraph instance.
   * @param graph_name [out] Output parameter set to the graph's name.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Graph_GetName( @Const OrtGraph graph, @Cast("const char**") PointerPointer graph_name);
  public native OrtStatus Graph_GetName( @Const OrtGraph graph, @Cast("const char**") @ByPtrPtr BytePointer graph_name);
  public native OrtStatus Graph_GetName( @Const OrtGraph graph, @Cast("const char**") @ByPtrPtr ByteBuffer graph_name);
  public native OrtStatus Graph_GetName( @Const OrtGraph graph, @Cast("const char**") @ByPtrPtr byte[] graph_name);

  /** \brief Get the filepath to the model from which an OrtGraph is constructed.
   *
   * \note The model's filepath is empty if the filepath is unknown, such as when the model is loaded from bytes
   * via CreateSessionFromArray.
   *
   * @param graph [in] The OrtGraph instance.
   * @param model_path [out] Output parameter set to the model's null-terminated filepath.
   *                        Set to an empty path string if unknown.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Graph_GetModelPath( @Const OrtGraph graph, @Cast("const ORTCHAR_T**") PointerPointer model_path);
  public native OrtStatus Graph_GetModelPath( @Const OrtGraph graph, @Cast("const ORTCHAR_T**") @ByPtrPtr Pointer model_path);

  /** \brief Returns the ONNX IR version.
   *
   * @param graph [in] The OrtGraph instance.
   * @param onnx_ir_version [out] Output parameter set to the ONNX IR version.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Graph_GetOnnxIRVersion( @Const OrtGraph graph, @Cast("int64_t*") LongPointer onnx_ir_version);
  public native OrtStatus Graph_GetOnnxIRVersion( @Const OrtGraph graph, @Cast("int64_t*") LongBuffer onnx_ir_version);
  public native OrtStatus Graph_GetOnnxIRVersion( @Const OrtGraph graph, @Cast("int64_t*") long[] onnx_ir_version);

  /** \brief Returns the number of operator sets that the graph's model uses.
   *
   * \note An operator set is uniquely identified by the (domain, opset_version) pair. All models must have at
   * least one entry that specifies which entry of the ONNX operator set is used. The ONNX domain is represented by
   * an empty string.
   *
   * @param graph [in] The OrtGraph instance.
   * @param num_operator_sets [out] Output parameter set to the number of operator sets that the graph's model uses.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Graph_GetNumOperatorSets( @Const OrtGraph graph, @Cast("size_t*") SizeTPointer num_operator_sets);

  /** \brief Returns the operator sets that the graph's model uses.
   *
   * \note An operator set is uniquely identified by the (domain, opset_version) pair. All models must have at
   * least one entry that specifies which entry of the ONNX operator set is used. The ONNX domain is represented by
   * an empty string.
   *
   * @param graph [in] The OrtGraph instance.
   * @param domains [out] Pre-allocated array of {@code num_operator_sets} elements that is filled with
   *                     null-terminated domain names.
   * @param opset_versions [out] Pre-allocated array of {@code num_operator_sets} elements that is filled with
   *                            the opset version of the corresponding domain in the {@code domains} array.
   * @param num_operator_sets [in] The size of the {@code domains} and {@code opset_versions} arrays.
   *                              Typical usage sets this to the result of Graph_GetNumOperatorSets().
   *                              An error status is returned if {@code num_operator_sets} is less than the actual number
   *                              of operator sets.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Graph_GetOperatorSets( @Const OrtGraph graph,
                    @Cast("const char**") PointerPointer domains,
                    @Cast("int64_t*") LongPointer opset_versions, @Cast("size_t") long num_operator_sets);
  public native OrtStatus Graph_GetOperatorSets( @Const OrtGraph graph,
                    @Cast("const char**") @ByPtrPtr BytePointer domains,
                    @Cast("int64_t*") LongPointer opset_versions, @Cast("size_t") long num_operator_sets);
  public native OrtStatus Graph_GetOperatorSets( @Const OrtGraph graph,
                    @Cast("const char**") @ByPtrPtr ByteBuffer domains,
                    @Cast("int64_t*") LongBuffer opset_versions, @Cast("size_t") long num_operator_sets);
  public native OrtStatus Graph_GetOperatorSets( @Const OrtGraph graph,
                    @Cast("const char**") @ByPtrPtr byte[] domains,
                    @Cast("int64_t*") long[] opset_versions, @Cast("size_t") long num_operator_sets);

  /** \brief Returns the number of graph inputs.
   *
   * \note The count includes initializers that are included in the list of graph inputs.
   *
   * @param graph [in] The OrtGraph instance.
   * @param num_inputs [out] Output parameter set to the number of graph inputs.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Graph_GetNumInputs( @Const OrtGraph graph, @Cast("size_t*") SizeTPointer num_inputs);

  /** \brief Returns the graph's inputs as OrtValueInfo instances.
   *
   * \note The result includes initializers that are included in the list of graph inputs.
   *
   * @param graph [in] The OrtGraph instance.
   * @param inputs [out] Pre-allocated array of {@code num_inputs} elements that is filled with the graph's inputs.
   * @param num_inputs [in] The size of the {@code inputs} array.
   *                       Typical usage sets this to the result of Graph_GetNumInputs(). An error status is
   *                       returned if {@code num_inputs} is less than the number of graph inputs.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Graph_GetInputs( @Const OrtGraph graph,
                    @Cast("const OrtValueInfo**") PointerPointer inputs, @Cast("size_t") long num_inputs);
  public native OrtStatus Graph_GetInputs( @Const OrtGraph graph,
                    @Const @ByPtrPtr OrtValueInfo inputs, @Cast("size_t") long num_inputs);

  /** \brief Returns the number of graph outputs.
   *
   * @param graph [in] The OrtGraph instance.
   * @param num_outputs [out] Output parameter set to the number of graph outputs.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Graph_GetNumOutputs( @Const OrtGraph graph, @Cast("size_t*") SizeTPointer num_outputs);

  /** \brief Returns the graph's outputs as OrtValueInfo instances.
   *
   * @param graph [in] The OrtGraph instance.
   * @param outputs [out] Pre-allocated array of {@code num_outputs} elements that is filled with the graph's outputs.
   * @param num_outputs [in] The size of the {@code outputs} array.
   *                        Typical usage sets this to the result of Graph_GetNumOutputs(). An error status is
   *                        returned if {@code num_outputs} is less than the number of graph outputs.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Graph_GetOutputs( @Const OrtGraph graph,
                    @Cast("const OrtValueInfo**") PointerPointer outputs, @Cast("size_t") long num_outputs);
  public native OrtStatus Graph_GetOutputs( @Const OrtGraph graph,
                    @Const @ByPtrPtr OrtValueInfo outputs, @Cast("size_t") long num_outputs);

  /** \brief Returns the number of graph initializers.
   *
   * Counts constant and non-constant initializers.
   *
   * @param graph [in] The OrtGraph instance.
   * @param num_initializers [out] Output parameter set to the number of graph initializers.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Graph_GetNumInitializers( @Const OrtGraph graph, @Cast("size_t*") SizeTPointer num_initializers);

  /** \brief Returns the graph's initializers as OrtValueInfo instances.
   *
   * Includes constant and non-constant initializers.
   *
   * For ONNX IR version < 4, all initializers are constant.
   *
   * For ONNX IR version >= 4, an initializer with a name that matches a graph input is considered a
   * non-constant initializer.
   *
   * Call ValueInfo_GetInitializerValue to get the initializer's data.
   *
   * @param graph [in] The OrtGraph instance.
   * @param initializers [out] Pre-allocated array of {@code num_outputs} elements that is filled with the initializers.
   * @param num_initializers [in] The size of the {@code initializers} array. Typical usage sets this to the
   *                             result of Graph_GetNumInitializers(). An error status is returned if
   *                            {@code num_initializers} is less than the number of graph initializers.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Graph_GetInitializers( @Const OrtGraph graph,
                    @Cast("const OrtValueInfo**") PointerPointer initializers,
                    @Cast("size_t") long num_initializers);
  public native OrtStatus Graph_GetInitializers( @Const OrtGraph graph,
                    @Const @ByPtrPtr OrtValueInfo initializers,
                    @Cast("size_t") long num_initializers);

  /** \brief Returns the number of graph nodes.
   *
   * @param graph [in] The OrtGraph instance.
   * @param num_nodes [out] Output parameter set to the number of graph nodes.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Graph_GetNumNodes( @Const OrtGraph graph, @Cast("size_t*") SizeTPointer num_nodes);

  /** \brief Returns the graph's nodes as OrtNode instances.
   *
   * The nodes are sorted using a stable topological ordering. Callers are responsible for maintaining their
   * own node ordering if a different order is required.
   *
   * @param graph [in] The OrtGraph instance.
   * @param nodes [out] Pre-allocated array of {@code num_nodes} elements that is filled with the graph's nodes.
   * @param num_nodes [in] The size of the {@code nodes} array. Typical usage sets this to the
   *                      result of Graph_GetNumNodes(). An error status is returned if
   *                      {@code num_nodes} is less than the number of graph nodes.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Graph_GetNodes( @Const OrtGraph graph,
                    @Cast("const OrtNode**") PointerPointer nodes, @Cast("size_t") long num_nodes);
  public native OrtStatus Graph_GetNodes( @Const OrtGraph graph,
                    @Const @ByPtrPtr OrtNode nodes, @Cast("size_t") long num_nodes);

  /** \brief Get the parent node for the given graph, if any exists.
   *
   * Certain operator types (e.g., If and Loop) contain nested subgraphs. This function enables
   * access to the parent node (e.g., the If and Loop node) from a nested subgraph.
   *
   * @param graph [in] The OrtGraph instance.
   * @param node [out] Output parameter that is set to the graph's parent node.
   *                  Set to NULL if a parent node does not exist (e.g., for a top-level graph).
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Graph_GetParentNode( @Const OrtGraph graph, @Cast("const OrtNode**") PointerPointer node);
  public native OrtStatus Graph_GetParentNode( @Const OrtGraph graph, @Const @ByPtrPtr OrtNode node);

  /** \brief Returns an OrtGraph that contains a subset of nodes in the source OrtGraph.
   *
   * \note The lifetime of "dst_graph" is tied to that of "src_graph", as they both internally reference
   * the same underlying graph.
   *
   * @param src_graph [in] The source OrtGraph instance.
   * @param nodes [in] A subset of the nodes/OrtNodes in 'graph'.
   * @param num_nodes [in] Number of nodes.
   * @param dst_graph [out] An OrtGraph created from a given set of nodes. Must be released by calling ReleaseGraph.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Graph_GetGraphView( @Const OrtGraph src_graph, @Cast("const OrtNode**") PointerPointer nodes,
                    @Cast("size_t") long num_nodes, @Cast("OrtGraph**") PointerPointer dst_graph);
  public native OrtStatus Graph_GetGraphView( @Const OrtGraph src_graph, @Const @ByPtrPtr OrtNode nodes,
                    @Cast("size_t") long num_nodes, @ByPtrPtr OrtGraph dst_graph);

  /** \}
   <p>
   *  \name OrtNode
   *  \{
  <p>
  /** \brief Returns a node's identifier.
   *
   * The node's identifier is only unique in the node's parent graph. Different nested subgraphs
   * (e.g., subgraphs contained by If and Loop nodes) may reuse identifiers.
   *
   * @param node [in] The OrtNode instance.
   * @param node_id [out] Output parameter set to the node's identifier.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetId( @Const OrtNode node, @Cast("size_t*") SizeTPointer node_id);

  /** \brief Returns a node's name. Can be an empty string.
   *
   * @param node [in] The OrtNode instance.
   * @param node_name [out] Output parameter set to the node's name.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetName( @Const OrtNode node, @Cast("const char**") PointerPointer node_name);
  public native OrtStatus Node_GetName( @Const OrtNode node, @Cast("const char**") @ByPtrPtr BytePointer node_name);
  public native OrtStatus Node_GetName( @Const OrtNode node, @Cast("const char**") @ByPtrPtr ByteBuffer node_name);
  public native OrtStatus Node_GetName( @Const OrtNode node, @Cast("const char**") @ByPtrPtr byte[] node_name);

  /** \brief Returns a node's operator type (e.g., "Conv").
   *
   * @param node [in] The OrtNode instance.
   * @param operator_type [out] Output parameter set to the name of the node's operator type.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetOperatorType( @Const OrtNode node, @Cast("const char**") PointerPointer operator_type);
  public native OrtStatus Node_GetOperatorType( @Const OrtNode node, @Cast("const char**") @ByPtrPtr BytePointer operator_type);
  public native OrtStatus Node_GetOperatorType( @Const OrtNode node, @Cast("const char**") @ByPtrPtr ByteBuffer operator_type);
  public native OrtStatus Node_GetOperatorType( @Const OrtNode node, @Cast("const char**") @ByPtrPtr byte[] operator_type);

  /** \brief Returns a node's domain name.
   *
   * @param node [in] The OrtNode instance.
   * @param domain_name [out] Output parameter set to the node's domain name.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetDomain( @Const OrtNode node, @Cast("const char**") PointerPointer domain_name);
  public native OrtStatus Node_GetDomain( @Const OrtNode node, @Cast("const char**") @ByPtrPtr BytePointer domain_name);
  public native OrtStatus Node_GetDomain( @Const OrtNode node, @Cast("const char**") @ByPtrPtr ByteBuffer domain_name);
  public native OrtStatus Node_GetDomain( @Const OrtNode node, @Cast("const char**") @ByPtrPtr byte[] domain_name);

  /** \brief Get the opset version in which the given node's operator type was first defined.
   *
   * @param node [in] The OrtNode instance.
   * @param since_version [out] The opset version in which the node's operator type was first defined.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetSinceVersion( @Const OrtNode node, IntPointer since_version);
  public native OrtStatus Node_GetSinceVersion( @Const OrtNode node, IntBuffer since_version);
  public native OrtStatus Node_GetSinceVersion( @Const OrtNode node, int[] since_version);

  /** \brief Returns the number of node inputs.
   *
   * @param node [in] The OrtNode instance.
   * @param num_inputs [out] Output parameter set to the number of node inputs.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetNumInputs( @Const OrtNode node, @Cast("size_t*") SizeTPointer num_inputs);

  /** \brief Returns the node's inputs as OrtValueInfo instances.
   *
   * @param node [in] The OrtNode instance.
   * @param inputs [out] Pre-allocated array of {@code num_inputs} elements that is filled with the node's inputs.
   * @param num_inputs [in] The size of the {@code inputs} array.
   *                       Typical usage sets this to the result of Node_GetNumInputs(). An error status is
   *                       returned if {@code num_inputs} is less than the number of node inputs.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetInputs( @Const OrtNode node,
                    @Cast("const OrtValueInfo**") PointerPointer inputs, @Cast("size_t") long num_inputs);
  public native OrtStatus Node_GetInputs( @Const OrtNode node,
                    @Const @ByPtrPtr OrtValueInfo inputs, @Cast("size_t") long num_inputs);

  /** \brief Returns the number of node outputs.
   *
   * @param node [in] The OrtNode instance.
   * @param num_outputs [out] Output parameter set to the number of node outputs.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetNumOutputs( @Const OrtNode node, @Cast("size_t*") SizeTPointer num_outputs);

  /** \brief Returns the node's outputs as OrtValueInfo instances.
   *
   * @param node [in] The OrtNode instance.
   * @param outputs [out] Pre-allocated array of {@code num_outputs} elements that is filled with the node's outputs.
   * @param num_outputs [in] The size of the {@code outputs} array.
   *                        Typical usage sets this to the result of Node_GetNumOutputs(). An error status is
   *                        returned if {@code num_outputs} is less than the number of node outputs.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetOutputs( @Const OrtNode node,
                    @Cast("const OrtValueInfo**") PointerPointer outputs, @Cast("size_t") long num_outputs);
  public native OrtStatus Node_GetOutputs( @Const OrtNode node,
                    @Const @ByPtrPtr OrtValueInfo outputs, @Cast("size_t") long num_outputs);

  /** \brief Returns the number of node implicit inputs.
   *
   * Certain operator types (e.g., If and Loop) contain nested subgraphs. The internal nodes within the nested subgraphs
   * may use values from the outer scope. Those "outer scope" values are considered implicit inputs to the node that
   * contains the subgraphs (e.g., the If or Loop node).
   *
   * @param node [in] The OrtNode instance.
   * @param num_implicit_inputs [out] Output parameter set to the number of node implicit inputs.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetNumImplicitInputs( @Const OrtNode node, @Cast("size_t*") SizeTPointer num_implicit_inputs);

  /** \brief Get the implicit inputs, as OrtValueInfo instances, that are used within the given node's subgraphs.
   *
   * \note Only certain operator types (e.g., If and Loop) contain nested subgraphs.
   * The internal nodes within the nested subgraphs may use values from the outer scope. Those "outer scope" values
   * are considered implicit inputs to the node that contains the subgraphs (e.g., the If or Loop node).
   *
   * @param node [in] The OrtNode instance.
   * @param implicit_inputs [out] Pre-allocated array of {@code num_implicit_inputs} elements that is filled the node's
   *                             implicit inputs.
   * @param num_implicit_inputs [in] The size of the {@code implicit_inputs} array. Typical usage sets this to the result
   *                                of Node_GetNumImplicitInputs(). An error status is returned if
   *                                {@code num_implicit_inputs} is less than the number of node implicit inputs.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetImplicitInputs( @Const OrtNode node,
                    @Cast("const OrtValueInfo**") PointerPointer implicit_inputs,
                    @Cast("size_t") long num_implicit_inputs);
  public native OrtStatus Node_GetImplicitInputs( @Const OrtNode node,
                    @Const @ByPtrPtr OrtValueInfo implicit_inputs,
                    @Cast("size_t") long num_implicit_inputs);

  /** \brief Returns the number of node attributes.
   *
   * @param node [in] The OrtNode instance.
   * @param num_attributes [out] Output parameter set to the number of node attributes.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetNumAttributes( @Const OrtNode node, @Cast("size_t*") SizeTPointer num_attributes);

  /** \brief Returns a node's attributes as OrtOpAttr instances.
   *
   * @param node [in] The OrtNode instance.
   * @param attributes [out] Pre-allocated array of {@code num_attributes} elements that is filled with the node's attributes.
   * @param num_attributes [in] The size of the {@code num_attributes} array.
   *                           Typical usage sets this to the result of Node_GetNumAttributes(). An error status is
   *                           returned if {@code num_attributes} is less than the number of node attributes.
   *
   * \note ONNX Runtime automatically sets optional (unset) attributes to their default values if the default value
   * is a constant expression that does not depend on other tensor/model characteristics. Conv's 'kernel_shape'
   * attribute is an example of an optional attribute that does not have a constant default value. This function
   * does not provide any unset optional attributes without a constant default value.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetAttributes( @Const OrtNode node,
                    @Cast("const OrtOpAttr**") PointerPointer attributes, @Cast("size_t") long num_attributes);
  public native OrtStatus Node_GetAttributes( @Const OrtNode node,
                    @Const @ByPtrPtr OrtOpAttr attributes, @Cast("size_t") long num_attributes);

  /** \brief Gets the OrtNode's attribute as OrtOpAttr by name.
   *
   * @param node [in] The OrtNode instance.
   * @param attribute_name [in] The name of the attribute
   * @param attribute [out] Output parameter set to the OrtOpAttr instance if an attribute by the given name exists.
   *                       For an unset optional attribute, {@code attribute} is set to NULL and a non-error status is
   *                       returned. For an invalid attribute name, {@code attribute} is set to NULL and an error status with
   *                       code ORT_NOT_FOUND is returned.
   *
   * \note ONNX Runtime automatically sets optional (unset) attributes to their default values if the default value
   * is a constant expression that does not depend on other tensor/model characteristics. Conv's 'kernel_shape'
   * attribute is an example of an optional attribute that does not have a constant default value. This function
   * does not provide any unset optional attributes without a constant default value.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetAttributeByName( @Const OrtNode node, @Cast("const char*") BytePointer attribute_name,
                    @Cast("const OrtOpAttr**") PointerPointer attribute);
  public native OrtStatus Node_GetAttributeByName( @Const OrtNode node, @Cast("const char*") BytePointer attribute_name,
                    @Const @ByPtrPtr OrtOpAttr attribute);
  public native OrtStatus Node_GetAttributeByName( @Const OrtNode node, String attribute_name,
                    @Const @ByPtrPtr OrtOpAttr attribute);

  /** \brief Get the OrtNode's 'TENSOR' attribute as an OrtValue.
   *
   * @param attribute [in] The OrtOpAttr instance.
   * @param attr_tensor [out] If successful, contains the 'TENSOR' attribute as a newly created OrtValue.
                             Must be freed with OrtApi::ReleaseValue.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus OpAttr_GetTensorAttributeAsOrtValue( @Const OrtOpAttr attribute,
                    @Cast("OrtValue**") PointerPointer attr_tensor);
  public native OrtStatus OpAttr_GetTensorAttributeAsOrtValue( @Const OrtOpAttr attribute,
                    @ByPtrPtr OrtValue attr_tensor);

  /** \brief Get the attribute type as OrtOpAttrType from an OrtOpAttr.
   *
   * @param attribute [in] The OrtOpAttr instance.
   * @param type [out] Output the attribute type as OrtOpAttrType.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus OpAttr_GetType( @Const OrtOpAttr attribute, @Cast("OrtOpAttrType*") IntPointer type);
  public native OrtStatus OpAttr_GetType( @Const OrtOpAttr attribute, @Cast("OrtOpAttrType*") IntBuffer type);
  public native OrtStatus OpAttr_GetType( @Const OrtOpAttr attribute, @Cast("OrtOpAttrType*") int[] type);

  /** \brief Get the attribute name from an OrtOpAttr.
   *
   * @param attribute [in] The OrtOpAttr instance.
   * @param name [out] Output parameter set to the attribute's name. The name is a null-terminated string.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus OpAttr_GetName( @Const OrtOpAttr attribute, @Cast("const char**") PointerPointer name);
  public native OrtStatus OpAttr_GetName( @Const OrtOpAttr attribute, @Cast("const char**") @ByPtrPtr BytePointer name);
  public native OrtStatus OpAttr_GetName( @Const OrtOpAttr attribute, @Cast("const char**") @ByPtrPtr ByteBuffer name);
  public native OrtStatus OpAttr_GetName( @Const OrtOpAttr attribute, @Cast("const char**") @ByPtrPtr byte[] name);

  /** \brief Returns the number of subgraphs contained by the given node.
   *
   * \note Only certain operator types (e.g., If and Loop) contain nested subgraphs.
   *
   * @param node [in] The OrtNode instance.
   * @param num_subgraphs [out] Output parameter set to the number of node subgraphs.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetNumSubgraphs( @Const OrtNode node, @Cast("size_t*") SizeTPointer num_subgraphs);

  /** \brief Get the subgraphs, as OrtGraph instances, contained by the given node.
   *
   * \note Only certain operator types (e.g., If and Loop) contain nested subgraphs. ONNX nodes store subgraphs in
   * their attributes, however, this function must be used to obtain subgraphs from an OrtNode.
   *
   * @param node [in] The OrtNode instance.
   * @param subgraphs [out] Pre-allocated array of {@code num_subgraphs} elements that is filled with the node's subgraphs.
   * @param num_subgraphs [in] The size of the {@code num_subgraphs} array.
   *                          Typical usage sets this to the result of Node_GetNumSubgraphs(). An error status is
   *                          returned if {@code num_subgraphs} is less than the number of node subgraphs.
   * @param attribute_names [out] Optional pre-allocated array of {@code num_subgraphs} elements that is filled with the
   *                             attribute names that correspond to the subgraphs. Ignored if set to NULL.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetSubgraphs( @Const OrtNode node,
                    @Cast("const OrtGraph**") PointerPointer subgraphs, @Cast("size_t") long num_subgraphs,
                    @Cast("const char**") PointerPointer attribute_names);
  public native OrtStatus Node_GetSubgraphs( @Const OrtNode node,
                    @Const @ByPtrPtr OrtGraph subgraphs, @Cast("size_t") long num_subgraphs,
                    @Cast("const char**") @ByPtrPtr BytePointer attribute_names);
  public native OrtStatus Node_GetSubgraphs( @Const OrtNode node,
                    @Const @ByPtrPtr OrtGraph subgraphs, @Cast("size_t") long num_subgraphs,
                    @Cast("const char**") @ByPtrPtr ByteBuffer attribute_names);
  public native OrtStatus Node_GetSubgraphs( @Const OrtNode node,
                    @Const @ByPtrPtr OrtGraph subgraphs, @Cast("size_t") long num_subgraphs,
                    @Cast("const char**") @ByPtrPtr byte[] attribute_names);

  /** \brief Get the node's parent OrtGraph instance.
   *
   * Can return NULL if the OrtNode was created without an owning graph.
   *
   * @param node [in] The OrtNode instance.
   * @param graph [out] Output parameter set to the node's OrtGraph. Can be set to NULL
   *                   if the node is not currently contained by a graph.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetGraph( @Const OrtNode node, @Cast("const OrtGraph**") PointerPointer graph);
  public native OrtStatus Node_GetGraph( @Const OrtNode node, @Const @ByPtrPtr OrtGraph graph);

  /** \brief Returns the execution provider name that this node is assigned to run on.
   *         Returns NULL if the node has not been assigned to any execution provider yet.
   *         For plugin execution providers, the name is the one returned by OrtEp::GetName.
   *
   * @param node [in] The OrtNode instance.
   * @param out [out] Output execution provider type and can be NULL if node has not been assigned.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Node_GetEpName( @Const OrtNode node, @Cast("const char**") PointerPointer out);
  public native OrtStatus Node_GetEpName( @Const OrtNode node, @Cast("const char**") @ByPtrPtr BytePointer out);
  public native OrtStatus Node_GetEpName( @Const OrtNode node, @Cast("const char**") @ByPtrPtr ByteBuffer out);
  public native OrtStatus Node_GetEpName( @Const OrtNode node, @Cast("const char**") @ByPtrPtr byte[] out);

  /** \}
   <p>
   *  \name OrtExternalInitializerInfo
   *  \{
  <p>
  /** \brief Release an OrtExternalInitializerInfo instance.
   *
   * @param input [in] OrtExternalInitializerInfo instance to be released.
   *
   * @since Version 1.23.
   */
  public native void ReleaseExternalInitializerInfo(OrtExternalInitializerInfo input);

  /** \brief Get the relative path to the file that stores the initializer's data.
   *
   * \note The path is relative to the filesystem directory where the ONNX model was stored.
   * Caller can use Graph_GetModelPath to get the model's full path and construct the absolute path to the
   * external initializer file if necessary.
   *
   * @param info [in] The OrtExternalInitializerInfo instance.
   * @return The relative path to the file that stores the initializer's data. Do NOT free this pointer.
   *
   * @since Version 1.23.
   */
  public static class ExternalInitializerInfo_GetFilePath_OrtExternalInitializerInfo extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    ExternalInitializerInfo_GetFilePath_OrtExternalInitializerInfo(Pointer p) { super(p); }
      protected ExternalInitializerInfo_GetFilePath_OrtExternalInitializerInfo() { allocate(); }
      private native void allocate();
      public native @Cast("const ORTCHAR_T*") Pointer call( @Const OrtExternalInitializerInfo info);
  }
  public native ExternalInitializerInfo_GetFilePath_OrtExternalInitializerInfo ExternalInitializerInfo_GetFilePath(); public native OrtApi ExternalInitializerInfo_GetFilePath(ExternalInitializerInfo_GetFilePath_OrtExternalInitializerInfo setter);

  /** \brief Get the byte offset within the file where the initializer's data is stored.
   *
   * @param info [in] The OrtExternalInitializerInfo instance.
   * @return The byte offset where the initializer's data is stored within the file.
   *
   * @since Version 1.23.
   */
  public static class ExternalInitializerInfo_GetFileOffset_OrtExternalInitializerInfo extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    ExternalInitializerInfo_GetFileOffset_OrtExternalInitializerInfo(Pointer p) { super(p); }
      protected ExternalInitializerInfo_GetFileOffset_OrtExternalInitializerInfo() { allocate(); }
      private native void allocate();
      public native @Cast("int64_t") long call( @Const OrtExternalInitializerInfo info);
  }
  public native ExternalInitializerInfo_GetFileOffset_OrtExternalInitializerInfo ExternalInitializerInfo_GetFileOffset(); public native OrtApi ExternalInitializerInfo_GetFileOffset(ExternalInitializerInfo_GetFileOffset_OrtExternalInitializerInfo setter);

  /** \brief Get the size in bytes of the initializer's data within the file.
   *
   * @param info [in] The OrtExternalInitializerInfo instance.
   * @return The size in bytes of the initializer's data within the file.
   *
   * @since Version 1.23.
   */
  public static class ExternalInitializerInfo_GetByteSize_OrtExternalInitializerInfo extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    ExternalInitializerInfo_GetByteSize_OrtExternalInitializerInfo(Pointer p) { super(p); }
      protected ExternalInitializerInfo_GetByteSize_OrtExternalInitializerInfo() { allocate(); }
      private native void allocate();
      public native @Cast("size_t") long call( @Const OrtExternalInitializerInfo info);
  }
  public native ExternalInitializerInfo_GetByteSize_OrtExternalInitializerInfo ExternalInitializerInfo_GetByteSize(); public native OrtApi ExternalInitializerInfo_GetByteSize(ExternalInitializerInfo_GetByteSize_OrtExternalInitializerInfo setter);

  /** \}
   <p>
   *  \name OrtRunOptions
   *  \{
  <p>
  /** \brief Get a run configuration entry.
   *
   * If a run configuration entry with key {@code config_key} doesn't exist, {@code config_value} will be set to NULL.
   *
   * {@code config_key}s are defined in onnxruntime_run_options_config_keys.h.
   *
   * @param options [in] The OrtRunOptions instance.
   * @param config_key [in] The configuration entry key. A null-terminated string.
   * @return The configuration entry value. Either a null-terminated string if the entry was found. nullptr otherwise.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23
   */
  public static class GetRunConfigEntry_OrtRunOptions_BytePointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    GetRunConfigEntry_OrtRunOptions_BytePointer(Pointer p) { super(p); }
      protected GetRunConfigEntry_OrtRunOptions_BytePointer() { allocate(); }
      private native void allocate();
      public native @Cast("const char*") BytePointer call( @Const OrtRunOptions options,
              @Cast("const char*") BytePointer config_key);
  }
  public native GetRunConfigEntry_OrtRunOptions_BytePointer GetRunConfigEntry(); public native OrtApi GetRunConfigEntry(GetRunConfigEntry_OrtRunOptions_BytePointer setter);

  /** \}
  <p>
  /** \brief Get the OrtMemoryInfo for the device.
   *
   * @param ep_device [in] The OrtEpDevice instance to query.
   * @param memory_type [in] The memory type to return.
   * @return A pointer to the OrtMemoryInfo for the device. This may be nullptr if not set.
   *         If memory_type is OrtDeviceMemoryType_DEFAULT and nullptr is returned the EP uses CPU memory.
   *
   * @since Version 1.23
   */
  public static class EpDevice_MemoryInfo_OrtEpDevice_int extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    EpDevice_MemoryInfo_OrtEpDevice_int(Pointer p) { super(p); }
      protected EpDevice_MemoryInfo_OrtEpDevice_int() { allocate(); }
      private native void allocate();
      public native @Const OrtMemoryInfo call( @Const OrtEpDevice ep_device,
              @Cast("OrtDeviceMemoryType") int memory_type);
  }
  public native EpDevice_MemoryInfo_OrtEpDevice_int EpDevice_MemoryInfo(); public native OrtApi EpDevice_MemoryInfo(EpDevice_MemoryInfo_OrtEpDevice_int setter);

  /** \brief Create/replace a shared allocator for the OrtEpDevice in the OrtEnv.
   *
   * OrtEpDevice maps to the EP factory, and the factory provides the allocator implementation.
   *
   * Both OrtDeviceMemoryType_DEFAULT and OrtDeviceMemoryType_HOST_ACCESSIBLE are optional for an EP to provide.
   * It is EP implementation dependent as to what is available.
   *
   * If a shared allocator already exists for the OrtEpDevice and OrtDeviceMemoryType, it is replaced. This allows
   * changing the shared allocator configuration from the default. e.g. adding an arena.
   *
   * @param env [in] The OrtEnv instance to create the shared allocator in.
   * @param ep_device [in] The OrtEpDevice instance to create the shared allocator for.
   * @param mem_type [in] The memory type to use for the shared allocator.
   * @param allocator_type [in] The type of allocator to create. Only OrtDeviceAllocator is valid currently.
   * @param allocator_options [in] Optional key-value pairs to configure the allocator. If arena based, see
   *                              include/onnxruntime/core/framework/allocator.h for the keys and values that can be
   *                              used.
   * @param allocator [out] A pointer to the created shared allocator. Owned by the OrtEnv instance.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23
   */
  public native OrtStatus CreateSharedAllocator( OrtEnv env, @Const OrtEpDevice ep_device,
                    @Cast("OrtDeviceMemoryType") int mem_type, @Cast("OrtAllocatorType") int allocator_type,
                    @Const OrtKeyValuePairs allocator_options,
                    @Cast("OrtAllocator**") PointerPointer allocator);
  public native OrtStatus CreateSharedAllocator( OrtEnv env, @Const OrtEpDevice ep_device,
                    @Cast("OrtDeviceMemoryType") int mem_type, @Cast("OrtAllocatorType") int allocator_type,
                    @Const OrtKeyValuePairs allocator_options,
                    @ByPtrPtr OrtAllocator allocator);

  /** \brief Get a shared allocator from the OrtEnv.
   *
   * By default there is a shared allocator created for all OrtEpDevice instances, so if you get the OrtMemoryInfo
   * from the OrtEpDevice using EpDevice_MemoryInfo a shared allocator is guaranteed to exist.
   *
   * This will also match and return custom allocators added with RegisterAllocator.
   *
   * It is not an error to not find a matching allocator.
   *
   * @param env [in] The OrtEnv instance to get the shared allocator from.
   * @param mem_info [in] The OrtMemoryInfo instance to get the shared allocator for.
   * @param allocator [out] A pointer to the shared allocator, or nullptr if no shared allocator exists for
   *                       the given memory info.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23
   */
  public native OrtStatus GetSharedAllocator( OrtEnv env, @Const OrtMemoryInfo mem_info,
                    @Cast("OrtAllocator**") PointerPointer allocator);
  public native OrtStatus GetSharedAllocator( OrtEnv env, @Const OrtMemoryInfo mem_info,
                    @ByPtrPtr OrtAllocator allocator);

  /** \brief Release a shared allocator from the OrtEnv for the OrtEpDevice and memory type.
   *
   * This will release the shared allocator for the given OrtEpDevice and memory type.
   * If no shared allocator exists, this is a no-op.
   *
   * @param env [in] The OrtEnv instance to release the shared allocator from.
   * @param ep_device [in] The OrtEpDevice instance to release the shared allocator for.
   * @param mem_type [in] The memory type of the shared allocator to release.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23
   */
  public native OrtStatus ReleaseSharedAllocator( OrtEnv env, @Const OrtEpDevice ep_device,
                    @Cast("OrtDeviceMemoryType") int mem_type);

  /** \brief Get a const pointer to the raw data inside a tensor
   *
   * Used to read the internal tensor data directly.
   * \note The returned pointer is valid until the OrtValue is destroyed.
   *
   * @param value [in] A tensor type (string tensors are not supported)
   * @param out [out] Filled in with a pointer to the internal storage
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23
   */
  public native OrtStatus GetTensorData( @Const OrtValue value, @Cast("const void**") PointerPointer out);
  public native OrtStatus GetTensorData( @Const OrtValue value, @Cast("const void**") @ByPtrPtr Pointer out);

  /** \brief Get Session configuration entries.
   *
   * @param options [in] The session options.
   * @param out [out] A pointer to a newly created OrtKeyValuePairs instance.
   *
   *  An OrtKeyValuePairs instance containing all session configuration entries.
   *  Note: the user should call OrtApi::ReleaseKeyValuePairs.
   *
   * @since Version 1.23.
   */
  public native OrtStatus GetSessionOptionsConfigEntries( @Const OrtSessionOptions options, @Cast("OrtKeyValuePairs**") PointerPointer out);
  public native OrtStatus GetSessionOptionsConfigEntries( @Const OrtSessionOptions options, @ByPtrPtr OrtKeyValuePairs out);

  /** \brief Get the OrtMemoryInfo for each input of the session.
   *
   * The memory info can be used to determine where the input tensors are required.
   *
   * The session must be fully initialized before calling this function as the input locations are not known until
   * this has occurred.
   *
   * @param session [in] The OrtSession instance.
   * @param inputs_memory_info [out] Pre-allocated array of size {@code num_inputs} that will be filled with the
   *                                OrtMemoryInfo* value for each input.
   *                                The order is the same as returned by SessionGetInputName.
   * @param num_inputs [in] The number of inputs in the session. Must match SessionGetInputCount.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23
   */
  public native OrtStatus SessionGetMemoryInfoForInputs( @Const OrtSession session,
                    @Cast("const OrtMemoryInfo**") PointerPointer inputs_memory_info,
                    @Cast("size_t") long num_inputs);
  public native OrtStatus SessionGetMemoryInfoForInputs( @Const OrtSession session,
                    @Const @ByPtrPtr OrtMemoryInfo inputs_memory_info,
                    @Cast("size_t") long num_inputs);

  /** \brief Get the OrtMemoryInfo for each output of the session.
   *
   * The memory info can be used to determine the device the output tensors are produced on.
   * The user can pre-allocate an OrtValue using this information or use IOBinding to keep the data on the device.
   * ORT will copy the output to CPU otherwise.
   *
   * The session must be fully initialized before calling this function as the output locations are not known until
   * this has occurred.
   *
   * @param session [in] The OrtSession instance.
   * @param outputs_memory_info [out] Pre-allocated array of size {@code num_outputs} that will be filled with
   *                                 OrtMemoryInfo* values for each output.
   *                                 The order is the same as returned by SessionGetOutputName.
   * @param num_outputs [in] The number of outputs in the session. Must match SessionGetOutputCount.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23
   */
  public native OrtStatus SessionGetMemoryInfoForOutputs( @Const OrtSession session,
                    @Cast("const OrtMemoryInfo**") PointerPointer outputs_memory_info,
                    @Cast("size_t") long num_outputs);
  public native OrtStatus SessionGetMemoryInfoForOutputs( @Const OrtSession session,
                    @Const @ByPtrPtr OrtMemoryInfo outputs_memory_info,
                    @Cast("size_t") long num_outputs);

  /** \brief Get the OrtEpDevice (if available) for each input of the session.
   *
   * An OrtEpDevice will be available if auto EP selection is enabled by calling
   * SessionOptionsSetEpSelectionPolicy or SessionOptionsSetEpSelectionPolicyDelegate,
   * or if the OrtEpDevice was manually added to the session using SessionOptionsAppendExecutionProvider_V2.
   *
   * If an OrtEpDevice is not available for the input a nullptr is returned.
   *
   * The returned OrtEpDevice can be used to create an OrtSyncStream via CreateSyncStreamForEpDevice to asynchronously
   * provide input to the inference session Run.
   *
   * The session must be fully initialized before calling this function as the assigned EPs are not known until
   * this has occurred.
   *
   * @param session [in] The OrtSession instance.
   * @param inputs_ep_devices [out] Pre-allocated array of size {@code num_inputs} that will be filled with
   *                               OrtEpDevice* values for each input.
   *                               The order is the same as returned by SessionGetInputName.
   * @param num_inputs [in] The number of inputs in the session. Must match SessionGetInputCount.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23
   */
  public native OrtStatus SessionGetEpDeviceForInputs( @Const OrtSession session,
                    @Cast("const OrtEpDevice**") PointerPointer inputs_ep_devices,
                    @Cast("size_t") long num_inputs);
  public native OrtStatus SessionGetEpDeviceForInputs( @Const OrtSession session,
                    @Const @ByPtrPtr OrtEpDevice inputs_ep_devices,
                    @Cast("size_t") long num_inputs);

  /** \brief Create an OrtSyncStream for the given OrtEpDevice.
   *
   * The OrtSyncStream can be used to enable asynchronous operations.
   * e.g. async usage of CopyTensors to provide input to an OrtSession Run call.
   *
   * An error code of ORT_NOT_IMPLEMENTED will be returned if the EP does not support OrtSyncStream.
   *
   * @param ep_device [in] The OrtEpDevice instance to create the sync stream for.
   * @param stream_options [in] Options for OrtSyncStream creation. May be nullptr.
   * @param stream [out] Output parameter set to the created OrtSyncStream instance.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23
   */
  public native OrtStatus CreateSyncStreamForEpDevice( @Const OrtEpDevice ep_device,
                    @Const OrtKeyValuePairs stream_options,
                    @Cast("OrtSyncStream**") PointerPointer stream);
  public native OrtStatus CreateSyncStreamForEpDevice( @Const OrtEpDevice ep_device,
                    @Const OrtKeyValuePairs stream_options,
                    @ByPtrPtr OrtSyncStream stream);

  /** \brief Get the native handle of the sync stream.
   *
   * This returns the native handle for the stream. e.g. cudaStream_t for CUDA streams.
   *
   * @param stream [in] The OrtSyncStream instance to get the handle from.
   *
   * @return The native handle of the stream.
   *
   * @since Version 1.23
   */
  public static class SyncStream_GetHandle_OrtSyncStream extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    SyncStream_GetHandle_OrtSyncStream(Pointer p) { super(p); }
      protected SyncStream_GetHandle_OrtSyncStream() { allocate(); }
      private native void allocate();
      public native Pointer call( OrtSyncStream stream);
  }
  public native SyncStream_GetHandle_OrtSyncStream SyncStream_GetHandle(); public native OrtApi SyncStream_GetHandle(SyncStream_GetHandle_OrtSyncStream setter);

  public native void ReleaseSyncStream(OrtSyncStream input);

  /** \brief Copy OrtValue instances containing Tensors between devices.
   *
   * The overall copy must be between a single source device and a single destination device. i.e.
   *   - all src_tensors must have matching OrtMemoryInfo,
   *   - all dst_tensors must have matching OrtMemoryInfo.
   *
   * OrtValue instances can be created by:
   *   - Use GetSharedAllocator to get the shared allocator for the OrtMemoryInfo if you need to allocate memory
   *     on the device.
   *   - Use CreateTensorAsOrtValue, CreateTensorWithDataAsOrtValue or CreateTensorWithDataAndDeleterAsOrtValue
   *     to create an OrtValue containing a tensor depending on whether you have existing data or not, and whether
   *     you want ORT to free the existing data once it is done with the OrtValue.
   *
   * @param env [in] The OrtEnv instance to use. The data transfer implementation is provided by an execution provider
   *                that is registered in this OrtEnv.
   * @param src_tensors [in] Array of OrtValue instances containing the source tensors to copy.
   * @param dst_tensors [in] Array of OrtValue instances to copy the source tensors to.
   * @param stream [in] Optional OrtSyncStream that can be used to perform the copy asynchronously. May be nullptr.
   * @param num_tensors [in] The number of tensors to copy. The size of {@code src_tensors} and {@code dst_tensors} must match.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23
   */
  public native OrtStatus CopyTensors( @Const OrtEnv env,
                    @Cast("const OrtValue*const*") PointerPointer src_tensors,
                    @Cast("OrtValue*const*") PointerPointer dst_tensors,
                    OrtSyncStream stream,
                    @Cast("size_t") long num_tensors);
  public native OrtStatus CopyTensors( @Const OrtEnv env,
                    @Const @ByPtrPtr OrtValue src_tensors,
                    @ByPtrPtr OrtValue dst_tensors,
                    OrtSyncStream stream,
                    @Cast("size_t") long num_tensors);

  /** \brief Get ::OrtModelMetadata from an ::OrtGraph
   *
   * @param graph [in] The OrtGraph instance.
   * @param out [out] Newly created ::OrtModelMetadata. Must be freed using OrtApi::ReleaseModelMetadata.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus Graph_GetModelMetadata( @Const OrtGraph graph, @Cast("OrtModelMetadata**") PointerPointer out);
  public native OrtStatus Graph_GetModelMetadata( @Const OrtGraph graph, @ByPtrPtr OrtModelMetadata out);

  /** \brief Validate a compiled model's compatibility information for one or more EP devices.
   *
   * @param ep_devices [in] The EP devices to validate against (e.g., from GetEpDevices).
   *                        All devices must belong to the same execution provider.
   * @param num_ep_devices [in] The number of EP devices provided.
   * @param compatibility_info [in] The compatibility info string produced when the model was compiled.
   * @param out_status [out] The resulting compatibility status for the EP devices.
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus GetModelCompatibilityForEpDevices(
                    @Cast("const OrtEpDevice*const*") PointerPointer ep_devices,
                    @Cast("size_t") long num_ep_devices,
                    @Cast("const char*") BytePointer compatibility_info,
                    @Cast("OrtCompiledModelCompatibility*") IntPointer out_status);
  public native OrtStatus GetModelCompatibilityForEpDevices(
                    @Const @ByPtrPtr OrtEpDevice ep_devices,
                    @Cast("size_t") long num_ep_devices,
                    @Cast("const char*") BytePointer compatibility_info,
                    @Cast("OrtCompiledModelCompatibility*") IntPointer out_status);
  public native OrtStatus GetModelCompatibilityForEpDevices(
                    @Const @ByPtrPtr OrtEpDevice ep_devices,
                    @Cast("size_t") long num_ep_devices,
                    String compatibility_info,
                    @Cast("OrtCompiledModelCompatibility*") IntBuffer out_status);
  public native OrtStatus GetModelCompatibilityForEpDevices(
                    @Const @ByPtrPtr OrtEpDevice ep_devices,
                    @Cast("size_t") long num_ep_devices,
                    @Cast("const char*") BytePointer compatibility_info,
                    @Cast("OrtCompiledModelCompatibility*") int[] out_status);
  public native OrtStatus GetModelCompatibilityForEpDevices(
                    @Const @ByPtrPtr OrtEpDevice ep_devices,
                    @Cast("size_t") long num_ep_devices,
                    String compatibility_info,
                    @Cast("OrtCompiledModelCompatibility*") IntPointer out_status);
  public native OrtStatus GetModelCompatibilityForEpDevices(
                    @Const @ByPtrPtr OrtEpDevice ep_devices,
                    @Cast("size_t") long num_ep_devices,
                    @Cast("const char*") BytePointer compatibility_info,
                    @Cast("OrtCompiledModelCompatibility*") IntBuffer out_status);
  public native OrtStatus GetModelCompatibilityForEpDevices(
                    @Const @ByPtrPtr OrtEpDevice ep_devices,
                    @Cast("size_t") long num_ep_devices,
                    String compatibility_info,
                    @Cast("OrtCompiledModelCompatibility*") int[] out_status);

  /** \name OrtExternalInitializerInfo
   *  \{
  <p>
  /** \brief Creates an OrtExternalInitializerInfo instance.
   *
   * @param filepath [in] The relative path to the file that stores the initializer's data. ORT copies this path string.
   * @param file_offset [in] The byte offset where the initializer's data is stored within the file.
   * @param byte_size [in] The size in bytes of the initializer's data within the file.
   * @param out [out] Output parameter set to the new OrtExternalInitializerInfo instance.
   *                 Must be released by calling ReleaseExternalInitializerInfo().
   *
   * \snippet{doc} snippets.dox OrtStatus Return Value
   *
   * @since Version 1.23.
   */
  public native OrtStatus CreateExternalInitializerInfo( @Cast("const ORTCHAR_T*") Pointer filepath, @Cast("int64_t") long file_offset,
                    @Cast("size_t") long byte_size, @Cast("OrtExternalInitializerInfo**") PointerPointer out);
  public native OrtStatus CreateExternalInitializerInfo( @Cast("const ORTCHAR_T*") Pointer filepath, @Cast("int64_t") long file_offset,
                    @Cast("size_t") long byte_size, @ByPtrPtr OrtExternalInitializerInfo out);

  /** \} */
}
