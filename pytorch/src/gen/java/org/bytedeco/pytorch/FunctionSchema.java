// Targeted by JavaCPP version 1.5.7: DO NOT EDIT THIS FILE

package org.bytedeco.pytorch;

import org.bytedeco.pytorch.Allocator;
import org.bytedeco.pytorch.Function;
import org.bytedeco.pytorch.Module;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;

import static org.bytedeco.pytorch.global.torch.*;


@Namespace("c10") @NoOffset @Properties(inherit = org.bytedeco.pytorch.presets.torch.class)
public class FunctionSchema extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FunctionSchema(Pointer p) { super(p); }

  public FunctionSchema(
        @StdString BytePointer name,
        @StdString BytePointer overload_name,
        @StdVector Argument arguments,
        @StdVector Argument returns,
        @Cast("bool") boolean is_vararg/*=false*/,
        @Cast("bool") boolean is_varret/*=false*/) { super((Pointer)null); allocate(name, overload_name, arguments, returns, is_vararg, is_varret); }
  private native void allocate(
        @StdString BytePointer name,
        @StdString BytePointer overload_name,
        @StdVector Argument arguments,
        @StdVector Argument returns,
        @Cast("bool") boolean is_vararg/*=false*/,
        @Cast("bool") boolean is_varret/*=false*/);
  public FunctionSchema(
        @StdString BytePointer name,
        @StdString BytePointer overload_name,
        @StdVector Argument arguments,
        @StdVector Argument returns) { super((Pointer)null); allocate(name, overload_name, arguments, returns); }
  private native void allocate(
        @StdString BytePointer name,
        @StdString BytePointer overload_name,
        @StdVector Argument arguments,
        @StdVector Argument returns);
  public FunctionSchema(
        @StdString String name,
        @StdString String overload_name,
        @StdVector Argument arguments,
        @StdVector Argument returns,
        @Cast("bool") boolean is_vararg/*=false*/,
        @Cast("bool") boolean is_varret/*=false*/) { super((Pointer)null); allocate(name, overload_name, arguments, returns, is_vararg, is_varret); }
  private native void allocate(
        @StdString String name,
        @StdString String overload_name,
        @StdVector Argument arguments,
        @StdVector Argument returns,
        @Cast("bool") boolean is_vararg/*=false*/,
        @Cast("bool") boolean is_varret/*=false*/);
  public FunctionSchema(
        @StdString String name,
        @StdString String overload_name,
        @StdVector Argument arguments,
        @StdVector Argument returns) { super((Pointer)null); allocate(name, overload_name, arguments, returns); }
  private native void allocate(
        @StdString String name,
        @StdString String overload_name,
        @StdVector Argument arguments,
        @StdVector Argument returns);

  public FunctionSchema(
        @ByVal Symbol name,
        @StdString BytePointer overload_name,
        @StdVector Argument arguments,
        @StdVector Argument returns,
        @Cast("bool") boolean is_vararg/*=false*/,
        @Cast("bool") boolean is_varret/*=false*/) { super((Pointer)null); allocate(name, overload_name, arguments, returns, is_vararg, is_varret); }
  private native void allocate(
        @ByVal Symbol name,
        @StdString BytePointer overload_name,
        @StdVector Argument arguments,
        @StdVector Argument returns,
        @Cast("bool") boolean is_vararg/*=false*/,
        @Cast("bool") boolean is_varret/*=false*/);
  public FunctionSchema(
        @ByVal Symbol name,
        @StdString BytePointer overload_name,
        @StdVector Argument arguments,
        @StdVector Argument returns) { super((Pointer)null); allocate(name, overload_name, arguments, returns); }
  private native void allocate(
        @ByVal Symbol name,
        @StdString BytePointer overload_name,
        @StdVector Argument arguments,
        @StdVector Argument returns);
  public FunctionSchema(
        @ByVal Symbol name,
        @StdString String overload_name,
        @StdVector Argument arguments,
        @StdVector Argument returns,
        @Cast("bool") boolean is_vararg/*=false*/,
        @Cast("bool") boolean is_varret/*=false*/) { super((Pointer)null); allocate(name, overload_name, arguments, returns, is_vararg, is_varret); }
  private native void allocate(
        @ByVal Symbol name,
        @StdString String overload_name,
        @StdVector Argument arguments,
        @StdVector Argument returns,
        @Cast("bool") boolean is_vararg/*=false*/,
        @Cast("bool") boolean is_varret/*=false*/);
  public FunctionSchema(
        @ByVal Symbol name,
        @StdString String overload_name,
        @StdVector Argument arguments,
        @StdVector Argument returns) { super((Pointer)null); allocate(name, overload_name, arguments, returns); }
  private native void allocate(
        @ByVal Symbol name,
        @StdString String overload_name,
        @StdVector Argument arguments,
        @StdVector Argument returns);

  // Checks whether this schema is backward compatible with the old one.
  // The following conditions must be true:
  // [Function structure] The new schema's name, overload-name, varargs, and
  //      return arity are the same.
  // [Output Narrowing] The new schema's output type must be the same class
  //      or inherit from the old schema's output type.
  // [Argument count] The new schema must have at least as many arguments as
  //      the old schema (considering the list of positional and kwargs).
  // [Arg Compatibility] Every argument in the old schema has a corresponding
  //      argument in the new schema that:
  //        * is at the same position.
  //        * has the same name.
  //        * is either positional, or kwarg and the old argument was kwarg.
  //        * has the same type, or the old argument's type inherits from the
  //          new argument's type.
  // [Default Values] Every new argument must have a default value.
  // E.g.
  //   OK    f_new(a, b, c=1) => f_old(a, b)
  //   NOK   f_new(a, c=1, *, b) => f_old(a, *, b)
  //   OK    f_new(a, b, *, c) => f_old(a, *, b, c)
  //   NOK   f_new(a, *, b, c) -> f_old(a, b, *, c)
  //   NOK   f_new(a, *, c, b) => f_old(a, *, b, c)
  //   OK    f_new(a, *, b, c, d=1) => f_old(a, *, b, c)
  public native @Cast("bool") boolean isBackwardCompatibleWith(
        @Const @ByRef FunctionSchema old,
        @Cast("std::ostream*") Pointer why_not/*=nullptr*/);
  public native @Cast("bool") boolean isBackwardCompatibleWith(
        @Const @ByRef FunctionSchema old);

  

  public native @Const @ByRef OperatorName operator_name();
  public native @StdString BytePointer name();
  public native @StdString BytePointer overload_name();
  public native @StdVector Argument arguments();
  public native @StdVector Argument returns();
  public native @Cast("bool") boolean is_vararg();
  public native @Cast("bool") boolean is_varret();
  public native @Cast("bool") boolean is_mutable();

  public native @ByVal IntOptional argumentIndexWithName(@ByVal @Cast("c10::string_view*") Pointer name);
  public native @ByVal FunctionSchema cloneWithName(@StdString BytePointer name, @StdString BytePointer overload_name);
  public native @ByVal FunctionSchema cloneWithName(@StdString String name, @StdString String overload_name);
  public native @ByVal FunctionSchema cloneWithArguments(@StdVector Argument new_arguments);
  public native @ByVal FunctionSchema cloneWithReturns(@StdVector Argument new_returns);

  public native @StdString BytePointer formatTypeMismatchMsg(
        @Const @ByRef Argument expected,
        @StdString BytePointer actual_type,
        @ByVal(nullValue = "c10::optional<size_t>(c10::nullopt)") SizeTOptional _position,
        @ByVal(nullValue = "c10::optional<std::string>(c10::nullopt)") StringOptional value);
  public native @StdString BytePointer formatTypeMismatchMsg(
        @Const @ByRef Argument expected,
        @StdString BytePointer actual_type);
  public native @StdString String formatTypeMismatchMsg(
        @Const @ByRef Argument expected,
        @StdString String actual_type,
        @ByVal(nullValue = "c10::optional<size_t>(c10::nullopt)") SizeTOptional _position,
        @ByVal(nullValue = "c10::optional<std::string>(c10::nullopt)") StringOptional value);
  public native @StdString String formatTypeMismatchMsg(
        @Const @ByRef Argument expected,
        @StdString String actual_type);

  public native @ByVal FunctionSchema cloneWithRemappedTypes(
        @Const @ByVal TypeMapper type_map);

  // Check that inputs have the correct types and appends any missing default
  // values.
  public native void checkAndNormalizeInputs(
        @ByRef IValueVector inputs,
        @Const @ByRef(nullValue = "std::unordered_map<std::string,c10::IValue>(std::unordered_map<std::string, c10::IValue>{})") StringIValueMap kwargs);
  public native void checkAndNormalizeInputs(
        @ByRef IValueVector inputs);

  public native @StdString BytePointer findErrorInKwargs(@Const @ByRef StringVector kwargs);

  public native @Cast("bool") boolean hasAnyAliasInfo();


  // TODO remove the mutation here
  public native @Cast("bool") boolean isDefaultAliasAnalysisKind();
  public native @ByVal AliasAnalysisKind aliasAnalysis();
  public native void setAliasAnalysis(@ByVal AliasAnalysisKind v);

  public native @ByVal @Cast("c10::optional<c10::string_view>*") Pointer getNamespace();

  // Returns true if we successfully set the namespace (as there
  // was none set, and false otherwise)
  public native @Cast("bool") boolean setNamespaceIfNotSet(@Cast("const char*") BytePointer ns);
  public native @Cast("bool") boolean setNamespaceIfNotSet(String ns);

  // can a function with this schema be substituted for a function of rhs's
  // schema and have the program typecheck?
  // as_method - if true, treat this schema as a method and ignore
  // the first argument, which will be the object in both cases
  public native @Cast("bool") boolean isSubtypeOf(@Const @ByRef FunctionSchema rhs, @Cast("bool") boolean as_method, @Cast("std::ostream*") Pointer why_not/*=nullptr*/);
  public native @Cast("bool") boolean isSubtypeOf(@Const @ByRef FunctionSchema rhs, @Cast("bool") boolean as_method);
}
