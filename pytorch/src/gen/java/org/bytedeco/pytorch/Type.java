// Targeted by JavaCPP version 1.5.7: DO NOT EDIT THIS FILE

package org.bytedeco.pytorch;

import org.bytedeco.pytorch.Allocator;
import org.bytedeco.pytorch.Function;
import org.bytedeco.pytorch.Module;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;

import static org.bytedeco.pytorch.global.torch.*;


@Namespace("c10") @NoOffset @Properties(inherit = org.bytedeco.pytorch.presets.torch.class)
public class Type extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Type(Pointer p) { super(p); }

  

  // subtyping relation. By default, we return true for the case
  // when the type is exactly equal or if this <: T where rhs = Optional[T]

  // if this returns false and the why_not stream is non-null, it contains
  // additional details that describe why this is not a subtype of 'rhs'.
  // This additional information should only contain details that are not obvious
  // from the annotation_str() that describes the type. For instance it is clear that `int <: str` is false
  // but not clear why `Foo <: InterfaceBar` might be false.
  public native @Cast("bool") boolean isSubtypeOfExt(@Const @SharedPtr @ByRef Type rhs, @Cast("std::ostream*") Pointer why_not);
  public native @Cast("bool") boolean is_module();
  public native @Cast("bool") boolean isSubtypeOf(@Const @SharedPtr @ByRef Type rhs);

  // How this type will appear in FunctionSchema declarations
  public native @StdString BytePointer str();

  // How this type will appear as if it were a type annotation in Python
  // which is sometimes different than how it appears in declarations (e.g.
  // int[] vs List[int])
  //
  // Takes a custom printer that users can pass in to customize the output of
  // this method.
  public native @StdString BytePointer annotation_str(@ByVal @Cast("c10::TypePrinter*") Pointer printer);
  public native @StdString BytePointer annotation_str();

  // Returns a human readable string that includes additional information like
  // "type is inferred rather than explictly defined" to help construct more
  // user-friendly messages.
  public native @StdString BytePointer repr_str();

  public native TypeKind kind();

  public native @Cast("bool") boolean requires_grad();

  // Dynamically cast this object to the subclass indicated by the
  // template variable, returning nullptr if the cast is invalid.
  public native @Cast("bool") boolean hasFreeVariables();
  // list of types this type contains, e.g. for a List then element type of a
  // list for a tuple, the types of the tuple elements
  public native @ByVal TypeArrayRef containedTypes();
  // create a new version of this type, replacing its contained types with
  // contained_types
  public native @SharedPtr @ByVal Type withContained(@ByVal TypeVector contained_types);
  // per-type constructor, you only need to override this if the
  // containedTypes() is not empty
  public native @SharedPtr @ByVal Type createWithContained(
        @ByVal TypeVector contained_types);
}
