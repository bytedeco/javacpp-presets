// Targeted by JavaCPP version 1.5.11-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.pytorch.cuda;

import org.bytedeco.pytorch.*;
import org.bytedeco.pytorch.helper.*;
import org.bytedeco.cuda.cudart.*;
import org.bytedeco.cuda.cusparse.*;
import org.bytedeco.cuda.cublas.*;
import org.bytedeco.cuda.cusolver.*;
import org.bytedeco.cuda.cudnn.*;
import org.bytedeco.pytorch.functions.*;
import org.bytedeco.pytorch.cuda.functions.*;
import org.bytedeco.pytorch.chrono.*;
import org.bytedeco.pytorch.global.torch.DeviceType;
import org.bytedeco.pytorch.global.torch.ScalarType;
import org.bytedeco.pytorch.global.torch.MemoryFormat;
import org.bytedeco.pytorch.Allocator;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;
import org.bytedeco.pytorch.*;
import static org.bytedeco.pytorch.global.torch.*;

import static org.bytedeco.pytorch.global.torch_cuda.*;


/*
* CUDAEvents are movable not copyable wrappers around CUDA's events.
*
* CUDAEvents are constructed lazily when first recorded unless it is
* reconstructed from a cudaIpcEventHandle_t. The event has a device, and this
* device is acquired from the first recording stream. However, if reconstructed
* from a handle, the device should be explicitly specified; or if ipc_handle() is
* called before the event is ever recorded, it will use the current device.
* Later streams that record the event must match this device.
*/
@Namespace("at::cuda") @NoOffset @Properties(inherit = org.bytedeco.pytorch.presets.torch_cuda.class)
public class CUDAEvent extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CUDAEvent(Pointer p) { super(p); }

  // Constructors
  // Default value for `flags` is specified below - it's cudaEventDisableTiming
  public CUDAEvent() { super((Pointer)null); allocate(); }
  @NoException(true) private native void allocate();
  public CUDAEvent(@Cast("unsigned int") int flags) { super((Pointer)null); allocate(flags); }
  @NoException(true) private native void allocate(@Cast("unsigned int") int flags);

  public CUDAEvent(
        byte device_index, @Const cudaIpcEventHandle_t handle) { super((Pointer)null); allocate(device_index, handle); }
  private native void allocate(
        byte device_index, @Const cudaIpcEventHandle_t handle);

  // Note: event destruction done on creating device to avoid creating a
  // CUDA context on other devices.

  
  

  public CUDAEvent(@ByRef(true) CUDAEvent other) { super((Pointer)null); allocate(other); }
  @NoException(true) private native void allocate(@ByRef(true) CUDAEvent other);
  public native @ByRef @Name("operator =") @NoException(true) CUDAEvent put(@ByRef(true) CUDAEvent other);

  public native @Name("operator cudaEvent_t") CUevent_st asCUevent_st();

  // Less than operator (to allow use in sets)
  private static native @Namespace @Cast("bool") @Name("operator <") boolean lessThan(@Const @ByRef CUDAEvent left, @Const @ByRef CUDAEvent right);
  public boolean lessThan(CUDAEvent right) { return lessThan(this, right); }

  public native @ByVal DeviceOptional device();

  public native @Cast("bool") boolean isCreated();
  public native byte device_index();
  public native CUevent_st event();

  // Note: cudaEventQuery can be safely called from any device
  public native @Cast("bool") boolean query();

  public native void record();

  public native void recordOnce(@Const @ByRef CUDAStream stream);

  // Note: cudaEventRecord must be called on the same device as the event.
  public native void record(@Const @ByRef CUDAStream stream);

  // Note: cudaStreamWaitEvent must be called on the same device as the stream.
  // The event has no actual GPU resources associated with it.
  public native void block(@Const @ByRef CUDAStream stream);

  // Note: cudaEventElapsedTime can be safely called from any device
  public native float elapsed_time(@Const @ByRef CUDAEvent other);

  // Note: cudaEventSynchronize can be safely called from any device
  public native void synchronize();

  // Note: cudaIpcGetEventHandle must be called on the same device as the event
  public native void ipc_handle(cudaIpcEventHandle_t handle);
}
