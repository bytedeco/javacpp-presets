// Targeted by JavaCPP version 1.5.7: DO NOT EDIT THIS FILE

package org.bytedeco.pytorch;

import org.bytedeco.pytorch.Allocator;
import org.bytedeco.pytorch.Function;
import org.bytedeco.pytorch.Module;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;

import static org.bytedeco.pytorch.global.torch.*;


/** Stores a type erased {@code Module} with name.
 * 
 *  The {@code NamedAnyModule} class enables the following API for constructing
 *  {@code nn::Sequential} with named submodules:
 *  \rst
 *  .. code-block:: cpp
 * 
 *    struct M : torch::nn::Module {
 *      explicit M(int value_) : value(value_) {}
 *      int value;
 *      int forward() {
 *        return value;
 *      }
 *    };
 * 
 *    Sequential sequential({
 *      {"m1", std::make_shared<M>(1)},  // shared pointer to {@code Module} is supported
 *      {std::string("m2"), M(2)},  // {@code Module} is supported
 *      {"linear1", Linear(10, 3)}  // {@code ModuleHolder} is supported
 *    });
 *  \endrst */
@Namespace("torch::nn") @NoOffset @Properties(inherit = org.bytedeco.pytorch.presets.torch.class)
public class NamedAnyModule extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public NamedAnyModule(Pointer p) { super(p); }

  /** Creates a {@code NamedAnyModule} from a (boxed) {@code Module}. */

  /** Creates a {@code NamedAnyModule} from a {@code Module}, moving or copying it
   *  into a {@code shared_ptr} internally. */
  // NOTE: We need to use `std::remove_reference<M>::type` to get rid of
  // any reference components for make_unique.

  /** Creates a {@code NamedAnyModule} from a {@code Module} that is unwrapped from
   *  a {@code ModuleHolder}. */

  /** Creates a {@code NamedAnyModule} from a type-erased {@code AnyModule}. */
  public NamedAnyModule(@StdString BytePointer name, @ByVal AnyModule any_module) { super((Pointer)null); allocate(name, any_module); }
  private native void allocate(@StdString BytePointer name, @ByVal AnyModule any_module);
  public NamedAnyModule(@StdString String name, @ByVal AnyModule any_module) { super((Pointer)null); allocate(name, any_module); }
  private native void allocate(@StdString String name, @ByVal AnyModule any_module);

  /** Returns a reference to the name. */
  public native @StdString @NoException(true) BytePointer name();

  /** Returns a reference to the module. */
  public native @ByRef @NoException(true) AnyModule module();

  /** Returns a const reference to the module. */
}
