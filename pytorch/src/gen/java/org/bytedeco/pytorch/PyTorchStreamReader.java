// Targeted by JavaCPP version 1.5.11-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.pytorch;

import org.bytedeco.pytorch.Allocator;
import org.bytedeco.pytorch.Function;
import org.bytedeco.pytorch.functions.*;
import org.bytedeco.pytorch.Module;
import org.bytedeco.javacpp.annotation.Cast;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;

import static org.bytedeco.pytorch.global.torch.*;


@Namespace("caffe2::serialize") @NoOffset @Properties(inherit = org.bytedeco.pytorch.presets.torch.class)
public class PyTorchStreamReader extends Pointer {
    static { Loader.load(); }

  public PyTorchStreamReader(@StdString BytePointer file_name) { super((Pointer)null); allocate(file_name); }
  private native void allocate(@StdString BytePointer file_name);
  public PyTorchStreamReader(@StdString String file_name) { super((Pointer)null); allocate(file_name); }
  private native void allocate(@StdString String file_name);
  public PyTorchStreamReader(@Cast("std::istream*") Pointer in) { super((Pointer)null); allocate(in); }
  private native void allocate(@Cast("std::istream*") Pointer in);
  public PyTorchStreamReader(@SharedPtr("caffe2::serialize::ReadAdapterInterface") @ByVal ReadAdapterInterface in) { super((Pointer)null); allocate(in); }
  private native void allocate(@SharedPtr("caffe2::serialize::ReadAdapterInterface") @ByVal ReadAdapterInterface in);

  // return dataptr, size
  public native @ByVal T_DataPtrSizeT_T getRecord(@StdString BytePointer name);
  public native @ByVal T_DataPtrSizeT_T getRecord(@StdString String name);
  // multi-thread getRecord
  public native @ByVal T_DataPtrSizeT_T getRecord(@StdString BytePointer name, @ByRef ReadAdapterInterfaceVector additionalReaders);
  public native @ByVal T_DataPtrSizeT_T getRecord(@StdString String name, @ByRef ReadAdapterInterfaceVector additionalReaders);
  // inplace memory writing
  public native @Cast("size_t") long getRecord(@StdString BytePointer name, Pointer dst, @Cast("size_t") long n);
  public native @Cast("size_t") long getRecord(@StdString String name, Pointer dst, @Cast("size_t") long n);
  // inplace memory writing, multi-threads.
  // When additionalReaders is empty, the default behavior is call getRecord(name, dst, n) with default reader
  // This approach can be used for reading large tensors.
  public native @Cast("size_t") long getRecord(@StdString BytePointer name, Pointer dst, @Cast("size_t") long n,
      @ByRef ReadAdapterInterfaceVector additionalReaders);
  public native @Cast("size_t") long getRecord(@StdString String name, Pointer dst, @Cast("size_t") long n,
      @ByRef ReadAdapterInterfaceVector additionalReaders);
  public native @Cast("size_t") long getRecord(
        @StdString BytePointer name,
        Pointer dst,
        @Cast("size_t") long n,
        @Cast("size_t") long chunk_size,
        Pointer buf,
        @Const @ByRef(nullValue = "std::function<void(void*,const void*,size_t)>(nullptr)") MemCopyFunction memcpy_func);
  public native @Cast("size_t") long getRecord(
        @StdString BytePointer name,
        Pointer dst,
        @Cast("size_t") long n,
        @Cast("size_t") long chunk_size,
        Pointer buf);
  public native @Cast("size_t") long getRecord(
        @StdString String name,
        Pointer dst,
        @Cast("size_t") long n,
        @Cast("size_t") long chunk_size,
        Pointer buf,
        @Const @ByRef(nullValue = "std::function<void(void*,const void*,size_t)>(nullptr)") MemCopyFunction memcpy_func);
  public native @Cast("size_t") long getRecord(
        @StdString String name,
        Pointer dst,
        @Cast("size_t") long n,
        @Cast("size_t") long chunk_size,
        Pointer buf);

  // Concurrent reading records with multiple readers.
  // additionalReaders are additional clients to access the underlying record at different offsets
  // and write to different trunks of buffers.
  // If the overall size of the tensor is 10, and size of additionalReader is 2.
  // The default thread will read [0,4), the additional reader will read [4,8).
  // The default reader will read [8,10).
  // The default reader will write to buffer[0,4), the additional reader will write to buffer[4,8),
  // the additional reader will write to buffer[8,10).
  // When additionalReaders is empty, the default behavior is call getRecord(name) with default reader
  // This approach can be used for reading large tensors.
  public native @Cast("size_t") long getRecordMultiReaders(@StdString BytePointer name,
    @ByRef ReadAdapterInterfaceVector additionalReaders,
    Pointer dst, @Cast("size_t") long n);
  public native @Cast("size_t") long getRecordMultiReaders(@StdString String name,
    @ByRef ReadAdapterInterfaceVector additionalReaders,
    Pointer dst, @Cast("size_t") long n);

  public native @Cast("size_t") long getRecordSize(@StdString BytePointer name);
  public native @Cast("size_t") long getRecordSize(@StdString String name);

  public native @Cast("size_t") long getRecordOffset(@StdString BytePointer name);
  public native @Cast("size_t") long getRecordOffset(@StdString String name);
  public native @Cast("bool") boolean hasRecord(@StdString BytePointer name);
  public native @Cast("bool") boolean hasRecord(@StdString String name);
  public native @ByVal StringVector getAllRecords();

  public native @ByVal ChunkRecordIterator createChunkReaderIter(
        @StdString BytePointer name,
        @Cast("const size_t") long recordSize,
        @Cast("const size_t") long chunkSize);
  public native @ByVal ChunkRecordIterator createChunkReaderIter(
        @StdString String name,
        @Cast("const size_t") long recordSize,
        @Cast("const size_t") long chunkSize);
  public native @Cast("uint64_t") long version();
  public native @StdString BytePointer serializationId();

  public native void setShouldLoadDebugSymbol(@Cast("bool") boolean should_load_debug_symbol);
  public native void setAdditionalReaderSizeThreshold(@Cast("const size_t") long size);
}
