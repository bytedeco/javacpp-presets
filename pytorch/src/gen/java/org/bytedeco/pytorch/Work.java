// Targeted by JavaCPP version 1.5.12-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.pytorch;

import org.bytedeco.pytorch.Allocator;
import org.bytedeco.pytorch.Function;
import org.bytedeco.pytorch.Module;
import org.bytedeco.javacpp.annotation.Cast;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;
import org.bytedeco.javacpp.chrono.*;
import static org.bytedeco.javacpp.global.chrono.*;

import static org.bytedeco.pytorch.global.torch.*;


// Please do not use Work API, it is going away, to be
// replaced by ivalue::Future.
// Python binding for this class might change, please do not assume
// this will be bound using pybind.
@Namespace("c10d") @NoOffset @Properties(inherit = org.bytedeco.pytorch.presets.torch.class)
public class Work extends CustomClassHolder {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Work(Pointer p) { super(p); }

  public Work(
        int rank/*=-1*/,
        OpType opType/*=c10d::OpType::UNKNOWN*/,
        @Cast("const char*") BytePointer profilingTitle/*=nullptr*/,
        @Const @ByRef(nullValue = "std::optional<std::vector<at::Tensor> >(std::nullopt)") TensorVectorOptional inputTensors) { super((Pointer)null); allocate(rank, opType, profilingTitle, inputTensors); }
  @IntrusivePtr @Name("c10::make_intrusive<c10d::Work>") private native void allocate(
        int rank/*=-1*/,
        OpType opType/*=c10d::OpType::UNKNOWN*/,
        @Cast("const char*") BytePointer profilingTitle/*=nullptr*/,
        @Const @ByRef(nullValue = "std::optional<std::vector<at::Tensor> >(std::nullopt)") TensorVectorOptional inputTensors);
  public Work() { super((Pointer)null); allocate(); }
  @IntrusivePtr @Name("c10::make_intrusive<c10d::Work>") private native void allocate();
  public Work(
        int rank/*=-1*/,
        @Cast("c10d::OpType") byte opType/*=c10d::OpType::UNKNOWN*/,
        String profilingTitle/*=nullptr*/,
        @Const @ByRef(nullValue = "std::optional<std::vector<at::Tensor> >(std::nullopt)") TensorVectorOptional inputTensors) { super((Pointer)null); allocate(rank, opType, profilingTitle, inputTensors); }
  @IntrusivePtr @Name("c10::make_intrusive<c10d::Work>") private native void allocate(
        int rank/*=-1*/,
        @Cast("c10d::OpType") byte opType/*=c10d::OpType::UNKNOWN*/,
        String profilingTitle/*=nullptr*/,
        @Const @ByRef(nullValue = "std::optional<std::vector<at::Tensor> >(std::nullopt)") TensorVectorOptional inputTensors);

  // Checks if request has completed. Non-blocking operation.
  public native @Cast("bool") boolean isCompleted();

  // Returns if the work completed successfully.
  // If false, the exception function can be called to get details.
  public native @Cast("bool") boolean isSuccess();

  // Returns exception if isSuccess() returned false.
  public native @ByVal @Cast("std::exception_ptr*") Pointer exception();

  // Returns source rank if this objects represents a recv-from-any.
  public native int sourceRank();

  // Returns result tensors, if applicable.
  // If work is not supposed to have result, we return empty list.
  public native @ByVal TensorVector result();

  // Ensures that operations on the output tensors that are invoked
  // after this function returns are correctly sequenced after the
  // asynchronous completion of this work.
  //
  // For CUDA tensors, it inserts stream synchronization such that
  // the streams of the caller wait for completion of the
  // asynchronous operations on the destination tensors.
  //
  // For CPU tensors, it is currently a nop.
  //
  // This function should only be used if the caller polls for
  // completion through the `isCompleted` function, it has returned
  // true, and the `isSuccess` function also has returned true.
  //
  public native void synchronize();

  // Waits until request completes. Blocking operation.
  // Throws if the work completed with an exception.
  // Returns false if the work is aborted.
  // Otherwise, it always returns true, indicating the work is completed.
  //
  // Functionally equivalent to:
  //
  //   while (!isCompleted()) { /* nop */ }
  //   auto success = isSuccess();
  //   if (!success) { std::rethrow_exception(exception()); }
  //   return success;
  //
  public native @Cast("bool") @Name("wait") boolean _wait(@ByVal(nullValue = "std::chrono::milliseconds(kNoTimeout)") Milliseconds timeout);
  public native @Cast("bool") @Name("wait") boolean _wait();

  public native void abort();

  // Returns a Future object that will be associated with the completion of
  // work. Only NCCL backend is currently supported.
  public native @IntrusivePtr("c10::ivalue::Future") @Cast({"", "c10::intrusive_ptr<c10::ivalue::Future>&"}) Future getFuture();

  // Get a Future object that would be marked as either success or failure
  // This API can be used by the user to track the completion of the work
  // and hanlde the exception if any.
  public native @IntrusivePtr("c10::ivalue::Future") @Cast({"", "c10::intrusive_ptr<c10::ivalue::Future>&"}) Future getFutureResult();

  public native float getDuration();

  public native @Cast("uint64_t") long getSequencenumber();

  public native OpType retrieveOpType();

  public static native @IntrusivePtr("c10d::Work") @Cast({"", "c10::intrusive_ptr<c10d::Work>&"}) Work create_from_future(
        @IntrusivePtr("c10::ivalue::Future") @Cast({"", "c10::intrusive_ptr<c10::ivalue::Future>&"}) Future arg0);
}
