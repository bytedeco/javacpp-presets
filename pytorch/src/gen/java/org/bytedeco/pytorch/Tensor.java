// Targeted by JavaCPP version 1.5.6-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.pytorch;

import org.bytedeco.pytorch.Allocator;
import org.bytedeco.pytorch.Function;
import org.bytedeco.pytorch.Module;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;

import static org.bytedeco.pytorch.global.torch.*;


// Tensor is a "generic" object holding a pointer to the underlying TensorImpl object, which
// has an embedded reference count. In this way, Tensor is similar to boost::intrusive_ptr.
//
// For example:
//
// void func(Tensor a) {
//   Tensor b = a;
//   ...
// }
//
// In this example, when we say Tensor b = a, we are creating a new object that points to the
// same underlying TensorImpl, and bumps its reference count. When b goes out of scope, the
// destructor decrements the reference count by calling release() on the TensorImpl it points to.
// The existing constructors, operator overloads, etc. take care to implement the correct semantics.
//
// Note that Tensor can also be NULL, i.e. it is not associated with any underlying TensorImpl, and
// special care must be taken to handle this.
@Namespace("at") @Properties(inherit = org.bytedeco.pytorch.presets.torch.class)
public class Tensor extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Tensor(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Tensor(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Tensor position(long position) {
        return (Tensor)super.position(position);
    }
    @Override public Tensor getPointer(long i) {
        return new Tensor((Pointer)this).position(position + i);
    }

  public Tensor() { super((Pointer)null); allocate(); }
  private native void allocate();
  // This constructor should not be used by end users and is an implementation
  // detail invoked by autogenerated code.
  public Tensor(@Const @ByRef Tensor arg0) { super((Pointer)null); allocate(arg0); }
  private native void allocate(@Const @ByRef Tensor arg0);
  // Creates a new wrapper from TensorImpl. Intentionally a free method because
  // it should be used with care. Checks necessary invariants

  public native @Cast("int64_t") long dim();
  public native @Cast("int64_t") long storage_offset();

  public native @ByVal Tensor contiguous(MemoryFormat memory_format/*=c10::MemoryFormat::Contiguous*/);
  public native @ByVal Tensor contiguous();
  public native @ByVal Tensor contiguous(@Cast("c10::MemoryFormat") byte memory_format/*=c10::MemoryFormat::Contiguous*/);

  public native @Cast("int64_t") long size(@Cast("int64_t") long dim);

  public native @Cast("int64_t") long stride(@Cast("int64_t") long dim);

  public native TensorImpl unsafeGetTensorImpl();
  public native TensorImpl unsafeReleaseTensorImpl();

  public native @Cast("bool") boolean defined();

  public native void reset();

  // The following overloads are very intruiging.  Consider the following
  // program:
  //
  //    x[1] = 3;
  //
  // We would expect that the first entry of x is written to 3.  But how can we
  // actually achieve this?  x[1] evaluates to a tensor...
  //
  // The answer is, using a ref-qualifier.  x[1] is an rvalue, which cannot be
  // (profitably) assigned to in the traditional sense, so we overload
  // assignment to mean, "Actually, copy 3 into the tensor data."  This is done
  // with an rvalue-reference ref-qualified overload (the methods with && at the
  // end of their type.)
  //
  // There's one more fly in the ointment: We also want
  //
  //    Tensor x = y;
  //
  // to work, and we want it NOT to copy.  So we need a traditional operator=
  // overload.  But we MUST specify a mutable lvalue ref-qualifier, to
  // disambiguate the traditional overload from the rvalue-reference
  // ref-qualified overload.  Otherwise, it will be ambiguous, because
  // a non ref-qualified method is eligible for all situations.

  // Unfortunately, we have to write these constructors out manually
  // to work around an MSVC bug:
  //    error C2580: 'at::Tensor &at::Tensor::operator =(const at::Tensor &) &':
  //    multiple versions of a defaulted special member functions are not allowed
  // Tensor& operator=(const Tensor&) & = default;
  // Tensor& operator=(Tensor&&) & = default;

  // Also MSVC will wrongly issue the following warning with the aforementioned fix
  //    warning C4522: 'at::Tensor': multiple assignment operators specified
  // Let's just skip the warning.

//   #ifdef _MSC_VER
//   #pragma warning( push )
//   #pragma warning( disable : 4522 )
//   #endif

  public native @ByRef @Name("operator =") Tensor put(@Const @ByRef Tensor x);

  
  
  

  public native @Cast("bool") @NoException boolean is_same(@Const @ByRef Tensor other);
  public native @Cast("size_t") @NoException long use_count();
  public native @Cast("size_t") @NoException long weak_use_count();

  public native @StdString String toString();

  public native @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef sizes();
  public native @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef strides();
  // See impl::get_opt_names in ATen/NamedTensor.h for docs.
  public native @ByVal DimnameListOptional opt_names();
  // See impl::get_names in ATen/NamedTensor.h for docs.
  public native @ByVal DimnameArrayRef names();
  public native @Cast("int64_t") long ndimension();

  public native @Cast("bool") boolean is_contiguous(@ByVal(nullValue = "at::MemoryFormat::Contiguous") MemoryFormat memory_format);
  public native @Cast("bool") boolean is_contiguous();

  public native @Cast("bool") boolean is_non_overlapping_and_dense();

  public native @ByVal MemoryFormat suggest_memory_format(
        @Cast("bool") boolean channels_last_strides_exact_match/*=false*/);
  public native @ByVal MemoryFormat suggest_memory_format();

  // Total bytes consumed by the "view" of elements of the array.  Does not
  // include size of metadata.  The number reported here does not necessarily
  // correspond to the true physical memory consumed by a tensor; instead,
  // it reports the memory the tensor would take *if* it were contiguous.
  // Defined to be numel() * itemsize()
  public native @Cast("size_t") long nbytes();

  public native @Cast("int64_t") long numel();

  // Length of one array element in bytes.  This is the traditional
  // Numpy naming.
  public native @Cast("size_t") long itemsize();

  // Same as itemsize().  This is the PyTorch naming.
  public native @Cast("int64_t") long element_size();

  public native @Deprecated @ByRef DeprecatedTypeProperties type();
  public native @ByVal DispatchKeySet key_set();
  public native ScalarType scalar_type();
  public native @Cast("bool") boolean has_storage();
  public native @Cast({"", "c10::Storage&&"}) @StdMove Storage storage();
  public native @Cast("bool") boolean is_alias_of(@Const @ByRef Tensor other);
  public native @ByVal Tensor toType(ScalarType t);
  public native @ByVal Tensor toBackend(Backend b);
  public native @ByVal Tensor toBackend(@Cast("c10::Backend") int b);

  public native @Cast("bool") @Deprecated @NoException boolean is_variable();

  /** Returns a {@code Tensor}'s layout. Defined in Type.h */
  public native @NoException Layout layout();

  /** Returns a {@code Tensor}'s dtype ({@code TypeMeta}). Defined in TensorMethods.cpp */
  public native @ByVal @Cast("caffe2::TypeMeta*") @NoException Pointer dtype();

  /** Returns a {@code Tensor}'s device. */
  public native @ByVal Device device();

  /** Returns a {@code Tensor}'s device index. */
  

  /** Returns if a {@code Tensor} has CUDA backend. */
  public native @Cast("bool") boolean is_cuda();

  /** Returns if a {@code Tensor} has XPU backend. */
  public native @Cast("bool") boolean is_xpu();

  /** Returns if a {@code Tensor} has XLA backend. */
  public native @Cast("bool") boolean is_xla();

  /** Returns if a {@code Tensor} has HIP backend. */
  public native @Cast("bool") boolean is_hip();

  /** Returns if a {@code Tensor} has sparse backend. */
  public native @Cast("bool") boolean is_sparse();

  /** Returns if a {@code Tensor} is mkldnn tensor. */
  public native @Cast("bool") boolean is_mkldnn();

  /** Returns if a {@code Tensor} is vulkan tensor. */
  public native @Cast("bool") boolean is_vulkan();

  /** Returns if a {@code Tensor} is metal tensor. */
  public native @Cast("bool") boolean is_metal();

  /** Returns if a {@code Tensor} has quantized backend. */
  public native @Cast("bool") boolean is_quantized();

  /** Returns if a {@code Tensor} is a meta tensor.  Meta tensors can
   *  also have other designations. */
  public native @Cast("bool") boolean is_meta();

  /** If a tensor is a quantized tensor, returns its quantizer
   *  TODO: it's not in native_functions.yaml yet as it's not exposed to python */

  /** Returns if a {@code Tensor} has any dimension names */
  public native @Cast("bool") boolean has_names();

  /** Returns a {@code Tensor}'s dimension names data structure */
  public native NamedTensorMeta get_named_tensor_meta();

  /** Returns the {@code TensorOptions} corresponding to this {@code Tensor}. Defined in
   *  TensorOptions.h. */
  public native @ByVal TensorOptions options();

  public native Pointer data_ptr();

  public native @Name("data_ptr<jbyte>") BytePointer data_ptr_byte();

  public native @Name("data_ptr<jshort>") ShortPointer data_ptr_short();

  public native @Name("data_ptr<jint>") IntPointer data_ptr_int();

  public native @Name("data_ptr<jlong>") LongPointer data_ptr_long();

  public native @Name("data_ptr<float>") FloatPointer data_ptr_float();

  public native @Name("data_ptr<double>") DoublePointer data_ptr_double();

  public native @Name("item<jbyte>") byte item_byte();

  public native @Name("item<jshort>") short item_short();

  public native @Name("item<jint>") int item_int();

  public native @Name("item<jlong>") long item_long();

  public native @Name("item<float>") float item_float();

  public native @Name("item<double>") double item_double();

  // Purposely not defined here to avoid inlining
  public native void print();

  // Return a `TensorAccessor` for CPU `Tensor`s. You have to specify scalar type and
  // dimension.
  

  // Return a `GenericPackedTensorAccessor` for CUDA `Tensor`s. You have to specify scalar type and
  // dimension. You can optionally specify RestrictPtrTraits as a template parameter to
  // cast the data pointer to a __restrict__ pointer.
  // In order to use this, your CUDA kernel has to take a corresponding GenericPackedTensorAccessor
  // as an argument.
  
  
  

  
  

  public native @ByVal @Name("operator ~") Tensor not();
  public native @ByVal @Name("operator -") Tensor subtract();
  public native @ByRef @Name("operator +=") Tensor addPut(@Const @ByRef Tensor other);
  public native @ByRef @Name("operator +=") Tensor addPut(@ByVal Scalar other);
  public native @ByRef @Name("operator -=") Tensor subtractPut(@Const @ByRef Tensor other);
  public native @ByRef @Name("operator -=") Tensor subtractPut(@ByVal Scalar other);
  public native @ByRef @Name("operator *=") Tensor multiplyPut(@Const @ByRef Tensor other);
  public native @ByRef @Name("operator *=") Tensor multiplyPut(@ByVal Scalar other);
  public native @ByRef @Name("operator /=") Tensor dividePut(@Const @ByRef Tensor other);
  public native @ByRef @Name("operator /=") Tensor dividePut(@ByVal Scalar other);
  public native @ByRef @Name("operator &=") Tensor andPut(@Const @ByRef Tensor other);
  public native @ByRef @Name("operator |=") Tensor orPut(@Const @ByRef Tensor other);
  public native @ByRef @Name("operator ^=") Tensor xorPut(@Const @ByRef Tensor other);
  public native @ByVal @Name("operator []") Tensor get(@ByVal Scalar index);
  public native @ByVal @Name("operator []") Tensor get(@ByVal Tensor index);
  public native @ByVal @Name("operator []") Tensor get(@Cast("int64_t") long index);

  public native @ByVal Tensor index(@ByVal TensorIndexArrayRef indices);

  public native @ByRef Tensor index_put_(@ByVal TensorIndexArrayRef indices, @Const @ByRef Tensor rhs);
  public native @ByRef Tensor index_put_(@ByVal TensorIndexArrayRef indices, @ByVal Scalar v);

  public native @ByVal Tensor cpu();
  public native @ByVal Tensor cuda();
  public native @ByVal Tensor hip();
  public native @ByVal Tensor vulkan();
  
  ///
  ///
  ///
  ///
  ///
  ///
  ///
  ///
  ///
  ///
  ///
  ///
  ///
  public native @ByVal Tensor metal();

  // ~~~~~ Autograd API ~~~~~

  /** \fn bool is_leaf() const;
   * 
   *  All Tensors that have {@code requires_grad()} which is {@code }false{@code } will be leaf Tensors by convention.
   * 
   *  For Tensors that have {@code requires_grad()} which is {@code }true{@code }, they will be leaf Tensors if they were
   *  created by the user. This means that they are not the result of an operation and so
   *  {@code grad_fn()} is {@code nullptr}.
   * 
   *  Only leaf Tensors will have their {@code grad()} populated during a call to {@code backward()}.
   *  To get {@code grad()} populated for non-leaf Tensors, you can use {@code retain_grad()}.
   * 
   *  Example:
   *  <pre>{@code
   *  auto a = torch::rand(10, torch::requires_grad());
   *  std::cout << a.is_leaf() << std::endl; // prints `true`
   * 
   *  auto b = torch::rand(10, torch::requires_grad()).to(torch::kCUDA);
   *  std::cout << b.is_leaf() << std::endl; // prints `false`
   *  // b was created by the operation that cast a cpu Tensor into a cuda Tensor
   * 
   *  auto c = torch::rand(10, torch::requires_grad()) + 2;
   *  std::cout << c.is_leaf() << std::endl; // prints `false`
   *  // c was created by the addition operation
   * 
   *  auto d = torch::rand(10).cuda();
   *  std::cout << d.is_leaf() << std::endl; // prints `true`
   *  // d does not require gradients and so has no operation creating it (that is tracked by the autograd engine)
   * 
   *  auto e = torch::rand(10).cuda().requires_grad_();
   *  std::cout << e.is_leaf() << std::endl; // prints `true`
   *  // e requires gradients and has no operations creating it
   * 
   *  auto f = torch::rand(10, torch::device(torch::kCUDA).requires_grad(true));
   *  std::cout << f.is_leaf() << std::endl; // prints `true`
   *  // f requires grad, has no operation creating it
   *  }</pre>
   <p>
   *  \fn void backward(const Tensor & gradient={}, c10::optional<bool> retain_graph=c10::nullopt, bool create_graph=false, c10::optional<TensorList> inputs=c10::nullopt) const;
   * 
   *  Computes the gradient of current tensor with respect to graph leaves.
   * 
   *  The graph is differentiated using the chain rule. If the tensor is
   *  non-scalar (i.e. its data has more than one element) and requires
   *  gradient, the function additionally requires specifying {@code }gradient{@code }.
   *  It should be a tensor of matching type and location, that contains
   *  the gradient of the differentiated function w.r.t. this Tensor.
   * 
   *  This function accumulates gradients in the leaves - you might need to
   *  zero them before calling it.
   * 
   *  @param gradient Gradient w.r.t. the
   *      tensor. If it is a tensor, it will be automatically converted
   *      to a Tensor that does not require grad unless {@code }create_graph{@code } is True.
   *      None values can be specified for scalar Tensors or ones that
   *      don't require grad. If a None value would be acceptable then
   *      this argument is optional.
   *  @param retain_graph If {@code }false{@code }, the graph used to compute
   *      the grads will be freed. Note that in nearly all cases setting
   *      this option to True is not needed and often can be worked around
   *      in a much more efficient way. Defaults to the value of
   *      {@code }create_graph{@code }.
   *  @param create_graph If {@code }true{@code }, graph of the derivative will
   *      be constructed, allowing to compute higher order derivative
   *      products. Defaults to {@code }false{@code }.
   *  @param inputs Inputs w.r.t. which the gradient will be accumulated into
   *      {@code }at::Tensor::grad{@code }. All other Tensors will be ignored. If not
   *      provided, the gradient is accumulated into all the leaf Tensors
   *      that were used to compute the current tensor. All the provided inputs
   *      must be leaf Tensors. */
  
  ///
  ///
  ///
  public native void backward(@Const @ByRef(nullValue = "at::Tensor{}") Tensor gradient, @ByVal(nullValue = "c10::optional<bool>(c10::nullopt)") BoolOptional retain_graph, @Cast("bool") boolean create_graph/*=false*/, @ByVal(nullValue = "c10::optional<at::TensorList>(c10::nullopt)") TensorListOptional inputs);
  public native void backward();

  /** \fn Tensor detach() const;
   * 
   *  Returns a new Tensor, detached from the current graph.
   *  The result will never require gradient.
   <p>
   *  \fn Tensor & detach_() const;
   * 
   *  Detaches the Tensor from the graph that created it, making it a leaf.
   *  Views cannot be detached in-place.
   <p>
   *  \fn void retain_grad() const;
   * 
   *  Enables .grad() for non-leaf Tensors. */

  public native @ByRef Tensor set_requires_grad(@Cast("bool") boolean requires_grad);
  public native @Cast("bool") boolean requires_grad();

  /** Return a mutable reference to the gradient. This is conventionally
   *  used as {@code t.grad() = x} to set a gradient to a completely new tensor.
   *  Note that this function work with a non-const Tensor and is not
   *  thread safe. */
  public native @ByRef Tensor mutable_grad();

  /** This function returns an undefined tensor by default and returns a defined tensor
   *  the first time a call to {@code backward()} computes gradients for this Tensor.
   *  The attribute will then contain the gradients computed and future calls
   *  to {@code backward()} will accumulate (add) gradients into it. */
  public native @Const @ByRef Tensor grad();

  // The Forward AD API functions below are low level and are not to be used by end
  // users who should use the API provided in torch/csrc/autograd.h

  /** This function returns the forward gradient for this Tensor at the given level. */
  public native @Const @ByRef Tensor fw_grad(@Cast("uint64_t") long level);

  /** This function can be used to set the value of the forward grad.
   *  Note that the given new_grad might not be used directly if it has different
   *  metadata (size/stride/storage offset) compared to this Tensor. In that case,
   *  new_grad content will be copied into a new Tensor */
  public native void set_fw_grad(@Const @ByRef Tensor new_grad, @Cast("uint64_t") long level, @Cast("bool") boolean is_inplace_op);


  // STOP.  Thinking of adding a method here, which only makes use
  // of other ATen methods?  Define it in native_functions.yaml.

  //example
  //Tensor * add(Tensor & b);
  public native void _backward(@ByVal TensorArrayRef inputs, @Const @ByRef(nullValue = "c10::optional<at::Tensor>{}") TensorOptional gradient, @ByVal(nullValue = "c10::optional<bool>(c10::nullopt)") BoolOptional retain_graph, @Cast("bool") boolean create_graph/*=false*/);
  public native void _backward(@ByVal TensorArrayRef inputs);
  public native void set_data(@Const @ByRef Tensor new_data);
  public native @ByVal Tensor data();
  public native @Cast("bool") boolean is_leaf();
  public native @Cast("int64_t") long output_nr();
  public native @Cast("int64_t") long _version();
  public native @ByRef Tensor requires_grad_(@Cast("bool") boolean requires_grad/*=true*/);
  public native @ByRef Tensor requires_grad_();
  public native void retain_grad();
  public native @ByVal Tensor _fw_primal(@Cast("int64_t") long level);
  public native @ByRef Tensor rename_(@ByVal DimnameListOptional names);
  public native @ByVal Tensor rename(@ByVal DimnameListOptional names);
  public native @ByVal Tensor align_to(@ByVal DimnameArrayRef names);
  public native @ByVal Tensor align_to(@ByVal DimnameArrayRef order, @Cast("int64_t") long ellipsis_idx);
  public native @ByVal Tensor align_as(@Const @ByRef Tensor other);
  public native @ByVal Tensor refine_names(@ByVal DimnameArrayRef names);
  public native @ByVal Tensor abs();
  public native @ByRef Tensor abs_();
  public native @ByVal Tensor absolute();
  public native @ByRef Tensor absolute_();
  public native @ByVal Tensor angle();
  public native @ByVal Tensor sgn();
  public native @ByRef Tensor sgn_();
  public native @ByVal Tensor conj();
  public native @ByVal Tensor acos();
  public native @ByRef Tensor acos_();
  public native @ByVal Tensor arccos();
  public native @ByRef Tensor arccos_();
  public native @ByVal Tensor add(@Const @ByRef Tensor other, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByVal Tensor add(@Const @ByRef Tensor other);
  public native @ByRef Tensor add_(@Const @ByRef Tensor other, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByRef Tensor add_(@Const @ByRef Tensor other);
  public native @ByVal Tensor add(@ByVal Scalar other, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByVal Tensor add(@ByVal Scalar other);
  public native @ByRef Tensor add_(@ByVal Scalar other, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByRef Tensor add_(@ByVal Scalar other);
  public native @ByVal Tensor addmv(@Const @ByRef Tensor mat, @Const @ByRef Tensor vec, @ByVal(nullValue = "c10::Scalar(1)") Scalar beta, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByVal Tensor addmv(@Const @ByRef Tensor mat, @Const @ByRef Tensor vec);
  public native @ByRef Tensor addmv_(@Const @ByRef Tensor mat, @Const @ByRef Tensor vec, @ByVal(nullValue = "c10::Scalar(1)") Scalar beta, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByRef Tensor addmv_(@Const @ByRef Tensor mat, @Const @ByRef Tensor vec);
  public native @ByVal Tensor addr(@Const @ByRef Tensor vec1, @Const @ByRef Tensor vec2, @ByVal(nullValue = "c10::Scalar(1)") Scalar beta, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByVal Tensor addr(@Const @ByRef Tensor vec1, @Const @ByRef Tensor vec2);
  public native @ByRef Tensor addr_(@Const @ByRef Tensor vec1, @Const @ByRef Tensor vec2, @ByVal(nullValue = "c10::Scalar(1)") Scalar beta, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByRef Tensor addr_(@Const @ByRef Tensor vec1, @Const @ByRef Tensor vec2);
  public native @ByVal Tensor all(@Cast("int64_t") long dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor all(@Cast("int64_t") long dim);
  public native @ByVal Tensor all(@ByVal Dimname dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor all(@ByVal Dimname dim);
  public native @Cast("bool") boolean allclose(@Const @ByRef Tensor other, double rtol/*=1e-05*/, double atol/*=1e-08*/, @Cast("bool") boolean equal_nan/*=false*/);
  public native @Cast("bool") boolean allclose(@Const @ByRef Tensor other);
  public native @ByVal Tensor any(@Cast("int64_t") long dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor any(@Cast("int64_t") long dim);
  public native @ByVal Tensor any(@ByVal Dimname dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor any(@ByVal Dimname dim);
  public native @ByVal Tensor argmax(@ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor argmax();
  public native @ByVal Tensor argmin(@ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor argmin();
  public native @ByVal Tensor acosh();
  public native @ByRef Tensor acosh_();
  public native @ByVal Tensor arccosh();
  public native @ByRef Tensor arccosh_();
  public native @ByVal Tensor asinh();
  public native @ByRef Tensor asinh_();
  public native @ByVal Tensor arcsinh();
  public native @ByRef Tensor arcsinh_();
  public native @ByVal Tensor atanh();
  public native @ByRef Tensor atanh_();
  public native @ByVal Tensor arctanh();
  public native @ByRef Tensor arctanh_();
  public native @ByVal Tensor as_strided(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef stride, @ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional storage_offset);
  public native @ByVal Tensor as_strided(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef stride);
  public native @ByVal Tensor as_strided(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] stride, @ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional storage_offset);
  public native @ByVal Tensor as_strided(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... stride);
  public native @ByRef Tensor as_strided_(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef stride, @ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional storage_offset);
  public native @ByRef Tensor as_strided_(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef stride);
  public native @ByRef Tensor as_strided_(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] stride, @ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional storage_offset);
  public native @ByRef Tensor as_strided_(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... stride);
  public native @ByVal Tensor asin();
  public native @ByRef Tensor asin_();
  public native @ByVal Tensor arcsin();
  public native @ByRef Tensor arcsin_();
  public native @ByVal Tensor atan();
  public native @ByRef Tensor atan_();
  public native @ByVal Tensor arctan();
  public native @ByRef Tensor arctan_();
  public native @ByVal Tensor baddbmm(@Const @ByRef Tensor batch1, @Const @ByRef Tensor batch2, @ByVal(nullValue = "c10::Scalar(1)") Scalar beta, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByVal Tensor baddbmm(@Const @ByRef Tensor batch1, @Const @ByRef Tensor batch2);
  public native @ByRef Tensor baddbmm_(@Const @ByRef Tensor batch1, @Const @ByRef Tensor batch2, @ByVal(nullValue = "c10::Scalar(1)") Scalar beta, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByRef Tensor baddbmm_(@Const @ByRef Tensor batch1, @Const @ByRef Tensor batch2);
  public native @ByVal Tensor bernoulli(@ByVal(nullValue = "c10::optional<at::Generator>(c10::nullopt)") GeneratorOptional generator);
  public native @ByVal Tensor bernoulli();
  public native @ByRef Tensor bernoulli_(@Const @ByRef Tensor p, @ByVal(nullValue = "c10::optional<at::Generator>(c10::nullopt)") GeneratorOptional generator);
  public native @ByRef Tensor bernoulli_(@Const @ByRef Tensor p);
  public native @ByRef Tensor bernoulli_(double p/*=0.5*/, @ByVal(nullValue = "c10::optional<at::Generator>(c10::nullopt)") GeneratorOptional generator);
  public native @ByRef Tensor bernoulli_();
  public native @ByVal Tensor bernoulli(double p, @ByVal(nullValue = "c10::optional<at::Generator>(c10::nullopt)") GeneratorOptional generator);
  public native @ByVal Tensor bernoulli(double p);
  public native @ByVal Tensor bincount(@Const @ByRef(nullValue = "c10::optional<at::Tensor>{}") TensorOptional weights, @Cast("int64_t") long minlength/*=0*/);
  public native @ByVal Tensor bincount();
  public native @ByVal Tensor bitwise_not();
  public native @ByRef Tensor bitwise_not_();
  public native @ByVal Tensor copysign(@Const @ByRef Tensor other);
  public native @ByRef Tensor copysign_(@Const @ByRef Tensor other);
  public native @ByVal Tensor copysign(@ByVal Scalar other);
  public native @ByRef Tensor copysign_(@ByVal Scalar other);
  public native @ByVal Tensor logical_not();
  public native @ByRef Tensor logical_not_();
  public native @ByVal Tensor logical_xor(@Const @ByRef Tensor other);
  public native @ByRef Tensor logical_xor_(@Const @ByRef Tensor other);
  public native @ByVal Tensor logical_and(@Const @ByRef Tensor other);
  public native @ByRef Tensor logical_and_(@Const @ByRef Tensor other);
  public native @ByVal Tensor logical_or(@Const @ByRef Tensor other);
  public native @ByRef Tensor logical_or_(@Const @ByRef Tensor other);
  public native @ByVal Tensor bmm(@Const @ByRef Tensor mat2);
  public native @ByVal Tensor broadcast_to(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size);
  public native @ByVal Tensor broadcast_to(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... size);
  public native @ByVal Tensor ceil();
  public native @ByRef Tensor ceil_();
  public native @StdMove TensorVector unsafe_chunk(@Cast("int64_t") long chunks, @Cast("int64_t") long dim/*=0*/);
  public native @StdMove TensorVector unsafe_chunk(@Cast("int64_t") long chunks);
  public native @StdMove TensorVector chunk(@Cast("int64_t") long chunks, @Cast("int64_t") long dim/*=0*/);
  public native @StdMove TensorVector chunk(@Cast("int64_t") long chunks);
  public native @StdMove TensorVector tensor_split(@Cast("int64_t") long sections, @Cast("int64_t") long dim/*=0*/);
  public native @StdMove TensorVector tensor_split(@Cast("int64_t") long sections);
  public native @StdMove TensorVector tensor_split(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef indices, @Cast("int64_t") long dim/*=0*/);
  public native @StdMove TensorVector tensor_split(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef indices);
  public native @StdMove TensorVector tensor_split(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] indices, @Cast("int64_t") long dim/*=0*/);
  public native @StdMove TensorVector tensor_split(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... indices);
  public native @StdMove TensorVector tensor_split(@Const @ByRef Tensor tensor_indices_or_sections, @Cast("int64_t") long dim/*=0*/);
  public native @StdMove TensorVector tensor_split(@Const @ByRef Tensor tensor_indices_or_sections);
  public native @ByVal Tensor clamp(@ByVal(nullValue = "c10::optional<c10::Scalar>(c10::nullopt)") ScalarOptional min, @ByVal(nullValue = "c10::optional<c10::Scalar>(c10::nullopt)") ScalarOptional max);
  public native @ByVal Tensor clamp();
  public native @ByRef Tensor clamp_(@ByVal(nullValue = "c10::optional<c10::Scalar>(c10::nullopt)") ScalarOptional min, @ByVal(nullValue = "c10::optional<c10::Scalar>(c10::nullopt)") ScalarOptional max);
  public native @ByRef Tensor clamp_();
  public native @ByVal Tensor clamp_max(@ByVal Scalar max);
  public native @ByRef Tensor clamp_max_(@ByVal Scalar max);
  public native @ByVal Tensor clamp_min(@ByVal Scalar min);
  public native @ByRef Tensor clamp_min_(@ByVal Scalar min);
  public native @ByVal Tensor clip(@ByVal(nullValue = "c10::optional<c10::Scalar>(c10::nullopt)") ScalarOptional min, @ByVal(nullValue = "c10::optional<c10::Scalar>(c10::nullopt)") ScalarOptional max);
  public native @ByVal Tensor clip();
  public native @ByRef Tensor clip_(@ByVal(nullValue = "c10::optional<c10::Scalar>(c10::nullopt)") ScalarOptional min, @ByVal(nullValue = "c10::optional<c10::Scalar>(c10::nullopt)") ScalarOptional max);
  public native @ByRef Tensor clip_();
  public native @ByVal Tensor __dispatch_contiguous(MemoryFormat memory_format/*=c10::MemoryFormat::Contiguous*/);
  public native @ByVal Tensor __dispatch_contiguous();
  public native @ByVal Tensor __dispatch_contiguous(@Cast("c10::MemoryFormat") byte memory_format/*=c10::MemoryFormat::Contiguous*/);
  public native @ByRef Tensor copy_(@Const @ByRef Tensor src, @Cast("bool") boolean non_blocking/*=false*/);
  public native @ByRef Tensor copy_(@Const @ByRef Tensor src);
  public native @ByVal Tensor cos();
  public native @ByRef Tensor cos_();
  public native @ByVal Tensor cosh();
  public native @ByRef Tensor cosh_();
  public native @ByVal Tensor count_nonzero(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim);
  public native @ByVal Tensor count_nonzero(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... dim);
  public native @ByVal Tensor count_nonzero(@ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional dim);
  public native @ByVal Tensor count_nonzero();
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor cummax(@Cast("int64_t") long dim);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor cummax(@ByVal Dimname dim);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor cummin(@Cast("int64_t") long dim);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor cummin(@ByVal Dimname dim);
  public native @ByVal Tensor cumprod(@Cast("int64_t") long dim, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor cumprod(@Cast("int64_t") long dim);
  public native @ByRef Tensor cumprod_(@Cast("int64_t") long dim, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByRef Tensor cumprod_(@Cast("int64_t") long dim);
  public native @ByVal Tensor cumprod(@ByVal Dimname dim, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor cumprod(@ByVal Dimname dim);
  public native @ByRef Tensor cumprod_(@ByVal Dimname dim, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByRef Tensor cumprod_(@ByVal Dimname dim);
  public native @ByVal Tensor cumsum(@Cast("int64_t") long dim, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor cumsum(@Cast("int64_t") long dim);
  public native @ByRef Tensor cumsum_(@Cast("int64_t") long dim, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByRef Tensor cumsum_(@Cast("int64_t") long dim);
  public native @ByVal Tensor cumsum(@ByVal Dimname dim, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor cumsum(@ByVal Dimname dim);
  public native @ByRef Tensor cumsum_(@ByVal Dimname dim, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByRef Tensor cumsum_(@ByVal Dimname dim);
  public native @ByVal Tensor diag_embed(@Cast("int64_t") long offset/*=0*/, @Cast("int64_t") long dim1/*=-2*/, @Cast("int64_t") long dim2/*=-1*/);
  public native @ByVal Tensor diag_embed();
  public native @ByVal Tensor diagflat(@Cast("int64_t") long offset/*=0*/);
  public native @ByVal Tensor diagflat();
  public native @ByVal Tensor diagonal(@Cast("int64_t") long offset/*=0*/, @Cast("int64_t") long dim1/*=0*/, @Cast("int64_t") long dim2/*=1*/);
  public native @ByVal Tensor diagonal();
  public native @ByVal Tensor diagonal(@ByVal Dimname outdim, @ByVal Dimname dim1, @ByVal Dimname dim2, @Cast("int64_t") long offset/*=0*/);
  public native @ByVal Tensor diagonal(@ByVal Dimname outdim, @ByVal Dimname dim1, @ByVal Dimname dim2);
  public native @ByRef Tensor fill_diagonal_(@ByVal Scalar fill_value, @Cast("bool") boolean wrap/*=false*/);
  public native @ByRef Tensor fill_diagonal_(@ByVal Scalar fill_value);
  public native @ByVal Tensor diff(@Cast("int64_t") long n/*=1*/, @Cast("int64_t") long dim/*=-1*/, @Const @ByRef(nullValue = "c10::optional<at::Tensor>{}") TensorOptional prepend, @Const @ByRef(nullValue = "c10::optional<at::Tensor>{}") TensorOptional append);
  public native @ByVal Tensor diff();
  public native @ByVal Tensor div(@Const @ByRef Tensor other);
  public native @ByRef Tensor div_(@Const @ByRef Tensor other);
  public native @ByVal Tensor div(@Const @ByRef Tensor other, @StdString BytePointer rounding_mode);
  public native @ByVal Tensor div(@Const @ByRef Tensor other, @StdString String rounding_mode);
  public native @ByRef Tensor div_(@Const @ByRef Tensor other, @StdString BytePointer rounding_mode);
  public native @ByRef Tensor div_(@Const @ByRef Tensor other, @StdString String rounding_mode);
  public native @ByVal Tensor div(@ByVal Scalar other);
  public native @ByRef Tensor div_(@ByVal Scalar other);
  public native @ByVal Tensor div(@ByVal Scalar other, @StdString BytePointer rounding_mode);
  public native @ByVal Tensor div(@ByVal Scalar other, @StdString String rounding_mode);
  public native @ByRef Tensor div_(@ByVal Scalar other, @StdString BytePointer rounding_mode);
  public native @ByRef Tensor div_(@ByVal Scalar other, @StdString String rounding_mode);
  public native @ByVal Tensor divide(@Const @ByRef Tensor other);
  public native @ByRef Tensor divide_(@Const @ByRef Tensor other);
  public native @ByVal Tensor divide(@ByVal Scalar other);
  public native @ByRef Tensor divide_(@ByVal Scalar other);
  public native @ByVal Tensor divide(@Const @ByRef Tensor other, @StdString BytePointer rounding_mode);
  public native @ByVal Tensor divide(@Const @ByRef Tensor other, @StdString String rounding_mode);
  public native @ByRef Tensor divide_(@Const @ByRef Tensor other, @StdString BytePointer rounding_mode);
  public native @ByRef Tensor divide_(@Const @ByRef Tensor other, @StdString String rounding_mode);
  public native @ByVal Tensor divide(@ByVal Scalar other, @StdString BytePointer rounding_mode);
  public native @ByVal Tensor divide(@ByVal Scalar other, @StdString String rounding_mode);
  public native @ByRef Tensor divide_(@ByVal Scalar other, @StdString BytePointer rounding_mode);
  public native @ByRef Tensor divide_(@ByVal Scalar other, @StdString String rounding_mode);
  public native @ByVal Tensor true_divide(@Const @ByRef Tensor other);
  public native @ByRef Tensor true_divide_(@Const @ByRef Tensor other);
  public native @ByVal Tensor true_divide(@ByVal Scalar other);
  public native @ByRef Tensor true_divide_(@ByVal Scalar other);
  public native @ByVal Tensor dot(@Const @ByRef Tensor tensor);
  public native @ByVal Tensor vdot(@Const @ByRef Tensor other);
  public native @ByVal Tensor new_empty(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @ByVal(nullValue = "c10::TensorOptions{}") TensorOptions options);
  public native @ByVal Tensor new_empty(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size);
  public native @ByVal Tensor new_empty(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @ByVal(nullValue = "c10::TensorOptions{}") TensorOptions options);
  public native @ByVal Tensor new_empty(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... size);
  public native @ByVal Tensor new_empty(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @ByVal ScalarTypeOptional dtype, @ByVal LayoutOptional layout, @ByVal DeviceOptional device, @ByVal BoolOptional pin_memory);
  public native @ByVal Tensor new_empty(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @ByVal ScalarTypeOptional dtype, @ByVal LayoutOptional layout, @ByVal DeviceOptional device, @ByVal BoolOptional pin_memory);
  public native @ByVal Tensor new_empty_strided(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef stride, @ByVal(nullValue = "c10::TensorOptions{}") TensorOptions options);
  public native @ByVal Tensor new_empty_strided(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef stride);
  public native @ByVal Tensor new_empty_strided(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] stride, @ByVal(nullValue = "c10::TensorOptions{}") TensorOptions options);
  public native @ByVal Tensor new_empty_strided(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... stride);
  public native @ByVal Tensor new_empty_strided(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef stride, @ByVal ScalarTypeOptional dtype, @ByVal LayoutOptional layout, @ByVal DeviceOptional device, @ByVal BoolOptional pin_memory);
  public native @ByVal Tensor new_empty_strided(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] stride, @ByVal ScalarTypeOptional dtype, @ByVal LayoutOptional layout, @ByVal DeviceOptional device, @ByVal BoolOptional pin_memory);
  public native @ByVal Tensor new_full(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @ByVal Scalar fill_value, @ByVal(nullValue = "c10::TensorOptions{}") TensorOptions options);
  public native @ByVal Tensor new_full(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @ByVal Scalar fill_value);
  public native @ByVal Tensor new_full(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @ByVal Scalar fill_value, @ByVal(nullValue = "c10::TensorOptions{}") TensorOptions options);
  public native @ByVal Tensor new_full(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @ByVal Scalar fill_value);
  public native @ByVal Tensor new_full(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @ByVal Scalar fill_value, @ByVal ScalarTypeOptional dtype, @ByVal LayoutOptional layout, @ByVal DeviceOptional device, @ByVal BoolOptional pin_memory);
  public native @ByVal Tensor new_full(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @ByVal Scalar fill_value, @ByVal ScalarTypeOptional dtype, @ByVal LayoutOptional layout, @ByVal DeviceOptional device, @ByVal BoolOptional pin_memory);
  public native @ByVal Tensor new_zeros(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @ByVal(nullValue = "c10::TensorOptions{}") TensorOptions options);
  public native @ByVal Tensor new_zeros(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size);
  public native @ByVal Tensor new_zeros(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @ByVal(nullValue = "c10::TensorOptions{}") TensorOptions options);
  public native @ByVal Tensor new_zeros(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... size);
  public native @ByVal Tensor new_zeros(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @ByVal ScalarTypeOptional dtype, @ByVal LayoutOptional layout, @ByVal DeviceOptional device, @ByVal BoolOptional pin_memory);
  public native @ByVal Tensor new_zeros(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @ByVal ScalarTypeOptional dtype, @ByVal LayoutOptional layout, @ByVal DeviceOptional device, @ByVal BoolOptional pin_memory);
  public native @ByRef Tensor resize_(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @ByVal(nullValue = "c10::optional<c10::MemoryFormat>(c10::nullopt)") MemoryFormatOptional memory_format);
  public native @ByRef Tensor resize_(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size);
  public native @ByRef Tensor resize_(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @ByVal(nullValue = "c10::optional<c10::MemoryFormat>(c10::nullopt)") MemoryFormatOptional memory_format);
  public native @ByRef Tensor resize_(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... size);
  public native @ByVal Tensor erf();
  public native @ByRef Tensor erf_();
  public native @ByVal Tensor erfc();
  public native @ByRef Tensor erfc_();
  public native @ByVal Tensor exp();
  public native @ByRef Tensor exp_();
  public native @ByVal Tensor exp2();
  public native @ByRef Tensor exp2_();
  public native @ByVal Tensor expm1();
  public native @ByRef Tensor expm1_();
  public native @ByVal Tensor expand(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @Cast("bool") boolean implicit/*=false*/);
  public native @ByVal Tensor expand(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size);
  public native @ByVal Tensor expand(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @Cast("bool") boolean implicit/*=false*/);
  public native @ByVal Tensor expand(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... size);
  public native @ByVal Tensor expand_as(@Const @ByRef Tensor other);
  public native @ByVal Tensor flatten(@Cast("int64_t") long start_dim/*=0*/, @Cast("int64_t") long end_dim/*=-1*/);
  public native @ByVal Tensor flatten();
  public native @ByVal Tensor flatten(@Cast("int64_t") long start_dim, @Cast("int64_t") long end_dim, @ByVal Dimname out_dim);
  public native @ByVal Tensor flatten(@ByVal Dimname start_dim, @ByVal Dimname end_dim, @ByVal Dimname out_dim);
  public native @ByVal Tensor flatten(@ByVal DimnameArrayRef dims, @ByVal Dimname out_dim);
  public native @ByVal Tensor unflatten(@Cast("int64_t") long dim, @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef sizes, @ByVal(nullValue = "c10::optional<at::DimnameList>(c10::nullopt)") DimnameListOptional names);
  public native @ByVal Tensor unflatten(@Cast("int64_t") long dim, @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef sizes);
  public native @ByVal Tensor unflatten(@Cast("int64_t") long dim, @ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] sizes, @ByVal(nullValue = "c10::optional<at::DimnameList>(c10::nullopt)") DimnameListOptional names);
  public native @ByVal Tensor unflatten(@Cast("int64_t") long dim, @ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... sizes);
  public native @ByVal Tensor unflatten(@ByVal Dimname dim, @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef sizes, @ByVal DimnameArrayRef names);
  public native @ByVal Tensor unflatten(@ByVal Dimname dim, @ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] sizes, @ByVal DimnameArrayRef names);
  public native @ByRef Tensor fill_(@ByVal Scalar value);
  public native @ByRef Tensor fill_(@Const @ByRef Tensor value);
  public native @ByVal Tensor floor();
  public native @ByRef Tensor floor_();
  public native @ByVal Tensor floor_divide(@Const @ByRef Tensor other);
  public native @ByRef Tensor floor_divide_(@Const @ByRef Tensor other);
  public native @ByVal Tensor floor_divide(@ByVal Scalar other);
  public native @ByRef Tensor floor_divide_(@ByVal Scalar other);
  public native @ByVal Tensor frac();
  public native @ByRef Tensor frac_();
  public native @ByVal Tensor gcd(@Const @ByRef Tensor other);
  public native @ByRef Tensor gcd_(@Const @ByRef Tensor other);
  public native @ByVal Tensor lcm(@Const @ByRef Tensor other);
  public native @ByRef Tensor lcm_(@Const @ByRef Tensor other);
  public native @ByRef Tensor index_copy_(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @Const @ByRef Tensor source);
  public native @ByVal Tensor index_copy(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @Const @ByRef Tensor source);
  public native @ByRef Tensor index_copy_(@ByVal Dimname dim, @Const @ByRef Tensor index, @Const @ByRef Tensor source);
  public native @ByVal Tensor index_copy(@ByVal Dimname dim, @Const @ByRef Tensor index, @Const @ByRef Tensor source);
  public native @ByVal Tensor inverse();
  public native @ByVal Tensor isclose(@Const @ByRef Tensor other, double rtol/*=1e-05*/, double atol/*=1e-08*/, @Cast("bool") boolean equal_nan/*=false*/);
  public native @ByVal Tensor isclose(@Const @ByRef Tensor other);
  public native @ByVal Tensor isnan();
  public native @Cast("bool") boolean is_distributed();
  public native @Cast("bool") boolean is_floating_point();
  public native @Cast("bool") boolean is_complex();
  public native @ByVal Tensor isreal();
  public native @Cast("bool") boolean is_nonzero();
  public native @Cast("bool") boolean is_same_size(@Const @ByRef Tensor other);
  public native @Cast("bool") boolean is_signed();
  public native @ByVal Tensor kron(@Const @ByRef Tensor other);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor kthvalue(@Cast("int64_t") long k, @Cast("int64_t") long dim/*=-1*/, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor kthvalue(@Cast("int64_t") long k);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor kthvalue(@Cast("int64_t") long k, @ByVal Dimname dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor kthvalue(@Cast("int64_t") long k, @ByVal Dimname dim);
  public native @ByVal Tensor nan_to_num(@ByVal(nullValue = "c10::optional<double>(c10::nullopt)") DoubleOptional nan, @ByVal(nullValue = "c10::optional<double>(c10::nullopt)") DoubleOptional posinf, @ByVal(nullValue = "c10::optional<double>(c10::nullopt)") DoubleOptional neginf);
  public native @ByVal Tensor nan_to_num();
  public native @ByRef Tensor nan_to_num_(@ByVal(nullValue = "c10::optional<double>(c10::nullopt)") DoubleOptional nan, @ByVal(nullValue = "c10::optional<double>(c10::nullopt)") DoubleOptional posinf, @ByVal(nullValue = "c10::optional<double>(c10::nullopt)") DoubleOptional neginf);
  public native @ByRef Tensor nan_to_num_();
  public native @ByVal Tensor ldexp(@Const @ByRef Tensor other);
  public native @ByRef Tensor ldexp_(@Const @ByRef Tensor other);
  public native @ByVal Tensor log();
  public native @ByRef Tensor log_();
  public native @ByVal Tensor log10();
  public native @ByRef Tensor log10_();
  public native @ByVal Tensor log1p();
  public native @ByRef Tensor log1p_();
  public native @ByVal Tensor log2();
  public native @ByRef Tensor log2_();
  public native @ByVal Tensor logaddexp(@Const @ByRef Tensor other);
  public native @ByVal Tensor logaddexp2(@Const @ByRef Tensor other);
  public native @ByVal Tensor xlogy(@Const @ByRef Tensor other);
  public native @ByVal Tensor xlogy(@ByVal Scalar other);
  public native @ByRef Tensor xlogy_(@Const @ByRef Tensor other);
  public native @ByRef Tensor xlogy_(@ByVal Scalar other);
  public native @ByVal Tensor logdet();
  public native @ByVal Tensor log_softmax(@Cast("int64_t") long dim, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor log_softmax(@Cast("int64_t") long dim);
  public native @ByVal Tensor log_softmax(@ByVal Dimname dim, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor log_softmax(@ByVal Dimname dim);
  public native @ByVal Tensor logcumsumexp(@Cast("int64_t") long dim);
  public native @ByVal Tensor logcumsumexp(@ByVal Dimname dim);
  public native @ByVal Tensor logsumexp(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor logsumexp(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim);
  public native @ByVal Tensor logsumexp(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor logsumexp(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... dim);
  public native @ByVal Tensor logsumexp(@ByVal DimnameArrayRef dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor logsumexp(@ByVal DimnameArrayRef dim);
  public native @ByVal Tensor matmul(@Const @ByRef Tensor other);
  public native @ByVal Tensor matrix_power(@Cast("int64_t") long n);
  public native @ByVal Tensor matrix_exp();
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor max(@Cast("int64_t") long dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor max(@Cast("int64_t") long dim);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor max(@ByVal Dimname dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor max(@ByVal Dimname dim);
  public native @ByVal Tensor amax(@ByVal(nullValue = "c10::IntArrayRef{}") @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor amax();
  public native @ByVal Tensor amax(@ByVal(nullValue = "c10::IntArrayRef{}") @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor mean(@ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor mean();
  public native @ByVal Tensor mean(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim, @Cast("bool") boolean keepdim/*=false*/, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor mean(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim);
  public native @ByVal Tensor mean(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] dim, @Cast("bool") boolean keepdim/*=false*/, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor mean(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... dim);
  public native @ByVal Tensor mean(@ByVal DimnameArrayRef dim, @Cast("bool") boolean keepdim/*=false*/, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor mean(@ByVal DimnameArrayRef dim);
  public native @ByVal Tensor median();
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor median(@Cast("int64_t") long dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor median(@Cast("int64_t") long dim);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor median(@ByVal Dimname dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor median(@ByVal Dimname dim);
  public native @ByVal Tensor nanmedian();
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor nanmedian(@Cast("int64_t") long dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor nanmedian(@Cast("int64_t") long dim);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor nanmedian(@ByVal Dimname dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor nanmedian(@ByVal Dimname dim);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor min(@Cast("int64_t") long dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor min(@Cast("int64_t") long dim);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor min(@ByVal Dimname dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor min(@ByVal Dimname dim);
  public native @ByVal Tensor amin(@ByVal(nullValue = "c10::IntArrayRef{}") @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor amin();
  public native @ByVal Tensor amin(@ByVal(nullValue = "c10::IntArrayRef{}") @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor mm(@Const @ByRef Tensor mat2);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor mode(@Cast("int64_t") long dim/*=-1*/, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor mode();
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor mode(@ByVal Dimname dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor mode(@ByVal Dimname dim);
  public native @ByVal Tensor mul(@Const @ByRef Tensor other);
  public native @ByRef Tensor mul_(@Const @ByRef Tensor other);
  public native @ByVal Tensor mul(@ByVal Scalar other);
  public native @ByRef Tensor mul_(@ByVal Scalar other);
  public native @ByVal Tensor multiply(@Const @ByRef Tensor other);
  public native @ByRef Tensor multiply_(@Const @ByRef Tensor other);
  public native @ByVal Tensor multiply(@ByVal Scalar other);
  public native @ByRef Tensor multiply_(@ByVal Scalar other);
  public native @ByVal Tensor mv(@Const @ByRef Tensor vec);
  public native @ByVal Tensor mvlgamma(@Cast("int64_t") long p);
  public native @ByRef Tensor mvlgamma_(@Cast("int64_t") long p);
  public native @ByVal Tensor narrow_copy(@Cast("int64_t") long dim, @Cast("int64_t") long start, @Cast("int64_t") long length);
  public native @ByVal Tensor narrow(@Cast("int64_t") long dim, @Cast("int64_t") long start, @Cast("int64_t") long length);
  public native @ByVal Tensor narrow(@Cast("int64_t") long dim, @Const @ByRef Tensor start, @Cast("int64_t") long length);
  public native @ByVal Tensor permute(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dims);
  public native @ByVal Tensor permute(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... dims);
  public native @ByVal Tensor movedim(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef source, @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef destination);
  public native @ByVal Tensor movedim(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] source, @ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... destination);
  public native @ByVal Tensor movedim(@Cast("int64_t") long source, @Cast("int64_t") long destination);
  public native @ByVal Tensor moveaxis(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef source, @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef destination);
  public native @ByVal Tensor moveaxis(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] source, @ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... destination);
  public native @ByVal Tensor moveaxis(@Cast("int64_t") long source, @Cast("int64_t") long destination);
  public native @ByVal Tensor numpy_T();
  public native @Cast("bool") boolean is_pinned();
  public native @ByVal Tensor pin_memory();
  public native @ByVal Tensor pinverse(double rcond/*=1e-15*/);
  public native @ByVal Tensor pinverse();
  public native @ByVal Tensor rad2deg();
  public native @ByRef Tensor rad2deg_();
  public native @ByVal Tensor deg2rad();
  public native @ByRef Tensor deg2rad_();
  public native @ByVal Tensor ravel();
  public native @ByVal Tensor reciprocal();
  public native @ByRef Tensor reciprocal_();
  public native @ByVal Tensor neg();
  public native @ByRef Tensor neg_();
  public native @ByVal Tensor negative();
  public native @ByRef Tensor negative_();
  public native @ByVal Tensor repeat(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef repeats);
  public native @ByVal Tensor repeat(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... repeats);
  public native @ByVal Tensor repeat_interleave(@Const @ByRef Tensor repeats, @ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional dim);
  public native @ByVal Tensor repeat_interleave(@Const @ByRef Tensor repeats);
  public native @ByVal Tensor repeat_interleave(@Cast("int64_t") long repeats, @ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional dim);
  public native @ByVal Tensor repeat_interleave(@Cast("int64_t") long repeats);
  public native @ByVal Tensor reshape(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef shape);
  public native @ByVal Tensor reshape(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... shape);
  public native @ByVal Tensor reshape_as(@Const @ByRef Tensor other);
  public native @ByVal Tensor round();
  public native @ByRef Tensor round_();
  public native @ByVal Tensor relu();
  public native @ByRef Tensor relu_();
  public native @ByVal Tensor prelu(@Const @ByRef Tensor weight);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor prelu_backward(@Const @ByRef Tensor grad_output, @Const @ByRef Tensor weight);
  public native @ByVal Tensor hardshrink(@ByVal(nullValue = "c10::Scalar(0.5)") Scalar lambd);
  public native @ByVal Tensor hardshrink();
  public native @ByVal Tensor hardshrink_backward(@Const @ByRef Tensor grad_out, @ByVal Scalar lambd);
  public native @ByVal Tensor rsqrt();
  public native @ByRef Tensor rsqrt_();
  public native @ByVal Tensor select(@ByVal Dimname dim, @Cast("int64_t") long index);
  public native @ByVal Tensor select(@Cast("int64_t") long dim, @Cast("int64_t") long index);
  public native @ByVal Tensor sigmoid();
  public native @ByRef Tensor sigmoid_();
  public native @ByVal Tensor logit(@ByVal(nullValue = "c10::optional<double>(c10::nullopt)") DoubleOptional eps);
  public native @ByVal Tensor logit();
  public native @ByRef Tensor logit_(@ByVal(nullValue = "c10::optional<double>(c10::nullopt)") DoubleOptional eps);
  public native @ByRef Tensor logit_();
  public native @ByVal Tensor sin();
  public native @ByRef Tensor sin_();
  public native @ByVal Tensor sinc();
  public native @ByRef Tensor sinc_();
  public native @ByVal Tensor sinh();
  public native @ByRef Tensor sinh_();
  public native @ByVal Tensor detach();
  public native @ByRef Tensor detach_();
  public native @Cast("int64_t") long size(@ByVal Dimname dim);
  public native @ByVal Tensor slice(@Cast("int64_t") long dim/*=0*/, @ByVal(nullValue = "c10::optional<int64_t>(0)") LongOptional start, @ByVal(nullValue = "c10::optional<int64_t>(9223372036854775807L)") LongOptional end, @Cast("int64_t") long step/*=1*/);
  public native @ByVal Tensor slice();
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor slogdet();
  public native @ByVal Tensor smm(@Const @ByRef Tensor mat2);
  public native @ByVal Tensor softmax(@Cast("int64_t") long dim, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor softmax(@Cast("int64_t") long dim);
  public native @ByVal Tensor softmax(@ByVal Dimname dim, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor softmax(@ByVal Dimname dim);
  public native @StdMove TensorVector unsafe_split(@Cast("int64_t") long split_size, @Cast("int64_t") long dim/*=0*/);
  public native @StdMove TensorVector unsafe_split(@Cast("int64_t") long split_size);
  public native @StdMove TensorVector split(@Cast("int64_t") long split_size, @Cast("int64_t") long dim/*=0*/);
  public native @StdMove TensorVector split(@Cast("int64_t") long split_size);
  public native @StdMove TensorVector unsafe_split_with_sizes(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef split_sizes, @Cast("int64_t") long dim/*=0*/);
  public native @StdMove TensorVector unsafe_split_with_sizes(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef split_sizes);
  public native @StdMove TensorVector unsafe_split_with_sizes(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] split_sizes, @Cast("int64_t") long dim/*=0*/);
  public native @StdMove TensorVector unsafe_split_with_sizes(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... split_sizes);
  public native @StdMove TensorVector split_with_sizes(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef split_sizes, @Cast("int64_t") long dim/*=0*/);
  public native @StdMove TensorVector split_with_sizes(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef split_sizes);
  public native @StdMove TensorVector split_with_sizes(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] split_sizes, @Cast("int64_t") long dim/*=0*/);
  public native @StdMove TensorVector split_with_sizes(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... split_sizes);
  public native @ByVal Tensor squeeze();
  public native @ByVal Tensor squeeze(@Cast("int64_t") long dim);
  public native @ByVal Tensor squeeze(@ByVal Dimname dim);
  public native @ByRef Tensor squeeze_();
  public native @ByRef Tensor squeeze_(@Cast("int64_t") long dim);
  public native @ByRef Tensor squeeze_(@ByVal Dimname dim);
  public native @ByVal Tensor sspaddmm(@Const @ByRef Tensor mat1, @Const @ByRef Tensor mat2, @ByVal(nullValue = "c10::Scalar(1)") Scalar beta, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByVal Tensor sspaddmm(@Const @ByRef Tensor mat1, @Const @ByRef Tensor mat2);
  public native @ByVal Tensor stft(@Cast("int64_t") long n_fft, @ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional hop_length, @ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional win_length, @Const @ByRef(nullValue = "c10::optional<at::Tensor>{}") TensorOptional window, @Cast("bool") boolean normalized/*=false*/, @ByVal(nullValue = "c10::optional<bool>(c10::nullopt)") BoolOptional onesided, @ByVal(nullValue = "c10::optional<bool>(c10::nullopt)") BoolOptional return_complex);
  public native @ByVal Tensor stft(@Cast("int64_t") long n_fft);
  public native @ByVal Tensor istft(@Cast("int64_t") long n_fft, @ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional hop_length, @ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional win_length, @Const @ByRef(nullValue = "c10::optional<at::Tensor>{}") TensorOptional window, @Cast("bool") boolean center/*=true*/, @Cast("bool") boolean normalized/*=false*/, @ByVal(nullValue = "c10::optional<bool>(c10::nullopt)") BoolOptional onesided, @ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional length, @Cast("bool") boolean return_complex/*=false*/);
  public native @ByVal Tensor istft(@Cast("int64_t") long n_fft);
  public native @Cast("int64_t") long stride(@ByVal Dimname dim);
  public native @ByVal Tensor sum(@ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor sum();
  public native @ByVal Tensor sum(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim, @Cast("bool") boolean keepdim/*=false*/, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor sum(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim);
  public native @ByVal Tensor sum(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] dim, @Cast("bool") boolean keepdim/*=false*/, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor sum(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... dim);
  public native @ByVal Tensor sum(@ByVal DimnameArrayRef dim, @Cast("bool") boolean keepdim/*=false*/, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor sum(@ByVal DimnameArrayRef dim);
  public native @ByVal Tensor nansum(@ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor nansum();
  public native @ByVal Tensor nansum(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim, @Cast("bool") boolean keepdim/*=false*/, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor nansum(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim);
  public native @ByVal Tensor nansum(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] dim, @Cast("bool") boolean keepdim/*=false*/, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor nansum(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... dim);
  public native @ByVal Tensor sum_to_size(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size);
  public native @ByVal Tensor sum_to_size(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... size);
  public native @ByVal Tensor sqrt();
  public native @ByRef Tensor sqrt_();
  public native @ByVal Tensor square();
  public native @ByRef Tensor square_();
  public native @ByVal Tensor std(@Cast("bool") boolean unbiased/*=true*/);
  public native @ByVal Tensor std();
  public native @ByVal Tensor std(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim, @Cast("bool") boolean unbiased/*=true*/, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor std(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim);
  public native @ByVal Tensor std(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] dim, @Cast("bool") boolean unbiased/*=true*/, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor std(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... dim);
  public native @ByVal Tensor std(@ByVal DimnameArrayRef dim, @Cast("bool") boolean unbiased/*=true*/, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor std(@ByVal DimnameArrayRef dim);
  public native @ByVal Tensor prod(@ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor prod();
  public native @ByVal Tensor prod(@Cast("int64_t") long dim, @Cast("bool") boolean keepdim/*=false*/, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor prod(@Cast("int64_t") long dim);
  public native @ByVal Tensor prod(@ByVal Dimname dim, @Cast("bool") boolean keepdim/*=false*/, @ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor prod(@ByVal Dimname dim);
  public native @ByVal Tensor t();
  public native @ByRef Tensor t_();
  public native @ByVal Tensor tan();
  public native @ByRef Tensor tan_();
  public native @ByVal Tensor tanh();
  public native @ByRef Tensor tanh_();
  public native @ByVal Tensor tile(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dims);
  public native @ByVal Tensor tile(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... dims);
  public native @ByVal Tensor transpose(@Cast("int64_t") long dim0, @Cast("int64_t") long dim1);
  public native @ByVal Tensor transpose(@ByVal Dimname dim0, @ByVal Dimname dim1);
  public native @ByRef Tensor transpose_(@Cast("int64_t") long dim0, @Cast("int64_t") long dim1);
  public native @ByVal Tensor flip(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dims);
  public native @ByVal Tensor flip(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... dims);
  public native @ByVal Tensor fliplr();
  public native @ByVal Tensor flipud();
  public native @ByVal Tensor roll(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef shifts, @ByVal(nullValue = "c10::IntArrayRef{}") @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dims);
  public native @ByVal Tensor roll(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef shifts);
  public native @ByVal Tensor roll(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] shifts, @ByVal(nullValue = "c10::IntArrayRef{}") @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... dims);
  public native @ByVal Tensor roll(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... shifts);
  public native @ByVal Tensor rot90(@Cast("int64_t") long k/*=1*/, @ByVal(nullValue = "c10::IntArrayRef({0,1})") @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dims);
  public native @ByVal Tensor rot90();
  public native @ByVal Tensor rot90(@Cast("int64_t") long k/*=1*/, @ByVal(nullValue = "c10::IntArrayRef({0,1})") @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... dims);
  public native @ByVal Tensor trunc();
  public native @ByRef Tensor trunc_();
  public native @ByVal Tensor fix();
  public native @ByRef Tensor fix_();
  public native @ByVal Tensor type_as(@Const @ByRef Tensor other);
  public native @ByVal Tensor unsqueeze(@Cast("int64_t") long dim);
  public native @ByRef Tensor unsqueeze_(@Cast("int64_t") long dim);
  public native @ByVal Tensor var(@Cast("bool") boolean unbiased/*=true*/);
  public native @ByVal Tensor var();
  public native @ByVal Tensor var(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim, @Cast("bool") boolean unbiased/*=true*/, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor var(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim);
  public native @ByVal Tensor var(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] dim, @Cast("bool") boolean unbiased/*=true*/, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor var(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... dim);
  public native @ByVal Tensor var(@ByVal DimnameArrayRef dim, @Cast("bool") boolean unbiased/*=true*/, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor var(@ByVal DimnameArrayRef dim);
  public native @ByVal Tensor view_as(@Const @ByRef Tensor other);
  public native @ByVal Tensor where(@Const @ByRef Tensor condition, @Const @ByRef Tensor other);
  public native @ByVal Tensor norm(@ByVal ScalarOptional p, ScalarType dtype);
  public native @ByVal Tensor norm(@ByVal(nullValue = "c10::Scalar(2)") Scalar p);
  public native @ByVal Tensor norm();
  public native @ByVal Tensor norm(@ByVal ScalarOptional p, @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim, @Cast("bool") boolean keepdim, ScalarType dtype);
  public native @ByVal Tensor norm(@ByVal ScalarOptional p, @ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] dim, @Cast("bool") boolean keepdim, ScalarType dtype);
  public native @ByVal Tensor norm(@ByVal ScalarOptional p, @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor norm(@ByVal ScalarOptional p, @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef dim);
  public native @ByVal Tensor norm(@ByVal ScalarOptional p, @ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor norm(@ByVal ScalarOptional p, @ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... dim);
  public native @ByVal Tensor norm(@ByVal ScalarOptional p, @ByVal DimnameArrayRef dim, @Cast("bool") boolean keepdim, ScalarType dtype);
  public native @ByVal Tensor norm(@ByVal ScalarOptional p, @ByVal DimnameArrayRef dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor norm(@ByVal ScalarOptional p, @ByVal DimnameArrayRef dim);
  public native @ByVal Tensor clone(@ByVal(nullValue = "c10::optional<c10::MemoryFormat>(c10::nullopt)") MemoryFormatOptional memory_format);
  public native @ByVal Tensor clone();
  public native @ByRef Tensor resize_as_(@Const @ByRef Tensor the_template, @ByVal(nullValue = "c10::optional<c10::MemoryFormat>(c10::nullopt)") MemoryFormatOptional memory_format);
  public native @ByRef Tensor resize_as_(@Const @ByRef Tensor the_template);
  public native @ByRef Tensor zero_();
  public native @ByVal Tensor sub(@Const @ByRef Tensor other, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByVal Tensor sub(@Const @ByRef Tensor other);
  public native @ByRef Tensor sub_(@Const @ByRef Tensor other, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByRef Tensor sub_(@Const @ByRef Tensor other);
  public native @ByVal Tensor sub(@ByVal Scalar other, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByVal Tensor sub(@ByVal Scalar other);
  public native @ByRef Tensor sub_(@ByVal Scalar other, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByRef Tensor sub_(@ByVal Scalar other);
  public native @ByVal Tensor subtract(@Const @ByRef Tensor other, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByVal Tensor subtract(@Const @ByRef Tensor other);
  public native @ByRef Tensor subtract_(@Const @ByRef Tensor other, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByRef Tensor subtract_(@Const @ByRef Tensor other);
  public native @ByVal Tensor subtract(@ByVal Scalar other, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByVal Tensor subtract(@ByVal Scalar other);
  public native @ByRef Tensor subtract_(@ByVal Scalar other, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByRef Tensor subtract_(@ByVal Scalar other);
  public native @ByVal Tensor heaviside(@Const @ByRef Tensor values);
  public native @ByRef Tensor heaviside_(@Const @ByRef Tensor values);
  public native @ByVal Tensor addmm(@Const @ByRef Tensor mat1, @Const @ByRef Tensor mat2, @ByVal(nullValue = "c10::Scalar(1)") Scalar beta, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByVal Tensor addmm(@Const @ByRef Tensor mat1, @Const @ByRef Tensor mat2);
  public native @ByRef Tensor addmm_(@Const @ByRef Tensor mat1, @Const @ByRef Tensor mat2, @ByVal(nullValue = "c10::Scalar(1)") Scalar beta, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByRef Tensor addmm_(@Const @ByRef Tensor mat1, @Const @ByRef Tensor mat2);
  public native @ByRef Tensor sparse_resize_(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @Cast("int64_t") long sparse_dim, @Cast("int64_t") long dense_dim);
  public native @ByRef Tensor sparse_resize_(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @Cast("int64_t") long sparse_dim, @Cast("int64_t") long dense_dim);
  public native @ByRef Tensor sparse_resize_and_clear_(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @Cast("int64_t") long sparse_dim, @Cast("int64_t") long dense_dim);
  public native @ByRef Tensor sparse_resize_and_clear_(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @Cast("int64_t") long sparse_dim, @Cast("int64_t") long dense_dim);
  public native @ByVal Tensor sparse_mask(@Const @ByRef Tensor mask);
  public native @ByVal Tensor to_dense(@ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor to_dense();
  public native @Cast("int64_t") long sparse_dim();
  public native @Cast("int64_t") long _dimI();
  public native @Cast("int64_t") long dense_dim();
  public native @Cast("int64_t") long _dimV();
  public native @Cast("int64_t") long _nnz();
  public native @ByVal Tensor coalesce();
  public native @Cast("bool") boolean is_coalesced();
  public native @ByVal Tensor _indices();
  public native @ByVal Tensor _values();
  public native @ByRef Tensor _coalesced_(@Cast("bool") boolean coalesced);
  public native @ByVal Tensor indices();
  public native @ByVal Tensor values();
  public native @StdMove TensorVector unbind(@Cast("int64_t") long dim/*=0*/);
  public native @StdMove TensorVector unbind();
  public native @StdMove TensorVector unbind(@ByVal Dimname dim);
  public native @ByVal Tensor to_sparse(@Cast("int64_t") long sparse_dim);
  public native @ByVal Tensor to_sparse();
  public native @ByVal Tensor to_mkldnn(@ByVal(nullValue = "c10::optional<at::ScalarType>(c10::nullopt)") ScalarTypeOptional dtype);
  public native @ByVal Tensor to_mkldnn();
  public native @ByVal Tensor dequantize();
  public native double q_scale();
  public native @Cast("int64_t") long q_zero_point();
  public native @ByVal Tensor q_per_channel_scales();
  public native @ByVal Tensor q_per_channel_zero_points();
  public native @Cast("int64_t") long q_per_channel_axis();
  public native @ByVal Tensor int_repr();
  public native QScheme qscheme();
  public native @ByVal Tensor to(@ByVal(nullValue = "c10::TensorOptions{}") TensorOptions options, @Cast("bool") boolean non_blocking/*=false*/, @Cast("bool") boolean copy/*=false*/, @ByVal(nullValue = "c10::optional<c10::MemoryFormat>(c10::nullopt)") MemoryFormatOptional memory_format);
  public native @ByVal Tensor to();
  public native @ByVal Tensor to(@ByVal ScalarTypeOptional dtype, @ByVal LayoutOptional layout, @ByVal DeviceOptional device, @ByVal BoolOptional pin_memory, @Cast("bool") boolean non_blocking, @Cast("bool") boolean copy, @ByVal MemoryFormatOptional memory_format);
  public native @ByVal Tensor to(@ByVal Device device, ScalarType dtype, @Cast("bool") boolean non_blocking/*=false*/, @Cast("bool") boolean copy/*=false*/, @ByVal(nullValue = "c10::optional<c10::MemoryFormat>(c10::nullopt)") MemoryFormatOptional memory_format);
  public native @ByVal Tensor to(@ByVal Device device, ScalarType dtype);
  public native @ByVal Tensor to(ScalarType dtype, @Cast("bool") boolean non_blocking/*=false*/, @Cast("bool") boolean copy/*=false*/, @ByVal(nullValue = "c10::optional<c10::MemoryFormat>(c10::nullopt)") MemoryFormatOptional memory_format);
  public native @ByVal Tensor to(ScalarType dtype);
  public native @ByVal Tensor to(@Const @ByRef Tensor other, @Cast("bool") boolean non_blocking/*=false*/, @Cast("bool") boolean copy/*=false*/, @ByVal(nullValue = "c10::optional<c10::MemoryFormat>(c10::nullopt)") MemoryFormatOptional memory_format);
  public native @ByVal Tensor to(@Const @ByRef Tensor other);
  public native @ByVal Scalar item();
  public native @ByRef Tensor set_(@Cast({"", "c10::Storage&&"}) @StdMove Storage source);
  public native @ByRef Tensor set_(@Cast({"", "c10::Storage&&"}) @StdMove Storage source, @Cast("int64_t") long storage_offset, @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size, @ByVal(nullValue = "c10::IntArrayRef{}") @Cast("c10::ArrayRef<int64_t>*") LongArrayRef stride);
  public native @ByRef Tensor set_(@Cast({"", "c10::Storage&&"}) @StdMove Storage source, @Cast("int64_t") long storage_offset, @ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size);
  public native @ByRef Tensor set_(@Cast({"", "c10::Storage&&"}) @StdMove Storage source, @Cast("int64_t") long storage_offset, @ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long[] size, @ByVal(nullValue = "c10::IntArrayRef{}") @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... stride);
  public native @ByRef Tensor set_(@Cast({"", "c10::Storage&&"}) @StdMove Storage source, @Cast("int64_t") long storage_offset, @ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... size);
  public native @ByRef Tensor set_(@Const @ByRef Tensor source);
  public native @ByRef Tensor set_();
  public native @Cast("bool") boolean is_set_to(@Const @ByRef Tensor tensor);
  public native @ByRef Tensor masked_fill_(@Const @ByRef Tensor mask, @ByVal Scalar value);
  public native @ByVal Tensor masked_fill(@Const @ByRef Tensor mask, @ByVal Scalar value);
  public native @ByRef Tensor masked_fill_(@Const @ByRef Tensor mask, @Const @ByRef Tensor value);
  public native @ByVal Tensor masked_fill(@Const @ByRef Tensor mask, @Const @ByRef Tensor value);
  public native @ByRef Tensor masked_scatter_(@Const @ByRef Tensor mask, @Const @ByRef Tensor source);
  public native @ByVal Tensor masked_scatter(@Const @ByRef Tensor mask, @Const @ByRef Tensor source);
  public native @ByVal Tensor view(@ByVal @Cast("c10::ArrayRef<int64_t>*") LongArrayRef size);
  public native @ByVal Tensor view(@ByVal @Cast({"int64_t*", "std::vector<int64_t>&"}) @StdVector long... size);
  public native @ByVal Tensor view(ScalarType dtype);
  public native @ByRef Tensor put_(@Const @ByRef Tensor index, @Const @ByRef Tensor source, @Cast("bool") boolean accumulate/*=false*/);
  public native @ByRef Tensor put_(@Const @ByRef Tensor index, @Const @ByRef Tensor source);
  public native @ByRef Tensor index_add_(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @Const @ByRef Tensor source);
  public native @ByVal Tensor index_add(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @Const @ByRef Tensor source);
  public native @ByVal Tensor index_add(@ByVal Dimname dim, @Const @ByRef Tensor index, @Const @ByRef Tensor source);
  public native @ByRef Tensor index_fill_(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @ByVal Scalar value);
  public native @ByVal Tensor index_fill(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @ByVal Scalar value);
  public native @ByRef Tensor index_fill_(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @Const @ByRef Tensor value);
  public native @ByVal Tensor index_fill(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @Const @ByRef Tensor value);
  public native @ByRef Tensor index_fill_(@ByVal Dimname dim, @Const @ByRef Tensor index, @ByVal Scalar value);
  public native @ByRef Tensor index_fill_(@ByVal Dimname dim, @Const @ByRef Tensor index, @Const @ByRef Tensor value);
  public native @ByVal Tensor index_fill(@ByVal Dimname dim, @Const @ByRef Tensor index, @ByVal Scalar value);
  public native @ByVal Tensor index_fill(@ByVal Dimname dim, @Const @ByRef Tensor index, @Const @ByRef Tensor value);
  public native @ByRef Tensor scatter_(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @Const @ByRef Tensor src);
  public native @ByVal Tensor scatter(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @Const @ByRef Tensor src);
  public native @ByRef Tensor scatter_(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @ByVal Scalar value);
  public native @ByVal Tensor scatter(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @ByVal Scalar value);
  public native @ByVal Tensor scatter(@ByVal Dimname dim, @Const @ByRef Tensor index, @Const @ByRef Tensor src);
  public native @ByVal Tensor scatter(@ByVal Dimname dim, @Const @ByRef Tensor index, @ByVal Scalar value);
  public native @ByRef Tensor scatter_(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @Const @ByRef Tensor src, @StdString BytePointer reduce);
  public native @ByRef Tensor scatter_(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @Const @ByRef Tensor src, @StdString String reduce);
  public native @ByRef Tensor scatter_(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @ByVal Scalar value, @StdString BytePointer reduce);
  public native @ByRef Tensor scatter_(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @ByVal Scalar value, @StdString String reduce);
  public native @ByRef Tensor scatter_add_(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @Const @ByRef Tensor src);
  public native @ByVal Tensor scatter_add(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @Const @ByRef Tensor src);
  public native @ByVal Tensor scatter_add(@ByVal Dimname dim, @Const @ByRef Tensor index, @Const @ByRef Tensor src);
  public native @ByRef Tensor eq_(@ByVal Scalar other);
  public native @ByRef Tensor eq_(@Const @ByRef Tensor other);
  public native @ByVal Tensor bitwise_and(@ByVal Scalar other);
  public native @ByVal Tensor bitwise_and(@Const @ByRef Tensor other);
  public native @ByRef Tensor bitwise_and_(@ByVal Scalar other);
  public native @ByRef Tensor bitwise_and_(@Const @ByRef Tensor other);
  public native @ByVal Tensor __and__(@ByVal Scalar other);
  public native @ByVal Tensor __and__(@Const @ByRef Tensor other);
  public native @ByRef Tensor __iand__(@ByVal Scalar other);
  public native @ByRef Tensor __iand__(@Const @ByRef Tensor other);
  public native @ByVal Tensor bitwise_or(@ByVal Scalar other);
  public native @ByVal Tensor bitwise_or(@Const @ByRef Tensor other);
  public native @ByRef Tensor bitwise_or_(@ByVal Scalar other);
  public native @ByRef Tensor bitwise_or_(@Const @ByRef Tensor other);
  public native @ByVal Tensor __or__(@ByVal Scalar other);
  public native @ByVal Tensor __or__(@Const @ByRef Tensor other);
  public native @ByRef Tensor __ior__(@ByVal Scalar other);
  public native @ByRef Tensor __ior__(@Const @ByRef Tensor other);
  public native @ByVal Tensor bitwise_xor(@ByVal Scalar other);
  public native @ByVal Tensor bitwise_xor(@Const @ByRef Tensor other);
  public native @ByRef Tensor bitwise_xor_(@ByVal Scalar other);
  public native @ByRef Tensor bitwise_xor_(@Const @ByRef Tensor other);
  public native @ByVal Tensor __xor__(@ByVal Scalar other);
  public native @ByVal Tensor __xor__(@Const @ByRef Tensor other);
  public native @ByRef Tensor __ixor__(@ByVal Scalar other);
  public native @ByRef Tensor __ixor__(@Const @ByRef Tensor other);
  public native @ByVal Tensor __lshift__(@ByVal Scalar other);
  public native @ByVal Tensor __lshift__(@Const @ByRef Tensor other);
  public native @ByRef Tensor __ilshift__(@ByVal Scalar other);
  public native @ByRef Tensor __ilshift__(@Const @ByRef Tensor other);
  public native @ByVal Tensor __rshift__(@ByVal Scalar other);
  public native @ByVal Tensor __rshift__(@Const @ByRef Tensor other);
  public native @ByRef Tensor __irshift__(@ByVal Scalar other);
  public native @ByRef Tensor __irshift__(@Const @ByRef Tensor other);
  public native @ByRef Tensor atan2_(@Const @ByRef Tensor other);
  public native @ByRef Tensor tril_(@Cast("int64_t") long diagonal/*=0*/);
  public native @ByRef Tensor tril_();
  public native @ByRef Tensor triu_(@Cast("int64_t") long diagonal/*=0*/);
  public native @ByRef Tensor triu_();
  public native @ByRef Tensor digamma_();
  public native @ByRef Tensor polygamma_(@Cast("int64_t") long n);
  public native @ByRef Tensor renorm_(@ByVal Scalar p, @Cast("int64_t") long dim, @ByVal Scalar maxnorm);
  public native @ByRef Tensor lerp_(@Const @ByRef Tensor end, @ByVal Scalar weight);
  public native @ByRef Tensor lerp_(@Const @ByRef Tensor end, @Const @ByRef Tensor weight);
  public native @ByRef Tensor fmod_(@ByVal Scalar other);
  public native @ByRef Tensor fmod_(@Const @ByRef Tensor other);
  public native @ByRef Tensor remainder_(@ByVal Scalar other);
  public native @ByRef Tensor remainder_(@Const @ByRef Tensor other);
  public native @ByRef Tensor addbmm_(@Const @ByRef Tensor batch1, @Const @ByRef Tensor batch2, @ByVal(nullValue = "c10::Scalar(1)") Scalar beta, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByRef Tensor addbmm_(@Const @ByRef Tensor batch1, @Const @ByRef Tensor batch2);
  public native @ByVal Tensor addbmm(@Const @ByRef Tensor batch1, @Const @ByRef Tensor batch2, @ByVal(nullValue = "c10::Scalar(1)") Scalar beta, @ByVal(nullValue = "c10::Scalar(1)") Scalar alpha);
  public native @ByVal Tensor addbmm(@Const @ByRef Tensor batch1, @Const @ByRef Tensor batch2);
  public native @ByRef Tensor addcdiv_(@Const @ByRef Tensor tensor1, @Const @ByRef Tensor tensor2, @ByVal(nullValue = "c10::Scalar(1)") Scalar value);
  public native @ByRef Tensor addcdiv_(@Const @ByRef Tensor tensor1, @Const @ByRef Tensor tensor2);
  public native @ByRef Tensor random_(@Cast("int64_t") long from, @ByVal LongOptional to, @ByVal(nullValue = "c10::optional<at::Generator>(c10::nullopt)") GeneratorOptional generator);
  public native @ByRef Tensor random_(@Cast("int64_t") long from, @ByVal LongOptional to);
  public native @ByRef Tensor random_(@Cast("int64_t") long to, @ByVal(nullValue = "c10::optional<at::Generator>(c10::nullopt)") GeneratorOptional generator);
  public native @ByRef Tensor random_(@Cast("int64_t") long to);
  public native @ByRef Tensor random_(@ByVal(nullValue = "c10::optional<at::Generator>(c10::nullopt)") GeneratorOptional generator);
  public native @ByRef Tensor random_();
  public native @ByRef Tensor uniform_(double from/*=0*/, double to/*=1*/, @ByVal(nullValue = "c10::optional<at::Generator>(c10::nullopt)") GeneratorOptional generator);
  public native @ByRef Tensor uniform_();
  public native @ByRef Tensor cauchy_(double median/*=0*/, double sigma/*=1*/, @ByVal(nullValue = "c10::optional<at::Generator>(c10::nullopt)") GeneratorOptional generator);
  public native @ByRef Tensor cauchy_();
  public native @ByRef Tensor log_normal_(double mean/*=1*/, double std/*=2*/, @ByVal(nullValue = "c10::optional<at::Generator>(c10::nullopt)") GeneratorOptional generator);
  public native @ByRef Tensor log_normal_();
  public native @ByRef Tensor exponential_(double lambd/*=1*/, @ByVal(nullValue = "c10::optional<at::Generator>(c10::nullopt)") GeneratorOptional generator);
  public native @ByRef Tensor exponential_();
  public native @ByRef Tensor geometric_(double p, @ByVal(nullValue = "c10::optional<at::Generator>(c10::nullopt)") GeneratorOptional generator);
  public native @ByRef Tensor geometric_(double p);
  public native @ByVal Tensor diag(@Cast("int64_t") long diagonal/*=0*/);
  public native @ByVal Tensor diag();
  public native @ByVal Tensor cross(@Const @ByRef Tensor other, @ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional dim);
  public native @ByVal Tensor cross(@Const @ByRef Tensor other);
  public native @ByVal Tensor triu(@Cast("int64_t") long diagonal/*=0*/);
  public native @ByVal Tensor triu();
  public native @ByVal Tensor tril(@Cast("int64_t") long diagonal/*=0*/);
  public native @ByVal Tensor tril();
  public native @ByVal Tensor trace();
  public native @ByVal Tensor ne(@ByVal Scalar other);
  public native @ByVal Tensor ne(@Const @ByRef Tensor other);
  public native @ByRef Tensor ne_(@ByVal Scalar other);
  public native @ByRef Tensor ne_(@Const @ByRef Tensor other);
  public native @ByVal Tensor not_equal(@ByVal Scalar other);
  public native @ByVal Tensor not_equal(@Const @ByRef Tensor other);
  public native @ByRef Tensor not_equal_(@ByVal Scalar other);
  public native @ByRef Tensor not_equal_(@Const @ByRef Tensor other);
  public native @ByVal Tensor eq(@ByVal Scalar other);
  public native @ByVal Tensor eq(@Const @ByRef Tensor other);
  public native @ByVal Tensor ge(@ByVal Scalar other);
  public native @ByVal Tensor ge(@Const @ByRef Tensor other);
  public native @ByRef Tensor ge_(@ByVal Scalar other);
  public native @ByRef Tensor ge_(@Const @ByRef Tensor other);
  public native @ByVal Tensor greater_equal(@ByVal Scalar other);
  public native @ByVal Tensor greater_equal(@Const @ByRef Tensor other);
  public native @ByRef Tensor greater_equal_(@ByVal Scalar other);
  public native @ByRef Tensor greater_equal_(@Const @ByRef Tensor other);
  public native @ByVal Tensor le(@ByVal Scalar other);
  public native @ByVal Tensor le(@Const @ByRef Tensor other);
  public native @ByRef Tensor le_(@ByVal Scalar other);
  public native @ByRef Tensor le_(@Const @ByRef Tensor other);
  public native @ByVal Tensor less_equal(@ByVal Scalar other);
  public native @ByVal Tensor less_equal(@Const @ByRef Tensor other);
  public native @ByRef Tensor less_equal_(@ByVal Scalar other);
  public native @ByRef Tensor less_equal_(@Const @ByRef Tensor other);
  public native @ByVal Tensor gt(@ByVal Scalar other);
  public native @ByVal Tensor gt(@Const @ByRef Tensor other);
  public native @ByRef Tensor gt_(@ByVal Scalar other);
  public native @ByRef Tensor gt_(@Const @ByRef Tensor other);
  public native @ByVal Tensor greater(@ByVal Scalar other);
  public native @ByVal Tensor greater(@Const @ByRef Tensor other);
  public native @ByRef Tensor greater_(@ByVal Scalar other);
  public native @ByRef Tensor greater_(@Const @ByRef Tensor other);
  public native @ByVal Tensor lt(@ByVal Scalar other);
  public native @ByVal Tensor lt(@Const @ByRef Tensor other);
  public native @ByRef Tensor lt_(@ByVal Scalar other);
  public native @ByRef Tensor lt_(@Const @ByRef Tensor other);
  public native @ByVal Tensor less(@ByVal Scalar other);
  public native @ByVal Tensor less(@Const @ByRef Tensor other);
  public native @ByRef Tensor less_(@ByVal Scalar other);
  public native @ByRef Tensor less_(@Const @ByRef Tensor other);
  public native @ByVal Tensor take(@Const @ByRef Tensor index);
  public native @ByVal Tensor index_select(@Cast("int64_t") long dim, @Const @ByRef Tensor index);
  public native @ByVal Tensor index_select(@ByVal Dimname dim, @Const @ByRef Tensor index);
  public native @ByVal Tensor masked_select(@Const @ByRef Tensor mask);
  public native @ByVal Tensor nonzero();
  public native @StdMove TensorVector nonzero_numpy();
  public native @ByVal Tensor gather(@Cast("int64_t") long dim, @Const @ByRef Tensor index, @Cast("bool") boolean sparse_grad/*=false*/);
  public native @ByVal Tensor gather(@Cast("int64_t") long dim, @Const @ByRef Tensor index);
  public native @ByVal Tensor gather(@ByVal Dimname dim, @Const @ByRef Tensor index, @Cast("bool") boolean sparse_grad/*=false*/);
  public native @ByVal Tensor gather(@ByVal Dimname dim, @Const @ByRef Tensor index);
  public native @ByVal Tensor addcmul(@Const @ByRef Tensor tensor1, @Const @ByRef Tensor tensor2, @ByVal(nullValue = "c10::Scalar(1)") Scalar value);
  public native @ByVal Tensor addcmul(@Const @ByRef Tensor tensor1, @Const @ByRef Tensor tensor2);
  public native @ByRef Tensor addcmul_(@Const @ByRef Tensor tensor1, @Const @ByRef Tensor tensor2, @ByVal(nullValue = "c10::Scalar(1)") Scalar value);
  public native @ByRef Tensor addcmul_(@Const @ByRef Tensor tensor1, @Const @ByRef Tensor tensor2);
  public native @ByVal Tensor addcdiv(@Const @ByRef Tensor tensor1, @Const @ByRef Tensor tensor2, @ByVal(nullValue = "c10::Scalar(1)") Scalar value);
  public native @ByVal Tensor addcdiv(@Const @ByRef Tensor tensor1, @Const @ByRef Tensor tensor2);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor lstsq(@Const @ByRef Tensor A);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor triangular_solve(@Const @ByRef Tensor A, @Cast("bool") boolean upper/*=true*/, @Cast("bool") boolean transpose/*=false*/, @Cast("bool") boolean unitriangular/*=false*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor triangular_solve(@Const @ByRef Tensor A);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor symeig(@Cast("bool") boolean eigenvectors/*=false*/, @Cast("bool") boolean upper/*=true*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor symeig();
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor eig(@Cast("bool") boolean eigenvectors/*=false*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor eig();
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor,at::Tensor>*") Tensor svd(@Cast("bool") boolean some/*=true*/, @Cast("bool") boolean compute_uv/*=true*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor,at::Tensor>*") Tensor svd();
  public native @ByVal Tensor swapaxes(@Cast("int64_t") long axis0, @Cast("int64_t") long axis1);
  public native @ByRef Tensor swapaxes_(@Cast("int64_t") long axis0, @Cast("int64_t") long axis1);
  public native @ByVal Tensor swapdims(@Cast("int64_t") long dim0, @Cast("int64_t") long dim1);
  public native @ByRef Tensor swapdims_(@Cast("int64_t") long dim0, @Cast("int64_t") long dim1);
  public native @ByVal Tensor cholesky(@Cast("bool") boolean upper/*=false*/);
  public native @ByVal Tensor cholesky();
  public native @ByVal Tensor cholesky_solve(@Const @ByRef Tensor input2, @Cast("bool") boolean upper/*=false*/);
  public native @ByVal Tensor cholesky_solve(@Const @ByRef Tensor input2);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor solve(@Const @ByRef Tensor A);
  public native @ByVal Tensor cholesky_inverse(@Cast("bool") boolean upper/*=false*/);
  public native @ByVal Tensor cholesky_inverse();
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor qr(@Cast("bool") boolean some/*=true*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor qr();
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor geqrf();
  public native @ByVal Tensor orgqr(@Const @ByRef Tensor input2);
  public native @ByVal Tensor ormqr(@Const @ByRef Tensor input2, @Const @ByRef Tensor input3, @Cast("bool") boolean left/*=true*/, @Cast("bool") boolean transpose/*=false*/);
  public native @ByVal Tensor ormqr(@Const @ByRef Tensor input2, @Const @ByRef Tensor input3);
  public native @ByVal Tensor lu_solve(@Const @ByRef Tensor LU_data, @Const @ByRef Tensor LU_pivots);
  public native @ByVal Tensor multinomial(@Cast("int64_t") long num_samples, @Cast("bool") boolean replacement/*=false*/, @ByVal(nullValue = "c10::optional<at::Generator>(c10::nullopt)") GeneratorOptional generator);
  public native @ByVal Tensor multinomial(@Cast("int64_t") long num_samples);
  public native @ByRef Tensor lgamma_();
  public native @ByVal Tensor lgamma();
  public native @ByVal Tensor digamma();
  public native @ByVal Tensor polygamma(@Cast("int64_t") long n);
  public native @ByVal Tensor erfinv();
  public native @ByRef Tensor erfinv_();
  public native @ByVal Tensor i0();
  public native @ByRef Tensor i0_();
  public native @ByVal Tensor sign();
  public native @ByRef Tensor sign_();
  public native @ByVal Tensor signbit();
  public native @ByVal Tensor dist(@Const @ByRef Tensor other, @ByVal(nullValue = "c10::Scalar(2)") Scalar p);
  public native @ByVal Tensor dist(@Const @ByRef Tensor other);
  public native @ByVal Tensor atan2(@Const @ByRef Tensor other);
  public native @ByVal Tensor lerp(@Const @ByRef Tensor end, @ByVal Scalar weight);
  public native @ByVal Tensor lerp(@Const @ByRef Tensor end, @Const @ByRef Tensor weight);
  public native @ByVal Tensor histc(@Cast("int64_t") long bins/*=100*/, @ByVal(nullValue = "c10::Scalar(0)") Scalar min, @ByVal(nullValue = "c10::Scalar(0)") Scalar max);
  public native @ByVal Tensor histc();
  public native @ByVal Tensor fmod(@ByVal Scalar other);
  public native @ByVal Tensor fmod(@Const @ByRef Tensor other);
  public native @ByVal Tensor hypot(@Const @ByRef Tensor other);
  public native @ByRef Tensor hypot_(@Const @ByRef Tensor other);
  public native @ByVal Tensor igamma(@Const @ByRef Tensor other);
  public native @ByRef Tensor igamma_(@Const @ByRef Tensor other);
  public native @ByVal Tensor igammac(@Const @ByRef Tensor other);
  public native @ByRef Tensor igammac_(@Const @ByRef Tensor other);
  public native @ByVal Tensor nextafter(@Const @ByRef Tensor other);
  public native @ByRef Tensor nextafter_(@Const @ByRef Tensor other);
  public native @ByVal Tensor remainder(@ByVal Scalar other);
  public native @ByVal Tensor remainder(@Const @ByRef Tensor other);
  public native @ByVal Tensor min();
  public native @ByVal Tensor fmin(@Const @ByRef Tensor other);
  public native @ByVal Tensor max();
  public native @ByVal Tensor fmax(@Const @ByRef Tensor other);
  public native @ByVal Tensor maximum(@Const @ByRef Tensor other);
  public native @ByVal Tensor max(@Const @ByRef Tensor other);
  public native @ByVal Tensor minimum(@Const @ByRef Tensor other);
  public native @ByVal Tensor min(@Const @ByRef Tensor other);
  public native @ByVal Tensor quantile(double q, @ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor quantile(double q);
  public native @ByVal Tensor quantile(@Const @ByRef Tensor q, @ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor quantile(@Const @ByRef Tensor q);
  public native @ByVal Tensor nanquantile(double q, @ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor nanquantile(double q);
  public native @ByVal Tensor nanquantile(@Const @ByRef Tensor q, @ByVal(nullValue = "c10::optional<int64_t>(c10::nullopt)") LongOptional dim, @Cast("bool") boolean keepdim/*=false*/);
  public native @ByVal Tensor nanquantile(@Const @ByRef Tensor q);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor sort(@Cast("int64_t") long dim/*=-1*/, @Cast("bool") boolean descending/*=false*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor sort();
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor sort(@ByVal Dimname dim, @Cast("bool") boolean descending/*=false*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor sort(@ByVal Dimname dim);
  public native @ByVal Tensor msort();
  public native @ByVal Tensor argsort(@Cast("int64_t") long dim/*=-1*/, @Cast("bool") boolean descending/*=false*/);
  public native @ByVal Tensor argsort();
  public native @ByVal Tensor argsort(@ByVal Dimname dim, @Cast("bool") boolean descending/*=false*/);
  public native @ByVal Tensor argsort(@ByVal Dimname dim);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor topk(@Cast("int64_t") long k, @Cast("int64_t") long dim/*=-1*/, @Cast("bool") boolean largest/*=true*/, @Cast("bool") boolean sorted/*=true*/);
  public native @ByVal @Cast("std::tuple<at::Tensor,at::Tensor>*") Tensor topk(@Cast("int64_t") long k);
  public native @ByVal Tensor all();
  public native @ByVal Tensor any();
  public native @ByVal Tensor renorm(@ByVal Scalar p, @Cast("int64_t") long dim, @ByVal Scalar maxnorm);
  public native @ByVal Tensor unfold(@Cast("int64_t") long dimension, @Cast("int64_t") long size, @Cast("int64_t") long step);
  public native @Cast("bool") boolean equal(@Const @ByRef Tensor other);
  public native @ByVal Tensor pow(@Const @ByRef Tensor exponent);
  public native @ByVal Tensor pow(@ByVal Scalar exponent);
  public native @ByRef Tensor pow_(@ByVal Scalar exponent);
  public native @ByRef Tensor pow_(@Const @ByRef Tensor exponent);
  public native @ByVal Tensor float_power(@Const @ByRef Tensor exponent);
  public native @ByVal Tensor float_power(@ByVal Scalar exponent);
  public native @ByRef Tensor float_power_(@ByVal Scalar exponent);
  public native @ByRef Tensor float_power_(@Const @ByRef Tensor exponent);
  public native @ByRef Tensor normal_(double mean/*=0*/, double std/*=1*/, @ByVal(nullValue = "c10::optional<at::Generator>(c10::nullopt)") GeneratorOptional generator);
  public native @ByRef Tensor normal_();
  public native @ByVal Tensor alias();
  public native @ByVal Tensor isfinite();
  public native @ByVal Tensor isinf();
  public native void record_stream(@ByVal Stream s);
  public native @ByVal Tensor isposinf();
  public native @ByVal Tensor isneginf();
  public native @ByVal Tensor det();
  public native @ByVal Tensor inner(@Const @ByRef Tensor other);
  public native @ByVal Tensor outer(@Const @ByRef Tensor vec2);
  public native @ByVal Tensor ger(@Const @ByRef Tensor vec2);

  // Special C++ only overloads for std()-like functions (See gh-40287)
  // These are needed because int -> bool conversion takes precedence over int -> IntArrayRef
  // So, for example std(0) would select the std(unbiased=False) overload

  public native @ByVal Tensor var(int dim);

  public native @ByVal Tensor std(int dim);

  // We changed .dtype() to return a TypeMeta in #12766. Ideally, we want the
  // at::kDouble and its friends to be TypeMeta's, but that hasn't happened yet.
  // Before that change, we make this method to maintain BC for C++ usage like
  // `x.to(y.dtype)`.
  // TODO: remove following two after at::kDouble and its friends are TypeMeta's.
  public native @ByVal Tensor to(@ByVal @Cast("caffe2::TypeMeta*") Pointer type_meta, @Cast("bool") boolean non_blocking/*=false*/, @Cast("bool") boolean copy/*=false*/);
  public native @ByVal Tensor to(@ByVal @Cast("caffe2::TypeMeta*") Pointer type_meta);
  public native @ByVal Tensor to(@ByVal Device device, @ByVal @Cast("caffe2::TypeMeta*") Pointer type_meta, @Cast("bool") boolean non_blocking/*=false*/, @Cast("bool") boolean copy/*=false*/);
  public native @ByVal Tensor to(@ByVal Device device, @ByVal @Cast("caffe2::TypeMeta*") Pointer type_meta);

  /** NOTE: This is similar to the legacy {@code .data()} function on {@code Variable}, and is intended
   *  to be used from functions that need to access the {@code Variable}'s equivalent {@code Tensor}
   *  (i.e. {@code Tensor} that shares the same storage and tensor metadata with the {@code Variable}).
   * 
   *  One notable difference with the legacy {@code .data()} function is that changes to the
   *  returned {@code Tensor}'s tensor metadata (e.g. sizes / strides / storage / storage_offset)
   *  will not update the original {@code Variable}, due to the fact that this function
   *  shallow-copies the {@code Variable}'s underlying TensorImpl. */
  
  ///
  public native @ByVal Tensor tensor_data();

  /** NOTE: {@code var.variable_data()} in C++ has the same semantics as {@code tensor.data}
   *  in Python, which create a new {@code Variable} that shares the same storage and
   *  tensor metadata with the original {@code Variable}, but with a completely new
   *  autograd history.
   * 
   *  NOTE: If we change the tensor metadata (e.g. sizes / strides /
   *  storage / storage_offset) of a variable created from {@code var.variable_data()}, those
   *  changes will not update the original variable {@code var}. In {@code .variable_data()}, we set
   *  {@code allow_tensor_metadata_change_} to false to make such changes explicitly illegal,
   *  in order to prevent users from changing metadata of {@code var.variable_data()}
   *  and expecting the original variable {@code var} to also be updated. */
  
  ///
  public native @ByVal Tensor variable_data();

  // Gradient Node and Edges
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  /** Gets the gradient function of the {@code Variable}. If this is a leaf variable,
   *  the pointer returned will be null.
   * 
   *  For View Variables:
   *  Gets the up-to-date grad_fn. If the shared data or base was modified, we
   *  re-create the grad_fn to express the up-to-date view relationship between
   *  this and the base Variable. */
  public native @SharedPtr Node grad_fn();

  // Hooks
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  ///
  ///
  ///

  /** Registers a backward hook.
   * 
   *  The hook will be called every time a gradient with respect to the Tensor is computed.
   *  The hook should have one of the following signature:
   *  <pre>{@code
   *  hook(Tensor grad) -> Tensor
   *  }</pre>
   *  <pre>{@code
   *  hook(Tensor grad) -> void
   *  }</pre>
   *  The hook should not modify its argument, but it can optionally return a new gradient
   *  which will be used in place of {@code grad}.
   * 
   *  This function returns the index of the hook in the list which can be used to remove hook.
   * 
   *  Example:
   *  <pre>{@code
   *  auto v = torch::tensor({0., 0., 0.}, torch::requires_grad());
   *  auto h = v.register_hook([](torch::Tensor grad){ return grad * 2; }); // double the gradient
   *  v.backward(torch::tensor({1., 2., 3.}));
   *  // This prints:
   *  // ```
   *  //  2
   *  //  4
   *  //  6
   *  // [ CPUFloatType{3} ]
   *  // ```
   *  std::cout << v.grad() << std::endl;
   *  v.remove_hook(h);  // removes the hook
   *  }</pre> */

  /** Remove hook at given position */
  public native void remove_hook(@Cast("unsigned") int pos);

  // View Variables
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  /** Returns true if this {@code Variable} is a view of another {@code Variable}. */
  public native @Cast("bool") boolean is_view();

  /** Returns the {@code Variable} that this {@code Variable} is a view of. If this
   *  {@code Variable} is not a view, throw a {@code std::runtime_error}. */
  public native @Const @ByRef Tensor _base();

  // Miscellaneous
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  public native @StdString BytePointer name();
}
