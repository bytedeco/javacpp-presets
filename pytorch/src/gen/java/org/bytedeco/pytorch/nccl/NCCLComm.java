// Targeted by JavaCPP version 1.5.13-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.pytorch.nccl;

import org.bytedeco.pytorch.Allocator;
import org.bytedeco.pytorch.Backend;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.cuda.cudart.*;
import static org.bytedeco.cuda.global.cudart.*;
import org.bytedeco.cuda.nccl.*;
import static org.bytedeco.cuda.global.nccl.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;
import org.bytedeco.javacpp.chrono.*;
import static org.bytedeco.javacpp.global.chrono.*;
import org.bytedeco.pytorch.*;
import static org.bytedeco.pytorch.global.torch.*;
import org.bytedeco.cuda.cublas.*;
import static org.bytedeco.cuda.global.cublas.*;
import org.bytedeco.cuda.cudnn.*;
import static org.bytedeco.cuda.global.cudnn.*;
import org.bytedeco.cuda.cusparse.*;
import static org.bytedeco.cuda.global.cusparse.*;
import org.bytedeco.cuda.cusolver.*;
import static org.bytedeco.cuda.global.cusolver.*;
import org.bytedeco.cuda.cupti.*;
import static org.bytedeco.cuda.global.cupti.*;
import org.bytedeco.pytorch.cuda.*;
import static org.bytedeco.pytorch.global.torch_cuda.*;

import static org.bytedeco.pytorch.global.torch_nccl.*;


// RAII wrapper for NCCL communicator
@Namespace("c10d") @NoOffset @Properties(inherit = org.bytedeco.pytorch.presets.torch_nccl.class)
public class NCCLComm extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public NCCLComm(Pointer p) { super(p); }

  public NCCLComm(ncclComm ncclComm) { super((Pointer)null); allocate(ncclComm); }
  @SharedPtr @Name("std::make_shared<c10d::NCCLComm>") private native void allocate(ncclComm ncclComm);

  public NCCLComm() { super((Pointer)null); allocate(); }
  @SharedPtr @Name("std::make_shared<c10d::NCCLComm>") private native void allocate();

  public native void setUniqueHash(@ByVal ncclUniqueId ncclId);
  public native void setUniqueHash(@StdString BytePointer hash);
  public native void setUniqueHash(@StdString String hash);
  public native @StdString BytePointer getUniqueHash();

  public static native @SharedPtr("c10d::NCCLComm") @ByVal NCCLComm create(
        int numRanks,
        int rank,
        @ByVal ncclUniqueId commId,
        byte deviceIndex);

// #ifdef NCCL_HAS_CONFIG
// #endif // NCCL_HAS_CONFIG

// #ifdef NCCL_HAS_COMM_SPLIT
// #endif // NCCL_HAS_COMM_SPLIT

// #if (defined(IS_NCCLX) || defined(USE_ROCM)) && defined(NCCL_COMM_DUMP)
// #endif

  public native byte getDeviceIndex();

  // Must not be copyable
  
  

  // Do not support move assignment as there is no valid use case
  

  // Move constructable
  // NOLINTNEXTLINE(*-noexcept-move-*)
  public NCCLComm(@ByRef(true) NCCLComm other) { super((Pointer)null); allocate(other); }
  @SharedPtr @Name("std::make_shared<c10d::NCCLComm>") private native void allocate(@ByRef(true) NCCLComm other);

  public native ncclComm getNcclComm();

  // Wait for the communicator to be ready. This is a blocking function.
  // Useful in nonblocking mode: NCCL requires the communicator to be ready
  // before issuing a second command.
  // Arguments:
  //   longInterval: if true, wait with sleep of an interval; otherwise, wait
  //   with `sched_yield` which is faster (but acquires CPU more frequently).
  //   Use `longInterval=true` when waiting for initialization or finalize to
  //   complete. Use `longInterval=false` when waiting collective call to return
  //   ncclSuccess.
  public native void waitReady(@Cast("bool") boolean longInterval);

  public native @ByVal StringOptional getNcclCommFailureReason();

  public native void abort(@ByVal(nullValue = "std::optional<std::string>(std::nullopt)") StringOptional commFailureReason);
  public native void abort();

  // Finalize a communicator -- asking it to flush its operations. When the
  // communicator is marked as nonblocking, this is a nonblocking function;
  // otherwise, it will block till all operations complete.
  public native void finalize();

  // Destroy a communicator. This is a blocking function.
  public native void destroy();

  public native @Cast("bool") boolean isInitialized();

  public native @Cast("bool") boolean isAborted();

  public native @Cast("uint64_t") long getCommSplitCounter();

  public native @Cast("ncclResult_t") int checkForNcclError();

  public native @Cast("ncclResult_t") int registerSegment(
        Pointer ptr,
        @Cast("size_t") long size,
        @Cast("bool") boolean errorOnRereg/*=true*/,
        @Cast("bool") boolean window/*=false*/);
  public native @Cast("ncclResult_t") int registerSegment(
        Pointer ptr,
        @Cast("size_t") long size);

  public native @Cast("ncclResult_t") int deregisterSegment(Pointer ptr, @Cast("bool") boolean window/*=false*/);
  public native @Cast("ncclResult_t") int deregisterSegment(Pointer ptr);

  public native @StdString BytePointer repr();
}
