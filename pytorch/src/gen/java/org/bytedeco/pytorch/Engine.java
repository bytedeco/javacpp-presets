// Targeted by JavaCPP version 1.5.11-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.pytorch;

import org.bytedeco.pytorch.Allocator;
import org.bytedeco.pytorch.Function;
import org.bytedeco.pytorch.functions.*;
import org.bytedeco.pytorch.chrono.*;
import org.bytedeco.pytorch.Module;
import org.bytedeco.javacpp.annotation.Cast;
import org.bytedeco.pytorch.presets.torch.IntrusivePtr;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;

import static org.bytedeco.pytorch.global.torch.*;


// A single instance of this struct should be created through the whole process
// lifetime. The worker thread creation logic and Engine's destructor rely on
// this.
@Namespace("torch::autograd") @NoOffset @Properties(inherit = org.bytedeco.pytorch.presets.torch.class)
public class Engine extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Engine(Pointer p) { super(p); }

  /** Returns a reference to a static {@code Engine} instance. */
  public static native @ByRef Engine get_default_engine();

  public static native @ByRef Engine get_base_engine();

  // compiled_autograd needs to live in a different .so file so that it
  // can have python symbols, so we add a layer of indirection
  // see [Note: Compiled Autograd]
  

  
  

  // Given a list of (Node, input number) pairs computes the value of the graph
  // by following next_edge references.
  public native @ByVal TensorVector execute(
        @Const @ByRef EdgeVector roots,
        @Const @ByRef TensorVector inputs,
        @Cast("bool") boolean keep_graph,
        @Cast("bool") boolean create_graph,
        @Cast("bool") boolean accumulate_grad,
        @Const @ByRef(nullValue = "torch::autograd::edge_list{}") EdgeVector outputs);
  public native @ByVal TensorVector execute(
        @Const @ByRef EdgeVector roots,
        @Const @ByRef TensorVector inputs,
        @Cast("bool") boolean keep_graph,
        @Cast("bool") boolean create_graph,
        @Cast("bool") boolean accumulate_grad);

  // Given a pre-populated GraphTask and GraphRoot, computes the backward pass
  // for the graph.
  //
  // NB: This API should only be used by internal autograd specific
  // machinery and shouldn't be exposed to users in anyway.

  public native @UniquePtr AnomalyMetadata make_anomaly_metadata();

  public native @UniquePtr SavedVariableHooks get_default_saved_variable_hooks();

  // We pass cpu_ready_queue to evaluate_function, so that it knows
  // the correct ready queue to push to after a NodeTask is ready

  public native void initialize_device_threads_pool();

  public native void queue_callback(@ByVal Func callback);

  public native @Cast("bool") boolean is_checkpoint_valid();

  // Should be called after fork to notify that worker threads are gone
  public native void release_workers();

  // Must be called by subclass before destructing to avoid a data-race-on-vptr.
  public native void stop();

  // Initializes a device thread for the autograd engine.
}
