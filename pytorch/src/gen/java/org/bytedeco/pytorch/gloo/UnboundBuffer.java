// Targeted by JavaCPP version 1.5.12-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.pytorch.gloo;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;
import org.bytedeco.javacpp.chrono.*;
import static org.bytedeco.javacpp.global.chrono.*;
import org.bytedeco.pytorch.*;
import static org.bytedeco.pytorch.global.torch.*;

import static org.bytedeco.pytorch.global.gloo.*;


// The unbound buffer class represents a chunk of memory.
// It can either be used as a source for send operations or a
// destination for receive operations, or both. There should only be a
// single pending operation against an unbound buffer at any given
// time, or resulting behavior is undefined.
//
// It is called unbound to contrast with the bound buffers that have
// been available since the inception of Gloo. It is unbound in that
// it is not tied to a particular pair.
//
@Namespace("gloo::transport") @NoOffset @Properties(inherit = org.bytedeco.pytorch.presets.gloo.class)
public class UnboundBuffer extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public UnboundBuffer(Pointer p) { super(p); }


  @MemberGetter public native Pointer ptr();
  @MemberGetter public native @Cast("const size_t") long size();

  // If specified, the source of this recv is stored in the rank pointer.
  // Returns true if it completed, false if it was aborted.
  public native @Cast("bool") boolean waitRecv(IntPointer rank, @ByVal Milliseconds timeout);
  public native @Cast("bool") boolean waitRecv(IntBuffer rank, @ByVal Milliseconds timeout);
  public native @Cast("bool") boolean waitRecv(int[] rank, @ByVal Milliseconds timeout);

  // If specified, the destination of this send is stored in the rank pointer.
  // Returns true if it completed, false if it was aborted.
  public native @Cast("bool") boolean waitSend(IntPointer rank, @ByVal Milliseconds timeout);
  public native @Cast("bool") boolean waitSend(IntBuffer rank, @ByVal Milliseconds timeout);
  public native @Cast("bool") boolean waitSend(int[] rank, @ByVal Milliseconds timeout);

  // Aborts a pending waitRecv call.
  public native void abortWaitRecv();

  // Aborts a pending waitSend call.
  public native void abortWaitSend();

  // Default overload.
  public native @Cast("bool") boolean waitRecv();

  // Default overload.
  public native @Cast("bool") boolean waitSend();

  // Rank overload.
  public native @Cast("bool") boolean waitRecv(IntPointer rank);
  public native @Cast("bool") boolean waitRecv(IntBuffer rank);
  public native @Cast("bool") boolean waitRecv(int[] rank);

  // Rank overload.
  public native @Cast("bool") boolean waitSend(IntPointer rank);
  public native @Cast("bool") boolean waitSend(IntBuffer rank);
  public native @Cast("bool") boolean waitSend(int[] rank);

  // Timeout overload.
  public native @Cast("bool") boolean waitRecv(@ByVal Milliseconds timeout);

  // Timeout overload.
  public native @Cast("bool") boolean waitSend(@ByVal Milliseconds timeout);

  // Deadline overload.

  // Deadline overload.

  // If the byte count argument is not specified, it will default the
  // number of bytes to be equal to the number of bytes remaining in
  // the buffer w.r.t. the offset.

  public native void send(
        int dstRank,
        @Cast("uint64_t") long slot,
        @Cast("size_t") long offset/*=0*/,
        @Cast("size_t") long nbytes/*=gloo::transport::UnboundBuffer::kUnspecifiedByteCount*/);
  public native void send(
        int dstRank,
        @Cast("uint64_t") long slot);

  public native void recv(
        int srcRank,
        @Cast("uint64_t") long slot,
        @Cast("size_t") long offset/*=0*/,
        @Cast("size_t") long nbytes/*=gloo::transport::UnboundBuffer::kUnspecifiedByteCount*/);
  public native void recv(
        int srcRank,
        @Cast("uint64_t") long slot);

  public native void recv(
        @StdVector IntPointer srcRanks,
        @Cast("uint64_t") long slot,
        @Cast("size_t") long offset/*=0*/,
        @Cast("size_t") long nbytes/*=gloo::transport::UnboundBuffer::kUnspecifiedByteCount*/);
  public native void recv(
        @StdVector IntPointer srcRanks,
        @Cast("uint64_t") long slot);
  public native void recv(
        @StdVector IntBuffer srcRanks,
        @Cast("uint64_t") long slot,
        @Cast("size_t") long offset/*=0*/,
        @Cast("size_t") long nbytes/*=gloo::transport::UnboundBuffer::kUnspecifiedByteCount*/);
  public native void recv(
        @StdVector IntBuffer srcRanks,
        @Cast("uint64_t") long slot);
  public native void recv(
        @StdVector int[] srcRanks,
        @Cast("uint64_t") long slot,
        @Cast("size_t") long offset/*=0*/,
        @Cast("size_t") long nbytes/*=gloo::transport::UnboundBuffer::kUnspecifiedByteCount*/);
  public native void recv(
        @StdVector int[] srcRanks,
        @Cast("uint64_t") long slot);
}
