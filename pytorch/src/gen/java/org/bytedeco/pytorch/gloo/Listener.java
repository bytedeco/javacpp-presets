// Targeted by JavaCPP version 1.5.13-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.pytorch.gloo;

import org.bytedeco.pytorch.gloo.Device;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;
import org.bytedeco.javacpp.chrono.*;
import static org.bytedeco.javacpp.global.chrono.*;
import org.bytedeco.pytorch.*;
import static org.bytedeco.pytorch.global.torch.*;

import static org.bytedeco.pytorch.global.torch_gloo.*;


// Listener deals with incoming connections. Incoming connections
// write a few bytes containing a sequence number. This sequence
// number is read off the socket and matched to a local sequence
// number. If there is a match, the socket is passed to the
// corresponding pair. If it can't be matched, it is stashed until a
// pair with the sequence number calls `waitForConnection`.
@Namespace("gloo::transport::tcp") @NoOffset @Properties(inherit = org.bytedeco.pytorch.presets.torch_gloo.class)
public class Listener extends Handler {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Listener(Pointer p) { super(p); }


  @MemberGetter public static native int kBacklog();
  public static final int kBacklog = kBacklog(); // allow somaxconn

  public Listener(@SharedPtr Loop loop, @Const @ByRef attr attr) { super((Pointer)null); allocate(loop, attr); }
  private native void allocate(@SharedPtr Loop loop, @Const @ByRef attr attr);

  public native void handleEvents(@ByRef Loop loop, int events);

  

  

  // Wait for connection with sequence number `seq`. The callback is
  // always called from a different thread (the event loop thread),
  // even if the connection is already available.
  

  public native void shutdown();
}
