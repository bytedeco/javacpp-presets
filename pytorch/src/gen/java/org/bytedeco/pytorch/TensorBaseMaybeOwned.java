// Targeted by JavaCPP version 1.5.10: DO NOT EDIT THIS FILE

package org.bytedeco.pytorch;

import org.bytedeco.pytorch.Allocator;
import org.bytedeco.pytorch.Function;
import org.bytedeco.pytorch.functions.*;
import org.bytedeco.pytorch.Module;
import org.bytedeco.javacpp.annotation.Cast;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;

import static org.bytedeco.pytorch.global.torch.*;

@Name("c10::MaybeOwned<at::TensorBase>") @NoOffset @Properties(inherit = org.bytedeco.pytorch.presets.torch.class)
public class TensorBaseMaybeOwned extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorBaseMaybeOwned(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TensorBaseMaybeOwned(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TensorBaseMaybeOwned position(long position) {
        return (TensorBaseMaybeOwned)super.position(position);
    }
    @Override public TensorBaseMaybeOwned getPointer(long i) {
        return new TensorBaseMaybeOwned((Pointer)this).offsetAddress(i);
    }

  public TensorBaseMaybeOwned() { super((Pointer)null); allocate(); }
  private native void allocate();

  // Copying a borrow yields another borrow of the original, as with a
  // T*. Copying an owned T yields another owned T for safety: no
  // chains of borrowing by default! (Note you could get that behavior
  // with MaybeOwned<T>::borrowed(*rhs) if you wanted it.)
  public TensorBaseMaybeOwned(@Cast({"", "c10::MaybeOwned<at::TensorBase>&&"}) @StdMove TensorBaseMaybeOwned rhs) { super((Pointer)null); allocate(rhs); }
  private native void allocate(@Cast({"", "c10::MaybeOwned<at::TensorBase>&&"}) @StdMove TensorBaseMaybeOwned rhs);

  public native @ByRef @Name("operator =") TensorBaseMaybeOwned put(@Cast({"", "c10::MaybeOwned<at::TensorBase>&&"}) @StdMove TensorBaseMaybeOwned rhs);

  public static native @Cast({"", "c10::MaybeOwned<at::TensorBase>&&"}) @StdMove TensorBaseMaybeOwned borrowed(@Const @ByRef TensorBase t);

  public static native @NoException(true) @Cast({"", "c10::MaybeOwned<at::TensorBase>&&"}) @StdMove TensorBaseMaybeOwned owned(@ByRef(true) TensorBase t);

  // This is an implementation detail!  You should know what you're doing
  // if you are testing this.  If you just want to guarantee ownership move
  // this into a T
  public native @Cast("bool") boolean unsafeIsBorrowed();

  public native @Const @ByRef @Name("operator *") TensorBase multiply();

  public native @Const @Name("operator ->") TensorBase access();

  // If borrowed, copy the underlying T. If owned, move from
  // it. borrowed/owned state remains the same, and either we
  // reference the same borrow as before or we are an owned moved-from
  // T.
  
}
