// Targeted by JavaCPP version 1.5.6-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.modsecurity;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

import static org.bytedeco.modsecurity.global.modsecurity.*;



// #ifdef __cplusplus



@Namespace("modsecurity") @NoOffset @Properties(inherit = org.bytedeco.modsecurity.presets.modsecurity.class)
public class RuleMessage extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RuleMessage(Pointer p) { super(p); }

    /** enum modsecurity::RuleMessage::LogMessageInfo */
    public static final int
        ErrorLogTailLogMessageInfo = 2,
        ClientLogMessageInfo = 4;

    /**
     *
     * FIXME: RuleMessage is currently too big, doing a lot of
     * unnecessary data duplication. Needs to be shrink down.
     *
     */

    public RuleMessage(RuleMessage rule) { super((Pointer)null); allocate(rule); }
    private native void allocate(RuleMessage rule);

    public native @ByRef @Name("operator =") RuleMessage put(@Const @ByRef RuleMessage ruleMessage);

    public native void clean();

    public native @StdString BytePointer log();
    public native @StdString BytePointer log(int props);
    public native @StdString BytePointer log(int props, int responseCode);
    public native @StdString BytePointer errorLog();

    public static native @StdString BytePointer log(@Const RuleMessage rm, int props, int code);
    public static native @StdString BytePointer log(@Const RuleMessage rm, int props);
    public static native @StdString BytePointer log(@Const RuleMessage rm);

    public static native @StdString BytePointer _details(@Const RuleMessage rm);
    public static native @StdString BytePointer _errorLogTail(@Const RuleMessage rm);

    public native int m_accuracy(); public native RuleMessage m_accuracy(int setter);
    public native @StdString BytePointer m_data(); public native RuleMessage m_data(BytePointer setter);
    public native @Cast("bool") boolean m_isDisruptive(); public native RuleMessage m_isDisruptive(boolean setter);
    public native @StdString BytePointer m_match(); public native RuleMessage m_match(BytePointer setter);
    public native int m_maturity(); public native RuleMessage m_maturity(int setter);
    public native @StdString BytePointer m_message(); public native RuleMessage m_message(BytePointer setter);
    public native @Cast("bool") boolean m_noAuditLog(); public native RuleMessage m_noAuditLog(boolean setter);
    public native int m_phase(); public native RuleMessage m_phase(int setter);
    public native @StdString BytePointer m_reference(); public native RuleMessage m_reference(BytePointer setter);
    public native @StdString BytePointer m_rev(); public native RuleMessage m_rev(BytePointer setter);
    public native int m_ruleId(); public native RuleMessage m_ruleId(int setter);
    public native int m_ruleLine(); public native RuleMessage m_ruleLine(int setter);
    public native @Cast("bool") boolean m_saveMessage(); public native RuleMessage m_saveMessage(boolean setter);
    public native int m_severity(); public native RuleMessage m_severity(int setter);
    public native @StdString BytePointer m_ver(); public native RuleMessage m_ver(BytePointer setter);

    public native @ByRef StringList m_tags(); public native RuleMessage m_tags(StringList setter);
}
