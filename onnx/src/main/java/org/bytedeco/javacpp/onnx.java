// Targeted by JavaCPP version 1.4.4: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class onnx extends org.bytedeco.javacpp.presets.onnx {
    static { Loader.load(); }

@Name("std::map<std::string,onnx::OpSchema::Attribute>") public static class StringAttributeMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringAttributeMap(Pointer p) { super(p); }
    public StringAttributeMap()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef StringAttributeMap put(@ByRef StringAttributeMap x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index(function = "at") public native @ByRef OpSchema.Attribute get(@StdString BytePointer i);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter @StdString BytePointer first();
        public native @Name("operator*().second") @MemberGetter @ByRef @Const OpSchema.Attribute second();
    }
}

@Name("std::set<int>") public static class IntSet extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IntSet(Pointer p) { super(p); }
    public IntSet()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef IntSet put(@ByRef IntSet x);

    public boolean empty() { return size() == 0; }
    public native long size();

    public native void insert(int value);
    public native void erase(int value);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") int get();
    }
}

@Name("std::set<std::string>") public static class StringSet extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringSet(Pointer p) { super(p); }
    public StringSet()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef StringSet put(@ByRef StringSet x);

    public boolean empty() { return size() == 0; }
    public native long size();

    public native void insert(@StdString BytePointer value);
    public native void erase(@StdString BytePointer value);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @StdString BytePointer get();
    }
}

@Name("std::vector<onnx::OpSchema::TypeConstraintParam>") public static class TypeConstraintParamVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeConstraintParamVector(Pointer p) { super(p); }
    public TypeConstraintParamVector()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef TypeConstraintParamVector put(@ByRef TypeConstraintParamVector x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index(function = "at") public native @ByRef OpSchema.TypeConstraintParam get(@Cast("size_t") long i);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @ByRef @Const OpSchema.TypeConstraintParam get();
    }
}

@Name("std::vector<float>") public static class FloatVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FloatVector(Pointer p) { super(p); }
    public FloatVector(float value) { this(1); put(0, value); }
    public FloatVector(float ... array) { this(array.length); put(array); }
    public FloatVector()       { allocate();  }
    public FloatVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef FloatVector put(@ByRef FloatVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native float get(@Cast("size_t") long i);
    public native FloatVector put(@Cast("size_t") long i, float value);

    public native @ByVal Iterator insert(@ByVal Iterator pos, float value);
    public native @ByVal Iterator erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") float get();
    }

    public float[] get() {
        float[] array = new float[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public float pop_back() {
        long size = size();
        float value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public FloatVector push_back(float value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public FloatVector put(float value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public FloatVector put(float ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<int64_t>") public static class LongVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LongVector(Pointer p) { super(p); }
    public LongVector(long ... array) { this(array.length); put(array); }
    public LongVector()       { allocate();  }
    public LongVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef LongVector put(@ByRef LongVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native @Cast("int64_t") long get(@Cast("size_t") long i);
    public native LongVector put(@Cast("size_t") long i, long value);

    public native @ByVal Iterator insert(@ByVal Iterator pos, @Cast("int64_t") long value);
    public native @ByVal Iterator erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @Cast("int64_t") long get();
    }

    public long[] get() {
        long[] array = new long[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public long pop_back() {
        long size = size();
        long value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public LongVector push_back(long value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public LongVector put(long value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public LongVector put(long ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<std::string>") public static class StringVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringVector(Pointer p) { super(p); }
    public StringVector(BytePointer value) { this(1); put(0, value); }
    public StringVector(BytePointer ... array) { this(array.length); put(array); }
    public StringVector(String value) { this(1); put(0, value); }
    public StringVector(String ... array) { this(array.length); put(array); }
    public StringVector()       { allocate();  }
    public StringVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef StringVector put(@ByRef StringVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native @StdString BytePointer get(@Cast("size_t") long i);
    public native StringVector put(@Cast("size_t") long i, BytePointer value);
    @ValueSetter @Index(function = "at") public native StringVector put(@Cast("size_t") long i, @StdString String value);

    public native @ByVal Iterator insert(@ByVal Iterator pos, @StdString BytePointer value);
    public native @ByVal Iterator erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @StdString BytePointer get();
    }

    public BytePointer[] get() {
        BytePointer[] array = new BytePointer[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public BytePointer pop_back() {
        long size = size();
        BytePointer value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public StringVector push_back(BytePointer value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public StringVector put(BytePointer value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public StringVector put(BytePointer ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }

    public StringVector push_back(String value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public StringVector put(String value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public StringVector put(String ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<onnx::OpSchema>") public static class OpSchemaVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSchemaVector(Pointer p) { super(p); }
    public OpSchemaVector(OpSchema value) { this(1); put(0, value); }
    public OpSchemaVector(OpSchema ... array) { this(array.length); put(array); }
    public OpSchemaVector()       { allocate();  }
    public OpSchemaVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef OpSchemaVector put(@ByRef OpSchemaVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native @ByRef OpSchema get(@Cast("size_t") long i);
    public native OpSchemaVector put(@Cast("size_t") long i, OpSchema value);

    public native @ByVal Iterator insert(@ByVal Iterator pos, @ByRef OpSchema value);
    public native @ByVal Iterator erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @ByRef @Const OpSchema get();
    }

    public OpSchema[] get() {
        OpSchema[] array = new OpSchema[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public OpSchema pop_back() {
        long size = size();
        OpSchema value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public OpSchemaVector push_back(OpSchema value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public OpSchemaVector put(OpSchema value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public OpSchemaVector put(OpSchema ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<onnx::OpSchema::FormalParameter>") public static class FormalParameterVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FormalParameterVector(Pointer p) { super(p); }
    public FormalParameterVector(OpSchema.FormalParameter value) { this(1); put(0, value); }
    public FormalParameterVector(OpSchema.FormalParameter ... array) { this(array.length); put(array); }
    public FormalParameterVector()       { allocate();  }
    public FormalParameterVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef FormalParameterVector put(@ByRef FormalParameterVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native @ByRef OpSchema.FormalParameter get(@Cast("size_t") long i);
    public native FormalParameterVector put(@Cast("size_t") long i, OpSchema.FormalParameter value);

    public native @ByVal Iterator insert(@ByVal Iterator pos, @ByRef OpSchema.FormalParameter value);
    public native @ByVal Iterator erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @ByRef @Const OpSchema.FormalParameter get();
    }

    public OpSchema.FormalParameter[] get() {
        OpSchema.FormalParameter[] array = new OpSchema.FormalParameter[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public OpSchema.FormalParameter pop_back() {
        long size = size();
        OpSchema.FormalParameter value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public FormalParameterVector push_back(OpSchema.FormalParameter value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public FormalParameterVector put(OpSchema.FormalParameter value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public FormalParameterVector put(OpSchema.FormalParameter ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<const onnx::TensorShapeProto*>") public static class TensorShapeProtoVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorShapeProtoVector(Pointer p) { super(p); }
    public TensorShapeProtoVector(TensorShapeProto value) { this(1); put(0, value); }
    public TensorShapeProtoVector(TensorShapeProto ... array) { this(array.length); put(array); }
    public TensorShapeProtoVector()       { allocate();  }
    public TensorShapeProtoVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef TensorShapeProtoVector put(@ByRef TensorShapeProtoVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native @Const TensorShapeProto get(@Cast("size_t") long i);
    public native TensorShapeProtoVector put(@Cast("size_t") long i, TensorShapeProto value);

    public native @ByVal Iterator insert(@ByVal Iterator pos, @Const TensorShapeProto value);
    public native @ByVal Iterator erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @Const TensorShapeProto get();
    }

    public TensorShapeProto[] get() {
        TensorShapeProto[] array = new TensorShapeProto[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public TensorShapeProto pop_back() {
        long size = size();
        TensorShapeProto value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public TensorShapeProtoVector push_back(TensorShapeProto value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public TensorShapeProtoVector put(TensorShapeProto value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public TensorShapeProtoVector put(TensorShapeProto ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@NoOffset @Name("std::pair<google::protobuf::uint64,google::protobuf::uint64>") public static class LongLongPair extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LongLongPair(Pointer p) { super(p); }
    public LongLongPair(long firstValue, long secondValue) { this(); put(firstValue, secondValue); }
    public LongLongPair()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef LongLongPair put(@ByRef LongLongPair x);


    @MemberGetter public native long first(); public native LongLongPair first(long first);
    @MemberGetter public native @Cast("google::protobuf::uint64") long second();  public native LongLongPair second(long second);

    public LongLongPair put(long firstValue, long secondValue) {
        first(firstValue);
        second(secondValue);
        return this;
    }
}

@NoOffset @Name("std::pair<int,int>") public static class UseTypeIntPair extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public UseTypeIntPair(Pointer p) { super(p); }
    public UseTypeIntPair(int firstValue, int secondValue) { this(); put(firstValue, secondValue); }
    public UseTypeIntPair()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef UseTypeIntPair put(@ByRef UseTypeIntPair x);


    @MemberGetter public native int first(); public native UseTypeIntPair first(int first);
    @MemberGetter public native int second();  public native UseTypeIntPair second(int second);

    public UseTypeIntPair put(int firstValue, int secondValue) {
        first(firstValue);
        second(secondValue);
        return this;
    }
}

@Name("std::unordered_map<std::string,int>") public static class StringIntMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringIntMap(Pointer p) { super(p); }
    public StringIntMap()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef StringIntMap put(@ByRef StringIntMap x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index public native int get(@StdString BytePointer i);
    public native StringIntMap put(@StdString BytePointer i, int value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter @StdString BytePointer first();
        public native @Name("operator*().second") @MemberGetter int second();
    }
}

@Name("std::unordered_map<std::string,const onnx::TypeProto*>") public static class StringTypeProtoMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringTypeProtoMap(Pointer p) { super(p); }
    public StringTypeProtoMap()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef StringTypeProtoMap put(@ByRef StringTypeProtoMap x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index public native @Const TypeProto get(@StdString BytePointer i);
    public native StringTypeProtoMap put(@StdString BytePointer i, TypeProto value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter @StdString BytePointer first();
        public native @Name("operator*().second") @MemberGetter @Const TypeProto second();
    }
}

@Name("std::unordered_map<std::string,const onnx::TensorProto*>") public static class StringTensorProtoMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringTensorProtoMap(Pointer p) { super(p); }
    public StringTensorProtoMap()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef StringTensorProtoMap put(@ByRef StringTensorProtoMap x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index public native @Const TensorProto get(@StdString BytePointer i);
    public native StringTensorProtoMap put(@StdString BytePointer i, TensorProto value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter @StdString BytePointer first();
        public native @Name("operator*().second") @MemberGetter @Const TensorProto second();
    }
}

@Name("std::unordered_map<std::string,const onnx::AttributeProto*>") public static class StringAttributeProtoMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringAttributeProtoMap(Pointer p) { super(p); }
    public StringAttributeProtoMap()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef StringAttributeProtoMap put(@ByRef StringAttributeProtoMap x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index public native @Const AttributeProto get(@StdString BytePointer i);
    public native StringAttributeProtoMap put(@StdString BytePointer i, AttributeProto value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter @StdString BytePointer first();
        public native @Name("operator*().second") @MemberGetter @Const AttributeProto second();
    }
}

@Name("std::unordered_map<std::string,std::pair<int,int> >") public static class StringIntIntPairMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringIntIntPairMap(Pointer p) { super(p); }
    public StringIntIntPairMap()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef StringIntIntPairMap put(@ByRef StringIntIntPairMap x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index(function = "at") public native int first(@StdString BytePointer i); public native StringIntIntPairMap first(@StdString BytePointer i, int first);
    @Index(function = "at") public native int second(@StdString BytePointer i);  public native StringIntIntPairMap second(@StdString BytePointer i, int second);
}

@Name("std::unordered_map<int,int>") public static class IntIntMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IntIntMap(Pointer p) { super(p); }
    public IntIntMap()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef IntIntMap put(@ByRef IntIntMap x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index public native int get(int i);
    public native IntIntMap put(int i, int value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter int first();
        public native @Name("operator*().second") @MemberGetter int second();
    }
}

@Name("std::unordered_set<std::string>") public static class UnorderedStringSet extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public UnorderedStringSet(Pointer p) { super(p); }
    public UnorderedStringSet()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef UnorderedStringSet put(@ByRef UnorderedStringSet x);

    public boolean empty() { return size() == 0; }
    public native long size();

    public native void insert(@StdString BytePointer value);
    public native void erase(@StdString BytePointer value);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @StdString BytePointer get();
    }
}

@Name("std::unordered_set<onnx::DataType>") public static class DataTypeSet extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DataTypeSet(Pointer p) { super(p); }
    public DataTypeSet()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef DataTypeSet put(@ByRef DataTypeSet x);

    public boolean empty() { return size() == 0; }
    public native long size();

    public native void insert(@StdString @Cast({"char*", "std::string*"}) BytePointer value);
    public native void erase(@StdString @Cast({"char*", "std::string*"}) BytePointer value);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @StdString @Const @Cast({"char*", "std::string*"}) BytePointer get();
    }
}

// Parsed from onnx/defs/schema.h

// Copyright (c) Facebook Inc. and Microsoft Corporation.
// Licensed under the MIT license.

// #pragma once

// #include <climits>
// #include <cstring>
// #include <functional>
// #include <initializer_list>
// #include <iostream>
// #include <limits>
// #include <ostream>
// #include <set>
// #include <string>
// #include <tuple>
// #include <unordered_map>
// #include <unordered_set>
// #include <vector>

// #include "data_type_utils.h"
// #include "onnx/common/constants.h"
// #include "onnx/defs/shape_inference.h"

@Namespace("onnx") @NoOffset public static class SchemaError extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SchemaError(Pointer p) { super(p); }


  public SchemaError(@StdString BytePointer message) { super((Pointer)null); allocate(message); }
  private native void allocate(@StdString BytePointer message);
  public SchemaError(@StdString String message) { super((Pointer)null); allocate(message); }
  private native void allocate(@StdString String message);

  public native @NoException @Cast("const char*") BytePointer what();

  public native void AppendContext(@StdString BytePointer context);
  public native void AppendContext(@StdString String context);
}

// #define fail_schema(...)
//   throw ONNX_NAMESPACE::SchemaError(ONNX_NAMESPACE::MakeString(__VA_ARGS__));

// Type constraint map. Key is type string. Value is data type set and
// description.

/**
 * \brief A class to record the schema of an op.
 *
 * OpSchema records the common interface of an op specified by its name.
 *
 * To register an OpSchema, one can use the macro ONNX_OPERATOR_SCHEMA(name) and
 * then append the various functions in the class. For example, for an op
 * that takes in two inputs, one output, and the first input and output
 * could be in-place, can be written as
 *
 *     ONNX_OPERATOR_SCHEMA(name)
 *         .NumInputs(2).NumOutputs(1).AllowConsumed({{0, 0}});
 *
 * To manufacture methods that may be used to register an OpSchema
 * non-statically, the following may be used:
 *
 *     ONNX_OPERATOR_SET_SCHEMA(name, version, OpSchema()
 *         .NumInputs(2).NumOutputs(1).AllowConsumed({{0, 0}}));
 */
@Namespace("onnx") @NoOffset public static class OpSchema extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSchema(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSchema(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public OpSchema position(long position) {
        return (OpSchema)super.position(position);
    }

  // Formal parameter options.
  /** enum onnx::OpSchema::FormalParameterOption */
  public static final byte
    // The input formal parameter is single and not optional.
    // Number of this input is 1.
    Single = 0,
    // The input formal parameter is single and optional.
    // Number of this input is 0 or 1.
    Optional = 1,
    // The input formal parameter is variadic.
    // Number of this input is [1, n].
    Variadic = 2;

  // Formal parameter represenation, including input/output name, typeStr,
  // description, and type constraints.
  @NoOffset public static class FormalParameter extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public FormalParameter(Pointer p) { super(p); }
      /** Native array allocator. Access with {@link Pointer#position(long)}. */
      public FormalParameter(long size) { super((Pointer)null); allocateArray(size); }
      private native void allocateArray(long size);
      @Override public FormalParameter position(long position) {
          return (FormalParameter)super.position(position);
      }
  
    // Constructor.
    public FormalParameter() { super((Pointer)null); allocate(); }
    private native void allocate();

    public FormalParameter(
            @StdString BytePointer name,
            @ByVal DataTypeSet type_set,
            @StdString BytePointer type_str,
            @StdString BytePointer description,
            @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/) { super((Pointer)null); allocate(name, type_set, type_str, description, param_option); }
    private native void allocate(
            @StdString BytePointer name,
            @ByVal DataTypeSet type_set,
            @StdString BytePointer type_str,
            @StdString BytePointer description,
            @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/);
    public FormalParameter(
            @StdString BytePointer name,
            @ByVal DataTypeSet type_set,
            @StdString BytePointer type_str,
            @StdString BytePointer description) { super((Pointer)null); allocate(name, type_set, type_str, description); }
    private native void allocate(
            @StdString BytePointer name,
            @ByVal DataTypeSet type_set,
            @StdString BytePointer type_str,
            @StdString BytePointer description);
    public FormalParameter(
            @StdString String name,
            @ByVal DataTypeSet type_set,
            @StdString String type_str,
            @StdString String description,
            @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/) { super((Pointer)null); allocate(name, type_set, type_str, description, param_option); }
    private native void allocate(
            @StdString String name,
            @ByVal DataTypeSet type_set,
            @StdString String type_str,
            @StdString String description,
            @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/);
    public FormalParameter(
            @StdString String name,
            @ByVal DataTypeSet type_set,
            @StdString String type_str,
            @StdString String description) { super((Pointer)null); allocate(name, type_set, type_str, description); }
    private native void allocate(
            @StdString String name,
            @ByVal DataTypeSet type_set,
            @StdString String type_str,
            @StdString String description);

    public FormalParameter(
            @StdString BytePointer name,
            @StdString BytePointer description,
            @StdString BytePointer type_str,
            @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/) { super((Pointer)null); allocate(name, description, type_str, param_option); }
    private native void allocate(
            @StdString BytePointer name,
            @StdString BytePointer description,
            @StdString BytePointer type_str,
            @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/);
    public FormalParameter(
            @StdString BytePointer name,
            @StdString BytePointer description,
            @StdString BytePointer type_str) { super((Pointer)null); allocate(name, description, type_str); }
    private native void allocate(
            @StdString BytePointer name,
            @StdString BytePointer description,
            @StdString BytePointer type_str);
    public FormalParameter(
            @StdString String name,
            @StdString String description,
            @StdString String type_str,
            @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/) { super((Pointer)null); allocate(name, description, type_str, param_option); }
    private native void allocate(
            @StdString String name,
            @StdString String description,
            @StdString String type_str,
            @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/);
    public FormalParameter(
            @StdString String name,
            @StdString String description,
            @StdString String type_str) { super((Pointer)null); allocate(name, description, type_str); }
    private native void allocate(
            @StdString String name,
            @StdString String description,
            @StdString String type_str);

    // Get formal parameter name.
    public native @StdString BytePointer GetName();

    // Get allowed data types.
    public native @Const @ByRef DataTypeSet GetTypes();

    // Get formal parameter type string.
    public native @StdString BytePointer GetTypeStr();

    // Get formal parameter description.
    public native @StdString BytePointer GetDescription();

    // Get the parameter option, it could be Single, Optional or Variadic.
    public native @Cast("onnx::OpSchema::FormalParameterOption") byte GetOption();
  }

  /** enum class onnx::OpSchema::SupportType */
  public static final byte
    COMMON = 0, // Supported by all frameworks that support this IR.
    EXPERIMENTAL = 1; // This OP is experimental and can be changed or removed in
                  // the future.

  public OpSchema() { super((Pointer)null); allocate(); }
  private native void allocate();
  public OpSchema(@StdString BytePointer name, @StdString BytePointer file, int line) { super((Pointer)null); allocate(name, file, line); }
  private native void allocate(@StdString BytePointer name, @StdString BytePointer file, int line);
  public OpSchema(@StdString String name, @StdString String file, int line) { super((Pointer)null); allocate(name, file, line); }
  private native void allocate(@StdString String name, @StdString String file, int line);

  /**
   * \brief Returns the file that the op schema is registered from.
   */
  public native @StdString BytePointer file();

  /**
   * \brief Returns the line in file that the op schema is registered from.
   */
  public native int line();

  /**
   * \brief Returns the support level of the op schema.
   */
  public native @Cast("onnx::OpSchema::SupportType") byte support_level();

  /**
   * \brief Returns the docstring of the op schema.
   */
  public native @Cast("const char*") BytePointer doc();

  /**
   * \brief Verifies if a NodeProto matches the pattern specified in
   * the schema.
   */
  public native void Verify(@Const @ByRef NodeProto node);

  // Functions to set the property of the operator schemas.
  // Sets the number of inputs, either a fixed number or a min and a max.

  /**
   * The earliest operator set version which this operator was
   * present in.  If an operator has had no BC-breaking changes,
   * this is simply the first operator set the operator was a member
   * of; if it has had BC-breaking changes, then for the semantics
   * /as described/ in the OpSchema entry, this version describes
   * the operator set which introduced the BC-breaking change.
   *
   * For example, suppose op Foo was added in v3, and had a BC-breaking
   * change in v6.  Then there will be an op schema entry for Foo with
   * SinceVersion(3), and another, updated op schema entry for Foo
   * with SinceVersion(6).
   */
  public native @ByRef @Function OpSchema SinceVersion(@Cast("onnx::OperatorSetVersion") int n); // aka int

  /**
   * \brief Input could be one of the values specified in allowed_input_nums.
   */
  public native @ByRef OpSchema NumInputs(@ByVal IntSet allowed_input_nums);

  /**
   * \brief Output could be one of the values specified in allowed_output_nums.
   */
  public native @ByRef OpSchema NumOutputs(@ByVal IntSet allowed_output_nums);

  // Shape Inference
  //
  // Note that signatures are defined to allow for forward-declaring
  // any structs used from ir.h
  public native @ByRef OpSchema TypeAndShapeInferenceFunction(@ByVal InferenceFunction inferenceFunction);
  

  // Set the support level for the op schema.
  public native @ByRef OpSchema SetSupportLevel(@Cast("onnx::OpSchema::SupportType") byte supportType);

  // Functions to do documentation for the operator schema.
  // This may be disabled to save memory.
  public native @ByRef OpSchema SetDoc(@Cast("const char*") BytePointer doc);
  public native @ByRef OpSchema SetDoc(String doc);

  // Functions to specify name for the operator schema.
  public native @ByRef OpSchema SetName(@Cast("const char*") BytePointer name);
  public native @ByRef OpSchema SetName(String name);

  // Functions to specify code location for the operator schema.
  public native @ByRef OpSchema SetLocation(@Cast("const char*") BytePointer file, int line);
  public native @ByRef OpSchema SetLocation(String file, int line);

  // Functions to specify domain for the operator schema.
  // Default domain value (ONNX_DOMAIN) means it's ONNX domain.
  public native @ByRef OpSchema SetDomain(@Cast("const char*") BytePointer domain);
  public native @ByRef OpSchema SetDomain(String domain);

  @NoOffset public static class Attribute extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public Attribute(Pointer p) { super(p); }
  
    public Attribute(
            @StdString BytePointer name_,
            @StdString BytePointer description_,
            @Cast("onnx::AttributeProto::AttributeType") int type_,
            @Cast("bool") boolean required_) { super((Pointer)null); allocate(name_, description_, type_, required_); }
    private native void allocate(
            @StdString BytePointer name_,
            @StdString BytePointer description_,
            @Cast("onnx::AttributeProto::AttributeType") int type_,
            @Cast("bool") boolean required_);
    public Attribute(
            @StdString String name_,
            @StdString String description_,
            @Cast("onnx::AttributeProto::AttributeType") int type_,
            @Cast("bool") boolean required_) { super((Pointer)null); allocate(name_, description_, type_, required_); }
    private native void allocate(
            @StdString String name_,
            @StdString String description_,
            @Cast("onnx::AttributeProto::AttributeType") int type_,
            @Cast("bool") boolean required_);

    public Attribute(
            @StdString BytePointer name_,
            @StdString BytePointer description_,
            @ByVal AttributeProto default_value_) { super((Pointer)null); allocate(name_, description_, default_value_); }
    private native void allocate(
            @StdString BytePointer name_,
            @StdString BytePointer description_,
            @ByVal AttributeProto default_value_);
    public Attribute(
            @StdString String name_,
            @StdString String description_,
            @ByVal AttributeProto default_value_) { super((Pointer)null); allocate(name_, description_, default_value_); }
    private native void allocate(
            @StdString String name_,
            @StdString String description_,
            @ByVal AttributeProto default_value_);

    public native @StdString BytePointer name(); public native Attribute name(BytePointer name);
    public native @StdString BytePointer description(); public native Attribute description(BytePointer description);
    public native @Cast("onnx::AttributeProto::AttributeType") int type(); public native Attribute type(int type);
    public native @Cast("bool") boolean required(); public native Attribute required(boolean required);
    public native @ByRef AttributeProto default_value(); public native Attribute default_value(AttributeProto default_value);
  }

  public native @ByRef OpSchema Attr(@ByVal Attribute attr);

// Register "optional" attribute with default value.
// #define ATTR_SETTER_WITH_DEFAULT_VALUE(TypeName)
//   OpSchema& Attr(
//       std::string name,
//       std::string description,
//       AttributeProto::AttributeType type,
//       const TypeName& defaultValue);
//   /* non-STL wrapper to reduce binary size */
//   OpSchema& Attr(
//       const char* name,
//       const char* description,
//       AttributeProto::AttributeType type,
//       const TypeName& defaultValue);
//   OpSchema& Attr(
//       std::string name,
//       std::string description,
//       AttributeProto::AttributeType type,
//       const std::vector<TypeName>& defaultValue);

  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Cast("const int64_t") long defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Cast("const int64_t") long defaultValue);
  /* non-STL wrapper to reduce binary size */
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef LongVector defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef LongVector defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        float defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        float defaultValue);
  /* non-STL wrapper to reduce binary size */
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef FloatVector defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef FloatVector defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @StdString BytePointer defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @StdString String defaultValue);
  /* non-STL wrapper to reduce binary size */
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef StringVector defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef StringVector defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef TensorProto defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef TensorProto defaultValue);
  /* non-STL wrapper to reduce binary size */
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef GraphProto defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef GraphProto defaultValue);
  /* non-STL wrapper to reduce binary size */

  // Register "required" attribute without default value.
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Cast("bool") boolean required/*=true*/);
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Cast("bool") boolean required/*=true*/);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type);

  // Non-STL wrapper to reduce binary size

  public native @ByRef OpSchema AllowUncheckedAttributes();

  // Type constraint.
  @NoOffset public static class TypeConstraintParam extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public TypeConstraintParam(Pointer p) { super(p); }
  
    public TypeConstraintParam(
            @StdString BytePointer type_param_str_,
            @ByVal StringVector allowed_type_strs_,
            @StdString BytePointer description_) { super((Pointer)null); allocate(type_param_str_, allowed_type_strs_, description_); }
    private native void allocate(
            @StdString BytePointer type_param_str_,
            @ByVal StringVector allowed_type_strs_,
            @StdString BytePointer description_);
    public TypeConstraintParam(
            @StdString String type_param_str_,
            @ByVal StringVector allowed_type_strs_,
            @StdString String description_) { super((Pointer)null); allocate(type_param_str_, allowed_type_strs_, description_); }
    private native void allocate(
            @StdString String type_param_str_,
            @ByVal StringVector allowed_type_strs_,
            @StdString String description_);

    // Type parameter string, for example, "T", "T1", etc.
    public native @StdString BytePointer type_param_str(); public native TypeConstraintParam type_param_str(BytePointer type_param_str);
    // Allowed type strings for <*this> type parameter, for example,
    // "tensor(float)".
    public native @ByRef StringVector allowed_type_strs(); public native TypeConstraintParam allowed_type_strs(StringVector allowed_type_strs);
    // Type parameter description.
    public native @StdString BytePointer description(); public native TypeConstraintParam description(BytePointer description);
  }

  // Grammar for type strings used in Input(), Output().
  // <type> ::= <data_type> |
  //            tensor(<data_type>) |
  //            seq(<type>) |
  //            map(<data_type>, <type>) |
  //            <type_parameter>
  // <data_type> :: = float | int32 | string | bool | uint8
  //                | int8 | uint16 | int16 | int64 | float16 | double
  // <type_parameter> ::= any type parameter string, say "T".
  //
  // NOTE: 1) <type_parameter> will always be together with a type constraints
  // specification.
  //       2) <type> ::= <data_type> means the data is scalar (zero dimension).
  //
  // Example:
  // ONNX_OPERATOR_SET_SCHEMA(Sum, 1, OpSchema()
  // .Input(0, "input_a", "the first input", "T")
  // .Input(1, "input_b", "the second input", "T")
  // .Output(0, "sum", "the sum of two numbers", "T")
  // .TypeConstraint("T", {"float", "double", "int32"}, "allowed data types for
  // sum."))
  //
  // Optional = true means that the input might have empty input value
  // (represented as "") in the graph even though the later inputs have values.
  // It's useful for complex situation when there are several independent
  // optional inputs.
  public native @ByRef OpSchema Input(
        int n,
        @StdString BytePointer name,
        @StdString BytePointer description,
        @StdString BytePointer type_str,
        @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/);
  public native @ByRef OpSchema Input(
        int n,
        @StdString BytePointer name,
        @StdString BytePointer description,
        @StdString BytePointer type_str);
  public native @ByRef OpSchema Input(
        int n,
        @StdString String name,
        @StdString String description,
        @StdString String type_str,
        @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/);
  public native @ByRef OpSchema Input(
        int n,
        @StdString String name,
        @StdString String description,
        @StdString String type_str);

  // Non-STL wrapper to reduce binary size
  public native @ByRef OpSchema Output(
        int n,
        @StdString BytePointer name,
        @StdString BytePointer description,
        @StdString BytePointer type_str,
        @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/);
  public native @ByRef OpSchema Output(
        int n,
        @StdString BytePointer name,
        @StdString BytePointer description,
        @StdString BytePointer type_str);
  public native @ByRef OpSchema Output(
        int n,
        @StdString String name,
        @StdString String description,
        @StdString String type_str,
        @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/);
  public native @ByRef OpSchema Output(
        int n,
        @StdString String name,
        @StdString String description,
        @StdString String type_str);

  // Non-STL wrapper to reduce binary size
  public native @ByRef OpSchema TypeConstraint(
        @StdString BytePointer type_str,
        @ByVal StringVector constraints,
        @StdString BytePointer description);
  public native @ByRef OpSchema TypeConstraint(
        @StdString String type_str,
        @ByVal StringVector constraints,
        @StdString String description);

  // Non-STL wrapper to reduce binary size

  // Convenience members for types

  // All high-precision numeric types.
  public static native @Const @ByRef StringVector numeric_types_for_math_reduction();

  public static native @Const @ByRef StringVector all_numeric_types();

  public static native @Const @ByRef StringVector all_tensor_types();

  // Calls the passed function with `this` as an argument. Useful for
  // adding docs for temlated/macro ops.
  public native @ByRef OpSchema FillUsing(@Const @ByRef VoidOpSchemaFn populator);

  

  public native @StdString BytePointer domain();

  // Get input formal parameters.
  public native @Const @ByRef FormalParameterVector inputs();

  // Get output formal parameters.
  public native @Const @ByRef FormalParameterVector outputs();

  public native @Const @ByRef TypeConstraintParamVector typeConstraintParams();

  public native @StdString BytePointer Name();

  public native @Cast("onnx::OperatorSetVersion") @Function int SinceVersion();

  public native int since_version();

  public native int min_input();
  public native int max_input();
  public native int min_output();
  public native int max_output();

  public native @Cast("bool") boolean has_type_and_shape_inference_function();

  // Verifies that the schema is valid and all specifications are compatible.
  // It will also parse all type strings specified for inputs/outputs into valid
  // TypeProto and create global unique string pointer as the DataType for
  // efficiency.
  public native void Finalize();
}

// Map type to store operator schemas. The format is,
// <OpName, <Domain, <OperatorSetVersion, OpSchema>>>.

@Namespace("onnx") public static class ISchemaRegistry extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ISchemaRegistry(Pointer p) { super(p); }


  public native @Const OpSchema GetSchema(
        @StdString BytePointer key,
        int maxInclusiveVersion,
        @StdString BytePointer domain/*=ONNX_DOMAIN*/);
  public native @Const OpSchema GetSchema(
        @StdString BytePointer key,
        int maxInclusiveVersion);
  public native @Const OpSchema GetSchema(
        @StdString String key,
        int maxInclusiveVersion,
        @StdString String domain/*=ONNX_DOMAIN*/);
  public native @Const OpSchema GetSchema(
        @StdString String key,
        int maxInclusiveVersion);
}

/**
 * \brief A registry to hold all the operator schemas.
 */
@Namespace("onnx") public static class OpSchemaRegistry extends ISchemaRegistry {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSchemaRegistry(Pointer p) { super(p); }

  // A singleton class to store domain to min/max op_set version map.
  @NoOffset public static class DomainToVersionRange extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public DomainToVersionRange(Pointer p) { super(p); }
      /** Native array allocator. Access with {@link Pointer#position(long)}. */
      public DomainToVersionRange(long size) { super((Pointer)null); allocateArray(size); }
      private native void allocateArray(long size);
      @Override public DomainToVersionRange position(long position) {
          return (DomainToVersionRange)super.position(position);
      }
  
    public DomainToVersionRange() { super((Pointer)null); allocate(); }
    private native void allocate();

    public native @Const @ByRef StringIntIntPairMap Map();

    // Add customized domain to min/max version.
    // Onnx partners are able to use onnx operator schema api to
    // register customized op in their own domain.
    public native void AddDomainToVersion(
            @StdString BytePointer domain,
            int min_version,
            int max_version);
    public native void AddDomainToVersion(
            @StdString String domain,
            int min_version,
            int max_version);

    public static native @ByRef DomainToVersionRange Instance();
  }

  public static class OpSchemaRegisterOnce extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public OpSchemaRegisterOnce(Pointer p) { super(p); }
  
    public OpSchemaRegisterOnce(@ByRef OpSchema op_schema) { super((Pointer)null); allocate(op_schema); }
    private native void allocate(@ByRef OpSchema op_schema);
  }

  // Return the latest schema for an operator in specified domain.
  // Domain with default value ONNX_DOMAIN means ONNX.
  public static native @Const OpSchema Schema(
        @StdString BytePointer key,
        @StdString BytePointer domain/*=ONNX_DOMAIN*/);
  public static native @Const OpSchema Schema(
        @StdString BytePointer key);
  public static native @Const OpSchema Schema(
        @StdString String key,
        @StdString String domain/*=ONNX_DOMAIN*/);
  public static native @Const OpSchema Schema(
        @StdString String key);

  // Return the schema with biggest version, which is not greater than specified
  // <maxInclusiveVersion> in specified domain. Domain with default value
  // ONNX_DOMAIN means ONNX.
  public static native @Const OpSchema Schema(
        @StdString BytePointer key,
        int maxInclusiveVersion,
        @StdString BytePointer domain/*=ONNX_DOMAIN*/);
  public static native @Const OpSchema Schema(
        @StdString BytePointer key,
        int maxInclusiveVersion);
  public static native @Const OpSchema Schema(
        @StdString String key,
        int maxInclusiveVersion,
        @StdString String domain/*=ONNX_DOMAIN*/);
  public static native @Const OpSchema Schema(
        @StdString String key,
        int maxInclusiveVersion);

  public static native OpSchemaRegistry Instance();

  public native @Const OpSchema GetSchema(
        @StdString BytePointer key,
        int maxInclusiveVersion,
        @StdString BytePointer domain/*=ONNX_DOMAIN*/);
  public native @Const OpSchema GetSchema(
        @StdString BytePointer key,
        int maxInclusiveVersion);
  public native @Const OpSchema GetSchema(
        @StdString String key,
        int maxInclusiveVersion,
        @StdString String domain/*=ONNX_DOMAIN*/);
  public native @Const OpSchema GetSchema(
        @StdString String key,
        int maxInclusiveVersion);
  public static native @Const @ByVal OpSchemaVector get_all_schemas_with_history();

  public static native @Const @ByVal OpSchemaVector get_all_schemas();
}



// Registers all schema of a given operator set

// Forward declaration for the non-specialized GetOpSchema method.  This
// enforces a consistent signature on functions that query individual schema,
// which are defined as specializations of this function.

// #define ONNX_OPERATOR_SET_SCHEMA(name, ver, impl)
//   ONNX_OPERATOR_SET_SCHEMA_EX(name, Onnx, ONNX_DOMAIN, ver, true, impl)

// #define ONNX_ML_OPERATOR_SET_SCHEMA(name, ver, impl)
//   ONNX_OPERATOR_SET_SCHEMA_EX(name, OnnxML, AI_ONNX_ML_DOMAIN, ver, true, impl)

// Defines specialization of GetOpSchema for a class whose name is determined
// based on a convention using name, domain, and version.  Operator schema are
// normally included in operator sets and registered in OpSchemaRegistry::map().
// In this case, callers should set dbg_included_in_static_opset to true.  This
// assists with runtime validation in in DEBUG builds ensuring the intended set
// of operator schema is registered.
// #define ONNX_OPERATOR_SET_SCHEMA_EX(
//     name, domain, domain_str, ver, dbg_included_in_static_opset, impl)
//   class ONNX_OPERATOR_SET_SCHEMA_CLASS_NAME(domain, ver, name);
//   template <>
//   OpSchema
//   GetOpSchema<ONNX_OPERATOR_SET_SCHEMA_CLASS_NAME(domain, ver, name)>() {
//     return impl.SetName(#name)
//         .SetDomain(domain_str)
//         .SinceVersion(ver)
//         .SetLocation(__FILE__, __LINE__);
//   }
//   size_t dbg_count_check_##name##_##domain##_ver##ver =
//       (dbg_included_in_static_opset) ? ONNX_DBG_INCREMENT_COUNT_IN_OPSETS()
//                                      : 0;

// #ifdef NDEBUG
// #define ONNX_DBG_INCREMENT_COUNT_IN_OPSETS() 0
// #else
// #define ONNX_DBG_INCREMENT_COUNT_IN_OPSETS()
//   DbgOperatorSetTracker::Instance().IncrementCount()
// #define ONNX_DBG_GET_COUNT_IN_OPSETS()
//   DbgOperatorSetTracker::Instance().GetCount()

@Namespace("onnx") public static class DbgOperatorSetTracker extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public DbgOperatorSetTracker() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public DbgOperatorSetTracker(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DbgOperatorSetTracker(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public DbgOperatorSetTracker position(long position) {
        return (DbgOperatorSetTracker)super.position(position);
    }

  public static native @ByRef DbgOperatorSetTracker Instance();

  public native @Cast("size_t") long IncrementCount();

  public native @Cast("size_t") long GetCount();
}
// #endif

// Naming convention for operator schema classes
// #define ONNX_OPERATOR_SET_SCHEMA_CLASS_NAME(domain, ver, name)
//   name##_##domain##_ver##ver

// Helper function


// #ifdef __GNUC__
// #define ONNX_UNUSED __attribute__((__unused__))
// #else
// #define ONNX_UNUSED
// #endif

// Legacy macros to register schema at static initialization
// #define ONNX_OPERATOR_SCHEMA(name)
//   ONNX_OPERATOR_SCHEMA_UNIQ_HELPER(__COUNTER__, name)
// #define ONNX_OPERATOR_SCHEMA_UNIQ_HELPER(Counter, name)
//   ONNX_OPERATOR_SCHEMA_UNIQ(Counter, name)
// #define ONNX_OPERATOR_SCHEMA_UNIQ(Counter, name)
//   static ONNX_NAMESPACE::OpSchemaRegistry::OpSchemaRegisterOnce(
//       op_schema_register_once##name##Counter) ONNX_UNUSED =
//       OpSchema(#name, __FILE__, __LINE__)

// Helper function


@Namespace("onnx") public static native @StdString BytePointer GenerateOptionalArgumentsDoc();

@Namespace("onnx") public static native @StdString BytePointer GenerateBroadcastingDocMul();

@Namespace("onnx") public static native @StdString BytePointer GenerateBroadcastingDocUni(
    @Cast("const char*") BytePointer from,
    @Cast("const char*") BytePointer to);
@Namespace("onnx") public static native @StdString String GenerateBroadcastingDocUni(
    String from,
    String to);

 // namespace ONNX_NAMESPACE


// Parsed from onnx/defs/operator_sets.h

// Copyright (c) Facebook Inc. and Microsoft Corporation.
// Licensed under the MIT license.

// #pragma once

// #include "onnx/defs/schema.h"

// Forward declarations for ai.onnx version 1
@Namespace("onnx") @Opaque public static class ATen_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ATen_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ATen_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Abs_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Abs_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Abs_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Add_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Add_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Add_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Affine_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Affine_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Affine_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class And_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public And_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public And_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ArgMax_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ArgMax_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ArgMax_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ArgMin_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ArgMin_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ArgMin_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class AveragePool_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public AveragePool_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AveragePool_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class BatchNormalization_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public BatchNormalization_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public BatchNormalization_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Cast_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Cast_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Cast_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Ceil_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Ceil_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Ceil_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Clip_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Clip_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Clip_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Concat_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Concat_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Concat_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Constant_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Constant_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Constant_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ConstantFill_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ConstantFill_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ConstantFill_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Conv_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Conv_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Conv_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ConvTranspose_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ConvTranspose_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ConvTranspose_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Crop_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Crop_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Crop_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class DepthToSpace_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public DepthToSpace_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DepthToSpace_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Div_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Div_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Div_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Dropout_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Dropout_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Dropout_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Elu_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Elu_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Elu_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Equal_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Equal_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Equal_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Exp_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Exp_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Exp_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Flatten_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Flatten_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Flatten_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Floor_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Floor_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Floor_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class GRU_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GRU_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GRU_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class GRUUnit_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GRUUnit_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GRUUnit_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Gather_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Gather_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Gather_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Gemm_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Gemm_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Gemm_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class GivenTensorFill_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GivenTensorFill_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GivenTensorFill_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class GlobalAveragePool_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GlobalAveragePool_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GlobalAveragePool_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class GlobalLpPool_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GlobalLpPool_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GlobalLpPool_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class GlobalMaxPool_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GlobalMaxPool_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GlobalMaxPool_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Greater_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Greater_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Greater_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class HardSigmoid_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public HardSigmoid_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public HardSigmoid_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Hardmax_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Hardmax_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Hardmax_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Identity_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Identity_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Identity_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class If_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public If_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public If_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ImageScaler_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ImageScaler_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ImageScaler_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class InstanceNormalization_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public InstanceNormalization_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public InstanceNormalization_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LRN_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LRN_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LRN_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LSTM_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LSTM_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LSTM_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LeakyRelu_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LeakyRelu_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LeakyRelu_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Less_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Less_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Less_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Log_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Log_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Log_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LogSoftmax_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LogSoftmax_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LogSoftmax_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Loop_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Loop_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Loop_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LpNormalization_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LpNormalization_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LpNormalization_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LpPool_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LpPool_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LpPool_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class MatMul_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public MatMul_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MatMul_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Max_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Max_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Max_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class MaxPool_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public MaxPool_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MaxPool_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class MaxRoiPool_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public MaxRoiPool_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MaxRoiPool_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Mean_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Mean_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Mean_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class MeanVarianceNormalization_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public MeanVarianceNormalization_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MeanVarianceNormalization_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Min_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Min_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Min_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Mul_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Mul_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Mul_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Neg_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Neg_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Neg_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Not_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Not_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Not_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Or_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Or_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Or_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class PRelu_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public PRelu_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PRelu_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Pad_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Pad_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Pad_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ParametricSoftplus_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ParametricSoftplus_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ParametricSoftplus_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Pow_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Pow_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Pow_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class RNN_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public RNN_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RNN_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class RandomNormal_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public RandomNormal_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RandomNormal_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class RandomNormalLike_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public RandomNormalLike_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RandomNormalLike_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class RandomUniform_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public RandomUniform_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RandomUniform_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class RandomUniformLike_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public RandomUniformLike_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RandomUniformLike_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Reciprocal_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Reciprocal_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Reciprocal_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceL1_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceL1_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceL1_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceL2_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceL2_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceL2_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceLogSum_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceLogSum_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceLogSum_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceLogSumExp_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceLogSumExp_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceLogSumExp_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceMax_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceMax_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceMax_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceMean_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceMean_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceMean_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceMin_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceMin_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceMin_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceProd_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceProd_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceProd_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceSum_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceSum_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceSum_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceSumSquare_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceSumSquare_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceSumSquare_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Relu_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Relu_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Relu_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Reshape_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Reshape_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Reshape_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Scale_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Scale_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Scale_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ScaledTanh_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ScaledTanh_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ScaledTanh_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Selu_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Selu_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Selu_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Shape_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Shape_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Shape_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sigmoid_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sigmoid_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sigmoid_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Size_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Size_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Size_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Slice_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Slice_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Slice_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Softmax_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Softmax_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Softmax_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Softplus_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Softplus_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Softplus_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Softsign_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Softsign_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Softsign_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class SpaceToDepth_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public SpaceToDepth_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SpaceToDepth_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Split_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Split_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Split_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sqrt_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sqrt_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sqrt_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Squeeze_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Squeeze_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Squeeze_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sub_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sub_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sub_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sum_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sum_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sum_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Tanh_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Tanh_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Tanh_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ThresholdedRelu_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ThresholdedRelu_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ThresholdedRelu_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Tile_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Tile_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Tile_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class TopK_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TopK_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TopK_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Transpose_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Transpose_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Transpose_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Unsqueeze_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Unsqueeze_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Unsqueeze_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Upsample_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Upsample_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Upsample_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Xor_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Xor_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Xor_Onnx_ver1(Pointer p) { super(p); }
}

// Iterate over schema from ai.onnx version 1
@Namespace("onnx") public static class OpSet_Onnx_ver1 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSet_Onnx_ver1() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSet_Onnx_ver1(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSet_Onnx_ver1(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSet_Onnx_ver1 position(long position) {
        return (OpSet_Onnx_ver1)super.position(position);
    }

}

// Forward declarations for ai.onnx version 2
@Namespace("onnx") @Opaque public static class GlobalLpPool_Onnx_ver2 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GlobalLpPool_Onnx_ver2() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GlobalLpPool_Onnx_ver2(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LpPool_Onnx_ver2 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LpPool_Onnx_ver2() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LpPool_Onnx_ver2(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Pad_Onnx_ver2 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Pad_Onnx_ver2() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Pad_Onnx_ver2(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Split_Onnx_ver2 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Split_Onnx_ver2() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Split_Onnx_ver2(Pointer p) { super(p); }
}

// Iterate over schema from ai.onnx version 2
@Namespace("onnx") public static class OpSet_Onnx_ver2 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSet_Onnx_ver2() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSet_Onnx_ver2(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSet_Onnx_ver2(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSet_Onnx_ver2 position(long position) {
        return (OpSet_Onnx_ver2)super.position(position);
    }

}

// Forward declarations for ai.onnx version 3
@Namespace("onnx") @Opaque public static class GRU_Onnx_ver3 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GRU_Onnx_ver3() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GRU_Onnx_ver3(Pointer p) { super(p); }
}

// Iterate over schema from ai.onnx version 3
@Namespace("onnx") public static class OpSet_Onnx_ver3 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSet_Onnx_ver3() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSet_Onnx_ver3(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSet_Onnx_ver3(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSet_Onnx_ver3 position(long position) {
        return (OpSet_Onnx_ver3)super.position(position);
    }

}

// Forward declarations for ai.onnx version 4
@Namespace("onnx") @Opaque public static class Concat_Onnx_ver4 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Concat_Onnx_ver4() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Concat_Onnx_ver4(Pointer p) { super(p); }
}

// Iterate over schema from ai.onnx version 4
@Namespace("onnx") public static class OpSet_Onnx_ver4 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSet_Onnx_ver4() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSet_Onnx_ver4(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSet_Onnx_ver4(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSet_Onnx_ver4 position(long position) {
        return (OpSet_Onnx_ver4)super.position(position);
    }

}

// Forward declarations for ai.onnx version 5
@Namespace("onnx") @Opaque public static class Reshape_Onnx_ver5 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Reshape_Onnx_ver5() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Reshape_Onnx_ver5(Pointer p) { super(p); }
}

// Iterate over schema from ai.onnx version 5
@Namespace("onnx") public static class OpSet_Onnx_ver5 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSet_Onnx_ver5() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSet_Onnx_ver5(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSet_Onnx_ver5(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSet_Onnx_ver5 position(long position) {
        return (OpSet_Onnx_ver5)super.position(position);
    }

}

// Forward declarations for ai.onnx version 6
@Namespace("onnx") @Opaque public static class Abs_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Abs_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Abs_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Add_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Add_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Add_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class BatchNormalization_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public BatchNormalization_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public BatchNormalization_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Cast_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Cast_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Cast_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Ceil_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Ceil_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Ceil_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Clip_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Clip_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Clip_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Div_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Div_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Div_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Dropout_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Dropout_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Dropout_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Elu_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Elu_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Elu_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Exp_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Exp_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Exp_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Floor_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Floor_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Floor_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Gemm_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Gemm_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Gemm_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class HardSigmoid_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public HardSigmoid_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public HardSigmoid_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class InstanceNormalization_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public InstanceNormalization_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public InstanceNormalization_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LeakyRelu_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LeakyRelu_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LeakyRelu_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Log_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Log_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Log_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Max_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Max_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Max_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Mean_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Mean_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Mean_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Min_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Min_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Min_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Mul_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Mul_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Mul_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Neg_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Neg_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Neg_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class PRelu_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public PRelu_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PRelu_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Reciprocal_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Reciprocal_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Reciprocal_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Relu_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Relu_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Relu_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Selu_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Selu_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Selu_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sigmoid_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sigmoid_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sigmoid_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sqrt_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sqrt_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sqrt_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sub_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sub_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sub_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sum_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sum_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sum_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Tanh_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Tanh_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Tanh_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Tile_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Tile_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Tile_Onnx_ver6(Pointer p) { super(p); }
}

// Iterate over schema from ai.onnx version 6
@Namespace("onnx") public static class OpSet_Onnx_ver6 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSet_Onnx_ver6() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSet_Onnx_ver6(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSet_Onnx_ver6(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSet_Onnx_ver6 position(long position) {
        return (OpSet_Onnx_ver6)super.position(position);
    }

}

// Forward declarations for ai.onnx version 7
@Namespace("onnx") @Opaque public static class Acos_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Acos_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Acos_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Add_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Add_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Add_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class And_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public And_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public And_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Asin_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Asin_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Asin_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Atan_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Atan_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Atan_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class AveragePool_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public AveragePool_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AveragePool_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class BatchNormalization_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public BatchNormalization_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public BatchNormalization_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Cos_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Cos_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Cos_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Div_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Div_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Div_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Dropout_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Dropout_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Dropout_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Equal_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Equal_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Equal_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Gemm_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Gemm_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Gemm_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Greater_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Greater_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Greater_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class GRU_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GRU_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GRU_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Less_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Less_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Less_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LSTM_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LSTM_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LSTM_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Mul_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Mul_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Mul_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Or_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Or_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Or_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Pow_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Pow_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Pow_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class RNN_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public RNN_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RNN_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sin_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sin_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sin_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sub_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sub_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sub_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Tan_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Tan_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Tan_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Upsample_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Upsample_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Upsample_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Multinomial_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Multinomial_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Multinomial_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Xor_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Xor_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Xor_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class PRelu_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public PRelu_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PRelu_Onnx_ver7(Pointer p) { super(p); }
}

// Iterate over schema from ai.onnx version 7
@Namespace("onnx") public static class OpSet_Onnx_ver7 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSet_Onnx_ver7() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSet_Onnx_ver7(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSet_Onnx_ver7(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSet_Onnx_ver7 position(long position) {
        return (OpSet_Onnx_ver7)super.position(position);
    }

}

// Forward declarations for ai.onnx version 8
@Namespace("onnx") @Opaque public static class Expand_Onnx_ver8 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Expand_Onnx_ver8() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Expand_Onnx_ver8(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Max_Onnx_ver8 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Max_Onnx_ver8() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Max_Onnx_ver8(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Min_Onnx_ver8 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Min_Onnx_ver8() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Min_Onnx_ver8(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sum_Onnx_ver8 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sum_Onnx_ver8() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sum_Onnx_ver8(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Mean_Onnx_ver8 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Mean_Onnx_ver8() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Mean_Onnx_ver8(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class MaxPool_Onnx_ver8 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public MaxPool_Onnx_ver8() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MaxPool_Onnx_ver8(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Scan_Onnx_ver8 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Scan_Onnx_ver8() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Scan_Onnx_ver8(Pointer p) { super(p); }
}

// Iterate over schema from ai.onnx version 7
@Namespace("onnx") public static class OpSet_Onnx_ver8 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSet_Onnx_ver8() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSet_Onnx_ver8(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSet_Onnx_ver8(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSet_Onnx_ver8 position(long position) {
        return (OpSet_Onnx_ver8)super.position(position);
    }

}

@Namespace("onnx") public static native void RegisterOnnxOperatorSetSchema();

 // namespace ONNX_NAMESPACE


// Parsed from onnx/defs/operator_sets-ml.h

// Copyright (c) Facebook Inc. and Microsoft Corporation.
// Licensed under the MIT license.

// #pragma once

// #ifdef ONNX_ML

// #include "onnx/defs/schema.h"

// Forward declarations for ai.onnx.ml version 1
@Namespace("onnx") @Opaque public static class ArrayFeatureExtractor_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ArrayFeatureExtractor_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ArrayFeatureExtractor_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Binarizer_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Binarizer_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Binarizer_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class CastMap_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public CastMap_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CastMap_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class CategoryMapper_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public CategoryMapper_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CategoryMapper_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class DictVectorizer_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public DictVectorizer_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DictVectorizer_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class FeatureVectorizer_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public FeatureVectorizer_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FeatureVectorizer_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Imputer_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Imputer_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Imputer_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LabelEncoder_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LabelEncoder_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LabelEncoder_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LinearClassifier_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LinearClassifier_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LinearClassifier_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LinearRegressor_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LinearRegressor_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LinearRegressor_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Normalizer_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Normalizer_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Normalizer_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class OneHotEncoder_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public OneHotEncoder_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OneHotEncoder_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class SVMClassifier_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public SVMClassifier_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SVMClassifier_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class SVMRegressor_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public SVMRegressor_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SVMRegressor_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Scaler_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Scaler_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Scaler_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class TreeEnsembleClassifier_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TreeEnsembleClassifier_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TreeEnsembleClassifier_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class TreeEnsembleRegressor_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TreeEnsembleRegressor_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TreeEnsembleRegressor_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ZipMap_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ZipMap_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ZipMap_OnnxML_ver1(Pointer p) { super(p); }
}

// Iterate over schema from ai.onnx.ml version 1
@Namespace("onnx") public static class OpSet_OnnxML_ver1 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSet_OnnxML_ver1() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSet_OnnxML_ver1(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSet_OnnxML_ver1(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSet_OnnxML_ver1 position(long position) {
        return (OpSet_OnnxML_ver1)super.position(position);
    }

}

@Namespace("onnx") public static native void RegisterOnnxMLOperatorSetSchema();
 // namespace ONNX_NAMESPACE

// #endif


// Parsed from onnx/defs/data_type_utils.h

// Copyright (c) Facebook Inc. and Microsoft Corporation.
// Licensed under the MIT license.

// #ifndef ONNX_DATA_TYPE_UTILS_H
// #define ONNX_DATA_TYPE_UTILS_H

// #include <mutex>
// #include <string>
// #include <unordered_map>
// #include <unordered_set>
// #include "onnx/onnx_pb.h"
// String pointer as unique TypeProto identifier.

// Data type utility, which maintains a global type string to TypeProto map.
// DataType (string pointer) is used as unique data type identifier for
// efficiency.
//
// Grammar for data type string:
// <type> ::= <data_type> |
//            tensor(<data_type>) |
//            seq(<type>) |
//            map(<data_type>, <type>)
// <data_type> :: = float | int32 | string | bool | uint8
//                | int8 | uint16 | int16 | int64 | float16 | double
//
// NOTE: <type> ::= <data_type> means the data is scalar (zero dimension).
//
// Example: float, tensor(float), etc.
//
@Namespace("onnx::Utils") public static class DataTypeUtils extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public DataTypeUtils() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public DataTypeUtils(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DataTypeUtils(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public DataTypeUtils position(long position) {
        return (DataTypeUtils)super.position(position);
    }

  public static native @StdString @ByVal @Cast({"char*", "std::string*"}) BytePointer ToType(@StdString BytePointer type_str);
  public static native @StdString @ByVal @Cast({"char*", "std::string*"}) BytePointer ToType(@StdString String type_str);

  public static native @StdString @ByVal @Cast({"char*", "std::string*"}) BytePointer ToType(@Const @ByRef TypeProto type_proto);

  public static native @Const @ByRef TypeProto ToTypeProto(@StdString @ByRef @Cast({"char*", "std::string*"}) BytePointer data_type);
}
 // namespace Utils
 // namespace ONNX_NAMESPACE

// #endif // ! ONNX_DATA_TYPE_UTILS_H


// Parsed from onnx/defs/shape_inference.h

// #pragma once

// #include "onnx/defs/data_type_utils.h"
// #include "onnx/proto_utils.h"
// #include "onnx/string_utils.h"

// Exception class used for handling errors in type and shape inference

@Namespace("onnx") @NoOffset public static class InferenceError extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public InferenceError(Pointer p) { super(p); }


  public InferenceError(@StdString BytePointer message) { super((Pointer)null); allocate(message); }
  private native void allocate(@StdString BytePointer message);
  public InferenceError(@StdString String message) { super((Pointer)null); allocate(message); }
  private native void allocate(@StdString String message);

  public native @NoException @Cast("const char*") BytePointer what();

  public native void AppendContext(@StdString BytePointer context);
  public native void AppendContext(@StdString String context);
}

// #define fail_type_inference(...)
//   throw ONNX_NAMESPACE::InferenceError(
//       ONNX_NAMESPACE::MakeString("[TypeInferenceError] ", __VA_ARGS__));

// #define fail_shape_inference(...)
//   throw ONNX_NAMESPACE::InferenceError(
//       ONNX_NAMESPACE::MakeString("[ShapeInferenceError] ", __VA_ARGS__));

@Namespace("onnx") public static class InferenceContext extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public InferenceContext(Pointer p) { super(p); }

  public native @Const AttributeProto getAttribute(@StdString BytePointer name);
  public native @Const AttributeProto getAttribute(@StdString String name);
  public native @Cast("size_t") long getNumInputs();
  public native @Const TypeProto getInputType(@Cast("size_t") long index);
  public native @Const TensorProto getInputData(@Cast("size_t") long index);
  public native @Cast("size_t") long getNumOutputs();
  public native TypeProto getOutputType(@Cast("size_t") long index);
}

// This no-op inference function is used for operators without an
// inference implementation.
@Namespace("onnx") public static native void dummyInferenceFunction(@ByRef InferenceContext arg0);

@Namespace("onnx") public static native @Cast("int64_t") long getAttribute(
    @ByRef InferenceContext ctx,
    @StdString BytePointer attributeName,
    @Cast("int64_t") long defaultValue);
@Namespace("onnx") public static native @Cast("int64_t") long getAttribute(
    @ByRef InferenceContext ctx,
    @StdString String attributeName,
    @Cast("int64_t") long defaultValue);

@Namespace("onnx") public static native @StdString BytePointer getAttribute(
    @ByRef InferenceContext ctx,
    @StdString BytePointer attributeName,
    @StdString BytePointer defaultValue);
@Namespace("onnx") public static native @StdString String getAttribute(
    @ByRef InferenceContext ctx,
    @StdString String attributeName,
    @StdString String defaultValue);

@Namespace("onnx") public static native @ByVal @Name("operator *") Dimension multiply(
    @ByVal Dimension dim1,
    @ByVal Dimension dim2);

@Namespace("onnx") public static native @ByVal @Name("operator *") Dimension multiply(
    @ByVal Dimension dim1,
    @Cast("int64_t") long dim2);

@Namespace("onnx") public static native @ByVal @Name("operator /") Dimension divide(
    @ByVal Dimension dim1,
    @Cast("int64_t") long dim2);

// if from >= upto_exclusive, return 1.
// Caller must make sure upto_exclusive is less than or equal to shape.size()
// Caller must make sure from>=0
@Namespace("onnx") public static native @ByVal Dimension multiplyDims(@Const @ByRef TensorShapeProto shape, int from, int upto_exclusive);

// Note: for all methods below for propagating type or shape, callers are
// responsible to handle optional inputs/outputs and ensure that the specified
// index value is less than NumInputs/NumOutputs.

@Namespace("onnx") public static native void propagateElemTypeFromInputToOutput(
    @ByRef InferenceContext ctx,
    @Cast("size_t") long inputIndex,
    @Cast("size_t") long outputIndex);

@Namespace("onnx") public static native @Cast("bool") boolean hasInputShape(@ByRef InferenceContext ctx, int n);

@Namespace("onnx") public static native @Cast("bool") boolean hasNInputShapes(@ByRef InferenceContext ctx, int n);

@Namespace("onnx") public static native @Const @ByRef TensorShapeProto getInputShape(@ByRef InferenceContext ctx, @Cast("size_t") long n);

// Caller must make sure fromDimIndex is strictly less than shape.dim_size()
@Namespace("onnx") public static native void appendSingleDimCopiedFromInputTypeToOutputType(
    @ByRef InferenceContext ctx,
    @Cast("size_t") long inputIndex,
    @Cast("size_t") long outputIndex,
    @Cast("size_t") long fromDimIndex);

@Namespace("onnx") public static native void propagateShapeFromInputToOutput(
    @ByRef InferenceContext ctx,
    @Cast("size_t") long inputIndex,
    @Cast("size_t") long outputIndex);

@Namespace("onnx") public static native void propagateShapeAndTypeFromFirstInput(@ByRef InferenceContext ctx);

@Namespace("onnx") public static native void updateOutputElemType(
    @ByRef InferenceContext ctx,
    @Cast("size_t") long outputIndex,
    @Cast("onnx::TensorProto_DataType") int elemType);

// Infer type of an output from the value of a specified attribute, which is
// expected to have a valid value representing a TensorProto_DataType.
@Namespace("onnx") public static native void propagateElemTypeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString BytePointer attributeName,
    @Cast("size_t") long outputIndex,
    @Cast("onnx::TensorProto_DataType") int default_value/*=TensorProto::UNDEFINED*/);
@Namespace("onnx") public static native void propagateElemTypeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString BytePointer attributeName,
    @Cast("size_t") long outputIndex);
@Namespace("onnx") public static native void propagateElemTypeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString String attributeName,
    @Cast("size_t") long outputIndex,
    @Cast("onnx::TensorProto_DataType") int default_value/*=TensorProto::UNDEFINED*/);
@Namespace("onnx") public static native void propagateElemTypeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString String attributeName,
    @Cast("size_t") long outputIndex);

@Namespace("onnx") public static native TensorShapeProto getOutputShape(@ByRef InferenceContext ctx, @Cast("size_t") long n);

@Namespace("onnx") public static native void updateOutputShape(
    @ByRef InferenceContext ctx,
    @Cast("size_t") long outputIndex,
    @Const @ByRef TensorShapeProto shape);

@Namespace("onnx") public static native void updateOutputShape(
    @ByRef InferenceContext ctx,
    @Cast("size_t") long outputIndex,
    @Const @ByRef TensorProto tensorProto);

// Infer shape of an output from the value of a specified attribute, which is
// expected to be a list of integers specifying a valid shape.
@Namespace("onnx") public static native void propagateShapeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString BytePointer attributeName,
    @Cast("size_t") long outputIndex);
@Namespace("onnx") public static native void propagateShapeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString String attributeName,
    @Cast("size_t") long outputIndex);

@Namespace("onnx") public static native void multidirectionalBroadcastShapeInference(
    @Const @ByRef TensorShapeProtoVector shapes,
    @ByRef TensorShapeProto resultShape);

@Namespace("onnx") public static native void bidirectionalBroadcastShapeInference(
	@Const @ByRef TensorShapeProto shapeL,
	@Const @ByRef TensorShapeProto shapeR,
	@ByRef TensorShapeProto resultShape);

 // namespace ONNX_NAMESPACE


// Parsed from onnx/onnx-operators-ml.pb.h

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: onnx/onnx-operators-ml.proto

// #ifndef PROTOBUF_INCLUDED_onnx_2fonnx_2doperators_2dml_2eproto
// #define PROTOBUF_INCLUDED_onnx_2fonnx_2doperators_2dml_2eproto

// #include <string>

// #include <google/protobuf/stubs/common.h>

// #if GOOGLE_PROTOBUF_VERSION < 3006001
// #error This file was generated by a newer version of protoc which is
// #error incompatible with your Protocol Buffer headers.  Please update
// #error your headers.
// #endif
// #if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
// #error This file was generated by an older version of protoc which is
// #error incompatible with your Protocol Buffer headers.  Please
// #error regenerate this file with a newer version of protoc.
// #endif

// #include <google/protobuf/io/coded_stream.h>
// #include <google/protobuf/arena.h>
// #include <google/protobuf/arenastring.h>
// #include <google/protobuf/generated_message_table_driven.h>
// #include <google/protobuf/generated_message_util.h>
// #include <google/protobuf/inlined_string_field.h>
// #include <google/protobuf/metadata.h>
// #include <google/protobuf/message.h>
// #include <google/protobuf/repeated_field.h>  // IWYU pragma: export
// #include <google/protobuf/extension_set.h>  // IWYU pragma: export
// #include <google/protobuf/generated_enum_reflection.h>
// #include <google/protobuf/unknown_field_set.h>
// #include "onnx/onnx-ml.pb.h"
// @@protoc_insertion_point(includes)
// #define PROTOBUF_INTERNAL_EXPORT_protobuf_onnx_2fonnx_2doperators_2dml_2eproto
// Internal implementation detail -- do not use these members.
@Namespace("protobuf_onnx_2fonnx_2doperators_2dml_2eproto") public static class TableStruct extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public TableStruct() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TableStruct(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TableStruct(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public TableStruct position(long position) {
        return (TableStruct)super.position(position);
    }

  @MemberGetter public static native @Cast("const google::protobuf::uint32") int offsets(int i);
  @MemberGetter public static native @Cast("const google::protobuf::uint32*") IntPointer offsets();
}
@Namespace("protobuf_onnx_2fonnx_2doperators_2dml_2eproto") public static native void AddDescriptors();
  // namespace protobuf_onnx_2fonnx_2doperators_2dml_2eproto
@Namespace("onnx") @Opaque public static class FunctionProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public FunctionProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FunctionProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class OperatorProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public OperatorProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OperatorProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class OperatorSetProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public OperatorSetProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OperatorSetProtoDefaultTypeInternal(Pointer p) { super(p); }
}

  // namespace onnx



  // namespace protobuf
  // namespace google

/** enum onnx::OperatorStatus */
public static final int
  EXPERIMENTAL = 0,
  STABLE = 1;
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::OperatorStatus") int OperatorStatus_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::OperatorStatus") int OperatorStatus_MAX();
@Namespace("onnx") @MemberGetter public static native int OperatorStatus_ARRAYSIZE();

@Namespace("onnx") public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer OperatorStatus_descriptor();
@Namespace("onnx") public static native @StdString BytePointer OperatorStatus_Name(@Cast("onnx::OperatorStatus") int value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString BytePointer name, @Cast("onnx::OperatorStatus*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString String name, @Cast("onnx::OperatorStatus*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString BytePointer name, @Cast("onnx::OperatorStatus*") int[] value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString String name, @Cast("onnx::OperatorStatus*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString BytePointer name, @Cast("onnx::OperatorStatus*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString String name, @Cast("onnx::OperatorStatus*") int[] value);
// ===================================================================

@Namespace("onnx") @NoOffset public static class FunctionProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FunctionProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public FunctionProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public FunctionProto position(long position) {
        return (FunctionProto)super.position(position);
    }

  public FunctionProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public FunctionProto(@Const @ByRef FunctionProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef FunctionProto from);

  public native @ByRef @Name("operator =") FunctionProto put(@Const @ByRef FunctionProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef FunctionProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const FunctionProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(FunctionProto other);
  

  // implements Message ----------------------------------------------

  public native FunctionProto New();

  public native FunctionProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef FunctionProto from);
  public native void MergeFrom(@Const @ByRef FunctionProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string input = 4;
  public native int input_size();
  public native void clear_input();
  @MemberGetter public static native int kInputFieldNumber();
  public static final int kInputFieldNumber = kInputFieldNumber();
  public native @StdString BytePointer input(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_input(int index);
  public native void set_input(int index, @StdString BytePointer value);
  public native void set_input(int index, @StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_input(int index, @Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_input(int index, String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_input();
  public native void add_input(@StdString BytePointer value);
  public native void add_input(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void add_input(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void add_input(String value, @Cast("size_t") long size);

  // repeated string output = 5;
  public native int output_size();
  public native void clear_output();
  @MemberGetter public static native int kOutputFieldNumber();
  public static final int kOutputFieldNumber = kOutputFieldNumber();
  public native @StdString BytePointer output(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_output(int index);
  public native void set_output(int index, @StdString BytePointer value);
  public native void set_output(int index, @StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_output(int index, @Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_output(int index, String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_output();
  public native void add_output(@StdString BytePointer value);
  public native void add_output(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void add_output(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void add_output(String value, @Cast("size_t") long size);

  // repeated string attribute = 6;
  public native int attribute_size();
  public native void clear_attribute();
  @MemberGetter public static native int kAttributeFieldNumber();
  public static final int kAttributeFieldNumber = kAttributeFieldNumber();
  public native @StdString BytePointer attribute(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_attribute(int index);
  public native void set_attribute(int index, @StdString BytePointer value);
  public native void set_attribute(int index, @StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_attribute(int index, @Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_attribute(int index, String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_attribute();
  public native void add_attribute(@StdString BytePointer value);
  public native void add_attribute(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void add_attribute(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void add_attribute(String value, @Cast("size_t") long size);

  // repeated .onnx.NodeProto node = 7;
  public native int node_size();
  public native void clear_node();
  @MemberGetter public static native int kNodeFieldNumber();
  public static final int kNodeFieldNumber = kNodeFieldNumber();
  public native NodeProto mutable_node(int index);
  public native @Const @ByRef NodeProto node(int index);
  public native NodeProto add_node();

  // optional string name = 1;
  public native @Cast("bool") boolean has_name();
  public native void clear_name();
  @MemberGetter public static native int kNameFieldNumber();
  public static final int kNameFieldNumber = kNameFieldNumber();
  public native @StdString BytePointer name();
  public native void set_name(@StdString BytePointer value);
  public native void set_name(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_name();
  public native void set_allocated_name(@StdString @Cast({"char*", "std::string*"}) BytePointer name);

  // optional string doc_string = 8;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional int64 since_version = 2;
  public native @Cast("bool") boolean has_since_version();
  public native void clear_since_version();
  @MemberGetter public static native int kSinceVersionFieldNumber();
  public static final int kSinceVersionFieldNumber = kSinceVersionFieldNumber();
  public native @Cast("google::protobuf::int64") long since_version();
  public native void set_since_version(@Cast("google::protobuf::int64") long value);

  // optional .onnx.OperatorStatus status = 3;
  public native @Cast("bool") boolean has_status();
  public native void clear_status();
  @MemberGetter public static native int kStatusFieldNumber();
  public static final int kStatusFieldNumber = kStatusFieldNumber();
  public native @Cast("onnx::OperatorStatus") int status();
  public native void set_status(@Cast("onnx::OperatorStatus") int value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class OperatorProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OperatorProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OperatorProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public OperatorProto position(long position) {
        return (OperatorProto)super.position(position);
    }

  public OperatorProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public OperatorProto(@Const @ByRef OperatorProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef OperatorProto from);

  public native @ByRef @Name("operator =") OperatorProto put(@Const @ByRef OperatorProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef OperatorProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const OperatorProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(OperatorProto other);
  

  // implements Message ----------------------------------------------

  public native OperatorProto New();

  public native OperatorProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef OperatorProto from);
  public native void MergeFrom(@Const @ByRef OperatorProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string op_type = 1;
  public native @Cast("bool") boolean has_op_type();
  public native void clear_op_type();
  @MemberGetter public static native int kOpTypeFieldNumber();
  public static final int kOpTypeFieldNumber = kOpTypeFieldNumber();
  public native @StdString BytePointer op_type();
  public native void set_op_type(@StdString BytePointer value);
  public native void set_op_type(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_op_type(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_op_type(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_op_type();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_op_type();
  public native void set_allocated_op_type(@StdString @Cast({"char*", "std::string*"}) BytePointer op_type);

  // optional string doc_string = 10;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional int64 since_version = 2;
  public native @Cast("bool") boolean has_since_version();
  public native void clear_since_version();
  @MemberGetter public static native int kSinceVersionFieldNumber();
  public static final int kSinceVersionFieldNumber = kSinceVersionFieldNumber();
  public native @Cast("google::protobuf::int64") long since_version();
  public native void set_since_version(@Cast("google::protobuf::int64") long value);

  // optional .onnx.OperatorStatus status = 3;
  public native @Cast("bool") boolean has_status();
  public native void clear_status();
  @MemberGetter public static native int kStatusFieldNumber();
  public static final int kStatusFieldNumber = kStatusFieldNumber();
  public native @Cast("onnx::OperatorStatus") int status();
  public native void set_status(@Cast("onnx::OperatorStatus") int value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class OperatorSetProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OperatorSetProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OperatorSetProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public OperatorSetProto position(long position) {
        return (OperatorSetProto)super.position(position);
    }

  public OperatorSetProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public OperatorSetProto(@Const @ByRef OperatorSetProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef OperatorSetProto from);

  public native @ByRef @Name("operator =") OperatorSetProto put(@Const @ByRef OperatorSetProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef OperatorSetProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const OperatorSetProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(OperatorSetProto other);
  

  // implements Message ----------------------------------------------

  public native OperatorSetProto New();

  public native OperatorSetProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef OperatorSetProto from);
  public native void MergeFrom(@Const @ByRef OperatorSetProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .onnx.OperatorProto operator = 8;
  public native int operator__size();
  public native void clear_operator_();
  @MemberGetter public static native int kOperatorFieldNumber();
  public static final int kOperatorFieldNumber = kOperatorFieldNumber();
  public native OperatorProto mutable_operator_(int index);
  public native @Const @ByRef OperatorProto operator_(int index);
  public native OperatorProto add_operator_();

  // repeated .onnx.FunctionProto functions = 9;
  public native int functions_size();
  public native void clear_functions();
  @MemberGetter public static native int kFunctionsFieldNumber();
  public static final int kFunctionsFieldNumber = kFunctionsFieldNumber();
  public native FunctionProto mutable_functions(int index);
  public native @Const @ByRef FunctionProto functions(int index);
  public native FunctionProto add_functions();

  // optional string magic = 1;
  public native @Cast("bool") boolean has_magic();
  public native void clear_magic();
  @MemberGetter public static native int kMagicFieldNumber();
  public static final int kMagicFieldNumber = kMagicFieldNumber();
  public native @StdString BytePointer magic();
  public native void set_magic(@StdString BytePointer value);
  public native void set_magic(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_magic(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_magic(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_magic();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_magic();
  public native void set_allocated_magic(@StdString @Cast({"char*", "std::string*"}) BytePointer magic);

  // optional string ir_version_prerelease = 3;
  public native @Cast("bool") boolean has_ir_version_prerelease();
  public native void clear_ir_version_prerelease();
  @MemberGetter public static native int kIrVersionPrereleaseFieldNumber();
  public static final int kIrVersionPrereleaseFieldNumber = kIrVersionPrereleaseFieldNumber();
  public native @StdString BytePointer ir_version_prerelease();
  public native void set_ir_version_prerelease(@StdString BytePointer value);
  public native void set_ir_version_prerelease(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_ir_version_prerelease(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_ir_version_prerelease(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_ir_version_prerelease();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_ir_version_prerelease();
  public native void set_allocated_ir_version_prerelease(@StdString @Cast({"char*", "std::string*"}) BytePointer ir_version_prerelease);

  // optional string domain = 4;
  public native @Cast("bool") boolean has_domain();
  public native void clear_domain();
  @MemberGetter public static native int kDomainFieldNumber();
  public static final int kDomainFieldNumber = kDomainFieldNumber();
  public native @StdString BytePointer domain();
  public native void set_domain(@StdString BytePointer value);
  public native void set_domain(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_domain(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_domain(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_domain();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_domain();
  public native void set_allocated_domain(@StdString @Cast({"char*", "std::string*"}) BytePointer domain);

  // optional string doc_string = 6;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional string ir_build_metadata = 7;
  public native @Cast("bool") boolean has_ir_build_metadata();
  public native void clear_ir_build_metadata();
  @MemberGetter public static native int kIrBuildMetadataFieldNumber();
  public static final int kIrBuildMetadataFieldNumber = kIrBuildMetadataFieldNumber();
  public native @StdString BytePointer ir_build_metadata();
  public native void set_ir_build_metadata(@StdString BytePointer value);
  public native void set_ir_build_metadata(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_ir_build_metadata(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_ir_build_metadata(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_ir_build_metadata();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_ir_build_metadata();
  public native void set_allocated_ir_build_metadata(@StdString @Cast({"char*", "std::string*"}) BytePointer ir_build_metadata);

  // optional int64 opset_version = 5;
  public native @Cast("bool") boolean has_opset_version();
  public native void clear_opset_version();
  @MemberGetter public static native int kOpsetVersionFieldNumber();
  public static final int kOpsetVersionFieldNumber = kOpsetVersionFieldNumber();
  public native @Cast("google::protobuf::int64") long opset_version();
  public native void set_opset_version(@Cast("google::protobuf::int64") long value);

  // optional int32 ir_version = 2;
  public native @Cast("bool") boolean has_ir_version();
  public native void clear_ir_version();
  @MemberGetter public static native int kIrVersionFieldNumber();
  public static final int kIrVersionFieldNumber = kIrVersionFieldNumber();
  public native @Cast("google::protobuf::int32") int ir_version();
  public native void set_ir_version(@Cast("google::protobuf::int32") int value);
}
// ===================================================================


// ===================================================================

// #ifdef __GNUC__
//   #pragma GCC diagnostic push
//   #pragma GCC diagnostic ignored "-Wstrict-aliasing"
// #endif  // __GNUC__
// FunctionProto

// optional string name = 1;






// #if LANG_CXX11

// #endif






// optional int64 since_version = 2;







// optional .onnx.OperatorStatus status = 3;







// repeated string input = 4;





// #if LANG_CXX11

// #endif




// #if LANG_CXX11

// #endif





// repeated string output = 5;





// #if LANG_CXX11

// #endif




// #if LANG_CXX11

// #endif





// repeated string attribute = 6;





// #if LANG_CXX11

// #endif




// #if LANG_CXX11

// #endif





// repeated .onnx.NodeProto node = 7;







// optional string doc_string = 8;






// #if LANG_CXX11

// #endif






// -------------------------------------------------------------------

// OperatorProto

// optional string op_type = 1;






// #if LANG_CXX11

// #endif






// optional int64 since_version = 2;







// optional .onnx.OperatorStatus status = 3;







// optional string doc_string = 10;






// #if LANG_CXX11

// #endif






// -------------------------------------------------------------------

// OperatorSetProto

// optional string magic = 1;






// #if LANG_CXX11

// #endif






// optional int32 ir_version = 2;







// optional string ir_version_prerelease = 3;






// #if LANG_CXX11

// #endif






// optional string ir_build_metadata = 7;






// #if LANG_CXX11

// #endif






// optional string domain = 4;






// #if LANG_CXX11

// #endif






// optional int64 opset_version = 5;







// optional string doc_string = 6;






// #if LANG_CXX11

// #endif






// repeated .onnx.OperatorProto operator = 8;








// repeated .onnx.FunctionProto functions = 9;








// #ifdef __GNUC__
//   #pragma GCC diagnostic pop
// #endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

  // namespace onnx


  // namespace protobuf
  // namespace google

// @@protoc_insertion_point(global_scope)

// #endif  // PROTOBUF_INCLUDED_onnx_2fonnx_2doperators_2dml_2eproto


// Parsed from onnx/onnx-ml.pb.h

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: onnx/onnx-ml.proto

// #ifndef PROTOBUF_INCLUDED_onnx_2fonnx_2dml_2eproto
// #define PROTOBUF_INCLUDED_onnx_2fonnx_2dml_2eproto

// #include <string>

// #include <google/protobuf/stubs/common.h>

// #if GOOGLE_PROTOBUF_VERSION < 3006001
// #error This file was generated by a newer version of protoc which is
// #error incompatible with your Protocol Buffer headers.  Please update
// #error your headers.
// #endif
// #if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
// #error This file was generated by an older version of protoc which is
// #error incompatible with your Protocol Buffer headers.  Please
// #error regenerate this file with a newer version of protoc.
// #endif

// #include <google/protobuf/io/coded_stream.h>
// #include <google/protobuf/arena.h>
// #include <google/protobuf/arenastring.h>
// #include <google/protobuf/generated_message_table_driven.h>
// #include <google/protobuf/generated_message_util.h>
// #include <google/protobuf/inlined_string_field.h>
// #include <google/protobuf/metadata.h>
// #include <google/protobuf/message.h>
// #include <google/protobuf/repeated_field.h>  // IWYU pragma: export
// #include <google/protobuf/extension_set.h>  // IWYU pragma: export
// #include <google/protobuf/generated_enum_reflection.h>
// #include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
// #define PROTOBUF_INTERNAL_EXPORT_protobuf_onnx_2fonnx_2dml_2eproto
// Internal implementation detail -- do not use these members.
  // namespace protobuf_onnx_2fonnx_2dml_2eproto
@Namespace("onnx") @Opaque public static class AttributeProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public AttributeProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AttributeProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class GraphProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GraphProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GraphProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class ModelProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ModelProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ModelProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class NodeProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public NodeProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public NodeProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class OperatorSetIdProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public OperatorSetIdProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OperatorSetIdProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class StringStringEntryProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public StringStringEntryProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringStringEntryProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class TensorProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TensorProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class TensorProto_SegmentDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TensorProto_SegmentDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorProto_SegmentDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class TensorShapeProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TensorShapeProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorShapeProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class TensorShapeProto_DimensionDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TensorShapeProto_DimensionDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorShapeProto_DimensionDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class TypeProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TypeProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class TypeProto_MapDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TypeProto_MapDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProto_MapDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class TypeProto_SequenceDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TypeProto_SequenceDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProto_SequenceDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class TypeProto_TensorDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TypeProto_TensorDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProto_TensorDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class ValueInfoProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ValueInfoProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ValueInfoProtoDefaultTypeInternal(Pointer p) { super(p); }
}

  // namespace onnx















  // namespace protobuf
  // namespace google

/** enum onnx::AttributeProto_AttributeType */
public static final int
  AttributeProto_AttributeType_UNDEFINED = 0,
  AttributeProto_AttributeType_FLOAT = 1,
  AttributeProto_AttributeType_INT = 2,
  AttributeProto_AttributeType_STRING = 3,
  AttributeProto_AttributeType_TENSOR = 4,
  AttributeProto_AttributeType_GRAPH = 5,
  AttributeProto_AttributeType_FLOATS = 6,
  AttributeProto_AttributeType_INTS = 7,
  AttributeProto_AttributeType_STRINGS = 8,
  AttributeProto_AttributeType_TENSORS = 9,
  AttributeProto_AttributeType_GRAPHS = 10;
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::AttributeProto_AttributeType") int AttributeProto_AttributeType_AttributeType_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::AttributeProto_AttributeType") int AttributeProto_AttributeType_AttributeType_MAX();
@Namespace("onnx") @MemberGetter public static native int AttributeProto_AttributeType_AttributeType_ARRAYSIZE();

@Namespace("onnx") public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer AttributeProto_AttributeType_descriptor();
@Namespace("onnx") public static native @StdString BytePointer AttributeProto_AttributeType_Name(@Cast("onnx::AttributeProto_AttributeType") int value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString BytePointer name, @Cast("onnx::AttributeProto_AttributeType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString String name, @Cast("onnx::AttributeProto_AttributeType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString BytePointer name, @Cast("onnx::AttributeProto_AttributeType*") int[] value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString String name, @Cast("onnx::AttributeProto_AttributeType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString BytePointer name, @Cast("onnx::AttributeProto_AttributeType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString String name, @Cast("onnx::AttributeProto_AttributeType*") int[] value);
/** enum onnx::TensorProto_DataType */
public static final int
  TensorProto_DataType_UNDEFINED = 0,
  TensorProto_DataType_FLOAT = 1,
  TensorProto_DataType_UINT8 = 2,
  TensorProto_DataType_INT8 = 3,
  TensorProto_DataType_UINT16 = 4,
  TensorProto_DataType_INT16 = 5,
  TensorProto_DataType_INT32 = 6,
  TensorProto_DataType_INT64 = 7,
  TensorProto_DataType_STRING = 8,
  TensorProto_DataType_BOOL = 9,
  TensorProto_DataType_FLOAT16 = 10,
  TensorProto_DataType_DOUBLE = 11,
  TensorProto_DataType_UINT32 = 12,
  TensorProto_DataType_UINT64 = 13,
  TensorProto_DataType_COMPLEX64 = 14,
  TensorProto_DataType_COMPLEX128 = 15;
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::TensorProto_DataType") int TensorProto_DataType_DataType_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::TensorProto_DataType") int TensorProto_DataType_DataType_MAX();
@Namespace("onnx") @MemberGetter public static native int TensorProto_DataType_DataType_ARRAYSIZE();

@Namespace("onnx") public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer TensorProto_DataType_descriptor();
@Namespace("onnx") public static native @StdString BytePointer TensorProto_DataType_Name(@Cast("onnx::TensorProto_DataType") int value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString BytePointer name, @Cast("onnx::TensorProto_DataType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString String name, @Cast("onnx::TensorProto_DataType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString BytePointer name, @Cast("onnx::TensorProto_DataType*") int... value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString String name, @Cast("onnx::TensorProto_DataType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString BytePointer name, @Cast("onnx::TensorProto_DataType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString String name, @Cast("onnx::TensorProto_DataType*") int... value);
/** enum onnx::Version */
public static final int
  _START_VERSION = 0,
  IR_VERSION_2017_10_10 = 1,
  IR_VERSION_2017_10_30 = 2,
  IR_VERSION = 3;
@Namespace("onnx") public static native @Cast("bool") boolean Version_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::Version") int Version_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::Version") int Version_MAX();
@Namespace("onnx") @MemberGetter public static native int Version_ARRAYSIZE();

@Namespace("onnx") public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer Version_descriptor();
@Namespace("onnx") public static native @StdString BytePointer Version_Name(@Cast("onnx::Version") int value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString BytePointer name, @Cast("onnx::Version*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString String name, @Cast("onnx::Version*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString BytePointer name, @Cast("onnx::Version*") int[] value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString String name, @Cast("onnx::Version*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString BytePointer name, @Cast("onnx::Version*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString String name, @Cast("onnx::Version*") int[] value);
// ===================================================================

@Namespace("onnx") @NoOffset public static class AttributeProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AttributeProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public AttributeProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public AttributeProto position(long position) {
        return (AttributeProto)super.position(position);
    }

  public AttributeProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public AttributeProto(@Const @ByRef AttributeProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef AttributeProto from);

  public native @ByRef @Name("operator =") AttributeProto put(@Const @ByRef AttributeProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef AttributeProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const AttributeProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(AttributeProto other);
  

  // implements Message ----------------------------------------------

  public native AttributeProto New();

  public native AttributeProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef AttributeProto from);
  public native void MergeFrom(@Const @ByRef AttributeProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int UNDEFINED();
  public static final int UNDEFINED = UNDEFINED();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int FLOAT();
  public static final int FLOAT = FLOAT();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int INT();
  public static final int INT = INT();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int STRING();
  public static final int STRING = STRING();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int TENSOR();
  public static final int TENSOR = TENSOR();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int GRAPH();
  public static final int GRAPH = GRAPH();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int FLOATS();
  public static final int FLOATS = FLOATS();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int INTS();
  public static final int INTS = INTS();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int STRINGS();
  public static final int STRINGS = STRINGS();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int TENSORS();
  public static final int TENSORS = TENSORS();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int GRAPHS();
  public static final int GRAPHS = GRAPHS();
  public static native @Cast("bool") boolean AttributeType_IsValid(int value);
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int AttributeType_MIN();
  public static final int AttributeType_MIN = AttributeType_MIN();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int AttributeType_MAX();
  public static final int AttributeType_MAX = AttributeType_MAX();
  @MemberGetter public static native int AttributeType_ARRAYSIZE();
  public static final int AttributeType_ARRAYSIZE = AttributeType_ARRAYSIZE();
  public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer AttributeType_descriptor();
  public static native @StdString BytePointer AttributeType_Name(@Cast("onnx::AttributeProto::AttributeType") int value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString BytePointer name,
        @Cast("onnx::AttributeProto::AttributeType*") IntPointer value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString String name,
        @Cast("onnx::AttributeProto::AttributeType*") IntBuffer value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString BytePointer name,
        @Cast("onnx::AttributeProto::AttributeType*") int... value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString String name,
        @Cast("onnx::AttributeProto::AttributeType*") IntPointer value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString BytePointer name,
        @Cast("onnx::AttributeProto::AttributeType*") IntBuffer value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString String name,
        @Cast("onnx::AttributeProto::AttributeType*") int... value);

  // accessors -------------------------------------------------------

  // repeated float floats = 7;
  public native int floats_size();
  public native void clear_floats();
  @MemberGetter public static native int kFloatsFieldNumber();
  public static final int kFloatsFieldNumber = kFloatsFieldNumber();
  public native float floats(int index);
  public native void set_floats(int index, float value);
  public native void add_floats(float value);

  // repeated int64 ints = 8;
  public native int ints_size();
  public native void clear_ints();
  @MemberGetter public static native int kIntsFieldNumber();
  public static final int kIntsFieldNumber = kIntsFieldNumber();
  public native @Cast("google::protobuf::int64") long ints(int index);
  public native void set_ints(int index, @Cast("google::protobuf::int64") long value);
  public native void add_ints(@Cast("google::protobuf::int64") long value);

  // repeated bytes strings = 9;
  public native int strings_size();
  public native void clear_strings();
  @MemberGetter public static native int kStringsFieldNumber();
  public static final int kStringsFieldNumber = kStringsFieldNumber();
  public native @StdString BytePointer strings(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_strings(int index);
  public native void set_strings(int index, @StdString BytePointer value);
  public native void set_strings(int index, @StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_strings(int index, @Const Pointer value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_strings();
  public native void add_strings(@StdString BytePointer value);
  public native void add_strings(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void add_strings(@Const Pointer value, @Cast("size_t") long size);

  // repeated .onnx.TensorProto tensors = 10;
  public native int tensors_size();
  public native void clear_tensors();
  @MemberGetter public static native int kTensorsFieldNumber();
  public static final int kTensorsFieldNumber = kTensorsFieldNumber();
  public native TensorProto mutable_tensors(int index);
  public native @Const @ByRef TensorProto tensors(int index);
  public native TensorProto add_tensors();

  // repeated .onnx.GraphProto graphs = 11;
  public native int graphs_size();
  public native void clear_graphs();
  @MemberGetter public static native int kGraphsFieldNumber();
  public static final int kGraphsFieldNumber = kGraphsFieldNumber();
  public native GraphProto mutable_graphs(int index);
  public native @Const @ByRef GraphProto graphs(int index);
  public native GraphProto add_graphs();

  // optional string name = 1;
  public native @Cast("bool") boolean has_name();
  public native void clear_name();
  @MemberGetter public static native int kNameFieldNumber();
  public static final int kNameFieldNumber = kNameFieldNumber();
  public native @StdString BytePointer name();
  public native void set_name(@StdString BytePointer value);
  public native void set_name(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_name();
  public native void set_allocated_name(@StdString @Cast({"char*", "std::string*"}) BytePointer name);

  // optional bytes s = 4;
  public native @Cast("bool") boolean has_s();
  public native void clear_s();
  @MemberGetter public static native int kSFieldNumber();
  public static final int kSFieldNumber = kSFieldNumber();
  public native @StdString BytePointer s();
  public native void set_s(@StdString BytePointer value);
  public native void set_s(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_s(@Const Pointer value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_s();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_s();
  public native void set_allocated_s(@StdString @Cast({"char*", "std::string*"}) BytePointer s);

  // optional string doc_string = 13;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional string ref_attr_name = 21;
  public native @Cast("bool") boolean has_ref_attr_name();
  public native void clear_ref_attr_name();
  @MemberGetter public static native int kRefAttrNameFieldNumber();
  public static final int kRefAttrNameFieldNumber = kRefAttrNameFieldNumber();
  public native @StdString BytePointer ref_attr_name();
  public native void set_ref_attr_name(@StdString BytePointer value);
  public native void set_ref_attr_name(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_ref_attr_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_ref_attr_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_ref_attr_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_ref_attr_name();
  public native void set_allocated_ref_attr_name(@StdString @Cast({"char*", "std::string*"}) BytePointer ref_attr_name);

  // optional .onnx.TensorProto t = 5;
  public native @Cast("bool") boolean has_t();
  public native void clear_t();
  @MemberGetter public static native int kTFieldNumber();
  public static final int kTFieldNumber = kTFieldNumber();
  public native @Const @ByRef TensorProto t();
  public native TensorProto release_t();
  public native TensorProto mutable_t();
  public native void set_allocated_t(TensorProto t);

  // optional .onnx.GraphProto g = 6;
  public native @Cast("bool") boolean has_g();
  public native void clear_g();
  @MemberGetter public static native int kGFieldNumber();
  public static final int kGFieldNumber = kGFieldNumber();
  public native @Const @ByRef GraphProto g();
  public native GraphProto release_g();
  public native GraphProto mutable_g();
  public native void set_allocated_g(GraphProto g);

  // optional int64 i = 3;
  public native @Cast("bool") boolean has_i();
  public native void clear_i();
  @MemberGetter public static native int kIFieldNumber();
  public static final int kIFieldNumber = kIFieldNumber();
  public native @Cast("google::protobuf::int64") long i();
  public native void set_i(@Cast("google::protobuf::int64") long value);

  // optional float f = 2;
  public native @Cast("bool") boolean has_f();
  public native void clear_f();
  @MemberGetter public static native int kFFieldNumber();
  public static final int kFFieldNumber = kFFieldNumber();
  public native float f();
  public native void set_f(float value);

  // optional .onnx.AttributeProto.AttributeType type = 20;
  public native @Cast("bool") boolean has_type();
  public native void clear_type();
  @MemberGetter public static native int kTypeFieldNumber();
  public static final int kTypeFieldNumber = kTypeFieldNumber();
  public native @Cast("onnx::AttributeProto_AttributeType") int type();
  public native void set_type(@Cast("onnx::AttributeProto_AttributeType") int value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class ValueInfoProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ValueInfoProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ValueInfoProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ValueInfoProto position(long position) {
        return (ValueInfoProto)super.position(position);
    }

  public ValueInfoProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public ValueInfoProto(@Const @ByRef ValueInfoProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef ValueInfoProto from);

  public native @ByRef @Name("operator =") ValueInfoProto put(@Const @ByRef ValueInfoProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef ValueInfoProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const ValueInfoProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(ValueInfoProto other);
  

  // implements Message ----------------------------------------------

  public native ValueInfoProto New();

  public native ValueInfoProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef ValueInfoProto from);
  public native void MergeFrom(@Const @ByRef ValueInfoProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  public native @Cast("bool") boolean has_name();
  public native void clear_name();
  @MemberGetter public static native int kNameFieldNumber();
  public static final int kNameFieldNumber = kNameFieldNumber();
  public native @StdString BytePointer name();
  public native void set_name(@StdString BytePointer value);
  public native void set_name(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_name();
  public native void set_allocated_name(@StdString @Cast({"char*", "std::string*"}) BytePointer name);

  // optional string doc_string = 3;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional .onnx.TypeProto type = 2;
  public native @Cast("bool") boolean has_type();
  public native void clear_type();
  @MemberGetter public static native int kTypeFieldNumber();
  public static final int kTypeFieldNumber = kTypeFieldNumber();
  public native @Const @ByRef TypeProto type();
  public native TypeProto release_type();
  public native TypeProto mutable_type();
  public native void set_allocated_type(TypeProto type);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class NodeProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public NodeProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public NodeProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public NodeProto position(long position) {
        return (NodeProto)super.position(position);
    }

  public NodeProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public NodeProto(@Const @ByRef NodeProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef NodeProto from);

  public native @ByRef @Name("operator =") NodeProto put(@Const @ByRef NodeProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef NodeProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const NodeProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(NodeProto other);
  

  // implements Message ----------------------------------------------

  public native NodeProto New();

  public native NodeProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef NodeProto from);
  public native void MergeFrom(@Const @ByRef NodeProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string input = 1;
  public native int input_size();
  public native void clear_input();
  @MemberGetter public static native int kInputFieldNumber();
  public static final int kInputFieldNumber = kInputFieldNumber();
  public native @StdString BytePointer input(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_input(int index);
  public native void set_input(int index, @StdString BytePointer value);
  public native void set_input(int index, @StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_input(int index, @Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_input(int index, String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_input();
  public native void add_input(@StdString BytePointer value);
  public native void add_input(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void add_input(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void add_input(String value, @Cast("size_t") long size);

  // repeated string output = 2;
  public native int output_size();
  public native void clear_output();
  @MemberGetter public static native int kOutputFieldNumber();
  public static final int kOutputFieldNumber = kOutputFieldNumber();
  public native @StdString BytePointer output(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_output(int index);
  public native void set_output(int index, @StdString BytePointer value);
  public native void set_output(int index, @StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_output(int index, @Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_output(int index, String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_output();
  public native void add_output(@StdString BytePointer value);
  public native void add_output(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void add_output(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void add_output(String value, @Cast("size_t") long size);

  // repeated .onnx.AttributeProto attribute = 5;
  public native int attribute_size();
  public native void clear_attribute();
  @MemberGetter public static native int kAttributeFieldNumber();
  public static final int kAttributeFieldNumber = kAttributeFieldNumber();
  public native AttributeProto mutable_attribute(int index);
  public native @Const @ByRef AttributeProto attribute(int index);
  public native AttributeProto add_attribute();

  // optional string name = 3;
  public native @Cast("bool") boolean has_name();
  public native void clear_name();
  @MemberGetter public static native int kNameFieldNumber();
  public static final int kNameFieldNumber = kNameFieldNumber();
  public native @StdString BytePointer name();
  public native void set_name(@StdString BytePointer value);
  public native void set_name(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_name();
  public native void set_allocated_name(@StdString @Cast({"char*", "std::string*"}) BytePointer name);

  // optional string op_type = 4;
  public native @Cast("bool") boolean has_op_type();
  public native void clear_op_type();
  @MemberGetter public static native int kOpTypeFieldNumber();
  public static final int kOpTypeFieldNumber = kOpTypeFieldNumber();
  public native @StdString BytePointer op_type();
  public native void set_op_type(@StdString BytePointer value);
  public native void set_op_type(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_op_type(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_op_type(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_op_type();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_op_type();
  public native void set_allocated_op_type(@StdString @Cast({"char*", "std::string*"}) BytePointer op_type);

  // optional string doc_string = 6;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional string domain = 7;
  public native @Cast("bool") boolean has_domain();
  public native void clear_domain();
  @MemberGetter public static native int kDomainFieldNumber();
  public static final int kDomainFieldNumber = kDomainFieldNumber();
  public native @StdString BytePointer domain();
  public native void set_domain(@StdString BytePointer value);
  public native void set_domain(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_domain(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_domain(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_domain();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_domain();
  public native void set_allocated_domain(@StdString @Cast({"char*", "std::string*"}) BytePointer domain);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class ModelProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ModelProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ModelProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ModelProto position(long position) {
        return (ModelProto)super.position(position);
    }

  public ModelProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public ModelProto(@Const @ByRef ModelProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef ModelProto from);

  public native @ByRef @Name("operator =") ModelProto put(@Const @ByRef ModelProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef ModelProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const ModelProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(ModelProto other);
  

  // implements Message ----------------------------------------------

  public native ModelProto New();

  public native ModelProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef ModelProto from);
  public native void MergeFrom(@Const @ByRef ModelProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .onnx.OperatorSetIdProto opset_import = 8;
  public native int opset_import_size();
  public native void clear_opset_import();
  @MemberGetter public static native int kOpsetImportFieldNumber();
  public static final int kOpsetImportFieldNumber = kOpsetImportFieldNumber();
  public native OperatorSetIdProto mutable_opset_import(int index);
  public native @Const @ByRef OperatorSetIdProto opset_import(int index);
  public native OperatorSetIdProto add_opset_import();

  // repeated .onnx.StringStringEntryProto metadata_props = 14;
  public native int metadata_props_size();
  public native void clear_metadata_props();
  @MemberGetter public static native int kMetadataPropsFieldNumber();
  public static final int kMetadataPropsFieldNumber = kMetadataPropsFieldNumber();
  public native StringStringEntryProto mutable_metadata_props(int index);
  public native @Const @ByRef StringStringEntryProto metadata_props(int index);
  public native StringStringEntryProto add_metadata_props();

  // optional string producer_name = 2;
  public native @Cast("bool") boolean has_producer_name();
  public native void clear_producer_name();
  @MemberGetter public static native int kProducerNameFieldNumber();
  public static final int kProducerNameFieldNumber = kProducerNameFieldNumber();
  public native @StdString BytePointer producer_name();
  public native void set_producer_name(@StdString BytePointer value);
  public native void set_producer_name(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_producer_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_producer_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_producer_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_producer_name();
  public native void set_allocated_producer_name(@StdString @Cast({"char*", "std::string*"}) BytePointer producer_name);

  // optional string producer_version = 3;
  public native @Cast("bool") boolean has_producer_version();
  public native void clear_producer_version();
  @MemberGetter public static native int kProducerVersionFieldNumber();
  public static final int kProducerVersionFieldNumber = kProducerVersionFieldNumber();
  public native @StdString BytePointer producer_version();
  public native void set_producer_version(@StdString BytePointer value);
  public native void set_producer_version(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_producer_version(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_producer_version(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_producer_version();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_producer_version();
  public native void set_allocated_producer_version(@StdString @Cast({"char*", "std::string*"}) BytePointer producer_version);

  // optional string domain = 4;
  public native @Cast("bool") boolean has_domain();
  public native void clear_domain();
  @MemberGetter public static native int kDomainFieldNumber();
  public static final int kDomainFieldNumber = kDomainFieldNumber();
  public native @StdString BytePointer domain();
  public native void set_domain(@StdString BytePointer value);
  public native void set_domain(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_domain(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_domain(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_domain();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_domain();
  public native void set_allocated_domain(@StdString @Cast({"char*", "std::string*"}) BytePointer domain);

  // optional string doc_string = 6;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional .onnx.GraphProto graph = 7;
  public native @Cast("bool") boolean has_graph();
  public native void clear_graph();
  @MemberGetter public static native int kGraphFieldNumber();
  public static final int kGraphFieldNumber = kGraphFieldNumber();
  public native @Const @ByRef GraphProto graph();
  public native GraphProto release_graph();
  public native GraphProto mutable_graph();
  public native void set_allocated_graph(GraphProto graph);

  // optional int64 ir_version = 1;
  public native @Cast("bool") boolean has_ir_version();
  public native void clear_ir_version();
  @MemberGetter public static native int kIrVersionFieldNumber();
  public static final int kIrVersionFieldNumber = kIrVersionFieldNumber();
  public native @Cast("google::protobuf::int64") long ir_version();
  public native void set_ir_version(@Cast("google::protobuf::int64") long value);

  // optional int64 model_version = 5;
  public native @Cast("bool") boolean has_model_version();
  public native void clear_model_version();
  @MemberGetter public static native int kModelVersionFieldNumber();
  public static final int kModelVersionFieldNumber = kModelVersionFieldNumber();
  public native @Cast("google::protobuf::int64") long model_version();
  public native void set_model_version(@Cast("google::protobuf::int64") long value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class StringStringEntryProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringStringEntryProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public StringStringEntryProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public StringStringEntryProto position(long position) {
        return (StringStringEntryProto)super.position(position);
    }

  public StringStringEntryProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public StringStringEntryProto(@Const @ByRef StringStringEntryProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef StringStringEntryProto from);

  public native @ByRef @Name("operator =") StringStringEntryProto put(@Const @ByRef StringStringEntryProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef StringStringEntryProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const StringStringEntryProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(StringStringEntryProto other);
  

  // implements Message ----------------------------------------------

  public native StringStringEntryProto New();

  public native StringStringEntryProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef StringStringEntryProto from);
  public native void MergeFrom(@Const @ByRef StringStringEntryProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  public native @Cast("bool") boolean has_key();
  public native void clear_key();
  @MemberGetter public static native int kKeyFieldNumber();
  public static final int kKeyFieldNumber = kKeyFieldNumber();
  public native @StdString BytePointer key();
  public native void set_key(@StdString BytePointer value);
  public native void set_key(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_key(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_key(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_key();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_key();
  public native void set_allocated_key(@StdString @Cast({"char*", "std::string*"}) BytePointer key);

  // optional string value = 2;
  public native @Cast("bool") boolean has_value();
  public native void clear_value();
  @MemberGetter public static native int kValueFieldNumber();
  public static final int kValueFieldNumber = kValueFieldNumber();
  public native @StdString BytePointer value();
  public native void set_value(@StdString BytePointer value);
  public native void set_value(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_value(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_value(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_value();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_value();
  public native void set_allocated_value(@StdString @Cast({"char*", "std::string*"}) BytePointer value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class GraphProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GraphProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public GraphProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public GraphProto position(long position) {
        return (GraphProto)super.position(position);
    }

  public GraphProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public GraphProto(@Const @ByRef GraphProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef GraphProto from);

  public native @ByRef @Name("operator =") GraphProto put(@Const @ByRef GraphProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef GraphProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const GraphProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(GraphProto other);
  

  // implements Message ----------------------------------------------

  public native GraphProto New();

  public native GraphProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef GraphProto from);
  public native void MergeFrom(@Const @ByRef GraphProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .onnx.NodeProto node = 1;
  public native int node_size();
  public native void clear_node();
  @MemberGetter public static native int kNodeFieldNumber();
  public static final int kNodeFieldNumber = kNodeFieldNumber();
  public native NodeProto mutable_node(int index);
  public native @Const @ByRef NodeProto node(int index);
  public native NodeProto add_node();

  // repeated .onnx.TensorProto initializer = 5;
  public native int initializer_size();
  public native void clear_initializer();
  @MemberGetter public static native int kInitializerFieldNumber();
  public static final int kInitializerFieldNumber = kInitializerFieldNumber();
  public native TensorProto mutable_initializer(int index);
  public native @Const @ByRef TensorProto initializer(int index);
  public native TensorProto add_initializer();

  // repeated .onnx.ValueInfoProto input = 11;
  public native int input_size();
  public native void clear_input();
  @MemberGetter public static native int kInputFieldNumber();
  public static final int kInputFieldNumber = kInputFieldNumber();
  public native ValueInfoProto mutable_input(int index);
  public native @Const @ByRef ValueInfoProto input(int index);
  public native ValueInfoProto add_input();

  // repeated .onnx.ValueInfoProto output = 12;
  public native int output_size();
  public native void clear_output();
  @MemberGetter public static native int kOutputFieldNumber();
  public static final int kOutputFieldNumber = kOutputFieldNumber();
  public native ValueInfoProto mutable_output(int index);
  public native @Const @ByRef ValueInfoProto output(int index);
  public native ValueInfoProto add_output();

  // repeated .onnx.ValueInfoProto value_info = 13;
  public native int value_info_size();
  public native void clear_value_info();
  @MemberGetter public static native int kValueInfoFieldNumber();
  public static final int kValueInfoFieldNumber = kValueInfoFieldNumber();
  public native ValueInfoProto mutable_value_info(int index);
  public native @Const @ByRef ValueInfoProto value_info(int index);
  public native ValueInfoProto add_value_info();

  // optional string name = 2;
  public native @Cast("bool") boolean has_name();
  public native void clear_name();
  @MemberGetter public static native int kNameFieldNumber();
  public static final int kNameFieldNumber = kNameFieldNumber();
  public native @StdString BytePointer name();
  public native void set_name(@StdString BytePointer value);
  public native void set_name(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_name();
  public native void set_allocated_name(@StdString @Cast({"char*", "std::string*"}) BytePointer name);

  // optional string doc_string = 10;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TensorProto_Segment extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorProto_Segment(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TensorProto_Segment(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TensorProto_Segment position(long position) {
        return (TensorProto_Segment)super.position(position);
    }

  public TensorProto_Segment() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TensorProto_Segment(@Const @ByRef TensorProto_Segment from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TensorProto_Segment from);

  public native @ByRef @Name("operator =") TensorProto_Segment put(@Const @ByRef TensorProto_Segment from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TensorProto_Segment default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const TensorProto_Segment internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(TensorProto_Segment other);
  

  // implements Message ----------------------------------------------

  public native TensorProto_Segment New();

  public native TensorProto_Segment New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TensorProto_Segment from);
  public native void MergeFrom(@Const @ByRef TensorProto_Segment from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 begin = 1;
  public native @Cast("bool") boolean has_begin();
  public native void clear_begin();
  @MemberGetter public static native int kBeginFieldNumber();
  public static final int kBeginFieldNumber = kBeginFieldNumber();
  public native @Cast("google::protobuf::int64") long begin();
  public native void set_begin(@Cast("google::protobuf::int64") long value);

  // optional int64 end = 2;
  public native @Cast("bool") boolean has_end();
  public native void clear_end();
  @MemberGetter public static native int kEndFieldNumber();
  public static final int kEndFieldNumber = kEndFieldNumber();
  public native @Cast("google::protobuf::int64") long end();
  public native void set_end(@Cast("google::protobuf::int64") long value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TensorProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TensorProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TensorProto position(long position) {
        return (TensorProto)super.position(position);
    }

  public TensorProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TensorProto(@Const @ByRef TensorProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TensorProto from);

  public native @ByRef @Name("operator =") TensorProto put(@Const @ByRef TensorProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TensorProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const TensorProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(TensorProto other);
  

  // implements Message ----------------------------------------------

  public native TensorProto New();

  public native TensorProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TensorProto from);
  public native void MergeFrom(@Const @ByRef TensorProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int UNDEFINED();
  public static final int UNDEFINED = UNDEFINED();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int FLOAT();
  public static final int FLOAT = FLOAT();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int UINT8();
  public static final int UINT8 = UINT8();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int INT8();
  public static final int INT8 = INT8();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int UINT16();
  public static final int UINT16 = UINT16();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int INT16();
  public static final int INT16 = INT16();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int INT32();
  public static final int INT32 = INT32();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int INT64();
  public static final int INT64 = INT64();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int STRING();
  public static final int STRING = STRING();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int BOOL();
  public static final int BOOL = BOOL();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int FLOAT16();
  public static final int FLOAT16 = FLOAT16();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int DOUBLE();
  public static final int DOUBLE = DOUBLE();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int UINT32();
  public static final int UINT32 = UINT32();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int UINT64();
  public static final int UINT64 = UINT64();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int COMPLEX64();
  public static final int COMPLEX64 = COMPLEX64();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int COMPLEX128();
  public static final int COMPLEX128 = COMPLEX128();
  public static native @Cast("bool") boolean DataType_IsValid(int value);
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int DataType_MIN();
  public static final int DataType_MIN = DataType_MIN();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int DataType_MAX();
  public static final int DataType_MAX = DataType_MAX();
  @MemberGetter public static native int DataType_ARRAYSIZE();
  public static final int DataType_ARRAYSIZE = DataType_ARRAYSIZE();
  public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer DataType_descriptor();
  public static native @StdString BytePointer DataType_Name(@Cast("onnx::TensorProto::DataType") int value);
  public static native @Cast("bool") boolean DataType_Parse(@StdString BytePointer name,
        @Cast("onnx::TensorProto::DataType*") IntPointer value);
  public static native @Cast("bool") boolean DataType_Parse(@StdString String name,
        @Cast("onnx::TensorProto::DataType*") IntBuffer value);
  public static native @Cast("bool") boolean DataType_Parse(@StdString BytePointer name,
        @Cast("onnx::TensorProto::DataType*") int... value);
  public static native @Cast("bool") boolean DataType_Parse(@StdString String name,
        @Cast("onnx::TensorProto::DataType*") IntPointer value);
  public static native @Cast("bool") boolean DataType_Parse(@StdString BytePointer name,
        @Cast("onnx::TensorProto::DataType*") IntBuffer value);
  public static native @Cast("bool") boolean DataType_Parse(@StdString String name,
        @Cast("onnx::TensorProto::DataType*") int... value);

  // accessors -------------------------------------------------------

  // repeated int64 dims = 1;
  public native int dims_size();
  public native void clear_dims();
  @MemberGetter public static native int kDimsFieldNumber();
  public static final int kDimsFieldNumber = kDimsFieldNumber();
  public native @Cast("google::protobuf::int64") long dims(int index);
  public native void set_dims(int index, @Cast("google::protobuf::int64") long value);
  public native void add_dims(@Cast("google::protobuf::int64") long value);

  // repeated float float_data = 4 [packed = true];
  public native int float_data_size();
  public native void clear_float_data();
  @MemberGetter public static native int kFloatDataFieldNumber();
  public static final int kFloatDataFieldNumber = kFloatDataFieldNumber();
  public native float float_data(int index);
  public native void set_float_data(int index, float value);
  public native void add_float_data(float value);

  // repeated int32 int32_data = 5 [packed = true];
  public native int int32_data_size();
  public native void clear_int32_data();
  @MemberGetter public static native int kInt32DataFieldNumber();
  public static final int kInt32DataFieldNumber = kInt32DataFieldNumber();
  public native @Cast("google::protobuf::int32") int int32_data(int index);
  public native void set_int32_data(int index, @Cast("google::protobuf::int32") int value);
  public native void add_int32_data(@Cast("google::protobuf::int32") int value);

  // repeated bytes string_data = 6;
  public native int string_data_size();
  public native void clear_string_data();
  @MemberGetter public static native int kStringDataFieldNumber();
  public static final int kStringDataFieldNumber = kStringDataFieldNumber();
  public native @StdString BytePointer string_data(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_string_data(int index);
  public native void set_string_data(int index, @StdString BytePointer value);
  public native void set_string_data(int index, @StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_string_data(int index, @Const Pointer value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_string_data();
  public native void add_string_data(@StdString BytePointer value);
  public native void add_string_data(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void add_string_data(@Const Pointer value, @Cast("size_t") long size);

  // repeated int64 int64_data = 7 [packed = true];
  public native int int64_data_size();
  public native void clear_int64_data();
  @MemberGetter public static native int kInt64DataFieldNumber();
  public static final int kInt64DataFieldNumber = kInt64DataFieldNumber();
  public native @Cast("google::protobuf::int64") long int64_data(int index);
  public native void set_int64_data(int index, @Cast("google::protobuf::int64") long value);
  public native void add_int64_data(@Cast("google::protobuf::int64") long value);

  // repeated double double_data = 10 [packed = true];
  public native int double_data_size();
  public native void clear_double_data();
  @MemberGetter public static native int kDoubleDataFieldNumber();
  public static final int kDoubleDataFieldNumber = kDoubleDataFieldNumber();
  public native double double_data(int index);
  public native void set_double_data(int index, double value);
  public native void add_double_data(double value);

  // repeated uint64 uint64_data = 11 [packed = true];
  public native int uint64_data_size();
  public native void clear_uint64_data();
  @MemberGetter public static native int kUint64DataFieldNumber();
  public static final int kUint64DataFieldNumber = kUint64DataFieldNumber();
  public native @Cast("google::protobuf::uint64") long uint64_data(int index);
  public native void set_uint64_data(int index, @Cast("google::protobuf::uint64") long value);
  public native void add_uint64_data(@Cast("google::protobuf::uint64") long value);

  // optional string name = 8;
  public native @Cast("bool") boolean has_name();
  public native void clear_name();
  @MemberGetter public static native int kNameFieldNumber();
  public static final int kNameFieldNumber = kNameFieldNumber();
  public native @StdString BytePointer name();
  public native void set_name(@StdString BytePointer value);
  public native void set_name(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_name();
  public native void set_allocated_name(@StdString @Cast({"char*", "std::string*"}) BytePointer name);

  // optional bytes raw_data = 9;
  public native @Cast("bool") boolean has_raw_data();
  public native void clear_raw_data();
  @MemberGetter public static native int kRawDataFieldNumber();
  public static final int kRawDataFieldNumber = kRawDataFieldNumber();
  public native @StdString BytePointer raw_data();
  public native void set_raw_data(@StdString BytePointer value);
  public native void set_raw_data(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_raw_data(@Const Pointer value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_raw_data();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_raw_data();
  public native void set_allocated_raw_data(@StdString @Cast({"char*", "std::string*"}) BytePointer raw_data);

  // optional string doc_string = 12;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional .onnx.TensorProto.Segment segment = 3;
  public native @Cast("bool") boolean has_segment();
  public native void clear_segment();
  @MemberGetter public static native int kSegmentFieldNumber();
  public static final int kSegmentFieldNumber = kSegmentFieldNumber();
  public native @Const @ByRef TensorProto_Segment segment();
  public native TensorProto_Segment release_segment();
  public native TensorProto_Segment mutable_segment();
  public native void set_allocated_segment(TensorProto_Segment segment);

  // optional .onnx.TensorProto.DataType data_type = 2;
  public native @Cast("bool") boolean has_data_type();
  public native void clear_data_type();
  @MemberGetter public static native int kDataTypeFieldNumber();
  public static final int kDataTypeFieldNumber = kDataTypeFieldNumber();
  public native @Cast("onnx::TensorProto_DataType") int data_type();
  public native void set_data_type(@Cast("onnx::TensorProto_DataType") int value);
}
// -------------------------------------------------------------------

@Name("onnx::TensorShapeProto_Dimension") @NoOffset public static class Dimension extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Dimension(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Dimension(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Dimension position(long position) {
        return (Dimension)super.position(position);
    }

  public Dimension() { super((Pointer)null); allocate(); }
  private native void allocate();

  public Dimension(@Const @ByRef Dimension from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef Dimension from);

  public native @ByRef @Name("operator =") Dimension put(@Const @ByRef Dimension from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef Dimension default_instance();

  /** enum onnx::TensorShapeProto_Dimension::ValueCase */
  public static final int
    kDimValue = 1,
    kDimParam = 2,
    VALUE_NOT_SET = 0;

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const Dimension internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(Dimension other);
  

  // implements Message ----------------------------------------------

  public native Dimension New();

  public native Dimension New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef Dimension from);
  public native void MergeFrom(@Const @ByRef Dimension from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string denotation = 3;
  public native @Cast("bool") boolean has_denotation();
  public native void clear_denotation();
  @MemberGetter public static native int kDenotationFieldNumber();
  public static final int kDenotationFieldNumber = kDenotationFieldNumber();
  public native @StdString BytePointer denotation();
  public native void set_denotation(@StdString BytePointer value);
  public native void set_denotation(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_denotation(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_denotation(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_denotation();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_denotation();
  public native void set_allocated_denotation(@StdString @Cast({"char*", "std::string*"}) BytePointer denotation);

  // optional int64 dim_value = 1;
  public native @Cast("bool") boolean has_dim_value();
  public native void clear_dim_value();
  @MemberGetter public static native int kDimValueFieldNumber();
  public static final int kDimValueFieldNumber = kDimValueFieldNumber();
  public native @Cast("google::protobuf::int64") long dim_value();
  public native void set_dim_value(@Cast("google::protobuf::int64") long value);

  // optional string dim_param = 2;
  public native @Cast("bool") boolean has_dim_param();
  public native void clear_dim_param();
  @MemberGetter public static native int kDimParamFieldNumber();
  public static final int kDimParamFieldNumber = kDimParamFieldNumber();
  public native @StdString BytePointer dim_param();
  public native void set_dim_param(@StdString BytePointer value);
  public native void set_dim_param(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_dim_param(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_dim_param(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_dim_param();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_dim_param();
  public native void set_allocated_dim_param(@StdString @Cast({"char*", "std::string*"}) BytePointer dim_param);

  public native void clear_value();
  public native @Cast("onnx::TensorShapeProto_Dimension::ValueCase") int value_case();
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TensorShapeProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorShapeProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TensorShapeProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TensorShapeProto position(long position) {
        return (TensorShapeProto)super.position(position);
    }

  public TensorShapeProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TensorShapeProto(@Const @ByRef TensorShapeProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TensorShapeProto from);

  public native @ByRef @Name("operator =") TensorShapeProto put(@Const @ByRef TensorShapeProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TensorShapeProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const TensorShapeProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(TensorShapeProto other);
  

  // implements Message ----------------------------------------------

  public native TensorShapeProto New();

  public native TensorShapeProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TensorShapeProto from);
  public native void MergeFrom(@Const @ByRef TensorShapeProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .onnx.TensorShapeProto.Dimension dim = 1;
  public native int dim_size();
  public native void clear_dim();
  @MemberGetter public static native int kDimFieldNumber();
  public static final int kDimFieldNumber = kDimFieldNumber();
  public native Dimension mutable_dim(int index);
  public native @Const @ByRef Dimension dim(int index);
  public native Dimension add_dim();
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TypeProto_Tensor extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProto_Tensor(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TypeProto_Tensor(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TypeProto_Tensor position(long position) {
        return (TypeProto_Tensor)super.position(position);
    }

  public TypeProto_Tensor() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TypeProto_Tensor(@Const @ByRef TypeProto_Tensor from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TypeProto_Tensor from);

  public native @ByRef @Name("operator =") TypeProto_Tensor put(@Const @ByRef TypeProto_Tensor from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TypeProto_Tensor default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const TypeProto_Tensor internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(TypeProto_Tensor other);
  

  // implements Message ----------------------------------------------

  public native TypeProto_Tensor New();

  public native TypeProto_Tensor New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TypeProto_Tensor from);
  public native void MergeFrom(@Const @ByRef TypeProto_Tensor from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .onnx.TensorShapeProto shape = 2;
  public native @Cast("bool") boolean has_shape();
  public native void clear_shape();
  @MemberGetter public static native int kShapeFieldNumber();
  public static final int kShapeFieldNumber = kShapeFieldNumber();
  public native @Const @ByRef TensorShapeProto shape();
  public native TensorShapeProto release_shape();
  public native TensorShapeProto mutable_shape();
  public native void set_allocated_shape(TensorShapeProto shape);

  // optional .onnx.TensorProto.DataType elem_type = 1;
  public native @Cast("bool") boolean has_elem_type();
  public native void clear_elem_type();
  @MemberGetter public static native int kElemTypeFieldNumber();
  public static final int kElemTypeFieldNumber = kElemTypeFieldNumber();
  public native @Cast("onnx::TensorProto_DataType") int elem_type();
  public native void set_elem_type(@Cast("onnx::TensorProto_DataType") int value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TypeProto_Sequence extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProto_Sequence(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TypeProto_Sequence(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TypeProto_Sequence position(long position) {
        return (TypeProto_Sequence)super.position(position);
    }

  public TypeProto_Sequence() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TypeProto_Sequence(@Const @ByRef TypeProto_Sequence from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TypeProto_Sequence from);

  public native @ByRef @Name("operator =") TypeProto_Sequence put(@Const @ByRef TypeProto_Sequence from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TypeProto_Sequence default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const TypeProto_Sequence internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(TypeProto_Sequence other);
  

  // implements Message ----------------------------------------------

  public native TypeProto_Sequence New();

  public native TypeProto_Sequence New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TypeProto_Sequence from);
  public native void MergeFrom(@Const @ByRef TypeProto_Sequence from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .onnx.TypeProto elem_type = 1;
  public native @Cast("bool") boolean has_elem_type();
  public native void clear_elem_type();
  @MemberGetter public static native int kElemTypeFieldNumber();
  public static final int kElemTypeFieldNumber = kElemTypeFieldNumber();
  public native @Const @ByRef TypeProto elem_type();
  public native TypeProto release_elem_type();
  public native TypeProto mutable_elem_type();
  public native void set_allocated_elem_type(TypeProto elem_type);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TypeProto_Map extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProto_Map(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TypeProto_Map(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TypeProto_Map position(long position) {
        return (TypeProto_Map)super.position(position);
    }

  public TypeProto_Map() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TypeProto_Map(@Const @ByRef TypeProto_Map from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TypeProto_Map from);

  public native @ByRef @Name("operator =") TypeProto_Map put(@Const @ByRef TypeProto_Map from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TypeProto_Map default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const TypeProto_Map internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(TypeProto_Map other);
  

  // implements Message ----------------------------------------------

  public native TypeProto_Map New();

  public native TypeProto_Map New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TypeProto_Map from);
  public native void MergeFrom(@Const @ByRef TypeProto_Map from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .onnx.TypeProto value_type = 2;
  public native @Cast("bool") boolean has_value_type();
  public native void clear_value_type();
  @MemberGetter public static native int kValueTypeFieldNumber();
  public static final int kValueTypeFieldNumber = kValueTypeFieldNumber();
  public native @Const @ByRef TypeProto value_type();
  public native TypeProto release_value_type();
  public native TypeProto mutable_value_type();
  public native void set_allocated_value_type(TypeProto value_type);

  // optional .onnx.TensorProto.DataType key_type = 1;
  public native @Cast("bool") boolean has_key_type();
  public native void clear_key_type();
  @MemberGetter public static native int kKeyTypeFieldNumber();
  public static final int kKeyTypeFieldNumber = kKeyTypeFieldNumber();
  public native @Cast("onnx::TensorProto_DataType") int key_type();
  public native void set_key_type(@Cast("onnx::TensorProto_DataType") int value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TypeProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TypeProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TypeProto position(long position) {
        return (TypeProto)super.position(position);
    }

  public TypeProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TypeProto(@Const @ByRef TypeProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TypeProto from);

  public native @ByRef @Name("operator =") TypeProto put(@Const @ByRef TypeProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TypeProto default_instance();

  /** enum onnx::TypeProto::ValueCase */
  public static final int
    kTensorType = 1,
    kSequenceType = 4,
    kMapType = 5,
    VALUE_NOT_SET = 0;

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const TypeProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(TypeProto other);
  

  // implements Message ----------------------------------------------

  public native TypeProto New();

  public native TypeProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TypeProto from);
  public native void MergeFrom(@Const @ByRef TypeProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string denotation = 6;
  public native @Cast("bool") boolean has_denotation();
  public native void clear_denotation();
  @MemberGetter public static native int kDenotationFieldNumber();
  public static final int kDenotationFieldNumber = kDenotationFieldNumber();
  public native @StdString BytePointer denotation();
  public native void set_denotation(@StdString BytePointer value);
  public native void set_denotation(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_denotation(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_denotation(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_denotation();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_denotation();
  public native void set_allocated_denotation(@StdString @Cast({"char*", "std::string*"}) BytePointer denotation);

  // optional .onnx.TypeProto.Tensor tensor_type = 1;
  public native @Cast("bool") boolean has_tensor_type();
  public native void clear_tensor_type();
  @MemberGetter public static native int kTensorTypeFieldNumber();
  public static final int kTensorTypeFieldNumber = kTensorTypeFieldNumber();
  public native @Const @ByRef TypeProto_Tensor tensor_type();
  public native TypeProto_Tensor release_tensor_type();
  public native TypeProto_Tensor mutable_tensor_type();
  public native void set_allocated_tensor_type(TypeProto_Tensor tensor_type);

  // optional .onnx.TypeProto.Sequence sequence_type = 4;
  public native @Cast("bool") boolean has_sequence_type();
  public native void clear_sequence_type();
  @MemberGetter public static native int kSequenceTypeFieldNumber();
  public static final int kSequenceTypeFieldNumber = kSequenceTypeFieldNumber();
  public native @Const @ByRef TypeProto_Sequence sequence_type();
  public native TypeProto_Sequence release_sequence_type();
  public native TypeProto_Sequence mutable_sequence_type();
  public native void set_allocated_sequence_type(TypeProto_Sequence sequence_type);

  // optional .onnx.TypeProto.Map map_type = 5;
  public native @Cast("bool") boolean has_map_type();
  public native void clear_map_type();
  @MemberGetter public static native int kMapTypeFieldNumber();
  public static final int kMapTypeFieldNumber = kMapTypeFieldNumber();
  public native @Const @ByRef TypeProto_Map map_type();
  public native TypeProto_Map release_map_type();
  public native TypeProto_Map mutable_map_type();
  public native void set_allocated_map_type(TypeProto_Map map_type);

  public native void clear_value();
  public native @Cast("onnx::TypeProto::ValueCase") int value_case();
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class OperatorSetIdProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OperatorSetIdProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OperatorSetIdProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public OperatorSetIdProto position(long position) {
        return (OperatorSetIdProto)super.position(position);
    }

  public OperatorSetIdProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public OperatorSetIdProto(@Const @ByRef OperatorSetIdProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef OperatorSetIdProto from);

  public native @ByRef @Name("operator =") OperatorSetIdProto put(@Const @ByRef OperatorSetIdProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef OperatorSetIdProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const OperatorSetIdProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(OperatorSetIdProto other);
  

  // implements Message ----------------------------------------------

  public native OperatorSetIdProto New();

  public native OperatorSetIdProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef OperatorSetIdProto from);
  public native void MergeFrom(@Const @ByRef OperatorSetIdProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string domain = 1;
  public native @Cast("bool") boolean has_domain();
  public native void clear_domain();
  @MemberGetter public static native int kDomainFieldNumber();
  public static final int kDomainFieldNumber = kDomainFieldNumber();
  public native @StdString BytePointer domain();
  public native void set_domain(@StdString BytePointer value);
  public native void set_domain(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_domain(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_domain(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_domain();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_domain();
  public native void set_allocated_domain(@StdString @Cast({"char*", "std::string*"}) BytePointer domain);

  // optional int64 version = 2;
  public native @Cast("bool") boolean has_version();
  public native void clear_version();
  @MemberGetter public static native int kVersionFieldNumber();
  public static final int kVersionFieldNumber = kVersionFieldNumber();
  public native @Cast("google::protobuf::int64") long version();
  public native void set_version(@Cast("google::protobuf::int64") long value);
}
// ===================================================================


// ===================================================================

// #ifdef __GNUC__
//   #pragma GCC diagnostic push
//   #pragma GCC diagnostic ignored "-Wstrict-aliasing"
// #endif  // __GNUC__
// AttributeProto

// optional string name = 1;






// #if LANG_CXX11

// #endif






// optional string ref_attr_name = 21;






// #if LANG_CXX11

// #endif






// optional string doc_string = 13;






// #if LANG_CXX11

// #endif






// optional .onnx.AttributeProto.AttributeType type = 20;







// optional float f = 2;







// optional int64 i = 3;







// optional bytes s = 4;






// #if LANG_CXX11

// #endif






// optional .onnx.TensorProto t = 5;










// optional .onnx.GraphProto g = 6;










// repeated float floats = 7;








// repeated int64 ints = 8;








// repeated bytes strings = 9;





// #if LANG_CXX11

// #endif




// #if LANG_CXX11

// #endif





// repeated .onnx.TensorProto tensors = 10;








// repeated .onnx.GraphProto graphs = 11;








// -------------------------------------------------------------------

// ValueInfoProto

// optional string name = 1;






// #if LANG_CXX11

// #endif






// optional .onnx.TypeProto type = 2;










// optional string doc_string = 3;






// #if LANG_CXX11

// #endif






// -------------------------------------------------------------------

// NodeProto

// repeated string input = 1;





// #if LANG_CXX11

// #endif




// #if LANG_CXX11

// #endif





// repeated string output = 2;





// #if LANG_CXX11

// #endif




// #if LANG_CXX11

// #endif





// optional string name = 3;






// #if LANG_CXX11

// #endif






// optional string op_type = 4;






// #if LANG_CXX11

// #endif






// optional string domain = 7;






// #if LANG_CXX11

// #endif






// repeated .onnx.AttributeProto attribute = 5;








// optional string doc_string = 6;






// #if LANG_CXX11

// #endif






// -------------------------------------------------------------------

// ModelProto

// optional int64 ir_version = 1;







// repeated .onnx.OperatorSetIdProto opset_import = 8;








// optional string producer_name = 2;






// #if LANG_CXX11

// #endif






// optional string producer_version = 3;






// #if LANG_CXX11

// #endif






// optional string domain = 4;






// #if LANG_CXX11

// #endif






// optional int64 model_version = 5;







// optional string doc_string = 6;






// #if LANG_CXX11

// #endif






// optional .onnx.GraphProto graph = 7;










// repeated .onnx.StringStringEntryProto metadata_props = 14;








// -------------------------------------------------------------------

// StringStringEntryProto

// optional string key = 1;






// #if LANG_CXX11

// #endif






// optional string value = 2;






// #if LANG_CXX11

// #endif






// -------------------------------------------------------------------

// GraphProto

// repeated .onnx.NodeProto node = 1;








// optional string name = 2;






// #if LANG_CXX11

// #endif






// repeated .onnx.TensorProto initializer = 5;








// optional string doc_string = 10;






// #if LANG_CXX11

// #endif






// repeated .onnx.ValueInfoProto input = 11;








// repeated .onnx.ValueInfoProto output = 12;








// repeated .onnx.ValueInfoProto value_info = 13;








// -------------------------------------------------------------------

// TensorProto_Segment

// optional int64 begin = 1;







// optional int64 end = 2;







// -------------------------------------------------------------------

// TensorProto

// repeated int64 dims = 1;








// optional .onnx.TensorProto.DataType data_type = 2;







// optional .onnx.TensorProto.Segment segment = 3;










// repeated float float_data = 4 [packed = true];








// repeated int32 int32_data = 5 [packed = true];








// repeated bytes string_data = 6;





// #if LANG_CXX11

// #endif




// #if LANG_CXX11

// #endif





// repeated int64 int64_data = 7 [packed = true];








// optional string name = 8;






// #if LANG_CXX11

// #endif






// optional string doc_string = 12;






// #if LANG_CXX11

// #endif






// optional bytes raw_data = 9;






// #if LANG_CXX11

// #endif






// repeated double double_data = 10 [packed = true];








// repeated uint64 uint64_data = 11 [packed = true];








// -------------------------------------------------------------------

// TensorShapeProto_Dimension

// optional int64 dim_value = 1;






// optional string dim_param = 2;





// #if LANG_CXX11

// #endif






// optional string denotation = 3;






// #if LANG_CXX11

// #endif









// -------------------------------------------------------------------

// TensorShapeProto

// repeated .onnx.TensorShapeProto.Dimension dim = 1;








// -------------------------------------------------------------------

// TypeProto_Tensor

// optional .onnx.TensorProto.DataType elem_type = 1;







// optional .onnx.TensorShapeProto shape = 2;










// -------------------------------------------------------------------

// TypeProto_Sequence

// optional .onnx.TypeProto elem_type = 1;










// -------------------------------------------------------------------

// TypeProto_Map

// optional .onnx.TensorProto.DataType key_type = 1;







// optional .onnx.TypeProto value_type = 2;










// -------------------------------------------------------------------

// TypeProto

// optional .onnx.TypeProto.Tensor tensor_type = 1;








// optional .onnx.TypeProto.Sequence sequence_type = 4;








// optional .onnx.TypeProto.Map map_type = 5;








// optional string denotation = 6;






// #if LANG_CXX11

// #endif









// -------------------------------------------------------------------

// OperatorSetIdProto

// optional string domain = 1;






// #if LANG_CXX11

// #endif






// optional int64 version = 2;







// #ifdef __GNUC__
//   #pragma GCC diagnostic pop
// #endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

  // namespace onnx




  // namespace protobuf
  // namespace google

// @@protoc_insertion_point(global_scope)

// #endif  // PROTOBUF_INCLUDED_onnx_2fonnx_2dml_2eproto


// Parsed from google/protobuf/arena.h

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This file defines an Arena allocator for better allocation performance.

// #ifndef GOOGLE_PROTOBUF_ARENA_H__
// #define GOOGLE_PROTOBUF_ARENA_H__

// #include <limits>
// #ifdef max
// #undef max  // Visual Studio defines this macro
// #endif
// #if defined(_MSC_VER) && !defined(_LIBCPP_STD_VER) && !_HAS_EXCEPTIONS
// Work around bugs in MSVC <typeinfo> header when _HAS_EXCEPTIONS=0.
// #include <exception>
// #include <typeinfo>

// #else
// #include <typeinfo>
// #endif

// #include <google/protobuf/arena_impl.h>
// #include <google/protobuf/stubs/port.h>
// #include <type_traits>  // defined below

  // namespace protobuf

@Namespace("google::quality_webanswers") public static native void TempPrivateWorkAround(ArenaOptions arena_options);

  // namespace quality_webanswers          // defined below        // defined in message.h

@Namespace("google::protobuf::arena_metrics") public static native void EnableArenaMetrics(ArenaOptions options);

  // namespace arena_metrics

@Namespace("google::protobuf::internal") @Opaque public static class ArenaStringPtr extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ArenaStringPtr() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ArenaStringPtr(Pointer p) { super(p); }
}     // defined in arenastring.h
@Namespace("google::protobuf::internal") @Opaque public static class LazyField extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LazyField() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LazyField(Pointer p) { super(p); }
}           // defined in lazy_field.h  // defined in repeated_field.h

// Templated cleanup methods.
@Namespace("google::protobuf::internal") public static native void arena_free(Pointer object, @Cast("size_t") long size);

  // namespace internal

// ArenaOptions provides optional additional parameters to arena construction
// that control its block-allocation behavior.
@Namespace("google::protobuf") @NoOffset public static class ArenaOptions extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ArenaOptions(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ArenaOptions(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ArenaOptions position(long position) {
        return (ArenaOptions)super.position(position);
    }

  // This defines the size of the first block requested from the system malloc.
  // Subsequent block sizes will increase in a geometric series up to a maximum.
  public native @Cast("size_t") long start_block_size(); public native ArenaOptions start_block_size(long start_block_size);

  // This defines the maximum block size requested from system malloc (unless an
  // individual arena allocation request occurs with a size larger than this
  // maximum). Requested block sizes increase up to this value, then remain
  // here.
  public native @Cast("size_t") long max_block_size(); public native ArenaOptions max_block_size(long max_block_size);

  // An initial block of memory for the arena to use, or NULL for none. If
  // provided, the block must live at least as long as the arena itself. The
  // creator of the Arena retains ownership of the block after the Arena is
  // destroyed.
  public native @Cast("char*") BytePointer initial_block(); public native ArenaOptions initial_block(BytePointer initial_block);

  // The size of the initial block, if provided.
  public native @Cast("size_t") long initial_block_size(); public native ArenaOptions initial_block_size(long initial_block_size);

  // A function pointer to an alloc method that returns memory blocks of size
  // requested. By default, it contains a ptr to the malloc function.
  //
  // NOTE: block_alloc and dealloc functions are expected to behave like
  // malloc and free, including Asan poisoning.
  public static class Block_alloc_long extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Block_alloc_long(Pointer p) { super(p); }
      protected Block_alloc_long() { allocate(); }
      private native void allocate();
      public native Pointer call(@Cast("size_t") long arg0);
  }
  public native Block_alloc_long block_alloc(); public native ArenaOptions block_alloc(Block_alloc_long block_alloc);
  // A function pointer to a dealloc method that takes ownership of the blocks
  // from the arena. By default, it contains a ptr to a wrapper function that
  // calls free.
  public static class Block_dealloc_Pointer_long extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Block_dealloc_Pointer_long(Pointer p) { super(p); }
      protected Block_dealloc_Pointer_long() { allocate(); }
      private native void allocate();
      public native void call(Pointer arg0, @Cast("size_t") long arg1);
  }
  public native Block_dealloc_Pointer_long block_dealloc(); public native ArenaOptions block_dealloc(Block_dealloc_Pointer_long block_dealloc);

  public ArenaOptions() { super((Pointer)null); allocate(); }
  private native void allocate();
}

// Support for non-RTTI environments. (The metrics hooks API uses type
// information.)
// #ifndef GOOGLE_PROTOBUF_NO_RTTI
// #define RTTI_TYPE_ID(type) (&typeid(type))
// #else
// #define RTTI_TYPE_ID(type) (NULL)
// #endif

// Arena allocator. Arena allocation replaces ordinary (heap-based) allocation
// with new/delete, and improves performance by aggregating allocations into
// larger blocks and freeing allocations all at once. Protocol messages are
// allocated on an arena by using Arena::CreateMessage<T>(Arena*), below, and
// are automatically freed when the arena is destroyed.
//
// This is a thread-safe implementation: multiple threads may allocate from the
// arena concurrently. Destruction is not thread-safe and the destructing
// thread must synchronize with users of the arena first.
//
// An arena provides two allocation interfaces: CreateMessage<T>, which works
// for arena-enabled proto2 message types as well as other types that satisfy
// the appropriate protocol (described below), and Create<T>, which works for
// any arbitrary type T. CreateMessage<T> is better when the type T supports it,
// because this interface (i) passes the arena pointer to the created object so
// that its sub-objects and internal allocations can use the arena too, and (ii)
// elides the object's destructor call when possible. Create<T> does not place
// any special requirements on the type T, and will invoke the object's
// destructor when the arena is destroyed.
//
// The arena message allocation protocol, required by CreateMessage<T>, is as
// follows:
//
// - The type T must have (at least) two constructors: a constructor with no
//   arguments, called when a T is allocated on the heap; and a constructor with
//   a google::protobuf::Arena* argument, called when a T is allocated on an arena. If the
//   second constructor is called with a NULL arena pointer, it must be
//   equivalent to invoking the first (no-argument) constructor.
//
// - The type T must have a particular type trait: a nested type
//   |InternalArenaConstructable_|. This is usually a typedef to |void|. If no
//   such type trait exists, then the instantiation CreateMessage<T> will fail
//   to compile.
//
// - The type T *may* have the type trait |DestructorSkippable_|. If this type
//   trait is present in the type, then its destructor will not be called if and
//   only if it was passed a non-NULL arena pointer. If this type trait is not
//   present on the type, then its destructor is always called when the
//   containing arena is destroyed.
//
// - One- and two-user-argument forms of CreateMessage<T>() also exist that
//   forward these constructor arguments to T's constructor: for example,
//   CreateMessage<T>(Arena*, arg1, arg2) forwards to a constructor T(Arena*,
//   arg1, arg2).
//
// This protocol is implemented by all arena-enabled proto2 message classes as
// well as RepeatedPtrField.
//
// Do NOT subclass Arena. This class will be marked as final when C++11 is
// enabled.
@Namespace("google::protobuf") @NoOffset public static class Arena extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Arena(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Arena(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Arena position(long position) {
        return (Arena)super.position(position);
    }

  // Arena constructor taking custom options. See ArenaOptions below for
  // descriptions of the options available.
  public Arena(@Const @ByRef ArenaOptions options) { super((Pointer)null); allocate(options); }
  private native void allocate(@Const @ByRef ArenaOptions options);

  // Block overhead.  Use this as a guide for how much to over-allocate the
  // initial block if you want an allocation of size N to fit inside it.
  //
  // WARNING: if you allocate multiple objects, it is difficult to guarantee
  // that a series of allocations will fit in the initial block, especially if
  // Arena changes its alignment guarantees in the future!
  @MemberGetter public static native @Cast("const size_t") long kBlockOverhead();
  public static final long kBlockOverhead = kBlockOverhead();

  // Default constructor with sensible default options, tuned for average
  // use-cases.
  public Arena() { super((Pointer)null); allocate(); }
  private native void allocate();

  public native void Init(@Const @ByRef ArenaOptions options);

  // API to create proto2 message objects on the arena. If the arena passed in
  // is NULL, then a heap allocated object is returned. Type T must be a message
  // defined in a .proto file with cc_enable_arenas set to true, otherwise a
  // compilation error will occur.
  //
  // RepeatedField and RepeatedPtrField may also be instantiated directly on an
  // arena with this method.
  //
  // This function also accepts any type T that satisfies the arena message
  // allocation protocol, documented above.

  // API to create any objects on the arena. Note that only the object will
  // be created on the arena; the underlying ptrs (in case of a proto2 message)
  // will be still heap allocated. Proto messages should usually be allocated
  // with CreateMessage<T>() instead.
  //
  // Note that even if T satisfies the arena message construction protocol
  // (InternalArenaConstructable_ trait and optional DestructorSkippable_
  // trait), as described above, this function does not follow the protocol;
  // instead, it treats T as a black-box type, just as if it did not have these
  // traits. Specifically, T's constructor arguments will always be only those
  // passed to Create<T>() -- no additional arena pointer is implicitly added.
  // Furthermore, the destructor will always be called at arena destruction time
  // (unless the destructor is trivial). Hence, from T's point of view, it is as
  // if the object were allocated on the heap (except that the underlying memory
  // is obtained from the arena).

  // Create an array of object type T on the arena *without* invoking the
  // constructor of T. If `arena` is null, then the return value should be freed
  // with `delete[] x;` (or `::operator delete[](x);`).
  // To ensure safe uses, this function checks at compile time
  // (when compiled as C++11) that T is trivially default-constructible and
  // trivially destructible.

  // Returns the total space allocated by the arena, which is the sum of the
  // sizes of the underlying blocks. This method is relatively fast; a counter
  // is kept as blocks are allocated.
  public native @Cast("google::protobuf::uint64") long SpaceAllocated();
  // Returns the total space used by the arena. Similar to SpaceAllocated but
  // does not include free space and block overhead. The total space returned
  // may not include space used by other threads executing concurrently with
  // the call to this method.
  public native @Cast("google::protobuf::uint64") long SpaceUsed();
  // DEPRECATED. Please use SpaceAllocated() and SpaceUsed().
  //
  // Combines SpaceAllocated and SpaceUsed. Returns a pair of
  // <space_allocated, space_used>.
  public native @ByVal LongLongPair SpaceAllocatedAndUsed();

  // Frees all storage allocated by this arena after calling destructors
  // registered with OwnDestructor() and freeing objects registered with Own().
  // Any objects allocated on this arena are unusable after this call. It also
  // returns the total space used by the arena which is the sums of the sizes
  // of the allocated blocks. This method is not thread-safe.
  public native @Cast("google::protobuf::uint64") long Reset();

  // Adds |object| to a list of heap-allocated objects to be freed with |delete|
  // when the arena is destroyed or reset.

  // Adds |object| to a list of objects whose destructors will be manually
  // called when the arena is destroyed or reset. This differs from Own() in
  // that it does not free the underlying memory with |delete|; hence, it is
  // normally only used for objects that are placement-newed into
  // arena-allocated memory.

  // Adds a custom member function on an object to the list of destructors that
  // will be manually called when the arena is destroyed or reset. This differs
  // from OwnDestructor() in that any member function may be specified, not only
  // the class destructor.
  public static class Destruct_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Destruct_Pointer(Pointer p) { super(p); }
      protected Destruct_Pointer() { allocate(); }
      private native void allocate();
      public native void call(Pointer arg0);
  }
  public native void OwnCustomDestructor(
        Pointer object, Destruct_Pointer destruct);

  // Retrieves the arena associated with |value| if |value| is an arena-capable
  // message, or NULL otherwise. This differs from value->GetArena() in that the
  // latter is a virtual call, while this method is a templated call that
  // resolves at compile-time.

  // Helper typetraits that indicates support for arenas in a type T at compile
  // time. This is public only to allow construction of higher-level templated
  // utilities.
  //
  // is_arena_constructable<T>::value is true if the message type T has arena
  // support enabled, and false otherwise.
  //
  // is_destructor_skippable<T>::value is true if the message type T has told
  // the arena that it is safe to skip the destructor, and false otherwise.
  //
  // This is inside Arena because only Arena has the friend relationships
  // necessary to see the underlying generated code traits.
}

// Defined above for supporting environments without RTTI.
// #undef RTTI_TYPE_ID

  // namespace protobuf

  // namespace google
// #endif  // GOOGLE_PROTOBUF_ARENA_H__


// Parsed from google/protobuf/message_lite.h

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Authors: wink@google.com (Wink Saville),
//          kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// Defines MessageLite, the abstract interface implemented by all (lite
// and non-lite) protocol message objects.

// #ifndef GOOGLE_PROTOBUF_MESSAGE_LITE_H__
// #define GOOGLE_PROTOBUF_MESSAGE_LITE_H__

// #include <climits>
// #include <google/protobuf/stubs/common.h>
// #include <google/protobuf/stubs/logging.h>
// #include <google/protobuf/stubs/once.h>
// #include <google/protobuf/arena.h>
// #include <google/protobuf/stubs/port.h>
@Namespace("google::protobuf::io") @Opaque public static class CodedInputStream extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public CodedInputStream() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CodedInputStream(Pointer p) { super(p); }
}
@Namespace("google::protobuf::io") @Opaque public static class CodedOutputStream extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public CodedOutputStream() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CodedOutputStream(Pointer p) { super(p); }
}
@Namespace("google::protobuf::io") @Opaque public static class ZeroCopyInputStream extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ZeroCopyInputStream() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ZeroCopyInputStream(Pointer p) { super(p); }
}
@Namespace("google::protobuf::io") @Opaque public static class ZeroCopyOutputStream extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ZeroCopyOutputStream() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ZeroCopyOutputStream(Pointer p) { super(p); }
}


@Namespace("google::protobuf::internal") @Opaque public static class RepeatedPtrFieldBase extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public RepeatedPtrFieldBase() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RepeatedPtrFieldBase(Pointer p) { super(p); }
}
@Namespace("google::protobuf::internal") @Opaque public static class WireFormatLite extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public WireFormatLite() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public WireFormatLite(Pointer p) { super(p); }
}
@Namespace("google::protobuf::internal") @Opaque public static class WeakFieldMap extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public WeakFieldMap() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public WeakFieldMap(Pointer p) { super(p); }
}

// #ifndef SWIG
// We compute sizes as size_t but cache them as int.  This function converts a
// computed size to a cached size.  Since we don't proceed with serialization
// if the total size was > INT_MAX, it is not important what this function
// returns for inputs > INT_MAX.  However this case should not error or
// GOOGLE_CHECK-fail, because the full size_t resolution is still returned from
// ByteSizeLong() and checked against INT_MAX; we can catch the overflow
// there.
@Namespace("google::protobuf::internal") public static native int ToCachedSize(@Cast("size_t") long size);

// We mainly calculate sizes in terms of size_t, but some functions that
// compute sizes return "int".  These int sizes are expected to always be
// positive. This function is more efficient than casting an int to size_t
// directly on 64-bit platforms because it avoids making the compiler emit a
// sign extending instruction, which we don't want and don't want to pay for.
@Namespace("google::protobuf::internal") public static native @Cast("size_t") long FromIntSize(int size);

// For cases where a legacy function returns an integer size.  We GOOGLE_DCHECK()
// that the conversion will fit within an integer; if this is false then we
// are losing information.
@Namespace("google::protobuf::internal") public static native int ToIntSize(@Cast("size_t") long size);

// This type wraps a variable whose constructor and destructor are explicitly
// called. It is particularly useful for a global variable, without its
// constructor and destructor run on start and end of the program lifetime.
// This circumvents the initial construction order fiasco, while keeping
// the address of the empty string a compile time constant.
//
// Pay special attention to the initialization state of the object.
// 1. The object is "uninitialized" to begin with.
// 2. Call DefaultConstruct() only if the object is uninitialized.
//    After the call, the object becomes "initialized".
// 3. Call get() and get_mutable() only if the object is initialized.
// 4. Call Destruct() only if the object is initialized.
//    After the call, the object becomes uninitialized.

// Default empty string object. Don't use this directly. Instead, call
// GetEmptyString() to get the reference.

@Namespace("google::protobuf::internal") public static native @StdString BytePointer GetEmptyStringAlreadyInited();

@Namespace("google::protobuf::internal") public static native @Cast("size_t") long StringSpaceUsedExcludingSelfLong(@StdString BytePointer str);
@Namespace("google::protobuf::internal") public static native @Cast("size_t") long StringSpaceUsedExcludingSelfLong(@StdString String str);
// #endif  // SWIG
  // namespace internal

// Interface to light weight protocol messages.
//
// This interface is implemented by all protocol message objects.  Non-lite
// messages additionally implement the Message interface, which is a
// subclass of MessageLite.  Use MessageLite instead when you only need
// the subset of features which it supports -- namely, nothing that uses
// descriptors or reflection.  You can instruct the protocol compiler
// to generate classes which implement only MessageLite, not the full
// Message interface, by adding the following line to the .proto file:
//
//   option optimize_for = LITE_RUNTIME;
//
// This is particularly useful on resource-constrained systems where
// the full protocol buffers runtime library is too big.
//
// Note that on non-constrained systems (e.g. servers) when you need
// to link in lots of protocol definitions, a better way to reduce
// total code footprint is to use optimize_for = CODE_SIZE.  This
// will make the generated code smaller while still supporting all the
// same features (at the expense of speed).  optimize_for = LITE_RUNTIME
// is best when you only have a small number of message types linked
// into your binary, in which case the size of the protocol buffers
// runtime itself is the biggest problem.
@Namespace("google::protobuf") public static class MessageLite extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MessageLite(Pointer p) { super(p); }


  // Basic Operations ------------------------------------------------

  // Get the name of this message type, e.g. "foo.bar.BazProto".
  public native @StdString BytePointer GetTypeName();

  // Construct a new instance of the same type.  Ownership is passed to the
  // caller.
  public native MessageLite New();

  // Construct a new instance on the arena. Ownership is passed to the caller
  // if arena is a NULL. Default implementation for backwards compatibility.
  public native MessageLite New(Arena arena);

  // Get the arena, if any, associated with this message. Virtual method
  // required for generic operations but most arena-related operations should
  // use the GetArenaNoVirtual() generated-code method. Default implementation
  // to reduce code size by avoiding the need for per-type implementations
  // when types do not implement arena support.
  public native Arena GetArena();

  // Get a pointer that may be equal to this message's arena, or may not be.
  // If the value returned by this method is equal to some arena pointer, then
  // this message is on that arena; however, if this message is on some arena,
  // this method may or may not return that arena's pointer. As a tradeoff,
  // this method may be more efficient than GetArena(). The intent is to allow
  // underlying representations that use e.g. tagged pointers to sometimes
  // store the arena pointer directly, and sometimes in a more indirect way,
  // and allow a fastpath comparison against the arena pointer when it's easy
  // to obtain.
  public native Pointer GetMaybeArenaPointer();

  // Clear all fields of the message and set them to their default values.
  // Clear() avoids freeing memory, assuming that any memory allocated
  // to hold parts of the message will be needed again to hold the next
  // message.  If you actually want to free the memory used by a Message,
  // you must delete it.
  public native void Clear();

  // Quickly check if all required fields have values set.
  public native @Cast("bool") boolean IsInitialized();

  // This is not implemented for Lite messages -- it just returns "(cannot
  // determine missing fields for lite message)".  However, it is implemented
  // for full messages.  See message.h.
  public native @StdString BytePointer InitializationErrorString();

  // If |other| is the exact same class as this, calls MergeFrom(). Otherwise,
  // results are undefined (probably crash).
  public native void CheckTypeAndMergeFrom(@Const @ByRef MessageLite other);

  // Parsing ---------------------------------------------------------
  // Methods for parsing in protocol buffer format.  Most of these are
  // just simple wrappers around MergeFromCodedStream().  Clear() will be
  // called before merging the input.

  // Fill the message with a protocol buffer parsed from the given input
  // stream. Returns false on a read error or if the input is in the wrong
  // format.  A successful return does not indicate the entire input is
  // consumed, ensure you call ConsumedEntireMessage() to check that if
  // applicable.
  public native @Cast("bool") boolean ParseFromCodedStream(CodedInputStream input);
  // Like ParseFromCodedStream(), but accepts messages that are missing
  // required fields.
  public native @Cast("bool") boolean ParsePartialFromCodedStream(CodedInputStream input);
  // Read a protocol buffer from the given zero-copy input stream.  If
  // successful, the entire input will be consumed.
  public native @Cast("bool") boolean ParseFromZeroCopyStream(ZeroCopyInputStream input);
  // Like ParseFromZeroCopyStream(), but accepts messages that are missing
  // required fields.
  public native @Cast("bool") boolean ParsePartialFromZeroCopyStream(ZeroCopyInputStream input);
  // Read a protocol buffer from the given zero-copy input stream, expecting
  // the message to be exactly "size" bytes long.  If successful, exactly
  // this many bytes will have been consumed from the input.
  public native @Cast("bool") boolean ParseFromBoundedZeroCopyStream(ZeroCopyInputStream input, int size);
  // Like ParseFromBoundedZeroCopyStream(), but accepts messages that are
  // missing required fields.
  public native @Cast("bool") boolean ParsePartialFromBoundedZeroCopyStream(ZeroCopyInputStream input,
                                               int size);
  // Parses a protocol buffer contained in a string. Returns true on success.
  // This function takes a string in the (non-human-readable) binary wire
  // format, matching the encoding output by MessageLite::SerializeToString().
  // If you'd like to convert a human-readable string into a protocol buffer
  // object, see google::protobuf::TextFormat::ParseFromString().
  public native @Cast("bool") boolean ParseFromString(@StdString BytePointer data);
  public native @Cast("bool") boolean ParseFromString(@StdString String data);
  // Like ParseFromString(), but accepts messages that are missing
  // required fields.
  public native @Cast("bool") boolean ParsePartialFromString(@StdString BytePointer data);
  public native @Cast("bool") boolean ParsePartialFromString(@StdString String data);
  // Parse a protocol buffer contained in an array of bytes.
  public native @Cast("bool") boolean ParseFromArray(@Const Pointer data, int size);
  // Like ParseFromArray(), but accepts messages that are missing
  // required fields.
  public native @Cast("bool") boolean ParsePartialFromArray(@Const Pointer data, int size);


  // Reads a protocol buffer from the stream and merges it into this
  // Message.  Singular fields read from the what is
  // already in the Message and repeated fields are appended to those
  // already present.
  //
  // It is the responsibility of the caller to call input->LastTagWas()
  // (for groups) or input->ConsumedEntireMessage() (for non-groups) after
  // this returns to verify that the message's end was delimited correctly.
  //
  // ParsefromCodedStream() is implemented as Clear() followed by
  // MergeFromCodedStream().
  public native @Cast("bool") boolean MergeFromCodedStream(CodedInputStream input);

  // Like MergeFromCodedStream(), but succeeds even if required fields are
  // missing in the input.
  //
  // MergeFromCodedStream() is just implemented as MergePartialFromCodedStream()
  // followed by IsInitialized().
  public native @Cast("bool") boolean MergePartialFromCodedStream(CodedInputStream input);


  // Serialization ---------------------------------------------------
  // Methods for serializing in protocol buffer format.  Most of these
  // are just simple wrappers around ByteSize() and SerializeWithCachedSizes().

  // Write a protocol buffer of this message to the given output.  Returns
  // false on a write error.  If the message is missing required fields,
  // this may GOOGLE_CHECK-fail.
  public native @Cast("bool") boolean SerializeToCodedStream(CodedOutputStream output);
  // Like SerializeToCodedStream(), but allows missing required fields.
  public native @Cast("bool") boolean SerializePartialToCodedStream(CodedOutputStream output);
  // Write the message to the given zero-copy output stream.  All required
  // fields must be set.
  public native @Cast("bool") boolean SerializeToZeroCopyStream(ZeroCopyOutputStream output);
  // Like SerializeToZeroCopyStream(), but allows missing required fields.
  public native @Cast("bool") boolean SerializePartialToZeroCopyStream(ZeroCopyOutputStream output);
  // Serialize the message and store it in the given string.  All required
  // fields must be set.
  public native @Cast("bool") boolean SerializeToString(@StdString @Cast({"char*", "std::string*"}) BytePointer output);
  // Like SerializeToString(), but allows missing required fields.
  public native @Cast("bool") boolean SerializePartialToString(@StdString @Cast({"char*", "std::string*"}) BytePointer output);
  // Serialize the message and store it in the given byte array.  All required
  // fields must be set.
  public native @Cast("bool") boolean SerializeToArray(Pointer data, int size);
  // Like SerializeToArray(), but allows missing required fields.
  public native @Cast("bool") boolean SerializePartialToArray(Pointer data, int size);

  // Make a string encoding the message. Is equivalent to calling
  // SerializeToString() on a string and using that.  Returns the empty
  // string if SerializeToString() would have returned an error.
  // Note: If you intend to generate many such strings, you may
  // reduce heap fragmentation by instead re-using the same string
  // object with calls to SerializeToString().
  public native @StdString BytePointer SerializeAsString();
  // Like SerializeAsString(), but allows missing required fields.
  public native @StdString BytePointer SerializePartialAsString();

  // Like SerializeToString(), but appends to the data to the string's existing
  // contents.  All required fields must be set.
  public native @Cast("bool") boolean AppendToString(@StdString @Cast({"char*", "std::string*"}) BytePointer output);
  // Like AppendToString(), but allows missing required fields.
  public native @Cast("bool") boolean AppendPartialToString(@StdString @Cast({"char*", "std::string*"}) BytePointer output);

  // Computes the serialized size of the message.  This recursively calls
  // ByteSizeLong() on all embedded messages.
  //
  // ByteSizeLong() is generally linear in the number of fields defined for the
  // proto.
  public native @Cast("size_t") long ByteSizeLong();

  // Legacy ByteSize() API.
  public native int ByteSize();

  // Serializes the message without recomputing the size.  The message must not
  // have changed since the last call to ByteSize(), and the value returned by
  // ByteSize must be non-negative.  Otherwise the results are undefined.
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);

  // Functions below here are not part of the public interface.  It isn't
  // enforced, but they should be treated as private, and will be private
  // at some future time.  Unfortunately the implementation of the "friend"
  // keyword in GCC is broken at the moment, but we expect it will be fixed.

  // Like SerializeWithCachedSizes, but writes directly to *target, returning
  // a pointer to the byte immediately after the last byte written.  "target"
  // must point at a byte array of at least ByteSize() bytes.  Whether to use
  // deterministic serialization, e.g., maps in sorted order, is determined by
  // CodedOutputStream::IsDefaultSerializationDeterministic().
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] target);

  // Returns the result of the last call to ByteSize().  An embedded message's
  // size is needed both to serialize it (because embedded messages are
  // length-delimited) and to compute the outer message's size.  Caching
  // the size avoids computing it multiple times.
  //
  // ByteSize() does not automatically use the cached size when available
  // because this would require invalidating it every time the message was
  // modified, which would be too hard and expensive.  (E.g. if a deeply-nested
  // sub-message is changed, all of its parents' cached sizes would need to be
  // invalidated, which is too much work for an otherwise inlined setter
  // method.)
  public native int GetCachedSize();

  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(@Cast("bool") boolean deterministic,
                                                           @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(@Cast("bool") boolean deterministic,
                                                           @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(@Cast("bool") boolean deterministic,
                                                           @Cast("google::protobuf::uint8*") byte[] target);
}



// DO NOT USE: For migration only. Will be removed when Proto3 defaults to
// preserve unknowns.
@Namespace("google::protobuf::internal") public static native @Cast("bool") boolean GetProto3PreserveUnknownsDefault();

// DO NOT USE: For migration only. Will be removed when Proto3 defaults to
// preserve unknowns.
@Namespace("google::protobuf::internal") public static native void SetProto3PreserveUnknownsDefault(@Cast("bool") boolean preserve);
  // namespace internal


  // namespace protobuf

  // namespace google
// #endif  // GOOGLE_PROTOBUF_MESSAGE_LITE_H__


// Parsed from google/protobuf/unknown_field_set.h

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// Contains classes used to keep track of unrecognized fields seen while
// parsing a protocol message.

// #ifndef GOOGLE_PROTOBUF_UNKNOWN_FIELD_SET_H__
// #define GOOGLE_PROTOBUF_UNKNOWN_FIELD_SET_H__

// #include <assert.h>
// #include <string>
// #include <vector>
// #include <google/protobuf/stubs/common.h>
// #include <google/protobuf/stubs/logging.h>
// #include <google/protobuf/message_lite.h>         // coded_stream.h        // coded_stream.h      // zero_copy_stream.h
  
    @Namespace("google::protobuf::internal") @Opaque public static class InternalMetadataWithArena extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public InternalMetadataWithArena() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public InternalMetadataWithArena(Pointer p) { super(p); }
    }  // metadata.h
    @Namespace("google::protobuf::internal") @Opaque public static class WireFormat extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public WireFormat() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public WireFormat(Pointer p) { super(p); }
    }               // wire_format.h
    @Namespace("google::protobuf::internal") @Opaque public static class MessageSetFieldSkipperUsingCord extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public MessageSetFieldSkipperUsingCord() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MessageSetFieldSkipperUsingCord(Pointer p) { super(p); }
    }
                                    // extension_set_heavy.cc
                        // message.h                 // below

// An UnknownFieldSet contains fields that were encountered while parsing a
// message but were not defined by its type.  Keeping track of these can be
// useful, especially in that they may be written if the message is serialized
// again without being cleared in between.  This means that software which
// simply receives messages and forwards them to other servers does not need
// to be updated every time a new field is added to the message definition.
//
// To get the UnknownFieldSet attached to any message, call
// Reflection::GetUnknownFields().
//
// This class is necessarily tied to the protocol buffer wire format, unlike
// the Reflection interface which is independent of any serialization scheme.
@Namespace("google::protobuf") @NoOffset public static class UnknownFieldSet extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public UnknownFieldSet(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public UnknownFieldSet(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public UnknownFieldSet position(long position) {
        return (UnknownFieldSet)super.position(position);
    }

  public UnknownFieldSet() { super((Pointer)null); allocate(); }
  private native void allocate();

  // Remove all fields.
  public native void Clear();

  // Remove all fields and deallocate internal data objects
  public native void ClearAndFreeMemory();

  // Is this set empty?
  public native @Cast("bool") boolean empty();

  // Merge the contents of some other UnknownFieldSet with this one.
  public native void MergeFrom(@Const @ByRef UnknownFieldSet other);

  // Similar to above, but this function will destroy the contents of other.
  public native void MergeFromAndDestroy(UnknownFieldSet other);

  // Merge the contents an UnknownFieldSet with the UnknownFieldSet in
  // *metadata, if there is one.  If *metadata doesn't have an UnknownFieldSet
  // then add one to it and make it be a copy of the first arg.
  public static native void MergeToInternalMetdata(
        @Const @ByRef UnknownFieldSet other,
        InternalMetadataWithArena metadata);

  // Swaps the contents of some other UnknownFieldSet with this one.
  public native void Swap(UnknownFieldSet x);

  // Computes (an estimate of) the total number of bytes currently used for
  // storing the unknown fields in memory. Does NOT include
  // sizeof(*this) in the calculation.
  public native @Cast("size_t") long SpaceUsedExcludingSelfLong();

  public native int SpaceUsedExcludingSelf();

  // Version of SpaceUsed() including sizeof(*this).
  public native @Cast("size_t") long SpaceUsedLong();

  public native int SpaceUsed();

  // Returns the number of fields present in the UnknownFieldSet.
  public native int field_count();
  // Get a field in the set, where 0 <= index < field_count().  The fields
  // appear in the order in which they were added.
  public native @Const @ByRef UnknownField field(int index);
  // Get a mutable pointer to a field in the set, where
  // 0 <= index < field_count().  The fields appear in the order in which
  // they were added.
  public native UnknownField mutable_field(int index);

  // Adding fields ---------------------------------------------------

  public native void AddVarint(int number, @Cast("google::protobuf::uint64") long value);
  public native void AddFixed32(int number, @Cast("google::protobuf::uint32") int value);
  public native void AddFixed64(int number, @Cast("google::protobuf::uint64") long value);
  public native void AddLengthDelimited(int number, @StdString BytePointer value);
  public native void AddLengthDelimited(int number, @StdString String value);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer AddLengthDelimited(int number);
  public native UnknownFieldSet AddGroup(int number);

  // Adds an unknown field from another set.
  public native void AddField(@Const @ByRef UnknownField field);

  // Delete fields with indices in the range [start .. start+num-1].
  // Caution: implementation moves all fields with indices [start+num .. ].
  public native void DeleteSubrange(int start, int num);

  // Delete all fields with a specific field number. The order of left fields
  // is preserved.
  // Caution: implementation moves all fields after the first deleted field.
  public native void DeleteByNumber(int number);

  // Parsing helpers -------------------------------------------------
  // These work exactly like the similarly-named methods of Message.

  public native @Cast("bool") boolean MergeFromCodedStream(CodedInputStream input);
  public native @Cast("bool") boolean ParseFromCodedStream(CodedInputStream input);
  public native @Cast("bool") boolean ParseFromZeroCopyStream(ZeroCopyInputStream input);
  public native @Cast("bool") boolean ParseFromArray(@Const Pointer data, int size);
  public native @Cast("bool") boolean ParseFromString(@StdString BytePointer data);
  public native @Cast("bool") boolean ParseFromString(@StdString String data);

  public static native @Const UnknownFieldSet default_instance();
}

// Represents one field in an UnknownFieldSet.
@Namespace("google::protobuf") public static class UnknownField extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public UnknownField() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public UnknownField(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public UnknownField(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public UnknownField position(long position) {
        return (UnknownField)super.position(position);
    }

  /** enum google::protobuf::UnknownField::Type */
  public static final int
    TYPE_VARINT = 0,
    TYPE_FIXED32 = 1,
    TYPE_FIXED64 = 2,
    TYPE_LENGTH_DELIMITED = 3,
    TYPE_GROUP = 4;

  // The field's field number, as seen on the wire.
  public native int number();

  // The field type.
  public native @Cast("google::protobuf::UnknownField::Type") int type();

  // Accessors -------------------------------------------------------
  // Each method works only for UnknownFields of the corresponding type.

  public native @Cast("google::protobuf::uint64") long varint();
  public native @Cast("google::protobuf::uint32") int fixed32();
  public native @Cast("google::protobuf::uint64") long fixed64();
  public native @StdString BytePointer length_delimited();
  public native @Const @ByRef UnknownFieldSet group();

  public native void set_varint(@Cast("google::protobuf::uint64") long value);
  public native void set_fixed32(@Cast("google::protobuf::uint32") int value);
  public native void set_fixed64(@Cast("google::protobuf::uint64") long value);
  public native void set_length_delimited(@StdString BytePointer value);
  public native void set_length_delimited(@StdString String value);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_length_delimited();
  public native UnknownFieldSet mutable_group();

  // Serialization API.
  // These methods can take advantage of the underlying implementation and may
  // archieve a better performance than using getters to retrieve the data and
  // do the serialization yourself.
  public native void SerializeLengthDelimitedNoTag(CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeLengthDelimitedNoTagToArray(@Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeLengthDelimitedNoTagToArray(@Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeLengthDelimitedNoTagToArray(@Cast("google::protobuf::uint8*") byte[] target);

  public native @Cast("size_t") long GetLengthDelimitedSize();


  // If this UnknownField contains a pointer, delete it.
  public native void Delete();

  // Reset all the underlying pointers to NULL. A special function to be only
  // used while merging from a temporary UFS.
  public native void Reset();

  // Make a deep copy of any pointers in this UnknownField.
  public native void DeepCopy(@Const @ByRef UnknownField other);

  // Set the wire type of this UnknownField. Should only be used when this
  // UnknownField is being created.
  public native void SetType(@Cast("google::protobuf::UnknownField::Type") int type);

  public native @Cast("google::protobuf::uint32") int number_(); public native UnknownField number_(int number_);
  public native @Cast("google::protobuf::uint32") int type_(); public native UnknownField type_(int type_);
    @Name("data_.varint_") public native @Cast("google::protobuf::uint64") long data__varint_(); public native UnknownField data__varint_(long data__varint_);
    @Name("data_.fixed32_") public native @Cast("google::protobuf::uint32") int data__fixed32_(); public native UnknownField data__fixed32_(int data__fixed32_);
    @Name("data_.fixed64_") public native @Cast("google::protobuf::uint64") long data__fixed64_(); public native UnknownField data__fixed64_(long data__fixed64_);
    @Name("data_.group_") public native UnknownFieldSet data__group_(); public native UnknownField data__group_(UnknownFieldSet data__group_);
}

// ===================================================================
// inline implementations











































  // namespace protobuf

  // namespace google
// #endif  // GOOGLE_PROTOBUF_UNKNOWN_FIELD_SET_H__


// Parsed from onnx/proto_utils.h

// #pragma once

// #include <google/protobuf/io/coded_stream.h>
// #include <google/protobuf/io/zero_copy_stream_impl_lite.h>

// #ifdef ONNX_USE_LITE_PROTO
// #include <google/protobuf/message_lite.h>
// #else // ONNX_USE_LITE_PROTO
// #include <google/protobuf/message.h>
// #endif  // !ONNX_USE_LITE_PROTO

// #ifdef ONNX_USE_LITE_PROTO
@Namespace("onnx") public static native @StdString BytePointer ProtoDebugString(@Const @ByRef MessageLite proto);
// #else
// #endif

@Namespace("onnx") public static native @Cast("bool") boolean ParseProtoFromBytes(MessageLite proto, @Cast("const char*") BytePointer buffer, @Cast("size_t") long length);
@Namespace("onnx") public static native @Cast("bool") boolean ParseProtoFromBytes(MessageLite proto, String buffer, @Cast("size_t") long length);

@Namespace("onnx") public static native @ByVal @Name("RetrieveValues<int64_t>") LongVector RetrieveValuesLong(@Const @ByRef AttributeProto attr);

@Namespace("onnx") public static native @ByVal @Name("RetrieveValues<std::string>") StringVector RetrieveValuesString(@Const @ByRef AttributeProto attr);

 // namespace ONNX_NAMESPACE


// Parsed from onnx/checker.h

// #pragma once

// #include <stdexcept>
// #include <unordered_map>
// #include <unordered_set>
// #include "onnx/defs/schema.h"
// #include "onnx/onnx-operators_pb.h"
// #include "onnx/onnx_pb.h"
// #include "onnx/string_utils.h"
@Namespace("onnx::checker") @NoOffset public static class ValidationError extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ValidationError(Pointer p) { super(p); }

  public native @NoException @Cast("const char*") BytePointer what();
  public native void AppendContext(@StdString BytePointer context);
  public native void AppendContext(@StdString String context);
}

// #define fail_check(...)
//   throw ONNX_NAMESPACE::checker::ValidationError(
//       ONNX_NAMESPACE::MakeString(__VA_ARGS__));

@Namespace("onnx::checker") @NoOffset public static class CheckerContext extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CheckerContext(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public CheckerContext(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public CheckerContext position(long position) {
        return (CheckerContext)super.position(position);
    }

  public native int get_ir_version();
  public native void set_ir_version(int v);
  public native @Const @ByRef StringIntMap get_opset_imports();
  public native void set_opset_imports(@ByVal StringIntMap imps);
  public native @Cast("bool") boolean is_main_graph();
  public native void set_is_main_graph(@Cast("bool") boolean is_main_graph);

  public native void set_schema_registry(@Const ISchemaRegistry schema_registry);

  public native @Const ISchemaRegistry get_schema_registry();

  public CheckerContext() { super((Pointer)null); allocate(); }
  private native void allocate();
}

@Namespace("onnx::checker") public static class LexicalScopeContext extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public LexicalScopeContext() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public LexicalScopeContext(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LexicalScopeContext(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public LexicalScopeContext position(long position) {
        return (LexicalScopeContext)super.position(position);
    }

  public native @ByRef UnorderedStringSet output_names(); public native LexicalScopeContext output_names(UnorderedStringSet output_names);
}
@Namespace("onnx::checker") public static native void check_value_info(@Const @ByRef ValueInfoProto value_info, @Const @ByRef CheckerContext arg1);
@Namespace("onnx::checker") public static native void check_tensor(@Const @ByRef TensorProto tensor, @Const @ByRef CheckerContext arg1);
@Namespace("onnx::checker") public static native void check_attribute(
    @Const @ByRef AttributeProto attr,
    @Const @ByRef CheckerContext arg1,
    @Const @ByRef LexicalScopeContext arg2);
@Namespace("onnx::checker") public static native void check_node(
    @Const @ByRef NodeProto node,
    @Const @ByRef CheckerContext arg1,
    @Const @ByRef LexicalScopeContext arg2);
@Namespace("onnx::checker") public static native void check_graph(
    @Const @ByRef GraphProto graph,
    @Const @ByRef CheckerContext arg1,
    @Const @ByRef LexicalScopeContext arg2);
@Namespace("onnx::checker") public static native void check_function(
    @Const @ByRef FunctionProto function,
    @Const @ByRef CheckerContext arg1,
    @Const @ByRef LexicalScopeContext arg2);

@Namespace("onnx::checker") public static native void check_model(@Const @ByRef ModelProto model);
 // namespace checker
 // namespace ONNX_NAMESPACE


// Parsed from onnx/shape_inference/implementation.h

// #pragma once

// #include "onnx/defs/schema.h"
// #include "onnx/proto_utils.h"
// #include "onnx/string_utils.h"

@Namespace("onnx::shape_inference") public static native void checkShapesAndTypes(
    @Const @ByRef TypeProto_Tensor inferredType,
    @Const @ByRef TypeProto_Tensor existingType);

@Namespace("onnx::shape_inference") public static native void mergeShapesAndTypes(
    @Const @ByRef TypeProto_Tensor inferredType,
    TypeProto_Tensor existingType);

@Namespace("onnx::shape_inference") public static native void InferShapes(
    @ByRef ModelProto m,
    @Const ISchemaRegistry schema_registry/*=onnx::OpSchemaRegistry::Instance()*/);
@Namespace("onnx::shape_inference") public static native void InferShapes(
    @ByRef ModelProto m);

 // namespace shape_inference
 // namespace ONNX_NAMESPACE


// Parsed from onnx/onnxifi.h

// #ifndef ONNXIFI_H
public static final int ONNXIFI_H = 1;

// #ifdef __cplusplus
// #endif

// #if defined(_WIN32) && defined(_M_IX86)
/* Windows x86 */
// #define ONNXIFI_ABI __stdcall
// #elif defined(__i386__)
/* Linux x86 */
// #define ONNXIFI_ABI __attribute__((__cdecl__))
// #else
// #define ONNXIFI_ABI
// #endif

// #ifndef ONNXIFI_PUBLIC
// #if defined(__ELF__)
// #define ONNXIFI_PUBLIC __attribute__((__visibility__("default")))
// #elif defined(__MACH__)
// #define ONNXIFI_PUBLIC __attribute__((__visibility__("default")))
// #elif defined(_WIN32) && defined(__GNUC__)
// #ifdef ONNXIFI_BUILD_LIBRARY
// #define ONNXIFI_PUBLIC __attribute__((__dllexport__))
// #else
// #define ONNXIFI_PUBLIC __attribute__((__dllimport__))
// #endif
// #elif defined(_WIN32)
// #ifdef ONNXIFI_BUILD_LIBRARY
// #define ONNXIFI_PUBLIC __declspec(dllexport)
// #else
// #define ONNXIFI_PUBLIC __declspec(dllimport)
// #endif
// #else
// #define ONNXIFI_PUBLIC
// #endif
// #endif

// #ifndef ONNXIFI_CHECK_RESULT
//   #if defined(__GNUC__) && (__GNUC__ >= 4)
//     #define ONNXIFI_CHECK_RESULT __attribute__((__warn_unused_result__))
//   #elif defined(_MSC_VER) && (_MSC_VER >= 1700)
//     #define ONNXIFI_CHECK_RESULT _Check_return_
//   #else
//     #define ONNXIFI_CHECK_RESULT
//   #endif
// #endif

// #include <stddef.h>

// #if !defined(ONNXIFI_NO_STDINT_H)
// #if defined(_MSC_VER) && (_MSC_VER < 1600)
// #else
// #include <stdint.h>
// #endif
// #endif /* !defined(ONNXIFI_NO_STDINT_H) */

/**
 * Opaque ONNXIFI backend ID.
 *
 * ONNXIFI backend is a combination of software layer and hardware device used
 * to run an ONNX graph. Backend ID uniquely identifies a backend for the life-
 * time of the process (i.e. no two hardware devices, software layers, or
 * combinations of both can have the same backend ID). Backend ID stays valid
 * even if the hardware device used by the backend disconnects from the system.
 */
@Namespace @Name("void") @Opaque public static class onnxBackendID extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public onnxBackendID() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public onnxBackendID(Pointer p) { super(p); }
}
/**
 * Opaque ONNXIFI backend handle.
 * ONNXIFI backend is a combination of software layer and hardware device used
 * to run an ONNX graph.
 */
@Namespace @Name("void") @Opaque public static class onnxBackend extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public onnxBackend() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public onnxBackend(Pointer p) { super(p); }
}
/** Opaque ONNXIFI graph handle. */
@Namespace @Name("void") @Opaque public static class onnxGraph extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public onnxGraph() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public onnxGraph(Pointer p) { super(p); }
}
/** Opaque ONNXIFI even handle. */
@Namespace @Name("void") @Opaque public static class onnxEvent extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public onnxEvent() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public onnxEvent(Pointer p) { super(p); }
}

/** Return code for ONNXIFI functions */
/**
 * Type for enumeration values.
 *
 * The low 32 bits are reserved for standardized ONNXIFI values.
 * The high 32 bits are reserved for vendor-specific extensions. Applications
 * must check for specific vendor extensions before interpreting these bits.
 */
/**
 * Type for bit fields.
 *
 * The low 32 bits are reserved for standardized ONNXIFI values.
 * The high 32 bits are reserved for vendor-specific extensions. Applications
 * must check for specific vendor extensions before interpreting these bits.
 */
/**
 * Type for pointers or handles for memory buffers.
 * This type is intended to work not only for CPU-addressable memory, but also
 * for device memory. uint64_t ensures the API can accomodate Vulkan buffers.
 */

public static final int ONNXIFI_STATUS_SUCCESS = 0x0000;
public static final int ONNXIFI_STATUS_FALLBACK = 0x0001;
public static final int ONNXIFI_STATUS_INVALID_ID = 0x0101;
public static final int ONNXIFI_STATUS_INVALID_SIZE = 0x0102;
public static final int ONNXIFI_STATUS_INVALID_POINTER = 0x0103;
public static final int ONNXIFI_STATUS_INVALID_PROTOBUF = 0x0104;
public static final int ONNXIFI_STATUS_INVALID_MODEL = 0x0105;
public static final int ONNXIFI_STATUS_INVALID_BACKEND = 0x0106;
public static final int ONNXIFI_STATUS_INVALID_GRAPH = 0x0107;
public static final int ONNXIFI_STATUS_INVALID_EVENT = 0x0108;
public static final int ONNXIFI_STATUS_INVALID_STATE = 0x0109;
public static final int ONNXIFI_STATUS_INVALID_NAME = 0x010A;
public static final int ONNXIFI_STATUS_INVALID_SHAPE = 0x010B;
public static final int ONNXIFI_STATUS_INVALID_DATATYPE = 0x010C;
public static final int ONNXIFI_STATUS_INVALID_MEMORY_TYPE = 0x010D;
public static final int ONNXIFI_STATUS_INVALID_MEMORY_LOCATION = 0x010E;
public static final int ONNXIFI_STATUS_INVALID_FENCE_TYPE = 0x010F;
public static final int ONNXIFI_STATUS_INVALID_PROPERTY = 0x0110;
public static final int ONNXIFI_STATUS_UNSUPPORTED_TAG = 0x0201;
public static final int ONNXIFI_STATUS_UNSUPPORTED_VERSION = 0x0202;
public static final int ONNXIFI_STATUS_UNSUPPORTED_OPERATOR = 0x0203;
public static final int ONNXIFI_STATUS_UNSUPPORTED_ATTRIBUTE = 0x0204;
public static final int ONNXIFI_STATUS_UNSUPPORTED_SHAPE = 0x0205;
public static final int ONNXIFI_STATUS_UNSUPPORTED_DATATYPE = 0x0206;
public static final int ONNXIFI_STATUS_UNSUPPORTED_MEMORY_TYPE = 0x0207;
public static final int ONNXIFI_STATUS_UNSUPPORTED_FENCE_TYPE = 0x0208;
public static final int ONNXIFI_STATUS_UNSUPPORTED_PROPERTY = 0x0209;
public static final int ONNXIFI_STATUS_UNIDENTIFIED_NAME = 0x0301;
public static final int ONNXIFI_STATUS_MISMATCHING_SHAPE = 0x0302;
public static final int ONNXIFI_STATUS_MISMATCHING_DATATYPE = 0x0303;
public static final int ONNXIFI_STATUS_NO_SYSTEM_MEMORY = 0x0401;
public static final int ONNXIFI_STATUS_NO_DEVICE_MEMORY = 0x0402;
public static final int ONNXIFI_STATUS_NO_SYSTEM_RESOURCES = 0x0403;
public static final int ONNXIFI_STATUS_NO_DEVICE_RESOURCES = 0x0404;
public static final int ONNXIFI_STATUS_BACKEND_UNAVAILABLE = 0x0405;
public static final int ONNXIFI_STATUS_INTERNAL_ERROR = 0x0406;

/**
 * State of an ONNXIFI event object.
 *
 * Possible values:
 *     ONNXIFI_EVENT_STATE_INVALID
 *     ONNXIFI_EVENT_STATE_NONSIGNALLED
 *     ONNXIFI_EVENT_STATE_SIGNALLED
 */

/**
 * State for an invalid onnxEvent.
 */
public static final int ONNXIFI_EVENT_STATE_INVALID = 0;
/**
 * Non-signalled onnxEvent state.
 * onnxInitEvent creates events in non-signalled state.
 */
public static final int ONNXIFI_EVENT_STATE_NONSIGNALLED = 0x16BD;
/**
 * Signalled onnxEvent state.
 * onnxSignalEvent changes event state to signalled.
 */
public static final int ONNXIFI_EVENT_STATE_SIGNALLED = 0x3395;

/** Special-purpose accelerator for neural network */
public static final int ONNXIFI_DEVICE_TYPE_NPU = 0x01;
/** Digital signal processor */
public static final int ONNXIFI_DEVICE_TYPE_DSP = 0x02;
/** Graphics accelerator */
public static final int ONNXIFI_DEVICE_TYPE_GPU = 0x04;
/** General-purpose central processor */
public static final int ONNXIFI_DEVICE_TYPE_CPU = 0x08;
/** Field-programmable gate array */
public static final int ONNXIFI_DEVICE_TYPE_FPGA = 0x10;
/**
 * Heterogeneous backend whichinternally arbitrates or distributes work between
 * multiple device types.
 */
public static final int ONNXIFI_DEVICE_TYPE_HETEROGENEOUS = 0x20;

/**
 * The backend supports multi-threaded access to ONNXIFI backend, graph, and
 * event objects. E.g. onnxInitGraph can be called on a different thread than
 * onnxInitBackend.
 *
 * If this capability it not indicated, ONNXIFI backend, graph, and event
 * objects that relate to the backend must always be used on the same thread
 * where the backend object was initialized.
 */
public static final int ONNXIFI_CAPABILITY_THREAD_SAFE = 0x01;
/**
 * The backend supports ONNX graphs with symbolic variables in the outer
 * shape dimension (batch size), using TensorShapeProto.dim_param for
 * ModelProto.graph.input.type.shape or ModelProto.graph.output.type.shape.
 *
 * The exact numerical value of the  of all input and output tensors must be specified
 * in the onnxSetGraphIO call(s).
 */
public static final int ONNXIFI_CAPABILITY_SYMBOLIC_BATCH_SIZE = 0x02;
/**
 * The backend supports ONNX graphs with symbolic variables in the all
 * shape dimensions, using TensorShapeProto.dim_param for
 * ModelProto.graph.input.type.shape or ModelProto.graph.output.type.shape.
 *
 * Backends with this capability also MUST support
 * ONNXIFI_CAPABILITY_SYMBOLIC_BATCH_SIZE capability.
 *
 * The exact numerical shape of all input and output tensors must be specified
 * in the onnxSetGraphIO call(s).
 */
public static final int ONNXIFI_CAPABILITY_SYMBOLIC_SIZE_TENSORS = 0x04;
/**
 * The backend supports ONNX graphs with data-dependent outer shape dimension
 * (batch size) of graph outputs. The ONNX graph would specify unknown outer
 * shape dimension (batch size) using symbolic variables, so this capability
 * requires ONNXIFI_CAPABILITY_SYMBOLIC_BATCH_SIZE support.
 *
 * For outputs with data-dependent outer shape dimension (batch size) the value
 * specified in onnxSetGraphIO call is interpreted as the upper limit. The exact
 * numerical batch size of the output can be retrieved by attaching a Shape
 * operator to the tensor with data-dependent shape and reading its output
 * through ONNXIFI.
 */
public static final int ONNXIFI_CAPABILITY_VARIABLE_BATCH_SIZE = 0x08;
/**
 * The backend supports ONNX graphs with data-dependent output shapes.
 * The ONNX graph would specify unknown output shapes using symbolic variables,
 * so this capability requires ONNXIFI_CAPABILITY_SYMBOLIC_SIZE_TENSORS support.
 *
 * Backends with this capability also MUST support
 * ONNXIFI_CAPABILITY_VARIABLE_BATCH_SIZE capability.
 *
 * For outputs with data-dependent shapes the shape specified in onnxSetGraphIO
 * call is interpreted as the upper limit. The exact numerical shape of the
 * output can be retrieved by attaching a Shape operator to the tensor with
 * data-dependent shape and reading its output through ONNXIFI.
 */
public static final int ONNXIFI_CAPABILITY_VARIABLE_SIZE_OUTPUTS = 0x10;
/**
 * The backend uses a hot-pluggable device, and can be disconnected at any time.
 *
 * If the underlying device disconnects from the system, subsequent operations
 * with the backend, or objects created on the backend, will fail with
 * ONNXIFI_STATUS_BACKEND_UNAVAILABLE status code.
 */
public static final int ONNXIFI_CAPABILITY_HOT_PLUGGABLE = 0x20;

/**
 * Type of the backend information.
 *
 * Possible values:
 *     ONNXIFI_BACKEND_ONNXIFI_VERSION
 *     ONNXIFI_BACKEND_NAME
 *     ONNXIFI_BACKEND_VENDOR
 *     ONNXIFI_BACKEND_VERSION
 *     ONNXIFI_BACKEND_EXTENSIONS
 *     ONNXIFI_BACKEND_DEVICE
 *     ONNXIFI_BACKEND_DEVICE_TYPE
 *     ONNXIFI_BACKEND_ONNX_IR_VERSION
 *     ONNXIFI_BACKEND_OPSET_VERSION
 *     ONNXIFI_BACKEND_CAPABILITIES
 *     ONNXIFI_BACKEND_INIT_PROPERTIES
 *     ONNXIFI_BACKEND_MEMORY_TYPES
 *     ONNXIFI_BACKEND_GRAPH_INIT_PROPERTIES
 *     ONNXIFI_BACKEND_SYNCHRONIZATION_TYPES
 *     ONNXIFI_BACKEND_MEMORY_SIZE
 *     ONNXIFI_BACKEND_MAX_GRAPH_SIZE
 *     ONNXIFI_BACKEND_MAX_GRAPH_COUNT
 *     ONNXIFI_BACKEND_MACS_FP32
 *     ONNXIFI_BACKEND_MACS_FP16
 *     ONNXIFI_BACKEND_MEMORY_BANDWIDTH
 *     ONNXIFI_BACKEND_CPU_MEMORY_READ_BANDWIDTH
 *     ONNXIFI_BACKEND_CPU_MEMORY_WRITE_BANDWIDTH
 *     ONNXIFI_BACKEND_PCI_BUS_ID
 *     ONNXIFI_BACKEND_PCI_DEVICE_ID
 *     ONNXIFI_BACKEND_PCI_DOMAIN_ID
 *     ONNXIFI_BACKEND_DIRECTX_ID
 *     ONNXIFI_BACKEND_CUDA_INDEX
 *     ONNXIFI_BACKEND_OPENCL_PLATFORM_ID
 *     ONNXIFI_BACKEND_OPENCL_DEVICE_ID
 */

/**
 * Major and minor version of ONNXIFI specification implemented by the backend.
 *
 * Since ONNXIFI 1.0, backends MUST support this information query.
 *
 * Value type: uint64_t.
 *      The high 32 bits specify the major version.
 *      The low 32 bits specify the minor version.
 *
 * Possible values:
 *      UINT64_C(0x0000000100000000) for ONNXIFI 1.0
 */
public static final int ONNXIFI_BACKEND_ONNXIFI_VERSION = 0;

/**
 * Marketing name of the backend (excluding the vendor name).
 *
 * Since ONNXIFI 1.0, backends MUST support this information query.
 *
 * This string MUST be in UTF-8 encoding and NOT locale-sensitive.
 *
 * Value type: char[], e.g.:
 *    "Caffe2"
 *    "Glow"
 */
public static final int ONNXIFI_BACKEND_NAME = 1;

/**
 * Name of the backend vendor.
 *
 * Since ONNXIFI 1.0, backends MUST support this information query.
 *
 * This string MUST be in UTF-8 encoding and NOT locale-sensitive.
 *
 * Value type: char[], e.g.:
 *    "Facebook"
 *    "Marat Dukhan"
 */
public static final int ONNXIFI_BACKEND_VENDOR = 2;

/**
 * Version of the backend software. Exact format is vendor-specific, but MUST be
 * unique for the software release.
 *
 * Since ONNXIFI 1.0, backends MUST support this information query.
 *
 * This string MUST be in US-ASCII encoding and NOT locale-sensitive.
 *
 * Value type: char[], e.g.:
 *    "1.2.3"
 *    "1.2.3.0"
 *    "1.2.3-db3a4439d233276e25681fb4735b7f8e674dda65"
 */
public static final int ONNXIFI_BACKEND_VERSION = 3;

/**
 * Space-separated list of vendor- or device-specific extensions supported on
 * this backend.
 *
 * Since ONNXIFI 1.0, backends MUST support this information query.
 *
 * This string MUST be in US-ASCII encoding and NOT locale-sensitive.
 *
 * Value type: char[], e.g.:
 *    ""
 *    "onnx_clone_graph"
 *    "onnx_clone_graph fb_maskrcnn"
 */
public static final int ONNXIFI_BACKEND_EXTENSIONS = 4;

/**
 * Descriptive name of the device (i.e. CPU, GPU, DSP, or NPU model).
 *
 * Since ONNXIFI 1.0, backends MUST support this information query.
 *
 * This string MUST be in UTF-8 encoding and NOT locale-sensitive.
 *
 * Value type: char[], e.g.:
 *    "nnDuino 123"
 */
public static final int ONNXIFI_BACKEND_DEVICE = 5;

/**
 * Type of the device.
 *
 * Since ONNXIFI 1.0, backends MUST support this information query.
 *
 * Value type: onnxEnum.
 * Possible values:
 *      ONNXIFI_DEVICE_TYPE_NPU
 *      ONNXIFI_DEVICE_TYPE_DSP
 *      ONNXIFI_DEVICE_TYPE_GPU
 *      ONNXIFI_DEVICE_TYPE_CPU
 *      ONNXIFI_DEVICE_TYPE_FPGA
 *      ONNXIFI_DEVICE_TYPE_HETEROGENEOUS
 */
public static final int ONNXIFI_BACKEND_DEVICE_TYPE = 6;

/**
 * List of supported ONNX IR versions.
 *
 * Since ONNXIFI 1.0, backends MUST support this information query.
 *
 * Value type: char[], e.g.:
 *    "3" (IR version in ONNX 1.0)
 *
 * Possible values: space-separated list of supported ONNX IR versions,
 *     represented as decimal integers. ONNX IR versions must match values
 *     in ONNX Version enum.
 */
public static final int ONNXIFI_BACKEND_ONNX_IR_VERSION = 7;

/**
 * List of supported operator set domains and maximum supported operator set
 * version for each domain.
 *
 * Since ONNXIFI 1.0, backends MUST support this information query.
 *
 * Value type: char[], e.g.:
 *    "ai.onnx:1" (only operators in version 1 of default ONNX operator set)
 *    "ai.onnx:7" (operators up to version 7 of default ONNX operator set)
 *    "org.pytorch:2 ai.onnx:6 ai.facebook:1"
 *
 * Possible values: space-separated list of domain:max_version pairs where
 *     domain corresponds to OperatorSetIdProto.domain and max_version
 *     corresponds to the maximum value of OperatorSetIdProto.version supported
 *     by the backend for this domain. The backend MUST support all previous
 *     operator set versions as well.
 */
public static final int ONNXIFI_BACKEND_OPSET_VERSION = 8;

/**
 * Optional features supported by the backend.
 *
 * Since ONNXIFI 1.0, backends MUST support this information query.
 *
 * Value type: onnxBitfield.
 * Possible values: any combination of the following flags:
 *      ONNXIFI_CAPABILITY_THREAD_SAFE
 *      ONNXIFI_CAPABILITY_SYMBOLIC_BATCH_SIZE
 *      ONNXIFI_CAPABILITY_SYMBOLIC_SIZE_TENSORS
 *      ONNXIFI_CAPABILITY_VARIABLE_BATCH_SIZE
 *      ONNXIFI_CAPABILITY_VARIABLE_SIZE_OUTPUTS
 *      ONNXIFI_CAPABILITY_HOT_PLUGGABLE
 *      or any vendor-specific flags in the high 32 bits of the bit field.
 */
public static final int ONNXIFI_BACKEND_CAPABILITIES = 10;

/**
 * Auxiliary initialization properties supported by the backend.
 *
 * Since ONNXIFI 1.0, backends MUST support this information query.
 *
 * Value type: onnxBitfield.
 * Possible values: any combination of vendor-specific flags in high 32 bits of
 * the bit field.
 */
public static final int ONNXIFI_BACKEND_INIT_PROPERTIES = 11;

/**
 * Memory types supported for graph inputs and outputs.
 *
 * Since ONNXIFI 1.0, backends MUST support this information query.
 *
 * Value type: onnxBitfield.
 * Possible values are any combination of the following flags:
 *     ONNXIFI_MEMORY_TYPE_CPU (always supported)
 *     ONNXIFI_MEMORY_TYPE_CUDA_BUFFER
 *     ONNXIFI_MEMORY_TYPE_OPENCL_BUFFER
 *     ONNXIFI_MEMORY_TYPE_OPENGLES_TEXTURE_2D
 *     ONNXIFI_MEMORY_TYPE_D3D_RESOURCE
 *     or any vendor-specific flags in the high 32 bits of the bit field.
 */
public static final int ONNXIFI_BACKEND_MEMORY_TYPES = 12;

/**
 * Auxiliary initialization properties supported by graphs on the backend.
 *
 * Since ONNXIFI 1.0, backends MUST support this information query.
 *
 * Value type: onnxBitfield.
 * Possible values: any combination of vendor-specific flags in high 32 bits of
 * the bit field.
 */
public static final int ONNXIFI_BACKEND_GRAPH_INIT_PROPERTIES = 13;

/**
 * Memory synchronization primitives supported for graph inputs and outputs.
 *
 * Since ONNXIFI 1.0, backends MUST support this information query.
 *
 * Possible values are any combination of the following flags:
 *     ONNXIFI_SYNCHRONIZATION_EVENT    (onnxEvent, always supported)
 *     ONNXIFI_SYNCHRONIZATION_IMPLICIT
 *     or any vendor-specific flags in the high 32 bits of the bit field.
 */
public static final int ONNXIFI_BACKEND_SYNCHRONIZATION_TYPES = 14;

/**
 * Maximum amount of memory, in bytes, available to the use by the backend.
 *
 * Since ONNXIFI 1.0, backends MUST support this information query.
 *
 * Value type: uint64_t.
 */
public static final int ONNXIFI_BACKEND_MEMORY_SIZE = 20;

/**
 * Maximum size of network parameters, in bytes.
 *
 * Since ONNXIFI 1.0, backends MUST support this information query.
 *
 * Value type: uint64_t.
 */
public static final int ONNXIFI_BACKEND_MAX_GRAPH_SIZE = 21;

/**
 * Maximum number of independent network graphs supported by the backend.
 *
 * Since ONNXIFI 1.0, backends MUST support this information query.
 *
 * Value type: uint64_t.
 */
public static final int ONNXIFI_BACKEND_MAX_GRAPH_COUNT = 22;

/**
 * Number of FP32 multiply-accumulate operations per second delivered by the
 * backend.
 *
 * Since ONNXIFI 1.0, backends are recommended, but not required to support this
 * information query.
 *
 * Value type: uint64_t.
 * If the backend does not support FP32 computation, the value MUST be 0.
 */
public static final int ONNXIFI_BACKEND_MACS_FP32 = 30;

/**
 * Number of FP16 multiply-accumulate operations per second delivered by the
 * backend.
 *
 * Since ONNXIFI 1.0, backends are recommended, but not required to support this
 * information query.
 *
 * Value type: uint64_t.
 * If the backend does not support FP16 computation, the value MUST be 0.
 */
public static final int ONNXIFI_BACKEND_MACS_FP16 = 31;

/**
 * Bandwidth, in bytes per second, of the global memory specific to the backend
 * device.
 *
 * Since ONNXIFI 1.0, backends are recommended, but not required to support this
 * information query.
 *
 * Value type: uint64_t.
 */
public static final int ONNXIFI_BACKEND_MEMORY_BANDWIDTH = 35;

/**
 * Bandwidth, in bytes per second, of transferring data from cacheable
 * CPU-allocated memory to the backend device.
 *
 * Since ONNXIFI 1.0, backends are recommended, but not required to support this
 * information query.
 *
 * Value type: uint64_t.
 */
public static final int ONNXIFI_BACKEND_CPU_MEMORY_READ_BANDWIDTH = 36;

/**
 * Bandwidth, in bytes per second, of transferring data to cacheable
 * CPU-allocated memory from the backend device.
 *
 * Since ONNXIFI 1.0, backends are recommended, but not required to support this
 * information query.
 *
 * Value type: uint64_t.
 */
public static final int ONNXIFI_BACKEND_CPU_MEMORY_WRITE_BANDWIDTH = 37;

/**
 * PCI bus ID of the backend device.
 *
 * Since ONNXIFI 1.0, backends are recommended, but not required to support this
 * information query.
 *
 * Value type: uint64_t.
 */
public static final int ONNXIFI_BACKEND_PCI_BUS_ID = 40;

/**
 * PCI device ID of the backend device.
 *
 * Since ONNXIFI 1.0, backends are recommended, but not required to support this
 * information query.
 *
 * Value type: uint64_t.
 */
public static final int ONNXIFI_BACKEND_PCI_DEVICE_ID = 41;

/**
 * PCI domain/function ID of the backend device.
 *
 * Since ONNXIFI 1.0, backends are recommended, but not required to support this
 * information query.
 *
 * Value type: uint64_t.
 */
public static final int ONNXIFI_BACKEND_PCI_DOMAIN_ID = 42;

/**
 * DirectX ID of the backend device.
 *
 * This is the value that would be returned by ID3D12Device::GetAdapterLuid()
 * for the hardware device used by the backend.
 *
 * Since ONNXIFI 1.0, DXGI-based backends are recommended, but not required to
 * support this information query.
 *
 * Value type: LUID (8 bytes).
 */
public static final int ONNXIFI_BACKEND_DIRECTX_ID = 43;

/**
 * CUDA index of the backend device.
 *
 * Since ONNXIFI 1.0, CUDA-based backends are recommended, but not required to
 * support this information query.
 *
 * Value type: uint64_t.
 */
public static final int ONNXIFI_BACKEND_CUDA_INDEX = 44;

/**
 * OpenCL platform ID for the backend device.
 * This platform ID is guaranteed to remain valid for the lifetime of ONNXIFI
 * objects related to the same ONNXIFI backend (backend ID, backend, graph,
 * event).
 *
 * Since ONNXIFI 1.0, OpenCL-based backends are recommended, but not required to
 * support this information query.
 *
 * Value type: cl_platform_id.
 */
public static final int ONNXIFI_BACKEND_OPENCL_PLATFORM_ID = 45;

/**
 * OpenCL device ID for the backend device.
 * This device ID is guaranteed to remain valid for the lifetime of ONNXIFI
 * objects related to the same ONNXIFI backend (backend ID, backend, graph,
 * event).
 *
 * Since ONNXIFI 1.0, OpenCL-based backends are recommended, but not required to
 * support this information query.
 *
 * Value type: cl_device_id.
 */
public static final int ONNXIFI_BACKEND_OPENCL_DEVICE_ID = 46;

/* Note: the data type values match ONNX TensorProto.DataType enum */
public static final int ONNXIFI_DATATYPE_UNDEFINED = 0;
public static final int ONNXIFI_DATATYPE_FLOAT16 = 10;
public static final int ONNXIFI_DATATYPE_FLOAT32 = 1;
public static final int ONNXIFI_DATATYPE_FLOAT64 = 11;
public static final int ONNXIFI_DATATYPE_INT8 = 3;
public static final int ONNXIFI_DATATYPE_INT16 = 5;
public static final int ONNXIFI_DATATYPE_INT32 = 6;
public static final int ONNXIFI_DATATYPE_INT64 = 7;
public static final int ONNXIFI_DATATYPE_UINT8 = 2;
public static final int ONNXIFI_DATATYPE_UINT16 = 4;
public static final int ONNXIFI_DATATYPE_UINT32 = 12;
public static final int ONNXIFI_DATATYPE_UINT64 = 13;
public static final int ONNXIFI_DATATYPE_COMPLEX64 = 14;
public static final int ONNXIFI_DATATYPE_COMPLEX128 = 15;

/** Cacheable CPU memory */
public static final int ONNXIFI_MEMORY_TYPE_CPU = 0;
/** CUDA memory buffer (allocated via cudaMalloc/cuMalloc).  */
public static final int ONNXIFI_MEMORY_TYPE_CUDA_BUFFER = 1;
/** OpenCL cl_mem object for a buffer or sub-buffer. */
public static final int ONNXIFI_MEMORY_TYPE_OPENCL_BUFFER = 2;
/** OpenGL ES 2.0+ 2D Texture. */
public static final int ONNXIFI_MEMORY_TYPE_OPENGLES_TEXTURE_2D = 4;
/** Direct3D resource. */
public static final int ONNXIFI_MEMORY_TYPE_D3D_RESOURCE = 8;

/**
 * Terminates the list of auxiliary backend initialization properties passed to
 * onnxInitBackend.
 */
public static final int ONNXIFI_BACKEND_PROPERTY_NONE = 0;
/**
 * Optimization target for graphs initialized on the backend.
 *
 * Possible values:
 *     ONNXIFI_OPTIMIZATION_HIGH_THROUGHPUT
 *     ONNXIFI_OPTIMIZATION_LOW_LATENCY
 *     ONNXIFI_OPTIMIZATION_LOW_POWER
 *     ONNXIFI_OPTIMIZATION_LOW_DELAY
 */
public static final int ONNXIFI_BACKEND_PROPERTY_OPTIMIZATION = 1;
/**
 * Logging verbosity level for the backend.
 *
 * If this property is not specified during initialization, the backend should
 * assume ONNXIFI_LOG_LEVEL_WARNING logging verbosity level.
 *
 * Possible values:
 *     ONNXIFI_LOG_LEVEL_ERROR
 *     ONNXIFI_LOG_LEVEL_WARNING
 *     ONNXIFI_LOG_LEVEL_INFO
 *     ONNXIFI_LOG_LEVEL_DEBUG
 */
public static final int ONNXIFI_BACKEND_PROPERTY_LOG_LEVEL = 2;
/**
 * CUDA stream to be used by the backend.
 * CUDA stream must be created on the CUDA device used by the ONNXIFI backend.
 * Users can query which CUDA device is used by the ONNXIFI backend by calling
 * onnxGetBackendInfo with ONNXIFI_BACKEND_CUDA_INDEX info type.
 *
 * If this property is not specified during initialization, the backend can
 * create a new CUDA stream for the device, or use a default CUDA stream.
 *
 * Possible values: cudaStream_t or CUstream object, cast to uint64_t.
 */
public static final int ONNXIFI_BACKEND_CUDA_STREAM = 4;
/**
 * OpenCL context to be used by the backend.
 * The context must be created with the OpenCL device ID and the OpenCL platform
 * ID used by the ONNXIFI backend. Users can query which OpenCL device ID and
 * OpenCL platform ID are used by the ONNXIFI backend by calling
 * onnxGetBackendInfo with ONNXIFI_BACKEND_OPENCL_PLATFORM_ID
 * and ONNXIFI_BACKEND_OPENCL_DEVICE_ID info types.
 *
 * If this property is not specified during initialization, the backend will
 * create a new OpenCL context for the device.
 *
 * Possible values: cl_context object, cast to uint64_t.
 */
public static final int ONNXIFI_BACKEND_OPENCL_CONTEXT = 8;

/**
 * Terminates the list of auxiliary graph initialization properties passed to
 * onnxInitGraph.
 */
public static final int ONNXIFI_GRAPH_PROPERTY_NONE = 0;

/**
 * Optimize graph representation and compilation for highest throughput.
 */
public static final int ONNXIFI_OPTIMIZATION_HIGH_THROUGHPUT = 0;

/**
 * Optimize graph representation and compilation for lowest latency.
 */
public static final int ONNXIFI_OPTIMIZATION_LOW_LATENCY = 1;

/**
 * Optimize graph representation and compilation for lowest power consumption.
 */
public static final int ONNXIFI_OPTIMIZATION_LOW_POWER = 2;

/**
 * Optimize graph representation and compilation for lowest delay until first
 * result.
 */
public static final int ONNXIFI_OPTIMIZATION_LOW_DELAY = 3;

/**
 * Log events which caused a failure in an ONNXIFI function call.
 */
public static final int ONNXIFI_LOG_LEVEL_ERROR = 4;

/**
 * Log events in ONNXIFI_LOG_LEVEL_ERROR and events which caused
 * a performance, accuracy, or quality of service degradation in a backend.
 * Enabling this logging level SHOULD NOT have a measurable effect on
 * performance.
 */
public static final int ONNXIFI_LOG_LEVEL_WARNING = 3;

/**
 * Log events in ONNXIFI_LOG_LEVEL_WARNING and high-level status information
 * about operation of a backend. Enabling this logging level MAY cause a small
 * degradation in performance.
 */
public static final int ONNXIFI_LOG_LEVEL_INFO = 2;

/**
 * Log events in ONNXIFI_LOG_LEVEL_INFO and detailed status information about
 * operations of a backend. Enabling this logging level MAY cause a serious
 * degradation in performance.
 */
public static final int ONNXIFI_LOG_LEVEL_DEBUG = 1;

/**
 * Tag for version 1 of tensor descriptor structure (onnxTensorDescriptorV1).
 *
 * The tag is unique for this version. If ONNXIFI introduce a new version of
 * the tensor descriptor structure in the future, it will get a new tag value.
 */
public static final int ONNXIFI_TAG_TENSOR_DESCRIPTOR_V1 = 0x43DFBF69;

public static class onnxTensorDescriptorV1 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public onnxTensorDescriptorV1() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public onnxTensorDescriptorV1(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public onnxTensorDescriptorV1(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public onnxTensorDescriptorV1 position(long position) {
        return (onnxTensorDescriptorV1)super.position(position);
    }

  /**
   * 32-bit tag needed to distinguish different versions of a tensor descriptor
   * structure. In the onnxTensorDescriptorV1 structure, the tag MUST be set to
   * ONNXIFI_TAG_TENSOR_DESCRIPTOR_V1. If ONNXIFI introduce a new version of the
   * tensor descriptor structure in the future, it WILL have 32-bit tag with a
   * different value as the first member of the structure.
   *
   * ONNXIFI implementations MUST validate tag before accessing any other
   * members of the structure.
   */
  public native @Cast("int32_t") int tag(); public native onnxTensorDescriptorV1 tag(int tag);
  /**
   * Name of the blob corresponding to this tensor in the ONNX model. The name
   * must exactly match the ValueInfoProto.name of one of the
   * ModelProto.graph.input or ModelProto.graph.output
   */
  @MemberGetter public native @Cast("const char*") BytePointer name();
  /**
   * Data type of the elements in the tensor.
   *
   * Possible values:
   *     ONNXIFI_DATATYPE_FLOAT16
   *     ONNXIFI_DATATYPE_FLOAT32
   *     ONNXIFI_DATATYPE_FLOAT64
   *     ONNXIFI_DATATYPE_INT8
   *     ONNXIFI_DATATYPE_INT16
   *     ONNXIFI_DATATYPE_INT32
   *     ONNXIFI_DATATYPE_INT64
   *     ONNXIFI_DATATYPE_UINT8
   *     ONNXIFI_DATATYPE_UINT16
   *     ONNXIFI_DATATYPE_UINT32
   *     ONNXIFI_DATATYPE_UINT64
   *     ONNXIFI_DATATYPE_COMPLEX64
   *     ONNXIFI_DATATYPE_COMPLEX128
   */
  public native @Cast("onnxEnum") int dataType(); public native onnxTensorDescriptorV1 dataType(int dataType);
  /**
   * Type of memory that stores the tensor.
   *
   * ONNXIFI_MEMORY_TYPE_CPU memory type is always supported by the backend, but
   * other memory types are optional. The use MUST call onnxGetBackendInfo with
   * ONNXIFI_BACKEND_MEMORY_TYPES to check if a particular memory type is
   * supported before using it.
   *
   * If the memory type is different than ONNXIFI_MEMORY_TYPE_CPU, it must be
   * allocated on the same device as the backend.
   *
   * Possible values:
   *     ONNXIFI_MEMORY_TYPE_CPU                 (always supported)
   *     ONNXIFI_MEMORY_TYPE_CUDA_BUFFER         (support is optional)
   *     ONNXIFI_MEMORY_TYPE_OPENCL_BUFFER       (support is optional)
   *     ONNXIFI_MEMORY_TYPE_OPENGLES_TEXTURE_2D (support is optional)
   *     ONNXIFI_MEMORY_TYPE_D3D_RESOURCE        (support is optional)
   */
  public native @Cast("onnxEnum") int memoryType(); public native onnxTensorDescriptorV1 memoryType(int memoryType);
  /**
   * Number of dimensions in the tensor.
   * For a scalar, the number of dimensions is 0.
   */
  public native @Cast("uint32_t") int dimensions(); public native onnxTensorDescriptorV1 dimensions(int dimensions);
  /**
   * Dimensions of the tensor.
   * For a scalar, this pointer can be NULL.
   */
  @MemberGetter public native @Cast("const uint64_t*") IntPointer shape();
  /**
   * Pointers to tensor data.
   *
   * Interpretation depends on memoryType:
   *   - ONNXIFI_MEMORY_TYPE_CPU: buffer is a valid pointer to CPU memory.
   *   - ONNXIFI_MEMORY_TYPE_CUDA_BUFFER: buffer is a valid pointer to CUDA
   *     device memory, allocated via cudaMalloc or cuMalloc. CUDA device memory
   *     must be allocated on the same device as the backend.
   *   - ONNXIFI_MEMORY_TYPE_OPENCL_BUFFER: buffer is a cl_mem handle for an
   *     OpenCL buffer or a sub-buffer. cl_mem object must be allocated on the
   *     same OpenCL context as the backend. The context must be specified via
   *     ONNXIFI_BACKEND_OPENCL_CONTEXT initialization property to
   *     onnxInitBackend.
   *   - ONNXIFI_MEMORY_TYPE_OPENGLES_TEXTURE_2D: buffer is a name of a 2D
   *     texture created by glGenTextures. The texture must be allocated on the
   *     same device as the backend.
   *   - ONNXIFI_MEMORY_TYPE_D3D_RESOURCE: TBD
   */
  public native @Cast("onnxPointer") int buffer(); public native onnxTensorDescriptorV1 buffer(int buffer);
}

/**
 * Synchronization using ONNXIFI event object (onnxEvent).
 */
public static final int ONNXIFI_SYNCHRONIZATION_EVENT = 0;
/**
 * Implicit synchronization of inputs and outputs access with the caller.
 * The details are backend-specific, and may involve extra parameters passed
 * during backend initialization.
 *
 * Examples:
 *  - CUDA-based backends could implicitly synchronize with the caller through
 *    the use of the same CUDA stream.
 *  - OpenCL-based backends could implicitly synchronize with the caller through
 *    the use of the same in-order OpenCL command queue.
 */
public static final int ONNXIFI_SYNCHRONIZATION_IMPLICIT = 2;

/**
 * Tag for version 1 of memory fence structure (onnxMemoryFenceV1).
 *
 * The tag is unique for this version. If ONNXIFI introduce a new version of
 * the memory fence structure in the future, it will get a new tag value.
 */
public static final int ONNXIFI_TAG_MEMORY_FENCE_V1 = 0x23E08AAB;

public static class onnxMemoryFenceV1 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public onnxMemoryFenceV1() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public onnxMemoryFenceV1(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public onnxMemoryFenceV1(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public onnxMemoryFenceV1 position(long position) {
        return (onnxMemoryFenceV1)super.position(position);
    }

  /**
   * 32-bit tag needed to distinguish different versions of a memory fence
   * structure. In the onnxMemoryFenceV1 structure, the tag MUST be set to
   * ONNXIFI_TAG_MEMORY_FENCE_V1. If ONNXIFI introduce a new version of the
   * memory fence structure in the future, it WILL have 32-bit tag with a
   * different value as the first member of the structure.
   *
   * ONNXIFI implementations MUST validate tag before accessing any other
   * members of the structure.
   */
  public native @Cast("int32_t") int tag(); public native onnxMemoryFenceV1 tag(int tag);
  /**
   * Type of memory synchronization primitive.
   *
   * Possible values:
   *      ONNXIFI_SYNCHRONIZATION_EVENT    (onnxEvent, always supported)
   *      ONNXIFI_SYNCHRONIZATION_IMPLICIT
   */
  public native @Cast("onnxEnum") int type(); public native onnxMemoryFenceV1 type(int type);
    /**
     * Handle for a single-shot ONNXIFI event used as a synchronization
     * primitive. Event for the input fence must be created by the caller to
     * onnxRunGraph. Event for the output fence is created by implementation of
     * onnxRunGraph, and stored into the output memory fence structure before
     * onnxRunGraph returns.
     */
    public native onnxEvent event(); public native onnxMemoryFenceV1 event(onnxEvent event);
}

/* Function pointer declarations for dynamic loading */
public static class onnxGetBackendIDsFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    onnxGetBackendIDsFunction(Pointer p) { super(p); }
    protected onnxGetBackendIDsFunction() { allocate(); }
    private native void allocate();
    public native @Cast("onnxStatus") int call(
    @ByPtrPtr onnxBackendID backendIDs,
    @Cast("size_t*") SizeTPointer numBackends);
}
public static class onnxReleaseBackendIDFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    onnxReleaseBackendIDFunction(Pointer p) { super(p); }
    protected onnxReleaseBackendIDFunction() { allocate(); }
    private native void allocate();
    public native @Cast("onnxStatus") int call(
    onnxBackendID backendID);
}
public static class onnxGetBackendInfoFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    onnxGetBackendInfoFunction(Pointer p) { super(p); }
    protected onnxGetBackendInfoFunction() { allocate(); }
    private native void allocate();
    public native @Cast("onnxStatus") int call(
    onnxBackendID backendID,
    @Cast("onnxBackendInfo") int infoType,
    Pointer infoValue,
    @Cast("size_t*") SizeTPointer infoValueSize);
}
public static class onnxGetBackendCompatibilityFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    onnxGetBackendCompatibilityFunction(Pointer p) { super(p); }
    protected onnxGetBackendCompatibilityFunction() { allocate(); }
    private native void allocate();
    public native @Cast("onnxStatus") int call(
    onnxBackendID backendID,
    @Cast("size_t") long onnxModelSize,
    @Const Pointer onnxModel);
}
public static class onnxInitBackendFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    onnxInitBackendFunction(Pointer p) { super(p); }
    protected onnxInitBackendFunction() { allocate(); }
    private native void allocate();
    public native @Cast("onnxStatus") int call(
    onnxBackendID backendID,
    @Cast("const uint64_t*") IntPointer auxPropertiesList,
    @ByPtrPtr onnxBackend backend);
}
public static class onnxReleaseBackendFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    onnxReleaseBackendFunction(Pointer p) { super(p); }
    protected onnxReleaseBackendFunction() { allocate(); }
    private native void allocate();
    public native @Cast("onnxStatus") int call(
    onnxBackend backend);
}
public static class onnxInitEventFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    onnxInitEventFunction(Pointer p) { super(p); }
    protected onnxInitEventFunction() { allocate(); }
    private native void allocate();
    public native @Cast("onnxStatus") int call(
    onnxBackend backend,
    @ByPtrPtr onnxEvent event);
}
public static class onnxSignalEventFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    onnxSignalEventFunction(Pointer p) { super(p); }
    protected onnxSignalEventFunction() { allocate(); }
    private native void allocate();
    public native @Cast("onnxStatus") int call(
    onnxEvent event);
}
public static class onnxGetEventStateFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    onnxGetEventStateFunction(Pointer p) { super(p); }
    protected onnxGetEventStateFunction() { allocate(); }
    private native void allocate();
    public native @Cast("onnxStatus") int call(
    onnxEvent event,
    @Cast("onnxEventState*") IntPointer state);
}
public static class onnxWaitEventFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    onnxWaitEventFunction(Pointer p) { super(p); }
    protected onnxWaitEventFunction() { allocate(); }
    private native void allocate();
    public native @Cast("onnxStatus") int call(
    onnxEvent event);
}
public static class onnxReleaseEventFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    onnxReleaseEventFunction(Pointer p) { super(p); }
    protected onnxReleaseEventFunction() { allocate(); }
    private native void allocate();
    public native @Cast("onnxStatus") int call(
    onnxEvent event);
}
public static class onnxInitGraphFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    onnxInitGraphFunction(Pointer p) { super(p); }
    protected onnxInitGraphFunction() { allocate(); }
    private native void allocate();
    public native @Cast("onnxStatus") int call(
    onnxBackend backend,
    @Cast("const uint64_t*") IntPointer auxPropertiesList,
    @Cast("size_t") long onnxModelSize,
    @Const Pointer onnxModel,
    @Cast("uint32_t") int weightsCount,
    @Const onnxTensorDescriptorV1 weightDescriptors,
    @ByPtrPtr onnxGraph graph);
}
public static class onnxSetGraphIOFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    onnxSetGraphIOFunction(Pointer p) { super(p); }
    protected onnxSetGraphIOFunction() { allocate(); }
    private native void allocate();
    public native @Cast("onnxStatus") int call(
    onnxGraph graph,
    @Cast("uint32_t") int inputsCount,
    @Const onnxTensorDescriptorV1 inputDescriptors,
    @Cast("uint32_t") int outputsCount,
    @Const onnxTensorDescriptorV1 outputDescriptors);
}
public static class onnxRunGraphFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    onnxRunGraphFunction(Pointer p) { super(p); }
    protected onnxRunGraphFunction() { allocate(); }
    private native void allocate();
    public native @Cast("onnxStatus") int call(
    onnxGraph graph,
    @Const onnxMemoryFenceV1 inputFence,
    onnxMemoryFenceV1 outputFence);
}
public static class onnxReleaseGraphFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    onnxReleaseGraphFunction(Pointer p) { super(p); }
    protected onnxReleaseGraphFunction() { allocate(); }
    private native void allocate();
    public native @Cast("onnxStatus") int call(
    onnxGraph graph);
}

/**
 * Get stable IDs of available backends on the system.
 *
 * ONNXIFI backend is a combination of software layer and hardware device used
 * to run an ONNX graph. The same software layer may expose multiple backends
 * (e.g. one ONNXIFI backend for each GPU in the system, or one ONNXIFI backend
 * for GPU and another for CPU, both implemented in the same software). Backends
 * implemented in the same software, but targeting different devices (e.g.
 * "MyNN" for CPU and "MyNN" for GPU) have different backend IDs.
 *
 * Note that some (hot-pluggable) backends can be connected and disconnected at
 * any time, and thus subsequent calls to this function may return different
 * number or set of backend IDs. The returned IDs, however, stay valid even if
 * the hardware device used by the backend disconnects from the system.
 *
 * To avoid resource leak, the backend ID MUST be released through a call to
 * onnxReleaseBackendID when it is no longer needed.
 *
 * @param backendIDs[out] - pointer to the memory location where the backend IDs
 *                          will be returned. If the pointer is NULL, it is
 *                          ignored, and the function returns only the number
 *                          of backend IDs through numBackendIDs pointer.
 * @param numBackendIDs[in,out] - pointer to a variable specifying number of
 *                                available backends. On function entry, the
 *                                variable MUST contain the capacity, in number
 *                                of backend IDs, of the memory buffer specified
 *                                by backendIDs. For successful completion, this
 *                                capacity must be at least as large as the
 *                                number of available backends. If the function
 *                                completes with either ONNXIFI_STATUS_SUCCESS
 *                                or ONNXIFI_STATUS_FALLBACK status codes, the
 *                                number of backend IDs written into backendIDs
 *                                buffer is stored in the variable specified by
 *                                this pointer.
 *
 * \retval ONNXIFI_STATUS_SUCCESS The function call succeeded, and backend IDs
 *                                are stored in the location specified by
 *                                backendIDs, and the number of the backends
 *                                is stored in the location specified by
 *                                numBackends.
 * \retval ONNXIFI_STATUS_FALLBACK The function call completed, but the
 *                                 backend IDs were not stored in the
 *                                 location specified by backendIDs, either
 *                                 because it is NULL, or because the size of
 *                                 the memory buffer is insufficient to store
 *                                 all available backend IDs. The number of
 *                                 available backends is stored in the
 *                                 location specified by numBackends.
 * \retval ONNXIFI_STATUS_INVALID_POINTER The function call failed because
 *                                        numBackends is NULL.
 * \retval ONNXIFI_STATUS_NO_SYSTEM_MEMORY The function call failed because the
 *                                         system failed to allocate memory
 *                                         to store backend ID information.
 * \retval ONNXIFI_STATUS_INTERNAL_ERROR The function call failed because the
 *                                       implementation experienced an
 *                                       unrecovered internal error.
 */
public static native @Cast("onnxStatus") int onnxGetBackendIDs(
    @ByPtrPtr onnxBackendID backendIDs,
    @Cast("size_t*") SizeTPointer numBackends);

/**
 * Deinitialize ONNXIFI backend IDs and release associated resources.
 *
 * The user MUST deinitialize all objects created with this backend ID
 * (onnxBackend, onnxGraph, onnxEvent) before calling this function to
 * deinitialize the backend ID.
 *
 * @param backendID - backend ID returned by onnxGetBackendIDs.
 *
 * \retval ONNXIFI_STATUS_SUCCESS The function call succeeded and the resources
 *                                associated to the backend ID were released to
 *                                the operating system.
 * \retval ONNXIFI_STATUS_INVALID_ID The function call failed because backendID
 *                                   is not an ONNXIFI backend ID.
 * \retval ONNXIFI_STATUS_INTERNAL_ERROR The function call failed because the
 *                                       implementation experienced an
 *                                       unrecovered internal error.
 */
public static native @Cast("onnxStatus") int onnxReleaseBackendID(
    onnxBackendID backendID);

/**
 * Query high-level information about the backend and its target device.
 *
 * ONNXIFI backend is a combination of software layer and hardware device used
 * to run an ONNX graph. The same software layer may expose multiple backends
 * (e.g. one ONNXIFI backend for each GPU in the system, or one ONNXIFI backend
 * for GPU and another for CPU, both implemented in the same software).
 *
 * The content, data type, and availability of information provided by this
 * function depends on infoType value as specified below:
 *
 *         infoType value                           data type      support
 *     ONNXIFI_BACKEND_ONNXIFI_VERSION               uint64_t     required
 *     ONNXIFI_BACKEND_NAME                           char[]      required
 *     ONNXIFI_BACKEND_VENDOR                         char[]      required
 *     ONNXIFI_BACKEND_VERSION                        char[]      required
 *     ONNXIFI_BACKEND_EXTENSIONS                     char[]      required
 *     ONNXIFI_BACKEND_DEVICE                         char[]      required
 *     ONNXIFI_BACKEND_DEVICE_TYPE                   onnxEnum     required
 *     ONNXIFI_BACKEND_ONNX_IR_VERSION                char[]      required
 *     ONNXIFI_BACKEND_OPSET_VERSION                  char[]      required
 *     ONNXIFI_BACKEND_CAPABILITIES                onnxBitfield   required
 *     ONNXIFI_BACKEND_INIT_PROPERTIES             onnxBitfield   required
 *     ONNXIFI_BACKEND_MEMORY_TYPES                onnxBitfield   required
 *     ONNXIFI_BACKEND_GRAPH_INIT_PROPERTIES       onnxBitfield   required
 *     ONNXIFI_BACKEND_SYNCHRONIZATION_TYPES       onnxBitfield   required
 *     ONNXIFI_BACKEND_MEMORY_SIZE                   uint64_t     required
 *     ONNXIFI_BACKEND_MAX_GRAPH_SIZE                uint64_t     required
 *     ONNXIFI_BACKEND_MAX_GRAPH_COUNT               uint64_t     required
 *     ONNXIFI_BACKEND_MACS_FP32                     uint64_t     optional
 *     ONNXIFI_BACKEND_MACS_FP16                     uint64_t     optional
 *     ONNXIFI_BACKEND_MEMORY_BANDWIDTH              uint64_t     optional
 *     ONNXIFI_BACKEND_CPU_MEMORY_READ_BANDWIDTH     uint64_t     optional
 *     ONNXIFI_BACKEND_CPU_MEMORY_WRITE_BANDWIDTH    uint64_t     optional
 *     ONNXIFI_BACKEND_PCI_BUS_ID                    uint64_t     optional
 *     ONNXIFI_BACKEND_PCI_DEVICE_ID                 uint64_t     optional
 *     ONNXIFI_BACKEND_PCI_DOMAIN_ID                 uint64_t     optional
 *     ONNXIFI_BACKEND_DIRECTX_ID                      LUID       optional
 *     ONNXIFI_BACKEND_CUDA_INDEX                    uint64_t     optional
 *     ONNXIFI_BACKEND_OPENCL_PLATFORM_ID         cl_platform_id  optional
 *     ONNXIFI_BACKEND_OPENCL_DEVICE_ID            cl_device_id   optional
 *
 * @param backendID - ID of the backend to query.
 * @param infoType - type of the backend information to query. Must be one of
 *                   the ONNXIFI_BACKEND_* constants. If this value is not
 *                   supported by the backend, the function will fail with
 *                   ONNXIFI_STATUS_UNSUPPORTED_ATTRIBUTE.
 * @param infoValue[out] - pointer to the memory location where the backend
 *                         information value will be returned. If the pointer is
 *                         NULL, is it ignored.
 * @param infoValueSize[in,out] - pointer to a variable specifying size, in
 *                                bytes, of the information value. On function
 *                                entry, the variable MUST contain the size of
 *                                the memory buffer specified by infoValue.
 *                                For successful completion, this size must be
 *                                at least as large as the queried value. If the
 *                                function completes with either
 *                                ONNXIFI_STATUS_SUCCESS or
 *                                ONNXIFI_STATUS_FALLBACK status codes, the
 *                                actual size of the value queried in the call
 *                                is stored in the variable specified by this
 *                                pointer.
 *
 * \retval ONNXIFI_STATUS_SUCCESS The function call succeeded, and requested
 *                                value is stored in the location specified by
 *                                infoValue, and the actual size of the
 *                                requested value is stored in the location
 *                                specified by infoValueSize.
 * \retval ONNXIFI_STATUS_FALLBACK The function call completed, but the
 *                                 requested value was not stored in the
 *                                 location specified by infoValue, either
 *                                 because it is NULL, or because the size of
 *                                 the memory buffer is insufficient for the
 *                                 value. The actual size of the requested value
 *                                 is stored in the location specified by
 *                                 infoValueSize.
 * \retval ONNXIFI_STATUS_INVALID_ID The function call failed because backendID
 *                                   is not an ONNXIFI backend ID.
 * \retval ONNXIFI_STATUS_INVALID_POINTER The function call failed because
 *                                        infoValueSize is NULL.
 * \retval ONNXIFI_STATUS_UNSUPPORTED_ATTRIBUTE The function call failed because
 *                                              the value of infoType is not
 *                                              supported by the backend.
 * \retval ONNXIFI_STATUS_BACKEND_UNAVAILABLE The function call failed because
 *                                            the backend was disconnected or
 *                                            uninstalled from the system.
 */
public static native @Cast("onnxStatus") int onnxGetBackendInfo(
    onnxBackendID backendID,
    @Cast("onnxBackendInfo") int infoType,
    Pointer infoValue,
    @Cast("size_t*") SizeTPointer infoValueSize);

/**
 * Query if an ONNX model graph is compatible with the backend.
 *
 * Model graph is passed as a serialized ModelProto message, where types and
 * dimensions of all inputs (including static weights) and outputs are specified
 * through ModelProto.graph.input and ModelProto.graph.output messages. If the
 * backend supports ONNXIFI_CAPABILITY_SYMBOLIC_SIZE_TENSORS, some of the shape
 * dimensions can be symbolic. If the backend supports
 * ONNXIFI_CAPABILITY_SYMBOLIC_BATCH_SIZE, the outer shape dimension can be
 * symbolic. In these cases, the validation of symbolic dimension should be
 * deferred until graph inputs and outputs are specified in onnxSetGraphIO.
 *
 * Commonly, the serialized ModelProto message passed to this function would
 * not include the static weights (ModelProto.graph.initializer is empty), and
 * the backend implementation MUST NOT rely on the weights to determine if the
 * graph is supported.
 *
 * An important use-case is a ModelProto containing only a single NodeProto in
 * ModelProto.graph.node, which happens when a high-level framework checks
 * operators one-by-one to find a connected subgraph that can be offloaded to
 * the backend. Backend implementations SHOULD optimize performance for this
 * use-case.
 *
 * @param backend - ID of the backend to query.
 * @param onnxModelSize - size of the serialized ONNX ModelProto message,
 *                        in bytes.
 * @param [in] onnxModel - pointer to serialized ONNX ModelProto message
 *                        representing the model graph.
 *
 * \retval ONNXIFI_STATUS_SUCCESS The function call succeeded and the model
 *                                graph can efficiently run on the backend.
 * \retval ONNXIFI_STATUS_FALLBACK The function call succeeded and the model
 *                                 graph can run on the backend through some
 *                                 emulation layer with some efficiency loss. If
 *                                 a backend decomposes this operator into
 *                                 multiple sub-operators, it should return this
 *                                 code. E.g. if a backend does not natively
 *                                 support grouped or depthwise convolution, but
 *                                 can execute it as multiple unit-group
 *                                 convolution operators, it must returns this
 *                                 code.
 * \retval ONNXIFI_STATUS_INVALID_ID The function call failed because backendID
 *                                   is not an ONNXIFI backend ID.
 * \retval ONNXIFI_STATUS_INVALID_POINTER The function call failed because
 *                                        onnxModel is NULL.
 * \retval ONNXIFI_STATUS_INVALID_SIZE The function call failed because
 *                                     onnxModelSize is 0.
 * \retval ONNXIFI_STATUS_INVALID_PROTOBUF The function call failed because it
 *                                         couldn't parse the serialized
 *                                         protobuf as an ONNX ModelProto
 *                                         message.
 * \retval ONNXIFI_STATUS_INVALID_MODEL The function call failed because the
 *                                      parsed ModelProto message does not
 *                                      satisfy ONNX requirements and
 *                                      constraints.
 * \retval ONNXIFI_STATUS_UNSUPPORTED_VERSION The function call failed because
 *                                            the ONNX IR version or operator
 *                                            version is not supported by the
 *                                            backend.
 * \retval ONNXIFI_STATUS_UNSUPPORTED_OPERATOR The function call failed because
 *                                             one of the operators in the model
 *                                             graph is not supported by the
 *                                             backend.
 * \retval ONNXIFI_STATUS_UNSUPPORTED_ATTRIBUTE The function call failed because
 *                                              the backend does not support the
 *                                              particular AttributeProto
 *                                              values in one of the operators.
 * \retval ONNXIFI_STATUS_UNSUPPORTED_SHAPE The function call failed because the
 *                                          backend does not support the
 *                                          tensor shapes in an input or output
 *                                          of one of the operators. The
 *                                          problematic tensor shapes could be
 *                                          directly specified through
 *                                          ValueInfoProto in GraphProto.input,
 *                                          GraphProto.output, or
 *                                          GraphProto.value_info, through
 *                                          TensorProto in
 *                                          GraphProto.initializer, or inferred
 *                                          from the inputs by the backend.
 * \retval ONNXIFI_STATUS_UNSUPPORTED_DATATYPE The function call failed because
 *                                             the backend does not support the
 *                                             data types in an input or output
 *                                             of one of the operators. The
 *                                             problematic data types could be
 *                                             directly specified through
 *                                             ValueInfoProto in
 *                                             GraphProto.input,
 *                                             GraphProto.output, or
 *                                             GraphProto.value_info, through
 *                                             TensorProto in
 *                                             GraphProto.initializer, or
 *                                             inferred from the inputs by the
 *                                             backend.
 * \retval ONNXIFI_STATUS_MISMATCHING_SHAPE The function call failed because
 *                                          output or intermediate shapes
 *                                          specified in the ONNX model graph do
 *                                          not match the shapes inferred from
 *                                          input shapes.
 * \retval ONNXIFI_STATUS_MISMATCHING_DATATYPE The function call failed because
 *                                             output or intermediate data types
 *                                             specified in the ONNX model graph
 *                                             do not match the data types
 *                                             inferred from graph inputs.
 * \retval ONNXIFI_STATUS_NO_SYSTEM_MEMORY The function call failed because the
 *                                         backend could not allocate enough
 *                                         system memory to parse and analyze
 *                                         the model graph.
 * \retval ONNXIFI_STATUS_BACKEND_UNAVAILABLE The function call failed because
 *                                            the backend was disconnected or
 *                                            uninstalled from the system.
 * \retval ONNXIFI_STATUS_INTERNAL_ERROR The function call failed because the
 *                                       backend experienced an unrecovered
 *                                       internal error.
 */
public static native @Cast("onnxStatus") int onnxGetBackendCompatibility(
    onnxBackendID backendID,
    @Cast("size_t") long onnxModelSize,
    @Const Pointer onnxModel);

/**
 * Initialize an ONNXIFI backend.
 *
 * ONNXIFI backend is a combination of software layer and hardware device used
 * to run an ONNXIFI graph. The same software layer may expose multiple backends
 * (e.g. one ONNXIFI backend for each GPU in the system, or one ONNXIFI backend
 * for GPU and another for CPU, both implemented in the same software).
 *
 * @param backendID - ID of the backend to initialize.
 * @param [in] auxPropertiesList - optional list of backend initialization
 *                                properties, terminated by
 *                                ONNXIFI_BACKEND_PROPERTY_NONE entry. Can be
 *                                NULL or empty.
 * @param [out] backend - pointer to an opaque handle for the initialized ONNXIFI
 *                       backend. If the function fails, the handle is
 *                       initialized to NULL.
 *
 * \retval ONNXIFI_STATUS_SUCCESS The function call succeeded and the backend
 *                                was successfully initialized.
 * \retval ONNXIFI_STATUS_INVALID_ID The function call failed because backendID
 *                                   is not an ONNXIFI backend ID.
 * \retval ONNXIFI_STATUS_INVALID_POINTER The function call failed because
 *                                        backend pointer is NULL.
 * \retval ONNXIFI_STATUS_INVALID_PROPERTY The function call failed because one
 *                                         of the backend initialization
 *                                         property values is invalid.
 * \retval ONNXIFI_STATUS_UNSUPPORTED_PROPERTY The function call failed because
 *                                             backend does not recognize one
 *                                             of the initialization
 *                                             property IDs.
 * \retval ONNXIFI_STATUS_NO_SYSTEM_MEMORY The function call failed due to
 *                                         insufficient system memory to
 *                                         initialize backend.
 * \retval ONNXIFI_STATUS_NO_SYSTEM_RESOURCES The function call failed due to
 *                                            insufficient non-memory system
 *                                            resources (e.g. file handles) to
 *                                            initialize the backend.
 * \retval ONNXIFI_STATUS_NO_DEVICE_MEMORY The function call failed due to
 *                                         insufficient backend-specific memory
 *                                         to initialize the backend.
 * \retval ONNXIFI_STATUS_NO_DEVICE_RESOURCES The function call failed due to
 *                                            insufficient non-memory
 *                                            backend-specific resources (e.g.
 *                                            command queues) to initialize the
 *                                            backend.
 * \retval ONNXIFI_STATUS_BACKEND_UNAVAILABLE The function call failed because
 *                                            the backend was disconnected or
 *                                            uninstalled from the system.
 * \retval ONNXIFI_STATUS_INTERNAL_ERROR The function call failed because the
 *                                       backend experienced an unrecovered
 *                                       internal error.
 */
public static native @Cast("onnxStatus") int onnxInitBackend(
    onnxBackendID backendID,
    @Cast("const uint64_t*") IntPointer auxPropertiesList,
    @ByPtrPtr onnxBackend backend);
public static native @Cast("onnxStatus") int onnxInitBackend(
    onnxBackendID backendID,
    @Cast("const uint64_t*") IntBuffer auxPropertiesList,
    @ByPtrPtr onnxBackend backend);
public static native @Cast("onnxStatus") int onnxInitBackend(
    onnxBackendID backendID,
    @Cast("const uint64_t*") int[] auxPropertiesList,
    @ByPtrPtr onnxBackend backend);

/**
 * Deinitialize an ONNXIFI backend and release associated resources.
 *
 * The user MUST deinitialize all objects created on this backend (onnxGraph,
 * onnxEvent) before calling this function to deinitialize the backend.
 *
 * @param backend - ONNXIFI backend handle created by onnxInitBackend.
 *
 * \retval ONNXIFI_STATUS_SUCCESS The function call succeeded and the backend
 *                                resources were released to the operating
 *                                system.
 * \retval ONNXIFI_STATUS_INVALID_BACKEND The function call failed because
 *                                        backend is not an ONNXIFI backend
 *                                        handle.
 * \retval ONNXIFI_STATUS_INTERNAL_ERROR The function call failed because the
 *                                       backend experienced an unrecovered
 *                                       internal error.
 */
public static native @Cast("onnxStatus") int onnxReleaseBackend(
    onnxBackend backend);

/**
 * Initialize a single-shot ONNXIFI event.
 *
 * The newly created event is in non-signalled state.
 *
 * @param backend - backend handle created by onnxInitBackend. This backend
 *                  would be used to initialize the event.
 * @param [out] event - pointer to the opaque handle for the created ONNXIFI
 *                     event. If the function fails, the handle is initialized
 *                     to NULL.
 *
 * \retval ONNXIFI_STATUS_SUCCESS The function call succeeded and the event
 *                                was successfully initialized.
 * \retval ONNXIFI_STATUS_INVALID_BACKEND The function call failed because
 *                                        backend is not an ONNXIFI backend
 *                                        handle.
 * \retval ONNXIFI_STATUS_INVALID_POINTER The function call failed because
 *                                        event pointer is NULL.
 * \retval ONNXIFI_STATUS_NO_SYSTEM_MEMORY The function call failed due to
 *                                         insufficient system memory to
 *                                         initialize the event.
 * \retval ONNXIFI_STATUS_NO_SYSTEM_RESOURCES The function call failed due to
 *                                            insufficient non-memory system
 *                                            resources (e.g. file handles) to
 *                                            initialize the event.
 * \retval ONNXIFI_STATUS_NO_DEVICE_MEMORY The function call failed due to
 *                                         insufficient backend-specific memory
 *                                         to initialize the event.
 * \retval ONNXIFI_STATUS_NO_DEVICE_RESOURCES The function call failed due to
 *                                            insufficient non-memory
 *                                            backend-specific resources (e.g.
 *                                            command queues) to initialize the
 *                                            event.
 * \retval ONNXIFI_STATUS_BACKEND_UNAVAILABLE The function call failed because
 *                                            the backend was disconnected or
 *                                            uninstalled from the system.
 * \retval ONNXIFI_STATUS_INTERNAL_ERROR The function call failed because the
 *                                       backend experienced an unrecovered
 *                                       internal error.
 */
public static native @Cast("onnxStatus") int onnxInitEvent(
    onnxBackend backend,
    @ByPtrPtr onnxEvent event);

/**
 * Change the state of an ONNXIFI event to signalled.
 *
 * @param event - event handle created by onnxInitEvent. While it is technically
 *                possible to use this function for output memory fence event
 *                created by onnxRunGraph, users SHOULD NOT do that.
 *
 * \retval ONNXIFI_STATUS_SUCCESS The function call succeeded and the event
 *                                was changed to signalled state.
 * \retval ONNXIFI_STATUS_INVALID_EVENT The function call failed because event
 *                                      is not an ONNXIFI event handle.
 * \retval ONNXIFI_STATUS_INVALID_STATE The function call failed because event
 *                                      is already in the signalled state.
 * \retval ONNXIFI_STATUS_BACKEND_UNAVAILABLE The function call failed because
 *                                            the backend was disconnected or
 *                                            uninstalled from the system.
 * \retval ONNXIFI_STATUS_INTERNAL_ERROR The function call failed because the
 *                                       implementation experienced an
 *                                       unrecovered internal error.
 */
public static native @Cast("onnxStatus") int onnxSignalEvent(
    onnxEvent event);

/**
 * Query ONNXIFI event state without blocking.
 *
 * @param event - event handle created by onnxRunGraph. While it is technically
 *                possible to use this function to events created by
 *                onnxInitEvent, this is not the intended use-case.
 * @param [out] state - pointer to the variable that will store the state of the
 *                     event. If the function fails, the variable is initialized
 *                     to ONNXIFI_EVENT_STATE_INVALID.
 *
 * \retval ONNXIFI_STATUS_SUCCESS The function call succeeded and the state
 *                                variable was initialized to either
 *                                ONNXIFI_EVENT_STATE_SIGNALLED or
 *                                ONNXIFI_EVENT_STATE_NONSIGNALLED according
 *                                to the state of the event.
 * \retval ONNXIFI_STATUS_INVALID_EVENT The function call failed because event
 *                                      is not an ONNXIFI event handle.
 * \retval ONNXIFI_STATUS_INVALID_POINTER The function call failed because state
 *                                        pointer is NULL.
 * \retval ONNXIFI_STATUS_BACKEND_UNAVAILABLE The function call failed because
 *                                            the backend was disconnected or
 *                                            uninstalled from the system.
 * \retval ONNXIFI_STATUS_INTERNAL_ERROR The function call failed because the
 *                                       implementation experienced an
 *                                       unrecovered internal error.
 */
public static native @Cast("onnxStatus") int onnxGetEventState(
    onnxEvent event,
    @Cast("onnxEventState*") IntPointer state);
public static native @Cast("onnxStatus") int onnxGetEventState(
    onnxEvent event,
    @Cast("onnxEventState*") IntBuffer state);
public static native @Cast("onnxStatus") int onnxGetEventState(
    onnxEvent event,
    @Cast("onnxEventState*") int[] state);

/**
 * Wait until an ONNXIFI event transitions to signalled state.
 *
 * @param event - event handle created by onnxRunGraph. While it is technically
 *                possible to use this function to events created by
 *                onnxInitEvent, this is not the intended use-case.
 *
 * \retval ONNXIFI_STATUS_SUCCESS The function call succeeded and the function
 *                                returned because event transitioned to
 *                                signalled state.
 * \retval ONNXIFI_STATUS_INVALID_EVENT The function call failed because event
 *                                      is not an ONNXIFI event handle.
 * \retval ONNXIFI_STATUS_BACKEND_UNAVAILABLE The function call failed because
 *                                            the backend was disconnected or
 *                                            uninstalled from the system.
 * \retval ONNXIFI_STATUS_INTERNAL_ERROR The function call failed because the
 *                                       implementation experienced an
 *                                       unrecovered internal error.
 */
public static native @Cast("onnxStatus") int onnxWaitEvent(
    onnxEvent event);

/**
 * Deinitialize an ONNXIFI event and release associated resources.
 *
 * @param event - event handle created by either onnxInitEvent or onnxRunGraph.
 *
 * \retval ONNXIFI_STATUS_SUCCESS The function call succeeded and the event
 *                                resources were released to the operating
 *                                system.
 * \retval ONNXIFI_STATUS_INVALID_EVENT The function call failed because event
 *                                      is not an ONNXIFI event handle.
 * \retval ONNXIFI_STATUS_INTERNAL_ERROR The function call failed because the
 *                                       implementation experienced an
 *                                       unrecovered internal error.
 */
public static native @Cast("onnxStatus") int onnxReleaseEvent(
    onnxEvent event);

/**
 * Parse an ONNXIFI graph and convert it for a particular backend.
 *
 * Model graph is passed as a serialized ModelProto message, where types and
 * dimensions of all inputs (including static weights) and outputs are specified
 * through ModelProto.graph.input and ModelProto.graph.output messages. If the
 * backend supports ONNXIFI_CAPABILITY_SYMBOLIC_SIZE_TENSORS, some of the shape
 * dimensions can be symbolic. If the backend supports
 * ONNXIFI_CAPABILITY_SYMBOLIC_BATCH_SIZE, the outer shape dimension can be
 * symbolic. In these cases, their validation should be deferred until a later
 * call to onnxSetGraphIO.
 *
 * Values of all static weights of the graph must be specified either in
 * ModelProto.graph.initializer, or through the weightDescriptors parameters,
 * but not through any combination of the two methods. If the caller creates the
 * graph on the fly, it SHOULD pass weights through weightDescriptors as it
 * involves less overhead.
 *
 * Blobs and operators in this graph are independent of the blobs and operators
 * of other graphs on the same backend.
 *
 * @param backend - backend handle created by onnxInitBackend. This backend
 *                  would be used to setup and run the model graph.
 * @param [in] auxPropertiesList - optional list of graph initialization
 *                                properties, terminated by
 *                                ONNXIFI_GRAPH_PROPERTY_NONE entry. Can be
 *                                NULL or empty.
 * @param onnxModelSize - size of the serialized ONNX ModelProto message,
 *                        in bytes.
 * @param [in] onnxModel - pointer to serialized ONNX ModelProto message
 *                        representing the model graph. The backend MUST not
 *                        assume that the serialized ModelProto message is
 *                        present at this address after the function returns.
 * @param weightsCount - number of weights specified in this function call
 *                       through tensor descriptors. Alternatively, the weights
 *                       can be specified in ModelProto.graph.initializer.
 *                       If weightsCount is non-zero, weightDescriptors must be
 *                       non-NULL.
 * @param [in] weightDescriptors - descriptors of static input tensors for the
 *                                graph. Elements of this array provide location
 *                                for blobs identified by ValueInfoProto.name
 *                                listed in ModelProto.graph.input of the ONNX
 *                                graph. If this parameter is non-NULL,
 *                                all static inputs must be specified through
 *                                the tensor descriptors, and the
 *                                ModelProto.graph.initilizer list must be
 *                                empty. The tensor descriptors
 *                                must use ONNXIFI_MEMORY_TYPE_CPU memory type,
 *                                and the backend must copy the values of the
 *                                tensors and all metadata, including shape,
 *                                into its own memory before the function
 *                                returns.
 * @param [out] graph - pointer to the opaque handle for the created ONNXIFI
 *                     graph. If the function fails, and this pointer is
 *                     non-NULL, the handle is initialized to NULL.
 *
 * \retval ONNXIFI_STATUS_SUCCESS The function call succeeded and the model
 *                                graph was successfully initialized on the
 *                                backend.
 * \retval ONNXIFI_STATUS_FALLBACK The function call succeeded and the model
 *                                 graph was initialized for the backend through
 *                                 an emulation layer with substantial
 *                                 efficiency loss. If a backend decomposes an
 *                                 operator into multiple sub-operators, it
 *                                 MUST return this code. E.g. if a backend
 *                                 does not natively support grouped or
 *                                 depthwise convolution, but can execute it as
 *                                 multiple unit-group convolution operators, it
 *                                 should return this code.
 * \retval ONNXIFI_STATUS_INVALID_BACKEND The function call failed because
 *                                        backend is not an ONNXIFI backend
 *                                        handle.
 * \retval ONNXIFI_STATUS_INVALID_PROPERTY The function call failed because one
 *                                         of the graph initialization property
 *                                         values is invalid.
 * \retval ONNXIFI_STATUS_INVALID_POINTER The function call failed because
 *                                        onnxModel or graph pointer is NULL, or
 *                                        weightDescriptors pointer is NULL
 *                                        while weightsCount is non-zero.
 * \retval ONNXIFI_STATUS_INVALID_SIZE The function call failed because
 *                                     onnxModelSize is 0.
 * \retval ONNXIFI_STATUS_INVALID_PROTOBUF The function call failed because it
 *                                         couldn't parse the serialized
 *                                         protobuf as an ONNX ModelProto
 *                                         message.
 * \retval ONNXIFI_STATUS_INVALID_MODEL The function call failed because the
 *                                      parsed ModelProto message does not
 *                                      satisfy ONNX requirements and
 *                                      constraints.
 * \retval ONNXIFI_STATUS_INVALID_SHAPE The function call failed because one of
 *                                      the shape dimensions in
 *                                      weightDescriptors is 0.
 * \retval ONNXIFI_STATUS_INVALID_DATATYPE The function call failed because
 *                                         one of the data types in
 *                                         weightDescriptors is unknown to the
 *                                         backend.
 * \retval ONNXIFI_STATUS_INVALID_MEMORY_TYPE The function call failed because
 *                                            one of the memory types in
 *                                            weightDescriptors is unknown to
 *                                            the backend.
 * \retval ONNXIFI_STATUS_INVALID_MEMORY_LOCATION The function call failed
 *                                                because one of the memory
 *                                                locations in weightDescriptors
 *                                                is invalid (NULL pointer).
 * \retval ONNXIFI_STATUS_UNSUPPORTED_PROPERTY The function call failed because
 *                                             backend does not recognize one
 *                                             of the graph initialization
 *                                             property IDs.
 * \retval ONNXIFI_STATUS_UNSUPPORTED_VERSION The function call failed because
 *                                            the ONNX IR version or operator
 *                                            version is not supported by the
 *                                            backend.
 * \retval ONNXIFI_STATUS_UNSUPPORTED_OPERATOR The function call failed because
 *                                             one of the operators in the model
 *                                             graph is not supported by the
 *                                             backend.
 * \retval ONNXIFI_STATUS_UNSUPPORTED_ATTRIBUTE The function call failed because
 *                                              the backend does not support the
 *                                              particular AttributeProto
 *                                              values in one of the operators.
 * \retval ONNXIFI_STATUS_UNSUPPORTED_SHAPE The function call failed because the
 *                                          backend does not support the
 *                                          tensor shapes in an input or
 *                                          output of one of the operators.
 *                                          The problematic tensor shapes could
 *                                          be directly specified through
 *                                          ValueInfoProto in GraphProto.input,
 *                                          GraphProto.output, or
 &                                          GraphProto.value_info, through
 *                                          TensorProto in
 *                                          GraphProto.initializer, through
 *                                          weightDescriptors argument,
 *                                          or inferred from the inputs by the
 *                                          backend.
 * \retval ONNXIFI_STATUS_UNSUPPORTED_DATATYPE The function call failed because
 *                                             the backend does not support the
 *                                             data types in an input or output
 *                                             of one of the operators. The
 *                                             problematic data types could be
 *                                             directly specified through
 *                                             ValueInfoProto in
 *                                             GraphProto.input,
 *                                             GraphProto.output, or
 *                                             GraphProto.value_info, through
 *                                             TensorProto in
 *                                             GraphProto.initializer, through
 *                                             weightDescriptors argument,
 *                                             or inferred from the inputs by
 *                                             the backend.
 * \retval ONNXIFI_STATUS_UNSUPPORTED_MEMORY_TYPE The function call failed
 *                                                because one of the memory
 *                                                types in weightDescriptors is
 *                                                different from
 *                                                ONNXIFI_MEMORY_TYPE_CPU.
 * \retval ONNXIFI_STATUS_MISMATCHING_SHAPE The function call failed because
 *                                          the shapes specified in weight
 *                                          descriptors do not match the shapes
 *                                          specified in the ONNX model graph,
 *                                          or output or intermediate shapes
 *                                          specified in the ONNX model graph do
 *                                          not match the shapes inferred from
 *                                          input shapes.
 * \retval ONNXIFI_STATUS_MISMATCHING_DATATYPE The function call failed because
 *                                             data types specified in weight
 *                                             descriptors do not match the data
 *                                             types specified in ONNX model
 *                                             graph, or output or intermediate
 *                                             data types specified in the ONNX
 *                                             model graph do not match the data
 *                                             types inferred from graph inputs.
 * \retval ONNXIFI_STATUS_NO_SYSTEM_MEMORY The function call failed because the
 *                                         backend could not allocate enough
 *                                         system memory to parse, analyze, and
 *                                         initialize the model graph.
 * \retval ONNXIFI_STATUS_NO_SYSTEM_RESOURCES The function call failed due to
 *                                            insufficient non-memory system
 *                                            resources (e.g. file handles) to
 *                                            initialize the graph.
 * \retval ONNXIFI_STATUS_NO_DEVICE_MEMORY The function call failed due to
 *                                         insufficient backend-specific memory
 *                                         to initialize the graph.
 * \retval ONNXIFI_STATUS_NO_DEVICE_RESOURCES The function call failed due to
 *                                            insufficient non-memory
 *                                            backend-specific resources (e.g.
 *                                            command queues) to initialize the
 *                                            graph.
 * \retval ONNXIFI_STATUS_BACKEND_UNAVAILABLE The function call failed because
 *                                            the backend was disconnected or
 *                                            uninstalled from the system.
 * \retval ONNXIFI_STATUS_INTERNAL_ERROR The function call failed because the
 *                                       implementation experienced an
 *                                       unrecovered internal error.
 */
public static native @Cast("onnxStatus") int onnxInitGraph(
    onnxBackend backend,
    @Cast("const uint64_t*") IntPointer auxPropertiesList,
    @Cast("size_t") long onnxModelSize,
    @Const Pointer onnxModel,
    @Cast("uint32_t") int weightsCount,
    @Const onnxTensorDescriptorV1 weightDescriptors,
    @ByPtrPtr onnxGraph graph);
public static native @Cast("onnxStatus") int onnxInitGraph(
    onnxBackend backend,
    @Cast("const uint64_t*") IntBuffer auxPropertiesList,
    @Cast("size_t") long onnxModelSize,
    @Const Pointer onnxModel,
    @Cast("uint32_t") int weightsCount,
    @Const onnxTensorDescriptorV1 weightDescriptors,
    @ByPtrPtr onnxGraph graph);
public static native @Cast("onnxStatus") int onnxInitGraph(
    onnxBackend backend,
    @Cast("const uint64_t*") int[] auxPropertiesList,
    @Cast("size_t") long onnxModelSize,
    @Const Pointer onnxModel,
    @Cast("uint32_t") int weightsCount,
    @Const onnxTensorDescriptorV1 weightDescriptors,
    @ByPtrPtr onnxGraph graph);

/**
 * Set locations for inputs and outputs of an ONNXIFI graph.
 *
 * The caller MUST ensure that the memory buffers specified for input and output
 * tensors remain accessible until all in-flight graph executions which use
 * specified buffer locations complete AND
 * - Either a next call to onnxSetGraphIO specifies different buffer locations
 * - Or the graph is deinitialized via onnxReleaseGraph
 * The caller can invalidate other data in tensor descriptors, including shape,
 * once the function returns.
 *
 * Calls to onnxRunGraph WILL use input and output locations specified in the
 * preceeding onnxSetGraphIO on the same graph. Asynchronous graph executions
 * that were in-flight before onnxSetGraphIO call will continue to use buffer
 * locations that were current when these graph executions started. An ONNXIFI
 * implementation MAY block inside onnxSetGraphIO until all in-flight graph
 * executions that started before the call complete.
 *
 * If a call to onnxSetGraphIO fails, it invalidates input and output locations
 * for the graph, and a subsequent call to onnxRunGraph will fail with
 * ONNXIFI_STATUS_UNIDENTIFIED_NAME.
 *
 * @param graph - graph handle created by onnxInitGraph.
 * @param inputsCount - number of elements in the inputDescriptors array.
 * @param [in] inputDescriptors - descriptors of input tensors for the graph.
 *                               Elements of this array must provide a location
 *                               for each ValueInfoProto.name listed in
 *                               ModelProto.graph.input of the ONNX graph.
 *                               If inputsCount is non-zero, inputDescriptors
 *                               pointer must be non-NULL.
 * @param outputsCount - number of elements in the outputDescriptors array.
 *                       Must be greater than zero.
 * @param [in] outputDescriptors - descriptors of output tensors for the graph.
 *                                outputDescriptors pointer must be non-NULL.
 *                                Elements of this array must provide a location
 *                                for each ValueInfoProto.name listed in
 *                                ModelProto.graph.output of the ONNX graph.
 *
 * \retval ONNXIFI_STATUS_SUCCESS The function call succeeded and the all graph
 *                                inputs and outputs were matched to a memory
 *                                location.
 * \retval ONNXIFI_STATUS_INVALID_GRAPH The function call failed because
 *                                      graph is not an ONNXIFI graph handle.
 * \retval ONNXIFI_STATUS_INVALID_POINTER The function call failed because
 *                                        outputDescriptors pointer is NULL or
 *                                        inputDescriptors pointer is NULL while
 *                                        inputsCount is non-zero.
 * \retval ONNXIFI_STATUS_INVALID_NAME The function call failed because one of
 *                                     the names in tensor descriptors doesn't
 *                                     match blob name in ModelProto.graph.input
 *                                     or ModelProto.graph.output, or the same
 *                                     name appears in more than one tensor
 *                                     descriptor.
 * \retval ONNXIFI_STATUS_INVALID_SHAPE The function call failed because one of
 *                                      the shape dimensions is 0.
 * \retval ONNXIFI_STATUS_INVALID_DATATYPE The function call failed because
 *                                         one of the data types in
 *                                         inputDescriptors or outputDescriptors
 *                                         is unknown to the backend.
 * \retval ONNXIFI_STATUS_INVALID_MEMORY_TYPE The function call failed because
 *                                            one of the memory types in
 *                                            inputDescriptors or
 *                                            outputDescriptors is unknown to
 *                                            the backend.
 * \retval ONNXIFI_STATUS_INVALID_MEMORY_LOCATION The function call failed
 *                                                because one of the memory
 *                                                locations in inputDescriptors
 *                                                or outputDescriptors is not
 *                                                valid for the specified
 *                                                memory type (e.g. NULL pointer
 *                                                for ONNXIFI_MEMORY_TYPE_CPU).
 * \retval ONNXIFI_STATUS_UNSUPPORTED_TAG The function call failed because one
 *                                        of the tags in inputDescriptors or
 *                                        outputDescriptors is unknown to the
 *                                        backend (tag does not match
 *                                        ONNXIFI_TAG_TENSOR_DESCRIPTOR_V1).
 * \retval ONNXIFI_STATUS_UNSUPPORTED_SHAPE The function call failed because the
 *                                          backend does not support the
 *                                          tensor shapes in an input or output
 *                                          of one of the operators. The
 *                                          problematic tensor shapes could be
 *                                          directly specified through
 *                                          inputDescriptors or
 *                                          outputDescriptors argument,
 *                                          or inferred from the inputs by the
 *                                          backend. This error code can be
 *                                          returned when the backend supports
 *                                          variable-size inputs and outputs,
 *                                          and the problematic tensor shape was
 *                                          provided in the ValueInfoProto as a
 *                                          symbolic variable.
 * \retval ONNXIFI_STATUS_UNSUPPORTED_MEMORY_TYPE The function call failed
 *                                                because the backend does not
 *                                                support one of the memory
 *                                                types in inputDescriptors or
 *                                                outputDescriptors.
 * \retval ONNXIFI_STATUS_UNIDENTIFIED_NAME The function call failed because one
 *                                          of the ValueInfoProto.name value in
 *                                          ModelProto.graph.input or
 *                                          ModelProto.graph.output doesn't have
 *                                          a match in the inputDescriptors or
 *                                          outputDescriptors.
 * \retval ONNXIFI_STATUS_MISMATCHING_SHAPE The function call failed because
 *                                          the shapes specified through
 *                                          inputDescriptors or
 *                                          outputDescriptors argument are
 *                                          inconsistent with the shapes
 *                                          specified in the ONNX model graph.
 * \retval ONNXIFI_STATUS_MISMATCHING_DATATYPE The function call failed because
 *                                             data types specified through
 *                                             inputDescriptors or
 *                                             outputDescriptors argument are
 *                                             inconsistent with the data types
 *                                             specified in the ONNX model
 *                                             graph.
 * \retval ONNXIFI_STATUS_NO_SYSTEM_MEMORY The function call failed because the
 *                                         backend could not allocate enough
 *                                         system memory to parse, analyze, and
 *                                         initialize the tensor locations.
 * \retval ONNXIFI_STATUS_NO_SYSTEM_RESOURCES The function call failed due to
 *                                            insufficient non-memory system
 *                                            resources (e.g. file handles) to
 *                                            initialize the tensor locations.
 * \retval ONNXIFI_STATUS_NO_DEVICE_MEMORY The function call failed due to
 *                                         insufficient backend-specific memory
 *                                         to initialize the tensor locations.
 * \retval ONNXIFI_STATUS_NO_DEVICE_RESOURCES The function call failed due to
 *                                            insufficient non-memory
 *                                            backend-specific resources (e.g.
 *                                            command queues) to initialize the
 *                                            tensor locations.
 * \retval ONNXIFI_STATUS_BACKEND_UNAVAILABLE The function call failed because
 *                                            the backend was disconnected or
 *                                            uninstalled from the system.
 * \retval ONNXIFI_STATUS_INTERNAL_ERROR The function call failed because the
 *                                       backend experienced an unrecovered
 *                                       internal error.
 */
public static native @Cast("onnxStatus") int onnxSetGraphIO(
    onnxGraph graph,
    @Cast("uint32_t") int inputsCount,
    @Const onnxTensorDescriptorV1 inputDescriptors,
    @Cast("uint32_t") int outputsCount,
    @Const onnxTensorDescriptorV1 outputDescriptors);

/**
 * Asynchronously execute operations in an ONNXIFI graph using pre-specified
 * locations for inputs and outputs.
 *
 * This function operates asynchronously: it doesn't require that the locations
 * for graph inputs graph inputs hold valid values before the function is
 * called, and doesn't guarantee that the locations for graph outputs hold
 * valid values when the function returns. Instead, two synchronization
 * primitives are used to signal to the backend when inputs are ready to use,
 * and to signal to the caller when outputs are ready to use. The only
 * synchronization primitive that is always available is onnxEvent
 * (ONNXIFI_SYNCHRONIZATION_EVENT memory fence type). If a backend supports
 * additional types of synchronization primitives, it must indicate them in
 * ONNXIFI_BACKEND_SYNCHRONIZATION_TYPES information query.
 *
 * The caller must successfully specify locations of input and output tensors
 * for the graph through onnxSetGraphIO before calling this function.
 *
 * @param graph - graph handle created by onnxInitGraph.
 * @param [in] inputFence - synchronization primitive that signals when graph
 *                         inputs are ready to use by the backend. The
 *                         synchronization primitive always must be initialized
 *                         by the caller.
 * @param [out] outputFence - synchronization primitive that signals when graph
 *                           outputs are ready to use by the caller. The type
 *                           of the synchronization primitive always must be
 *                           initialized by the caller. The type of the
 *                           synchronization primitive determines whether it
 *                           is initialized by the user before the call or by
 *                           the backend as a result of this call. Single-shot
 *                           synchronizatiom objects are initialized as a result
 *                           of the call. Reusable synchronization objects are
 *                           generally initialized by the user prior to the
 *                           call.
 *
 * \retval ONNXIFI_STATUS_SUCCESS The function call succeeded and the all graph
 *                                inputs and outputs were matched to a memory
 *                                location.
 * \retval ONNXIFI_STATUS_INVALID_POINTER The function call failed because
 *                                        inputFence or outputFence pointer is
 *                                        NULL.
 * \retval ONNXIFI_STATUS_INVALID_GRAPH The function call failed because
 *                                      graph is not an ONNXIFI graph handle.
 * \retval ONNXIFI_STATUS_INVALID_FENCE_TYPE The function call failed because
 *                                           the type of synchronization
 *                                           primitive specified in inputFence
 *                                           or outputFence is unknown to the
 *                                           backend.
 * \retval ONNXIFI_STATUS_INVALID_EVENT The function call failed because
 *                                      the memory synchronization primitive
 *                                      specified in inputFence or outputFence
 *                                      is not valid (e.g. NULL onnxEvent).
 * \retval ONNXIFI_STATUS_UNSUPPORTED_TAG The function call failed because a tag
 *                                        in inputFence or outputFence is
 *                                        unknown to the backend (tag does not
 *                                        match ONNXIFI_TAG_MEMORY_FENCE_V1).
 * \retval ONNXIFI_STATUS_UNSUPPORTED_FENCE_TYPE The function call failed
 *                                               because the backend does not
 *                                               support the type of
 *                                               synchronization primitive
 *                                               specified in inputFence or
 *                                               outputFence.
 * \retval ONNXIFI_STATUS_UNIDENTIFIED_NAME The function call failed because
 *                                          some of the ValueInfoProto.name
 *                                          value in ModelProto.graph.input or
 *                                          ModelProto.graph.output were not
 *                                          specified in a call to
 *                                          onnxSetGraphIO.
 * \retval ONNXIFI_STATUS_NO_SYSTEM_MEMORY The function call failed because the
 *                                         backend could not allocate enough
 *                                         system memory to execute the model
 *                                         graph.
 * \retval ONNXIFI_STATUS_NO_SYSTEM_RESOURCES The function call failed due to
 *                                            insufficient non-memory system
 *                                            resources (e.g. file handles) to
 *                                            execute the model graph.
 * \retval ONNXIFI_STATUS_NO_DEVICE_MEMORY The function call failed due to
 *                                         insufficient backend-specific memory
 *                                         to execute the graph.
 * \retval ONNXIFI_STATUS_NO_DEVICE_RESOURCES The function call failed due to
 *                                            insufficient non-memory
 *                                            backend-specific resources (e.g.
 *                                            command queues) to execute the
 *                                            graph.
 * \retval ONNXIFI_STATUS_BACKEND_UNAVAILABLE The function call failed because
 *                                            the backend was disconnected or
 *                                            uninstalled from the system.
 * \retval ONNXIFI_STATUS_INTERNAL_ERROR The function call failed because the
 *                                       backend experienced an unrecovered
 *                                       internal error.
 */
public static native @Cast("onnxStatus") int onnxRunGraph(
    onnxGraph graph,
    @Const onnxMemoryFenceV1 inputFence,
    onnxMemoryFenceV1 outputFence);

/**
 * Deinitialize an ONNXIFI graph and release associated resources.
 *
 * If there are in-flight asynchronous inference operations on this graph,
 * the function MUST block until all outstanding operations complete.
 *
 * @param graph - graph handle created by onnxInitGraph.
 *
 * \retval ONNXIFI_STATUS_SUCCESS The function call succeeded and the graph
 *                                resources were released to the operating
 *                                system.
 * \retval ONNXIFI_STATUS_INVALID_GRAPH The function call failed because graph
 *                                      is not an ONNXIFI graph handle.
 * \retval ONNXIFI_STATUS_INTERNAL_ERROR The function call failed because the
 *                                       graph backend experienced an
 *                                       unrecovered internal error.
 */
public static native @Cast("onnxStatus") int onnxReleaseGraph(
    onnxGraph graph);

// #ifdef __cplusplus /* extern "C" */
// #endif

// #endif /* !defined(ONNXIFI_H) */


// Parsed from onnx/common/tensor.h

// ATTENTION: The code in this file is highly EXPERIMENTAL.
// Adventurous users should note that the APIs will probably change.

// #pragma once

// #include <cmath>
// #include <functional>
// #include <numeric>
// #include "onnx/common/assertions.h"
// #include "onnx/onnx_pb.h"

@Namespace("onnx") @NoOffset public static class Tensor extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Tensor(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Tensor(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Tensor position(long position) {
        return (Tensor)super.position(position);
    }

  public Tensor() { super((Pointer)null); allocate(); }
  private native void allocate();
  public native @ByRef LongVector sizes();

  public native @Cast("int64_t") int size_from_dim(int dim);

  public native @Cast("onnx::TensorProto_DataType*") @ByRef IntPointer elem_type();

  public native @ByRef StringVector strings();

  public native @ByRef FloatVector floats();

  public native @StdVector DoublePointer doubles();

  public native @Cast("int32_t*") @StdVector IntPointer int32s();

  public native @ByRef LongVector int64s();

  public native @Cast("uint64_t*") @StdVector IntPointer uint64s();

  public native @StdString BytePointer raw();

  public native void set_raw_data(@StdString BytePointer raw_data);
  public native void set_raw_data(@StdString String raw_data);

  public native @Cast("bool") boolean is_segment();

  public native @Cast("int64_t") int segment_begin();

  public native @Cast("int64_t") int segment_end();

  public native void set_segment_begin_and_end(@Cast("int64_t") int begin, @Cast("int64_t") int end);

  public native @Cast("bool") boolean hasName();

  public native @StdString BytePointer name();

  public native void setName(@StdString BytePointer name);
  public native void setName(@StdString String name);

  public native @Cast("bool") boolean is_raw_data();

  //this += a
  //Supported for
  //FLOAT, BOOL, INT8, INT16, INT32, UINT8, UINT16, INT64,
  //UINT32, UINT64, DOUBLE,
  //TODO: Support for FLOAT16, COMPLEX64, COMPLEX128
  public native void add(@Const @ByRef Tensor a);

  //this -= a
  //Supported for
  //FLOAT, BOOL, INT8, INT16, INT32, UINT8, UINT16, INT64,
  //UINT32, UINT64, DOUBLE
  //TODO: Support for FLOAT16, COMPLEX64, COMPLEX128
  public native void subtract(@Const @ByRef Tensor a);

  //this *= a
  //Supported for
  //FLOAT, BOOL, INT8, INT16, INT32, UINT8, UINT16, INT64,
  //UINT32, UINT64, DOUBLE
  //TODO: Support for FLOAT16, COMPLEX64, COMPLEX128
  public native void multiply(@Const @ByRef Tensor a);

  //this /= a
  //Supported for
  //FLOAT, INT8, INT16, INT32, UINT8, UINT16, INT64,
  //UINT32, UINT64, DOUBLE
  //TODO: Support for FLOAT16, COMPLEX64, COMPLEX128
  public native void divide(@Const @ByRef Tensor a);

  //Element-wise square root of This
  //Supported for
  //FLOAT, DOUBLE,
  //TODO: Support for FLOAT16
  public native void sqrt();

  //Element wise scaling of tensor s
  //s is one dimensional, has size M, where M is size of first dimension of tensor
  //s must have has data type corresponding to this
  //Supported for
  //FLOAT16, FLOAT, DOUBLE
  public native void scale_by_first_dim(@Const @ByRef Tensor s);
}

// #define define_data(type, field)
//   template <>
//   inline type* Tensor::data<type>() {
//     if (is_raw_data_) {
//       return (type*)&raw_data_.data()[0];
//     } else {
//       return field.data();
//     }
//   }
// 
//   template <>
//   inline const type* Tensor::data<type>() const {
//     if (is_raw_data_) {
//       return (type*)(raw_data_.data());
//     } else {
//       return field.data();
//     }
//   }



  


  


  


  


  


  
// #undef define_data







// #define APPLY_BINARY_FUNCTION(op_name, f)
//   inline void Tensor::op_name(const Tensor& other) {
//     TENSOR_ASSERTM(
//         other.eem_type() == elem_type_,
//         "Tensor types do not match: %s != %s",
//         to_string(elem_type_).c_str(),
//         " vs. ",
//         to_string(other.eem_type()).c_str());
//     TENSOR_ASSERTM(other.sizes() == sizes_, "Tensor sizes do not match.");
//     switch (elem_type_) {
//       case ONNX_NAMESPACE::TensorProto_DataType_FLOAT: {
//         bin_func(f<float>(), data<float>(), other.data<float>());
//         break;
//       }
//       case ONNX_NAMESPACE::TensorProto_DataType_BOOL:
//       case ONNX_NAMESPACE::TensorProto_DataType_INT8:
//       case ONNX_NAMESPACE::TensorProto_DataType_INT16:
//       case ONNX_NAMESPACE::TensorProto_DataType_INT32:
//       case ONNX_NAMESPACE::TensorProto_DataType_UINT8:
//       case ONNX_NAMESPACE::TensorProto_DataType_UINT16: {
//         bin_func(f<int32_t>(), data<int32_t>(), other.data<int32_t>());
//         break;
//       }
//       case ONNX_NAMESPACE::TensorProto_DataType_INT64: {
//         bin_func(f<int64_t>(), data<int64_t>(), other.data<int64_t>());
//         break;
//       }
//       case ONNX_NAMESPACE::TensorProto_DataType_UINT32:
//       case ONNX_NAMESPACE::TensorProto_DataType_UINT64: {
//         bin_func(f<uint64_t>(), data<uint64_t>(), other.data<uint64_t>());
//         break;
//       }
//       case ONNX_NAMESPACE::TensorProto_DataType_DOUBLE: {
//         bin_func(f<double>(), data<double>(), other.data<double>());
//         break;
//       }
//       default:
//         TENSOR_ASSERTM(
//             false,
//             "Operation %s not supported for data type %s",
//             #op_name,
//             " not supported for data type ",
//             to_string(elem_type_).c_str());
//     }
//   }






// #undef APPLY_BINARY_FUNCTION





 // namespace ONNX_NAMESPACE


// Parsed from onnx/common/array_ref.h

// ATTENTION: The code in this file is highly EXPERIMENTAL.
// Adventurous users should note that the APIs will probably change.

//===--- ArrayRef.h - Array Reference Wrapper -------------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

// ONNX: modified from llvm::ArrayRef.
// removed llvm-specific functionality
// removed some implicit const -> non-const conversions that rely on
// complicated std::enable_if meta-programming
// removed a bunch of slice variants for simplicity...

// #pragma once
// #include <assert.h>
// #include <array>
// #include <vector>
  /** ArrayRef - Represent a constant reference to an array (0 or more elements
   *  consecutively in memory), i.e. a start pointer and a length.  It allows
   *  various APIs to take consecutive elements easily and conveniently.
   * 
   *  This class does not own the underlying data, it is expected to be used in
   *  situations where the data resides in some other buffer, whose lifetime
   *  extends past that of the ArrayRef. For this reason, it is not in general
   *  safe to store an ArrayRef.
   * 
   *  This is intended to be trivially copyable, so it should be passed by
   *  value. */

 // namespace ONNX_NAMESPACE


// Parsed from onnx/common/stl_backports.h

// #pragma once

// This file contains backports of STL features for newer C++.

// #include <memory>
// #include <type_traits>

/*
 * Use MOVE_CAPTURE_IF_CPP14 in a lambda capture so it gets
 * copied in C++11 and moved in C++14.
 * Example:
 *   std::string mystring;
 *   auto lambda = [MOVE_CAPTURE_IF_CPP14(mystring)] {
 *     std::cout << mystring;
 *   }
 */
// #ifdef __cpp_init_captures
//   #define MOVE_CAPTURE_IF_CPP14(variable) variable = std::move(variable)
// #else
//   #define MOVE_CAPTURE_IF_CPP14(variable) variable
// #endif


/**
 * For exception safety and consistency with make_shared. Erase me when
 * we have std::make_unique().
 *
 * @author Louis Brandy (ldbrandy\fb.com)
 * @author Xu Ning (xning\fb.com)
 * @author Sebastian Messmer (messmer\fb.com)
 */

// #if __cplusplus >= 201402L || __cpp_lib_make_unique >= 201304L ||
//     (__ANDROID__ && __cplusplus >= 201300L) || _MSC_VER >= 1900


// #else

// Allows 'make_unique<T[]>(10)'. (N3690 s20.9.1.4 p3-4)

// Disallows 'make_unique<T[10]>()'. (N3690 s20.9.1.4 p5)




// #endif


// Parsed from onnx/common/ir.h

// ATTENTION: The code in this file is highly EXPERIMENTAL.
// Adventurous users should note that the APIs will probably change.

// #pragma once

// #include <atomic>
// #include <algorithm>
// #include <cstdint>
// #include <functional>
// #include <iostream>
// #include <memory>
// #include <sstream>
// #include <stdint.h>
// #include <string>
// #include <unordered_set>
// #include <vector>

// #include "onnx/string_utils.h"
// #include "onnx/common/array_ref.h"
// #include "onnx/common/assertions.h"
// #include "onnx/common/interned_strings.h"
// #include "onnx/common/graph_node_list.h"
// #include "onnx/common/tensor.h"


// #define ONNX_DISALLOW_COPY_AND_ASSIGN(TypeName)
//   TypeName(const TypeName&) = delete;
//   void operator=(const TypeName&) = delete

// Graph represents one "function" of computation.
// It uses a simple ownership model where the graph owns all the nodes inside it.
// All references inside the graph are raw pointers.
// Destroying the Graph will invalidate any pointers to nodes in the graph.


// Node is the base class of the IR graph. It represents one computation
// and dependencies on a list of Values. The "prim-ops", so to speak.
@Namespace("onnx") @Opaque public static class Node extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Node() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Node(Pointer p) { super(p); }
}


// A Value represents an input or output to node that is either a
// Tensor or an opaque Handle object, as determined by type().


@Name("onnx::Dimension") @NoOffset public static class DimensionIR extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DimensionIR(Pointer p) { super(p); }

  public DimensionIR(@StdString BytePointer param) { super((Pointer)null); allocate(param); }
  private native void allocate(@StdString BytePointer param);
  public DimensionIR(@StdString String param) { super((Pointer)null); allocate(param); }
  private native void allocate(@StdString String param);
  public DimensionIR(@Cast("int64_t") int dim) { super((Pointer)null); allocate(dim); }
  private native void allocate(@Cast("int64_t") int dim);

  public native @Cast("bool") boolean is_int(); public native DimensionIR is_int(boolean is_int);
  public native @Cast("int64_t") int dim(); public native DimensionIR dim(int dim);
  public native @StdString BytePointer param(); public native DimensionIR param(BytePointer param);
}


/** enum class onnx::AttributeKind */
public static final int
  // float, float list, int, int list, string, string list,
  // tensor, tensor list, subgraph, subgraph list
  f = 0, fs = 1, i = 2, is = 3, s = 4, ss = 5, t = 6, ts = 7, g = 8, gs = 9;





@Namespace("onnx") public static class AttributeValue extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AttributeValue(Pointer p) { super(p); }

  public native @Cast("onnx::AttributeKind") int kind();
  public native @UniquePtr AttributeValue clone();
}


// CRTP so that Node which inherits Attributes can be return for
// method chaining e.g:
// Node * n = g->create(kSelect)->set_i(kOffset,3)->set_f(kValue,3.5);
// we return Derived* pointers because Nodes are normally held as pointers.



// Each use is represented by this type, see Node::uses()
// 'user' is the consumer of the value, offset is the index into
// 'user's input this where the produces will be found.
@Namespace("onnx") @NoOffset public static class Use extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Use(Pointer p) { super(p); }

  public Use(Node user, @Cast("size_t") long offset) { super((Pointer)null); allocate(user, offset); }
  private native void allocate(Node user, @Cast("size_t") long offset);
  public native Node user(); public native Use user(Node user);
  public native @Cast("size_t") long offset(); public native Use offset(long offset);
}

@Namespace("onnx") public static native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef Use a, @Const @ByRef Use b);


// the list types are intentionally simple, but we type-def
// them here so if we need to change them, refactoring will be easier


@Namespace("onnx") @NoOffset public static class Value extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Value(Pointer p) { super(p); }

  
  
  public Value(Node node_, @Cast("size_t") long offset_) { super((Pointer)null); allocate(node_, offset_); }
  private native void allocate(Node node_, @Cast("size_t") long offset_);
  public native Value setElemType(@Cast("onnx::TensorProto_DataType") int elem_type);
  public native @Cast("onnx::TensorProto_DataType") int elemType();
  public native @Cast("bool") boolean has_sizes();
  public native Value setSizes(@StdVector DimensionIR sizes);
  public native @StdVector DimensionIR sizes();
  public native @Cast("size_t") long unique();
  public native @Cast("bool") boolean has_unique_name();
  public native @StdString BytePointer uniqueName();
  public native Value setUniqueName(@StdString BytePointer name);
  public native Value setUniqueName(@StdString String name);
  public native Value setStage(@Cast("size_t") long s);
  public native @Cast("size_t") long stage();
  public native Node node();
  public native @Cast("size_t") long offset();
  public native Graph owningGraph();
  // TODO: make this more const correct
  public native @StdVector Use uses();

  // Replaces all uses of this node with 'newValue'.
  //
  // Given:   %3 = f(%1, %2)
  //          %4 = g(%3)
  //          %5 = h(%3, %3)
  // Execute: %3.replaceAllUsesWith(%6)
  // Result:  %3 = f(%1, %2)
  //          %4 = g(%6)
  //          %5 = h(%6, %6)
  public native void replaceAllUsesWith(Value newValue);

  public native Value copyMetadata(Value from);

}

// A class with the same properties as OperatorSetIdProto, but without protobuf
// overhead, resulting in a simpler and more readable workflow.
@Namespace("onnx") @NoOffset public static class OpSetID extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSetID(Pointer p) { super(p); }

    public OpSetID(@Const @ByRef OperatorSetIdProto proto) { super((Pointer)null); allocate(proto); }
    private native void allocate(@Const @ByRef OperatorSetIdProto proto);

    // Default Domain Constructor
    public OpSetID(@Cast("const int64_t") int version) { super((Pointer)null); allocate(version); }
    private native void allocate(@Cast("const int64_t") int version);

    public OpSetID(@StdString BytePointer domain, @Cast("int64_t") int version) { super((Pointer)null); allocate(domain, version); }
    private native void allocate(@StdString BytePointer domain, @Cast("int64_t") int version);
    public OpSetID(@StdString String domain, @Cast("int64_t") int version) { super((Pointer)null); allocate(domain, version); }
    private native void allocate(@StdString String domain, @Cast("int64_t") int version);

    // target must be in the form "<domain>&<version>"
    

    // target must be in the form "<domain>&<version>"
    public static native @ByVal OpSetID fromString(@StdString BytePointer target);
    public static native @ByVal OpSetID fromString(@StdString String target);

    public native @StdString BytePointer domain();

    public native @Cast("int64_t") int version();

    public native void incrementVersion(@Cast("int64_t") int step);

    public native void setVersion(@Cast("int64_t") int newVal);
}

@Namespace("onnx") @NoOffset public static class Graph extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Graph(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Graph(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Graph position(long position) {
        return (Graph)super.position(position);
    }


  
  public Graph() { super((Pointer)null); allocate(); }
  private native void allocate();

  public native @Cast("bool") boolean has_doc_string();
  public native @StdString BytePointer docString();
  public native void setDocString(@StdString BytePointer doc_string);
  public native void setDocString(@StdString String doc_string);

  public native void addInitializer(@ByVal Tensor initializer, @StdString BytePointer name);
  public native void addInitializer(@ByVal Tensor initializer, @StdString String name);
  public native void eraseInitializer(@StdString BytePointer name);
  public native void eraseInitializer(@StdString String name);
  public native void clearInitializers();
  public native @StdVector Tensor initializers();
  public native @Const @ByRef StringVector initializer_names();

  public native @StdVector OpSetID opset_versions_mutable();

  // These invocations of begin() on output of function are OK
  // because graph_node_list is non-owning, so it doesn't matter
  // if it immediately dies after the invocation.
  public native Node return_node();

  public native Value addInput();
  public native void eraseInput(@Cast("size_t") long i);
  public native void advanceStage();
  public native void setStage(@Cast("size_t") long new_stage);
  public native @Cast("size_t") long stage();

  public native @Cast("size_t") long registerOutput(Value n);

  public native Node appendNode(Node n);

  public native Node prependNode(Node n);

  //Adds to graph initializer list, initializer names list, and as a graph input
  //Also syncs the initializer name, tensor name, and value name
  public native Value addInitializerAndInput(@Const @ByRef Tensor initializer, @StdString BytePointer name);
  public native Value addInitializerAndInput(@Const @ByRef Tensor initializer, @StdString String name);

  public native Value addInitializerAndInput(@Const @ByRef Tensor initializer);


  //Erases from graph initializer list, initializer names list, and as a graph input
  //Must have no uses
  public native void eraseInitializerAndInput(Value v);

  

  public native @Cast("bool") boolean has_name();

  public native @StdString BytePointer name();

  public native void setName(@StdString BytePointer name);
  public native void setName(@StdString String name);

  
}

















/************* All nodes not required to be defined before Graph **************/







 // namespace ONNX_NAMESPACE


// Parsed from onnx/common/ir_pb_converter.h

// ATTENTION: The code in this file is highly EXPERIMENTAL.
// Adventurous users should note that the APIs will probably change.

// #pragma once

// #include "onnx/common/ir.h"
// #include "onnx/onnx_pb.h"

@Namespace("onnx") @NoOffset public static class ConvertError extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ConvertError(Pointer p) { super(p); }


  public ConvertError(@StdString BytePointer message) { super((Pointer)null); allocate(message); }
  private native void allocate(@StdString BytePointer message);
  public ConvertError(@StdString String message) { super((Pointer)null); allocate(message); }
  private native void allocate(@StdString String message);

  public native @NoException @Cast("const char*") BytePointer what();

  public native void AppendContext(@StdString BytePointer context);
  public native void AppendContext(@StdString String context);
}

// #define fail_convert(...)
//   throw ConvertError(MakeString(__VA_ARGS__));

@Namespace("onnx") public static native void ExportModelProto(ModelProto p_m, @SharedPtr Graph g);

@Namespace("onnx") public static native @UniquePtr Graph ImportModelProto(@Const @ByRef ModelProto mp);

@Namespace("onnx") public static native @ByVal ModelProto PrepareOutput(@Const @ByRef ModelProto mp_in);

@Namespace("onnx") public static native void assertNonNull(@SharedPtr Graph g);
 // namespace ONNX_NAMESPACE


// Parsed from onnx/version_converter/adapters/adapter.h

// Interface for Op Version Adapters

// #pragma once

// #include "onnx/onnx_pb.h"
// #include "onnx/version_converter/helper.h"

@Namespace("onnx::version_conversion") @NoOffset public static class Adapter extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Adapter(Pointer p) { super(p); }


    public native void adapt(@SharedPtr Graph arg0, Node node);

    public native @StdString BytePointer name();

    public native @Const @ByRef OpSetID initial_version();

    public native @Const @ByRef OpSetID target_version();
}

 // namespace ONNX_NAMESPACE::version_conversion


// Parsed from onnx/version_converter/helper.h

// Helper Methods for Adapters

// #pragma once

// #include "onnx/common/ir.h"
    @Namespace("onnx::version_conversion") public static native int check_numpy_unibroadcastable_and_require_broadcast(
            @StdVector DimensionIR input1_sizes,
            @StdVector DimensionIR input2_sizes);

    @Namespace("onnx::version_conversion") public static native void assert_numpy_multibroadcastable(@StdVector DimensionIR input1_sizes,
            @StdVector DimensionIR input2_sizes);

    @Namespace("onnx::version_conversion") public static native void assertNotParams(@StdVector DimensionIR sizes);



// Parsed from onnx/version_converter/BaseConverter.h

// Version converter interface for ONNX models between different opset versions.

// #pragma once

// #include "onnx/common/ir.h"
// #include "onnx/common/ir_pb_converter.h"
// #include "onnx/common/stl_backports.h"
// #include "onnx/proto_utils.h"
// #include "onnx/defs/schema.h"
// #include <utility>
// #include <iostream>
// #include <stdlib.h>
// #include "onnx/version_converter/adapters/adapter.h"

// TODO: Consider creating interface for this class.
@Namespace("onnx::version_conversion") @NoOffset public static class BaseVersionConverter extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public BaseVersionConverter(Pointer p) { super(p); }


    // adapter_lookup should be called in convert_version when the user would
    // like to identify the proper registered adapter in the adapters map for
    // a given Node from a certain version to another. It should only be called
    // when the user knows that an adapter should exist for the given context.
    public native @Const @ByRef Adapter adapter_lookup(@Const Node op,
            @Const @ByRef OpSetID initial_version,
            @Const @ByRef OpSetID target_version);

  public native @ByVal ModelProto convert_version(
        @Const @ByRef ModelProto mp_in,
        @Const @ByRef OpSetID initial_version,
        @Const @ByRef OpSetID target_version);

  
}

 // namespace ONNX_NAMESPACE::version_conversion


// Parsed from onnx/version_converter/convert.h

// Default converter for ONNX models between different opset versions
// in the default domain ("" or "ai.onnx").

// #pragma once

// #include "onnx/version_converter/BaseConverter.h"
// #include "onnx/version_converter/adapters/no_previous_version.h"
// #include "onnx/version_converter/adapters/broadcast_backward_compatibility.h"
// #include "onnx/version_converter/adapters/broadcast_forward_compatibility.h"
// #include "onnx/version_converter/adapters/type_restriction.h"
// #include "onnx/version_converter/adapters/compatible.h"
// #include "onnx/version_converter/adapters/remove_consumed_inputs.h"
// #include "onnx/version_converter/adapters/gemm_7_6.h"
// #include "onnx/version_converter/adapters/gemm_6_7.h"
// #include "onnx/version_converter/adapters/batch_normalization_6_5.h"
// #include "onnx/version_converter/adapters/batch_normalization_6_7.h"
// #include "onnx/version_converter/adapters/set_is_test.h"
// #include "onnx/version_converter/adapters/concat_3_4.h"
// #include "onnx/version_converter/adapters/reshape_5_4.h"
// #include "onnx/version_converter/adapters/reshape_4_5.h"
// #include "onnx/version_converter/adapters/sum_8_7.h"
// #include "onnx/version_converter/adapters/averagepool_7_6.h"
// #include "onnx/version_converter/adapters/dropout_6_7.h"
// #include "onnx/version_converter/adapters/maxpool_8_7.h"

@Namespace("onnx::version_conversion") @NoOffset public static class DefaultVersionConverter extends BaseVersionConverter {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DefaultVersionConverter(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public DefaultVersionConverter(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public DefaultVersionConverter position(long position) {
        return (DefaultVersionConverter)super.position(position);
    }

    public DefaultVersionConverter() { super((Pointer)null); allocate(); }
    private native void allocate();

    public native @ByVal ModelProto convert_version(
            @Const @ByRef ModelProto mp_in,
            @Const @ByRef OpSetID initial_version,
            @Const @ByRef OpSetID target_version);
}

@Namespace("onnx::version_conversion") public static native @ByVal ModelProto ConvertVersion(
    @Const @ByRef ModelProto mp_in,
    int target_version);
 // namespace ONNX_NAMESPACE::version_conversion


// Parsed from onnx/optimizer/passes/optimize_pass.h

// ATTENTION: The code in this file is highly EXPERIMENTAL.
// Adventurous users should note that the APIs will probably change.

// #pragma once

// #include "onnx/common/ir.h"
// #include "onnx/onnx_pb.h"

/** enum class onnx::optimization::API_TYPE */
public static final int
  PROTO = 0, IR = 1;

@Namespace("onnx::optimization") @NoOffset public static class OptimizePass extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OptimizePass(Pointer p) { super(p); }


  public native @StdString BytePointer name(); public native OptimizePass name(BytePointer name);
  public native @Cast("onnx::optimization::API_TYPE") int type(); public native OptimizePass type(int type);

  public native void optimize(@ByRef ModelProto arg0);

  public native void optimize(@ByRef Graph arg0);

}



 // namespace ONNX_NAMESPACE::optimization


// Parsed from onnx/optimizer/optimize.h

// ATTENTION: The code in this file is highly EXPERIMENTAL.
// Adventurous users should note that the APIs will probably change.

// #pragma once

// #include "onnx/common/ir.h"
// #include "onnx/common/ir_pb_converter.h"
// #include "onnx/common/stl_backports.h"
// #include "onnx/optimizer/passes/eliminate_identity.h"
// #include "onnx/optimizer/passes/eliminate_nop_transpose.h"
// #include "onnx/optimizer/passes/eliminate_nop_pad.h"
// #include "onnx/optimizer/passes/eliminate_unused_initializer.h"
// #include "onnx/optimizer/passes/extract_constant_to_initializer.h"
// #include "onnx/optimizer/passes/fuse_add_bias_into_conv.h"
// #include "onnx/optimizer/passes/fuse_consecutive_squeezes.h"
// #include "onnx/optimizer/passes/fuse_consecutive_transposes.h"
// #include "onnx/optimizer/passes/fuse_transpose_into_gemm.h"
// #include "onnx/optimizer/passes/lift_lexical_references.h"
// #include "onnx/optimizer/passes/nop.h"
// #include "onnx/optimizer/passes/split.h"
// #include "onnx/optimizer/passes/fuse_bn_into_conv.h"
// #include "onnx/proto_utils.h"

@Namespace("onnx::optimization") public static class Optimizer extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Optimizer(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Optimizer(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Optimizer position(long position) {
        return (Optimizer)super.position(position);
    }


  public Optimizer() { super((Pointer)null); allocate(); }
  private native void allocate();

  public native @ByVal ModelProto optimize(
        @Const @ByRef ModelProto mp_in,
        @Const @ByRef StringVector names);
}

@Namespace("onnx::optimization") public static native @Const @ByVal StringVector GetAvailablePasses();

@Namespace("onnx::optimization") public static native @ByVal ModelProto Optimize(
    @Const @ByRef ModelProto mp_in,
    @Const @ByRef StringVector names);

 // namespace optimization
 // namespace ONNX_NAMESPACE


}
