// Targeted by JavaCPP version 1.4.2-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class onnx extends org.bytedeco.javacpp.presets.onnx {
    static { Loader.load(); }

@Name("std::map<std::string,onnx::OpSchema::Attribute>") public static class StringAttributeMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringAttributeMap(Pointer p) { super(p); }
    public StringAttributeMap()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef StringAttributeMap put(@ByRef StringAttributeMap x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index(function = "at") public native @ByRef OpSchema.Attribute get(@StdString BytePointer i);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter @StdString BytePointer first();
        public native @Name("operator*().second") @MemberGetter @ByRef @Const OpSchema.Attribute second();
    }
}

@Name("std::set<int>") public static class IntSet extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IntSet(Pointer p) { super(p); }
    public IntSet()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef IntSet put(@ByRef IntSet x);

    public boolean empty() { return size() == 0; }
    public native long size();

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") int get();
    }
}

@Name("std::vector<std::string>") public static class StringVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringVector(Pointer p) { super(p); }
    public StringVector(BytePointer value) { this(1); put(0, value); }
    public StringVector(BytePointer ... array) { this(array.length); put(array); }
    public StringVector(String value) { this(1); put(0, value); }
    public StringVector(String ... array) { this(array.length); put(array); }
    public StringVector()       { allocate();  }
    public StringVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef StringVector put(@ByRef StringVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native @StdString BytePointer get(@Cast("size_t") long i);
    public native StringVector put(@Cast("size_t") long i, BytePointer value);
    @ValueSetter @Index(function = "at") public native StringVector put(@Cast("size_t") long i, @StdString String value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @StdString BytePointer get();
    }

    public BytePointer[] get() {
        BytePointer[] array = new BytePointer[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public BytePointer pop_back() {
        long size = size();
        BytePointer value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public StringVector push_back(BytePointer value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public StringVector put(BytePointer value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public StringVector put(BytePointer ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }

    public StringVector push_back(String value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public StringVector put(String value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public StringVector put(String ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<onnx::OpSchema::FormalParameter>") public static class FormalParameterVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FormalParameterVector(Pointer p) { super(p); }
    public FormalParameterVector(OpSchema.FormalParameter value) { this(1); put(0, value); }
    public FormalParameterVector(OpSchema.FormalParameter ... array) { this(array.length); put(array); }
    public FormalParameterVector()       { allocate();  }
    public FormalParameterVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef FormalParameterVector put(@ByRef FormalParameterVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native @ByRef OpSchema.FormalParameter get(@Cast("size_t") long i);
    public native FormalParameterVector put(@Cast("size_t") long i, OpSchema.FormalParameter value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @ByRef @Const OpSchema.FormalParameter get();
    }

    public OpSchema.FormalParameter[] get() {
        OpSchema.FormalParameter[] array = new OpSchema.FormalParameter[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public OpSchema.FormalParameter pop_back() {
        long size = size();
        OpSchema.FormalParameter value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public FormalParameterVector push_back(OpSchema.FormalParameter value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public FormalParameterVector put(OpSchema.FormalParameter value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public FormalParameterVector put(OpSchema.FormalParameter ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<onnx::OpSchema>") public static class OpSchemaVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSchemaVector(Pointer p) { super(p); }
    public OpSchemaVector(OpSchema value) { this(1); put(0, value); }
    public OpSchemaVector(OpSchema ... array) { this(array.length); put(array); }
    public OpSchemaVector()       { allocate();  }
    public OpSchemaVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef OpSchemaVector put(@ByRef OpSchemaVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native @ByRef OpSchema get(@Cast("size_t") long i);
    public native OpSchemaVector put(@Cast("size_t") long i, OpSchema value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @ByRef @Const OpSchema get();
    }

    public OpSchema[] get() {
        OpSchema[] array = new OpSchema[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public OpSchema pop_back() {
        long size = size();
        OpSchema value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public OpSchemaVector push_back(OpSchema value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public OpSchemaVector put(OpSchema value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public OpSchemaVector put(OpSchema ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<onnx::OpSchema::TypeConstraintParam>") public static class TypeConstraintParamVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeConstraintParamVector(Pointer p) { super(p); }
    public TypeConstraintParamVector(OpSchema.TypeConstraintParam value) { this(1); put(0, value); }
    public TypeConstraintParamVector(OpSchema.TypeConstraintParam ... array) { this(array.length); put(array); }
    public TypeConstraintParamVector()       { allocate();  }
    public TypeConstraintParamVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef TypeConstraintParamVector put(@ByRef TypeConstraintParamVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native @ByRef OpSchema.TypeConstraintParam get(@Cast("size_t") long i);
    public native TypeConstraintParamVector put(@Cast("size_t") long i, OpSchema.TypeConstraintParam value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @ByRef @Const OpSchema.TypeConstraintParam get();
    }

    public OpSchema.TypeConstraintParam[] get() {
        OpSchema.TypeConstraintParam[] array = new OpSchema.TypeConstraintParam[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public OpSchema.TypeConstraintParam pop_back() {
        long size = size();
        OpSchema.TypeConstraintParam value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public TypeConstraintParamVector push_back(OpSchema.TypeConstraintParam value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public TypeConstraintParamVector put(OpSchema.TypeConstraintParam value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public TypeConstraintParamVector put(OpSchema.TypeConstraintParam ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@NoOffset @Name("std::pair<google::protobuf::uint64,google::protobuf::uint64>") public static class ProtoLongPair extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ProtoLongPair(Pointer p) { super(p); }
    public ProtoLongPair(long firstValue, long secondValue) { this(); put(firstValue, secondValue); }
    public ProtoLongPair()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef ProtoLongPair put(@ByRef ProtoLongPair x);


    @MemberGetter public native long first(); public native ProtoLongPair first(long first);
    @MemberGetter public native @Cast("google::protobuf::uint64") long second();  public native ProtoLongPair second(long second);

    public ProtoLongPair put(long firstValue, long secondValue) {
        first(firstValue);
        second(secondValue);
        return this;
    }
}

@NoOffset @Name("std::pair<int,int>") public static class UseTypeIntPair extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public UseTypeIntPair(Pointer p) { super(p); }
    public UseTypeIntPair(int firstValue, int secondValue) { this(); put(firstValue, secondValue); }
    public UseTypeIntPair()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef UseTypeIntPair put(@ByRef UseTypeIntPair x);


    @MemberGetter public native int first(); public native UseTypeIntPair first(int first);
    @MemberGetter public native int second();  public native UseTypeIntPair second(int second);

    public UseTypeIntPair put(int firstValue, int secondValue) {
        first(firstValue);
        second(secondValue);
        return this;
    }
}

@Name("std::unordered_map<std::string,std::pair<int,int> >") public static class StringIntIntPairMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringIntIntPairMap(Pointer p) { super(p); }
    public StringIntIntPairMap()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef StringIntIntPairMap put(@ByRef StringIntIntPairMap x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index(function = "at") public native int first(@StdString BytePointer i); public native StringIntIntPairMap first(@StdString BytePointer i, int first);
    @Index(function = "at") public native int second(@StdString BytePointer i);  public native StringIntIntPairMap second(@StdString BytePointer i, int second);
}

@Name("std::unordered_map<int,int>") public static class IntIntMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IntIntMap(Pointer p) { super(p); }
    public IntIntMap()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef IntIntMap put(@ByRef IntIntMap x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index(function = "at") public native int get(int i);
    public native IntIntMap put(int i, int value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter int first();
        public native @Name("operator*().second") @MemberGetter int second();
    }
}

@Name("std::unordered_set<onnx::DataType>") public static class DataTypeSet extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DataTypeSet(Pointer p) { super(p); }
    public DataTypeSet()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef DataTypeSet put(@ByRef DataTypeSet x);

    public boolean empty() { return size() == 0; }
    public native long size();

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @ByRef @Const @Cast({"char*", "std::string*"}) BytePointer get();
    }
}

// Parsed from onnx/proto_utils.h

// #pragma once

// #include <google/protobuf/io/coded_stream.h>
// #include <google/protobuf/io/zero_copy_stream_impl_lite.h>
 // namespace onnx


// Parsed from defs/schema.h

// Copyright (c) Facebook Inc. and Microsoft Corporation.
// Licensed under the MIT license.

// #pragma once

// #include <climits>
// #include <cstring>
// #include <functional>
// #include <initializer_list>
// #include <iostream>
// #include <limits>
// #include <ostream>
// #include <set>
// #include <string>
// #include <tuple>
// #include <unordered_map>
// #include <unordered_set>
// #include <vector>

// #include "data_type_utils.h"

// Type constraint map. Key is type string. Value is data type set and
// description.

// A const value returned by OpSchema::CalculateOutput() if the number of
// output cannot be determined.
@Namespace("onnx") @MemberGetter public static native int kCannotComputeNumOutputs();

/**
 * \brief A class to record the schema of an op.
 *
 * OpSchema records the common interface of an op specified by its name.
 *
 * To register an OpSchema, one can use the macro OPERATOR_SCHEMA(name) and
 * then append the various functions in the class. For example, for an op
 * that itakes in two inputs, one output, and the first input and output
 * could be in-place, can be written as
 *
 *     OPERATOR_SCHEMA(name)
 *         .NumInputs(2).NumOutputs(1).AllowConsumed({{0, 0}});
 */
@Namespace("onnx") @NoOffset public static class OpSchema extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSchema(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSchema(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public OpSchema position(long position) {
        return (OpSchema)super.position(position);
    }

  // Formal parameter options.
  /** enum onnx::OpSchema::FormalParameterOption */
  public static final int
    // The input formal parameter is single and not optional.
    // Number of this input is 1.
    Single = 0,
    // The input formal parameter is single and optional.
    // Number of this input is 0 or 1.
    Optional = 1,
    // The input formal parameter is variadic.
    // Number of this input is [0, n].
    Variadic = 2;

  // Formal parameter represenation, including input/output name, typeStr,
  // description, and type constraints.
  @NoOffset public static class FormalParameter extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public FormalParameter(Pointer p) { super(p); }
      /** Native array allocator. Access with {@link Pointer#position(long)}. */
      public FormalParameter(long size) { super((Pointer)null); allocateArray(size); }
      private native void allocateArray(long size);
      @Override public FormalParameter position(long position) {
          return (FormalParameter)super.position(position);
      }
  
    // Constructor.
    public FormalParameter() { super((Pointer)null); allocate(); }
    private native void allocate();

    public FormalParameter(
            @StdString BytePointer name,
            @Const @ByRef DataTypeSet type_set,
            @StdString BytePointer type_str,
            @StdString BytePointer description,
            @Cast("onnx::OpSchema::FormalParameterOption") int param_option/*=onnx::OpSchema::Single*/) { super((Pointer)null); allocate(name, type_set, type_str, description, param_option); }
    private native void allocate(
            @StdString BytePointer name,
            @Const @ByRef DataTypeSet type_set,
            @StdString BytePointer type_str,
            @StdString BytePointer description,
            @Cast("onnx::OpSchema::FormalParameterOption") int param_option/*=onnx::OpSchema::Single*/);
    public FormalParameter(
            @StdString BytePointer name,
            @Const @ByRef DataTypeSet type_set,
            @StdString BytePointer type_str,
            @StdString BytePointer description) { super((Pointer)null); allocate(name, type_set, type_str, description); }
    private native void allocate(
            @StdString BytePointer name,
            @Const @ByRef DataTypeSet type_set,
            @StdString BytePointer type_str,
            @StdString BytePointer description);
    public FormalParameter(
            @StdString String name,
            @Const @ByRef DataTypeSet type_set,
            @StdString String type_str,
            @StdString String description,
            @Cast("onnx::OpSchema::FormalParameterOption") int param_option/*=onnx::OpSchema::Single*/) { super((Pointer)null); allocate(name, type_set, type_str, description, param_option); }
    private native void allocate(
            @StdString String name,
            @Const @ByRef DataTypeSet type_set,
            @StdString String type_str,
            @StdString String description,
            @Cast("onnx::OpSchema::FormalParameterOption") int param_option/*=onnx::OpSchema::Single*/);
    public FormalParameter(
            @StdString String name,
            @Const @ByRef DataTypeSet type_set,
            @StdString String type_str,
            @StdString String description) { super((Pointer)null); allocate(name, type_set, type_str, description); }
    private native void allocate(
            @StdString String name,
            @Const @ByRef DataTypeSet type_set,
            @StdString String type_str,
            @StdString String description);

    public FormalParameter(
            @StdString BytePointer name,
            @StdString BytePointer description,
            @StdString BytePointer type_str,
            @Cast("onnx::OpSchema::FormalParameterOption") int param_option/*=onnx::OpSchema::Single*/) { super((Pointer)null); allocate(name, description, type_str, param_option); }
    private native void allocate(
            @StdString BytePointer name,
            @StdString BytePointer description,
            @StdString BytePointer type_str,
            @Cast("onnx::OpSchema::FormalParameterOption") int param_option/*=onnx::OpSchema::Single*/);
    public FormalParameter(
            @StdString BytePointer name,
            @StdString BytePointer description,
            @StdString BytePointer type_str) { super((Pointer)null); allocate(name, description, type_str); }
    private native void allocate(
            @StdString BytePointer name,
            @StdString BytePointer description,
            @StdString BytePointer type_str);
    public FormalParameter(
            @StdString String name,
            @StdString String description,
            @StdString String type_str,
            @Cast("onnx::OpSchema::FormalParameterOption") int param_option/*=onnx::OpSchema::Single*/) { super((Pointer)null); allocate(name, description, type_str, param_option); }
    private native void allocate(
            @StdString String name,
            @StdString String description,
            @StdString String type_str,
            @Cast("onnx::OpSchema::FormalParameterOption") int param_option/*=onnx::OpSchema::Single*/);
    public FormalParameter(
            @StdString String name,
            @StdString String description,
            @StdString String type_str) { super((Pointer)null); allocate(name, description, type_str); }
    private native void allocate(
            @StdString String name,
            @StdString String description,
            @StdString String type_str);

    // Get formal parameter name.
    public native @StdString BytePointer GetName();

    // Get allowed data types.
    public native @Const @ByRef DataTypeSet GetTypes();

    // Get formal parameter type string.
    public native @StdString BytePointer GetTypeStr();

    // Get formal parameter description.
    public native @StdString BytePointer GetDescription();

    // Get the parameter option, it could be Single, Optional or Variadic.
    public native @Cast("onnx::OpSchema::FormalParameterOption") int GetOption();
  }

  /** enum class onnx::OpSchema::SupportType */
  public static final int
    COMMON = 0, // Supported by all frameworks that support this IR.
    EXPERIMENTAL = 1; // This OP is experimental and can be changed or removed in
                  // the future.

  public OpSchema() { super((Pointer)null); allocate(); }
  private native void allocate();
  public OpSchema(@StdString BytePointer name, @StdString BytePointer file, int line) { super((Pointer)null); allocate(name, file, line); }
  private native void allocate(@StdString BytePointer name, @StdString BytePointer file, int line);
  public OpSchema(@StdString String name, @StdString String file, int line) { super((Pointer)null); allocate(name, file, line); }
  private native void allocate(@StdString String name, @StdString String file, int line);

  /**
   * \brief Returns the file that the op schema is registered from.
   */
  public native @StdString BytePointer file();

  /**
   * \brief Returns the line in file that the op schema is registered from.
   */
  public native int line();

  /**
   * \brief Returns the support level of the op schema.
   */
  public native @Cast("onnx::OpSchema::SupportType") int support_level();

  /**
   * \brief Returns the docstring of the op schema.
   */
  public native @Cast("const char*") BytePointer doc();

  /**
   * \brief Verifies if a NodeProto matches the pattern specified in
   * the schema.
   */
  public native void Verify(@Const @ByRef NodeProto node);

  // Functions to set the property of the operator schemas.
  // Sets the number of inputs, either a fixed number or a min and a max.

  /**
   * The earliest operator set version which this operator was
   * present in.  If an operator has had no BC-breaking changes,
   * this is simply the first operator set the operator was a member
   * of; if it has had BC-breaking changes, then for the semantics
   * /as described/ in the OpSchema entry, this version describes
   * the operator set which introduced the BC-breaking change.
   *
   * For example, suppose op Foo was added in v3, and had a BC-breaking
   * change in v6.  Then there will be an op schema entry for Foo with
   * SinceVersion(3), and another, updated op schema entry for Foo
   * with SinceVersion(6).
   */
  public native @ByRef OpSchema SinceVersion(@Cast("onnx::OperatorSetVersion") int n); // aka int

  /**
   * \brief A single input.
   */
  public native @ByRef OpSchema NumInputs(int n);
  /**
   * \brief Input could be in range [min, max], inclusive.
   */
  public native @ByRef OpSchema NumInputs(int min, int max);
  /**
   * \brief Input could be one of the values specified in allowed_input_nums.
   */
  public native @ByRef OpSchema NumInputs(@ByVal IntSet allowed_input_nums);
  /**
   * \brief Input is checked with a specified function.
   */
  public native @ByRef OpSchema NumInputs(@ByVal BoolIntFn func);

  // Sets the number of outputs, either a fixed number, a min and a max,
  // or a function that takes in the input number and produces an output
  // number. Use only one function in the set below.
  /**
   * \brief A single output.
   */
  public native @ByRef OpSchema NumOutputs(int n);
  /**
   * \brief Output could be in range [min, max], inclusive.
   */
  public native @ByRef OpSchema NumOutputs(int min, int max);
  /**
   * \brief Output could be one of the values specified in allowed_output_nums.
   */
  public native @ByRef OpSchema NumOutputs(@ByVal IntSet allowed_output_nums);
  /**
   * \brief Output is checked with a specified function.
   */
  public native @ByRef OpSchema NumOutputs(@ByVal BoolIntFn func);

  /**
   * \brief Relationship between inputs and outputs is checked with a specified
   * function.
   */
  public native @ByRef OpSchema NumInputsOutputs(@ByVal BoolIntIntFn func);

  // Set the function that can calculate the number of output based on the
  // number of input. Use only one function in the set below.
  /**
   * \brief Set the output calculator to a user-defined function.
   */
  public native @ByRef OpSchema OutputCalculator(@ByVal IntIntFn calc);
  /**
   * \brief Set the number of outputs to be the same as the number of inputs.
   */
  public native @ByRef OpSchema SameNumberOfOutput();

  // Sets the rule to allow optional in-place operation.
  public native @ByRef OpSchema AllowConsumed(@ByVal PairBoolIntIntFn inplace);
  public native @ByRef OpSchema AllowConsumed(@ByVal IntIntMap inplace);
  public native @ByRef OpSchema AllowOneToOneConsumed();
  // Sets the rule to enforce in-place opeartion.
  public native @ByRef OpSchema EnforceConsumed(@ByVal PairBoolIntIntFn inplace);
  public native @ByRef OpSchema EnforceConsumed(@ByVal IntIntMap inplace);
  public native @ByRef OpSchema EnforceOneToOneConsumed();

  // Set the support level for the op schema.
  public native @ByRef OpSchema SetSupportLevel(@Cast("onnx::OpSchema::SupportType") int supportType);

  // Functions to do documentation for the operator schema.
  public native @ByRef OpSchema SetDoc(@StdString BytePointer doc);
  public native @ByRef OpSchema SetDoc(@StdString String doc);

  // Functions to specify domain for the operator schema.
  // Default domain value ("") means it's ONNX domain.
  public native @ByRef OpSchema SetDomain(@StdString BytePointer domain);
  public native @ByRef OpSchema SetDomain(@StdString String domain);

  // Note: this enum is structurally identical to the
  // AttributeProto.AttributeType enum defined in onnx.proto.  If you rev one,
  // you likely need to rev the other.
  /** enum class onnx::OpSchema::AttrType */
  public static final int
    FLOAT = 0,
    INT = 1,
    STRING = 2,
    TENSOR = 3,
    GRAPH = 4,
    FLOATS = 5,
    INTS = 6,
    STRINGS = 7,
    TENSORS = 8,
    GRAPHS = 9;

  /** enum class onnx::OpSchema::UseType */
  public static final int
    DEFAULT = 0, // read only use of an input
    CONSUME_ALLOWED = 1, // allowed to be marked consumed by a "consumed_inputs"
                     // attribute.
    CONSUME_ENFORCED = 2; // must be marked consumed by a "consumed_inputs"
                      // attribute.

  @NoOffset public static class Attribute extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public Attribute(Pointer p) { super(p); }
  
    public Attribute(
            @Cast("const char*") BytePointer name_,
            @Cast("const char*") BytePointer description_,
            @Cast("onnx::OpSchema::AttrType") int type_,
            @Cast("bool") boolean required_) { super((Pointer)null); allocate(name_, description_, type_, required_); }
    private native void allocate(
            @Cast("const char*") BytePointer name_,
            @Cast("const char*") BytePointer description_,
            @Cast("onnx::OpSchema::AttrType") int type_,
            @Cast("bool") boolean required_);
    public Attribute(
            String name_,
            String description_,
            @Cast("onnx::OpSchema::AttrType") int type_,
            @Cast("bool") boolean required_) { super((Pointer)null); allocate(name_, description_, type_, required_); }
    private native void allocate(
            String name_,
            String description_,
            @Cast("onnx::OpSchema::AttrType") int type_,
            @Cast("bool") boolean required_);

    @MemberGetter public native @StdString BytePointer name();
    @MemberGetter public native @StdString BytePointer description();
    public native @Cast("onnx::OpSchema::AttrType") int type(); public native Attribute type(int type);
    public native @Cast("bool") boolean required(); public native Attribute required(boolean required);
  }

  public native @ByRef OpSchema Attr(@Const @ByRef Attribute attr);
  public native @ByRef OpSchema Attr(
        @Cast("const char*") BytePointer name,
        @Cast("const char*") BytePointer description,
        @Cast("onnx::OpSchema::AttrType") int type,
        @Cast("bool") boolean required/*=false*/);
  public native @ByRef OpSchema Attr(
        @Cast("const char*") BytePointer name,
        @Cast("const char*") BytePointer description,
        @Cast("onnx::OpSchema::AttrType") int type);
  public native @ByRef OpSchema Attr(
        String name,
        String description,
        @Cast("onnx::OpSchema::AttrType") int type,
        @Cast("bool") boolean required/*=false*/);
  public native @ByRef OpSchema Attr(
        String name,
        String description,
        @Cast("onnx::OpSchema::AttrType") int type);
  public native @ByRef OpSchema AllowUncheckedAttributes();

  // Type constraint.
  @NoOffset public static class TypeConstraintParam extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public TypeConstraintParam(Pointer p) { super(p); }
      /** Native array allocator. Access with {@link Pointer#position(long)}. */
      public TypeConstraintParam(long size) { super((Pointer)null); allocateArray(size); }
      private native void allocateArray(long size);
      @Override public TypeConstraintParam position(long position) {
          return (TypeConstraintParam)super.position(position);
      }
  
    public TypeConstraintParam() { super((Pointer)null); allocate(); }
    private native void allocate();
    public TypeConstraintParam(
            @StdString BytePointer type_param_str_,
            @Const @ByRef StringVector allowed_type_strs_,
            @StdString BytePointer description_) { super((Pointer)null); allocate(type_param_str_, allowed_type_strs_, description_); }
    private native void allocate(
            @StdString BytePointer type_param_str_,
            @Const @ByRef StringVector allowed_type_strs_,
            @StdString BytePointer description_);
    public TypeConstraintParam(
            @StdString String type_param_str_,
            @Const @ByRef StringVector allowed_type_strs_,
            @StdString String description_) { super((Pointer)null); allocate(type_param_str_, allowed_type_strs_, description_); }
    private native void allocate(
            @StdString String type_param_str_,
            @Const @ByRef StringVector allowed_type_strs_,
            @StdString String description_);

    // Type parameter string, for example, "T", "T1", etc.
    public native @StdString BytePointer type_param_str(); public native TypeConstraintParam type_param_str(BytePointer type_param_str);
    // Allowed type strings for <*this> type parameter, for example,
    // "tensor(float)".
    public native @ByRef StringVector allowed_type_strs(); public native TypeConstraintParam allowed_type_strs(StringVector allowed_type_strs);
    // Type parameter description.
    public native @StdString BytePointer description(); public native TypeConstraintParam description(BytePointer description);
  }

  // Grammar for type strings used in Input(), Output().
  // <type> ::= <data_type> |
  //            tensor(<data_type>) |
  //            seq(<type>) |
  //            map(<data_type>, <type>) |
  //            <type_parameter>
  // <data_type> :: = float | int32 | string | bool | uint8
  //                | int8 | uint16 | int16 | int64 | float16 | double
  // <type_parameter> ::= any type parameter string, say "T".
  //
  // NOTE: 1) <type_parameter> will always be together with a type constraints
  // specification.
  //       2) <type> ::= <data_type> means the data is scalar (zero dimension).
  //
  // Example:
  // OPERATOR_SCHEMA(Sum)
  // .Input(0, "input_a", "the first input", "T")
  // .Input(1, "input_b", "the second input", "T")
  // .Output(0, "sum", "the sum of two numbers", "T")
  // .TypeConstraint("T", {"float", "double", "int32"}, "allowed data types for
  // sum.")
  //
  // Optional = true means that the input might have empty input value
  // (represented as "") in the graph even though the later inputs have values.
  // It's useful for complex situation when there are several independent
  // optional inputs.
  public native @ByRef OpSchema Input(
        int n,
        @StdString BytePointer name,
        @StdString BytePointer description,
        @StdString BytePointer type_str,
        @Cast("onnx::OpSchema::FormalParameterOption") int param_option/*=onnx::OpSchema::Single*/);
  public native @ByRef OpSchema Input(
        int n,
        @StdString BytePointer name,
        @StdString BytePointer description,
        @StdString BytePointer type_str);
  public native @ByRef OpSchema Input(
        int n,
        @StdString String name,
        @StdString String description,
        @StdString String type_str,
        @Cast("onnx::OpSchema::FormalParameterOption") int param_option/*=onnx::OpSchema::Single*/);
  public native @ByRef OpSchema Input(
        int n,
        @StdString String name,
        @StdString String description,
        @StdString String type_str);
  public native @ByRef OpSchema Output(
        int n,
        @StdString BytePointer name,
        @StdString BytePointer description,
        @StdString BytePointer type_str);
  public native @ByRef OpSchema Output(
        int n,
        @StdString String name,
        @StdString String description,
        @StdString String type_str);
  public native @ByRef OpSchema TypeConstraint(
        @StdString BytePointer type_str,
        @Const @ByRef StringVector constraints,
        @StdString BytePointer description);
  public native @ByRef OpSchema TypeConstraint(
        @StdString String type_str,
        @Const @ByRef StringVector constraints,
        @StdString String description);

  // Calls the passed function with `this` as an argument. Useful for
  // adding docs for temlated/macro ops.
  public native @ByRef OpSchema FillUsing(@ByVal VoidOpSchemaFn populator);

  /**
   * \brief A function to allow one to get the number of outputs based on the
   * number of inputs, if this schema supports it.
   */
  public native int CalculateOutput(int num_input);

  

  public native @StdString BytePointer domain();

  public native int since_version();

  public native @Const @ByRef StringAttributeMap attributes();

  // Get input formal parameters.
  public native @Const @ByRef FormalParameterVector inputs();

  // Get output formal parameters.
  public native @Const @ByRef FormalParameterVector outputs();

  public native @Const @ByRef TypeConstraintParamVector typeConstraintParams();

  public native @StdString BytePointer Name();

  public native @Cast("const onnx::OperatorSetVersion") int SinceVersion();

  public native int min_input();
  public native int max_input();
  public native int min_output();
  public native int max_output();
}

// Map type to store operator schemas. The format is,
// <OpName, <Domain, <OperatorSetVersion, OpSchema>>>.    

/**
 * \brief A registry to hold all the operator schemas.
 */
@Namespace("onnx") public static class OpSchemaRegistry extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSchemaRegistry() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSchemaRegistry(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSchemaRegistry(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSchemaRegistry position(long position) {
        return (OpSchemaRegistry)super.position(position);
    }

  @NoOffset public static class DomainToVersionRange extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public DomainToVersionRange(Pointer p) { super(p); }
      /** Native array allocator. Access with {@link Pointer#position(long)}. */
      public DomainToVersionRange(long size) { super((Pointer)null); allocateArray(size); }
      private native void allocateArray(long size);
      @Override public DomainToVersionRange position(long position) {
          return (DomainToVersionRange)super.position(position);
      }
  
    public DomainToVersionRange() { super((Pointer)null); allocate(); }
    private native void allocate();

    public native @Const @ByRef StringIntIntPairMap Map();

    public static native @ByRef DomainToVersionRange Instance();
  }

  public static class OpSchemaRegisterOnce extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public OpSchemaRegisterOnce(Pointer p) { super(p); }
  
    public OpSchemaRegisterOnce(@ByRef OpSchema op_schema) { super((Pointer)null); allocate(op_schema); }
    private native void allocate(@ByRef OpSchema op_schema);
  }

  // Return the latest schema for an operator in specified domain.
  // Domain with default value "" means ONNX.
  public static native @Const OpSchema Schema(
        @StdString BytePointer key,
        @StdString BytePointer domain/*=""*/);
  public static native @Const OpSchema Schema(
        @StdString BytePointer key);
  public static native @Const OpSchema Schema(
        @StdString String key,
        @StdString String domain/*=""*/);
  public static native @Const OpSchema Schema(
        @StdString String key);

  // Return the schema with biggest version, which is not greater than specified
  // <maxInclusiveVersion> in specified domain. Domain with default value "" means ONNX.
  public static native @Const OpSchema Schema(
        @StdString BytePointer key,
        int maxInclusiveVersion,
        @StdString BytePointer domain/*=""*/);
  public static native @Const OpSchema Schema(
        @StdString BytePointer key,
        int maxInclusiveVersion);
  public static native @Const OpSchema Schema(
        @StdString String key,
        int maxInclusiveVersion,
        @StdString String domain/*=""*/);
  public static native @Const OpSchema Schema(
        @StdString String key,
        int maxInclusiveVersion);

// private:
  // OpSchemaRegistry should not need to be instantiated.
//  OpSchemaRegistry() = delete;

  /**
   * \brief Returns the underlying string to OpSchema map.
   *
   * You should not manually manipulate the map object returned. Instead, use
   * the macros defined such as OPERATOR_SCHEMA to register your operator
   * schema.
   *
   * We wrap it inside a function to avoid the statia initialization order
   * fiasco.
   */
  public static native @Cast("onnx::OpName_Domain_Version_Schema_Map*") @ByRef StringIntIntPairMap map();
  public static native @Const @ByVal OpSchemaVector get_all_schemas_with_history();

  public static native @Const @ByVal OpSchemaVector get_all_schemas();
}

// #define OPERATOR_SCHEMA(name)
//   static onnx::OpSchemaRegistry::OpSchemaRegisterOnce(
//       op_schema_register_once##name) = OpSchema(#name, __FILE__, __LINE__)

// Helper function
//size_t ReplaceAll(std::string& s, const char* from, const char* to);
 // namespace onnx


// Parsed from defs/data_type_utils.h

// Copyright (c) Facebook Inc. and Microsoft Corporation.
// Licensed under the MIT license.

// #ifndef ONNX_DATA_TYPE_UTILS_H
// #define ONNX_DATA_TYPE_UTILS_H

// #include <mutex>
// #include <string>
// #include <unordered_map>
// #include <unordered_set>
// #include "onnx/onnx_pb.h"
// String pointer as unique TypeProto identifier.

// Data type utility, which maintains a global type string to TypeProto map.
// DataType (string pointer) is used as unique data type identifier for
// efficiency.
//
// Grammar for data type string:
// <type> ::= <data_type> |
//            tensor(<data_type>) |
//            seq(<type>) |
//            map(<data_type>, <type>)
// <data_type> :: = float | int32 | string | bool | uint8
//                | int8 | uint16 | int16 | int64 | float16 | double
//
// NOTE: <type> ::= <data_type> means the data is scalar (zero dimension).
//
// Example: float, tensor(float), etc.
//
@Namespace("onnx::Utils") public static class DataTypeUtils extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public DataTypeUtils() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public DataTypeUtils(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DataTypeUtils(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public DataTypeUtils position(long position) {
        return (DataTypeUtils)super.position(position);
    }

  public static native @ByVal @Cast({"char*", "std::string*"}) BytePointer ToType(@StdString BytePointer type_str);
  public static native @ByVal @Cast({"char*", "std::string*"}) BytePointer ToType(@StdString String type_str);

  public static native @ByVal @Cast({"char*", "std::string*"}) BytePointer ToType(@Const @ByRef TypeProto type_proto);

  public static native @Const @ByRef TypeProto ToTypeProto(@ByRef @Cast({"char*", "std::string*"}) BytePointer data_type);
}
 // namespace Utils
 // namespace onnx

// #endif // ! ONNX_DATA_TYPE_UTILS_H


// Parsed from onnx/onnx-operators.pb.h

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: onnx-operators.proto

// #ifndef PROTOBUF_onnx_2doperators_2eproto__INCLUDED
// #define PROTOBUF_onnx_2doperators_2eproto__INCLUDED

// #include <string>

// #include <google/protobuf/stubs/common.h>

// #if GOOGLE_PROTOBUF_VERSION < 2006000
// #error This file was generated by a newer version of protoc which is
// #error incompatible with your Protocol Buffer headers.  Please update
// #error your headers.
// #endif
// #if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
// #error This file was generated by an older version of protoc which is
// #error incompatible with your Protocol Buffer headers.  Please
// #error regenerate this file with a newer version of protoc.
// #endif

// #include <google/protobuf/generated_message_util.h>
// #include <google/protobuf/message.h>
// #include <google/protobuf/repeated_field.h>
// #include <google/protobuf/extension_set.h>
// #include <google/protobuf/generated_enum_reflection.h>
// #include <google/protobuf/unknown_field_set.h>
// #include "onnx.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
@Namespace("onnx") public static native void protobuf_AddDesc_onnx_2doperators_2eproto();
@Namespace("onnx") public static native void protobuf_AssignDesc_onnx_2doperators_2eproto();
@Namespace("onnx") public static native void protobuf_ShutdownFile_onnx_2doperators_2eproto();

/** enum onnx::OperatorProto_OperatorStatus */
public static final int
  OperatorProto_OperatorStatus_EXPERIMENTAL = 0,
  OperatorProto_OperatorStatus_STABLE = 1;
@Namespace("onnx") public static native @Cast("bool") boolean OperatorProto_OperatorStatus_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::OperatorProto_OperatorStatus") int OperatorProto_OperatorStatus_OperatorStatus_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::OperatorProto_OperatorStatus") int OperatorProto_OperatorStatus_OperatorStatus_MAX();
@Namespace("onnx") @MemberGetter public static native int OperatorProto_OperatorStatus_OperatorStatus_ARRAYSIZE();

@Namespace("onnx") public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer OperatorProto_OperatorStatus_descriptor();
@Namespace("onnx") public static native @StdString BytePointer OperatorProto_OperatorStatus_Name(@Cast("onnx::OperatorProto_OperatorStatus") int value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorProto_OperatorStatus_Parse(
    @StdString BytePointer name, @Cast("onnx::OperatorProto_OperatorStatus*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorProto_OperatorStatus_Parse(
    @StdString String name, @Cast("onnx::OperatorProto_OperatorStatus*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorProto_OperatorStatus_Parse(
    @StdString BytePointer name, @Cast("onnx::OperatorProto_OperatorStatus*") int... value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorProto_OperatorStatus_Parse(
    @StdString String name, @Cast("onnx::OperatorProto_OperatorStatus*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorProto_OperatorStatus_Parse(
    @StdString BytePointer name, @Cast("onnx::OperatorProto_OperatorStatus*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorProto_OperatorStatus_Parse(
    @StdString String name, @Cast("onnx::OperatorProto_OperatorStatus*") int... value);
// ===================================================================

@Namespace("onnx") @NoOffset public static class OperatorProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OperatorProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OperatorProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public OperatorProto position(long position) {
        return (OperatorProto)super.position(position);
    }

  public OperatorProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public OperatorProto(@Const @ByRef OperatorProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef OperatorProto from);

  public native @ByRef @Name("operator =") OperatorProto put(@Const @ByRef OperatorProto from);

  public native @Const @ByRef UnknownFieldSet unknown_fields();

  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef OperatorProto default_instance();

  public native void Swap(OperatorProto other);

  // implements Message ----------------------------------------------

  public native OperatorProto New();
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef OperatorProto from);
  public native void MergeFrom(@Const @ByRef OperatorProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native int ByteSize();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer output);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer output);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] output);
  public native int GetCachedSize();
  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------
  @MemberGetter public static native @Cast("const onnx::OperatorProto::OperatorStatus") int EXPERIMENTAL();
  public static final int EXPERIMENTAL = EXPERIMENTAL();
  @MemberGetter public static native @Cast("const onnx::OperatorProto::OperatorStatus") int STABLE();
  public static final int STABLE = STABLE();
  public static native @Cast("bool") boolean OperatorStatus_IsValid(int value);
  @MemberGetter public static native @Cast("const onnx::OperatorProto::OperatorStatus") int OperatorStatus_MIN();
  public static final int OperatorStatus_MIN = OperatorStatus_MIN();
  @MemberGetter public static native @Cast("const onnx::OperatorProto::OperatorStatus") int OperatorStatus_MAX();
  public static final int OperatorStatus_MAX = OperatorStatus_MAX();
  @MemberGetter public static native int OperatorStatus_ARRAYSIZE();
  public static final int OperatorStatus_ARRAYSIZE = OperatorStatus_ARRAYSIZE();
  public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer OperatorStatus_descriptor();
  public static native @StdString BytePointer OperatorStatus_Name(@Cast("onnx::OperatorProto::OperatorStatus") int value);
  public static native @Cast("bool") boolean OperatorStatus_Parse(@StdString BytePointer name,
        @Cast("onnx::OperatorProto::OperatorStatus*") IntPointer value);
  public static native @Cast("bool") boolean OperatorStatus_Parse(@StdString String name,
        @Cast("onnx::OperatorProto::OperatorStatus*") IntBuffer value);
  public static native @Cast("bool") boolean OperatorStatus_Parse(@StdString BytePointer name,
        @Cast("onnx::OperatorProto::OperatorStatus*") int... value);
  public static native @Cast("bool") boolean OperatorStatus_Parse(@StdString String name,
        @Cast("onnx::OperatorProto::OperatorStatus*") IntPointer value);
  public static native @Cast("bool") boolean OperatorStatus_Parse(@StdString BytePointer name,
        @Cast("onnx::OperatorProto::OperatorStatus*") IntBuffer value);
  public static native @Cast("bool") boolean OperatorStatus_Parse(@StdString String name,
        @Cast("onnx::OperatorProto::OperatorStatus*") int... value);

  // accessors -------------------------------------------------------

  // optional string op_type = 1;
  public native @Cast("bool") boolean has_op_type();
  public native void clear_op_type();
  @MemberGetter public static native int kOpTypeFieldNumber();
  public static final int kOpTypeFieldNumber = kOpTypeFieldNumber();
  public native @StdString BytePointer op_type();
  public native void set_op_type(@StdString BytePointer value);
  public native void set_op_type(@StdString String value);
  public native void set_op_type(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_op_type(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_op_type();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_op_type();
  public native void set_allocated_op_type(@StdString @Cast({"char*", "std::string*"}) BytePointer op_type);

  // optional int64 since_version = 2;
  public native @Cast("bool") boolean has_since_version();
  public native void clear_since_version();
  @MemberGetter public static native int kSinceVersionFieldNumber();
  public static final int kSinceVersionFieldNumber = kSinceVersionFieldNumber();
  public native @Cast("google::protobuf::int64") long since_version();
  public native void set_since_version(@Cast("google::protobuf::int64") long value);

  // optional .onnx.OperatorProto.OperatorStatus status = 3;
  public native @Cast("bool") boolean has_status();
  public native void clear_status();
  @MemberGetter public static native int kStatusFieldNumber();
  public static final int kStatusFieldNumber = kStatusFieldNumber();
  public native @Cast("onnx::OperatorProto_OperatorStatus") int status();
  public native void set_status(@Cast("onnx::OperatorProto_OperatorStatus") int value);

  // optional string doc_string = 10;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class OperatorSetProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OperatorSetProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OperatorSetProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public OperatorSetProto position(long position) {
        return (OperatorSetProto)super.position(position);
    }

  public OperatorSetProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public OperatorSetProto(@Const @ByRef OperatorSetProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef OperatorSetProto from);

  public native @ByRef @Name("operator =") OperatorSetProto put(@Const @ByRef OperatorSetProto from);

  public native @Const @ByRef UnknownFieldSet unknown_fields();

  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef OperatorSetProto default_instance();

  public native void Swap(OperatorSetProto other);

  // implements Message ----------------------------------------------

  public native OperatorSetProto New();
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef OperatorSetProto from);
  public native void MergeFrom(@Const @ByRef OperatorSetProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native int ByteSize();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer output);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer output);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] output);
  public native int GetCachedSize();
  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string magic = 1;
  public native @Cast("bool") boolean has_magic();
  public native void clear_magic();
  @MemberGetter public static native int kMagicFieldNumber();
  public static final int kMagicFieldNumber = kMagicFieldNumber();
  public native @StdString BytePointer magic();
  public native void set_magic(@StdString BytePointer value);
  public native void set_magic(@StdString String value);
  public native void set_magic(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_magic(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_magic();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_magic();
  public native void set_allocated_magic(@StdString @Cast({"char*", "std::string*"}) BytePointer magic);

  // optional int32 ir_version = 2;
  public native @Cast("bool") boolean has_ir_version();
  public native void clear_ir_version();
  @MemberGetter public static native int kIrVersionFieldNumber();
  public static final int kIrVersionFieldNumber = kIrVersionFieldNumber();
  public native @Cast("google::protobuf::int32") int ir_version();
  public native void set_ir_version(@Cast("google::protobuf::int32") int value);

  // optional string ir_version_prerelease = 3;
  public native @Cast("bool") boolean has_ir_version_prerelease();
  public native void clear_ir_version_prerelease();
  @MemberGetter public static native int kIrVersionPrereleaseFieldNumber();
  public static final int kIrVersionPrereleaseFieldNumber = kIrVersionPrereleaseFieldNumber();
  public native @StdString BytePointer ir_version_prerelease();
  public native void set_ir_version_prerelease(@StdString BytePointer value);
  public native void set_ir_version_prerelease(@StdString String value);
  public native void set_ir_version_prerelease(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_ir_version_prerelease(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_ir_version_prerelease();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_ir_version_prerelease();
  public native void set_allocated_ir_version_prerelease(@StdString @Cast({"char*", "std::string*"}) BytePointer ir_version_prerelease);

  // optional string ir_build_metadata = 7;
  public native @Cast("bool") boolean has_ir_build_metadata();
  public native void clear_ir_build_metadata();
  @MemberGetter public static native int kIrBuildMetadataFieldNumber();
  public static final int kIrBuildMetadataFieldNumber = kIrBuildMetadataFieldNumber();
  public native @StdString BytePointer ir_build_metadata();
  public native void set_ir_build_metadata(@StdString BytePointer value);
  public native void set_ir_build_metadata(@StdString String value);
  public native void set_ir_build_metadata(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_ir_build_metadata(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_ir_build_metadata();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_ir_build_metadata();
  public native void set_allocated_ir_build_metadata(@StdString @Cast({"char*", "std::string*"}) BytePointer ir_build_metadata);

  // optional string domain = 4;
  public native @Cast("bool") boolean has_domain();
  public native void clear_domain();
  @MemberGetter public static native int kDomainFieldNumber();
  public static final int kDomainFieldNumber = kDomainFieldNumber();
  public native @StdString BytePointer domain();
  public native void set_domain(@StdString BytePointer value);
  public native void set_domain(@StdString String value);
  public native void set_domain(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_domain(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_domain();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_domain();
  public native void set_allocated_domain(@StdString @Cast({"char*", "std::string*"}) BytePointer domain);

  // optional int64 opset_version = 5;
  public native @Cast("bool") boolean has_opset_version();
  public native void clear_opset_version();
  @MemberGetter public static native int kOpsetVersionFieldNumber();
  public static final int kOpsetVersionFieldNumber = kOpsetVersionFieldNumber();
  public native @Cast("google::protobuf::int64") long opset_version();
  public native void set_opset_version(@Cast("google::protobuf::int64") long value);

  // optional string doc_string = 6;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // repeated .onnx.OperatorProto operator = 8;
  public native int operator__size();
  public native void clear_operator_();
  @MemberGetter public static native int kOperatorFieldNumber();
  public static final int kOperatorFieldNumber = kOperatorFieldNumber();
  public native @Const @ByRef OperatorProto operator_(int index);
  public native OperatorProto mutable_operator_(int index);
  public native OperatorProto add_operator_();
}
// ===================================================================


// ===================================================================

// OperatorProto

// optional string op_type = 1;












// optional int64 since_version = 2;







// optional .onnx.OperatorProto.OperatorStatus status = 3;







// optional string doc_string = 10;












// -------------------------------------------------------------------

// OperatorSetProto

// optional string magic = 1;












// optional int32 ir_version = 2;







// optional string ir_version_prerelease = 3;












// optional string ir_build_metadata = 7;












// optional string domain = 4;












// optional int64 opset_version = 5;







// optional string doc_string = 6;












// repeated .onnx.OperatorProto operator = 8;









// @@protoc_insertion_point(namespace_scope)

  // namespace onnx

// #ifndef SWIG


  // namespace google
  // namespace protobuf
// #endif  // SWIG

// @@protoc_insertion_point(global_scope)

// #endif  // PROTOBUF_onnx_2doperators_2eproto__INCLUDED


// Parsed from onnx/onnx.pb.h

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: onnx.proto

// #ifndef PROTOBUF_onnx_2eproto__INCLUDED
// #define PROTOBUF_onnx_2eproto__INCLUDED

// #include <string>

// #include <google/protobuf/stubs/common.h>

// #if GOOGLE_PROTOBUF_VERSION < 2006000
// #error This file was generated by a newer version of protoc which is
// #error incompatible with your Protocol Buffer headers.  Please update
// #error your headers.
// #endif
// #if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
// #error This file was generated by an older version of protoc which is
// #error incompatible with your Protocol Buffer headers.  Please
// #error regenerate this file with a newer version of protoc.
// #endif

// #include <google/protobuf/generated_message_util.h>
// #include <google/protobuf/message.h>
// #include <google/protobuf/repeated_field.h>
// #include <google/protobuf/extension_set.h>
// #include <google/protobuf/generated_enum_reflection.h>
// #include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
@Namespace("onnx") public static native void protobuf_AddDesc_onnx_2eproto();
@Namespace("onnx") public static native void protobuf_AssignDesc_onnx_2eproto();
@Namespace("onnx") public static native void protobuf_ShutdownFile_onnx_2eproto();

/** enum onnx::AttributeProto_AttributeType */
public static final int
  AttributeProto_AttributeType_UNDEFINED = 0,
  AttributeProto_AttributeType_FLOAT = 1,
  AttributeProto_AttributeType_INT = 2,
  AttributeProto_AttributeType_STRING = 3,
  AttributeProto_AttributeType_TENSOR = 4,
  AttributeProto_AttributeType_GRAPH = 5,
  AttributeProto_AttributeType_FLOATS = 6,
  AttributeProto_AttributeType_INTS = 7,
  AttributeProto_AttributeType_STRINGS = 8,
  AttributeProto_AttributeType_TENSORS = 9,
  AttributeProto_AttributeType_GRAPHS = 10;
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::AttributeProto_AttributeType") int AttributeProto_AttributeType_AttributeType_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::AttributeProto_AttributeType") int AttributeProto_AttributeType_AttributeType_MAX();
@Namespace("onnx") @MemberGetter public static native int AttributeProto_AttributeType_AttributeType_ARRAYSIZE();

@Namespace("onnx") public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer AttributeProto_AttributeType_descriptor();
@Namespace("onnx") public static native @StdString BytePointer AttributeProto_AttributeType_Name(@Cast("onnx::AttributeProto_AttributeType") int value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString BytePointer name, @Cast("onnx::AttributeProto_AttributeType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString String name, @Cast("onnx::AttributeProto_AttributeType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString BytePointer name, @Cast("onnx::AttributeProto_AttributeType*") int... value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString String name, @Cast("onnx::AttributeProto_AttributeType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString BytePointer name, @Cast("onnx::AttributeProto_AttributeType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString String name, @Cast("onnx::AttributeProto_AttributeType*") int... value);
/** enum onnx::TensorProto_DataType */
public static final int
  TensorProto_DataType_UNDEFINED = 0,
  TensorProto_DataType_FLOAT = 1,
  TensorProto_DataType_UINT8 = 2,
  TensorProto_DataType_INT8 = 3,
  TensorProto_DataType_UINT16 = 4,
  TensorProto_DataType_INT16 = 5,
  TensorProto_DataType_INT32 = 6,
  TensorProto_DataType_INT64 = 7,
  TensorProto_DataType_STRING = 8,
  TensorProto_DataType_BOOL = 9,
  TensorProto_DataType_FLOAT16 = 10,
  TensorProto_DataType_DOUBLE = 11,
  TensorProto_DataType_UINT32 = 12,
  TensorProto_DataType_UINT64 = 13,
  TensorProto_DataType_COMPLEX64 = 14,
  TensorProto_DataType_COMPLEX128 = 15;
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native int TensorProto_DataType_DataType_MIN();
@Namespace("onnx") @MemberGetter public static native int TensorProto_DataType_DataType_MAX();
@Namespace("onnx") @MemberGetter public static native int TensorProto_DataType_DataType_ARRAYSIZE();

@Namespace("onnx") public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer TensorProto_DataType_descriptor();
@Namespace("onnx") public static native @StdString BytePointer TensorProto_DataType_Name(int value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString BytePointer name, int value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString String name, int value);
/** enum onnx::Version */
public static final int
  _START_VERSION = 0,
  IR_VERSION_2017_10_10 = 1,
  IR_VERSION_2017_10_30 = 2,
  IR_VERSION = 3;
@Namespace("onnx") public static native @Cast("bool") boolean Version_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::Version") int Version_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::Version") int Version_MAX();
@Namespace("onnx") @MemberGetter public static native int Version_ARRAYSIZE();

@Namespace("onnx") public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer Version_descriptor();
@Namespace("onnx") public static native @StdString BytePointer Version_Name(@Cast("onnx::Version") int value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString BytePointer name, @Cast("onnx::Version*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString String name, @Cast("onnx::Version*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString BytePointer name, @Cast("onnx::Version*") int... value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString String name, @Cast("onnx::Version*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString BytePointer name, @Cast("onnx::Version*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString String name, @Cast("onnx::Version*") int... value);
// ===================================================================

@Namespace("onnx") @NoOffset public static class AttributeProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AttributeProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public AttributeProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public AttributeProto position(long position) {
        return (AttributeProto)super.position(position);
    }

  public AttributeProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public AttributeProto(@Const @ByRef AttributeProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef AttributeProto from);

  public native @ByRef @Name("operator =") AttributeProto put(@Const @ByRef AttributeProto from);

  public native @Const @ByRef UnknownFieldSet unknown_fields();

  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef AttributeProto default_instance();

  public native void Swap(AttributeProto other);

  // implements Message ----------------------------------------------

  public native AttributeProto New();
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef AttributeProto from);
  public native void MergeFrom(@Const @ByRef AttributeProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native int ByteSize();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer output);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer output);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] output);
  public native int GetCachedSize();
  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int UNDEFINED();
  public static final int UNDEFINED = UNDEFINED();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int FLOAT();
  public static final int FLOAT = FLOAT();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int INT();
  public static final int INT = INT();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int STRING();
  public static final int STRING = STRING();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int TENSOR();
  public static final int TENSOR = TENSOR();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int GRAPH();
  public static final int GRAPH = GRAPH();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int FLOATS();
  public static final int FLOATS = FLOATS();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int INTS();
  public static final int INTS = INTS();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int STRINGS();
  public static final int STRINGS = STRINGS();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int TENSORS();
  public static final int TENSORS = TENSORS();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int GRAPHS();
  public static final int GRAPHS = GRAPHS();
  public static native @Cast("bool") boolean AttributeType_IsValid(int value);
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int AttributeType_MIN();
  public static final int AttributeType_MIN = AttributeType_MIN();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int AttributeType_MAX();
  public static final int AttributeType_MAX = AttributeType_MAX();
  @MemberGetter public static native int AttributeType_ARRAYSIZE();
  public static final int AttributeType_ARRAYSIZE = AttributeType_ARRAYSIZE();
  public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer AttributeType_descriptor();
  public static native @StdString BytePointer AttributeType_Name(@Cast("onnx::AttributeProto::AttributeType") int value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString BytePointer name,
        @Cast("onnx::AttributeProto::AttributeType*") IntPointer value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString String name,
        @Cast("onnx::AttributeProto::AttributeType*") IntBuffer value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString BytePointer name,
        @Cast("onnx::AttributeProto::AttributeType*") int... value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString String name,
        @Cast("onnx::AttributeProto::AttributeType*") IntPointer value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString BytePointer name,
        @Cast("onnx::AttributeProto::AttributeType*") IntBuffer value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString String name,
        @Cast("onnx::AttributeProto::AttributeType*") int... value);

  // accessors -------------------------------------------------------

  // optional string name = 1;
  public native @Cast("bool") boolean has_name();
  public native void clear_name();
  @MemberGetter public static native int kNameFieldNumber();
  public static final int kNameFieldNumber = kNameFieldNumber();
  public native @StdString BytePointer name();
  public native void set_name(@StdString BytePointer value);
  public native void set_name(@StdString String value);
  public native void set_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_name();
  public native void set_allocated_name(@StdString @Cast({"char*", "std::string*"}) BytePointer name);

  // optional string doc_string = 13;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional .onnx.AttributeProto.AttributeType type = 20;
  public native @Cast("bool") boolean has_type();
  public native void clear_type();
  @MemberGetter public static native int kTypeFieldNumber();
  public static final int kTypeFieldNumber = kTypeFieldNumber();
  public native @Cast("onnx::AttributeProto_AttributeType") int type();
  public native void set_type(@Cast("onnx::AttributeProto_AttributeType") int value);

  // optional float f = 2;
  public native @Cast("bool") boolean has_f();
  public native void clear_f();
  @MemberGetter public static native int kFFieldNumber();
  public static final int kFFieldNumber = kFFieldNumber();
  public native float f();
  public native void set_f(float value);

  // optional int64 i = 3;
  public native @Cast("bool") boolean has_i();
  public native void clear_i();
  @MemberGetter public static native int kIFieldNumber();
  public static final int kIFieldNumber = kIFieldNumber();
  public native @Cast("google::protobuf::int64") long i();
  public native void set_i(@Cast("google::protobuf::int64") long value);

  // optional bytes s = 4;
  public native @Cast("bool") boolean has_s();
  public native void clear_s();
  @MemberGetter public static native int kSFieldNumber();
  public static final int kSFieldNumber = kSFieldNumber();
  public native @StdString BytePointer s();
  public native void set_s(@StdString BytePointer value);
  public native void set_s(@StdString String value);
  public native void set_s(@Const Pointer value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_s();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_s();
  public native void set_allocated_s(@StdString @Cast({"char*", "std::string*"}) BytePointer s);

  // optional .onnx.TensorProto t = 5;
  public native @Cast("bool") boolean has_t();
  public native void clear_t();
  @MemberGetter public static native int kTFieldNumber();
  public static final int kTFieldNumber = kTFieldNumber();
  public native @Const @ByRef TensorProto t();
  public native TensorProto mutable_t();
  public native TensorProto release_t();
  public native void set_allocated_t(TensorProto t);

  // optional .onnx.GraphProto g = 6;
  public native @Cast("bool") boolean has_g();
  public native void clear_g();
  @MemberGetter public static native int kGFieldNumber();
  public static final int kGFieldNumber = kGFieldNumber();
  public native @Const @ByRef GraphProto g();
  public native GraphProto mutable_g();
  public native GraphProto release_g();
  public native void set_allocated_g(GraphProto g);

  // repeated float floats = 7;
  public native int floats_size();
  public native void clear_floats();
  @MemberGetter public static native int kFloatsFieldNumber();
  public static final int kFloatsFieldNumber = kFloatsFieldNumber();
  public native float floats(int index);
  public native void set_floats(int index, float value);
  public native void add_floats(float value);

  // repeated int64 ints = 8;
  public native int ints_size();
  public native void clear_ints();
  @MemberGetter public static native int kIntsFieldNumber();
  public static final int kIntsFieldNumber = kIntsFieldNumber();
  public native @Cast("google::protobuf::int64") long ints(int index);
  public native void set_ints(int index, @Cast("google::protobuf::int64") long value);
  public native void add_ints(@Cast("google::protobuf::int64") long value);

  // repeated bytes strings = 9;
  public native int strings_size();
  public native void clear_strings();
  @MemberGetter public static native int kStringsFieldNumber();
  public static final int kStringsFieldNumber = kStringsFieldNumber();
  public native @StdString BytePointer strings(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_strings(int index);
  public native void set_strings(int index, @StdString BytePointer value);
  public native void set_strings(int index, @StdString String value);
  public native void set_strings(int index, @Const Pointer value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_strings();
  public native void add_strings(@StdString BytePointer value);
  public native void add_strings(@StdString String value);
  public native void add_strings(@Const Pointer value, @Cast("size_t") long size);

  // repeated .onnx.TensorProto tensors = 10;
  public native int tensors_size();
  public native void clear_tensors();
  @MemberGetter public static native int kTensorsFieldNumber();
  public static final int kTensorsFieldNumber = kTensorsFieldNumber();
  public native @Const @ByRef TensorProto tensors(int index);
  public native TensorProto mutable_tensors(int index);
  public native TensorProto add_tensors();

  // repeated .onnx.GraphProto graphs = 11;
  public native int graphs_size();
  public native void clear_graphs();
  @MemberGetter public static native int kGraphsFieldNumber();
  public static final int kGraphsFieldNumber = kGraphsFieldNumber();
  public native @Const @ByRef GraphProto graphs(int index);
  public native GraphProto mutable_graphs(int index);
  public native GraphProto add_graphs();
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class ValueInfoProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ValueInfoProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ValueInfoProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ValueInfoProto position(long position) {
        return (ValueInfoProto)super.position(position);
    }

  public ValueInfoProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public ValueInfoProto(@Const @ByRef ValueInfoProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef ValueInfoProto from);

  public native @ByRef @Name("operator =") ValueInfoProto put(@Const @ByRef ValueInfoProto from);

  public native @Const @ByRef UnknownFieldSet unknown_fields();

  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef ValueInfoProto default_instance();

  public native void Swap(ValueInfoProto other);

  // implements Message ----------------------------------------------

  public native ValueInfoProto New();
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef ValueInfoProto from);
  public native void MergeFrom(@Const @ByRef ValueInfoProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native int ByteSize();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer output);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer output);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] output);
  public native int GetCachedSize();
  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  public native @Cast("bool") boolean has_name();
  public native void clear_name();
  @MemberGetter public static native int kNameFieldNumber();
  public static final int kNameFieldNumber = kNameFieldNumber();
  public native @StdString BytePointer name();
  public native void set_name(@StdString BytePointer value);
  public native void set_name(@StdString String value);
  public native void set_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_name();
  public native void set_allocated_name(@StdString @Cast({"char*", "std::string*"}) BytePointer name);

  // optional .onnx.TypeProto type = 2;
  public native @Cast("bool") boolean has_type();
  public native void clear_type();
  @MemberGetter public static native int kTypeFieldNumber();
  public static final int kTypeFieldNumber = kTypeFieldNumber();
  public native @Const @ByRef TypeProto type();
  public native TypeProto mutable_type();
  public native TypeProto release_type();
  public native void set_allocated_type(TypeProto type);

  // optional string doc_string = 3;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class NodeProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public NodeProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public NodeProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public NodeProto position(long position) {
        return (NodeProto)super.position(position);
    }

  public NodeProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public NodeProto(@Const @ByRef NodeProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef NodeProto from);

  public native @ByRef @Name("operator =") NodeProto put(@Const @ByRef NodeProto from);

  public native @Const @ByRef UnknownFieldSet unknown_fields();

  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef NodeProto default_instance();

  public native void Swap(NodeProto other);

  // implements Message ----------------------------------------------

  public native NodeProto New();
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef NodeProto from);
  public native void MergeFrom(@Const @ByRef NodeProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native int ByteSize();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer output);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer output);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] output);
  public native int GetCachedSize();
  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string input = 1;
  public native int input_size();
  public native void clear_input();
  @MemberGetter public static native int kInputFieldNumber();
  public static final int kInputFieldNumber = kInputFieldNumber();
  public native @StdString BytePointer input(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_input(int index);
  public native void set_input(int index, @StdString BytePointer value);
  public native void set_input(int index, @StdString String value);
  public native void set_input(int index, @Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_input(int index, String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_input();
  public native void add_input(@StdString BytePointer value);
  public native void add_input(@StdString String value);
  public native void add_input(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void add_input(String value, @Cast("size_t") long size);

  // repeated string output = 2;
  public native int output_size();
  public native void clear_output();
  @MemberGetter public static native int kOutputFieldNumber();
  public static final int kOutputFieldNumber = kOutputFieldNumber();
  public native @StdString BytePointer output(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_output(int index);
  public native void set_output(int index, @StdString BytePointer value);
  public native void set_output(int index, @StdString String value);
  public native void set_output(int index, @Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_output(int index, String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_output();
  public native void add_output(@StdString BytePointer value);
  public native void add_output(@StdString String value);
  public native void add_output(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void add_output(String value, @Cast("size_t") long size);

  // optional string name = 3;
  public native @Cast("bool") boolean has_name();
  public native void clear_name();
  @MemberGetter public static native int kNameFieldNumber();
  public static final int kNameFieldNumber = kNameFieldNumber();
  public native @StdString BytePointer name();
  public native void set_name(@StdString BytePointer value);
  public native void set_name(@StdString String value);
  public native void set_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_name();
  public native void set_allocated_name(@StdString @Cast({"char*", "std::string*"}) BytePointer name);

  // optional string op_type = 4;
  public native @Cast("bool") boolean has_op_type();
  public native void clear_op_type();
  @MemberGetter public static native int kOpTypeFieldNumber();
  public static final int kOpTypeFieldNumber = kOpTypeFieldNumber();
  public native @StdString BytePointer op_type();
  public native void set_op_type(@StdString BytePointer value);
  public native void set_op_type(@StdString String value);
  public native void set_op_type(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_op_type(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_op_type();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_op_type();
  public native void set_allocated_op_type(@StdString @Cast({"char*", "std::string*"}) BytePointer op_type);

  // optional string domain = 7;
  public native @Cast("bool") boolean has_domain();
  public native void clear_domain();
  @MemberGetter public static native int kDomainFieldNumber();
  public static final int kDomainFieldNumber = kDomainFieldNumber();
  public native @StdString BytePointer domain();
  public native void set_domain(@StdString BytePointer value);
  public native void set_domain(@StdString String value);
  public native void set_domain(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_domain(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_domain();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_domain();
  public native void set_allocated_domain(@StdString @Cast({"char*", "std::string*"}) BytePointer domain);

  // repeated .onnx.AttributeProto attribute = 5;
  public native int attribute_size();
  public native void clear_attribute();
  @MemberGetter public static native int kAttributeFieldNumber();
  public static final int kAttributeFieldNumber = kAttributeFieldNumber();
  public native @Const @ByRef AttributeProto attribute(int index);
  public native AttributeProto mutable_attribute(int index);
  public native AttributeProto add_attribute();

  // optional string doc_string = 6;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class ModelProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ModelProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ModelProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ModelProto position(long position) {
        return (ModelProto)super.position(position);
    }

  public ModelProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public ModelProto(@Const @ByRef ModelProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef ModelProto from);

  public native @ByRef @Name("operator =") ModelProto put(@Const @ByRef ModelProto from);

  public native @Const @ByRef UnknownFieldSet unknown_fields();

  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef ModelProto default_instance();

  public native void Swap(ModelProto other);

  // implements Message ----------------------------------------------

  public native ModelProto New();
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef ModelProto from);
  public native void MergeFrom(@Const @ByRef ModelProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native int ByteSize();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer output);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer output);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] output);
  public native int GetCachedSize();
  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 ir_version = 1;
  public native @Cast("bool") boolean has_ir_version();
  public native void clear_ir_version();
  @MemberGetter public static native int kIrVersionFieldNumber();
  public static final int kIrVersionFieldNumber = kIrVersionFieldNumber();
  public native @Cast("google::protobuf::int64") long ir_version();
  public native void set_ir_version(@Cast("google::protobuf::int64") long value);

  // repeated .onnx.OperatorSetIdProto opset_import = 8;
  public native int opset_import_size();
  public native void clear_opset_import();
  @MemberGetter public static native int kOpsetImportFieldNumber();
  public static final int kOpsetImportFieldNumber = kOpsetImportFieldNumber();
  public native @Const @ByRef OperatorSetIdProto opset_import(int index);
  public native OperatorSetIdProto mutable_opset_import(int index);
  public native OperatorSetIdProto add_opset_import();

  // optional string producer_name = 2;
  public native @Cast("bool") boolean has_producer_name();
  public native void clear_producer_name();
  @MemberGetter public static native int kProducerNameFieldNumber();
  public static final int kProducerNameFieldNumber = kProducerNameFieldNumber();
  public native @StdString BytePointer producer_name();
  public native void set_producer_name(@StdString BytePointer value);
  public native void set_producer_name(@StdString String value);
  public native void set_producer_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_producer_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_producer_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_producer_name();
  public native void set_allocated_producer_name(@StdString @Cast({"char*", "std::string*"}) BytePointer producer_name);

  // optional string producer_version = 3;
  public native @Cast("bool") boolean has_producer_version();
  public native void clear_producer_version();
  @MemberGetter public static native int kProducerVersionFieldNumber();
  public static final int kProducerVersionFieldNumber = kProducerVersionFieldNumber();
  public native @StdString BytePointer producer_version();
  public native void set_producer_version(@StdString BytePointer value);
  public native void set_producer_version(@StdString String value);
  public native void set_producer_version(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_producer_version(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_producer_version();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_producer_version();
  public native void set_allocated_producer_version(@StdString @Cast({"char*", "std::string*"}) BytePointer producer_version);

  // optional string domain = 4;
  public native @Cast("bool") boolean has_domain();
  public native void clear_domain();
  @MemberGetter public static native int kDomainFieldNumber();
  public static final int kDomainFieldNumber = kDomainFieldNumber();
  public native @StdString BytePointer domain();
  public native void set_domain(@StdString BytePointer value);
  public native void set_domain(@StdString String value);
  public native void set_domain(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_domain(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_domain();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_domain();
  public native void set_allocated_domain(@StdString @Cast({"char*", "std::string*"}) BytePointer domain);

  // optional int64 model_version = 5;
  public native @Cast("bool") boolean has_model_version();
  public native void clear_model_version();
  @MemberGetter public static native int kModelVersionFieldNumber();
  public static final int kModelVersionFieldNumber = kModelVersionFieldNumber();
  public native @Cast("google::protobuf::int64") long model_version();
  public native void set_model_version(@Cast("google::protobuf::int64") long value);

  // optional string doc_string = 6;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional .onnx.GraphProto graph = 7;
  public native @Cast("bool") boolean has_graph();
  public native void clear_graph();
  @MemberGetter public static native int kGraphFieldNumber();
  public static final int kGraphFieldNumber = kGraphFieldNumber();
  public native @Const @ByRef GraphProto graph();
  public native GraphProto mutable_graph();
  public native GraphProto release_graph();
  public native void set_allocated_graph(GraphProto graph);

  // repeated .onnx.StringStringEntryProto metadata_props = 14;
  public native int metadata_props_size();
  public native void clear_metadata_props();
  @MemberGetter public static native int kMetadataPropsFieldNumber();
  public static final int kMetadataPropsFieldNumber = kMetadataPropsFieldNumber();
  public native @Const @ByRef StringStringEntryProto metadata_props(int index);
  public native StringStringEntryProto mutable_metadata_props(int index);
  public native StringStringEntryProto add_metadata_props();
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class StringStringEntryProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringStringEntryProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public StringStringEntryProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public StringStringEntryProto position(long position) {
        return (StringStringEntryProto)super.position(position);
    }

  public StringStringEntryProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public StringStringEntryProto(@Const @ByRef StringStringEntryProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef StringStringEntryProto from);

  public native @ByRef @Name("operator =") StringStringEntryProto put(@Const @ByRef StringStringEntryProto from);

  public native @Const @ByRef UnknownFieldSet unknown_fields();

  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef StringStringEntryProto default_instance();

  public native void Swap(StringStringEntryProto other);

  // implements Message ----------------------------------------------

  public native StringStringEntryProto New();
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef StringStringEntryProto from);
  public native void MergeFrom(@Const @ByRef StringStringEntryProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native int ByteSize();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer output);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer output);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] output);
  public native int GetCachedSize();
  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  public native @Cast("bool") boolean has_key();
  public native void clear_key();
  @MemberGetter public static native int kKeyFieldNumber();
  public static final int kKeyFieldNumber = kKeyFieldNumber();
  public native @StdString BytePointer key();
  public native void set_key(@StdString BytePointer value);
  public native void set_key(@StdString String value);
  public native void set_key(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_key(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_key();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_key();
  public native void set_allocated_key(@StdString @Cast({"char*", "std::string*"}) BytePointer key);

  // optional string value = 2;
  public native @Cast("bool") boolean has_value();
  public native void clear_value();
  @MemberGetter public static native int kValueFieldNumber();
  public static final int kValueFieldNumber = kValueFieldNumber();
  public native @StdString BytePointer value();
  public native void set_value(@StdString BytePointer value);
  public native void set_value(@StdString String value);
  public native void set_value(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_value(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_value();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_value();
  public native void set_allocated_value(@StdString @Cast({"char*", "std::string*"}) BytePointer value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class GraphProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GraphProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public GraphProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public GraphProto position(long position) {
        return (GraphProto)super.position(position);
    }

  public GraphProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public GraphProto(@Const @ByRef GraphProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef GraphProto from);

  public native @ByRef @Name("operator =") GraphProto put(@Const @ByRef GraphProto from);

  public native @Const @ByRef UnknownFieldSet unknown_fields();

  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef GraphProto default_instance();

  public native void Swap(GraphProto other);

  // implements Message ----------------------------------------------

  public native GraphProto New();
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef GraphProto from);
  public native void MergeFrom(@Const @ByRef GraphProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native int ByteSize();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer output);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer output);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] output);
  public native int GetCachedSize();
  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .onnx.NodeProto node = 1;
  public native int node_size();
  public native void clear_node();
  @MemberGetter public static native int kNodeFieldNumber();
  public static final int kNodeFieldNumber = kNodeFieldNumber();
  public native @Const @ByRef NodeProto node(int index);
  public native NodeProto mutable_node(int index);
  public native NodeProto add_node();

  // optional string name = 2;
  public native @Cast("bool") boolean has_name();
  public native void clear_name();
  @MemberGetter public static native int kNameFieldNumber();
  public static final int kNameFieldNumber = kNameFieldNumber();
  public native @StdString BytePointer name();
  public native void set_name(@StdString BytePointer value);
  public native void set_name(@StdString String value);
  public native void set_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_name();
  public native void set_allocated_name(@StdString @Cast({"char*", "std::string*"}) BytePointer name);

  // repeated .onnx.TensorProto initializer = 5;
  public native int initializer_size();
  public native void clear_initializer();
  @MemberGetter public static native int kInitializerFieldNumber();
  public static final int kInitializerFieldNumber = kInitializerFieldNumber();
  public native @Const @ByRef TensorProto initializer(int index);
  public native TensorProto mutable_initializer(int index);
  public native TensorProto add_initializer();

  // optional string doc_string = 10;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // repeated .onnx.ValueInfoProto input = 11;
  public native int input_size();
  public native void clear_input();
  @MemberGetter public static native int kInputFieldNumber();
  public static final int kInputFieldNumber = kInputFieldNumber();
  public native @Const @ByRef ValueInfoProto input(int index);
  public native ValueInfoProto mutable_input(int index);
  public native ValueInfoProto add_input();

  // repeated .onnx.ValueInfoProto output = 12;
  public native int output_size();
  public native void clear_output();
  @MemberGetter public static native int kOutputFieldNumber();
  public static final int kOutputFieldNumber = kOutputFieldNumber();
  public native @Const @ByRef ValueInfoProto output(int index);
  public native ValueInfoProto mutable_output(int index);
  public native ValueInfoProto add_output();

  // repeated .onnx.ValueInfoProto value_info = 13;
  public native int value_info_size();
  public native void clear_value_info();
  @MemberGetter public static native int kValueInfoFieldNumber();
  public static final int kValueInfoFieldNumber = kValueInfoFieldNumber();
  public native @Const @ByRef ValueInfoProto value_info(int index);
  public native ValueInfoProto mutable_value_info(int index);
  public native ValueInfoProto add_value_info();
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TensorProto_Segment extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorProto_Segment(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TensorProto_Segment(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TensorProto_Segment position(long position) {
        return (TensorProto_Segment)super.position(position);
    }

  public TensorProto_Segment() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TensorProto_Segment(@Const @ByRef TensorProto_Segment from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TensorProto_Segment from);

  public native @ByRef @Name("operator =") TensorProto_Segment put(@Const @ByRef TensorProto_Segment from);

  public native @Const @ByRef UnknownFieldSet unknown_fields();

  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TensorProto_Segment default_instance();

  public native void Swap(TensorProto_Segment other);

  // implements Message ----------------------------------------------

  public native TensorProto_Segment New();
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TensorProto_Segment from);
  public native void MergeFrom(@Const @ByRef TensorProto_Segment from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native int ByteSize();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer output);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer output);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] output);
  public native int GetCachedSize();
  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 begin = 1;
  public native @Cast("bool") boolean has_begin();
  public native void clear_begin();
  @MemberGetter public static native int kBeginFieldNumber();
  public static final int kBeginFieldNumber = kBeginFieldNumber();
  public native @Cast("google::protobuf::int64") long begin();
  public native void set_begin(@Cast("google::protobuf::int64") long value);

  // optional int64 end = 2;
  public native @Cast("bool") boolean has_end();
  public native void clear_end();
  @MemberGetter public static native int kEndFieldNumber();
  public static final int kEndFieldNumber = kEndFieldNumber();
  public native @Cast("google::protobuf::int64") long end();
  public native void set_end(@Cast("google::protobuf::int64") long value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TensorProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TensorProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TensorProto position(long position) {
        return (TensorProto)super.position(position);
    }

  public TensorProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TensorProto(@Const @ByRef TensorProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TensorProto from);

  public native @ByRef @Name("operator =") TensorProto put(@Const @ByRef TensorProto from);

  public native @Const @ByRef UnknownFieldSet unknown_fields();

  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TensorProto default_instance();

  public native void Swap(TensorProto other);

  // implements Message ----------------------------------------------

  public native TensorProto New();
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TensorProto from);
  public native void MergeFrom(@Const @ByRef TensorProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native int ByteSize();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer output);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer output);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] output);
  public native int GetCachedSize();
  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------
  @MemberGetter public static native int UNDEFINED();
  public static final int UNDEFINED = UNDEFINED();
  @MemberGetter public static native int FLOAT();
  public static final int FLOAT = FLOAT();
  @MemberGetter public static native int UINT8();
  public static final int UINT8 = UINT8();
  @MemberGetter public static native int INT8();
  public static final int INT8 = INT8();
  @MemberGetter public static native int UINT16();
  public static final int UINT16 = UINT16();
  @MemberGetter public static native int INT16();
  public static final int INT16 = INT16();
  @MemberGetter public static native int INT32();
  public static final int INT32 = INT32();
  @MemberGetter public static native int INT64();
  public static final int INT64 = INT64();
  @MemberGetter public static native int STRING();
  public static final int STRING = STRING();
  @MemberGetter public static native int BOOL();
  public static final int BOOL = BOOL();
  @MemberGetter public static native int FLOAT16();
  public static final int FLOAT16 = FLOAT16();
  @MemberGetter public static native int DOUBLE();
  public static final int DOUBLE = DOUBLE();
  @MemberGetter public static native int UINT32();
  public static final int UINT32 = UINT32();
  @MemberGetter public static native int UINT64();
  public static final int UINT64 = UINT64();
  @MemberGetter public static native int COMPLEX64();
  public static final int COMPLEX64 = COMPLEX64();
  @MemberGetter public static native int COMPLEX128();
  public static final int COMPLEX128 = COMPLEX128();
  public static native @Cast("bool") boolean DataType_IsValid(int value);
  @MemberGetter public static native int DataType_MIN();
  public static final int DataType_MIN = DataType_MIN();
  @MemberGetter public static native int DataType_MAX();
  public static final int DataType_MAX = DataType_MAX();
  @MemberGetter public static native int DataType_ARRAYSIZE();
  public static final int DataType_ARRAYSIZE = DataType_ARRAYSIZE();
  public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer DataType_descriptor();
  public static native @StdString BytePointer DataType_Name(int value);
  public static native @Cast("bool") boolean DataType_Parse(@StdString BytePointer name,
        int value);
  public static native @Cast("bool") boolean DataType_Parse(@StdString String name,
        int value);

  // accessors -------------------------------------------------------

  // repeated int64 dims = 1;
  public native int dims_size();
  public native void clear_dims();
  @MemberGetter public static native int kDimsFieldNumber();
  public static final int kDimsFieldNumber = kDimsFieldNumber();
  public native @Cast("google::protobuf::int64") long dims(int index);
  public native void set_dims(int index, @Cast("google::protobuf::int64") long value);
  public native void add_dims(@Cast("google::protobuf::int64") long value);

  // optional .onnx.TensorProto.DataType data_type = 2;
  public native @Cast("bool") boolean has_data_type();
  public native void clear_data_type();
  @MemberGetter public static native int kDataTypeFieldNumber();
  public static final int kDataTypeFieldNumber = kDataTypeFieldNumber();
  public native int data_type();
  public native void set_data_type(int value);

  // optional .onnx.TensorProto.Segment segment = 3;
  public native @Cast("bool") boolean has_segment();
  public native void clear_segment();
  @MemberGetter public static native int kSegmentFieldNumber();
  public static final int kSegmentFieldNumber = kSegmentFieldNumber();
  public native @Const @ByRef TensorProto_Segment segment();
  public native TensorProto_Segment mutable_segment();
  public native TensorProto_Segment release_segment();
  public native void set_allocated_segment(TensorProto_Segment segment);

  // repeated float float_data = 4 [packed = true];
  public native int float_data_size();
  public native void clear_float_data();
  @MemberGetter public static native int kFloatDataFieldNumber();
  public static final int kFloatDataFieldNumber = kFloatDataFieldNumber();
  public native float float_data(int index);
  public native void set_float_data(int index, float value);
  public native void add_float_data(float value);

  // repeated int32 int32_data = 5 [packed = true];
  public native int int32_data_size();
  public native void clear_int32_data();
  @MemberGetter public static native int kInt32DataFieldNumber();
  public static final int kInt32DataFieldNumber = kInt32DataFieldNumber();
  public native @Cast("google::protobuf::int32") int int32_data(int index);
  public native void set_int32_data(int index, @Cast("google::protobuf::int32") int value);
  public native void add_int32_data(@Cast("google::protobuf::int32") int value);

  // repeated bytes string_data = 6;
  public native int string_data_size();
  public native void clear_string_data();
  @MemberGetter public static native int kStringDataFieldNumber();
  public static final int kStringDataFieldNumber = kStringDataFieldNumber();
  public native @StdString BytePointer string_data(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_string_data(int index);
  public native void set_string_data(int index, @StdString BytePointer value);
  public native void set_string_data(int index, @StdString String value);
  public native void set_string_data(int index, @Const Pointer value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_string_data();
  public native void add_string_data(@StdString BytePointer value);
  public native void add_string_data(@StdString String value);
  public native void add_string_data(@Const Pointer value, @Cast("size_t") long size);

  // repeated int64 int64_data = 7 [packed = true];
  public native int int64_data_size();
  public native void clear_int64_data();
  @MemberGetter public static native int kInt64DataFieldNumber();
  public static final int kInt64DataFieldNumber = kInt64DataFieldNumber();
  public native @Cast("google::protobuf::int64") long int64_data(int index);
  public native void set_int64_data(int index, @Cast("google::protobuf::int64") long value);
  public native void add_int64_data(@Cast("google::protobuf::int64") long value);

  // optional string name = 8;
  public native @Cast("bool") boolean has_name();
  public native void clear_name();
  @MemberGetter public static native int kNameFieldNumber();
  public static final int kNameFieldNumber = kNameFieldNumber();
  public native @StdString BytePointer name();
  public native void set_name(@StdString BytePointer value);
  public native void set_name(@StdString String value);
  public native void set_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_name();
  public native void set_allocated_name(@StdString @Cast({"char*", "std::string*"}) BytePointer name);

  // optional string doc_string = 12;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional bytes raw_data = 9;
  public native @Cast("bool") boolean has_raw_data();
  public native void clear_raw_data();
  @MemberGetter public static native int kRawDataFieldNumber();
  public static final int kRawDataFieldNumber = kRawDataFieldNumber();
  public native @StdString BytePointer raw_data();
  public native void set_raw_data(@StdString BytePointer value);
  public native void set_raw_data(@StdString String value);
  public native void set_raw_data(@Const Pointer value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_raw_data();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_raw_data();
  public native void set_allocated_raw_data(@StdString @Cast({"char*", "std::string*"}) BytePointer raw_data);

  // repeated double double_data = 10 [packed = true];
  public native int double_data_size();
  public native void clear_double_data();
  @MemberGetter public static native int kDoubleDataFieldNumber();
  public static final int kDoubleDataFieldNumber = kDoubleDataFieldNumber();
  public native double double_data(int index);
  public native void set_double_data(int index, double value);
  public native void add_double_data(double value);

  // repeated uint64 uint64_data = 11 [packed = true];
  public native int uint64_data_size();
  public native void clear_uint64_data();
  @MemberGetter public static native int kUint64DataFieldNumber();
  public static final int kUint64DataFieldNumber = kUint64DataFieldNumber();
  public native @Cast("google::protobuf::uint64") long uint64_data(int index);
  public native void set_uint64_data(int index, @Cast("google::protobuf::uint64") long value);
  public native void add_uint64_data(@Cast("google::protobuf::uint64") long value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TensorShapeProto_Dimension extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorShapeProto_Dimension(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TensorShapeProto_Dimension(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TensorShapeProto_Dimension position(long position) {
        return (TensorShapeProto_Dimension)super.position(position);
    }

  public TensorShapeProto_Dimension() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TensorShapeProto_Dimension(@Const @ByRef TensorShapeProto_Dimension from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TensorShapeProto_Dimension from);

  public native @ByRef @Name("operator =") TensorShapeProto_Dimension put(@Const @ByRef TensorShapeProto_Dimension from);

  public native @Const @ByRef UnknownFieldSet unknown_fields();

  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TensorShapeProto_Dimension default_instance();

  /** enum onnx::TensorShapeProto_Dimension::ValueCase */
  public static final int
    kDimValue = 1,
    kDimParam = 2,
    VALUE_NOT_SET = 0;

  public native void Swap(TensorShapeProto_Dimension other);

  // implements Message ----------------------------------------------

  public native TensorShapeProto_Dimension New();
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TensorShapeProto_Dimension from);
  public native void MergeFrom(@Const @ByRef TensorShapeProto_Dimension from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native int ByteSize();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer output);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer output);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] output);
  public native int GetCachedSize();
  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 dim_value = 1;
  public native @Cast("bool") boolean has_dim_value();
  public native void clear_dim_value();
  @MemberGetter public static native int kDimValueFieldNumber();
  public static final int kDimValueFieldNumber = kDimValueFieldNumber();
  public native @Cast("google::protobuf::int64") long dim_value();
  public native void set_dim_value(@Cast("google::protobuf::int64") long value);

  // optional string dim_param = 2;
  public native @Cast("bool") boolean has_dim_param();
  public native void clear_dim_param();
  @MemberGetter public static native int kDimParamFieldNumber();
  public static final int kDimParamFieldNumber = kDimParamFieldNumber();
  public native @StdString BytePointer dim_param();
  public native void set_dim_param(@StdString BytePointer value);
  public native void set_dim_param(@StdString String value);
  public native void set_dim_param(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_dim_param(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_dim_param();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_dim_param();
  public native void set_allocated_dim_param(@StdString @Cast({"char*", "std::string*"}) BytePointer dim_param);

  public native @Cast("onnx::TensorShapeProto_Dimension::ValueCase") int value_case();
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TensorShapeProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorShapeProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TensorShapeProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TensorShapeProto position(long position) {
        return (TensorShapeProto)super.position(position);
    }

  public TensorShapeProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TensorShapeProto(@Const @ByRef TensorShapeProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TensorShapeProto from);

  public native @ByRef @Name("operator =") TensorShapeProto put(@Const @ByRef TensorShapeProto from);

  public native @Const @ByRef UnknownFieldSet unknown_fields();

  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TensorShapeProto default_instance();

  public native void Swap(TensorShapeProto other);

  // implements Message ----------------------------------------------

  public native TensorShapeProto New();
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TensorShapeProto from);
  public native void MergeFrom(@Const @ByRef TensorShapeProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native int ByteSize();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer output);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer output);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] output);
  public native int GetCachedSize();
  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .onnx.TensorShapeProto.Dimension dim = 1;
  public native int dim_size();
  public native void clear_dim();
  @MemberGetter public static native int kDimFieldNumber();
  public static final int kDimFieldNumber = kDimFieldNumber();
  public native @Const @ByRef TensorShapeProto_Dimension dim(int index);
  public native TensorShapeProto_Dimension mutable_dim(int index);
  public native TensorShapeProto_Dimension add_dim();
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TypeProto_Tensor extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProto_Tensor(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TypeProto_Tensor(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TypeProto_Tensor position(long position) {
        return (TypeProto_Tensor)super.position(position);
    }

  public TypeProto_Tensor() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TypeProto_Tensor(@Const @ByRef TypeProto_Tensor from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TypeProto_Tensor from);

  public native @ByRef @Name("operator =") TypeProto_Tensor put(@Const @ByRef TypeProto_Tensor from);

  public native @Const @ByRef UnknownFieldSet unknown_fields();

  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TypeProto_Tensor default_instance();

  public native void Swap(TypeProto_Tensor other);

  // implements Message ----------------------------------------------

  public native TypeProto_Tensor New();
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TypeProto_Tensor from);
  public native void MergeFrom(@Const @ByRef TypeProto_Tensor from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native int ByteSize();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer output);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer output);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] output);
  public native int GetCachedSize();
  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .onnx.TensorProto.DataType elem_type = 1;
  public native @Cast("bool") boolean has_elem_type();
  public native void clear_elem_type();
  @MemberGetter public static native int kElemTypeFieldNumber();
  public static final int kElemTypeFieldNumber = kElemTypeFieldNumber();
  public native int elem_type();
  public native void set_elem_type(int value);

  // optional .onnx.TensorShapeProto shape = 2;
  public native @Cast("bool") boolean has_shape();
  public native void clear_shape();
  @MemberGetter public static native int kShapeFieldNumber();
  public static final int kShapeFieldNumber = kShapeFieldNumber();
  public native @Const @ByRef TensorShapeProto shape();
  public native TensorShapeProto mutable_shape();
  public native TensorShapeProto release_shape();
  public native void set_allocated_shape(TensorShapeProto shape);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TypeProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TypeProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TypeProto position(long position) {
        return (TypeProto)super.position(position);
    }

  public TypeProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TypeProto(@Const @ByRef TypeProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TypeProto from);

  public native @ByRef @Name("operator =") TypeProto put(@Const @ByRef TypeProto from);

  public native @Const @ByRef UnknownFieldSet unknown_fields();

  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TypeProto default_instance();

  /** enum onnx::TypeProto::ValueCase */
  public static final int
    kTensorType = 1,
    VALUE_NOT_SET = 0;

  public native void Swap(TypeProto other);

  // implements Message ----------------------------------------------

  public native TypeProto New();
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TypeProto from);
  public native void MergeFrom(@Const @ByRef TypeProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native int ByteSize();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer output);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer output);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] output);
  public native int GetCachedSize();
  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .onnx.TypeProto.Tensor tensor_type = 1;
  public native @Cast("bool") boolean has_tensor_type();
  public native void clear_tensor_type();
  @MemberGetter public static native int kTensorTypeFieldNumber();
  public static final int kTensorTypeFieldNumber = kTensorTypeFieldNumber();
  public native @Const @ByRef TypeProto_Tensor tensor_type();
  public native TypeProto_Tensor mutable_tensor_type();
  public native TypeProto_Tensor release_tensor_type();
  public native void set_allocated_tensor_type(TypeProto_Tensor tensor_type);

  public native @Cast("onnx::TypeProto::ValueCase") int value_case();
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class OperatorSetIdProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OperatorSetIdProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OperatorSetIdProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public OperatorSetIdProto position(long position) {
        return (OperatorSetIdProto)super.position(position);
    }

  public OperatorSetIdProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public OperatorSetIdProto(@Const @ByRef OperatorSetIdProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef OperatorSetIdProto from);

  public native @ByRef @Name("operator =") OperatorSetIdProto put(@Const @ByRef OperatorSetIdProto from);

  public native @Const @ByRef UnknownFieldSet unknown_fields();

  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef OperatorSetIdProto default_instance();

  public native void Swap(OperatorSetIdProto other);

  // implements Message ----------------------------------------------

  public native OperatorSetIdProto New();
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef OperatorSetIdProto from);
  public native void MergeFrom(@Const @ByRef OperatorSetIdProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native int ByteSize();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer output);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer output);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] output);
  public native int GetCachedSize();
  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string domain = 1;
  public native @Cast("bool") boolean has_domain();
  public native void clear_domain();
  @MemberGetter public static native int kDomainFieldNumber();
  public static final int kDomainFieldNumber = kDomainFieldNumber();
  public native @StdString BytePointer domain();
  public native void set_domain(@StdString BytePointer value);
  public native void set_domain(@StdString String value);
  public native void set_domain(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_domain(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_domain();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_domain();
  public native void set_allocated_domain(@StdString @Cast({"char*", "std::string*"}) BytePointer domain);

  // optional int64 version = 2;
  public native @Cast("bool") boolean has_version();
  public native void clear_version();
  @MemberGetter public static native int kVersionFieldNumber();
  public static final int kVersionFieldNumber = kVersionFieldNumber();
  public native @Cast("google::protobuf::int64") long version();
  public native void set_version(@Cast("google::protobuf::int64") long value);
}
// ===================================================================


// ===================================================================

// AttributeProto

// optional string name = 1;












// optional string doc_string = 13;












// optional .onnx.AttributeProto.AttributeType type = 20;







// optional float f = 2;







// optional int64 i = 3;







// optional bytes s = 4;












// optional .onnx.TensorProto t = 5;









// optional .onnx.GraphProto g = 6;









// repeated float floats = 7;








// repeated int64 ints = 8;








// repeated bytes strings = 9;














// repeated .onnx.TensorProto tensors = 10;








// repeated .onnx.GraphProto graphs = 11;








// -------------------------------------------------------------------

// ValueInfoProto

// optional string name = 1;












// optional .onnx.TypeProto type = 2;









// optional string doc_string = 3;












// -------------------------------------------------------------------

// NodeProto

// repeated string input = 1;














// repeated string output = 2;














// optional string name = 3;












// optional string op_type = 4;












// optional string domain = 7;












// repeated .onnx.AttributeProto attribute = 5;








// optional string doc_string = 6;












// -------------------------------------------------------------------

// ModelProto

// optional int64 ir_version = 1;







// repeated .onnx.OperatorSetIdProto opset_import = 8;








// optional string producer_name = 2;












// optional string producer_version = 3;












// optional string domain = 4;












// optional int64 model_version = 5;







// optional string doc_string = 6;












// optional .onnx.GraphProto graph = 7;









// repeated .onnx.StringStringEntryProto metadata_props = 14;








// -------------------------------------------------------------------

// StringStringEntryProto

// optional string key = 1;












// optional string value = 2;












// -------------------------------------------------------------------

// GraphProto

// repeated .onnx.NodeProto node = 1;








// optional string name = 2;












// repeated .onnx.TensorProto initializer = 5;








// optional string doc_string = 10;












// repeated .onnx.ValueInfoProto input = 11;








// repeated .onnx.ValueInfoProto output = 12;








// repeated .onnx.ValueInfoProto value_info = 13;








// -------------------------------------------------------------------

// TensorProto_Segment

// optional int64 begin = 1;







// optional int64 end = 2;







// -------------------------------------------------------------------

// TensorProto

// repeated int64 dims = 1;








// optional .onnx.TensorProto.DataType data_type = 2;







// optional .onnx.TensorProto.Segment segment = 3;









// repeated float float_data = 4 [packed = true];








// repeated int32 int32_data = 5 [packed = true];








// repeated bytes string_data = 6;














// repeated int64 int64_data = 7 [packed = true];








// optional string name = 8;












// optional string doc_string = 12;












// optional bytes raw_data = 9;












// repeated double double_data = 10 [packed = true];








// repeated uint64 uint64_data = 11 [packed = true];








// -------------------------------------------------------------------

// TensorShapeProto_Dimension

// optional int64 dim_value = 1;






// optional string dim_param = 2;














// -------------------------------------------------------------------

// TensorShapeProto

// repeated .onnx.TensorShapeProto.Dimension dim = 1;








// -------------------------------------------------------------------

// TypeProto_Tensor

// optional .onnx.TensorProto.DataType elem_type = 1;







// optional .onnx.TensorShapeProto shape = 2;









// -------------------------------------------------------------------

// TypeProto

// optional .onnx.TypeProto.Tensor tensor_type = 1;











// -------------------------------------------------------------------

// OperatorSetIdProto

// optional string domain = 1;












// optional int64 version = 2;








// @@protoc_insertion_point(namespace_scope)

  // namespace onnx

// #ifndef SWIG




  // namespace google
  // namespace protobuf
// #endif  // SWIG

// @@protoc_insertion_point(global_scope)

// #endif  // PROTOBUF_onnx_2eproto__INCLUDED


// Parsed from google/protobuf/message_lite.h

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Authors: wink@google.com (Wink Saville),
//          kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// Defines MessageLite, the abstract interface implemented by all (lite
// and non-lite) protocol message objects.

// #ifndef GOOGLE_PROTOBUF_MESSAGE_LITE_H__
// #define GOOGLE_PROTOBUF_MESSAGE_LITE_H__

// #include <google/protobuf/stubs/common.h>
  @Namespace("google::protobuf::io") @Opaque public static class CodedInputStream extends Pointer {
      /** Empty constructor. Calls {@code super((Pointer)null)}. */
      public CodedInputStream() { super((Pointer)null); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public CodedInputStream(Pointer p) { super(p); }
  }
  @Namespace("google::protobuf::io") @Opaque public static class CodedOutputStream extends Pointer {
      /** Empty constructor. Calls {@code super((Pointer)null)}. */
      public CodedOutputStream() { super((Pointer)null); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public CodedOutputStream(Pointer p) { super(p); }
  }
  @Namespace("google::protobuf::io") @Opaque public static class ZeroCopyInputStream extends Pointer {
      /** Empty constructor. Calls {@code super((Pointer)null)}. */
      public ZeroCopyInputStream() { super((Pointer)null); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public ZeroCopyInputStream(Pointer p) { super(p); }
  }
  @Namespace("google::protobuf::io") @Opaque public static class ZeroCopyOutputStream extends Pointer {
      /** Empty constructor. Calls {@code super((Pointer)null)}. */
      public ZeroCopyOutputStream() { super((Pointer)null); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public ZeroCopyOutputStream(Pointer p) { super(p); }
  }


// Interface to light weight protocol messages.
//
// This interface is implemented by all protocol message objects.  Non-lite
// messages additionally implement the Message interface, which is a
// subclass of MessageLite.  Use MessageLite instead when you only need
// the subset of features which it supports -- namely, nothing that uses
// descriptors or reflection.  You can instruct the protocol compiler
// to generate classes which implement only MessageLite, not the full
// Message interface, by adding the following line to the .proto file:
//
//   option optimize_for = LITE_RUNTIME;
//
// This is particularly useful on resource-constrained systems where
// the full protocol buffers runtime library is too big.
//
// Note that on non-constrained systems (e.g. servers) when you need
// to link in lots of protocol definitions, a better way to reduce
// total code footprint is to use optimize_for = CODE_SIZE.  This
// will make the generated code smaller while still supporting all the
// same features (at the expense of speed).  optimize_for = LITE_RUNTIME
// is best when you only have a small number of message types linked
// into your binary, in which case the size of the protocol buffers
// runtime itself is the biggest problem.
@Namespace("google::protobuf") public static class MessageLite extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MessageLite(Pointer p) { super(p); }


  // Basic Operations ------------------------------------------------

  // Get the name of this message type, e.g. "foo.bar.BazProto".
  public native @StdString BytePointer GetTypeName();

  // Construct a new instance of the same type.  Ownership is passed to the
  // caller.
  public native MessageLite New();

  // Clear all fields of the message and set them to their default values.
  // Clear() avoids freeing memory, assuming that any memory allocated
  // to hold parts of the message will be needed again to hold the next
  // message.  If you actually want to free the memory used by a Message,
  // you must delete it.
  public native void Clear();

  // Quickly check if all required fields have values set.
  public native @Cast("bool") boolean IsInitialized();

  // This is not implemented for Lite messages -- it just returns "(cannot
  // determine missing fields for lite message)".  However, it is implemented
  // for full messages.  See message.h.
  public native @StdString BytePointer InitializationErrorString();

  // If |other| is the exact same class as this, calls MergeFrom().  Otherwise,
  // results are undefined (probably crash).
  public native void CheckTypeAndMergeFrom(@Const @ByRef MessageLite other);

  // Parsing ---------------------------------------------------------
  // Methods for parsing in protocol buffer format.  Most of these are
  // just simple wrappers around MergeFromCodedStream().  Clear() will be called
  // before merging the input.

  // Fill the message with a protocol buffer parsed from the given input
  // stream.  Returns false on a read error or if the input is in the
  // wrong format.
  public native @Cast("bool") boolean ParseFromCodedStream(CodedInputStream input);
  // Like ParseFromCodedStream(), but accepts messages that are missing
  // required fields.
  public native @Cast("bool") boolean ParsePartialFromCodedStream(CodedInputStream input);
  // Read a protocol buffer from the given zero-copy input stream.  If
  // successful, the entire input will be consumed.
  public native @Cast("bool") boolean ParseFromZeroCopyStream(ZeroCopyInputStream input);
  // Like ParseFromZeroCopyStream(), but accepts messages that are missing
  // required fields.
  public native @Cast("bool") boolean ParsePartialFromZeroCopyStream(ZeroCopyInputStream input);
  // Read a protocol buffer from the given zero-copy input stream, expecting
  // the message to be exactly "size" bytes long.  If successful, exactly
  // this many bytes will have been consumed from the input.
  public native @Cast("bool") boolean ParseFromBoundedZeroCopyStream(ZeroCopyInputStream input, int size);
  // Like ParseFromBoundedZeroCopyStream(), but accepts messages that are
  // missing required fields.
  public native @Cast("bool") boolean ParsePartialFromBoundedZeroCopyStream(ZeroCopyInputStream input,
                                               int size);
  // Parse a protocol buffer contained in a string.
  public native @Cast("bool") boolean ParseFromString(@StdString BytePointer data);
  public native @Cast("bool") boolean ParseFromString(@StdString String data);
  // Like ParseFromString(), but accepts messages that are missing
  // required fields.
  public native @Cast("bool") boolean ParsePartialFromString(@StdString BytePointer data);
  public native @Cast("bool") boolean ParsePartialFromString(@StdString String data);
  // Parse a protocol buffer contained in an array of bytes.
  public native @Cast("bool") boolean ParseFromArray(@Const Pointer data, int size);
  // Like ParseFromArray(), but accepts messages that are missing
  // required fields.
  public native @Cast("bool") boolean ParsePartialFromArray(@Const Pointer data, int size);


  // Reads a protocol buffer from the stream and merges it into this
  // Message.  Singular fields read from the input overwrite what is
  // already in the Message and repeated fields are appended to those
  // already present.
  //
  // It is the responsibility of the caller to call input->LastTagWas()
  // (for groups) or input->ConsumedEntireMessage() (for non-groups) after
  // this returns to verify that the message's end was delimited correctly.
  //
  // ParsefromCodedStream() is implemented as Clear() followed by
  // MergeFromCodedStream().
  public native @Cast("bool") boolean MergeFromCodedStream(CodedInputStream input);

  // Like MergeFromCodedStream(), but succeeds even if required fields are
  // missing in the input.
  //
  // MergeFromCodedStream() is just implemented as MergePartialFromCodedStream()
  // followed by IsInitialized().
  public native @Cast("bool") boolean MergePartialFromCodedStream(CodedInputStream input);


  // Serialization ---------------------------------------------------
  // Methods for serializing in protocol buffer format.  Most of these
  // are just simple wrappers around ByteSize() and SerializeWithCachedSizes().

  // Write a protocol buffer of this message to the given output.  Returns
  // false on a write error.  If the message is missing required fields,
  // this may GOOGLE_CHECK-fail.
  public native @Cast("bool") boolean SerializeToCodedStream(CodedOutputStream output);
  // Like SerializeToCodedStream(), but allows missing required fields.
  public native @Cast("bool") boolean SerializePartialToCodedStream(CodedOutputStream output);
  // Write the message to the given zero-copy output stream.  All required
  // fields must be set.
  public native @Cast("bool") boolean SerializeToZeroCopyStream(ZeroCopyOutputStream output);
  // Like SerializeToZeroCopyStream(), but allows missing required fields.
  public native @Cast("bool") boolean SerializePartialToZeroCopyStream(ZeroCopyOutputStream output);
  // Serialize the message and store it in the given string.  All required
  // fields must be set.
  public native @Cast("bool") boolean SerializeToString(@StdString @Cast({"char*", "std::string*"}) BytePointer output);
  // Like SerializeToString(), but allows missing required fields.
  public native @Cast("bool") boolean SerializePartialToString(@StdString @Cast({"char*", "std::string*"}) BytePointer output);
  // Serialize the message and store it in the given byte array.  All required
  // fields must be set.
  public native @Cast("bool") boolean SerializeToArray(Pointer data, int size);
  // Like SerializeToArray(), but allows missing required fields.
  public native @Cast("bool") boolean SerializePartialToArray(Pointer data, int size);

  // Make a string encoding the message. Is equivalent to calling
  // SerializeToString() on a string and using that.  Returns the empty
  // string if SerializeToString() would have returned an error.
  // Note: If you intend to generate many such strings, you may
  // reduce heap fragmentation by instead re-using the same string
  // object with calls to SerializeToString().
  public native @StdString BytePointer SerializeAsString();
  // Like SerializeAsString(), but allows missing required fields.
  public native @StdString BytePointer SerializePartialAsString();

  // Like SerializeToString(), but appends to the data to the string's existing
  // contents.  All required fields must be set.
  public native @Cast("bool") boolean AppendToString(@StdString @Cast({"char*", "std::string*"}) BytePointer output);
  // Like AppendToString(), but allows missing required fields.
  public native @Cast("bool") boolean AppendPartialToString(@StdString @Cast({"char*", "std::string*"}) BytePointer output);

  // Computes the serialized size of the message.  This recursively calls
  // ByteSize() on all embedded messages.  If a subclass does not override
  // this, it MUST override SetCachedSize().
  public native int ByteSize();

  // Serializes the message without recomputing the size.  The message must
  // not have changed since the last call to ByteSize(); if it has, the results
  // are undefined.
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);

  // Like SerializeWithCachedSizes, but writes directly to *target, returning
  // a pointer to the byte immediately after the last byte written.  "target"
  // must point at a byte array of at least ByteSize() bytes.
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] target);

  // Returns the result of the last call to ByteSize().  An embedded message's
  // size is needed both to serialize it (because embedded messages are
  // length-delimited) and to compute the outer message's size.  Caching
  // the size avoids computing it multiple times.
  //
  // ByteSize() does not automatically use the cached size when available
  // because this would require invalidating it every time the message was
  // modified, which would be too hard and expensive.  (E.g. if a deeply-nested
  // sub-message is changed, all of its parents' cached sizes would need to be
  // invalidated, which is too much work for an otherwise inlined setter
  // method.)
  public native int GetCachedSize();
}

  // namespace protobuf

  // namespace google
// #endif  // GOOGLE_PROTOBUF_MESSAGE_LITE_H__


// Parsed from google/protobuf/unknown_field_set.h

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// Contains classes used to keep track of unrecognized fields seen while
// parsing a protocol message.

// #ifndef GOOGLE_PROTOBUF_UNKNOWN_FIELD_SET_H__
// #define GOOGLE_PROTOBUF_UNKNOWN_FIELD_SET_H__

// #include <assert.h>
// #include <string>
// #include <vector>
// #include <google/protobuf/stubs/common.h>         // coded_stream.h        // coded_stream.h      // zero_copy_stream.h
  
    @Namespace("google::protobuf::internal") @Opaque public static class WireFormat extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public WireFormat() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public WireFormat(Pointer p) { super(p); }
    }               // wire_format.h
    @Namespace("google::protobuf::internal") @Opaque public static class MessageSetFieldSkipperUsingCord extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public MessageSetFieldSkipperUsingCord() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MessageSetFieldSkipperUsingCord(Pointer p) { super(p); }
    }
                                    // extension_set_heavy.cc
                        // message.h                 // below

// An UnknownFieldSet contains fields that were encountered while parsing a
// message but were not defined by its type.  Keeping track of these can be
// useful, especially in that they may be written if the message is serialized
// again without being cleared in between.  This means that software which
// simply receives messages and forwards them to other servers does not need
// to be updated every time a new field is added to the message definition.
//
// To get the UnknownFieldSet attached to any message, call
// Reflection::GetUnknownFields().
//
// This class is necessarily tied to the protocol buffer wire format, unlike
// the Reflection interface which is independent of any serialization scheme.
@Namespace("google::protobuf") @NoOffset public static class UnknownFieldSet extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public UnknownFieldSet(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public UnknownFieldSet(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public UnknownFieldSet position(long position) {
        return (UnknownFieldSet)super.position(position);
    }

  public UnknownFieldSet() { super((Pointer)null); allocate(); }
  private native void allocate();

  // Remove all fields.
  public native void Clear();

  // Remove all fields and deallocate internal data objects
  public native void ClearAndFreeMemory();

  // Is this set empty?
  public native @Cast("bool") boolean empty();

  // Merge the contents of some other UnknownFieldSet with this one.
  public native void MergeFrom(@Const @ByRef UnknownFieldSet other);

  // Swaps the contents of some other UnknownFieldSet with this one.
  public native void Swap(UnknownFieldSet x);

  // Computes (an estimate of) the total number of bytes currently used for
  // storing the unknown fields in memory. Does NOT include
  // sizeof(*this) in the calculation.
  public native int SpaceUsedExcludingSelf();

  // Version of SpaceUsed() including sizeof(*this).
  public native int SpaceUsed();

  // Returns the number of fields present in the UnknownFieldSet.
  public native int field_count();
  // Get a field in the set, where 0 <= index < field_count().  The fields
  // appear in the order in which they were added.
  public native @Const @ByRef UnknownField field(int index);
  // Get a mutable pointer to a field in the set, where
  // 0 <= index < field_count().  The fields appear in the order in which
  // they were added.
  public native UnknownField mutable_field(int index);

  // Adding fields ---------------------------------------------------

  public native void AddVarint(int number, @Cast("google::protobuf::uint64") long value);
  public native void AddFixed32(int number, @Cast("google::protobuf::uint32") int value);
  public native void AddFixed64(int number, @Cast("google::protobuf::uint64") long value);
  public native void AddLengthDelimited(int number, @StdString BytePointer value);
  public native void AddLengthDelimited(int number, @StdString String value);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer AddLengthDelimited(int number);
  public native UnknownFieldSet AddGroup(int number);

  // Adds an unknown field from another set.
  public native void AddField(@Const @ByRef UnknownField field);

  // Delete fields with indices in the range [start .. start+num-1].
  // Caution: implementation moves all fields with indices [start+num .. ].
  public native void DeleteSubrange(int start, int num);

  // Delete all fields with a specific field number. The order of left fields
  // is preserved.
  // Caution: implementation moves all fields after the first deleted field.
  public native void DeleteByNumber(int number);

  // Parsing helpers -------------------------------------------------
  // These work exactly like the similarly-named methods of Message.

  public native @Cast("bool") boolean MergeFromCodedStream(CodedInputStream input);
  public native @Cast("bool") boolean ParseFromCodedStream(CodedInputStream input);
  public native @Cast("bool") boolean ParseFromZeroCopyStream(ZeroCopyInputStream input);
  public native @Cast("bool") boolean ParseFromArray(@Const Pointer data, int size);
  public native @Cast("bool") boolean ParseFromString(@StdString BytePointer data);
  public native @Cast("bool") boolean ParseFromString(@StdString String data);
}

// Represents one field in an UnknownFieldSet.
@Namespace("google::protobuf") public static class UnknownField extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public UnknownField() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public UnknownField(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public UnknownField(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public UnknownField position(long position) {
        return (UnknownField)super.position(position);
    }

  /** enum google::protobuf::UnknownField::Type */
  public static final int
    TYPE_VARINT = 0,
    TYPE_FIXED32 = 1,
    TYPE_FIXED64 = 2,
    TYPE_LENGTH_DELIMITED = 3,
    TYPE_GROUP = 4;

  // The field's tag number, as seen on the wire.
  public native int number();

  // The field type.
  public native @Cast("google::protobuf::UnknownField::Type") int type();

  // Accessors -------------------------------------------------------
  // Each method works only for UnknownFields of the corresponding type.

  public native @Cast("google::protobuf::uint64") long varint();
  public native @Cast("google::protobuf::uint32") int fixed32();
  public native @Cast("google::protobuf::uint64") long fixed64();
  public native @StdString BytePointer length_delimited();
  public native @Const @ByRef UnknownFieldSet group();

  public native void set_varint(@Cast("google::protobuf::uint64") long value);
  public native void set_fixed32(@Cast("google::protobuf::uint32") int value);
  public native void set_fixed64(@Cast("google::protobuf::uint64") long value);
  public native void set_length_delimited(@StdString BytePointer value);
  public native void set_length_delimited(@StdString String value);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_length_delimited();
  public native UnknownFieldSet mutable_group();

  // Serialization API.
  // These methods can take advantage of the underlying implementation and may
  // archieve a better performance than using getters to retrieve the data and
  // do the serialization yourself.
  public native void SerializeLengthDelimitedNoTag(CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeLengthDelimitedNoTagToArray(@Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeLengthDelimitedNoTagToArray(@Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeLengthDelimitedNoTagToArray(@Cast("google::protobuf::uint8*") byte[] target);

  public native int GetLengthDelimitedSize();
}

// ===================================================================
// inline implementations



































  // namespace protobuf

  // namespace google
// #endif  // GOOGLE_PROTOBUF_UNKNOWN_FIELD_SET_H__


}
