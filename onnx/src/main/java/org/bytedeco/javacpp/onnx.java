// Targeted by JavaCPP version 1.4.3-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class onnx extends org.bytedeco.javacpp.presets.onnx {
    static { Loader.load(); }

@Name("std::map<std::string,onnx::OpSchema::Attribute>") public static class StringAttributeMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringAttributeMap(Pointer p) { super(p); }
    public StringAttributeMap()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef StringAttributeMap put(@ByRef StringAttributeMap x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index(function = "at") public native @ByRef OpSchema.Attribute get(@StdString BytePointer i);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter @StdString BytePointer first();
        public native @Name("operator*().second") @MemberGetter @ByRef @Const OpSchema.Attribute second();
    }
}

@Name("std::set<int>") public static class IntSet extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IntSet(Pointer p) { super(p); }
    public IntSet()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef IntSet put(@ByRef IntSet x);

    public boolean empty() { return size() == 0; }
    public native long size();

    public native void insert(int value);
    public native void erase(int value);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") int get();
    }
}

@Name("std::vector<onnx::OpSchema::TypeConstraintParam>") public static class TypeConstraintParamVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeConstraintParamVector(Pointer p) { super(p); }
    public TypeConstraintParamVector()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef TypeConstraintParamVector put(@ByRef TypeConstraintParamVector x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index(function = "at") public native @ByRef OpSchema.TypeConstraintParam get(@Cast("size_t") long i);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @ByRef @Const OpSchema.TypeConstraintParam get();
    }
}

@Name("std::vector<float>") public static class FloatVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FloatVector(Pointer p) { super(p); }
    public FloatVector(float value) { this(1); put(0, value); }
    public FloatVector(float ... array) { this(array.length); put(array); }
    public FloatVector()       { allocate();  }
    public FloatVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef FloatVector put(@ByRef FloatVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native float get(@Cast("size_t") long i);
    public native FloatVector put(@Cast("size_t") long i, float value);

    public native @ByVal Iterator insert(@ByVal Iterator pos, float value);
    public native @ByVal Iterator erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") float get();
    }

    public float[] get() {
        float[] array = new float[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public float pop_back() {
        long size = size();
        float value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public FloatVector push_back(float value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public FloatVector put(float value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public FloatVector put(float ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<int64_t>") public static class LongVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LongVector(Pointer p) { super(p); }
    public LongVector(long ... array) { this(array.length); put(array); }
    public LongVector()       { allocate();  }
    public LongVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef LongVector put(@ByRef LongVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native @Cast("int64_t") long get(@Cast("size_t") long i);
    public native LongVector put(@Cast("size_t") long i, long value);

    public native @ByVal Iterator insert(@ByVal Iterator pos, @Cast("int64_t") long value);
    public native @ByVal Iterator erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @Cast("int64_t") long get();
    }

    public long[] get() {
        long[] array = new long[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public long pop_back() {
        long size = size();
        long value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public LongVector push_back(long value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public LongVector put(long value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public LongVector put(long ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<std::string>") public static class StringVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringVector(Pointer p) { super(p); }
    public StringVector(BytePointer value) { this(1); put(0, value); }
    public StringVector(BytePointer ... array) { this(array.length); put(array); }
    public StringVector(String value) { this(1); put(0, value); }
    public StringVector(String ... array) { this(array.length); put(array); }
    public StringVector()       { allocate();  }
    public StringVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef StringVector put(@ByRef StringVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native @StdString BytePointer get(@Cast("size_t") long i);
    public native StringVector put(@Cast("size_t") long i, BytePointer value);
    @ValueSetter @Index(function = "at") public native StringVector put(@Cast("size_t") long i, @StdString String value);

    public native @ByVal Iterator insert(@ByVal Iterator pos, @StdString BytePointer value);
    public native @ByVal Iterator erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @StdString BytePointer get();
    }

    public BytePointer[] get() {
        BytePointer[] array = new BytePointer[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public BytePointer pop_back() {
        long size = size();
        BytePointer value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public StringVector push_back(BytePointer value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public StringVector put(BytePointer value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public StringVector put(BytePointer ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }

    public StringVector push_back(String value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public StringVector put(String value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public StringVector put(String ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<onnx::OpSchema>") public static class OpSchemaVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSchemaVector(Pointer p) { super(p); }
    public OpSchemaVector(OpSchema value) { this(1); put(0, value); }
    public OpSchemaVector(OpSchema ... array) { this(array.length); put(array); }
    public OpSchemaVector()       { allocate();  }
    public OpSchemaVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef OpSchemaVector put(@ByRef OpSchemaVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native @ByRef OpSchema get(@Cast("size_t") long i);
    public native OpSchemaVector put(@Cast("size_t") long i, OpSchema value);

    public native @ByVal Iterator insert(@ByVal Iterator pos, @ByRef OpSchema value);
    public native @ByVal Iterator erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @ByRef @Const OpSchema get();
    }

    public OpSchema[] get() {
        OpSchema[] array = new OpSchema[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public OpSchema pop_back() {
        long size = size();
        OpSchema value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public OpSchemaVector push_back(OpSchema value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public OpSchemaVector put(OpSchema value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public OpSchemaVector put(OpSchema ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@Name("std::vector<onnx::OpSchema::FormalParameter>") public static class FormalParameterVector extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FormalParameterVector(Pointer p) { super(p); }
    public FormalParameterVector(OpSchema.FormalParameter value) { this(1); put(0, value); }
    public FormalParameterVector(OpSchema.FormalParameter ... array) { this(array.length); put(array); }
    public FormalParameterVector()       { allocate();  }
    public FormalParameterVector(long n) { allocate(n); }
    private native void allocate();
    private native void allocate(@Cast("size_t") long n);
    public native @Name("operator=") @ByRef FormalParameterVector put(@ByRef FormalParameterVector x);

    public boolean empty() { return size() == 0; }
    public native long size();
    public void clear() { resize(0); }
    public native void resize(@Cast("size_t") long n);

    @Index(function = "at") public native @ByRef OpSchema.FormalParameter get(@Cast("size_t") long i);
    public native FormalParameterVector put(@Cast("size_t") long i, OpSchema.FormalParameter value);

    public native @ByVal Iterator insert(@ByVal Iterator pos, @ByRef OpSchema.FormalParameter value);
    public native @ByVal Iterator erase(@ByVal Iterator pos);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @ByRef @Const OpSchema.FormalParameter get();
    }

    public OpSchema.FormalParameter[] get() {
        OpSchema.FormalParameter[] array = new OpSchema.FormalParameter[size() < Integer.MAX_VALUE ? (int)size() : Integer.MAX_VALUE];
        for (int i = 0; i < array.length; i++) {
            array[i] = get(i);
        }
        return array;
    }
    @Override public String toString() {
        return java.util.Arrays.toString(get());
    }

    public OpSchema.FormalParameter pop_back() {
        long size = size();
        OpSchema.FormalParameter value = get(size - 1);
        resize(size - 1);
        return value;
    }
    public FormalParameterVector push_back(OpSchema.FormalParameter value) {
        long size = size();
        resize(size + 1);
        return put(size, value);
    }
    public FormalParameterVector put(OpSchema.FormalParameter value) {
        if (size() != 1) { resize(1); }
        return put(0, value);
    }
    public FormalParameterVector put(OpSchema.FormalParameter ... array) {
        if (size() != array.length) { resize(array.length); }
        for (int i = 0; i < array.length; i++) {
            put(i, array[i]);
        }
        return this;
    }
}

@NoOffset @Name("std::pair<int,int>") public static class UseTypeIntPair extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public UseTypeIntPair(Pointer p) { super(p); }
    public UseTypeIntPair(int firstValue, int secondValue) { this(); put(firstValue, secondValue); }
    public UseTypeIntPair()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef UseTypeIntPair put(@ByRef UseTypeIntPair x);


    @MemberGetter public native int first(); public native UseTypeIntPair first(int first);
    @MemberGetter public native int second();  public native UseTypeIntPair second(int second);

    public UseTypeIntPair put(int firstValue, int secondValue) {
        first(firstValue);
        second(secondValue);
        return this;
    }
}

@Name("std::unordered_map<std::string,int>") public static class StringIntMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringIntMap(Pointer p) { super(p); }
    public StringIntMap()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef StringIntMap put(@ByRef StringIntMap x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index public native int get(@StdString BytePointer i);
    public native StringIntMap put(@StdString BytePointer i, int value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter @StdString BytePointer first();
        public native @Name("operator*().second") @MemberGetter int second();
    }
}

@Name("std::unordered_map<std::string,std::pair<int,int> >") public static class StringIntIntPairMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringIntIntPairMap(Pointer p) { super(p); }
    public StringIntIntPairMap()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef StringIntIntPairMap put(@ByRef StringIntIntPairMap x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index(function = "at") public native int first(@StdString BytePointer i); public native StringIntIntPairMap first(@StdString BytePointer i, int first);
    @Index(function = "at") public native int second(@StdString BytePointer i);  public native StringIntIntPairMap second(@StdString BytePointer i, int second);
}

@Name("std::unordered_map<int,int>") public static class IntIntMap extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IntIntMap(Pointer p) { super(p); }
    public IntIntMap()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef IntIntMap put(@ByRef IntIntMap x);

    public boolean empty() { return size() == 0; }
    public native long size();

    @Index public native int get(int i);
    public native IntIntMap put(int i, int value);

    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*().first") @MemberGetter int first();
        public native @Name("operator*().second") @MemberGetter int second();
    }
}

@Name("std::unordered_set<std::string>") public static class StringSet extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringSet(Pointer p) { super(p); }
    public StringSet()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef StringSet put(@ByRef StringSet x);

    public boolean empty() { return size() == 0; }
    public native long size();

    public native void insert(@StdString BytePointer value);
    public native void erase(@StdString BytePointer value);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @StdString BytePointer get();
    }
}

@Name("std::unordered_set<onnx::DataType>") public static class DataTypeSet extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DataTypeSet(Pointer p) { super(p); }
    public DataTypeSet()       { allocate();  }
    private native void allocate();
    public native @Name("operator=") @ByRef DataTypeSet put(@ByRef DataTypeSet x);

    public boolean empty() { return size() == 0; }
    public native long size();

    public native void insert(@StdString @Cast({"char*", "std::string*"}) BytePointer value);
    public native void erase(@StdString @Cast({"char*", "std::string*"}) BytePointer value);
    public native @ByVal Iterator begin();
    public native @ByVal Iterator end();
    @NoOffset @Name("iterator") public static class Iterator extends Pointer {
        public Iterator(Pointer p) { super(p); }
        public Iterator() { }

        public native @Name("operator++") @ByRef Iterator increment();
        public native @Name("operator==") boolean equals(@ByRef Iterator it);
        public native @Name("operator*") @StdString @Const @Cast({"char*", "std::string*"}) BytePointer get();
    }
}

// Parsed from onnx/defs/schema.h

// Copyright (c) Facebook Inc. and Microsoft Corporation.
// Licensed under the MIT license.

// #pragma once

// #include <climits>
// #include <cstring>
// #include <functional>
// #include <initializer_list>
// #include <iostream>
// #include <limits>
// #include <ostream>
// #include <set>
// #include <string>
// #include <tuple>
// #include <unordered_map>
// #include <unordered_set>
// #include <vector>

// #include "data_type_utils.h"
// #include "onnx/common/constants.h"
// #include "onnx/defs/shape_inference.h"

@Namespace("onnx") @NoOffset public static class SchemaError extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SchemaError(Pointer p) { super(p); }


  public SchemaError(@StdString BytePointer message) { super((Pointer)null); allocate(message); }
  private native void allocate(@StdString BytePointer message);
  public SchemaError(@StdString String message) { super((Pointer)null); allocate(message); }
  private native void allocate(@StdString String message);

  public native @Cast("const char*") BytePointer what();

  public native void AppendContext(@StdString BytePointer context);
  public native void AppendContext(@StdString String context);
}

// #define fail_schema(...)
//   throw ONNX_NAMESPACE::SchemaError(ONNX_NAMESPACE::MakeString(__VA_ARGS__));

// Type constraint map. Key is type string. Value is data type set and
// description.

/**
 * \brief A class to record the schema of an op.
 *
 * OpSchema records the common interface of an op specified by its name.
 *
 * To register an OpSchema, one can use the macro ONNX_OPERATOR_SCHEMA(name) and
 * then append the various functions in the class. For example, for an op
 * that takes in two inputs, one output, and the first input and output
 * could be in-place, can be written as
 *
 *     ONNX_OPERATOR_SCHEMA(name)
 *         .NumInputs(2).NumOutputs(1).AllowConsumed({{0, 0}});
 *
 * To manufacture methods that may be used to register an OpSchema
 * non-statically, the following may be used:
 *
 *     ONNX_OPERATOR_SET_SCHEMA(name, version, OpSchema()
 *         .NumInputs(2).NumOutputs(1).AllowConsumed({{0, 0}}));
 */
@Namespace("onnx") @NoOffset public static class OpSchema extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSchema(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSchema(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public OpSchema position(long position) {
        return (OpSchema)super.position(position);
    }

  // Formal parameter options.
  /** enum onnx::OpSchema::FormalParameterOption */
  public static final byte
    // The input formal parameter is single and not optional.
    // Number of this input is 1.
    Single = 0,
    // The input formal parameter is single and optional.
    // Number of this input is 0 or 1.
    Optional = 1,
    // The input formal parameter is variadic.
    // Number of this input is [1, n].
    Variadic = 2;

  // Formal parameter represenation, including input/output name, typeStr,
  // description, and type constraints.
  @NoOffset public static class FormalParameter extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public FormalParameter(Pointer p) { super(p); }
      /** Native array allocator. Access with {@link Pointer#position(long)}. */
      public FormalParameter(long size) { super((Pointer)null); allocateArray(size); }
      private native void allocateArray(long size);
      @Override public FormalParameter position(long position) {
          return (FormalParameter)super.position(position);
      }
  
    // Constructor.
    public FormalParameter() { super((Pointer)null); allocate(); }
    private native void allocate();

    public FormalParameter(
            @StdString BytePointer name,
            @ByVal DataTypeSet type_set,
            @StdString BytePointer type_str,
            @StdString BytePointer description,
            @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/) { super((Pointer)null); allocate(name, type_set, type_str, description, param_option); }
    private native void allocate(
            @StdString BytePointer name,
            @ByVal DataTypeSet type_set,
            @StdString BytePointer type_str,
            @StdString BytePointer description,
            @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/);
    public FormalParameter(
            @StdString BytePointer name,
            @ByVal DataTypeSet type_set,
            @StdString BytePointer type_str,
            @StdString BytePointer description) { super((Pointer)null); allocate(name, type_set, type_str, description); }
    private native void allocate(
            @StdString BytePointer name,
            @ByVal DataTypeSet type_set,
            @StdString BytePointer type_str,
            @StdString BytePointer description);
    public FormalParameter(
            @StdString String name,
            @ByVal DataTypeSet type_set,
            @StdString String type_str,
            @StdString String description,
            @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/) { super((Pointer)null); allocate(name, type_set, type_str, description, param_option); }
    private native void allocate(
            @StdString String name,
            @ByVal DataTypeSet type_set,
            @StdString String type_str,
            @StdString String description,
            @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/);
    public FormalParameter(
            @StdString String name,
            @ByVal DataTypeSet type_set,
            @StdString String type_str,
            @StdString String description) { super((Pointer)null); allocate(name, type_set, type_str, description); }
    private native void allocate(
            @StdString String name,
            @ByVal DataTypeSet type_set,
            @StdString String type_str,
            @StdString String description);

    public FormalParameter(
            @StdString BytePointer name,
            @StdString BytePointer description,
            @StdString BytePointer type_str,
            @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/) { super((Pointer)null); allocate(name, description, type_str, param_option); }
    private native void allocate(
            @StdString BytePointer name,
            @StdString BytePointer description,
            @StdString BytePointer type_str,
            @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/);
    public FormalParameter(
            @StdString BytePointer name,
            @StdString BytePointer description,
            @StdString BytePointer type_str) { super((Pointer)null); allocate(name, description, type_str); }
    private native void allocate(
            @StdString BytePointer name,
            @StdString BytePointer description,
            @StdString BytePointer type_str);
    public FormalParameter(
            @StdString String name,
            @StdString String description,
            @StdString String type_str,
            @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/) { super((Pointer)null); allocate(name, description, type_str, param_option); }
    private native void allocate(
            @StdString String name,
            @StdString String description,
            @StdString String type_str,
            @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/);
    public FormalParameter(
            @StdString String name,
            @StdString String description,
            @StdString String type_str) { super((Pointer)null); allocate(name, description, type_str); }
    private native void allocate(
            @StdString String name,
            @StdString String description,
            @StdString String type_str);

    // Get formal parameter name.
    public native @StdString BytePointer GetName();

    // Get allowed data types.
    public native @Const @ByRef DataTypeSet GetTypes();

    // Get formal parameter type string.
    public native @StdString BytePointer GetTypeStr();

    // Get formal parameter description.
    public native @StdString BytePointer GetDescription();

    // Get the parameter option, it could be Single, Optional or Variadic.
    public native @Cast("onnx::OpSchema::FormalParameterOption") byte GetOption();
  }

  /** enum class onnx::OpSchema::SupportType */
  public static final byte
    COMMON = 0, // Supported by all frameworks that support this IR.
    EXPERIMENTAL = 1; // This OP is experimental and can be changed or removed in
                  // the future.

  public OpSchema() { super((Pointer)null); allocate(); }
  private native void allocate();
  public OpSchema(@StdString BytePointer name, @StdString BytePointer file, int line) { super((Pointer)null); allocate(name, file, line); }
  private native void allocate(@StdString BytePointer name, @StdString BytePointer file, int line);
  public OpSchema(@StdString String name, @StdString String file, int line) { super((Pointer)null); allocate(name, file, line); }
  private native void allocate(@StdString String name, @StdString String file, int line);

  /**
   * \brief Returns the file that the op schema is registered from.
   */
  public native @StdString BytePointer file();

  /**
   * \brief Returns the line in file that the op schema is registered from.
   */
  public native int line();

  /**
   * \brief Returns the support level of the op schema.
   */
  public native @Cast("onnx::OpSchema::SupportType") byte support_level();

  /**
   * \brief Returns the docstring of the op schema.
   */
  public native @Cast("const char*") BytePointer doc();

  /**
   * \brief Verifies if a NodeProto matches the pattern specified in
   * the schema.
   */
  public native void Verify(@Const @ByRef NodeProto node);

  // Functions to set the property of the operator schemas.
  // Sets the number of inputs, either a fixed number or a min and a max.

  /**
   * The earliest operator set version which this operator was
   * present in.  If an operator has had no BC-breaking changes,
   * this is simply the first operator set the operator was a member
   * of; if it has had BC-breaking changes, then for the semantics
   * /as described/ in the OpSchema entry, this version describes
   * the operator set which introduced the BC-breaking change.
   *
   * For example, suppose op Foo was added in v3, and had a BC-breaking
   * change in v6.  Then there will be an op schema entry for Foo with
   * SinceVersion(3), and another, updated op schema entry for Foo
   * with SinceVersion(6).
   */
  public native @ByRef OpSchema SinceVersion(@Cast("onnx::OperatorSetVersion") int n); // aka int

  /**
   * \brief Input could be one of the values specified in allowed_input_nums.
   */
  public native @ByRef OpSchema NumInputs(@ByVal IntSet allowed_input_nums);

  /**
   * \brief Output could be one of the values specified in allowed_output_nums.
   */
  public native @ByRef OpSchema NumOutputs(@ByVal IntSet allowed_output_nums);

  // Shape Inference
  //
  // Note that signatures are defined to allow for forward-declaring
  // any structs used from ir.h
  public native @ByRef OpSchema TypeAndShapeInferenceFunction(@ByVal InferenceFunction inferenceFunction);
  

  // Set the support level for the op schema.
  public native @ByRef OpSchema SetSupportLevel(@Cast("onnx::OpSchema::SupportType") byte supportType);

  // Functions to do documentation for the operator schema.
  // This may be disabled to save memory.
  public native @ByRef OpSchema SetDoc(@Cast("const char*") BytePointer doc);
  public native @ByRef OpSchema SetDoc(String doc);

  // Functions to specify name for the operator schema.
  public native @ByRef OpSchema SetName(@Cast("const char*") BytePointer name);
  public native @ByRef OpSchema SetName(String name);

  // Functions to specify code location for the operator schema.
  public native @ByRef OpSchema SetLocation(@Cast("const char*") BytePointer file, int line);
  public native @ByRef OpSchema SetLocation(String file, int line);

  // Functions to specify domain for the operator schema.
  // Default domain value (ONNX_DOMAIN) means it's ONNX domain.
  public native @ByRef OpSchema SetDomain(@Cast("const char*") BytePointer domain);
  public native @ByRef OpSchema SetDomain(String domain);

  @NoOffset public static class Attribute extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public Attribute(Pointer p) { super(p); }
  
    public Attribute(
            @StdString BytePointer name_,
            @StdString BytePointer description_,
            @Cast("onnx::AttributeProto::AttributeType") int type_,
            @Cast("bool") boolean required_) { super((Pointer)null); allocate(name_, description_, type_, required_); }
    private native void allocate(
            @StdString BytePointer name_,
            @StdString BytePointer description_,
            @Cast("onnx::AttributeProto::AttributeType") int type_,
            @Cast("bool") boolean required_);
    public Attribute(
            @StdString String name_,
            @StdString String description_,
            @Cast("onnx::AttributeProto::AttributeType") int type_,
            @Cast("bool") boolean required_) { super((Pointer)null); allocate(name_, description_, type_, required_); }
    private native void allocate(
            @StdString String name_,
            @StdString String description_,
            @Cast("onnx::AttributeProto::AttributeType") int type_,
            @Cast("bool") boolean required_);

    public Attribute(
            @StdString BytePointer name_,
            @StdString BytePointer description_,
            @ByVal AttributeProto default_value_) { super((Pointer)null); allocate(name_, description_, default_value_); }
    private native void allocate(
            @StdString BytePointer name_,
            @StdString BytePointer description_,
            @ByVal AttributeProto default_value_);
    public Attribute(
            @StdString String name_,
            @StdString String description_,
            @ByVal AttributeProto default_value_) { super((Pointer)null); allocate(name_, description_, default_value_); }
    private native void allocate(
            @StdString String name_,
            @StdString String description_,
            @ByVal AttributeProto default_value_);

    @MemberGetter public native @StdString BytePointer name();
    @MemberGetter public native @StdString BytePointer description();
    public native @Cast("onnx::AttributeProto::AttributeType") int type(); public native Attribute type(int type);
    public native @Cast("bool") boolean required(); public native Attribute required(boolean required);
    public native @ByRef AttributeProto default_value(); public native Attribute default_value(AttributeProto default_value);
  }

  public native @ByRef OpSchema Attr(@ByVal Attribute attr);

// Register "optional" attribute with default value.
// #define ATTR_SETTER_WITH_DEFAULT_VALUE(TypeName)
//   OpSchema& Attr(
//       std::string name,
//       std::string description,
//       AttributeProto::AttributeType type,
//       const TypeName& defaultValue);
//   /* non-STL wrapper to reduce binary size */
//   OpSchema& Attr(
//       const char* name,
//       const char* description,
//       AttributeProto::AttributeType type,
//       const TypeName& defaultValue);
//   OpSchema& Attr(
//       std::string name,
//       std::string description,
//       AttributeProto::AttributeType type,
//       const std::vector<TypeName>& defaultValue);

  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Cast("const int64_t") long defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Cast("const int64_t") long defaultValue);
  /* non-STL wrapper to reduce binary size */
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef LongVector defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef LongVector defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        float defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        float defaultValue);
  /* non-STL wrapper to reduce binary size */
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef FloatVector defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef FloatVector defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @StdString BytePointer defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @StdString String defaultValue);
  /* non-STL wrapper to reduce binary size */
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef StringVector defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef StringVector defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef TensorProto defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef TensorProto defaultValue);
  /* non-STL wrapper to reduce binary size */
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef GraphProto defaultValue);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Const @ByRef GraphProto defaultValue);
  /* non-STL wrapper to reduce binary size */

  // Register "required" attribute without default value.
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Cast("bool") boolean required/*=true*/);
  public native @ByRef OpSchema Attr(
        @StdString BytePointer name,
        @StdString BytePointer description,
        @Cast("onnx::AttributeProto::AttributeType") int type);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type,
        @Cast("bool") boolean required/*=true*/);
  public native @ByRef OpSchema Attr(
        @StdString String name,
        @StdString String description,
        @Cast("onnx::AttributeProto::AttributeType") int type);

  // Non-STL wrapper to reduce binary size

  public native @ByRef OpSchema AllowUncheckedAttributes();

  // Type constraint.
  @NoOffset public static class TypeConstraintParam extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public TypeConstraintParam(Pointer p) { super(p); }
  
    public TypeConstraintParam(
            @StdString BytePointer type_param_str_,
            @ByVal StringVector allowed_type_strs_,
            @StdString BytePointer description_) { super((Pointer)null); allocate(type_param_str_, allowed_type_strs_, description_); }
    private native void allocate(
            @StdString BytePointer type_param_str_,
            @ByVal StringVector allowed_type_strs_,
            @StdString BytePointer description_);
    public TypeConstraintParam(
            @StdString String type_param_str_,
            @ByVal StringVector allowed_type_strs_,
            @StdString String description_) { super((Pointer)null); allocate(type_param_str_, allowed_type_strs_, description_); }
    private native void allocate(
            @StdString String type_param_str_,
            @ByVal StringVector allowed_type_strs_,
            @StdString String description_);

    // Type parameter string, for example, "T", "T1", etc.
    public native @StdString BytePointer type_param_str(); public native TypeConstraintParam type_param_str(BytePointer type_param_str);
    // Allowed type strings for <*this> type parameter, for example,
    // "tensor(float)".
    public native @ByRef StringVector allowed_type_strs(); public native TypeConstraintParam allowed_type_strs(StringVector allowed_type_strs);
    // Type parameter description.
    public native @StdString BytePointer description(); public native TypeConstraintParam description(BytePointer description);
  }

  // Grammar for type strings used in Input(), Output().
  // <type> ::= <data_type> |
  //            tensor(<data_type>) |
  //            seq(<type>) |
  //            map(<data_type>, <type>) |
  //            <type_parameter>
  // <data_type> :: = float | int32 | string | bool | uint8
  //                | int8 | uint16 | int16 | int64 | float16 | double
  // <type_parameter> ::= any type parameter string, say "T".
  //
  // NOTE: 1) <type_parameter> will always be together with a type constraints
  // specification.
  //       2) <type> ::= <data_type> means the data is scalar (zero dimension).
  //
  // Example:
  // ONNX_OPERATOR_SET_SCHEMA(Sum, 1, OpSchema()
  // .Input(0, "input_a", "the first input", "T")
  // .Input(1, "input_b", "the second input", "T")
  // .Output(0, "sum", "the sum of two numbers", "T")
  // .TypeConstraint("T", {"float", "double", "int32"}, "allowed data types for
  // sum."))
  //
  // Optional = true means that the input might have empty input value
  // (represented as "") in the graph even though the later inputs have values.
  // It's useful for complex situation when there are several independent
  // optional inputs.
  public native @ByRef OpSchema Input(
        int n,
        @StdString BytePointer name,
        @StdString BytePointer description,
        @StdString BytePointer type_str,
        @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/);
  public native @ByRef OpSchema Input(
        int n,
        @StdString BytePointer name,
        @StdString BytePointer description,
        @StdString BytePointer type_str);
  public native @ByRef OpSchema Input(
        int n,
        @StdString String name,
        @StdString String description,
        @StdString String type_str,
        @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/);
  public native @ByRef OpSchema Input(
        int n,
        @StdString String name,
        @StdString String description,
        @StdString String type_str);

  // Non-STL wrapper to reduce binary size
  public native @ByRef OpSchema Output(
        int n,
        @StdString BytePointer name,
        @StdString BytePointer description,
        @StdString BytePointer type_str,
        @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/);
  public native @ByRef OpSchema Output(
        int n,
        @StdString BytePointer name,
        @StdString BytePointer description,
        @StdString BytePointer type_str);
  public native @ByRef OpSchema Output(
        int n,
        @StdString String name,
        @StdString String description,
        @StdString String type_str,
        @Cast("onnx::OpSchema::FormalParameterOption") byte param_option/*=onnx::OpSchema::Single*/);
  public native @ByRef OpSchema Output(
        int n,
        @StdString String name,
        @StdString String description,
        @StdString String type_str);

  // Non-STL wrapper to reduce binary size
  public native @ByRef OpSchema TypeConstraint(
        @StdString BytePointer type_str,
        @ByVal StringVector constraints,
        @StdString BytePointer description);
  public native @ByRef OpSchema TypeConstraint(
        @StdString String type_str,
        @ByVal StringVector constraints,
        @StdString String description);

  // Non-STL wrapper to reduce binary size

  // Convenience members for types

  // All high-precision numeric types.
  public static native @Const @ByRef StringVector numeric_types_for_math_reduction();

  public static native @Const @ByRef StringVector all_numeric_types();

  public static native @Const @ByRef StringVector all_tensor_types();

  // Calls the passed function with `this` as an argument. Useful for
  // adding docs for temlated/macro ops.
  public native @ByRef OpSchema FillUsing(@Const @ByRef VoidOpSchemaFn populator);

  

  public native @StdString BytePointer domain();

  public native int since_version();
  public native @Const @ByRef StringAttributeMap attributes();

  // Get input formal parameters.
  public native @Const @ByRef FormalParameterVector inputs();

  // Get output formal parameters.
  public native @Const @ByRef FormalParameterVector outputs();

  public native @Const @ByRef TypeConstraintParamVector typeConstraintParams();

  public native @StdString BytePointer Name();

  public native @Cast("const onnx::OperatorSetVersion") int SinceVersion();

  public native int min_input();
  public native int max_input();
  public native int min_output();
  public native int max_output();

  public native @Cast("bool") boolean has_type_and_shape_inference_function();

  // Verifies that the schema is valid and all specifications are compatible.
  // It will also parse all type strings specified for inputs/outputs into valid
  // TypeProto and create global unique string pointer as the DataType for
  // efficiency.
  public native void Finalize();
}

// Map type to store operator schemas. The format is,
// <OpName, <Domain, <OperatorSetVersion, OpSchema>>>.

@Namespace("onnx") public static class ISchemaRegistry extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ISchemaRegistry(Pointer p) { super(p); }


  public native @Const OpSchema GetSchema(
        @StdString BytePointer key,
        int maxInclusiveVersion,
        @StdString BytePointer domain/*=ONNX_DOMAIN*/);
  public native @Const OpSchema GetSchema(
        @StdString BytePointer key,
        int maxInclusiveVersion);
  public native @Const OpSchema GetSchema(
        @StdString String key,
        int maxInclusiveVersion,
        @StdString String domain/*=ONNX_DOMAIN*/);
  public native @Const OpSchema GetSchema(
        @StdString String key,
        int maxInclusiveVersion);
}

/**
 * \brief A registry to hold all the operator schemas.
 */
@Namespace("onnx") public static class OpSchemaRegistry extends ISchemaRegistry {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSchemaRegistry(Pointer p) { super(p); }

  // A singleton class to store domain to min/max op_set version map.
  @NoOffset public static class DomainToVersionRange extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public DomainToVersionRange(Pointer p) { super(p); }
      /** Native array allocator. Access with {@link Pointer#position(long)}. */
      public DomainToVersionRange(long size) { super((Pointer)null); allocateArray(size); }
      private native void allocateArray(long size);
      @Override public DomainToVersionRange position(long position) {
          return (DomainToVersionRange)super.position(position);
      }
  
    public DomainToVersionRange() { super((Pointer)null); allocate(); }
    private native void allocate();

    public native @Const @ByRef StringIntIntPairMap Map();

    // Add customized domain to min/max version.
    // Onnx partners are able to use onnx operator schema api to
    // register customized op in their own domain.
    public native void AddDomainToVersion(
            @StdString BytePointer domain,
            int min_version,
            int max_version);
    public native void AddDomainToVersion(
            @StdString String domain,
            int min_version,
            int max_version);

    public static native @ByRef DomainToVersionRange Instance();
  }

  public static class OpSchemaRegisterOnce extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public OpSchemaRegisterOnce(Pointer p) { super(p); }
  
    public OpSchemaRegisterOnce(@ByRef OpSchema op_schema) { super((Pointer)null); allocate(op_schema); }
    private native void allocate(@ByRef OpSchema op_schema);
  }

  // Return the latest schema for an operator in specified domain.
  // Domain with default value ONNX_DOMAIN means ONNX.
  public static native @Const OpSchema Schema(
        @StdString BytePointer key,
        @StdString BytePointer domain/*=ONNX_DOMAIN*/);
  public static native @Const OpSchema Schema(
        @StdString BytePointer key);
  public static native @Const OpSchema Schema(
        @StdString String key,
        @StdString String domain/*=ONNX_DOMAIN*/);
  public static native @Const OpSchema Schema(
        @StdString String key);

  // Return the schema with biggest version, which is not greater than specified
  // <maxInclusiveVersion> in specified domain. Domain with default value
  // ONNX_DOMAIN means ONNX.
  public static native @Const OpSchema Schema(
        @StdString BytePointer key,
        int maxInclusiveVersion,
        @StdString BytePointer domain/*=ONNX_DOMAIN*/);
  public static native @Const OpSchema Schema(
        @StdString BytePointer key,
        int maxInclusiveVersion);
  public static native @Const OpSchema Schema(
        @StdString String key,
        int maxInclusiveVersion,
        @StdString String domain/*=ONNX_DOMAIN*/);
  public static native @Const OpSchema Schema(
        @StdString String key,
        int maxInclusiveVersion);

  public static native OpSchemaRegistry Instance();

  public native @Const OpSchema GetSchema(
        @StdString BytePointer key,
        int maxInclusiveVersion,
        @StdString BytePointer domain/*=ONNX_DOMAIN*/);
  public native @Const OpSchema GetSchema(
        @StdString BytePointer key,
        int maxInclusiveVersion);
  public native @Const OpSchema GetSchema(
        @StdString String key,
        int maxInclusiveVersion,
        @StdString String domain/*=ONNX_DOMAIN*/);
  public native @Const OpSchema GetSchema(
        @StdString String key,
        int maxInclusiveVersion);
  public static native @Const @ByVal OpSchemaVector get_all_schemas_with_history();

  public static native @Const @ByVal OpSchemaVector get_all_schemas();
}



// Registers all schema of a given operator set

// Forward declaration for the non-specialized GetOpSchema method.  This
// enforces a consistent signature on functions that query individual schema,
// which are defined as specializations of this function.

// #define ONNX_OPERATOR_SET_SCHEMA(name, ver, impl)
//   ONNX_OPERATOR_SET_SCHEMA_EX(name, Onnx, ONNX_DOMAIN, ver, true, impl)

// #define ONNX_ML_OPERATOR_SET_SCHEMA(name, ver, impl)
//   ONNX_OPERATOR_SET_SCHEMA_EX(name, OnnxML, AI_ONNX_ML_DOMAIN, ver, true, impl)

// Defines specialization of GetOpSchema for a class whose name is determined
// based on a convention using name, domain, and version.  Operator schema are
// normally included in operator sets and registered in OpSchemaRegistry::map().
// In this case, callers should set dbg_included_in_static_opset to true.  This
// assists with runtime validation in in DEBUG builds ensuring the intended set
// of operator schema is registered.
// #define ONNX_OPERATOR_SET_SCHEMA_EX(
//     name, domain, domain_str, ver, dbg_included_in_static_opset, impl)
//   class ONNX_OPERATOR_SET_SCHEMA_CLASS_NAME(domain, ver, name);
//   template <>
//   OpSchema
//   GetOpSchema<ONNX_OPERATOR_SET_SCHEMA_CLASS_NAME(domain, ver, name)>() {
//     return impl.SetName(#name)
//         .SetDomain(domain_str)
//         .SinceVersion(ver)
//         .SetLocation(__FILE__, __LINE__);
//   }
//   size_t dbg_count_check_##name##_##domain##_ver##ver =
//       (dbg_included_in_static_opset) ? ONNX_DBG_INCREMENT_COUNT_IN_OPSETS()
//                                      : 0;

// #ifdef NDEBUG
// #define ONNX_DBG_INCREMENT_COUNT_IN_OPSETS() 0
// #else
// #define ONNX_DBG_INCREMENT_COUNT_IN_OPSETS()
//   DbgOperatorSetTracker::Instance().IncrementCount()
// #define ONNX_DBG_GET_COUNT_IN_OPSETS()
//   DbgOperatorSetTracker::Instance().GetCount()

@Namespace("onnx") public static class DbgOperatorSetTracker extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public DbgOperatorSetTracker() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public DbgOperatorSetTracker(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DbgOperatorSetTracker(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public DbgOperatorSetTracker position(long position) {
        return (DbgOperatorSetTracker)super.position(position);
    }

  public static native @ByRef DbgOperatorSetTracker Instance();

  public native @Cast("size_t") long IncrementCount();

  public native @Cast("size_t") long GetCount();
}
// #endif

// Naming convention for operator schema classes
// #define ONNX_OPERATOR_SET_SCHEMA_CLASS_NAME(domain, ver, name)
//   name##_##domain##_ver##ver

// Helper function


// Legacy macros to register schema at static initialization
// #define ONNX_OPERATOR_SCHEMA(name)
//   ONNX_OPERATOR_SCHEMA_UNIQ_HELPER(__COUNTER__, name)
// #define ONNX_OPERATOR_SCHEMA_UNIQ_HELPER(Counter, name)
//   ONNX_OPERATOR_SCHEMA_UNIQ(Counter, name)
// #define ONNX_OPERATOR_SCHEMA_UNIQ(Counter, name)
//   static ONNX_NAMESPACE::OpSchemaRegistry::OpSchemaRegisterOnce(
//       op_schema_register_once##name##Counter) =
//       OpSchema(#name, __FILE__, __LINE__)

// Helper function


@Namespace("onnx") public static native @StdString BytePointer GenerateOptionalArgumentsDoc();

@Namespace("onnx") public static native @StdString BytePointer GenerateBroadcastingDocMul();

@Namespace("onnx") public static native @StdString BytePointer GenerateBroadcastingDocUni(
    @Cast("const char*") BytePointer from,
    @Cast("const char*") BytePointer to);
@Namespace("onnx") public static native @StdString String GenerateBroadcastingDocUni(
    String from,
    String to);

 // namespace ONNX_NAMESPACE


// Parsed from onnx/defs/operator_sets.h

// Copyright (c) Facebook Inc. and Microsoft Corporation.
// Licensed under the MIT license.

// #pragma once

// #include "onnx/defs/schema.h"

// Forward declarations for ai.onnx version 1
@Namespace("onnx") @Opaque public static class ATen_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ATen_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ATen_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Abs_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Abs_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Abs_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Add_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Add_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Add_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Affine_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Affine_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Affine_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class And_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public And_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public And_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ArgMax_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ArgMax_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ArgMax_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ArgMin_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ArgMin_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ArgMin_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class AveragePool_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public AveragePool_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AveragePool_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class BatchNormalization_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public BatchNormalization_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public BatchNormalization_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Cast_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Cast_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Cast_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Ceil_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Ceil_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Ceil_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Clip_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Clip_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Clip_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Concat_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Concat_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Concat_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Constant_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Constant_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Constant_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ConstantFill_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ConstantFill_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ConstantFill_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Conv_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Conv_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Conv_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ConvTranspose_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ConvTranspose_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ConvTranspose_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Crop_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Crop_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Crop_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class DepthToSpace_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public DepthToSpace_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DepthToSpace_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Div_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Div_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Div_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Dropout_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Dropout_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Dropout_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Elu_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Elu_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Elu_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Equal_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Equal_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Equal_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Exp_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Exp_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Exp_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Flatten_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Flatten_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Flatten_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Floor_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Floor_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Floor_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class GRU_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GRU_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GRU_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class GRUUnit_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GRUUnit_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GRUUnit_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Gather_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Gather_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Gather_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Gemm_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Gemm_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Gemm_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class GivenTensorFill_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GivenTensorFill_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GivenTensorFill_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class GlobalAveragePool_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GlobalAveragePool_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GlobalAveragePool_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class GlobalLpPool_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GlobalLpPool_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GlobalLpPool_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class GlobalMaxPool_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GlobalMaxPool_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GlobalMaxPool_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Greater_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Greater_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Greater_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class HardSigmoid_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public HardSigmoid_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public HardSigmoid_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Hardmax_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Hardmax_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Hardmax_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Identity_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Identity_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Identity_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class If_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public If_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public If_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ImageScaler_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ImageScaler_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ImageScaler_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class InstanceNormalization_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public InstanceNormalization_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public InstanceNormalization_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LRN_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LRN_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LRN_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LSTM_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LSTM_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LSTM_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LeakyRelu_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LeakyRelu_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LeakyRelu_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Less_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Less_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Less_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Log_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Log_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Log_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LogSoftmax_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LogSoftmax_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LogSoftmax_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Loop_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Loop_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Loop_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LoopIndexTensor_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LoopIndexTensor_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LoopIndexTensor_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LpNormalization_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LpNormalization_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LpNormalization_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LpPool_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LpPool_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LpPool_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class MatMul_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public MatMul_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MatMul_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Max_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Max_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Max_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class MaxPool_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public MaxPool_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MaxPool_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class MaxRoiPool_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public MaxRoiPool_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MaxRoiPool_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Mean_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Mean_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Mean_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class MeanVarianceNormalization_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public MeanVarianceNormalization_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MeanVarianceNormalization_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Min_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Min_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Min_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Mul_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Mul_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Mul_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Neg_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Neg_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Neg_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Not_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Not_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Not_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Or_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Or_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Or_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class PRelu_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public PRelu_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PRelu_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Pad_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Pad_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Pad_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ParametricSoftplus_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ParametricSoftplus_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ParametricSoftplus_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Pow_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Pow_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Pow_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class RNN_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public RNN_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RNN_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class RandomNormal_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public RandomNormal_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RandomNormal_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class RandomNormalLike_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public RandomNormalLike_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RandomNormalLike_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class RandomUniform_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public RandomUniform_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RandomUniform_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class RandomUniformLike_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public RandomUniformLike_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RandomUniformLike_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Reciprocal_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Reciprocal_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Reciprocal_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceL1_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceL1_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceL1_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceL2_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceL2_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceL2_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceLogSum_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceLogSum_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceLogSum_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceLogSumExp_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceLogSumExp_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceLogSumExp_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceMax_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceMax_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceMax_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceMean_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceMean_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceMean_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceMin_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceMin_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceMin_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceProd_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceProd_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceProd_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceSum_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceSum_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceSum_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ReduceSumSquare_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ReduceSumSquare_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ReduceSumSquare_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Relu_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Relu_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Relu_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Reshape_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Reshape_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Reshape_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Scale_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Scale_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Scale_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ScaledTanh_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ScaledTanh_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ScaledTanh_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Selu_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Selu_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Selu_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Shape_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Shape_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Shape_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sigmoid_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sigmoid_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sigmoid_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Size_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Size_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Size_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Slice_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Slice_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Slice_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Softmax_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Softmax_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Softmax_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Softplus_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Softplus_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Softplus_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Softsign_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Softsign_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Softsign_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class SpaceToDepth_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public SpaceToDepth_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SpaceToDepth_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Split_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Split_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Split_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sqrt_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sqrt_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sqrt_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Squeeze_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Squeeze_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Squeeze_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sub_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sub_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sub_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sum_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sum_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sum_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Tanh_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Tanh_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Tanh_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ThresholdedRelu_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ThresholdedRelu_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ThresholdedRelu_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Tile_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Tile_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Tile_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class TopK_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TopK_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TopK_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Transpose_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Transpose_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Transpose_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Unsqueeze_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Unsqueeze_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Unsqueeze_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Upsample_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Upsample_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Upsample_Onnx_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Xor_Onnx_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Xor_Onnx_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Xor_Onnx_ver1(Pointer p) { super(p); }
}

// Iterate over schema from ai.onnx version 1
@Namespace("onnx") public static class OpSet_Onnx_ver1 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSet_Onnx_ver1() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSet_Onnx_ver1(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSet_Onnx_ver1(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSet_Onnx_ver1 position(long position) {
        return (OpSet_Onnx_ver1)super.position(position);
    }

}

// Forward declarations for ai.onnx version 2
@Namespace("onnx") @Opaque public static class GlobalLpPool_Onnx_ver2 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GlobalLpPool_Onnx_ver2() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GlobalLpPool_Onnx_ver2(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LpPool_Onnx_ver2 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LpPool_Onnx_ver2() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LpPool_Onnx_ver2(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Pad_Onnx_ver2 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Pad_Onnx_ver2() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Pad_Onnx_ver2(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Split_Onnx_ver2 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Split_Onnx_ver2() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Split_Onnx_ver2(Pointer p) { super(p); }
}

// Iterate over schema from ai.onnx version 2
@Namespace("onnx") public static class OpSet_Onnx_ver2 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSet_Onnx_ver2() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSet_Onnx_ver2(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSet_Onnx_ver2(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSet_Onnx_ver2 position(long position) {
        return (OpSet_Onnx_ver2)super.position(position);
    }

}

// Forward declarations for ai.onnx version 3
@Namespace("onnx") @Opaque public static class GRU_Onnx_ver3 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GRU_Onnx_ver3() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GRU_Onnx_ver3(Pointer p) { super(p); }
}

// Iterate over schema from ai.onnx version 3
@Namespace("onnx") public static class OpSet_Onnx_ver3 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSet_Onnx_ver3() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSet_Onnx_ver3(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSet_Onnx_ver3(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSet_Onnx_ver3 position(long position) {
        return (OpSet_Onnx_ver3)super.position(position);
    }

}

// Forward declarations for ai.onnx version 4
@Namespace("onnx") @Opaque public static class Concat_Onnx_ver4 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Concat_Onnx_ver4() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Concat_Onnx_ver4(Pointer p) { super(p); }
}

// Iterate over schema from ai.onnx version 4
@Namespace("onnx") public static class OpSet_Onnx_ver4 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSet_Onnx_ver4() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSet_Onnx_ver4(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSet_Onnx_ver4(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSet_Onnx_ver4 position(long position) {
        return (OpSet_Onnx_ver4)super.position(position);
    }

}

// Forward declarations for ai.onnx version 5
@Namespace("onnx") @Opaque public static class Reshape_Onnx_ver5 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Reshape_Onnx_ver5() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Reshape_Onnx_ver5(Pointer p) { super(p); }
}

// Iterate over schema from ai.onnx version 5
@Namespace("onnx") public static class OpSet_Onnx_ver5 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSet_Onnx_ver5() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSet_Onnx_ver5(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSet_Onnx_ver5(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSet_Onnx_ver5 position(long position) {
        return (OpSet_Onnx_ver5)super.position(position);
    }

}

// Forward declarations for ai.onnx version 6
@Namespace("onnx") @Opaque public static class Abs_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Abs_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Abs_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Add_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Add_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Add_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class BatchNormalization_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public BatchNormalization_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public BatchNormalization_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Cast_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Cast_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Cast_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Ceil_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Ceil_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Ceil_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Clip_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Clip_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Clip_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Div_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Div_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Div_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Dropout_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Dropout_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Dropout_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Elu_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Elu_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Elu_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Exp_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Exp_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Exp_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Floor_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Floor_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Floor_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Gemm_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Gemm_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Gemm_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class HardSigmoid_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public HardSigmoid_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public HardSigmoid_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class InstanceNormalization_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public InstanceNormalization_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public InstanceNormalization_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LeakyRelu_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LeakyRelu_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LeakyRelu_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Log_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Log_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Log_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Max_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Max_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Max_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Mean_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Mean_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Mean_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Min_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Min_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Min_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Mul_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Mul_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Mul_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Neg_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Neg_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Neg_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class PRelu_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public PRelu_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PRelu_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Reciprocal_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Reciprocal_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Reciprocal_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Relu_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Relu_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Relu_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Selu_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Selu_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Selu_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sigmoid_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sigmoid_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sigmoid_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sqrt_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sqrt_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sqrt_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sub_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sub_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sub_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sum_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sum_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sum_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Tanh_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Tanh_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Tanh_Onnx_ver6(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Tile_Onnx_ver6 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Tile_Onnx_ver6() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Tile_Onnx_ver6(Pointer p) { super(p); }
}

// Iterate over schema from ai.onnx version 6
@Namespace("onnx") public static class OpSet_Onnx_ver6 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSet_Onnx_ver6() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSet_Onnx_ver6(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSet_Onnx_ver6(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSet_Onnx_ver6 position(long position) {
        return (OpSet_Onnx_ver6)super.position(position);
    }

}

// Forward declarations for ai.onnx version 7
@Namespace("onnx") @Opaque public static class Acos_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Acos_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Acos_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Add_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Add_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Add_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class And_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public And_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public And_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Asin_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Asin_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Asin_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Atan_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Atan_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Atan_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class AveragePool_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public AveragePool_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AveragePool_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class BatchNormalization_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public BatchNormalization_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public BatchNormalization_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Cos_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Cos_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Cos_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Div_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Div_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Div_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Dropout_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Dropout_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Dropout_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Equal_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Equal_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Equal_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Gemm_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Gemm_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Gemm_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Greater_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Greater_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Greater_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class GRU_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GRU_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GRU_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Less_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Less_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Less_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LSTM_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LSTM_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LSTM_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Mul_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Mul_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Mul_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Or_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Or_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Or_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Pow_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Pow_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Pow_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class RNN_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public RNN_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RNN_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sin_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sin_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sin_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Sub_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Sub_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sub_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Tan_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Tan_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Tan_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Upsample_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Upsample_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Upsample_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Multinomial_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Multinomial_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Multinomial_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Xor_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Xor_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Xor_Onnx_ver7(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class PRelu_Onnx_ver7 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public PRelu_Onnx_ver7() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PRelu_Onnx_ver7(Pointer p) { super(p); }
}

// Iterate over schema from ai.onnx version 7
@Namespace("onnx") public static class OpSet_Onnx_ver7 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSet_Onnx_ver7() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSet_Onnx_ver7(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSet_Onnx_ver7(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSet_Onnx_ver7 position(long position) {
        return (OpSet_Onnx_ver7)super.position(position);
    }

}

@Namespace("onnx") public static native void RegisterOnnxOperatorSetSchema();

 // namespace ONNX_NAMESPACE


// Parsed from onnx/defs/operator_sets-ml.h

// Copyright (c) Facebook Inc. and Microsoft Corporation.
// Licensed under the MIT license.

// #pragma once

// #ifdef ONNX_ML

// #include "onnx/defs/schema.h"

// Forward declarations for ai.onnx.ml version 1
@Namespace("onnx") @Opaque public static class ArrayFeatureExtractor_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ArrayFeatureExtractor_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ArrayFeatureExtractor_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Binarizer_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Binarizer_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Binarizer_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class CastMap_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public CastMap_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CastMap_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class CategoryMapper_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public CategoryMapper_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CategoryMapper_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class DictVectorizer_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public DictVectorizer_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DictVectorizer_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class FeatureVectorizer_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public FeatureVectorizer_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FeatureVectorizer_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Imputer_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Imputer_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Imputer_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LabelEncoder_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LabelEncoder_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LabelEncoder_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LinearClassifier_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LinearClassifier_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LinearClassifier_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class LinearRegressor_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public LinearRegressor_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LinearRegressor_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Normalizer_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Normalizer_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Normalizer_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class OneHotEncoder_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public OneHotEncoder_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OneHotEncoder_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class SVMClassifier_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public SVMClassifier_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SVMClassifier_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class SVMRegressor_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public SVMRegressor_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public SVMRegressor_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class Scaler_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Scaler_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Scaler_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class TreeEnsembleClassifier_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TreeEnsembleClassifier_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TreeEnsembleClassifier_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class TreeEnsembleRegressor_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TreeEnsembleRegressor_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TreeEnsembleRegressor_OnnxML_ver1(Pointer p) { super(p); }
}
@Namespace("onnx") @Opaque public static class ZipMap_OnnxML_ver1 extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ZipMap_OnnxML_ver1() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ZipMap_OnnxML_ver1(Pointer p) { super(p); }
}

// Iterate over schema from ai.onnx.ml version 1
@Namespace("onnx") public static class OpSet_OnnxML_ver1 extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public OpSet_OnnxML_ver1() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OpSet_OnnxML_ver1(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OpSet_OnnxML_ver1(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public OpSet_OnnxML_ver1 position(long position) {
        return (OpSet_OnnxML_ver1)super.position(position);
    }

}

@Namespace("onnx") public static native void RegisterOnnxMLOperatorSetSchema();
 // namespace ONNX_NAMESPACE

// #endif


// Parsed from onnx/defs/data_type_utils.h

// Copyright (c) Facebook Inc. and Microsoft Corporation.
// Licensed under the MIT license.

// #ifndef ONNX_DATA_TYPE_UTILS_H
// #define ONNX_DATA_TYPE_UTILS_H

// #include <mutex>
// #include <string>
// #include <unordered_map>
// #include <unordered_set>
// #include "onnx/onnx_pb.h"
// String pointer as unique TypeProto identifier.

// Data type utility, which maintains a global type string to TypeProto map.
// DataType (string pointer) is used as unique data type identifier for
// efficiency.
//
// Grammar for data type string:
// <type> ::= <data_type> |
//            tensor(<data_type>) |
//            seq(<type>) |
//            map(<data_type>, <type>)
// <data_type> :: = float | int32 | string | bool | uint8
//                | int8 | uint16 | int16 | int64 | float16 | double
//
// NOTE: <type> ::= <data_type> means the data is scalar (zero dimension).
//
// Example: float, tensor(float), etc.
//
@Namespace("onnx::Utils") public static class DataTypeUtils extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public DataTypeUtils() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public DataTypeUtils(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DataTypeUtils(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public DataTypeUtils position(long position) {
        return (DataTypeUtils)super.position(position);
    }

  public static native @StdString @ByVal @Cast({"char*", "std::string*"}) BytePointer ToType(@StdString BytePointer type_str);
  public static native @StdString @ByVal @Cast({"char*", "std::string*"}) BytePointer ToType(@StdString String type_str);

  public static native @StdString @ByVal @Cast({"char*", "std::string*"}) BytePointer ToType(@Const @ByRef TypeProto type_proto);

  public static native @Const @ByRef TypeProto ToTypeProto(@StdString @ByRef @Cast({"char*", "std::string*"}) BytePointer data_type);
}
 // namespace Utils
 // namespace ONNX_NAMESPACE

// #endif // ! ONNX_DATA_TYPE_UTILS_H


// Parsed from onnx/defs/shape_inference.h

// #pragma once

// #include "onnx/defs/data_type_utils.h"
// #include "onnx/proto_utils.h"
// #include "onnx/string_utils.h"

// Exception class used for handling errors in type and shape inference

@Namespace("onnx") @NoOffset public static class InferenceError extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public InferenceError(Pointer p) { super(p); }


	public InferenceError(@StdString BytePointer message) { super((Pointer)null); allocate(message); }
	private native void allocate(@StdString BytePointer message);
	public InferenceError(@StdString String message) { super((Pointer)null); allocate(message); }
	private native void allocate(@StdString String message);

	public native @Cast("const char*") BytePointer what();

	public native void AppendContext(@StdString BytePointer context);
	public native void AppendContext(@StdString String context);
}

// #define fail_type_inference(...)
//   throw ONNX_NAMESPACE::InferenceError(
//       ONNX_NAMESPACE::MakeString("[TypeInferenceError] ", __VA_ARGS__));

// #define fail_shape_inference(...)
//   throw ONNX_NAMESPACE::InferenceError(
//       ONNX_NAMESPACE::MakeString("[ShapeInferenceError] ", __VA_ARGS__));

@Namespace("onnx") public static class InferenceContext extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public InferenceContext(Pointer p) { super(p); }

  public native @Const AttributeProto getAttribute(@StdString BytePointer name);
  public native @Const AttributeProto getAttribute(@StdString String name);
  public native @Cast("size_t") long getNumInputs();
  public native @Const TypeProto getInputType(@Cast("size_t") long index);
  public native @Cast("size_t") long getNumOutputs();
  public native TypeProto getOutputType(@Cast("size_t") long index);
}

// This no-op inference function is used for operators without an
// inference implementation.
@Namespace("onnx") public static native void dummyInferenceFunction(@ByRef InferenceContext arg0);

@Namespace("onnx") public static native @Cast("int64_t") long getAttribute(@ByRef InferenceContext ctx, @StdString BytePointer attributeName, @Cast("int64_t") long defaultValue);
@Namespace("onnx") public static native @Cast("int64_t") long getAttribute(@ByRef InferenceContext ctx, @StdString String attributeName, @Cast("int64_t") long defaultValue);

@Namespace("onnx") public static native @StdString BytePointer getAttribute(@ByRef InferenceContext ctx, @StdString BytePointer attributeName, @StdString BytePointer defaultValue);
@Namespace("onnx") public static native @StdString String getAttribute(@ByRef InferenceContext ctx, @StdString String attributeName, @StdString String defaultValue);

@Namespace("onnx") public static native @ByVal @Name("operator *") Dimension multiply(@ByVal Dimension dim1, @ByVal Dimension dim2);

@Namespace("onnx") public static native @ByVal @Name("operator *") Dimension multiply(@ByVal Dimension dim1, @Cast("int64_t") long dim2);

@Namespace("onnx") public static native @ByVal @Name("operator /") Dimension divide(@ByVal Dimension dim1, @Cast("int64_t") long dim2);

//if from >= upto_exclusive, return 1.
//Caller must make sure upto_exclusive is less than or equal to shape.size()
//Caller must make sure from>=0
@Namespace("onnx") public static native @ByVal Dimension multiplyDims(@Const @ByRef TensorShapeProto shape, int from, int upto_exclusive);

// Note: for all methods below for propagating type or shape, callers are responsible
// to handle optional inputs/outputs and ensure that the specified index value
// is less than NumInputs/NumOutputs.

@Namespace("onnx") public static native void propagateElemTypeFromInputToOutput(
    @ByRef InferenceContext ctx,
    @Cast("size_t") long inputIndex,
    @Cast("size_t") long outputIndex);

@Namespace("onnx") public static native @Cast("bool") boolean hasInputShape(@ByRef InferenceContext ctx, int n);

@Namespace("onnx") public static native @Cast("bool") boolean hasNInputShapes(@ByRef InferenceContext ctx, int n);

@Namespace("onnx") public static native @Const @ByRef TensorShapeProto getInputShape(@ByRef InferenceContext ctx, @Cast("size_t") long n);

//Caller must make sure fromDimIndex is strictly less than shape.dim_size()
@Namespace("onnx") public static native void appendSingleDimCopiedFromInputTypeToOutputType(
    @ByRef InferenceContext ctx,
    @Cast("size_t") long inputIndex,
    @Cast("size_t") long outputIndex,
    @Cast("size_t") long fromDimIndex);

@Namespace("onnx") public static native void propagateShapeFromInputToOutput(
    @ByRef InferenceContext ctx,
    @Cast("size_t") long inputIndex,
    @Cast("size_t") long outputIndex);

@Namespace("onnx") public static native void propagateShapeAndTypeFromFirstInput(@ByRef InferenceContext ctx);

@Namespace("onnx") public static native void updateOutputElemType(
    @ByRef InferenceContext ctx,
    @Cast("size_t") long outputIndex,
    @Cast("onnx::TensorProto_DataType") int elemType);

// Infer type of an output from the value of a specified attribute, which is expected
// to have a valid value representing a TensorProto_DataType.
@Namespace("onnx") public static native void propagateElemTypeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString BytePointer attributeName,
    @Cast("size_t") long outputIndex,
    @Cast("onnx::TensorProto_DataType") int default_value/*=TensorProto::UNDEFINED*/);
@Namespace("onnx") public static native void propagateElemTypeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString BytePointer attributeName,
    @Cast("size_t") long outputIndex);
@Namespace("onnx") public static native void propagateElemTypeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString String attributeName,
    @Cast("size_t") long outputIndex,
    @Cast("onnx::TensorProto_DataType") int default_value/*=TensorProto::UNDEFINED*/);
@Namespace("onnx") public static native void propagateElemTypeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString String attributeName,
    @Cast("size_t") long outputIndex);

@Namespace("onnx") public static native TensorShapeProto getOutputShape(@ByRef InferenceContext ctx, @Cast("size_t") long n);

@Namespace("onnx") public static native void updateOutputShape(
    @ByRef InferenceContext ctx,
    @Cast("size_t") long outputIndex,
    @Const @ByRef TensorShapeProto shape);

@Namespace("onnx") public static native void updateOutputShape(
    @ByRef InferenceContext ctx,
    @Cast("size_t") long outputIndex,
    @Const @ByRef TensorProto tensorProto);

// Infer shape of an output from the value of a specified attribute, which is expected
// to be a list of integers specifying a valid shape.
@Namespace("onnx") public static native void propagateShapeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString BytePointer attributeName,
    @Cast("size_t") long outputIndex);
@Namespace("onnx") public static native void propagateShapeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString String attributeName,
    @Cast("size_t") long outputIndex);

@Namespace("onnx") public static native void bidirectionalBroadcastShapeInference(
    @Const @ByRef TensorShapeProto shapeL,
    @Const @ByRef TensorShapeProto shapeR,
    @ByRef TensorShapeProto resultShape);

 // namespace ONNX_NAMESPACE


// Parsed from onnx/onnx-operators-ml.pb.h

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: onnx-operators-ml.proto

// #ifndef PROTOBUF_onnx_2doperators_2dml_2eproto__INCLUDED
// #define PROTOBUF_onnx_2doperators_2dml_2eproto__INCLUDED

// #include <string>

// #include <google/protobuf/stubs/common.h>

// #if GOOGLE_PROTOBUF_VERSION < 3005000
// #error This file was generated by a newer version of protoc which is
// #error incompatible with your Protocol Buffer headers.  Please update
// #error your headers.
// #endif
// #if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
// #error This file was generated by an older version of protoc which is
// #error incompatible with your Protocol Buffer headers.  Please
// #error regenerate this file with a newer version of protoc.
// #endif

// #include <google/protobuf/io/coded_stream.h>
// #include <google/protobuf/arena.h>
// #include <google/protobuf/arenastring.h>
// #include <google/protobuf/generated_message_table_driven.h>
// #include <google/protobuf/generated_message_util.h>
// #include <google/protobuf/metadata.h>
// #include <google/protobuf/message.h>
// #include <google/protobuf/repeated_field.h>  // IWYU pragma: export
// #include <google/protobuf/extension_set.h>  // IWYU pragma: export
// #include <google/protobuf/generated_enum_reflection.h>
// #include <google/protobuf/unknown_field_set.h>
// #include "onnx-ml.pb.h"
// @@protoc_insertion_point(includes)
// Internal implementation detail -- do not use these members.
@Namespace("protobuf_onnx_2doperators_2dml_2eproto") public static class TableStruct extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public TableStruct() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TableStruct(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TableStruct(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public TableStruct position(long position) {
        return (TableStruct)super.position(position);
    }

  @MemberGetter public static native @Cast("const google::protobuf::uint32") int offsets(int i);
  @MemberGetter public static native @Cast("const google::protobuf::uint32*") IntPointer offsets();
}
@Namespace("protobuf_onnx_2doperators_2dml_2eproto") public static native void AddDescriptors();
@Namespace("protobuf_onnx_2doperators_2dml_2eproto") public static native void InitDefaultsFunctionProtoImpl();
@Namespace("protobuf_onnx_2doperators_2dml_2eproto") public static native void InitDefaultsFunctionProto();
@Namespace("protobuf_onnx_2doperators_2dml_2eproto") public static native void InitDefaultsOperatorProtoImpl();
@Namespace("protobuf_onnx_2doperators_2dml_2eproto") public static native void InitDefaultsOperatorProto();
@Namespace("protobuf_onnx_2doperators_2dml_2eproto") public static native void InitDefaultsOperatorSetProtoImpl();
@Namespace("protobuf_onnx_2doperators_2dml_2eproto") public static native void InitDefaultsOperatorSetProto();
@Namespace("protobuf_onnx_2doperators_2dml_2eproto") public static native void InitDefaults();
  // namespace protobuf_onnx_2doperators_2dml_2eproto
@Namespace("onnx") @Opaque public static class FunctionProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public FunctionProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FunctionProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class OperatorProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public OperatorProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OperatorProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class OperatorSetProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public OperatorSetProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OperatorSetProtoDefaultTypeInternal(Pointer p) { super(p); }
}

  // namespace onnx

/** enum onnx::OperatorStatus */
public static final int
  EXPERIMENTAL = 0,
  STABLE = 1;
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::OperatorStatus") int OperatorStatus_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::OperatorStatus") int OperatorStatus_MAX();
@Namespace("onnx") @MemberGetter public static native int OperatorStatus_ARRAYSIZE();

@Namespace("onnx") public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer OperatorStatus_descriptor();
@Namespace("onnx") public static native @StdString BytePointer OperatorStatus_Name(@Cast("onnx::OperatorStatus") int value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString BytePointer name, @Cast("onnx::OperatorStatus*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString String name, @Cast("onnx::OperatorStatus*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString BytePointer name, @Cast("onnx::OperatorStatus*") int[] value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString String name, @Cast("onnx::OperatorStatus*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString BytePointer name, @Cast("onnx::OperatorStatus*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString String name, @Cast("onnx::OperatorStatus*") int[] value);
// ===================================================================

@Namespace("onnx") @NoOffset public static class FunctionProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FunctionProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public FunctionProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public FunctionProto position(long position) {
        return (FunctionProto)super.position(position);
    }

  public FunctionProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public FunctionProto(@Const @ByRef FunctionProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef FunctionProto from);

  public native @ByRef @Name("operator =") FunctionProto put(@Const @ByRef FunctionProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef FunctionProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const FunctionProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(FunctionProto other);
  

  // implements Message ----------------------------------------------

  public native FunctionProto New();

  public native FunctionProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef FunctionProto from);
  public native void MergeFrom(@Const @ByRef FunctionProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string input = 4;
  public native int input_size();
  public native void clear_input();
  @MemberGetter public static native int kInputFieldNumber();
  public static final int kInputFieldNumber = kInputFieldNumber();
  public native @StdString BytePointer input(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_input(int index);
  public native void set_input(int index, @StdString BytePointer value);
  public native void set_input(int index, @StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_input(int index, @Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_input(int index, String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_input();
  public native void add_input(@StdString BytePointer value);
  public native void add_input(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void add_input(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void add_input(String value, @Cast("size_t") long size);

  // repeated string output = 5;
  public native int output_size();
  public native void clear_output();
  @MemberGetter public static native int kOutputFieldNumber();
  public static final int kOutputFieldNumber = kOutputFieldNumber();
  public native @StdString BytePointer output(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_output(int index);
  public native void set_output(int index, @StdString BytePointer value);
  public native void set_output(int index, @StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_output(int index, @Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_output(int index, String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_output();
  public native void add_output(@StdString BytePointer value);
  public native void add_output(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void add_output(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void add_output(String value, @Cast("size_t") long size);

  // repeated string attribute = 6;
  public native int attribute_size();
  public native void clear_attribute();
  @MemberGetter public static native int kAttributeFieldNumber();
  public static final int kAttributeFieldNumber = kAttributeFieldNumber();
  public native @StdString BytePointer attribute(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_attribute(int index);
  public native void set_attribute(int index, @StdString BytePointer value);
  public native void set_attribute(int index, @StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_attribute(int index, @Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_attribute(int index, String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_attribute();
  public native void add_attribute(@StdString BytePointer value);
  public native void add_attribute(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void add_attribute(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void add_attribute(String value, @Cast("size_t") long size);

  // repeated .onnx.NodeProto node = 7;
  public native int node_size();
  public native void clear_node();
  @MemberGetter public static native int kNodeFieldNumber();
  public static final int kNodeFieldNumber = kNodeFieldNumber();
  public native @Const @ByRef NodeProto node(int index);
  public native NodeProto mutable_node(int index);
  public native NodeProto add_node();

  // optional string name = 1;
  public native @Cast("bool") boolean has_name();
  public native void clear_name();
  @MemberGetter public static native int kNameFieldNumber();
  public static final int kNameFieldNumber = kNameFieldNumber();
  public native @StdString BytePointer name();
  public native void set_name(@StdString BytePointer value);
  public native void set_name(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_name();
  public native void set_allocated_name(@StdString @Cast({"char*", "std::string*"}) BytePointer name);

  // optional string doc_string = 8;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional int64 since_version = 2;
  public native @Cast("bool") boolean has_since_version();
  public native void clear_since_version();
  @MemberGetter public static native int kSinceVersionFieldNumber();
  public static final int kSinceVersionFieldNumber = kSinceVersionFieldNumber();
  public native @Cast("google::protobuf::int64") long since_version();
  public native void set_since_version(@Cast("google::protobuf::int64") long value);

  // optional .onnx.OperatorStatus status = 3;
  public native @Cast("bool") boolean has_status();
  public native void clear_status();
  @MemberGetter public static native int kStatusFieldNumber();
  public static final int kStatusFieldNumber = kStatusFieldNumber();
  public native @Cast("onnx::OperatorStatus") int status();
  public native void set_status(@Cast("onnx::OperatorStatus") int value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class OperatorProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OperatorProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OperatorProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public OperatorProto position(long position) {
        return (OperatorProto)super.position(position);
    }

  public OperatorProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public OperatorProto(@Const @ByRef OperatorProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef OperatorProto from);

  public native @ByRef @Name("operator =") OperatorProto put(@Const @ByRef OperatorProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef OperatorProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const OperatorProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(OperatorProto other);
  

  // implements Message ----------------------------------------------

  public native OperatorProto New();

  public native OperatorProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef OperatorProto from);
  public native void MergeFrom(@Const @ByRef OperatorProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string op_type = 1;
  public native @Cast("bool") boolean has_op_type();
  public native void clear_op_type();
  @MemberGetter public static native int kOpTypeFieldNumber();
  public static final int kOpTypeFieldNumber = kOpTypeFieldNumber();
  public native @StdString BytePointer op_type();
  public native void set_op_type(@StdString BytePointer value);
  public native void set_op_type(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_op_type(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_op_type(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_op_type();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_op_type();
  public native void set_allocated_op_type(@StdString @Cast({"char*", "std::string*"}) BytePointer op_type);

  // optional string doc_string = 10;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional int64 since_version = 2;
  public native @Cast("bool") boolean has_since_version();
  public native void clear_since_version();
  @MemberGetter public static native int kSinceVersionFieldNumber();
  public static final int kSinceVersionFieldNumber = kSinceVersionFieldNumber();
  public native @Cast("google::protobuf::int64") long since_version();
  public native void set_since_version(@Cast("google::protobuf::int64") long value);

  // optional .onnx.OperatorStatus status = 3;
  public native @Cast("bool") boolean has_status();
  public native void clear_status();
  @MemberGetter public static native int kStatusFieldNumber();
  public static final int kStatusFieldNumber = kStatusFieldNumber();
  public native @Cast("onnx::OperatorStatus") int status();
  public native void set_status(@Cast("onnx::OperatorStatus") int value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class OperatorSetProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OperatorSetProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OperatorSetProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public OperatorSetProto position(long position) {
        return (OperatorSetProto)super.position(position);
    }

  public OperatorSetProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public OperatorSetProto(@Const @ByRef OperatorSetProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef OperatorSetProto from);

  public native @ByRef @Name("operator =") OperatorSetProto put(@Const @ByRef OperatorSetProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef OperatorSetProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const OperatorSetProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(OperatorSetProto other);
  

  // implements Message ----------------------------------------------

  public native OperatorSetProto New();

  public native OperatorSetProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef OperatorSetProto from);
  public native void MergeFrom(@Const @ByRef OperatorSetProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .onnx.OperatorProto operator = 8;
  public native int operator__size();
  public native void clear_operator_();
  @MemberGetter public static native int kOperatorFieldNumber();
  public static final int kOperatorFieldNumber = kOperatorFieldNumber();
  public native @Const @ByRef OperatorProto operator_(int index);
  public native OperatorProto mutable_operator_(int index);
  public native OperatorProto add_operator_();

  // repeated .onnx.FunctionProto functions = 9;
  public native int functions_size();
  public native void clear_functions();
  @MemberGetter public static native int kFunctionsFieldNumber();
  public static final int kFunctionsFieldNumber = kFunctionsFieldNumber();
  public native @Const @ByRef FunctionProto functions(int index);
  public native FunctionProto mutable_functions(int index);
  public native FunctionProto add_functions();

  // optional string magic = 1;
  public native @Cast("bool") boolean has_magic();
  public native void clear_magic();
  @MemberGetter public static native int kMagicFieldNumber();
  public static final int kMagicFieldNumber = kMagicFieldNumber();
  public native @StdString BytePointer magic();
  public native void set_magic(@StdString BytePointer value);
  public native void set_magic(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_magic(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_magic(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_magic();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_magic();
  public native void set_allocated_magic(@StdString @Cast({"char*", "std::string*"}) BytePointer magic);

  // optional string ir_version_prerelease = 3;
  public native @Cast("bool") boolean has_ir_version_prerelease();
  public native void clear_ir_version_prerelease();
  @MemberGetter public static native int kIrVersionPrereleaseFieldNumber();
  public static final int kIrVersionPrereleaseFieldNumber = kIrVersionPrereleaseFieldNumber();
  public native @StdString BytePointer ir_version_prerelease();
  public native void set_ir_version_prerelease(@StdString BytePointer value);
  public native void set_ir_version_prerelease(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_ir_version_prerelease(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_ir_version_prerelease(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_ir_version_prerelease();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_ir_version_prerelease();
  public native void set_allocated_ir_version_prerelease(@StdString @Cast({"char*", "std::string*"}) BytePointer ir_version_prerelease);

  // optional string domain = 4;
  public native @Cast("bool") boolean has_domain();
  public native void clear_domain();
  @MemberGetter public static native int kDomainFieldNumber();
  public static final int kDomainFieldNumber = kDomainFieldNumber();
  public native @StdString BytePointer domain();
  public native void set_domain(@StdString BytePointer value);
  public native void set_domain(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_domain(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_domain(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_domain();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_domain();
  public native void set_allocated_domain(@StdString @Cast({"char*", "std::string*"}) BytePointer domain);

  // optional string doc_string = 6;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional string ir_build_metadata = 7;
  public native @Cast("bool") boolean has_ir_build_metadata();
  public native void clear_ir_build_metadata();
  @MemberGetter public static native int kIrBuildMetadataFieldNumber();
  public static final int kIrBuildMetadataFieldNumber = kIrBuildMetadataFieldNumber();
  public native @StdString BytePointer ir_build_metadata();
  public native void set_ir_build_metadata(@StdString BytePointer value);
  public native void set_ir_build_metadata(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_ir_build_metadata(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_ir_build_metadata(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_ir_build_metadata();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_ir_build_metadata();
  public native void set_allocated_ir_build_metadata(@StdString @Cast({"char*", "std::string*"}) BytePointer ir_build_metadata);

  // optional int64 opset_version = 5;
  public native @Cast("bool") boolean has_opset_version();
  public native void clear_opset_version();
  @MemberGetter public static native int kOpsetVersionFieldNumber();
  public static final int kOpsetVersionFieldNumber = kOpsetVersionFieldNumber();
  public native @Cast("google::protobuf::int64") long opset_version();
  public native void set_opset_version(@Cast("google::protobuf::int64") long value);

  // optional int32 ir_version = 2;
  public native @Cast("bool") boolean has_ir_version();
  public native void clear_ir_version();
  @MemberGetter public static native int kIrVersionFieldNumber();
  public static final int kIrVersionFieldNumber = kIrVersionFieldNumber();
  public native @Cast("google::protobuf::int32") int ir_version();
  public native void set_ir_version(@Cast("google::protobuf::int32") int value);
}
// ===================================================================


// ===================================================================

// #ifdef __GNUC__
//   #pragma GCC diagnostic push
//   #pragma GCC diagnostic ignored "-Wstrict-aliasing"
// #endif  // __GNUC__
// FunctionProto

// optional string name = 1;






// #if LANG_CXX11

// #endif






// optional int64 since_version = 2;







// optional .onnx.OperatorStatus status = 3;







// repeated string input = 4;





// #if LANG_CXX11

// #endif




// #if LANG_CXX11

// #endif





// repeated string output = 5;





// #if LANG_CXX11

// #endif




// #if LANG_CXX11

// #endif





// repeated string attribute = 6;





// #if LANG_CXX11

// #endif




// #if LANG_CXX11

// #endif





// repeated .onnx.NodeProto node = 7;







// optional string doc_string = 8;






// #if LANG_CXX11

// #endif






// -------------------------------------------------------------------

// OperatorProto

// optional string op_type = 1;






// #if LANG_CXX11

// #endif






// optional int64 since_version = 2;







// optional .onnx.OperatorStatus status = 3;







// optional string doc_string = 10;






// #if LANG_CXX11

// #endif






// -------------------------------------------------------------------

// OperatorSetProto

// optional string magic = 1;






// #if LANG_CXX11

// #endif






// optional int32 ir_version = 2;







// optional string ir_version_prerelease = 3;






// #if LANG_CXX11

// #endif






// optional string ir_build_metadata = 7;






// #if LANG_CXX11

// #endif






// optional string domain = 4;






// #if LANG_CXX11

// #endif






// optional int64 opset_version = 5;







// optional string doc_string = 6;






// #if LANG_CXX11

// #endif






// repeated .onnx.OperatorProto operator = 8;








// repeated .onnx.FunctionProto functions = 9;








// #ifdef __GNUC__
//   #pragma GCC diagnostic pop
// #endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

  // namespace onnx


  // namespace protobuf
  // namespace google

// @@protoc_insertion_point(global_scope)

// #endif  // PROTOBUF_onnx_2doperators_2dml_2eproto__INCLUDED


// Parsed from onnx/onnx-ml.pb.h

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: onnx-ml.proto

// #ifndef PROTOBUF_onnx_2dml_2eproto__INCLUDED
// #define PROTOBUF_onnx_2dml_2eproto__INCLUDED

// #include <string>

// #include <google/protobuf/stubs/common.h>

// #if GOOGLE_PROTOBUF_VERSION < 3005000
// #error This file was generated by a newer version of protoc which is
// #error incompatible with your Protocol Buffer headers.  Please update
// #error your headers.
// #endif
// #if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
// #error This file was generated by an older version of protoc which is
// #error incompatible with your Protocol Buffer headers.  Please
// #error regenerate this file with a newer version of protoc.
// #endif

// #include <google/protobuf/io/coded_stream.h>
// #include <google/protobuf/arena.h>
// #include <google/protobuf/arenastring.h>
// #include <google/protobuf/generated_message_table_driven.h>
// #include <google/protobuf/generated_message_util.h>
// #include <google/protobuf/metadata.h>
// #include <google/protobuf/message.h>
// #include <google/protobuf/repeated_field.h>  // IWYU pragma: export
// #include <google/protobuf/extension_set.h>  // IWYU pragma: export
// #include <google/protobuf/generated_enum_reflection.h>
// #include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
// Internal implementation detail -- do not use these members.
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsAttributeProtoImpl();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsAttributeProto();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsValueInfoProtoImpl();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsValueInfoProto();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsModelProtoImpl();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsModelProto();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsStringStringEntryProtoImpl();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsStringStringEntryProto();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsTensorProto_SegmentImpl();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsTensorProto_Segment();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsTensorProtoImpl();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsTensorProto();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsTensorShapeProto_DimensionImpl();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsTensorShapeProto_Dimension();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsTensorShapeProtoImpl();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsTensorShapeProto();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsTypeProto_TensorImpl();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsTypeProto_Tensor();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsTypeProtoImpl();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsTypeProto();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsOperatorSetIdProtoImpl();
@Namespace("protobuf_onnx_2dml_2eproto") public static native void InitDefaultsOperatorSetIdProto();
  // namespace protobuf_onnx_2dml_2eproto
@Namespace("onnx") @Opaque public static class AttributeProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public AttributeProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AttributeProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class GraphProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GraphProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GraphProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class ModelProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ModelProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ModelProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class NodeProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public NodeProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public NodeProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class OperatorSetIdProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public OperatorSetIdProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OperatorSetIdProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class StringStringEntryProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public StringStringEntryProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringStringEntryProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class TensorProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TensorProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class TensorProto_SegmentDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TensorProto_SegmentDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorProto_SegmentDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class TensorShapeProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TensorShapeProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorShapeProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class TensorShapeProto_DimensionDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TensorShapeProto_DimensionDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorShapeProto_DimensionDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class TypeProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TypeProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProtoDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class TypeProto_MapDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TypeProto_MapDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProto_MapDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class TypeProto_SequenceDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TypeProto_SequenceDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProto_SequenceDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class TypeProto_TensorDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public TypeProto_TensorDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProto_TensorDefaultTypeInternal(Pointer p) { super(p); }
}

@Namespace("onnx") @Opaque public static class ValueInfoProtoDefaultTypeInternal extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ValueInfoProtoDefaultTypeInternal() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ValueInfoProtoDefaultTypeInternal(Pointer p) { super(p); }
}

  // namespace onnx

/** enum onnx::AttributeProto_AttributeType */
public static final int
  AttributeProto_AttributeType_UNDEFINED = 0,
  AttributeProto_AttributeType_FLOAT = 1,
  AttributeProto_AttributeType_INT = 2,
  AttributeProto_AttributeType_STRING = 3,
  AttributeProto_AttributeType_TENSOR = 4,
  AttributeProto_AttributeType_GRAPH = 5,
  AttributeProto_AttributeType_FLOATS = 6,
  AttributeProto_AttributeType_INTS = 7,
  AttributeProto_AttributeType_STRINGS = 8,
  AttributeProto_AttributeType_TENSORS = 9,
  AttributeProto_AttributeType_GRAPHS = 10;
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::AttributeProto_AttributeType") int AttributeProto_AttributeType_AttributeType_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::AttributeProto_AttributeType") int AttributeProto_AttributeType_AttributeType_MAX();
@Namespace("onnx") @MemberGetter public static native int AttributeProto_AttributeType_AttributeType_ARRAYSIZE();

@Namespace("onnx") public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer AttributeProto_AttributeType_descriptor();
@Namespace("onnx") public static native @StdString BytePointer AttributeProto_AttributeType_Name(@Cast("onnx::AttributeProto_AttributeType") int value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString BytePointer name, @Cast("onnx::AttributeProto_AttributeType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString String name, @Cast("onnx::AttributeProto_AttributeType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString BytePointer name, @Cast("onnx::AttributeProto_AttributeType*") int[] value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString String name, @Cast("onnx::AttributeProto_AttributeType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString BytePointer name, @Cast("onnx::AttributeProto_AttributeType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString String name, @Cast("onnx::AttributeProto_AttributeType*") int[] value);
/** enum onnx::TensorProto_DataType */
public static final int
  TensorProto_DataType_UNDEFINED = 0,
  TensorProto_DataType_FLOAT = 1,
  TensorProto_DataType_UINT8 = 2,
  TensorProto_DataType_INT8 = 3,
  TensorProto_DataType_UINT16 = 4,
  TensorProto_DataType_INT16 = 5,
  TensorProto_DataType_INT32 = 6,
  TensorProto_DataType_INT64 = 7,
  TensorProto_DataType_STRING = 8,
  TensorProto_DataType_BOOL = 9,
  TensorProto_DataType_FLOAT16 = 10,
  TensorProto_DataType_DOUBLE = 11,
  TensorProto_DataType_UINT32 = 12,
  TensorProto_DataType_UINT64 = 13,
  TensorProto_DataType_COMPLEX64 = 14,
  TensorProto_DataType_COMPLEX128 = 15;
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::TensorProto_DataType") int TensorProto_DataType_DataType_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::TensorProto_DataType") int TensorProto_DataType_DataType_MAX();
@Namespace("onnx") @MemberGetter public static native int TensorProto_DataType_DataType_ARRAYSIZE();

@Namespace("onnx") public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer TensorProto_DataType_descriptor();
@Namespace("onnx") public static native @StdString BytePointer TensorProto_DataType_Name(@Cast("onnx::TensorProto_DataType") int value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString BytePointer name, @Cast("onnx::TensorProto_DataType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString String name, @Cast("onnx::TensorProto_DataType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString BytePointer name, @Cast("onnx::TensorProto_DataType*") int... value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString String name, @Cast("onnx::TensorProto_DataType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString BytePointer name, @Cast("onnx::TensorProto_DataType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString String name, @Cast("onnx::TensorProto_DataType*") int... value);
/** enum onnx::Version */
public static final int
  _START_VERSION = 0,
  IR_VERSION_2017_10_10 = 1,
  IR_VERSION_2017_10_30 = 2,
  IR_VERSION = 3;
@Namespace("onnx") public static native @Cast("bool") boolean Version_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::Version") int Version_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::Version") int Version_MAX();
@Namespace("onnx") @MemberGetter public static native int Version_ARRAYSIZE();

@Namespace("onnx") public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer Version_descriptor();
@Namespace("onnx") public static native @StdString BytePointer Version_Name(@Cast("onnx::Version") int value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString BytePointer name, @Cast("onnx::Version*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString String name, @Cast("onnx::Version*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString BytePointer name, @Cast("onnx::Version*") int[] value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString String name, @Cast("onnx::Version*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString BytePointer name, @Cast("onnx::Version*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString String name, @Cast("onnx::Version*") int[] value);
// ===================================================================

@Namespace("onnx") @NoOffset public static class AttributeProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AttributeProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public AttributeProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public AttributeProto position(long position) {
        return (AttributeProto)super.position(position);
    }

  public AttributeProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public AttributeProto(@Const @ByRef AttributeProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef AttributeProto from);

  public native @ByRef @Name("operator =") AttributeProto put(@Const @ByRef AttributeProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef AttributeProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const AttributeProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(AttributeProto other);
  

  // implements Message ----------------------------------------------

  public native AttributeProto New();

  public native AttributeProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef AttributeProto from);
  public native void MergeFrom(@Const @ByRef AttributeProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int UNDEFINED();
  public static final int UNDEFINED = UNDEFINED();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int FLOAT();
  public static final int FLOAT = FLOAT();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int INT();
  public static final int INT = INT();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int STRING();
  public static final int STRING = STRING();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int TENSOR();
  public static final int TENSOR = TENSOR();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int GRAPH();
  public static final int GRAPH = GRAPH();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int FLOATS();
  public static final int FLOATS = FLOATS();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int INTS();
  public static final int INTS = INTS();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int STRINGS();
  public static final int STRINGS = STRINGS();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int TENSORS();
  public static final int TENSORS = TENSORS();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int GRAPHS();
  public static final int GRAPHS = GRAPHS();
  public static native @Cast("bool") boolean AttributeType_IsValid(int value);
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int AttributeType_MIN();
  public static final int AttributeType_MIN = AttributeType_MIN();
  @MemberGetter public static native @Cast("const onnx::AttributeProto::AttributeType") int AttributeType_MAX();
  public static final int AttributeType_MAX = AttributeType_MAX();
  @MemberGetter public static native int AttributeType_ARRAYSIZE();
  public static final int AttributeType_ARRAYSIZE = AttributeType_ARRAYSIZE();
  public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer AttributeType_descriptor();
  public static native @StdString BytePointer AttributeType_Name(@Cast("onnx::AttributeProto::AttributeType") int value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString BytePointer name,
        @Cast("onnx::AttributeProto::AttributeType*") IntPointer value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString String name,
        @Cast("onnx::AttributeProto::AttributeType*") IntBuffer value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString BytePointer name,
        @Cast("onnx::AttributeProto::AttributeType*") int... value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString String name,
        @Cast("onnx::AttributeProto::AttributeType*") IntPointer value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString BytePointer name,
        @Cast("onnx::AttributeProto::AttributeType*") IntBuffer value);
  public static native @Cast("bool") boolean AttributeType_Parse(@StdString String name,
        @Cast("onnx::AttributeProto::AttributeType*") int... value);

  // accessors -------------------------------------------------------

  // repeated float floats = 7;
  public native int floats_size();
  public native void clear_floats();
  @MemberGetter public static native int kFloatsFieldNumber();
  public static final int kFloatsFieldNumber = kFloatsFieldNumber();
  public native float floats(int index);
  public native void set_floats(int index, float value);
  public native void add_floats(float value);

  // repeated int64 ints = 8;
  public native int ints_size();
  public native void clear_ints();
  @MemberGetter public static native int kIntsFieldNumber();
  public static final int kIntsFieldNumber = kIntsFieldNumber();
  public native @Cast("google::protobuf::int64") long ints(int index);
  public native void set_ints(int index, @Cast("google::protobuf::int64") long value);
  public native void add_ints(@Cast("google::protobuf::int64") long value);

  // repeated bytes strings = 9;
  public native int strings_size();
  public native void clear_strings();
  @MemberGetter public static native int kStringsFieldNumber();
  public static final int kStringsFieldNumber = kStringsFieldNumber();
  public native @StdString BytePointer strings(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_strings(int index);
  public native void set_strings(int index, @StdString BytePointer value);
  public native void set_strings(int index, @StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_strings(int index, @Const Pointer value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_strings();
  public native void add_strings(@StdString BytePointer value);
  public native void add_strings(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void add_strings(@Const Pointer value, @Cast("size_t") long size);

  // repeated .onnx.TensorProto tensors = 10;
  public native int tensors_size();
  public native void clear_tensors();
  @MemberGetter public static native int kTensorsFieldNumber();
  public static final int kTensorsFieldNumber = kTensorsFieldNumber();
  public native @Const @ByRef TensorProto tensors(int index);
  public native TensorProto mutable_tensors(int index);
  public native TensorProto add_tensors();

  // repeated .onnx.GraphProto graphs = 11;
  public native int graphs_size();
  public native void clear_graphs();
  @MemberGetter public static native int kGraphsFieldNumber();
  public static final int kGraphsFieldNumber = kGraphsFieldNumber();
  public native @Const @ByRef GraphProto graphs(int index);
  public native GraphProto mutable_graphs(int index);
  public native GraphProto add_graphs();

  // optional string name = 1;
  public native @Cast("bool") boolean has_name();
  public native void clear_name();
  @MemberGetter public static native int kNameFieldNumber();
  public static final int kNameFieldNumber = kNameFieldNumber();
  public native @StdString BytePointer name();
  public native void set_name(@StdString BytePointer value);
  public native void set_name(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_name();
  public native void set_allocated_name(@StdString @Cast({"char*", "std::string*"}) BytePointer name);

  // optional bytes s = 4;
  public native @Cast("bool") boolean has_s();
  public native void clear_s();
  @MemberGetter public static native int kSFieldNumber();
  public static final int kSFieldNumber = kSFieldNumber();
  public native @StdString BytePointer s();
  public native void set_s(@StdString BytePointer value);
  public native void set_s(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_s(@Const Pointer value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_s();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_s();
  public native void set_allocated_s(@StdString @Cast({"char*", "std::string*"}) BytePointer s);

  // optional string doc_string = 13;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional string ref_attr_name = 21;
  public native @Cast("bool") boolean has_ref_attr_name();
  public native void clear_ref_attr_name();
  @MemberGetter public static native int kRefAttrNameFieldNumber();
  public static final int kRefAttrNameFieldNumber = kRefAttrNameFieldNumber();
  public native @StdString BytePointer ref_attr_name();
  public native void set_ref_attr_name(@StdString BytePointer value);
  public native void set_ref_attr_name(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_ref_attr_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_ref_attr_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_ref_attr_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_ref_attr_name();
  public native void set_allocated_ref_attr_name(@StdString @Cast({"char*", "std::string*"}) BytePointer ref_attr_name);

  // optional .onnx.TensorProto t = 5;
  public native @Cast("bool") boolean has_t();
  public native void clear_t();
  @MemberGetter public static native int kTFieldNumber();
  public static final int kTFieldNumber = kTFieldNumber();
  public native @Const @ByRef TensorProto t();
  public native TensorProto release_t();
  public native TensorProto mutable_t();
  public native void set_allocated_t(TensorProto t);

  // optional .onnx.GraphProto g = 6;
  public native @Cast("bool") boolean has_g();
  public native void clear_g();
  @MemberGetter public static native int kGFieldNumber();
  public static final int kGFieldNumber = kGFieldNumber();
  public native @Const @ByRef GraphProto g();
  public native GraphProto release_g();
  public native GraphProto mutable_g();
  public native void set_allocated_g(GraphProto g);

  // optional int64 i = 3;
  public native @Cast("bool") boolean has_i();
  public native void clear_i();
  @MemberGetter public static native int kIFieldNumber();
  public static final int kIFieldNumber = kIFieldNumber();
  public native @Cast("google::protobuf::int64") long i();
  public native void set_i(@Cast("google::protobuf::int64") long value);

  // optional float f = 2;
  public native @Cast("bool") boolean has_f();
  public native void clear_f();
  @MemberGetter public static native int kFFieldNumber();
  public static final int kFFieldNumber = kFFieldNumber();
  public native float f();
  public native void set_f(float value);

  // optional .onnx.AttributeProto.AttributeType type = 20;
  public native @Cast("bool") boolean has_type();
  public native void clear_type();
  @MemberGetter public static native int kTypeFieldNumber();
  public static final int kTypeFieldNumber = kTypeFieldNumber();
  public native @Cast("onnx::AttributeProto_AttributeType") int type();
  public native void set_type(@Cast("onnx::AttributeProto_AttributeType") int value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class ValueInfoProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ValueInfoProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ValueInfoProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ValueInfoProto position(long position) {
        return (ValueInfoProto)super.position(position);
    }

  public ValueInfoProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public ValueInfoProto(@Const @ByRef ValueInfoProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef ValueInfoProto from);

  public native @ByRef @Name("operator =") ValueInfoProto put(@Const @ByRef ValueInfoProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef ValueInfoProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const ValueInfoProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(ValueInfoProto other);
  

  // implements Message ----------------------------------------------

  public native ValueInfoProto New();

  public native ValueInfoProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef ValueInfoProto from);
  public native void MergeFrom(@Const @ByRef ValueInfoProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  public native @Cast("bool") boolean has_name();
  public native void clear_name();
  @MemberGetter public static native int kNameFieldNumber();
  public static final int kNameFieldNumber = kNameFieldNumber();
  public native @StdString BytePointer name();
  public native void set_name(@StdString BytePointer value);
  public native void set_name(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_name();
  public native void set_allocated_name(@StdString @Cast({"char*", "std::string*"}) BytePointer name);

  // optional string doc_string = 3;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional .onnx.TypeProto type = 2;
  public native @Cast("bool") boolean has_type();
  public native void clear_type();
  @MemberGetter public static native int kTypeFieldNumber();
  public static final int kTypeFieldNumber = kTypeFieldNumber();
  public native @Const @ByRef TypeProto type();
  public native TypeProto release_type();
  public native TypeProto mutable_type();
  public native void set_allocated_type(TypeProto type);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class NodeProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public NodeProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public NodeProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public NodeProto position(long position) {
        return (NodeProto)super.position(position);
    }

  public NodeProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public NodeProto(@Const @ByRef NodeProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef NodeProto from);

  public native @ByRef @Name("operator =") NodeProto put(@Const @ByRef NodeProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef NodeProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const NodeProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(NodeProto other);
  

  // implements Message ----------------------------------------------

  public native NodeProto New();

  public native NodeProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef NodeProto from);
  public native void MergeFrom(@Const @ByRef NodeProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string input = 1;
  public native int input_size();
  public native void clear_input();
  @MemberGetter public static native int kInputFieldNumber();
  public static final int kInputFieldNumber = kInputFieldNumber();
  public native @StdString BytePointer input(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_input(int index);
  public native void set_input(int index, @StdString BytePointer value);
  public native void set_input(int index, @StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_input(int index, @Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_input(int index, String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_input();
  public native void add_input(@StdString BytePointer value);
  public native void add_input(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void add_input(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void add_input(String value, @Cast("size_t") long size);

  // repeated string output = 2;
  public native int output_size();
  public native void clear_output();
  @MemberGetter public static native int kOutputFieldNumber();
  public static final int kOutputFieldNumber = kOutputFieldNumber();
  public native @StdString BytePointer output(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_output(int index);
  public native void set_output(int index, @StdString BytePointer value);
  public native void set_output(int index, @StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_output(int index, @Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_output(int index, String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_output();
  public native void add_output(@StdString BytePointer value);
  public native void add_output(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void add_output(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void add_output(String value, @Cast("size_t") long size);

  // repeated .onnx.AttributeProto attribute = 5;
  public native int attribute_size();
  public native void clear_attribute();
  @MemberGetter public static native int kAttributeFieldNumber();
  public static final int kAttributeFieldNumber = kAttributeFieldNumber();
  public native @Const @ByRef AttributeProto attribute(int index);
  public native AttributeProto mutable_attribute(int index);
  public native AttributeProto add_attribute();

  // optional string name = 3;
  public native @Cast("bool") boolean has_name();
  public native void clear_name();
  @MemberGetter public static native int kNameFieldNumber();
  public static final int kNameFieldNumber = kNameFieldNumber();
  public native @StdString BytePointer name();
  public native void set_name(@StdString BytePointer value);
  public native void set_name(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_name();
  public native void set_allocated_name(@StdString @Cast({"char*", "std::string*"}) BytePointer name);

  // optional string op_type = 4;
  public native @Cast("bool") boolean has_op_type();
  public native void clear_op_type();
  @MemberGetter public static native int kOpTypeFieldNumber();
  public static final int kOpTypeFieldNumber = kOpTypeFieldNumber();
  public native @StdString BytePointer op_type();
  public native void set_op_type(@StdString BytePointer value);
  public native void set_op_type(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_op_type(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_op_type(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_op_type();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_op_type();
  public native void set_allocated_op_type(@StdString @Cast({"char*", "std::string*"}) BytePointer op_type);

  // optional string doc_string = 6;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional string domain = 7;
  public native @Cast("bool") boolean has_domain();
  public native void clear_domain();
  @MemberGetter public static native int kDomainFieldNumber();
  public static final int kDomainFieldNumber = kDomainFieldNumber();
  public native @StdString BytePointer domain();
  public native void set_domain(@StdString BytePointer value);
  public native void set_domain(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_domain(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_domain(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_domain();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_domain();
  public native void set_allocated_domain(@StdString @Cast({"char*", "std::string*"}) BytePointer domain);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class ModelProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ModelProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ModelProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ModelProto position(long position) {
        return (ModelProto)super.position(position);
    }

  public ModelProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public ModelProto(@Const @ByRef ModelProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef ModelProto from);

  public native @ByRef @Name("operator =") ModelProto put(@Const @ByRef ModelProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef ModelProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const ModelProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(ModelProto other);
  

  // implements Message ----------------------------------------------

  public native ModelProto New();

  public native ModelProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef ModelProto from);
  public native void MergeFrom(@Const @ByRef ModelProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .onnx.OperatorSetIdProto opset_import = 8;
  public native int opset_import_size();
  public native void clear_opset_import();
  @MemberGetter public static native int kOpsetImportFieldNumber();
  public static final int kOpsetImportFieldNumber = kOpsetImportFieldNumber();
  public native @Const @ByRef OperatorSetIdProto opset_import(int index);
  public native OperatorSetIdProto mutable_opset_import(int index);
  public native OperatorSetIdProto add_opset_import();

  // repeated .onnx.StringStringEntryProto metadata_props = 14;
  public native int metadata_props_size();
  public native void clear_metadata_props();
  @MemberGetter public static native int kMetadataPropsFieldNumber();
  public static final int kMetadataPropsFieldNumber = kMetadataPropsFieldNumber();
  public native @Const @ByRef StringStringEntryProto metadata_props(int index);
  public native StringStringEntryProto mutable_metadata_props(int index);
  public native StringStringEntryProto add_metadata_props();

  // optional string producer_name = 2;
  public native @Cast("bool") boolean has_producer_name();
  public native void clear_producer_name();
  @MemberGetter public static native int kProducerNameFieldNumber();
  public static final int kProducerNameFieldNumber = kProducerNameFieldNumber();
  public native @StdString BytePointer producer_name();
  public native void set_producer_name(@StdString BytePointer value);
  public native void set_producer_name(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_producer_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_producer_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_producer_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_producer_name();
  public native void set_allocated_producer_name(@StdString @Cast({"char*", "std::string*"}) BytePointer producer_name);

  // optional string producer_version = 3;
  public native @Cast("bool") boolean has_producer_version();
  public native void clear_producer_version();
  @MemberGetter public static native int kProducerVersionFieldNumber();
  public static final int kProducerVersionFieldNumber = kProducerVersionFieldNumber();
  public native @StdString BytePointer producer_version();
  public native void set_producer_version(@StdString BytePointer value);
  public native void set_producer_version(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_producer_version(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_producer_version(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_producer_version();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_producer_version();
  public native void set_allocated_producer_version(@StdString @Cast({"char*", "std::string*"}) BytePointer producer_version);

  // optional string domain = 4;
  public native @Cast("bool") boolean has_domain();
  public native void clear_domain();
  @MemberGetter public static native int kDomainFieldNumber();
  public static final int kDomainFieldNumber = kDomainFieldNumber();
  public native @StdString BytePointer domain();
  public native void set_domain(@StdString BytePointer value);
  public native void set_domain(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_domain(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_domain(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_domain();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_domain();
  public native void set_allocated_domain(@StdString @Cast({"char*", "std::string*"}) BytePointer domain);

  // optional string doc_string = 6;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional .onnx.GraphProto graph = 7;
  public native @Cast("bool") boolean has_graph();
  public native void clear_graph();
  @MemberGetter public static native int kGraphFieldNumber();
  public static final int kGraphFieldNumber = kGraphFieldNumber();
  public native @Const @ByRef GraphProto graph();
  public native GraphProto release_graph();
  public native GraphProto mutable_graph();
  public native void set_allocated_graph(GraphProto graph);

  // optional int64 ir_version = 1;
  public native @Cast("bool") boolean has_ir_version();
  public native void clear_ir_version();
  @MemberGetter public static native int kIrVersionFieldNumber();
  public static final int kIrVersionFieldNumber = kIrVersionFieldNumber();
  public native @Cast("google::protobuf::int64") long ir_version();
  public native void set_ir_version(@Cast("google::protobuf::int64") long value);

  // optional int64 model_version = 5;
  public native @Cast("bool") boolean has_model_version();
  public native void clear_model_version();
  @MemberGetter public static native int kModelVersionFieldNumber();
  public static final int kModelVersionFieldNumber = kModelVersionFieldNumber();
  public native @Cast("google::protobuf::int64") long model_version();
  public native void set_model_version(@Cast("google::protobuf::int64") long value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class StringStringEntryProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StringStringEntryProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public StringStringEntryProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public StringStringEntryProto position(long position) {
        return (StringStringEntryProto)super.position(position);
    }

  public StringStringEntryProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public StringStringEntryProto(@Const @ByRef StringStringEntryProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef StringStringEntryProto from);

  public native @ByRef @Name("operator =") StringStringEntryProto put(@Const @ByRef StringStringEntryProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef StringStringEntryProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const StringStringEntryProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(StringStringEntryProto other);
  

  // implements Message ----------------------------------------------

  public native StringStringEntryProto New();

  public native StringStringEntryProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef StringStringEntryProto from);
  public native void MergeFrom(@Const @ByRef StringStringEntryProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  public native @Cast("bool") boolean has_key();
  public native void clear_key();
  @MemberGetter public static native int kKeyFieldNumber();
  public static final int kKeyFieldNumber = kKeyFieldNumber();
  public native @StdString BytePointer key();
  public native void set_key(@StdString BytePointer value);
  public native void set_key(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_key(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_key(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_key();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_key();
  public native void set_allocated_key(@StdString @Cast({"char*", "std::string*"}) BytePointer key);

  // optional string value = 2;
  public native @Cast("bool") boolean has_value();
  public native void clear_value();
  @MemberGetter public static native int kValueFieldNumber();
  public static final int kValueFieldNumber = kValueFieldNumber();
  public native @StdString BytePointer value();
  public native void set_value(@StdString BytePointer value);
  public native void set_value(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_value(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_value(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_value();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_value();
  public native void set_allocated_value(@StdString @Cast({"char*", "std::string*"}) BytePointer value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class GraphProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GraphProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public GraphProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public GraphProto position(long position) {
        return (GraphProto)super.position(position);
    }

  public GraphProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public GraphProto(@Const @ByRef GraphProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef GraphProto from);

  public native @ByRef @Name("operator =") GraphProto put(@Const @ByRef GraphProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef GraphProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const GraphProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(GraphProto other);
  

  // implements Message ----------------------------------------------

  public native GraphProto New();

  public native GraphProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef GraphProto from);
  public native void MergeFrom(@Const @ByRef GraphProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .onnx.NodeProto node = 1;
  public native int node_size();
  public native void clear_node();
  @MemberGetter public static native int kNodeFieldNumber();
  public static final int kNodeFieldNumber = kNodeFieldNumber();
  public native @Const @ByRef NodeProto node(int index);
  public native NodeProto mutable_node(int index);
  public native NodeProto add_node();

  // repeated .onnx.TensorProto initializer = 5;
  public native int initializer_size();
  public native void clear_initializer();
  @MemberGetter public static native int kInitializerFieldNumber();
  public static final int kInitializerFieldNumber = kInitializerFieldNumber();
  public native @Const @ByRef TensorProto initializer(int index);
  public native TensorProto mutable_initializer(int index);
  public native TensorProto add_initializer();

  // repeated .onnx.ValueInfoProto input = 11;
  public native int input_size();
  public native void clear_input();
  @MemberGetter public static native int kInputFieldNumber();
  public static final int kInputFieldNumber = kInputFieldNumber();
  public native @Const @ByRef ValueInfoProto input(int index);
  public native ValueInfoProto mutable_input(int index);
  public native ValueInfoProto add_input();

  // repeated .onnx.ValueInfoProto output = 12;
  public native int output_size();
  public native void clear_output();
  @MemberGetter public static native int kOutputFieldNumber();
  public static final int kOutputFieldNumber = kOutputFieldNumber();
  public native @Const @ByRef ValueInfoProto output(int index);
  public native ValueInfoProto mutable_output(int index);
  public native ValueInfoProto add_output();

  // repeated .onnx.ValueInfoProto value_info = 13;
  public native int value_info_size();
  public native void clear_value_info();
  @MemberGetter public static native int kValueInfoFieldNumber();
  public static final int kValueInfoFieldNumber = kValueInfoFieldNumber();
  public native @Const @ByRef ValueInfoProto value_info(int index);
  public native ValueInfoProto mutable_value_info(int index);
  public native ValueInfoProto add_value_info();

  // optional string name = 2;
  public native @Cast("bool") boolean has_name();
  public native void clear_name();
  @MemberGetter public static native int kNameFieldNumber();
  public static final int kNameFieldNumber = kNameFieldNumber();
  public native @StdString BytePointer name();
  public native void set_name(@StdString BytePointer value);
  public native void set_name(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_name();
  public native void set_allocated_name(@StdString @Cast({"char*", "std::string*"}) BytePointer name);

  // optional string doc_string = 10;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TensorProto_Segment extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorProto_Segment(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TensorProto_Segment(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TensorProto_Segment position(long position) {
        return (TensorProto_Segment)super.position(position);
    }

  public TensorProto_Segment() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TensorProto_Segment(@Const @ByRef TensorProto_Segment from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TensorProto_Segment from);

  public native @ByRef @Name("operator =") TensorProto_Segment put(@Const @ByRef TensorProto_Segment from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TensorProto_Segment default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const TensorProto_Segment internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(TensorProto_Segment other);
  

  // implements Message ----------------------------------------------

  public native TensorProto_Segment New();

  public native TensorProto_Segment New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TensorProto_Segment from);
  public native void MergeFrom(@Const @ByRef TensorProto_Segment from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 begin = 1;
  public native @Cast("bool") boolean has_begin();
  public native void clear_begin();
  @MemberGetter public static native int kBeginFieldNumber();
  public static final int kBeginFieldNumber = kBeginFieldNumber();
  public native @Cast("google::protobuf::int64") long begin();
  public native void set_begin(@Cast("google::protobuf::int64") long value);

  // optional int64 end = 2;
  public native @Cast("bool") boolean has_end();
  public native void clear_end();
  @MemberGetter public static native int kEndFieldNumber();
  public static final int kEndFieldNumber = kEndFieldNumber();
  public native @Cast("google::protobuf::int64") long end();
  public native void set_end(@Cast("google::protobuf::int64") long value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TensorProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TensorProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TensorProto position(long position) {
        return (TensorProto)super.position(position);
    }

  public TensorProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TensorProto(@Const @ByRef TensorProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TensorProto from);

  public native @ByRef @Name("operator =") TensorProto put(@Const @ByRef TensorProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TensorProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const TensorProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(TensorProto other);
  

  // implements Message ----------------------------------------------

  public native TensorProto New();

  public native TensorProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TensorProto from);
  public native void MergeFrom(@Const @ByRef TensorProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int UNDEFINED();
  public static final int UNDEFINED = UNDEFINED();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int FLOAT();
  public static final int FLOAT = FLOAT();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int UINT8();
  public static final int UINT8 = UINT8();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int INT8();
  public static final int INT8 = INT8();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int UINT16();
  public static final int UINT16 = UINT16();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int INT16();
  public static final int INT16 = INT16();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int INT32();
  public static final int INT32 = INT32();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int INT64();
  public static final int INT64 = INT64();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int STRING();
  public static final int STRING = STRING();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int BOOL();
  public static final int BOOL = BOOL();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int FLOAT16();
  public static final int FLOAT16 = FLOAT16();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int DOUBLE();
  public static final int DOUBLE = DOUBLE();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int UINT32();
  public static final int UINT32 = UINT32();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int UINT64();
  public static final int UINT64 = UINT64();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int COMPLEX64();
  public static final int COMPLEX64 = COMPLEX64();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int COMPLEX128();
  public static final int COMPLEX128 = COMPLEX128();
  public static native @Cast("bool") boolean DataType_IsValid(int value);
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int DataType_MIN();
  public static final int DataType_MIN = DataType_MIN();
  @MemberGetter public static native @Cast("const onnx::TensorProto::DataType") int DataType_MAX();
  public static final int DataType_MAX = DataType_MAX();
  @MemberGetter public static native int DataType_ARRAYSIZE();
  public static final int DataType_ARRAYSIZE = DataType_ARRAYSIZE();
  public static native @Cast("const google::protobuf::EnumDescriptor*") Pointer DataType_descriptor();
  public static native @StdString BytePointer DataType_Name(@Cast("onnx::TensorProto::DataType") int value);
  public static native @Cast("bool") boolean DataType_Parse(@StdString BytePointer name,
        @Cast("onnx::TensorProto::DataType*") IntPointer value);
  public static native @Cast("bool") boolean DataType_Parse(@StdString String name,
        @Cast("onnx::TensorProto::DataType*") IntBuffer value);
  public static native @Cast("bool") boolean DataType_Parse(@StdString BytePointer name,
        @Cast("onnx::TensorProto::DataType*") int... value);
  public static native @Cast("bool") boolean DataType_Parse(@StdString String name,
        @Cast("onnx::TensorProto::DataType*") IntPointer value);
  public static native @Cast("bool") boolean DataType_Parse(@StdString BytePointer name,
        @Cast("onnx::TensorProto::DataType*") IntBuffer value);
  public static native @Cast("bool") boolean DataType_Parse(@StdString String name,
        @Cast("onnx::TensorProto::DataType*") int... value);

  // accessors -------------------------------------------------------

  // repeated int64 dims = 1;
  public native int dims_size();
  public native void clear_dims();
  @MemberGetter public static native int kDimsFieldNumber();
  public static final int kDimsFieldNumber = kDimsFieldNumber();
  public native @Cast("google::protobuf::int64") long dims(int index);
  public native void set_dims(int index, @Cast("google::protobuf::int64") long value);
  public native void add_dims(@Cast("google::protobuf::int64") long value);

  // repeated float float_data = 4 [packed = true];
  public native int float_data_size();
  public native void clear_float_data();
  @MemberGetter public static native int kFloatDataFieldNumber();
  public static final int kFloatDataFieldNumber = kFloatDataFieldNumber();
  public native float float_data(int index);
  public native void set_float_data(int index, float value);
  public native void add_float_data(float value);

  // repeated int32 int32_data = 5 [packed = true];
  public native int int32_data_size();
  public native void clear_int32_data();
  @MemberGetter public static native int kInt32DataFieldNumber();
  public static final int kInt32DataFieldNumber = kInt32DataFieldNumber();
  public native @Cast("google::protobuf::int32") int int32_data(int index);
  public native void set_int32_data(int index, @Cast("google::protobuf::int32") int value);
  public native void add_int32_data(@Cast("google::protobuf::int32") int value);

  // repeated bytes string_data = 6;
  public native int string_data_size();
  public native void clear_string_data();
  @MemberGetter public static native int kStringDataFieldNumber();
  public static final int kStringDataFieldNumber = kStringDataFieldNumber();
  public native @StdString BytePointer string_data(int index);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_string_data(int index);
  public native void set_string_data(int index, @StdString BytePointer value);
  public native void set_string_data(int index, @StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_string_data(int index, @Const Pointer value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer add_string_data();
  public native void add_string_data(@StdString BytePointer value);
  public native void add_string_data(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void add_string_data(@Const Pointer value, @Cast("size_t") long size);

  // repeated int64 int64_data = 7 [packed = true];
  public native int int64_data_size();
  public native void clear_int64_data();
  @MemberGetter public static native int kInt64DataFieldNumber();
  public static final int kInt64DataFieldNumber = kInt64DataFieldNumber();
  public native @Cast("google::protobuf::int64") long int64_data(int index);
  public native void set_int64_data(int index, @Cast("google::protobuf::int64") long value);
  public native void add_int64_data(@Cast("google::protobuf::int64") long value);

  // repeated double double_data = 10 [packed = true];
  public native int double_data_size();
  public native void clear_double_data();
  @MemberGetter public static native int kDoubleDataFieldNumber();
  public static final int kDoubleDataFieldNumber = kDoubleDataFieldNumber();
  public native double double_data(int index);
  public native void set_double_data(int index, double value);
  public native void add_double_data(double value);

  // repeated uint64 uint64_data = 11 [packed = true];
  public native int uint64_data_size();
  public native void clear_uint64_data();
  @MemberGetter public static native int kUint64DataFieldNumber();
  public static final int kUint64DataFieldNumber = kUint64DataFieldNumber();
  public native @Cast("google::protobuf::uint64") long uint64_data(int index);
  public native void set_uint64_data(int index, @Cast("google::protobuf::uint64") long value);
  public native void add_uint64_data(@Cast("google::protobuf::uint64") long value);

  // optional string name = 8;
  public native @Cast("bool") boolean has_name();
  public native void clear_name();
  @MemberGetter public static native int kNameFieldNumber();
  public static final int kNameFieldNumber = kNameFieldNumber();
  public native @StdString BytePointer name();
  public native void set_name(@StdString BytePointer value);
  public native void set_name(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_name(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_name(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_name();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_name();
  public native void set_allocated_name(@StdString @Cast({"char*", "std::string*"}) BytePointer name);

  // optional bytes raw_data = 9;
  public native @Cast("bool") boolean has_raw_data();
  public native void clear_raw_data();
  @MemberGetter public static native int kRawDataFieldNumber();
  public static final int kRawDataFieldNumber = kRawDataFieldNumber();
  public native @StdString BytePointer raw_data();
  public native void set_raw_data(@StdString BytePointer value);
  public native void set_raw_data(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_raw_data(@Const Pointer value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_raw_data();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_raw_data();
  public native void set_allocated_raw_data(@StdString @Cast({"char*", "std::string*"}) BytePointer raw_data);

  // optional string doc_string = 12;
  public native @Cast("bool") boolean has_doc_string();
  public native void clear_doc_string();
  @MemberGetter public static native int kDocStringFieldNumber();
  public static final int kDocStringFieldNumber = kDocStringFieldNumber();
  public native @StdString BytePointer doc_string();
  public native void set_doc_string(@StdString BytePointer value);
  public native void set_doc_string(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_doc_string(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_doc_string(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_doc_string();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_doc_string();
  public native void set_allocated_doc_string(@StdString @Cast({"char*", "std::string*"}) BytePointer doc_string);

  // optional .onnx.TensorProto.Segment segment = 3;
  public native @Cast("bool") boolean has_segment();
  public native void clear_segment();
  @MemberGetter public static native int kSegmentFieldNumber();
  public static final int kSegmentFieldNumber = kSegmentFieldNumber();
  public native @Const @ByRef TensorProto_Segment segment();
  public native TensorProto_Segment release_segment();
  public native TensorProto_Segment mutable_segment();
  public native void set_allocated_segment(TensorProto_Segment segment);

  // optional .onnx.TensorProto.DataType data_type = 2;
  public native @Cast("bool") boolean has_data_type();
  public native void clear_data_type();
  @MemberGetter public static native int kDataTypeFieldNumber();
  public static final int kDataTypeFieldNumber = kDataTypeFieldNumber();
  public native @Cast("onnx::TensorProto_DataType") int data_type();
  public native void set_data_type(@Cast("onnx::TensorProto_DataType") int value);
}
// -------------------------------------------------------------------

@Name("onnx::TensorShapeProto_Dimension") @NoOffset public static class Dimension extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Dimension(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Dimension(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Dimension position(long position) {
        return (Dimension)super.position(position);
    }

  public Dimension() { super((Pointer)null); allocate(); }
  private native void allocate();

  public Dimension(@Const @ByRef Dimension from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef Dimension from);

  public native @ByRef @Name("operator =") Dimension put(@Const @ByRef Dimension from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef Dimension default_instance();

  /** enum onnx::TensorShapeProto_Dimension::ValueCase */
  public static final int
    kDimValue = 1,
    kDimParam = 2,
    VALUE_NOT_SET = 0;

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const Dimension internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(Dimension other);
  

  // implements Message ----------------------------------------------

  public native Dimension New();

  public native Dimension New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef Dimension from);
  public native void MergeFrom(@Const @ByRef Dimension from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string denotation = 3;
  public native @Cast("bool") boolean has_denotation();
  public native void clear_denotation();
  @MemberGetter public static native int kDenotationFieldNumber();
  public static final int kDenotationFieldNumber = kDenotationFieldNumber();
  public native @StdString BytePointer denotation();
  public native void set_denotation(@StdString BytePointer value);
  public native void set_denotation(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_denotation(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_denotation(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_denotation();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_denotation();
  public native void set_allocated_denotation(@StdString @Cast({"char*", "std::string*"}) BytePointer denotation);

  // optional int64 dim_value = 1;
  public native @Cast("bool") boolean has_dim_value();
  public native void clear_dim_value();
  @MemberGetter public static native int kDimValueFieldNumber();
  public static final int kDimValueFieldNumber = kDimValueFieldNumber();
  public native @Cast("google::protobuf::int64") long dim_value();
  public native void set_dim_value(@Cast("google::protobuf::int64") long value);

  // optional string dim_param = 2;
  public native @Cast("bool") boolean has_dim_param();
  public native void clear_dim_param();
  @MemberGetter public static native int kDimParamFieldNumber();
  public static final int kDimParamFieldNumber = kDimParamFieldNumber();
  public native @StdString BytePointer dim_param();
  public native void set_dim_param(@StdString BytePointer value);
  public native void set_dim_param(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_dim_param(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_dim_param(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_dim_param();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_dim_param();
  public native void set_allocated_dim_param(@StdString @Cast({"char*", "std::string*"}) BytePointer dim_param);

  public native @Cast("onnx::TensorShapeProto_Dimension::ValueCase") int value_case();
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TensorShapeProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TensorShapeProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TensorShapeProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TensorShapeProto position(long position) {
        return (TensorShapeProto)super.position(position);
    }

  public TensorShapeProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TensorShapeProto(@Const @ByRef TensorShapeProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TensorShapeProto from);

  public native @ByRef @Name("operator =") TensorShapeProto put(@Const @ByRef TensorShapeProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TensorShapeProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const TensorShapeProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(TensorShapeProto other);
  

  // implements Message ----------------------------------------------

  public native TensorShapeProto New();

  public native TensorShapeProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TensorShapeProto from);
  public native void MergeFrom(@Const @ByRef TensorShapeProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .onnx.TensorShapeProto.Dimension dim = 1;
  public native int dim_size();
  public native void clear_dim();
  @MemberGetter public static native int kDimFieldNumber();
  public static final int kDimFieldNumber = kDimFieldNumber();
  public native @Const @ByRef Dimension dim(int index);
  public native Dimension mutable_dim(int index);
  public native Dimension add_dim();
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TypeProto_Tensor extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProto_Tensor(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TypeProto_Tensor(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TypeProto_Tensor position(long position) {
        return (TypeProto_Tensor)super.position(position);
    }

  public TypeProto_Tensor() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TypeProto_Tensor(@Const @ByRef TypeProto_Tensor from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TypeProto_Tensor from);

  public native @ByRef @Name("operator =") TypeProto_Tensor put(@Const @ByRef TypeProto_Tensor from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TypeProto_Tensor default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const TypeProto_Tensor internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(TypeProto_Tensor other);
  

  // implements Message ----------------------------------------------

  public native TypeProto_Tensor New();

  public native TypeProto_Tensor New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TypeProto_Tensor from);
  public native void MergeFrom(@Const @ByRef TypeProto_Tensor from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .onnx.TensorShapeProto shape = 2;
  public native @Cast("bool") boolean has_shape();
  public native void clear_shape();
  @MemberGetter public static native int kShapeFieldNumber();
  public static final int kShapeFieldNumber = kShapeFieldNumber();
  public native @Const @ByRef TensorShapeProto shape();
  public native TensorShapeProto release_shape();
  public native TensorShapeProto mutable_shape();
  public native void set_allocated_shape(TensorShapeProto shape);

  // optional .onnx.TensorProto.DataType elem_type = 1;
  public native @Cast("bool") boolean has_elem_type();
  public native void clear_elem_type();
  @MemberGetter public static native int kElemTypeFieldNumber();
  public static final int kElemTypeFieldNumber = kElemTypeFieldNumber();
  public native @Cast("onnx::TensorProto_DataType") int elem_type();
  public native void set_elem_type(@Cast("onnx::TensorProto_DataType") int value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TypeProto_Sequence extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProto_Sequence(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TypeProto_Sequence(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TypeProto_Sequence position(long position) {
        return (TypeProto_Sequence)super.position(position);
    }

  public TypeProto_Sequence() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TypeProto_Sequence(@Const @ByRef TypeProto_Sequence from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TypeProto_Sequence from);

  public native @ByRef @Name("operator =") TypeProto_Sequence put(@Const @ByRef TypeProto_Sequence from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TypeProto_Sequence default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const TypeProto_Sequence internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(TypeProto_Sequence other);
  

  // implements Message ----------------------------------------------

  public native TypeProto_Sequence New();

  public native TypeProto_Sequence New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TypeProto_Sequence from);
  public native void MergeFrom(@Const @ByRef TypeProto_Sequence from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .onnx.TypeProto elem_type = 1;
  public native @Cast("bool") boolean has_elem_type();
  public native void clear_elem_type();
  @MemberGetter public static native int kElemTypeFieldNumber();
  public static final int kElemTypeFieldNumber = kElemTypeFieldNumber();
  public native @Const @ByRef TypeProto elem_type();
  public native TypeProto release_elem_type();
  public native TypeProto mutable_elem_type();
  public native void set_allocated_elem_type(TypeProto elem_type);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TypeProto_Map extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProto_Map(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TypeProto_Map(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TypeProto_Map position(long position) {
        return (TypeProto_Map)super.position(position);
    }

  public TypeProto_Map() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TypeProto_Map(@Const @ByRef TypeProto_Map from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TypeProto_Map from);

  public native @ByRef @Name("operator =") TypeProto_Map put(@Const @ByRef TypeProto_Map from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TypeProto_Map default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const TypeProto_Map internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(TypeProto_Map other);
  

  // implements Message ----------------------------------------------

  public native TypeProto_Map New();

  public native TypeProto_Map New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TypeProto_Map from);
  public native void MergeFrom(@Const @ByRef TypeProto_Map from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .onnx.TypeProto value_type = 2;
  public native @Cast("bool") boolean has_value_type();
  public native void clear_value_type();
  @MemberGetter public static native int kValueTypeFieldNumber();
  public static final int kValueTypeFieldNumber = kValueTypeFieldNumber();
  public native @Const @ByRef TypeProto value_type();
  public native TypeProto release_value_type();
  public native TypeProto mutable_value_type();
  public native void set_allocated_value_type(TypeProto value_type);

  // optional .onnx.TensorProto.DataType key_type = 1;
  public native @Cast("bool") boolean has_key_type();
  public native void clear_key_type();
  @MemberGetter public static native int kKeyTypeFieldNumber();
  public static final int kKeyTypeFieldNumber = kKeyTypeFieldNumber();
  public native @Cast("onnx::TensorProto_DataType") int key_type();
  public native void set_key_type(@Cast("onnx::TensorProto_DataType") int value);
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class TypeProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TypeProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TypeProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TypeProto position(long position) {
        return (TypeProto)super.position(position);
    }

  public TypeProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public TypeProto(@Const @ByRef TypeProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef TypeProto from);

  public native @ByRef @Name("operator =") TypeProto put(@Const @ByRef TypeProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef TypeProto default_instance();

  /** enum onnx::TypeProto::ValueCase */
  public static final int
    kTensorType = 1,
    kSequenceType = 4,
    kMapType = 5,
    VALUE_NOT_SET = 0;

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const TypeProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(TypeProto other);
  

  // implements Message ----------------------------------------------

  public native TypeProto New();

  public native TypeProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef TypeProto from);
  public native void MergeFrom(@Const @ByRef TypeProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string denotation = 6;
  public native @Cast("bool") boolean has_denotation();
  public native void clear_denotation();
  @MemberGetter public static native int kDenotationFieldNumber();
  public static final int kDenotationFieldNumber = kDenotationFieldNumber();
  public native @StdString BytePointer denotation();
  public native void set_denotation(@StdString BytePointer value);
  public native void set_denotation(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_denotation(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_denotation(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_denotation();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_denotation();
  public native void set_allocated_denotation(@StdString @Cast({"char*", "std::string*"}) BytePointer denotation);

  // optional .onnx.TypeProto.Tensor tensor_type = 1;
  public native @Cast("bool") boolean has_tensor_type();
  public native void clear_tensor_type();
  @MemberGetter public static native int kTensorTypeFieldNumber();
  public static final int kTensorTypeFieldNumber = kTensorTypeFieldNumber();
  public native @Const @ByRef TypeProto_Tensor tensor_type();
  public native TypeProto_Tensor release_tensor_type();
  public native TypeProto_Tensor mutable_tensor_type();
  public native void set_allocated_tensor_type(TypeProto_Tensor tensor_type);

  // optional .onnx.TypeProto.Sequence sequence_type = 4;
  public native @Cast("bool") boolean has_sequence_type();
  public native void clear_sequence_type();
  @MemberGetter public static native int kSequenceTypeFieldNumber();
  public static final int kSequenceTypeFieldNumber = kSequenceTypeFieldNumber();
  public native @Const @ByRef TypeProto_Sequence sequence_type();
  public native TypeProto_Sequence release_sequence_type();
  public native TypeProto_Sequence mutable_sequence_type();
  public native void set_allocated_sequence_type(TypeProto_Sequence sequence_type);

  // optional .onnx.TypeProto.Map map_type = 5;
  public native @Cast("bool") boolean has_map_type();
  public native void clear_map_type();
  @MemberGetter public static native int kMapTypeFieldNumber();
  public static final int kMapTypeFieldNumber = kMapTypeFieldNumber();
  public native @Const @ByRef TypeProto_Map map_type();
  public native TypeProto_Map release_map_type();
  public native TypeProto_Map mutable_map_type();
  public native void set_allocated_map_type(TypeProto_Map map_type);

  public native @Cast("onnx::TypeProto::ValueCase") int value_case();
}
// -------------------------------------------------------------------

@Namespace("onnx") @NoOffset public static class OperatorSetIdProto extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OperatorSetIdProto(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public OperatorSetIdProto(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public OperatorSetIdProto position(long position) {
        return (OperatorSetIdProto)super.position(position);
    }

  public OperatorSetIdProto() { super((Pointer)null); allocate(); }
  private native void allocate();

  public OperatorSetIdProto(@Const @ByRef OperatorSetIdProto from) { super((Pointer)null); allocate(from); }
  private native void allocate(@Const @ByRef OperatorSetIdProto from);

  public native @ByRef @Name("operator =") OperatorSetIdProto put(@Const @ByRef OperatorSetIdProto from);
//   #if LANG_CXX11
//   #endif
  public native @Const @ByRef UnknownFieldSet unknown_fields();
  public native UnknownFieldSet mutable_unknown_fields();

  public static native @Cast("const google::protobuf::Descriptor*") Pointer descriptor();
  public static native @Const @ByRef OperatorSetIdProto default_instance();

  public static native void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  public static native @Const OperatorSetIdProto internal_default_instance();
  @MemberGetter public static native int kIndexInFileMessages();
  public static final int kIndexInFileMessages = kIndexInFileMessages();

  public native void Swap(OperatorSetIdProto other);
  

  // implements Message ----------------------------------------------

  public native OperatorSetIdProto New();

  public native OperatorSetIdProto New(Arena arena);
  public native void CopyFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void MergeFrom(@Cast("const google::protobuf::Message*") @ByRef MessageLite from);
  public native void CopyFrom(@Const @ByRef OperatorSetIdProto from);
  public native void MergeFrom(@Const @ByRef OperatorSetIdProto from);
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();

  public native @Cast("size_t") long ByteSizeLong();
  public native @Cast("bool") boolean MergePartialFromCodedStream(
        CodedInputStream input);
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(
        @Cast("bool") boolean deterministic, @Cast("google::protobuf::uint8*") byte[] target);
  public native int GetCachedSize();

  public native @ByVal @Cast("google::protobuf::Metadata*") Pointer GetMetadata();

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string domain = 1;
  public native @Cast("bool") boolean has_domain();
  public native void clear_domain();
  @MemberGetter public static native int kDomainFieldNumber();
  public static final int kDomainFieldNumber = kDomainFieldNumber();
  public native @StdString BytePointer domain();
  public native void set_domain(@StdString BytePointer value);
  public native void set_domain(@StdString String value);
//   #if LANG_CXX11
//   #endif
  public native void set_domain(@Cast("const char*") BytePointer value, @Cast("size_t") long size);
  public native void set_domain(String value, @Cast("size_t") long size);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_domain();
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer release_domain();
  public native void set_allocated_domain(@StdString @Cast({"char*", "std::string*"}) BytePointer domain);

  // optional int64 version = 2;
  public native @Cast("bool") boolean has_version();
  public native void clear_version();
  @MemberGetter public static native int kVersionFieldNumber();
  public static final int kVersionFieldNumber = kVersionFieldNumber();
  public native @Cast("google::protobuf::int64") long version();
  public native void set_version(@Cast("google::protobuf::int64") long value);
}
// ===================================================================


// ===================================================================

// #ifdef __GNUC__
//   #pragma GCC diagnostic push
//   #pragma GCC diagnostic ignored "-Wstrict-aliasing"
// #endif  // __GNUC__
// AttributeProto

// optional string name = 1;






// #if LANG_CXX11

// #endif






// optional string ref_attr_name = 21;






// #if LANG_CXX11

// #endif






// optional string doc_string = 13;






// #if LANG_CXX11

// #endif






// optional .onnx.AttributeProto.AttributeType type = 20;







// optional float f = 2;







// optional int64 i = 3;







// optional bytes s = 4;






// #if LANG_CXX11

// #endif






// optional .onnx.TensorProto t = 5;









// optional .onnx.GraphProto g = 6;









// repeated float floats = 7;








// repeated int64 ints = 8;








// repeated bytes strings = 9;





// #if LANG_CXX11

// #endif




// #if LANG_CXX11

// #endif





// repeated .onnx.TensorProto tensors = 10;








// repeated .onnx.GraphProto graphs = 11;








// -------------------------------------------------------------------

// ValueInfoProto

// optional string name = 1;






// #if LANG_CXX11

// #endif






// optional .onnx.TypeProto type = 2;









// optional string doc_string = 3;






// #if LANG_CXX11

// #endif






// -------------------------------------------------------------------

// NodeProto

// repeated string input = 1;





// #if LANG_CXX11

// #endif




// #if LANG_CXX11

// #endif





// repeated string output = 2;





// #if LANG_CXX11

// #endif




// #if LANG_CXX11

// #endif





// optional string name = 3;






// #if LANG_CXX11

// #endif






// optional string op_type = 4;






// #if LANG_CXX11

// #endif






// optional string domain = 7;






// #if LANG_CXX11

// #endif






// repeated .onnx.AttributeProto attribute = 5;








// optional string doc_string = 6;






// #if LANG_CXX11

// #endif






// -------------------------------------------------------------------

// ModelProto

// optional int64 ir_version = 1;







// repeated .onnx.OperatorSetIdProto opset_import = 8;








// optional string producer_name = 2;






// #if LANG_CXX11

// #endif






// optional string producer_version = 3;






// #if LANG_CXX11

// #endif






// optional string domain = 4;






// #if LANG_CXX11

// #endif






// optional int64 model_version = 5;







// optional string doc_string = 6;






// #if LANG_CXX11

// #endif






// optional .onnx.GraphProto graph = 7;









// repeated .onnx.StringStringEntryProto metadata_props = 14;








// -------------------------------------------------------------------

// StringStringEntryProto

// optional string key = 1;






// #if LANG_CXX11

// #endif






// optional string value = 2;






// #if LANG_CXX11

// #endif






// -------------------------------------------------------------------

// GraphProto

// repeated .onnx.NodeProto node = 1;








// optional string name = 2;






// #if LANG_CXX11

// #endif






// repeated .onnx.TensorProto initializer = 5;








// optional string doc_string = 10;






// #if LANG_CXX11

// #endif






// repeated .onnx.ValueInfoProto input = 11;








// repeated .onnx.ValueInfoProto output = 12;








// repeated .onnx.ValueInfoProto value_info = 13;








// -------------------------------------------------------------------

// TensorProto_Segment

// optional int64 begin = 1;







// optional int64 end = 2;







// -------------------------------------------------------------------

// TensorProto

// repeated int64 dims = 1;








// optional .onnx.TensorProto.DataType data_type = 2;







// optional .onnx.TensorProto.Segment segment = 3;









// repeated float float_data = 4 [packed = true];








// repeated int32 int32_data = 5 [packed = true];








// repeated bytes string_data = 6;





// #if LANG_CXX11

// #endif




// #if LANG_CXX11

// #endif





// repeated int64 int64_data = 7 [packed = true];








// optional string name = 8;






// #if LANG_CXX11

// #endif






// optional string doc_string = 12;






// #if LANG_CXX11

// #endif






// optional bytes raw_data = 9;






// #if LANG_CXX11

// #endif






// repeated double double_data = 10 [packed = true];








// repeated uint64 uint64_data = 11 [packed = true];








// -------------------------------------------------------------------

// TensorShapeProto_Dimension

// optional int64 dim_value = 1;






// optional string dim_param = 2;





// #if LANG_CXX11

// #endif






// optional string denotation = 3;






// #if LANG_CXX11

// #endif









// -------------------------------------------------------------------

// TensorShapeProto

// repeated .onnx.TensorShapeProto.Dimension dim = 1;








// -------------------------------------------------------------------

// TypeProto_Tensor

// optional .onnx.TensorProto.DataType elem_type = 1;







// optional .onnx.TensorShapeProto shape = 2;









// -------------------------------------------------------------------

// TypeProto_Sequence

// optional .onnx.TypeProto elem_type = 1;









// -------------------------------------------------------------------

// TypeProto_Map

// optional .onnx.TensorProto.DataType key_type = 1;







// optional .onnx.TypeProto value_type = 2;









// -------------------------------------------------------------------

// TypeProto

// optional .onnx.TypeProto.Tensor tensor_type = 1;







// optional .onnx.TypeProto.Sequence sequence_type = 4;







// optional .onnx.TypeProto.Map map_type = 5;







// optional string denotation = 6;






// #if LANG_CXX11

// #endif









// -------------------------------------------------------------------

// OperatorSetIdProto

// optional string domain = 1;






// #if LANG_CXX11

// #endif






// optional int64 version = 2;







// #ifdef __GNUC__
//   #pragma GCC diagnostic pop
// #endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

  // namespace onnx




  // namespace protobuf
  // namespace google

// @@protoc_insertion_point(global_scope)

// #endif  // PROTOBUF_onnx_2dml_2eproto__INCLUDED


// Parsed from google/protobuf/message_lite.h

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Authors: wink@google.com (Wink Saville),
//          kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// Defines MessageLite, the abstract interface implemented by all (lite
// and non-lite) protocol message objects.

// #ifndef GOOGLE_PROTOBUF_MESSAGE_LITE_H__
// #define GOOGLE_PROTOBUF_MESSAGE_LITE_H__

// #include <climits>
// #include <google/protobuf/stubs/common.h>
// #include <google/protobuf/stubs/logging.h>
// #include <google/protobuf/stubs/once.h>
// #include <google/protobuf/stubs/port.h>
@Namespace("google::protobuf") @Opaque public static class Arena extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Arena() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Arena(Pointer p) { super(p); }
}
@Namespace("google::protobuf::io") @Opaque public static class CodedInputStream extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public CodedInputStream() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CodedInputStream(Pointer p) { super(p); }
}
@Namespace("google::protobuf::io") @Opaque public static class CodedOutputStream extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public CodedOutputStream() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CodedOutputStream(Pointer p) { super(p); }
}
@Namespace("google::protobuf::io") @Opaque public static class ZeroCopyInputStream extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ZeroCopyInputStream() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ZeroCopyInputStream(Pointer p) { super(p); }
}
@Namespace("google::protobuf::io") @Opaque public static class ZeroCopyOutputStream extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ZeroCopyOutputStream() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ZeroCopyOutputStream(Pointer p) { super(p); }
}


@Namespace("google::protobuf::internal") @Opaque public static class WireFormatLite extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public WireFormatLite() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public WireFormatLite(Pointer p) { super(p); }
}

// #ifndef SWIG
// We compute sizes as size_t but cache them as int.  This function converts a
// computed size to a cached size.  Since we don't proceed with serialization
// if the total size was > INT_MAX, it is not important what this function
// returns for inputs > INT_MAX.  However this case should not error or
// GOOGLE_CHECK-fail, because the full size_t resolution is still returned from
// ByteSizeLong() and checked against INT_MAX; we can catch the overflow
// there.
@Namespace("google::protobuf::internal") public static native int ToCachedSize(@Cast("size_t") long size);

// We mainly calculate sizes in terms of size_t, but some functions that
// compute sizes return "int".  These int sizes are expected to always be
// positive. This function is more efficient than casting an int to size_t
// directly on 64-bit platforms because it avoids making the compiler emit a
// sign extending instruction, which we don't want and don't want to pay for.
@Namespace("google::protobuf::internal") public static native @Cast("size_t") long FromIntSize(int size);

// For cases where a legacy function returns an integer size.  We GOOGLE_DCHECK()
// that the conversion will fit within an integer; if this is false then we
// are losing information.
@Namespace("google::protobuf::internal") public static native int ToIntSize(@Cast("size_t") long size);

// This type wraps a variable whose constructor and destructor are explicitly
// called. It is particularly useful for a global variable, without its
// constructor and destructor run on start and end of the program lifetime.
// This circumvents the initial construction order fiasco, while keeping
// the address of the empty string a compile time constant.
//
// Pay special attention to the initialization state of the object.
// 1. The object is "uninitialized" to begin with.
// 2. Call DefaultConstruct() only if the object is uninitialized.
//    After the call, the object becomes "initialized".
// 3. Call get() and get_mutable() only if the object is initialized.
// 4. Call Destruct() only if the object is initialized.
//    After the call, the object becomes uninitialized.

// Default empty string object. Don't use this directly. Instead, call
// GetEmptyString() to get the reference.

@Namespace("google::protobuf::internal") public static native void InitEmptyString();


@Namespace("google::protobuf::internal") public static native @StdString BytePointer GetEmptyStringAlreadyInited();

@Namespace("google::protobuf::internal") public static native @StdString BytePointer GetEmptyString();

@Namespace("google::protobuf::internal") public static native @Cast("size_t") long StringSpaceUsedExcludingSelfLong(@StdString BytePointer str);
@Namespace("google::protobuf::internal") public static native @Cast("size_t") long StringSpaceUsedExcludingSelfLong(@StdString String str);
// #endif  // SWIG
  // namespace internal

// Interface to light weight protocol messages.
//
// This interface is implemented by all protocol message objects.  Non-lite
// messages additionally implement the Message interface, which is a
// subclass of MessageLite.  Use MessageLite instead when you only need
// the subset of features which it supports -- namely, nothing that uses
// descriptors or reflection.  You can instruct the protocol compiler
// to generate classes which implement only MessageLite, not the full
// Message interface, by adding the following line to the .proto file:
//
//   option optimize_for = LITE_RUNTIME;
//
// This is particularly useful on resource-constrained systems where
// the full protocol buffers runtime library is too big.
//
// Note that on non-constrained systems (e.g. servers) when you need
// to link in lots of protocol definitions, a better way to reduce
// total code footprint is to use optimize_for = CODE_SIZE.  This
// will make the generated code smaller while still supporting all the
// same features (at the expense of speed).  optimize_for = LITE_RUNTIME
// is best when you only have a small number of message types linked
// into your binary, in which case the size of the protocol buffers
// runtime itself is the biggest problem.
@Namespace("google::protobuf") public static class MessageLite extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MessageLite(Pointer p) { super(p); }


  // Basic Operations ------------------------------------------------

  // Get the name of this message type, e.g. "foo.bar.BazProto".
  public native @StdString BytePointer GetTypeName();

  // Construct a new instance of the same type.  Ownership is passed to the
  // caller.
  public native MessageLite New();

  // Construct a new instance on the arena. Ownership is passed to the caller
  // if arena is a NULL. Default implementation for backwards compatibility.
  public native MessageLite New(Arena arena);

  // Get the arena, if any, associated with this message. Virtual method
  // required for generic operations but most arena-related operations should
  // use the GetArenaNoVirtual() generated-code method. Default implementation
  // to reduce code size by avoiding the need for per-type implementations
  // when types do not implement arena support.
  public native Arena GetArena();

  // Get a pointer that may be equal to this message's arena, or may not be.
  // If the value returned by this method is equal to some arena pointer, then
  // this message is on that arena; however, if this message is on some arena,
  // this method may or may not return that arena's pointer. As a tradeoff,
  // this method may be more efficient than GetArena(). The intent is to allow
  // underlying representations that use e.g. tagged pointers to sometimes
  // store the arena pointer directly, and sometimes in a more indirect way,
  // and allow a fastpath comparison against the arena pointer when it's easy
  // to obtain.
  public native Pointer GetMaybeArenaPointer();

  // Clear all fields of the message and set them to their default values.
  // Clear() avoids freeing memory, assuming that any memory allocated
  // to hold parts of the message will be needed again to hold the next
  // message.  If you actually want to free the memory used by a Message,
  // you must delete it.
  public native void Clear();

  // Quickly check if all required fields have values set.
  public native @Cast("bool") boolean IsInitialized();

  // This is not implemented for Lite messages -- it just returns "(cannot
  // determine missing fields for lite message)".  However, it is implemented
  // for full messages.  See message.h.
  public native @StdString BytePointer InitializationErrorString();

  // If |other| is the exact same class as this, calls MergeFrom(). Otherwise,
  // results are undefined (probably crash).
  public native void CheckTypeAndMergeFrom(@Const @ByRef MessageLite other);

  // Parsing ---------------------------------------------------------
  // Methods for parsing in protocol buffer format.  Most of these are
  // just simple wrappers around MergeFromCodedStream().  Clear() will be
  // called before merging the input.

  // Fill the message with a protocol buffer parsed from the given input
  // stream. Returns false on a read error or if the input is in the wrong
  // format.  A successful return does not indicate the entire input is
  // consumed, ensure you call ConsumedEntireMessage() to check that if
  // applicable.
  public native @Cast("bool") boolean ParseFromCodedStream(CodedInputStream input);
  // Like ParseFromCodedStream(), but accepts messages that are missing
  // required fields.
  public native @Cast("bool") boolean ParsePartialFromCodedStream(CodedInputStream input);
  // Read a protocol buffer from the given zero-copy input stream.  If
  // successful, the entire input will be consumed.
  public native @Cast("bool") boolean ParseFromZeroCopyStream(ZeroCopyInputStream input);
  // Like ParseFromZeroCopyStream(), but accepts messages that are missing
  // required fields.
  public native @Cast("bool") boolean ParsePartialFromZeroCopyStream(ZeroCopyInputStream input);
  // Read a protocol buffer from the given zero-copy input stream, expecting
  // the message to be exactly "size" bytes long.  If successful, exactly
  // this many bytes will have been consumed from the input.
  public native @Cast("bool") boolean ParseFromBoundedZeroCopyStream(ZeroCopyInputStream input, int size);
  // Like ParseFromBoundedZeroCopyStream(), but accepts messages that are
  // missing required fields.
  public native @Cast("bool") boolean ParsePartialFromBoundedZeroCopyStream(ZeroCopyInputStream input,
                                               int size);
  // Parses a protocol buffer contained in a string. Returns true on success.
  // This function takes a string in the (non-human-readable) binary wire
  // format, matching the encoding output by MessageLite::SerializeToString().
  // If you'd like to convert a human-readable string into a protocol buffer
  // object, see google::protobuf::TextFormat::ParseFromString().
  public native @Cast("bool") boolean ParseFromString(@StdString BytePointer data);
  public native @Cast("bool") boolean ParseFromString(@StdString String data);
  // Like ParseFromString(), but accepts messages that are missing
  // required fields.
  public native @Cast("bool") boolean ParsePartialFromString(@StdString BytePointer data);
  public native @Cast("bool") boolean ParsePartialFromString(@StdString String data);
  // Parse a protocol buffer contained in an array of bytes.
  public native @Cast("bool") boolean ParseFromArray(@Const Pointer data, int size);
  // Like ParseFromArray(), but accepts messages that are missing
  // required fields.
  public native @Cast("bool") boolean ParsePartialFromArray(@Const Pointer data, int size);


  // Reads a protocol buffer from the stream and merges it into this
  // Message.  Singular fields read from the input overwrite what is
  // already in the Message and repeated fields are appended to those
  // already present.
  //
  // It is the responsibility of the caller to call input->LastTagWas()
  // (for groups) or input->ConsumedEntireMessage() (for non-groups) after
  // this returns to verify that the message's end was delimited correctly.
  //
  // ParsefromCodedStream() is implemented as Clear() followed by
  // MergeFromCodedStream().
  public native @Cast("bool") boolean MergeFromCodedStream(CodedInputStream input);

  // Like MergeFromCodedStream(), but succeeds even if required fields are
  // missing in the input.
  //
  // MergeFromCodedStream() is just implemented as MergePartialFromCodedStream()
  // followed by IsInitialized().
  public native @Cast("bool") boolean MergePartialFromCodedStream(CodedInputStream input);


  // Serialization ---------------------------------------------------
  // Methods for serializing in protocol buffer format.  Most of these
  // are just simple wrappers around ByteSize() and SerializeWithCachedSizes().

  // Write a protocol buffer of this message to the given output.  Returns
  // false on a write error.  If the message is missing required fields,
  // this may GOOGLE_CHECK-fail.
  public native @Cast("bool") boolean SerializeToCodedStream(CodedOutputStream output);
  // Like SerializeToCodedStream(), but allows missing required fields.
  public native @Cast("bool") boolean SerializePartialToCodedStream(CodedOutputStream output);
  // Write the message to the given zero-copy output stream.  All required
  // fields must be set.
  public native @Cast("bool") boolean SerializeToZeroCopyStream(ZeroCopyOutputStream output);
  // Like SerializeToZeroCopyStream(), but allows missing required fields.
  public native @Cast("bool") boolean SerializePartialToZeroCopyStream(ZeroCopyOutputStream output);
  // Serialize the message and store it in the given string.  All required
  // fields must be set.
  public native @Cast("bool") boolean SerializeToString(@StdString @Cast({"char*", "std::string*"}) BytePointer output);
  // Like SerializeToString(), but allows missing required fields.
  public native @Cast("bool") boolean SerializePartialToString(@StdString @Cast({"char*", "std::string*"}) BytePointer output);
  // Serialize the message and store it in the given byte array.  All required
  // fields must be set.
  public native @Cast("bool") boolean SerializeToArray(Pointer data, int size);
  // Like SerializeToArray(), but allows missing required fields.
  public native @Cast("bool") boolean SerializePartialToArray(Pointer data, int size);

  // Make a string encoding the message. Is equivalent to calling
  // SerializeToString() on a string and using that.  Returns the empty
  // string if SerializeToString() would have returned an error.
  // Note: If you intend to generate many such strings, you may
  // reduce heap fragmentation by instead re-using the same string
  // object with calls to SerializeToString().
  public native @StdString BytePointer SerializeAsString();
  // Like SerializeAsString(), but allows missing required fields.
  public native @StdString BytePointer SerializePartialAsString();

  // Like SerializeToString(), but appends to the data to the string's existing
  // contents.  All required fields must be set.
  public native @Cast("bool") boolean AppendToString(@StdString @Cast({"char*", "std::string*"}) BytePointer output);
  // Like AppendToString(), but allows missing required fields.
  public native @Cast("bool") boolean AppendPartialToString(@StdString @Cast({"char*", "std::string*"}) BytePointer output);

  // Computes the serialized size of the message.  This recursively calls
  // ByteSizeLong() on all embedded messages.
  //
  // ByteSizeLong() is generally linear in the number of fields defined for the
  // proto.
  public native @Cast("size_t") long ByteSizeLong();

  // Legacy ByteSize() API.
  public native int ByteSize();

  // Serializes the message without recomputing the size.  The message must not
  // have changed since the last call to ByteSize(), and the value returned by
  // ByteSize must be non-negative.  Otherwise the results are undefined.
  public native void SerializeWithCachedSizes(
        CodedOutputStream output);

  // Functions below here are not part of the public interface.  It isn't
  // enforced, but they should be treated as private, and will be private
  // at some future time.  Unfortunately the implementation of the "friend"
  // keyword in GCC is broken at the moment, but we expect it will be fixed.

  // Like SerializeWithCachedSizes, but writes directly to *target, returning
  // a pointer to the byte immediately after the last byte written.  "target"
  // must point at a byte array of at least ByteSize() bytes.  Whether to use
  // deterministic serialization, e.g., maps in sorted order, is determined by
  // CodedOutputStream::IsDefaultSerializationDeterministic().
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeWithCachedSizesToArray(@Cast("google::protobuf::uint8*") byte[] target);

  // Returns the result of the last call to ByteSize().  An embedded message's
  // size is needed both to serialize it (because embedded messages are
  // length-delimited) and to compute the outer message's size.  Caching
  // the size avoids computing it multiple times.
  //
  // ByteSize() does not automatically use the cached size when available
  // because this would require invalidating it every time the message was
  // modified, which would be too hard and expensive.  (E.g. if a deeply-nested
  // sub-message is changed, all of its parents' cached sizes would need to be
  // invalidated, which is too much work for an otherwise inlined setter
  // method.)
  public native int GetCachedSize();

  public native @Cast("google::protobuf::uint8*") BytePointer InternalSerializeWithCachedSizesToArray(@Cast("bool") boolean deterministic,
                                                           @Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer InternalSerializeWithCachedSizesToArray(@Cast("bool") boolean deterministic,
                                                           @Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] InternalSerializeWithCachedSizesToArray(@Cast("bool") boolean deterministic,
                                                           @Cast("google::protobuf::uint8*") byte[] target);
}



// DO NOT USE: For migration only. Will be removed when Proto3 defaults to
// preserve unknowns.
@Namespace("google::protobuf::internal") public static native @Cast("bool") boolean GetProto3PreserveUnknownsDefault();

// DO NOT USE: For migration only. Will be removed when Proto3 defaults to
// preserve unknowns.
@Namespace("google::protobuf::internal") public static native void SetProto3PreserveUnknownsDefault(@Cast("bool") boolean preserve);
  // namespace internal


  // namespace protobuf

  // namespace google
// #endif  // GOOGLE_PROTOBUF_MESSAGE_LITE_H__


// Parsed from google/protobuf/unknown_field_set.h

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// Contains classes used to keep track of unrecognized fields seen while
// parsing a protocol message.

// #ifndef GOOGLE_PROTOBUF_UNKNOWN_FIELD_SET_H__
// #define GOOGLE_PROTOBUF_UNKNOWN_FIELD_SET_H__

// #include <assert.h>
// #include <string>
// #include <vector>
// #include <google/protobuf/stubs/common.h>
// #include <google/protobuf/stubs/logging.h>
// #include <google/protobuf/message_lite.h>         // coded_stream.h        // coded_stream.h      // zero_copy_stream.h
  
    @Namespace("google::protobuf::internal") @Opaque public static class InternalMetadataWithArena extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public InternalMetadataWithArena() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public InternalMetadataWithArena(Pointer p) { super(p); }
    }  // metadata.h
    @Namespace("google::protobuf::internal") @Opaque public static class WireFormat extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public WireFormat() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public WireFormat(Pointer p) { super(p); }
    }               // wire_format.h
    @Namespace("google::protobuf::internal") @Opaque public static class MessageSetFieldSkipperUsingCord extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public MessageSetFieldSkipperUsingCord() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public MessageSetFieldSkipperUsingCord(Pointer p) { super(p); }
    }
                                    // extension_set_heavy.cc
                        // message.h                 // below

// An UnknownFieldSet contains fields that were encountered while parsing a
// message but were not defined by its type.  Keeping track of these can be
// useful, especially in that they may be written if the message is serialized
// again without being cleared in between.  This means that software which
// simply receives messages and forwards them to other servers does not need
// to be updated every time a new field is added to the message definition.
//
// To get the UnknownFieldSet attached to any message, call
// Reflection::GetUnknownFields().
//
// This class is necessarily tied to the protocol buffer wire format, unlike
// the Reflection interface which is independent of any serialization scheme.
@Namespace("google::protobuf") @NoOffset public static class UnknownFieldSet extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public UnknownFieldSet(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public UnknownFieldSet(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public UnknownFieldSet position(long position) {
        return (UnknownFieldSet)super.position(position);
    }

  public UnknownFieldSet() { super((Pointer)null); allocate(); }
  private native void allocate();

  // Remove all fields.
  public native void Clear();

  // Remove all fields and deallocate internal data objects
  public native void ClearAndFreeMemory();

  // Is this set empty?
  public native @Cast("bool") boolean empty();

  // Merge the contents of some other UnknownFieldSet with this one.
  public native void MergeFrom(@Const @ByRef UnknownFieldSet other);

  // Similar to above, but this function will destroy the contents of other.
  public native void MergeFromAndDestroy(UnknownFieldSet other);

  // Merge the contents an UnknownFieldSet with the UnknownFieldSet in
  // *metadata, if there is one.  If *metadata doesn't have an UnknownFieldSet
  // then add one to it and make it be a copy of the first arg.
  public static native void MergeToInternalMetdata(
        @Const @ByRef UnknownFieldSet other,
        InternalMetadataWithArena metadata);

  // Swaps the contents of some other UnknownFieldSet with this one.
  public native void Swap(UnknownFieldSet x);

  // Computes (an estimate of) the total number of bytes currently used for
  // storing the unknown fields in memory. Does NOT include
  // sizeof(*this) in the calculation.
  public native @Cast("size_t") long SpaceUsedExcludingSelfLong();

  public native int SpaceUsedExcludingSelf();

  // Version of SpaceUsed() including sizeof(*this).
  public native @Cast("size_t") long SpaceUsedLong();

  public native int SpaceUsed();

  // Returns the number of fields present in the UnknownFieldSet.
  public native int field_count();
  // Get a field in the set, where 0 <= index < field_count().  The fields
  // appear in the order in which they were added.
  public native @Const @ByRef UnknownField field(int index);
  // Get a mutable pointer to a field in the set, where
  // 0 <= index < field_count().  The fields appear in the order in which
  // they were added.
  public native UnknownField mutable_field(int index);

  // Adding fields ---------------------------------------------------

  public native void AddVarint(int number, @Cast("google::protobuf::uint64") long value);
  public native void AddFixed32(int number, @Cast("google::protobuf::uint32") int value);
  public native void AddFixed64(int number, @Cast("google::protobuf::uint64") long value);
  public native void AddLengthDelimited(int number, @StdString BytePointer value);
  public native void AddLengthDelimited(int number, @StdString String value);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer AddLengthDelimited(int number);
  public native UnknownFieldSet AddGroup(int number);

  // Adds an unknown field from another set.
  public native void AddField(@Const @ByRef UnknownField field);

  // Delete fields with indices in the range [start .. start+num-1].
  // Caution: implementation moves all fields with indices [start+num .. ].
  public native void DeleteSubrange(int start, int num);

  // Delete all fields with a specific field number. The order of left fields
  // is preserved.
  // Caution: implementation moves all fields after the first deleted field.
  public native void DeleteByNumber(int number);

  // Parsing helpers -------------------------------------------------
  // These work exactly like the similarly-named methods of Message.

  public native @Cast("bool") boolean MergeFromCodedStream(CodedInputStream input);
  public native @Cast("bool") boolean ParseFromCodedStream(CodedInputStream input);
  public native @Cast("bool") boolean ParseFromZeroCopyStream(ZeroCopyInputStream input);
  public native @Cast("bool") boolean ParseFromArray(@Const Pointer data, int size);
  public native @Cast("bool") boolean ParseFromString(@StdString BytePointer data);
  public native @Cast("bool") boolean ParseFromString(@StdString String data);

  public static native @Const UnknownFieldSet default_instance();
}

// Represents one field in an UnknownFieldSet.
@Namespace("google::protobuf") public static class UnknownField extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public UnknownField() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public UnknownField(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public UnknownField(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public UnknownField position(long position) {
        return (UnknownField)super.position(position);
    }

  /** enum google::protobuf::UnknownField::Type */
  public static final int
    TYPE_VARINT = 0,
    TYPE_FIXED32 = 1,
    TYPE_FIXED64 = 2,
    TYPE_LENGTH_DELIMITED = 3,
    TYPE_GROUP = 4;

  // The field's field number, as seen on the wire.
  public native int number();

  // The field type.
  public native @Cast("google::protobuf::UnknownField::Type") int type();

  // Accessors -------------------------------------------------------
  // Each method works only for UnknownFields of the corresponding type.

  public native @Cast("google::protobuf::uint64") long varint();
  public native @Cast("google::protobuf::uint32") int fixed32();
  public native @Cast("google::protobuf::uint64") long fixed64();
  public native @StdString BytePointer length_delimited();
  public native @Const @ByRef UnknownFieldSet group();

  public native void set_varint(@Cast("google::protobuf::uint64") long value);
  public native void set_fixed32(@Cast("google::protobuf::uint32") int value);
  public native void set_fixed64(@Cast("google::protobuf::uint64") long value);
  public native void set_length_delimited(@StdString BytePointer value);
  public native void set_length_delimited(@StdString String value);
  public native @StdString @Cast({"char*", "std::string*"}) BytePointer mutable_length_delimited();
  public native UnknownFieldSet mutable_group();

  // Serialization API.
  // These methods can take advantage of the underlying implementation and may
  // archieve a better performance than using getters to retrieve the data and
  // do the serialization yourself.
  public native void SerializeLengthDelimitedNoTag(CodedOutputStream output);
  public native @Cast("google::protobuf::uint8*") BytePointer SerializeLengthDelimitedNoTagToArray(@Cast("google::protobuf::uint8*") BytePointer target);
  public native @Cast("google::protobuf::uint8*") ByteBuffer SerializeLengthDelimitedNoTagToArray(@Cast("google::protobuf::uint8*") ByteBuffer target);
  public native @Cast("google::protobuf::uint8*") byte[] SerializeLengthDelimitedNoTagToArray(@Cast("google::protobuf::uint8*") byte[] target);

  public native @Cast("size_t") long GetLengthDelimitedSize();


  // If this UnknownField contains a pointer, delete it.
  public native void Delete();

  // Reset all the underlying pointers to NULL. A special function to be only
  // used while merging from a temporary UFS.
  public native void Reset();

  // Make a deep copy of any pointers in this UnknownField.
  public native void DeepCopy(@Const @ByRef UnknownField other);

  // Set the wire type of this UnknownField. Should only be used when this
  // UnknownField is being created.
  public native void SetType(@Cast("google::protobuf::UnknownField::Type") int type);

  public native @Cast("google::protobuf::uint32") int number_(); public native UnknownField number_(int number_);
  public native @Cast("google::protobuf::uint32") int type_(); public native UnknownField type_(int type_);
    @Name("data_.varint_") public native @Cast("google::protobuf::uint64") long data__varint_(); public native UnknownField data__varint_(long data__varint_);
    @Name("data_.fixed32_") public native @Cast("google::protobuf::uint32") int data__fixed32_(); public native UnknownField data__fixed32_(int data__fixed32_);
    @Name("data_.fixed64_") public native @Cast("google::protobuf::uint64") long data__fixed64_(); public native UnknownField data__fixed64_(long data__fixed64_);
    @Name("data_.group_") public native UnknownFieldSet data__group_(); public native UnknownField data__group_(UnknownFieldSet data__group_);
}

// ===================================================================
// inline implementations











































  // namespace protobuf

  // namespace google
// #endif  // GOOGLE_PROTOBUF_UNKNOWN_FIELD_SET_H__


// Parsed from onnx/proto_utils.h

// #pragma once

// #include <google/protobuf/io/coded_stream.h>
// #include <google/protobuf/io/zero_copy_stream_impl_lite.h>

// #ifdef ONNX_USE_LITE_PROTO
// #include <google/protobuf/message_lite.h>
// #else // ONNX_USE_LITE_PROTO
// #include <google/protobuf/message.h>
// #endif  // !ONNX_USE_LITE_PROTO

// #ifdef ONNX_USE_LITE_PROTO
@Namespace("onnx") public static native @StdString BytePointer ProtoDebugString(@Const @ByRef MessageLite proto);
// #else
// #endif

@Namespace("onnx") public static native @Cast("bool") boolean ParseProtoFromBytes(MessageLite proto, @Cast("const char*") BytePointer buffer, @Cast("size_t") long length);
@Namespace("onnx") public static native @Cast("bool") boolean ParseProtoFromBytes(MessageLite proto, String buffer, @Cast("size_t") long length);

@Namespace("onnx") public static native @ByVal @Name("RetrieveValues<int64_t>") LongVector RetrieveValuesLong(@Const @ByRef AttributeProto attr);

@Namespace("onnx") public static native @ByVal @Name("RetrieveValues<std::string>") StringVector RetrieveValuesString(@Const @ByRef AttributeProto attr);

 // namespace ONNX_NAMESPACE


// Parsed from onnx/checker.h

// #pragma once

// #include <stdexcept>
// #include <unordered_map>
// #include <unordered_set>
// #include "onnx/defs/schema.h"
// #include "onnx/onnx-operators_pb.h"
// #include "onnx/onnx_pb.h"
// #include "onnx/string_utils.h"
@Namespace("onnx::checker") @NoOffset public static class ValidationError extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ValidationError(Pointer p) { super(p); }

  public native @Cast("const char*") BytePointer what();
  public native void AppendContext(@StdString BytePointer context);
  public native void AppendContext(@StdString String context);
}

// #define fail_check(...)
//   throw ONNX_NAMESPACE::checker::ValidationError(
//       ONNX_NAMESPACE::MakeString(__VA_ARGS__));

@Namespace("onnx::checker") @NoOffset public static class CheckerContext extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CheckerContext(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public CheckerContext(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public CheckerContext position(long position) {
        return (CheckerContext)super.position(position);
    }

  public native int get_ir_version();
  public native void set_ir_version(int v);
  public native @Const @ByRef StringIntMap get_opset_imports();
  public native void set_opset_imports(@ByVal StringIntMap imps);
  public native @Cast("bool") boolean is_main_graph();
  public native void set_is_main_graph(@Cast("bool") boolean is_main_graph);

  public native void set_schema_registry(@Const ISchemaRegistry schema_registry);

  public native @Const ISchemaRegistry get_schema_registry();

  public CheckerContext() { super((Pointer)null); allocate(); }
  private native void allocate();
}

@Namespace("onnx::checker") public static class LexicalScopeContext extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public LexicalScopeContext() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public LexicalScopeContext(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public LexicalScopeContext(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public LexicalScopeContext position(long position) {
        return (LexicalScopeContext)super.position(position);
    }

  public native @ByRef StringSet output_names(); public native LexicalScopeContext output_names(StringSet output_names);
}
@Namespace("onnx::checker") public static native void check_value_info(@Const @ByRef ValueInfoProto value_info, @Const @ByRef CheckerContext arg1);
@Namespace("onnx::checker") public static native void check_tensor(@Const @ByRef TensorProto tensor, @Const @ByRef CheckerContext arg1);
@Namespace("onnx::checker") public static native void check_attribute(
    @Const @ByRef AttributeProto attr,
    @Const @ByRef CheckerContext arg1,
    @Const @ByRef LexicalScopeContext arg2);
@Namespace("onnx::checker") public static native void check_node(
    @Const @ByRef NodeProto node,
    @Const @ByRef CheckerContext arg1,
    @Const @ByRef LexicalScopeContext arg2);
@Namespace("onnx::checker") public static native void check_graph(
    @Const @ByRef GraphProto graph,
    @Const @ByRef CheckerContext arg1,
    @Const @ByRef LexicalScopeContext arg2);
@Namespace("onnx::checker") public static native void check_function(
    @Const @ByRef FunctionProto function,
    @Const @ByRef CheckerContext arg1,
    @Const @ByRef LexicalScopeContext arg2);

@Namespace("onnx::checker") public static native void check_model(@Const @ByRef ModelProto model);
 // namespace checker
 // namespace ONNX_NAMESPACE


}
