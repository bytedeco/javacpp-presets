// Targeted by JavaCPP version 1.5.10-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.onnx.global;

import org.bytedeco.onnx.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

public class onnx extends org.bytedeco.onnx.presets.onnx {
    static { Loader.load(); }

// Targeting ../StringAttributeMap.java


// Targeting ../IntSet.java


// Targeting ../StringSet.java


// Targeting ../TypeConstraintParamVector.java


// Targeting ../FloatVector.java


// Targeting ../LongVector.java


// Targeting ../StringVector.java


// Targeting ../OpSchemaVector.java


// Targeting ../FormalParameterVector.java


// Targeting ../TypeProtoVector.java


// Targeting ../TensorShapeProtoVector.java


// Targeting ../LongLongPair.java


// Targeting ../UseTypeIntPair.java


// Targeting ../SizeTStringMap.java


// Targeting ../StringIntMap.java


// Targeting ../StringTypeProtoMap.java


// Targeting ../StringTensorShapeProtoMap.java


// Targeting ../StringTensorProtoMap.java


// Targeting ../StringAttributeProtoMap.java


// Targeting ../StringIntIntPairMap.java


// Targeting ../IntIntMap.java


// Targeting ../UnorderedStringSet.java


// Targeting ../DataTypeSet.java


// Parsed from onnx/defs/schema.h

/*
 * SPDX-License-Identifier: Apache-2.0
 */

// #pragma once

// #include <climits>
// #include <cstring>
// #include <functional>
// #include <initializer_list>
// #include <iostream>
// #include <limits>
// #include <map>
// #include <memory>
// #include <ostream>
// #include <set>
// #include <string>
// #include <tuple>
// #include <unordered_map>
// #include <unordered_set>
// #include <utility>
// #include <vector>

// #include "onnx/common/common.h"
// #include "onnx/common/constants.h"
// #include "onnx/defs/shape_inference.h"
// Targeting ../FunctionBodyBuildContext.java


// Targeting ../FunctionBodyBuildContextImpl.java


// Targeting ../SchemaError.java



// #define fail_schema(...) ONNX_THROW_EX(ONNX_NAMESPACE::SchemaError(ONNX_NAMESPACE::MakeString(__VA_ARGS__)));

// Type constraint map. Key is type string. Value is data type set and
// description.
// Targeting ../OpSchema.java



// Map type to store operator schemas. The format is,
// <OpName, <Domain, <OperatorSetVersion, OpSchema>>>.
// Targeting ../ISchemaRegistry.java


// Targeting ../OpSchemaRegistry.java





// Registers the latest opset schema before opset_version_to_load
// By default opset_version_to_load=0 means it will register all versions

// Forward declaration for the non-specialized GetOpSchema method.  This
// enforces a consistent signature on functions that query individual schema,
// which are defined as specializations of this function.

// #define ONNX_OPERATOR_SET_SCHEMA(name, ver, impl) ONNX_OPERATOR_SET_SCHEMA_EX(name, Onnx, ONNX_DOMAIN, ver, true, impl)

// #define ONNX_ML_OPERATOR_SET_SCHEMA(name, ver, impl)
//   ONNX_OPERATOR_SET_SCHEMA_EX(name, OnnxML, AI_ONNX_ML_DOMAIN, ver, true, impl)

// #define ONNX_TRAINING_OPERATOR_SET_SCHEMA(name, ver, impl)
//   ONNX_OPERATOR_SET_SCHEMA_EX(name, OnnxTraining, AI_ONNX_TRAINING_DOMAIN, ver, true, impl)

// #define ONNX_PREVIEW_TRAINING_OPERATOR_SET_SCHEMA(name, ver, impl)
//   ONNX_OPERATOR_SET_SCHEMA_EX(name, OnnxPreview, AI_ONNX_PREVIEW_TRAINING_DOMAIN, ver, true, impl)

// Defines specialization of GetOpSchema for a class whose name is determined
// based on a convention using name, domain, and version.  Operator schema are
// normally included in operator sets and registered in OpSchemaRegistry::map().
// In this case, callers should set dbg_included_in_static_opset to true.  This
// assists with runtime validation in DEBUG builds ensuring the intended set
// of operator schema is registered.
// #define ONNX_OPERATOR_SET_SCHEMA_EX(name, domain, domain_str, ver, dbg_included_in_static_opset, impl)
//   class ONNX_OPERATOR_SET_SCHEMA_CLASS_NAME(domain, ver, name);
//   template <>
//   OpSchema GetOpSchema<ONNX_OPERATOR_SET_SCHEMA_CLASS_NAME(domain, ver, name)>() {
//     return impl.SetName(#name).SetDomain(domain_str).SinceVersion(ver).SetLocation(__FILE__, __LINE__);
//   }
//   size_t dbg_count_check_##name##_##domain##_ver##ver =
//       (dbg_included_in_static_opset) ? ONNX_DBG_INCREMENT_COUNT_IN_OPSETS() : 0;
// #ifdef NDEBUG
// #define ONNX_DBG_INCREMENT_COUNT_IN_OPSETS() 0
// #else
// #define ONNX_DBG_INCREMENT_COUNT_IN_OPSETS() DbgOperatorSetTracker::Instance().IncrementCount()
// #define ONNX_DBG_GET_COUNT_IN_OPSETS() DbgOperatorSetTracker::Instance().GetCount()
// Targeting ../DbgOperatorSetTracker.java


// #endif

// Naming convention for operator schema classes
// #define ONNX_OPERATOR_SET_SCHEMA_CLASS_NAME(domain, ver, name) name##_##domain##_ver##ver

// Naming convention for preview operator schema classes
// #define ONNX_PREVIEW_OPERATOR_SET_SCHEMA_CLASS_NAME(ver, name)
//   ONNX_OPERATOR_SET_SCHEMA_CLASS_NAME(OnnxPreview, ver, name)

// Helper function


// #ifdef __GNUC__
// #define ONNX_UNUSED __attribute__((__unused__))
// #else
// #define ONNX_UNUSED
// #endif

// Legacy macros to register schema at static initialization
// #define ONNX_OPERATOR_SCHEMA(name) ONNX_OPERATOR_SCHEMA_UNIQ_HELPER(__COUNTER__, name)
// #define ONNX_OPERATOR_SCHEMA_UNIQ_HELPER(Counter, name) ONNX_OPERATOR_SCHEMA_UNIQ(Counter, name)
// #define ONNX_OPERATOR_SCHEMA_UNIQ(Counter, name)
//   static ONNX_NAMESPACE::OpSchemaRegistry::OpSchemaRegisterOnce(op_schema_register_once##name##Counter) ONNX_UNUSED =
//       OpSchema(#name, __FILE__, __LINE__)

// Helper function


@Namespace("onnx") public static native @StdString BytePointer GenerateOptionalArgumentsDoc();

@Namespace("onnx") public static native @StdString BytePointer GenerateBroadcastingDocMul();

@Namespace("onnx") public static native @StdString BytePointer GenerateBroadcastingDocUni(@Cast("const char*") BytePointer from, @Cast("const char*") BytePointer to);
@Namespace("onnx") public static native @StdString String GenerateBroadcastingDocUni(String from, String to);

/*
 * Macros for setting operator documentation
 * Use this macro for simple SetDoc() calls that generate documentation
 * directly. This is the macro to use in almost all cases.
 * Sample usage guidelines:
 * const char* doc_str = "foo";
 * SetDoc(GET_OP_DOC_STR(doc_str))
 *
 * SetDoc(GET_OP_DOC_STR(
            std::string(BitShift_ver11_doc) + GenerateBroadcastingDocMul()))
 */
// #ifndef __ONNX_NO_DOC_STRINGS
// #define GET_OP_DOC_STR(doc_str) (doc_str)
// #else
// #define GET_OP_DOC_STR(doc_str) ("")
// #endif

/*
 * Use this macro when the documentation needs to be populated in some
 * complicated way like string substitutions, etc before calling SetDoc.
 * Sample usage guidelines:
    std::string doc;
    POPULATE_OP_DOC_STR(
        doc = R"DOC(
Returns the tensor resulted from performing the `{name}` logical operation
elementwise on the input tensors `A` and `B` (with Numpy-style broadcasting
support).

{broadcast_doc}
)DOC";
        ReplaceAll(doc, "{name}", name);
        ReplaceAll(
            doc, "{broadcast_doc}", GenerateBroadcastingDocMul().c_str()););
    schema.SetDoc(doc);
 *
 */
// #ifndef __ONNX_NO_DOC_STRINGS
// #define POPULATE_OP_DOC_STR(DocPopulatorCode)
//   do {
//     DocPopulatorCode
//   } while (0)
// #else
// #define POPULATE_OP_DOC_STR(DocPopulatorCode)
// #endif

 // namespace ONNX_NAMESPACE


// Parsed from onnx/defs/operator_sets.h

/*
 * SPDX-License-Identifier: Apache-2.0
 */

// #pragma once

// #include "onnx/defs/schema.h"
// Targeting ../Abs_Onnx_ver1.java


// Targeting ../Add_Onnx_ver1.java


// Targeting ../And_Onnx_ver1.java


// Targeting ../ArgMax_Onnx_ver1.java


// Targeting ../ArgMin_Onnx_ver1.java


// Targeting ../AveragePool_Onnx_ver1.java


// Targeting ../BatchNormalization_Onnx_ver1.java


// Targeting ../Cast_Onnx_ver1.java


// Targeting ../Ceil_Onnx_ver1.java


// Targeting ../Clip_Onnx_ver1.java


// Targeting ../Concat_Onnx_ver1.java


// Targeting ../Constant_Onnx_ver1.java


// Targeting ../Conv_Onnx_ver1.java


// Targeting ../ConvTranspose_Onnx_ver1.java


// Targeting ../DepthToSpace_Onnx_ver1.java


// Targeting ../Div_Onnx_ver1.java


// Targeting ../Dropout_Onnx_ver1.java


// Targeting ../Elu_Onnx_ver1.java


// Targeting ../Equal_Onnx_ver1.java


// Targeting ../Exp_Onnx_ver1.java


// Targeting ../Flatten_Onnx_ver1.java


// Targeting ../Floor_Onnx_ver1.java


// Targeting ../GRU_Onnx_ver1.java


// Targeting ../Gather_Onnx_ver1.java


// Targeting ../Gemm_Onnx_ver1.java


// Targeting ../GlobalAveragePool_Onnx_ver1.java


// Targeting ../GlobalLpPool_Onnx_ver1.java


// Targeting ../GlobalMaxPool_Onnx_ver1.java


// Targeting ../Greater_Onnx_ver1.java


// Targeting ../HardSigmoid_Onnx_ver1.java


// Targeting ../Hardmax_Onnx_ver1.java


// Targeting ../Identity_Onnx_ver1.java


// Targeting ../If_Onnx_ver1.java


// Targeting ../InstanceNormalization_Onnx_ver1.java


// Targeting ../LRN_Onnx_ver1.java


// Targeting ../LSTM_Onnx_ver1.java


// Targeting ../LeakyRelu_Onnx_ver1.java


// Targeting ../Less_Onnx_ver1.java


// Targeting ../Log_Onnx_ver1.java


// Targeting ../LogSoftmax_Onnx_ver1.java


// Targeting ../Loop_Onnx_ver1.java


// Targeting ../LpNormalization_Onnx_ver1.java


// Targeting ../LpPool_Onnx_ver1.java


// Targeting ../MatMul_Onnx_ver1.java


// Targeting ../Max_Onnx_ver1.java


// Targeting ../MaxPool_Onnx_ver1.java


// Targeting ../MaxRoiPool_Onnx_ver1.java


// Targeting ../Mean_Onnx_ver1.java


// Targeting ../Min_Onnx_ver1.java


// Targeting ../Mul_Onnx_ver1.java


// Targeting ../Neg_Onnx_ver1.java


// Targeting ../Not_Onnx_ver1.java


// Targeting ../Or_Onnx_ver1.java


// Targeting ../PRelu_Onnx_ver1.java


// Targeting ../Pad_Onnx_ver1.java


// Targeting ../Pow_Onnx_ver1.java


// Targeting ../RNN_Onnx_ver1.java


// Targeting ../RandomNormal_Onnx_ver1.java


// Targeting ../RandomNormalLike_Onnx_ver1.java


// Targeting ../RandomUniform_Onnx_ver1.java


// Targeting ../RandomUniformLike_Onnx_ver1.java


// Targeting ../Reciprocal_Onnx_ver1.java


// Targeting ../ReduceL1_Onnx_ver1.java


// Targeting ../ReduceL2_Onnx_ver1.java


// Targeting ../ReduceLogSum_Onnx_ver1.java


// Targeting ../ReduceLogSumExp_Onnx_ver1.java


// Targeting ../ReduceMax_Onnx_ver1.java


// Targeting ../ReduceMean_Onnx_ver1.java


// Targeting ../ReduceMin_Onnx_ver1.java


// Targeting ../ReduceProd_Onnx_ver1.java


// Targeting ../ReduceSum_Onnx_ver1.java


// Targeting ../ReduceSumSquare_Onnx_ver1.java


// Targeting ../Relu_Onnx_ver1.java


// Targeting ../Reshape_Onnx_ver1.java


// Targeting ../Selu_Onnx_ver1.java


// Targeting ../Shape_Onnx_ver1.java


// Targeting ../Sigmoid_Onnx_ver1.java


// Targeting ../Size_Onnx_ver1.java


// Targeting ../Slice_Onnx_ver1.java


// Targeting ../Softmax_Onnx_ver1.java


// Targeting ../Softplus_Onnx_ver1.java


// Targeting ../Softsign_Onnx_ver1.java


// Targeting ../SpaceToDepth_Onnx_ver1.java


// Targeting ../Split_Onnx_ver1.java


// Targeting ../Sqrt_Onnx_ver1.java


// Targeting ../Squeeze_Onnx_ver1.java


// Targeting ../Sub_Onnx_ver1.java


// Targeting ../Sum_Onnx_ver1.java


// Targeting ../Tanh_Onnx_ver1.java


// Targeting ../Tile_Onnx_ver1.java


// Targeting ../TopK_Onnx_ver1.java


// Targeting ../Transpose_Onnx_ver1.java


// Targeting ../Unsqueeze_Onnx_ver1.java


// Targeting ../Upsample_Onnx_ver1.java


// Targeting ../Xor_Onnx_ver1.java


// Targeting ../OpSet_Onnx_ver1.java


// Targeting ../GlobalLpPool_Onnx_ver2.java


// Targeting ../LpPool_Onnx_ver2.java


// Targeting ../Pad_Onnx_ver2.java


// Targeting ../Split_Onnx_ver2.java


// Targeting ../OpSet_Onnx_ver2.java


// Targeting ../GRU_Onnx_ver3.java


// Targeting ../OpSet_Onnx_ver3.java


// Targeting ../Concat_Onnx_ver4.java


// Targeting ../OpSet_Onnx_ver4.java


// Targeting ../Reshape_Onnx_ver5.java


// Targeting ../OpSet_Onnx_ver5.java


// Targeting ../Abs_Onnx_ver6.java


// Targeting ../Add_Onnx_ver6.java


// Targeting ../BatchNormalization_Onnx_ver6.java


// Targeting ../Cast_Onnx_ver6.java


// Targeting ../Ceil_Onnx_ver6.java


// Targeting ../Clip_Onnx_ver6.java


// Targeting ../Div_Onnx_ver6.java


// Targeting ../Dropout_Onnx_ver6.java


// Targeting ../Elu_Onnx_ver6.java


// Targeting ../Exp_Onnx_ver6.java


// Targeting ../Floor_Onnx_ver6.java


// Targeting ../Gemm_Onnx_ver6.java


// Targeting ../HardSigmoid_Onnx_ver6.java


// Targeting ../InstanceNormalization_Onnx_ver6.java


// Targeting ../LeakyRelu_Onnx_ver6.java


// Targeting ../Log_Onnx_ver6.java


// Targeting ../Max_Onnx_ver6.java


// Targeting ../Mean_Onnx_ver6.java


// Targeting ../Min_Onnx_ver6.java


// Targeting ../Mul_Onnx_ver6.java


// Targeting ../Neg_Onnx_ver6.java


// Targeting ../PRelu_Onnx_ver6.java


// Targeting ../Reciprocal_Onnx_ver6.java


// Targeting ../Relu_Onnx_ver6.java


// Targeting ../Selu_Onnx_ver6.java


// Targeting ../Sigmoid_Onnx_ver6.java


// Targeting ../Sqrt_Onnx_ver6.java


// Targeting ../Sub_Onnx_ver6.java


// Targeting ../Sum_Onnx_ver6.java


// Targeting ../Tanh_Onnx_ver6.java


// Targeting ../Tile_Onnx_ver6.java


// Targeting ../OpSet_Onnx_ver6.java


// Targeting ../Acos_Onnx_ver7.java


// Targeting ../Add_Onnx_ver7.java


// Targeting ../And_Onnx_ver7.java


// Targeting ../Asin_Onnx_ver7.java


// Targeting ../Atan_Onnx_ver7.java


// Targeting ../AveragePool_Onnx_ver7.java


// Targeting ../BatchNormalization_Onnx_ver7.java


// Targeting ../Cos_Onnx_ver7.java


// Targeting ../Div_Onnx_ver7.java


// Targeting ../Dropout_Onnx_ver7.java


// Targeting ../Equal_Onnx_ver7.java


// Targeting ../Gemm_Onnx_ver7.java


// Targeting ../Greater_Onnx_ver7.java


// Targeting ../GRU_Onnx_ver7.java


// Targeting ../Less_Onnx_ver7.java


// Targeting ../LSTM_Onnx_ver7.java


// Targeting ../Mul_Onnx_ver7.java


// Targeting ../Or_Onnx_ver7.java


// Targeting ../Pow_Onnx_ver7.java


// Targeting ../RNN_Onnx_ver7.java


// Targeting ../Sin_Onnx_ver7.java


// Targeting ../Sub_Onnx_ver7.java


// Targeting ../Tan_Onnx_ver7.java


// Targeting ../Upsample_Onnx_ver7.java


// Targeting ../Multinomial_Onnx_ver7.java


// Targeting ../Xor_Onnx_ver7.java


// Targeting ../PRelu_Onnx_ver7.java


// Targeting ../OpSet_Onnx_ver7.java


// Targeting ../Expand_Onnx_ver8.java


// Targeting ../Max_Onnx_ver8.java


// Targeting ../Min_Onnx_ver8.java


// Targeting ../Sum_Onnx_ver8.java


// Targeting ../Mean_Onnx_ver8.java


// Targeting ../MaxPool_Onnx_ver8.java


// Targeting ../Scan_Onnx_ver8.java


// Targeting ../OpSet_Onnx_ver8.java


// Targeting ../BatchNormalization_Onnx_ver9.java


// Targeting ../Compress_Onnx_ver9.java


// Targeting ../ConstantOfShape_Onnx_ver9.java


// Targeting ../EyeLike_Onnx_ver9.java


// Targeting ../Greater_Onnx_ver9.java


// Targeting ../Less_Onnx_ver9.java


// Targeting ../Upsample_Onnx_ver9.java


// Targeting ../MaxUnpool_Onnx_ver9.java


// Targeting ../Constant_Onnx_ver9.java


// Targeting ../MatMul_Onnx_ver9.java


// Targeting ../OneHot_Onnx_ver9.java


// Targeting ../PRelu_Onnx_ver9.java


// Targeting ../Gemm_Onnx_ver9.java


// Targeting ../Flatten_Onnx_ver9.java


// Targeting ../Sinh_Onnx_ver9.java


// Targeting ../Cosh_Onnx_ver9.java


// Targeting ../Asinh_Onnx_ver9.java


// Targeting ../Acosh_Onnx_ver9.java


// Targeting ../Atanh_Onnx_ver9.java


// Targeting ../Shrink_Onnx_ver9.java


// Targeting ../IsNaN_Onnx_ver9.java


// Targeting ../Sign_Onnx_ver9.java


// Targeting ../Scan_Onnx_ver9.java


// Targeting ../Erf_Onnx_ver9.java


// Targeting ../Scatter_Onnx_ver9.java


// Targeting ../Where_Onnx_ver9.java


// Targeting ../Cast_Onnx_ver9.java


// Targeting ../NonZero_Onnx_ver9.java


// Targeting ../TfIdfVectorizer_Onnx_ver9.java


// Targeting ../MeanVarianceNormalization_Onnx_ver9.java


// Targeting ../OpSet_Onnx_ver9.java


// Targeting ../StringNormalizer_Onnx_ver10.java


// Targeting ../Upsample_Onnx_ver10.java


// Targeting ../Resize_Onnx_ver10.java


// Targeting ../TopK_Onnx_ver10.java


// Targeting ../MaxPool_Onnx_ver10.java


// Targeting ../Mod_Onnx_ver10.java


// Targeting ../AveragePool_Onnx_ver10.java


// Targeting ../Slice_Onnx_ver10.java


// Targeting ../ThresholdedRelu_Onnx_ver10.java


// Targeting ../Dropout_Onnx_ver10.java


// Targeting ../MatMulInteger_Onnx_ver10.java


// Targeting ../QLinearMatMul_Onnx_ver10.java


// Targeting ../ConvInteger_Onnx_ver10.java


// Targeting ../QLinearConv_Onnx_ver10.java


// Targeting ../QuantizeLinear_Onnx_ver10.java


// Targeting ../DequantizeLinear_Onnx_ver10.java


// Targeting ../IsInf_Onnx_ver10.java


// Targeting ../NonMaxSuppression_Onnx_ver10.java


// Targeting ../ReverseSequence_Onnx_ver10.java


// Targeting ../RoiAlign_Onnx_ver10.java


// Targeting ../OpSet_Onnx_ver10.java


// Targeting ../Loop_Onnx_ver11.java


// Targeting ../CumSum_Onnx_ver11.java


// Targeting ../Round_Onnx_ver11.java


// Targeting ../BitShift_Onnx_ver11.java


// Targeting ../Unique_Onnx_ver11.java


// Targeting ../TopK_Onnx_ver11.java


// Targeting ../DepthToSpace_Onnx_ver11.java


// Targeting ../Equal_Onnx_ver11.java


// Targeting ../Constant_Onnx_ver11.java


// Targeting ../DynamicQuantizeLinear_Onnx_ver11.java


// Targeting ../GatherElements_Onnx_ver11.java


// Targeting ../ScatterElements_Onnx_ver11.java


// Targeting ../Scatter_Onnx_ver11.java


// Targeting ../Clip_Onnx_ver11.java


// Targeting ../Resize_Onnx_ver11.java


// Targeting ../Range_Onnx_ver11.java


// Targeting ../Det_Onnx_ver11.java


// Targeting ../ScatterND_Onnx_ver11.java


// Targeting ../GatherND_Onnx_ver11.java


// Targeting ../Gather_Onnx_ver11.java


// Targeting ../OneHot_Onnx_ver11.java


// Targeting ../Slice_Onnx_ver11.java


// Targeting ../Squeeze_Onnx_ver11.java


// Targeting ../Unsqueeze_Onnx_ver11.java


// Targeting ../Flatten_Onnx_ver11.java


// Targeting ../ArgMax_Onnx_ver11.java


// Targeting ../ArgMin_Onnx_ver11.java


// Targeting ../ReduceL1_Onnx_ver11.java


// Targeting ../ReduceL2_Onnx_ver11.java


// Targeting ../ReduceLogSum_Onnx_ver11.java


// Targeting ../ReduceLogSumExp_Onnx_ver11.java


// Targeting ../ReduceMax_Onnx_ver11.java


// Targeting ../ReduceMean_Onnx_ver11.java


// Targeting ../ReduceMin_Onnx_ver11.java


// Targeting ../ReduceProd_Onnx_ver11.java


// Targeting ../ReduceSum_Onnx_ver11.java


// Targeting ../ReduceSumSquare_Onnx_ver11.java


// Targeting ../Compress_Onnx_ver11.java


// Targeting ../Concat_Onnx_ver11.java


// Targeting ../Hardmax_Onnx_ver11.java


// Targeting ../LogSoftmax_Onnx_ver11.java


// Targeting ../Softmax_Onnx_ver11.java


// Targeting ../Scan_Onnx_ver11.java


// Targeting ../Split_Onnx_ver11.java


// Targeting ../AveragePool_Onnx_ver11.java


// Targeting ../MaxPool_Onnx_ver11.java


// Targeting ../MaxUnpool_Onnx_ver11.java


// Targeting ../LpPool_Onnx_ver11.java


// Targeting ../Conv_Onnx_ver11.java


// Targeting ../ConvTranspose_Onnx_ver11.java


// Targeting ../SequenceEmpty_Onnx_ver11.java


// Targeting ../SequenceConstruct_Onnx_ver11.java


// Targeting ../SequenceInsert_Onnx_ver11.java


// Targeting ../SequenceAt_Onnx_ver11.java


// Targeting ../SequenceErase_Onnx_ver11.java


// Targeting ../SequenceLength_Onnx_ver11.java


// Targeting ../SplitToSequence_Onnx_ver11.java


// Targeting ../ConcatFromSequence_Onnx_ver11.java


// Targeting ../Pad_Onnx_ver11.java


// Targeting ../Gemm_Onnx_ver11.java


// Targeting ../If_Onnx_ver11.java


// Targeting ../NonMaxSuppression_Onnx_ver11.java


// Targeting ../OpSet_Onnx_ver11.java


// Targeting ../ArgMax_Onnx_ver12.java


// Targeting ../ArgMin_Onnx_ver12.java


// Targeting ../Clip_Onnx_ver12.java


// Targeting ../Einsum_Onnx_ver12.java


// Targeting ../MaxPool_Onnx_ver12.java


// Targeting ../ReduceMax_Onnx_ver12.java


// Targeting ../ReduceMin_Onnx_ver12.java


// Targeting ../GatherND_Onnx_ver12.java


// Targeting ../NegativeLogLikelihoodLoss_Onnx_ver12.java


// Targeting ../Dropout_Onnx_ver12.java


// Targeting ../Constant_Onnx_ver12.java


// Targeting ../Celu_Onnx_ver12.java


// Targeting ../Max_Onnx_ver12.java


// Targeting ../Min_Onnx_ver12.java


// Targeting ../LessOrEqual_Onnx_ver12.java


// Targeting ../GreaterOrEqual_Onnx_ver12.java


// Targeting ../SoftmaxCrossEntropyLoss_Onnx_ver12.java


// Targeting ../Pow_Onnx_ver12.java


// Targeting ../OpSet_Onnx_ver12.java


// Targeting ../Constant_Onnx_ver13.java


// Targeting ../Greater_Onnx_ver13.java


// Targeting ../Less_Onnx_ver13.java


// Targeting ../Equal_Onnx_ver13.java


// Targeting ../Add_Onnx_ver13.java


// Targeting ../Sub_Onnx_ver13.java


// Targeting ../Mul_Onnx_ver13.java


// Targeting ../Div_Onnx_ver13.java


// Targeting ../Softmax_Onnx_ver13.java


// Targeting ../LogSoftmax_Onnx_ver13.java


// Targeting ../Hardmax_Onnx_ver13.java


// Targeting ../Mod_Onnx_ver13.java


// Targeting ../Neg_Onnx_ver13.java


// Targeting ../Abs_Onnx_ver13.java


// Targeting ../Reciprocal_Onnx_ver13.java


// Targeting ../Floor_Onnx_ver13.java


// Targeting ../Ceil_Onnx_ver13.java


// Targeting ../Sqrt_Onnx_ver13.java


// Targeting ../Relu_Onnx_ver13.java


// Targeting ../Exp_Onnx_ver13.java


// Targeting ../Log_Onnx_ver13.java


// Targeting ../Tanh_Onnx_ver13.java


// Targeting ../Pow_Onnx_ver13.java


// Targeting ../Sigmoid_Onnx_ver13.java


// Targeting ../Max_Onnx_ver13.java


// Targeting ../Min_Onnx_ver13.java


// Targeting ../Sum_Onnx_ver13.java


// Targeting ../Mean_Onnx_ver13.java


// Targeting ../Clip_Onnx_ver13.java


// Targeting ../Gemm_Onnx_ver13.java


// Targeting ../MatMul_Onnx_ver13.java


// Targeting ../Expand_Onnx_ver13.java


// Targeting ../Sign_Onnx_ver13.java


// Targeting ../Erf_Onnx_ver13.java


// Targeting ../SoftmaxCrossEntropyLoss_Onnx_ver13.java


// Targeting ../NegativeLogLikelihoodLoss_Onnx_ver13.java


// Targeting ../Dropout_Onnx_ver13.java


// Targeting ../Flatten_Onnx_ver13.java


// Targeting ../LRN_Onnx_ver13.java


// Targeting ../MeanVarianceNormalization_Onnx_ver13.java


// Targeting ../ReduceMax_Onnx_ver13.java


// Targeting ../ReduceMin_Onnx_ver13.java


// Targeting ../ReduceSum_Onnx_ver13.java


// Targeting ../ReduceSumSquare_Onnx_ver13.java


// Targeting ../ReduceMean_Onnx_ver13.java


// Targeting ../ReduceProd_Onnx_ver13.java


// Targeting ../ReduceLogSum_Onnx_ver13.java


// Targeting ../ReduceLogSumExp_Onnx_ver13.java


// Targeting ../ReduceL1_Onnx_ver13.java


// Targeting ../ReduceL2_Onnx_ver13.java


// Targeting ../ArgMax_Onnx_ver13.java


// Targeting ../ArgMin_Onnx_ver13.java


// Targeting ../Cast_Onnx_ver13.java


// Targeting ../Reshape_Onnx_ver13.java


// Targeting ../Shape_Onnx_ver13.java


// Targeting ../Size_Onnx_ver13.java


// Targeting ../Concat_Onnx_ver13.java


// Targeting ../Split_Onnx_ver13.java


// Targeting ../Slice_Onnx_ver13.java


// Targeting ../Transpose_Onnx_ver13.java


// Targeting ../ScatterND_Onnx_ver13.java


// Targeting ../ScatterElements_Onnx_ver13.java


// Targeting ../Gather_Onnx_ver13.java


// Targeting ../GatherElements_Onnx_ver13.java


// Targeting ../Squeeze_Onnx_ver13.java


// Targeting ../Unsqueeze_Onnx_ver13.java


// Targeting ../SpaceToDepth_Onnx_ver13.java


// Targeting ../DepthToSpace_Onnx_ver13.java


// Targeting ../Tile_Onnx_ver13.java


// Targeting ../Resize_Onnx_ver13.java


// Targeting ../Identity_Onnx_ver13.java


// Targeting ../IsNaN_Onnx_ver13.java


// Targeting ../NonZero_Onnx_ver13.java


// Targeting ../GatherND_Onnx_ver13.java


// Targeting ../Pad_Onnx_ver13.java


// Targeting ../QuantizeLinear_Onnx_ver13.java


// Targeting ../DequantizeLinear_Onnx_ver13.java


// Targeting ../Loop_Onnx_ver13.java


// Targeting ../If_Onnx_ver13.java


// Targeting ../OpSet_Onnx_ver13.java


// Targeting ../CumSum_Onnx_ver14.java


// Targeting ../Relu_Onnx_ver14.java


// Targeting ../Reshape_Onnx_ver14.java


// Targeting ../GRU_Onnx_ver14.java


// Targeting ../LSTM_Onnx_ver14.java


// Targeting ../RNN_Onnx_ver14.java


// Targeting ../Trilu_Onnx_ver14.java


// Targeting ../BatchNormalization_Onnx_ver14.java


// Targeting ../HardSwish_Onnx_ver14.java


// Targeting ../Add_Onnx_ver14.java


// Targeting ../Sub_Onnx_ver14.java


// Targeting ../Mul_Onnx_ver14.java


// Targeting ../Div_Onnx_ver14.java


// Targeting ../Identity_Onnx_ver14.java


// Targeting ../OpSet_Onnx_ver14.java


// Targeting ../BatchNormalization_Onnx_ver15.java


// Targeting ../Bernoulli_Onnx_ver15.java


// Targeting ../Pow_Onnx_ver15.java


// Targeting ../Optional_Onnx_ver15.java


// Targeting ../OptionalHasElement_Onnx_ver15.java


// Targeting ../OptionalGetElement_Onnx_ver15.java


// Targeting ../CastLike_Onnx_ver15.java


// Targeting ../Shape_Onnx_ver15.java


// Targeting ../OpSet_Onnx_ver15.java


// Targeting ../RoiAlign_Onnx_ver16.java


// Targeting ../ScatterND_Onnx_ver16.java


// Targeting ../ScatterElements_Onnx_ver16.java


// Targeting ../If_Onnx_ver16.java


// Targeting ../Loop_Onnx_ver16.java


// Targeting ../Identity_Onnx_ver16.java


// Targeting ../Where_Onnx_ver16.java


// Targeting ../GridSample_Onnx_ver16.java


// Targeting ../Scan_Onnx_ver16.java


// Targeting ../LessOrEqual_Onnx_ver16.java


// Targeting ../GreaterOrEqual_Onnx_ver16.java


// Targeting ../LeakyRelu_Onnx_ver16.java


// Targeting ../PRelu_Onnx_ver16.java


// Targeting ../OpSet_Onnx_ver16.java


// Targeting ../LayerNormalization_Onnx_ver17.java


// Targeting ../SequenceMap_Onnx_ver17.java


// Targeting ../DFT_Onnx_ver17.java


// Targeting ../HannWindow_Onnx_ver17.java


// Targeting ../HammingWindow_Onnx_ver17.java


// Targeting ../BlackmanWindow_Onnx_ver17.java


// Targeting ../MelWeightMatrix_Onnx_ver17.java


// Targeting ../STFT_Onnx_ver17.java


// Targeting ../OpSet_Onnx_ver17.java


// Targeting ../Pad_Onnx_ver18.java


// Targeting ../CenterCropPad_Onnx_ver18.java


// Targeting ../Resize_Onnx_ver18.java


// Targeting ../Mish_Onnx_ver18.java


// Targeting ../OptionalGetElement_Onnx_ver18.java


// Targeting ../OptionalHasElement_Onnx_ver18.java


// Targeting ../Split_Onnx_ver18.java


// Targeting ../Col2Im_Onnx_ver18.java


// Targeting ../ScatterND_Onnx_ver18.java


// Targeting ../ScatterElements_Onnx_ver18.java


// Targeting ../ReduceSumSquare_Onnx_ver18.java


// Targeting ../ReduceLogSum_Onnx_ver18.java


// Targeting ../ReduceLogSumExp_Onnx_ver18.java


// Targeting ../ReduceL1_Onnx_ver18.java


// Targeting ../ReduceL2_Onnx_ver18.java


// Targeting ../ReduceMax_Onnx_ver18.java


// Targeting ../ReduceMin_Onnx_ver18.java


// Targeting ../ReduceMean_Onnx_ver18.java


// Targeting ../ReduceProd_Onnx_ver18.java


// Targeting ../BitwiseAnd_Onnx_ver18.java


// Targeting ../BitwiseOr_Onnx_ver18.java


// Targeting ../BitwiseXor_Onnx_ver18.java


// Targeting ../BitwiseNot_Onnx_ver18.java


// Targeting ../GroupNormalization_Onnx_ver18.java


// Targeting ../LpPool_Onnx_ver18.java


// Targeting ../OpSet_Onnx_ver18.java


// Targeting ../Equal_Onnx_ver19.java


// Targeting ../AveragePool_Onnx_ver19.java


// Targeting ../Cast_Onnx_ver19.java


// Targeting ../CastLike_Onnx_ver19.java


// Targeting ../Constant_Onnx_ver19.java


// Targeting ../DeformConv_Onnx_ver19.java


// Targeting ../DequantizeLinear_Onnx_ver19.java


// Targeting ../Identity_Onnx_ver19.java


// Targeting ../If_Onnx_ver19.java


// Targeting ../Loop_Onnx_ver19.java


// Targeting ../Pad_Onnx_ver19.java


// Targeting ../QuantizeLinear_Onnx_ver19.java


// Targeting ../Resize_Onnx_ver19.java


// Targeting ../Reshape_Onnx_ver19.java


// Targeting ../Scan_Onnx_ver19.java


// Targeting ../Shape_Onnx_ver19.java


// Targeting ../Size_Onnx_ver19.java


// Targeting ../OpSet_Onnx_ver19.java


// Targeting ../AffineGrid_Onnx_ver20.java


// Targeting ../ConstantOfShape_Onnx_ver20.java


// Targeting ../DFT_Onnx_ver20.java


// Targeting ../Gelu_Onnx_ver20.java


// Targeting ../GridSample_Onnx_ver20.java


// Targeting ../ImageDecoder_Onnx_ver20.java


// Targeting ../IsInf_Onnx_ver20.java


// Targeting ../IsNaN_Onnx_ver20.java


// Targeting ../ReduceMax_Onnx_ver20.java


// Targeting ../ReduceMin_Onnx_ver20.java


// Targeting ../RegexFullMatch_Onnx_ver20.java


// Targeting ../StringConcat_Onnx_ver20.java


// Targeting ../StringSplit_Onnx_ver20.java


// Targeting ../OpSet_Onnx_ver20.java



@Namespace("onnx") public static native void RegisterOnnxOperatorSetSchema();

@Namespace("onnx") public static native void RegisterOnnxOperatorSetSchema(int target_version, @Cast("bool") boolean fail_duplicate_schema/*=true*/);
@Namespace("onnx") public static native void RegisterOnnxOperatorSetSchema(int target_version);

@Namespace("onnx") public static native void DeregisterOnnxOperatorSetSchema();

@Namespace("onnx") public static native @Cast("bool") boolean IsOnnxStaticRegistrationDisabled();

 // namespace ONNX_NAMESPACE


// Parsed from onnx/defs/operator_sets_ml.h

/*
 * SPDX-License-Identifier: Apache-2.0
 */

// #pragma once

// #ifdef ONNX_ML

// #include "onnx/defs/schema.h"
// Targeting ../ArrayFeatureExtractor_OnnxML_ver1.java


// Targeting ../Binarizer_OnnxML_ver1.java


// Targeting ../CastMap_OnnxML_ver1.java


// Targeting ../CategoryMapper_OnnxML_ver1.java


// Targeting ../DictVectorizer_OnnxML_ver1.java


// Targeting ../FeatureVectorizer_OnnxML_ver1.java


// Targeting ../Imputer_OnnxML_ver1.java


// Targeting ../LabelEncoder_OnnxML_ver1.java


// Targeting ../LinearClassifier_OnnxML_ver1.java


// Targeting ../LinearRegressor_OnnxML_ver1.java


// Targeting ../Normalizer_OnnxML_ver1.java


// Targeting ../OneHotEncoder_OnnxML_ver1.java


// Targeting ../SVMClassifier_OnnxML_ver1.java


// Targeting ../SVMRegressor_OnnxML_ver1.java


// Targeting ../Scaler_OnnxML_ver1.java


// Targeting ../TreeEnsembleClassifier_OnnxML_ver1.java


// Targeting ../TreeEnsembleRegressor_OnnxML_ver1.java


// Targeting ../ZipMap_OnnxML_ver1.java


// Targeting ../OpSet_OnnxML_ver1.java


// Targeting ../LabelEncoder_OnnxML_ver2.java


// Targeting ../OpSet_OnnxML_ver2.java


// Targeting ../TreeEnsembleClassifier_OnnxML_ver3.java


// Targeting ../TreeEnsembleRegressor_OnnxML_ver3.java


// Targeting ../OpSet_OnnxML_ver3.java


// Targeting ../LabelEncoder_OnnxML_ver4.java


// Targeting ../OpSet_OnnxML_ver4.java



@Namespace("onnx") public static native void RegisterOnnxMLOperatorSetSchema();
 // namespace ONNX_NAMESPACE

// #endif


// Parsed from onnx/defs/operator_sets_training.h

/*
 * SPDX-License-Identifier: Apache-2.0
 */

// #pragma once

// #include "onnx/defs/schema.h"
// Targeting ../OpSet_OnnxTraining_ver1.java



// Register training operators.
@Namespace("onnx") public static native void RegisterOnnxTrainingOperatorSetSchema();

 // namespace ONNX_NAMESPACE


// Parsed from onnx/defs/data_type_utils.h

/*
 * SPDX-License-Identifier: Apache-2.0
 */

// #ifndef ONNX_DATA_TYPE_UTILS_H
// #define ONNX_DATA_TYPE_UTILS_H

// #include <mutex>
// #include <string>
// #include <unordered_map>
// #include <unordered_set>

// #include "onnx/common/common.h"
// #include "onnx/onnx_pb.h"
// String pointer as unique TypeProto identifier.
// Targeting ../DataTypeUtils.java


 // namespace Utils
 // namespace ONNX_NAMESPACE

// #endif // ! ONNX_DATA_TYPE_UTILS_H


// Parsed from onnx/defs/shape_inference.h

/*
 * SPDX-License-Identifier: Apache-2.0
 */

// #pragma once

// #include <algorithm>
// #include <functional>
// #include <string>
// #include <utility>
// #include <vector>

// #include "onnx/defs/data_type_utils.h"
// #include "onnx/proto_utils.h"
// #include "onnx/string_utils.h"
// Targeting ../ShapeInferenceOptions.java


// Targeting ../SymbolTable.java


// Targeting ../InferenceError.java



// #define fail_type_inference(...)
//   ONNX_THROW_EX(ONNX_NAMESPACE::InferenceError(ONNX_NAMESPACE::MakeString("[TypeInferenceError] ", __VA_ARGS__)));

// #define fail_shape_inference(...)
//   ONNX_THROW_EX(ONNX_NAMESPACE::InferenceError(ONNX_NAMESPACE::MakeString("[ShapeInferenceError] ", __VA_ARGS__)));
// Targeting ../InferenceContext.java


// Targeting ../DataPropagationContext.java



// This no-op inference function is used for operators without an
// inference implementation.
@Namespace("onnx") public static native void dummyInferenceFunction(@ByRef InferenceContext arg0);

// This no-op data propagation function is used for operators without a defined data propagator
@Namespace("onnx") public static native void dummyDataPropagationFunction(@ByRef DataPropagationContext arg0);

@Namespace("onnx") public static native @Cast("int64_t") long getAttribute(@ByRef InferenceContext ctx, @StdString BytePointer attributeName, @Cast("int64_t") long defaultValue);
@Namespace("onnx") public static native @Cast("int64_t") long getAttribute(@ByRef InferenceContext ctx, @StdString String attributeName, @Cast("int64_t") long defaultValue);

@Namespace("onnx") public static native @Cast("int64_t") long getAttribute(@ByRef DataPropagationContext ctx, @StdString BytePointer attributeName, @Cast("int64_t") long defaultValue);
@Namespace("onnx") public static native @Cast("int64_t") long getAttribute(@ByRef DataPropagationContext ctx, @StdString String attributeName, @Cast("int64_t") long defaultValue);

@Namespace("onnx") public static native @StdString BytePointer getAttribute(@ByRef InferenceContext ctx, @StdString BytePointer attributeName, @StdString BytePointer defaultValue);
@Namespace("onnx") public static native @StdString String getAttribute(@ByRef InferenceContext ctx, @StdString String attributeName, @StdString String defaultValue);

@Namespace("onnx") public static native @ByVal @Name("operator *") Dimension multiply(@ByVal Dimension dim1, @ByVal Dimension dim2);

@Namespace("onnx") public static native @ByVal @Name("operator *") Dimension multiply(@ByVal Dimension dim1, @Cast("int64_t") long dim2);

@Namespace("onnx") public static native @ByVal @Name("operator /") Dimension divide(@ByVal Dimension dim1, @Cast("int64_t") long dim2);

// if from >= upto_exclusive, return 1.
// Caller must make sure upto_exclusive is less than or equal to shape.size()
// Caller must make sure from>=0
@Namespace("onnx") public static native @ByVal Dimension multiplyDims(@Const @ByRef TensorShapeProto shape, int from, int upto_exclusive);

@Namespace("onnx") public static native int getTensorElementType(@Const @ByRef TypeProto type);

@Namespace("onnx") public static native void setTensorElementType(int elem_type, @Cast("onnx::TypeProto::ValueCase") int value_case, @ByRef TypeProto type);

@Namespace("onnx") public static native void propagateElemTypeWithValidation(@Const TypeProto input_type, TypeProto output_type);

@Namespace("onnx") public static native void propagateElemTypeFromInputToOutput(@ByRef InferenceContext ctx, @Cast("size_t") long inputIndex, @Cast("size_t") long outputIndex);

@Namespace("onnx") public static native void propagateElemTypeFromTensorInputToOutput(@ByRef InferenceContext ctx, @Cast("size_t") long inputIndex, @Cast("size_t") long outputIndex);

@Namespace("onnx") public static native void propagateElemTypeFromDtypeToOutput(
    @ByRef InferenceContext ctx,
    int data_type,
    @Cast("size_t") long outputIndex,
    @Cast("onnx::TypeProto::ValueCase") int expected_value_case);

@Namespace("onnx") public static native void propagateElemTypeFromDtypeToOutput(@ByRef InferenceContext ctx, int data_type, @Cast("size_t") long outputIndex);

@Namespace("onnx") public static native void propagateElemTypeFromDtypeToOutput(@ByRef InferenceContext ctx, @Const AttributeProto attr, @Cast("size_t") long outputIndex);

@Namespace("onnx") public static native @Cast("bool") boolean hasShape(@Const @ByRef TypeProto type);

@Namespace("onnx") public static native @Const @ByRef TensorShapeProto getInputShape(@Const @ByRef InferenceContext ctx, @Cast("size_t") long n);

@Namespace("onnx") public static native @Const TensorShapeProto getOptionalInputShape(@ByRef InferenceContext ctx, @Cast("size_t") long n);

// Caller must make sure fromDimIndex is strictly less than shape.dim_size()
@Namespace("onnx") public static native void appendSingleDimCopiedFromInputTypeToOutputType(
    @ByRef InferenceContext ctx,
    @Cast("size_t") long inputIndex,
    @Cast("size_t") long outputIndex,
    @Cast("size_t") long fromDimIndex);

@Namespace("onnx") public static native void propagateShape(@Const TypeProto from_type, TypeProto to_type);

@Namespace("onnx") public static native void propagateShapeFromInputToOutput(@ByRef InferenceContext ctx, @Cast("size_t") long inputIndex, @Cast("size_t") long outputIndex);

@Namespace("onnx") public static native void propagateShapeAndTypeFromFirstInput(@ByRef InferenceContext ctx);

@Namespace("onnx") public static native void updateOutputElemType(@ByRef InferenceContext ctx, @Cast("size_t") long outputIndex, int elemType, @Cast("onnx::TypeProto::ValueCase") int expected_type);

@Namespace("onnx") public static native void updateOutputElemType(@ByRef InferenceContext ctx, @Cast("size_t") long outputIndex, int elemType);

// Infer type of an output from the value of a specified attribute, which is
// expected to have a valid value representing a TensorProto_DataType.
@Namespace("onnx") public static native void propagateElemTypeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString BytePointer attributeName,
    @Cast("size_t") long outputIndex,
    @Cast("onnx::TypeProto::ValueCase") int expected_type,
    @Cast("onnx::TensorProto_DataType") int default_value/*=TensorProto::UNDEFINED*/);
@Namespace("onnx") public static native void propagateElemTypeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString BytePointer attributeName,
    @Cast("size_t") long outputIndex,
    @Cast("onnx::TypeProto::ValueCase") int expected_type);
@Namespace("onnx") public static native void propagateElemTypeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString String attributeName,
    @Cast("size_t") long outputIndex,
    @Cast("onnx::TypeProto::ValueCase") int expected_type,
    @Cast("onnx::TensorProto_DataType") int default_value/*=TensorProto::UNDEFINED*/);
@Namespace("onnx") public static native void propagateElemTypeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString String attributeName,
    @Cast("size_t") long outputIndex,
    @Cast("onnx::TypeProto::ValueCase") int expected_type);

@Namespace("onnx") public static native void propagateElemTypeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString BytePointer attributeName,
    @Cast("size_t") long outputIndex);
@Namespace("onnx") public static native void propagateElemTypeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString String attributeName,
    @Cast("size_t") long outputIndex);

@Namespace("onnx") public static native TensorShapeProto getTensorMutableShape(@Cast("onnx::TypeProto::ValueCase") int value_case, @ByRef TypeProto type);

@Namespace("onnx") public static native TensorShapeProto getOutputShape(@ByRef InferenceContext ctx, @Cast("size_t") long n, @Cast("onnx::TypeProto::ValueCase") int default_type/*=TypeProto::kTensorType*/);
@Namespace("onnx") public static native TensorShapeProto getOutputShape(@ByRef InferenceContext ctx, @Cast("size_t") long n);

@Namespace("onnx") public static native void appendDim(TensorShapeProto shape, @Cast("int64_t") long dim_value);

@Namespace("onnx") public static native void updateOutputShape(
    @ByRef InferenceContext ctx,
    @Cast("size_t") long outputIndex,
    @Const @ByRef TensorShapeProto shape,
    @Cast("onnx::TypeProto::ValueCase") int default_type/*=TypeProto::kTensorType*/);
@Namespace("onnx") public static native void updateOutputShape(
    @ByRef InferenceContext ctx,
    @Cast("size_t") long outputIndex,
    @Const @ByRef TensorShapeProto shape);

@Namespace("onnx") public static native void updateOutputShape(
    @ByRef InferenceContext ctx,
    @Cast("size_t") long outputIndex,
    @Const @ByRef TensorProto tensorProto,
    @Cast("onnx::TypeProto::ValueCase") int default_type/*=TypeProto::kTensorType*/);
@Namespace("onnx") public static native void updateOutputShape(
    @ByRef InferenceContext ctx,
    @Cast("size_t") long outputIndex,
    @Const @ByRef TensorProto tensorProto);

// Get shape input by first checking initializer and then propagated symbolic data.
// If neither is available, try rank inference.
// When one of above succeeds, `true` is stored in `found`.
// Otherwise, `false` is stored, which means that returned TensorShapeProto does not make sense.
@Namespace("onnx") public static native @ByVal TensorShapeProto getShapeInput(@Const @ByRef InferenceContext ctx, @Cast("size_t") long input_index, @Cast("bool*") @ByRef BoolPointer found);
@Namespace("onnx") public static native @ByVal TensorShapeProto getShapeInput(@Const @ByRef InferenceContext ctx, @Cast("size_t") long input_index, @Cast("bool*") @ByRef boolean[] found);

// Infer shape of an output from the value of a specified attribute, which is
// expected to be a list of integers specifying a valid shape.
@Namespace("onnx") public static native void propagateShapeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString BytePointer attributeName,
    @Cast("size_t") long outputIndex,
    @Cast("onnx::TypeProto::ValueCase") int default_type/*=TypeProto::kTensorType*/);
@Namespace("onnx") public static native void propagateShapeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString BytePointer attributeName,
    @Cast("size_t") long outputIndex);
@Namespace("onnx") public static native void propagateShapeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString String attributeName,
    @Cast("size_t") long outputIndex,
    @Cast("onnx::TypeProto::ValueCase") int default_type/*=TypeProto::kTensorType*/);
@Namespace("onnx") public static native void propagateShapeFromAttributeToOutput(
    @ByRef InferenceContext ctx,
    @StdString String attributeName,
    @Cast("size_t") long outputIndex);

@Namespace("onnx") public static native void multidirectionalBroadcastShapeInference(
    @Const @ByRef TensorShapeProtoVector shapes,
    @ByRef TensorShapeProto resultShape);

@Namespace("onnx") public static native void bidirectionalBroadcastShapeInference(
    @Const @ByRef TensorShapeProto shapeL,
    @Const @ByRef TensorShapeProto shapeR,
    @ByRef TensorShapeProto resultShape);

/*
Merge the dimension information from two TensorShapeProto_Dimension instances.
Values are merged into target from source.
If target has no dimension information, copy from source.
If source has no dimension information, ignore source.
If both have dimension information:
 - Prefer values over params. If both have values, values must match.
 - Prefer target param over source param if mismatched.
Fail if there are mismatches in dimension values.
Currently, there is no way to refine/update dimension information for the
source from information available in the target.
*/
@Namespace("onnx") public static native void mergeInDimensionInfo(
    @Const @ByRef Dimension source_dim,
    @ByRef Dimension target_dim,
    int dim_index);

@Namespace("onnx") public static native void mergeInShapeInfo(@Const @ByRef TensorShapeProto source_shape, @ByRef TypeProto_Tensor target_type);

@Namespace("onnx") public static native void mergeInShapeInfo(@Const @ByRef TensorShapeProto source_shape, @ByRef TypeProto_SparseTensor target_type);

/*
Merge the shape information from two TypeProto_Tensor instances.
Values are merged into target from source.
If target has no shape information, copy from source.
If source has no shape information, ignore source.
If both have shape information:
- merge each TensorShapeProto_Dimension separately.
- Prefer values over params. If both have values, values must match.
- Prefer target param over source param if mismatched.
Fail if there are mismatches in number of dimensions or dimension values.
*/
@Namespace("onnx") public static native void mergeInShapeInfo(@Const @ByRef TypeProto_Tensor source, @ByRef TypeProto_Tensor target);

@Namespace("onnx") public static native void mergeInShapeInfo(@Const @ByRef TypeProto_SparseTensor source, @ByRef TypeProto_SparseTensor target);

// Return a copy of a type, with a specified dimension removed from its shape.
@Namespace("onnx") public static native @ByVal TypeProto RemoveIthDimensionFromShape(@Const @ByRef TypeProto proto, int removed_dim);

// Return a copy of a type, with specified number of dimensions removed from the
// beginning.
@Namespace("onnx") public static native @ByVal TypeProto RemoveDimensionsFromShape(@Const @ByRef TypeProto proto, int num_dimensions);

// copied from GSL:
// https://github.com/microsoft/GSL/blob/main/include/gsl/util

@Namespace("onnx") public static native void checkInputRank(@ByRef InferenceContext ctx, @Cast("size_t") long input_index, int expected_rank);

// Unification (between dimensions and/or shapes) is at the heart of
// shape-inference. The current inference algorithm can check input
// shapes/dimensions of a node and update the output shapes/dimensions. It
// cannot currently update input shapes and dimensions (even though in some
// contexts this inference is possible). Hence, we have the variants below to
// support "const" and "mutable" dimensions/shapes in unification.

@Namespace("onnx") public static native void checkDimEquality(@Cast("int64_t") long value1, @Cast("int64_t") long value2);

@Namespace("onnx") public static native void unifyDim(@Cast("const onnx::Dim*") @ByRef Dimension dim1, @Cast("const onnx::Dim*") @ByRef Dimension dim2);

// TODO: The functionality of unifyDim is similar to that of
// mergeInDimensionInfo. However, the error messages are different. Leaving this
// duplication in-place to preserve error message content.

@Namespace("onnx") public static native void unifyInputDim(@ByRef InferenceContext ctx, @Cast("size_t") long input_index, int dim_index, @Cast("onnx::Dim*") @ByRef Dimension dim);

// unifyDim: unifies a dimension with a constant value. If the dimension
// already has a value, we check for equality of new value with old value.
@Namespace("onnx") public static native void unifyDim(@Cast("onnx::Dim*") @ByRef Dimension dim, @Cast("int64_t") long value);

// target-shape = Union (target-shape, source_shape)
// Example 1: same rank, different dimensions
//    input1 shape: (2, 3, 4, 'x')
//    input2 shape: (2, 'y', 5, 'x')
//    output shape: (2, None, None, 'x')
// Example 2: different rank
//    input1 shape: (2, 3, 4, 'x')
//    input2 shape: (2, 3, 4)
//    output shape: None
@Namespace("onnx") public static native void UnionShapeInfo(@Const @ByRef TensorShapeProto source_shape, @ByRef TypeProto_Tensor target_type);

@Namespace("onnx") public static native void UnionShapeInfo(@Const @ByRef TensorShapeProto source_shape, @ByRef TypeProto_SparseTensor target_type);

// target-type = Union (target-type, source-type)
// target and source are required to have the same type.
// Example 1: same tensor type, different shape
//    source: tensor elem_type: int64, shape: (2, 3, 4, 'x')
//    target: tensor elem_type: int64, shape: (2, 'y', 5, 'x')
//    output: tensor elem_type: int64, shape: (2, None, None, 'x')
// Example 2: same sequence type, different shape
//    source: sequence of tensor, elem_type: float, shape: (2, 3, 4)
//    target: sequence of tensor, elem_type: float, shape: None
//    output: sequence of tensor, elem_type: float, shape: None
@Namespace("onnx") public static native void UnionTypeInfo(@Const @ByRef TypeProto source_type, @ByRef TypeProto target_type);

// adjustNegativeAxes: Negative axes values are translated to the right axis in the positive range

// checkAxesRange: Checks that values are within the range [-rank, rank)

// checkDuplicateAxes: Check that there are no duplicated axes

 // namespace ONNX_NAMESPACE


// Parsed from google/protobuf/port_def.inc

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This file defines common macros that are used in protobuf.
//
// To hide these definitions from the outside world (and to prevent collisions
// if more than one version of protobuf is #included in the same project) you
// must follow this pattern when #including port_def.inc in a header file:
//
// #include "other_header.h"
// #include "message.h"
// // etc.
//
// #include "port_def.inc"  // MUST be last header included
//
// // Definitions for this header.
//
// #include "port_undef.inc"
//
// This is a textual header with no include guard, because we want to
// detect/prohibit anytime it is #included twice without a corresponding
// #undef.

// The definitions in this file are intended to be portable across Clang,
// GCC, and MSVC. Function-like macros are usable without an #ifdef guard.
// Syntax macros (for example, attributes) are always defined, although
// they may be empty.
//
// Some definitions rely on the NDEBUG macro and/or (in MSVC) _DEBUG:
// - https://en.cppreference.com/w/c/error/assert
// - https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros#microsoft-specific-predefined-macros
//
// References for predefined macros:
// - Standard: https://en.cppreference.com/w/cpp/preprocessor/replace
// - Clang: https://clang.llvm.org/docs/LanguageExtensions.html
//          (see also GCC predefined macros)
// - GCC: https://gcc.gnu.org/onlinedocs/cpp/Predefined-Macros.html
// - MSVC: https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros
// - Interactive (Clang/GCC only): https://www.compiler-explorer.com/z/hc6jKd3sj
//
// References for attributes (and extension attributes):
// - Standard: https://en.cppreference.com/w/cpp/language/attributes
// - Clang: https://clang.llvm.org/docs/AttributeReference.html
// - GCC: https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html
//        (see Clang attribute docs as well)
//
// References for standard C++ language conformance (and minimum versions):
// - Clang: https://clang.llvm.org/cxx_status.html
// - GCC: https://gcc.gnu.org/projects/cxx-status.html
// - MSVC: https://docs.microsoft.com/en-us/cpp/overview/visual-cpp-language-conformance
//
// Historical release notes (which can help to determine minimum versions):
// - Clang: https://releases.llvm.org/
// - GCC: https://gcc.gnu.org/releases.html
// - MSVC: https://docs.microsoft.com/en-us/visualstudio/releases/2019/release-notes-history
//         https://docs.microsoft.com/en-us/visualstudio/releasenotes/vs2017-relnotes-history

// Portable fallbacks for C++20 feature test macros:
// https://en.cppreference.com/w/cpp/feature_test
// #ifndef __has_cpp_attribute
// #define __has_cpp_attribute(x) 0
// #define PROTOBUF_has_cpp_attribute_DEFINED_
// #endif

// Portable fallback for Clang's __has_feature macro:
// https://clang.llvm.org/docs/LanguageExtensions.html#has-feature-and-has-extension
// #ifndef __has_feature
// #define __has_feature(x) 0
// #define PROTOBUF_has_feature_DEFINED_
// #endif

// Portable fallback for Clang's __has_warning macro:
// #ifndef __has_warning
// #define __has_warning(x) 0
// #define PROTOBUF_has_warning_DEFINED_
// #endif

// Portable fallbacks for the __has_attribute macro (GCC and Clang):
// https://clang.llvm.org/docs/LanguageExtensions.html#has-attribute
// https://gcc.gnu.org/onlinedocs/cpp/_005f_005fhas_005fattribute.html
// #ifndef __has_attribute
// #define __has_attribute(x) 0
// #define PROTOBUF_has_attribute_DEFINED_
// #endif

// Portable fallback for __has_builtin (GCC and Clang):
// https://clang.llvm.org/docs/LanguageExtensions.html#has-builtin
// https://gcc.gnu.org/onlinedocs/cpp/_005f_005fhas_005fbuiltin.html
// #ifndef __has_builtin
// #define __has_builtin(x) 0
// #define PROTOBUF_has_builtin_DEFINED_
// #endif

// Portable check for GCC minimum version:
// https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html
// #if defined(__GNUC__) && defined(__GNUC_MINOR__)
//     && defined(__GNUC_PATCHLEVEL__)
// #  define PROTOBUF_GNUC_MIN(x, y)
//   (__GNUC__ > (x) || __GNUC__ == (x) && __GNUC_MINOR__ >= (y))
// #else
// #  define PROTOBUF_GNUC_MIN(x, y) 0
// #endif

// Portable check for MSVC minimum version:
// https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros
// #if defined(_MSC_VER)
// #define PROTOBUF_MSC_VER_MIN(x) (_MSC_VER >= x)
// #else
// #define PROTOBUF_MSC_VER_MIN(x) 0
// #endif

// Portable check for minimum C++ language version:
// https://en.cppreference.com/w/cpp/preprocessor/replace
// https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros
// #if !defined(_MSVC_LANG)
// #define PROTOBUF_CPLUSPLUS_MIN(x) (__cplusplus >= x)
// #else
// #define PROTOBUF_CPLUSPLUS_MIN(x) (_MSVC_LANG >= x)
// #endif

// Future versions of protobuf will include breaking changes to some APIs.
// This macro can be set to enable these API changes ahead of time, so that
// user code can be updated before upgrading versions of protobuf.
// PROTOBUF_FUTURE_FINAL is used on classes that are historically not marked as
// final, but that may be marked final in future (breaking) releases.
// #define PROTOBUF_FUTURE_BREAKING_CHANGES 1
// #define PROTOBUF_FUTURE_FINAL final
// #define PROTOBUF_FUTURE_FINAL

// #ifdef PROTOBUF_VERSION
// #error PROTOBUF_VERSION was previously defined
// #endif
public static final int PROTOBUF_VERSION = 3020003;

// #ifdef PROTOBUF_MIN_HEADER_VERSION_FOR_PROTOC
// #error PROTOBUF_MIN_HEADER_VERSION_FOR_PROTOC was previously defined
// #endif
public static final int PROTOBUF_MIN_HEADER_VERSION_FOR_PROTOC = 3020000;

// #ifdef PROTOBUF_MIN_PROTOC_VERSION
// #error PROTOBUF_MIN_PROTOC_VERSION was previously defined
// #endif
public static final int PROTOBUF_MIN_PROTOC_VERSION = 3020000;

// #ifdef PROTOBUF_VERSION_SUFFIX
// #error PROTOBUF_VERSION_SUFFIX was previously defined
// #endif
public static final String PROTOBUF_VERSION_SUFFIX = "";

// #if defined(PROTOBUF_NAMESPACE) || defined(PROTOBUF_NAMESPACE_ID)
// #error PROTOBUF_NAMESPACE or PROTOBUF_NAMESPACE_ID was previously defined
// #endif
public static final String PROTOBUF_NAMESPACE = "google::protobuf";
// #define PROTOBUF_NAMESPACE_ID google::protobuf
// #define PROTOBUF_NAMESPACE_OPEN
//   namespace google {
//   namespace protobuf {
// #define PROTOBUF_NAMESPACE_CLOSE
//   } /* namespace protobuf */
//   } /* namespace google */

// #ifdef PROTOBUF_ALWAYS_INLINE
// #endif
// For functions we want to force inline.
// #if defined(PROTOBUF_NO_INLINE)
// # define PROTOBUF_ALWAYS_INLINE
// #elif PROTOBUF_GNUC_MIN(3, 1)
// # define PROTOBUF_ALWAYS_INLINE __attribute__((always_inline))
// #elif defined(_MSC_VER)
// # define PROTOBUF_ALWAYS_INLINE __forceinline
// #else
// # define PROTOBUF_ALWAYS_INLINE
// #endif

// #ifdef PROTOBUF_NDEBUG_INLINE
// #endif
// Avoid excessive inlining in non-optimized builds. Without other optimizations
// the inlining is not going to provide benefits anyway and the huge resulting
// functions, especially in the proto-generated serialization functions, produce
// stack frames so large that many tests run into stack overflows (b/32192897).
// #if defined(NDEBUG) || (defined(_MSC_VER) && !defined(_DEBUG))
// # define PROTOBUF_NDEBUG_INLINE PROTOBUF_ALWAYS_INLINE
// #else
// # define PROTOBUF_NDEBUG_INLINE
// #endif

// Note that PROTOBUF_NOINLINE is an attribute applied to functions, to prevent
// them from being inlined by the compiler. This is different from
// PROTOBUF_NO_INLINE, which is a user-supplied macro that disables forced
// inlining by PROTOBUF_(ALWAYS|NDEBUG)_INLINE.
// #ifdef PROTOBUF_NOINLINE
// #endif
// #if PROTOBUF_GNUC_MIN(3, 1)
// # define PROTOBUF_NOINLINE __attribute__((noinline))
// #elif defined(_MSC_VER)
// Seems to have been around since at least Visual Studio 2005
// # define PROTOBUF_NOINLINE __declspec(noinline)
// #endif

// #ifdef PROTOBUF_MUSTTAIL
// #endif
// #ifdef PROTOBUF_TAILCALL
// #endif
// #if __has_cpp_attribute(clang::musttail) && !defined(__arm__) &&
//     !defined(_ARCH_PPC) && !defined(__wasm__) &&
//     !(defined(_MSC_VER) && defined(_M_IX86))
// #  ifndef PROTO2_OPENSOURCE
// Compilation fails on ARM32: b/195943306
// Compilation fails on powerpc64le: b/187985113
// Compilation fails on X86 Windows:
// https://github.com/llvm/llvm-project/issues/53271
// #  endif
// #define PROTOBUF_MUSTTAIL [[clang::musttail]]
// #define PROTOBUF_TAILCALL true
// #else
// #define PROTOBUF_MUSTTAIL
// #define PROTOBUF_TAILCALL false
// #endif

// #ifdef PROTOBUF_EXCLUSIVE_LOCKS_REQUIRED
// #error PROTOBUF_EXCLUSIVE_LOCKS_REQUIRED was previously defined
// #endif
// #if __has_attribute(exclusive_locks_required)
// #define PROTOBUF_EXCLUSIVE_LOCKS_REQUIRED(...)
//   __attribute__((exclusive_locks_required(__VA_ARGS__)))
// #else
// #define PROTOBUF_EXCLUSIVE_LOCKS_REQUIRED(...)
// #endif

// #ifdef PROTOBUF_NO_THREAD_SAFETY_ANALYSIS
// #endif
// #if __has_attribute(no_thread_safety_analysis)
// #define PROTOBUF_NO_THREAD_SAFETY_ANALYSIS
//   __attribute__((no_thread_safety_analysis))
// #else
// #define PROTOBUF_NO_THREAD_SAFETY_ANALYSIS
// #endif

// #ifdef PROTOBUF_GUARDED_BY
// #error PROTOBUF_GUARDED_BY was previously defined
// #endif
// #if __has_attribute(guarded_by)
// #define PROTOBUF_GUARDED_BY(x) __attribute__((guarded_by(x)))
// #else
// #define PROTOBUF_GUARDED_BY(x)
// #endif

// #ifdef PROTOBUF_LOCKS_EXCLUDED
// #error PROTOBUF_LOCKS_EXCLUDED was previously defined
// #endif
// #if __has_attribute(locks_excluded)
// #define PROTOBUF_LOCKS_EXCLUDED(...)
//   __attribute__((locks_excluded(__VA_ARGS__)))
// #else
// #define PROTOBUF_LOCKS_EXCLUDED(...)
// #endif

// #ifdef PROTOBUF_COLD
// #endif
// #if __has_attribute(cold) || PROTOBUF_GNUC_MIN(4, 3)
// # define PROTOBUF_COLD __attribute__((cold))
// #else
// # define PROTOBUF_COLD
// #endif

// #ifdef PROTOBUF_SECTION_VARIABLE
// #error PROTOBUF_SECTION_VARIABLE was previously defined
// #endif
// #if (__has_attribute(section) || defined(__GNUC__)) && defined(__ELF__)
// Place a variable in the given ELF section.
// # define PROTOBUF_SECTION_VARIABLE(x) __attribute__((section(#x)))
// #else
// # define PROTOBUF_SECTION_VARIABLE(x)
// #endif

// #if defined(PROTOBUF_DEPRECATED)
// #error PROTOBUF_DEPRECATED was previously defined
// #endif
// #if defined(PROTOBUF_DEPRECATED_MSG)
// #error PROTOBUF_DEPRECATED_MSG was previously defined
// #endif
// #if __has_attribute(deprecated) || PROTOBUF_GNUC_MIN(3, 0)
// # define PROTOBUF_DEPRECATED __attribute__((deprecated))
// # define PROTOBUF_DEPRECATED_MSG(msg) __attribute__((deprecated(msg)))
// #elif defined(_MSC_VER)
// # define PROTOBUF_DEPRECATED __declspec(deprecated)
// # define PROTOBUF_DEPRECATED_MSG(msg) __declspec(deprecated(msg))
// #else
// # define PROTOBUF_DEPRECATED
// # define PROTOBUF_DEPRECATED_MSG(msg)
// #endif

// #if defined(PROTOBUF_DEPRECATED_ENUM)
// #error PROTOBUF_DEPRECATED_ENUM was previously defined
// #endif
// #if defined(__clang__) || PROTOBUF_GNUC_MIN(6, 0)
// https://gcc.gnu.org/gcc-6/changes.html
// # define PROTOBUF_DEPRECATED_ENUM __attribute__((deprecated))
// #else
// # define PROTOBUF_DEPRECATED_ENUM
// #endif

// #ifdef PROTOBUF_FUNC_ALIGN
// #error PROTOBUF_FUNC_ALIGN was previously defined
// #endif
// #if __has_attribute(aligned) || PROTOBUF_GNUC_MIN(4, 3)
// #define PROTOBUF_FUNC_ALIGN(bytes) __attribute__((aligned(bytes)))
// #else
// #define PROTOBUF_FUNC_ALIGN(bytes)
// #endif

// #ifdef PROTOBUF_RETURNS_NONNULL
// #endif
// #if __has_attribute(returns_nonnull) || PROTOBUF_GNUC_MIN(4, 9)
// #define PROTOBUF_RETURNS_NONNULL __attribute__((returns_nonnull))
// #else
// #define PROTOBUF_RETURNS_NONNULL
// #endif

// #ifdef PROTOBUF_ATTRIBUTE_REINITIALIZES
// #endif
// #if __has_cpp_attribute(clang::reinitializes)
// #define PROTOBUF_ATTRIBUTE_REINITIALIZES [[clang::reinitializes]]
// #else
// #define PROTOBUF_ATTRIBUTE_REINITIALIZES
// #endif

// The minimum library version which works with the current version of the
// headers.
public static final int GOOGLE_PROTOBUF_MIN_LIBRARY_VERSION = 3020000;

// #ifdef PROTOBUF_RTTI
// #error PROTOBUF_RTTI was previously defined
// #endif
// #if defined(GOOGLE_PROTOBUF_NO_RTTI) && GOOGLE_PROTOBUF_NO_RTTI
// A user-provided definition GOOGLE_PROTOBUF_NO_RTTI=1 disables RTTI.
public static final int PROTOBUF_RTTI = 0;
// #elif defined(__cpp_rtti)
// https://en.cppreference.com/w/cpp/feature_test
// #elif __has_feature(cxx_rtti)
// https://clang.llvm.org/docs/LanguageExtensions.html#c-rtti
// #elif defined(__GXX_RTTI)
// https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html
// #elif defined(_CPPRTTI)
// https://docs.microsoft.com/en-us/cpp/build/reference/gr-enable-run-time-type-information
// #else
// #endif

// Returns the offset of the given field within the given aggregate type.
// This is equivalent to the ANSI C offsetof() macro.  However, according
// to the C++ standard, offsetof() only works on POD types, and GCC
// enforces this requirement with a warning.  In practice, this rule is
// unnecessarily strict; there is probably no compiler or platform on
// which the offsets of the direct fields of a class are non-constant.
// Fields inherited from superclasses *can* have non-constant offsets,
// but that's not what this macro will be used for.
// #ifdef PROTOBUF_FIELD_OFFSET
// #error PROTOBUF_FIELD_OFFSET was previously defined
// #endif
// #if defined(__clang__)
// For Clang we use __builtin_offsetof() and suppress the warning,
// to avoid Control Flow Integrity and UBSan vptr sanitizers from
// crashing while trying to validate the invalid reinterpret_casts.
// #define PROTOBUF_FIELD_OFFSET(TYPE, FIELD)
//   _Pragma("clang diagnostic push")
//   _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"")
//   __builtin_offsetof(TYPE, FIELD)
//   _Pragma("clang diagnostic pop")
// #elif PROTOBUF_GNUC_MIN(4, 8)
// #define PROTOBUF_FIELD_OFFSET(TYPE, FIELD) __builtin_offsetof(TYPE, FIELD)
// #else  // defined(__clang__)
// Note that we calculate relative to the pointer value 16 here since if we
// just use zero, GCC complains about dereferencing a NULL pointer.  We
// choose 16 rather than some other number just in case the compiler would
// be confused by an unaligned pointer.
// #define PROTOBUF_FIELD_OFFSET(TYPE, FIELD)
//   static_cast< ::uint32_t>(reinterpret_cast<const char*>(
//                              &reinterpret_cast<const TYPE*>(16)->FIELD) -
//                          reinterpret_cast<const char*>(16))
// #endif

// #ifdef PROTOBUF_EXPORT
// #endif

// #if defined(PROTOBUF_USE_DLLS) && defined(_MSC_VER)
// # if defined(LIBPROTOBUF_EXPORTS)
// #  define PROTOBUF_EXPORT __declspec(dllexport)
// #  define PROTOBUF_EXPORT_TEMPLATE_DECLARE
// #  define PROTOBUF_EXPORT_TEMPLATE_DEFINE __declspec(dllexport)
// # else
// #  define PROTOBUF_EXPORT __declspec(dllimport)
// #  define PROTOBUF_EXPORT_TEMPLATE_DECLARE
// #  define PROTOBUF_EXPORT_TEMPLATE_DEFINE __declspec(dllimport)
// # endif  // defined(LIBPROTOBUF_EXPORTS)
// #elif defined(PROTOBUF_USE_DLLS) && defined(LIBPROTOBUF_EXPORTS)
// # define PROTOBUF_EXPORT __attribute__((visibility("default")))
// # define PROTOBUF_EXPORT_TEMPLATE_DECLARE __attribute__((visibility("default")))
// # define PROTOBUF_EXPORT_TEMPLATE_DEFINE
// #else
// # define PROTOBUF_EXPORT
// # define PROTOBUF_EXPORT_TEMPLATE_DECLARE
// # define PROTOBUF_EXPORT_TEMPLATE_DEFINE
// #endif

// #ifdef PROTOC_EXPORT
// #endif

// #if defined(PROTOBUF_USE_DLLS) && defined(_MSC_VER)
// # if defined(LIBPROTOC_EXPORTS)
// #  define PROTOC_EXPORT __declspec(dllexport)
// # else
// #  define PROTOC_EXPORT __declspec(dllimport)
// # endif  // defined(LIBPROTOC_EXPORTS)
// #elif defined(PROTOBUF_USE_DLLS) && defined(LIBPROTOC_EXPORTS)
// # define PROTOC_EXPORT __attribute__((visibility("default")))
// #else
// # define PROTOC_EXPORT
// #endif

// #if defined(PROTOBUF_PREDICT_TRUE) || defined(PROTOBUF_PREDICT_FALSE)
// #error PROTOBUF_PREDICT_(TRUE|FALSE) was previously defined
// #endif
// #if PROTOBUF_GNUC_MIN(3, 0)
// # define PROTOBUF_PREDICT_TRUE(x) (__builtin_expect(false || (x), true))
// # define PROTOBUF_PREDICT_FALSE(x) (__builtin_expect(false || (x), false))
// #else
// # define PROTOBUF_PREDICT_TRUE(x) (x)
// # define PROTOBUF_PREDICT_FALSE(x) (x)
// #endif

// #ifdef PROTOBUF_NODISCARD
// #endif
// #if __has_cpp_attribute(nodiscard) && PROTOBUF_CPLUSPLUS_MIN(201703L)
// #define PROTOBUF_NODISCARD [[nodiscard]]
// #elif __has_attribute(warn_unused_result) || PROTOBUF_GNUC_MIN(4, 8)
// #define PROTOBUF_NODISCARD __attribute__((warn_unused_result))
// #else
// #define PROTOBUF_NODISCARD
// #endif

// Enable all stable experiments if this flag is set.  This allows us to group
// all of these experiments under a single build flag, which can be enabled in
// the protobuf.stable-experiments TAP project.
// #ifdef PROTOBUF_ENABLE_STABLE_EXPERIMENTS
// #define PROTOBUF_FORCE_MESSAGE_OWNED_ARENA
// #endif  // !PROTOBUF_ENABLE_STABLE_EXPERIMENTS

// #ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
// #error PROTOBUF_FORCE_COPY_IN_RELEASE was previously defined
// #endif

// #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
// #endif

// #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
// #error PROTOBUF_FORCE_COPY_IN_MOVE was previously defined
// #endif

// Force copy the default string to a string field so that non-optimized builds
// have harder-to-rely-on address stability.
// #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
// #error PROTOBUF_FORCE_COPY_DEFAULT_STRING was previously defined
// #endif

// #ifdef PROTOBUF_FALLTHROUGH_INTENDED
// #endif
// #if __has_cpp_attribute(fallthrough)
// #define PROTOBUF_FALLTHROUGH_INTENDED [[fallthrough]]
// #elif __has_feature(cxx_attributes) && __has_warning("-Wimplicit-fallthrough")
// #define PROTOBUF_FALLTHROUGH_INTENDED [[clang::fallthrough]]
// #elif PROTOBUF_GNUC_MIN(7, 0)
// #define PROTOBUF_FALLTHROUGH_INTENDED [[gnu::fallthrough]]
// #else
// #define PROTOBUF_FALLTHROUGH_INTENDED
// #endif

// PROTOBUF_ASSUME(pred) tells the compiler that it can assume pred is true. To
// be safe, we also validate the assumption with a GOOGLE_DCHECK in unoptimized
// builds. The macro does not do anything useful if the compiler does not
// support __builtin_assume.
// #ifdef PROTOBUF_ASSUME
// #error PROTOBUF_ASSUME was previously defined
// #endif
// #if __has_builtin(__builtin_assume)
// #define PROTOBUF_ASSUME(pred)
//   GOOGLE_DCHECK(pred);
//   __builtin_assume(pred)
// #else
// #define PROTOBUF_ASSUME(pred) GOOGLE_DCHECK(pred)
// #endif

// Specify memory alignment for structs, classes, etc.
// Use like:
//   class PROTOBUF_ALIGNAS(16) MyClass { ... }
//   PROTOBUF_ALIGNAS(16) int array[4];
//
// In most places you can use the C++11 keyword "alignas", which is preferred.
//
// But compilers have trouble mixing __attribute__((...)) syntax with
// alignas(...) syntax.
//
// Doesn't work in clang or gcc:
//   struct alignas(16) __attribute__((packed)) S { char c; };
// Works in clang but not gcc:
//   struct __attribute__((packed)) alignas(16) S2 { char c; };
// Works in clang and gcc:
//   struct alignas(16) S3 { char c; } __attribute__((packed));
//
// There are also some attributes that must be specified *before* a class
// definition: visibility (used for exporting functions/classes) is one of
// these attributes. This means that it is not possible to use alignas() with a
// class that is marked as exported.
// #ifdef PROTOBUF_ALIGNAS
// #error PROTOBUF_ALIGNAS was previously defined
// #endif
// #if defined(_MSC_VER)
// #define PROTOBUF_ALIGNAS(byte_alignment) __declspec(align(byte_alignment))
// #elif PROTOBUF_GNUC_MIN(3, 0)
// #define PROTOBUF_ALIGNAS(byte_alignment)
//   __attribute__((aligned(byte_alignment)))
// #else
// #define PROTOBUF_ALIGNAS(byte_alignment) alignas(byte_alignment)
// #endif

// #ifdef PROTOBUF_FINAL
// #endif
// #define PROTOBUF_FINAL final

// #ifdef PROTOBUF_THREAD_LOCAL
// #endif
// #if defined(_MSC_VER)
// #define PROTOBUF_THREAD_LOCAL __declspec(thread)
// #else
// #define PROTOBUF_THREAD_LOCAL __thread
// #endif

// For enabling message owned arena, one major blocker is semantic change from
// moving to copying when there is ownership transfer (e.g., move ctor, swap,
// set allocated, release). This change not only causes performance regression
// but also breaks users code (e.g., dangling reference). For top-level
// messages, since it owns the arena, we can mitigate the issue by transferring
// ownership of arena. However, we cannot do that for nested messages. In order
// to tell how many usages of nested messages affected by message owned arena,
// we need to simulate the arena ownership.
// This experiment is purely for the purpose of gathering data. All code guarded
// by this flag is supposed to be removed after this experiment.
// #define PROTOBUF_MESSAGE_OWNED_ARENA_EXPERIMENT
// #ifdef PROTOBUF_CONSTINIT
// #endif
// #if defined(__cpp_constinit)
// #define PROTOBUF_CONSTINIT constinit
// #define PROTOBUF_CONSTEXPR constexpr
// Some older Clang versions incorrectly raise an error about
// constant-initializing weak default instance pointers. Versions 12.0 and
// higher seem to work, except that XCode 12.5.1 shows the error even though it
// uses Clang 12.0.5.
// #elif __has_cpp_attribute(clang::require_constant_initialization) &&
//     ((defined(__APPLE__) && __clang_major__ >= 13) ||
//      (!defined(__APPLE__) && __clang_major__ >= 12))
// #define PROTOBUF_CONSTINIT [[clang::require_constant_initialization]]
// #define PROTOBUF_CONSTEXPR constexpr
// #elif PROTOBUF_GNUC_MIN(12, 0)
// #define PROTOBUF_CONSTINIT __constinit
// #define PROTOBUF_CONSTEXPR constexpr
// #else
// #define PROTOBUF_CONSTINIT
// #define PROTOBUF_CONSTEXPR inline
// #endif

// Some globals with an empty non-trivial destructor are annotated with
// no_destroy for performance reasons. It reduces the cost of these globals in
// non-opt mode and under sanitizers.
// #ifdef PROTOBUF_ATTRIBUTE_NO_DESTROY
// #endif
// #if __has_cpp_attribute(clang::no_destroy)
// #define PROTOBUF_ATTRIBUTE_NO_DESTROY [[clang::no_destroy]]
// #else
// #define PROTOBUF_ATTRIBUTE_NO_DESTROY
// #endif

// Force clang to always emit complete debug info for a type.
// Clang uses constructor homing to determine when to emit debug info for a
// type. If the constructor of a type is never used, which can happen in some
// cases where member variables are constructed in place for optimization
// purposes (see b/208803175 for an example), the type will have incomplete
// debug info unless this attribute is used.
// #ifdef PROTOBUF_ATTRIBUTE_STANDALONE_DEBUG
// #endif
// #if __has_cpp_attribute(clang::standalone_debug)
// #define PROTOBUF_ATTRIBUTE_STANDALONE_DEBUG [[clang::standalone_debug]]
// #else
// #define PROTOBUF_ATTRIBUTE_STANDALONE_DEBUG
// #endif

// Protobuf extensions and reflection require registration of the protos linked
// in the binary. Not until everything is registered does the runtime have a
// complete view on all protos. When code is using reflection or extensions
// in between registration calls this can lead to surprising behavior. By
// having the registration run first we mitigate this scenario.
// Highest priority is 101. We use 102 for registration, to allow code that
// really wants to higher priority to still beat us. Some initialization happens
// at higher priority, though, since it is needed before registration.
// #ifdef PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
// #endif
// #ifdef PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
// #endif
// #if PROTOBUF_GNUC_MIN(3, 0) && (!defined(__APPLE__) || defined(__clang__)) &&
//     !((defined(sun) || defined(__sun)) &&
//       (defined(__SVR4) || defined(__svr4__)))
// #define PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 __attribute__((init_priority((101))))
// #define PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 __attribute__((init_priority((102))))
// #else
// #define PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
// #define PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
// #endif

// #ifdef PROTOBUF_PRAGMA_INIT_SEG
// #endif
// #ifdef _MSC_VER
// #define PROTOBUF_PRAGMA_INIT_SEG __pragma(init_seg(lib))
// #else
// #define PROTOBUF_PRAGMA_INIT_SEG
// #endif

// #ifdef PROTOBUF_ATTRIBUTE_WEAK
// #endif
// #if __has_attribute(weak) &&
//     !defined(__APPLE__) &&
//     (!defined(_WIN32) || __clang_major__ < 9) &&
//     !defined(__MINGW32__)
// #define PROTOBUF_ATTRIBUTE_WEAK __attribute__((weak))
public static final int PROTOBUF_HAVE_ATTRIBUTE_WEAK = 1;
// #else
// #define PROTOBUF_ATTRIBUTE_WEAK
// #endif

// Macros to detect sanitizers.
// #ifdef PROTOBUF_ASAN
// #error PROTOBUF_ASAN was previously defined
// #endif
// #ifdef PROTOBUF_MSAN
// #error PROTOBUF_MSAN was previously defined
// #endif
// #ifdef PROTOBUF_TSAN
// #error PROTOBUF_TSAN was previously defined
// #endif
// #if defined(__clang__)
// #  if __has_feature(address_sanitizer)
public static final int PROTOBUF_ASAN = 1;
// #  endif
// #  if __has_feature(thread_sanitizer)
public static final int PROTOBUF_TSAN = 1;
// #  endif
// #  if __has_feature(memory_sanitizer)
public static final int PROTOBUF_MSAN = 1;
// #  endif
// #elif PROTOBUF_GNUC_MIN(3, 0)
// Double-guard is needed for -Wundef:
// #  ifdef __SANITIZE_ADDRESS__
// #  if    __SANITIZE_ADDRESS__
// #  endif
// #  endif
// #  ifdef __SANITIZE_THREAD__
// #  if    __SANITIZE_THREAD__
// #  endif
// #  endif
// #endif

// Tail call table-driven parsing can be enabled by defining
// PROTOBUF_EXPERIMENTAL_USE_TAIL_CALL_TABLE_PARSER at compilation time. Note
// that this macro is for small-scale testing only, and is not supported.
// #ifdef PROTOBUF_TAIL_CALL_TABLE_PARSER_ENABLED
// #error PROTOBUF_TAIL_CALL_TABLE_PARSER_ENABLED was previously declared
// #endif
// #if defined(PROTOBUF_EXPERIMENTAL_USE_TAIL_CALL_TABLE_PARSER)
public static final int PROTOBUF_TAIL_CALL_TABLE_PARSER_ENABLED = 1;
// #endif

// #define PROTOBUF_TC_PARAM_DECL
//   ::google::protobuf::MessageLite *msg, const char *ptr,
//       ::google::protobuf::internal::ParseContext *ctx,
//       const ::google::protobuf::internal::TcParseTableBase *table,
//       uint64_t hasbits, ::google::protobuf::internal::TcFieldData data

// #ifdef PROTOBUF_UNUSED
// #endif
// #if __has_cpp_attribute(maybe_unused) ||
//     (PROTOBUF_MSC_VER_MIN(1911) && PROTOBUF_CPLUSPLUS_MIN(201703L))
// #define PROTOBUF_UNUSED [[maybe_unused]]
// #elif __has_attribute(unused) || PROTOBUF_GNUC_MIN(3, 0)
// #define PROTOBUF_UNUSED __attribute__((__unused__))
// #else
// #define PROTOBUF_UNUSED
// #endif

// ThreadSafeArenaz is turned off completely in opensource builds.

// Windows declares several inconvenient macro names.  We #undef them and then
// restore them in port_undef.inc.
// #ifdef _MSC_VER
// #pragma push_macro("CREATE_NEW")
// #undef CREATE_NEW
// #pragma push_macro("DELETE")
// #undef DELETE
// #pragma push_macro("DOUBLE_CLICK")
// #undef DOUBLE_CLICK
// #pragma push_macro("ERROR")
// #undef ERROR
// #pragma push_macro("ERROR_BUSY")
// #undef ERROR_BUSY
// #pragma push_macro("ERROR_INSTALL_FAILED")
// #undef ERROR_INSTALL_FAILED
// #pragma push_macro("ERROR_NOT_FOUND")
// #undef ERROR_NOT_FOUND
// #pragma push_macro("GetMessage")
// #undef GetMessage
// #pragma push_macro("IGNORE")
// #undef IGNORE
// #pragma push_macro("IN")
// #undef IN
// #pragma push_macro("INPUT_KEYBOARD")
// #undef INPUT_KEYBOARD
// #pragma push_macro("NO_ERROR")
// #undef NO_ERROR
// #pragma push_macro("OUT")
// #undef OUT
// #pragma push_macro("OPTIONAL")
// #undef OPTIONAL
// #pragma push_macro("min")
// #undef min
// #pragma push_macro("max")
// #undef max
// #pragma push_macro("NEAR")
// #undef NEAR
// #pragma push_macro("NO_DATA")
// #undef NO_DATA
// #pragma push_macro("REASON_UNKNOWN")
// #undef REASON_UNKNOWN
// #pragma push_macro("SERVICE_DISABLED")
// #undef SERVICE_DISABLED
// #pragma push_macro("SEVERITY_ERROR")
// #undef SEVERITY_ERROR
// #pragma push_macro("STATUS_PENDING")
// #undef STATUS_PENDING
// #pragma push_macro("STRICT")
// #undef STRICT
// #pragma push_macro("timezone")
// #undef timezone
// #endif  // _MSC_VER

// #ifdef __APPLE__
// Inconvenient macro names from usr/include/math.h in some macOS SDKs.
// #pragma push_macro("DOMAIN")
// #undef DOMAIN
// Inconvenient macro names from /usr/include/mach/boolean.h in some macOS SDKs.
// #pragma push_macro("TRUE")
// #undef TRUE
// #pragma push_macro("FALSE")
// #undef FALSE
// #endif  // __APPLE__

// #if defined(__clang__) || PROTOBUF_GNUC_MIN(3, 0) || defined(_MSC_VER)
// Don't let Objective-C Macros interfere with proto identifiers with the same
// name.
// #pragma push_macro("DEBUG")
// #undef DEBUG
// #endif // defined(__clang__) || PROTOBUF_GNUC_MIN(3, 0) || defined(_MSC_VER)

// #if defined(__clang__)
// #pragma clang diagnostic push
// TODO(gerbens) ideally we cleanup the code. But a cursory try shows many
// violations. So let's ignore for now.
// #pragma clang diagnostic ignored "-Wshorten-64-to-32"
// #elif PROTOBUF_GNUC_MIN(3, 0)
// GCC does not allow disabling diagnostics within an expression:
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60875, so we disable this one
// globally even though it's only used for PROTOBUF_FIELD_OFFSET.
// #pragma GCC diagnostic push
// #pragma GCC diagnostic ignored "-Winvalid-offsetof"
// #endif

// Silence some MSVC warnings in all our code.
// #ifdef _MSC_VER
// #pragma warning(push)
// For non-trivial unions
// #pragma warning(disable : 4582)
// #pragma warning(disable : 4583)
// For init_seg(lib)
// #pragma warning(disable : 4073)
// To silence the fact that we will pop this push from another file
// #pragma warning(disable : 5031)
// Conditional expression is constant
// #pragma warning(disable: 4127)
// decimal digit terminates octal escape sequence
// #pragma warning(disable: 4125)
// #endif

// We don't want code outside port_def doing complex testing, so
// remove our portable condition test macros to nudge folks away from
// using it themselves.
// #ifdef PROTOBUF_has_cpp_attribute_DEFINED_
// #endif
// #ifdef PROTOBUF_has_feature_DEFINED_
// #endif
// #ifdef PROTOBUF_has_warning_DEFINED_
// #endif
// #ifdef PROTOBUF_has_attribute_DEFINED_
// #endif
// #ifdef PROTOBUF_has_builtin_DEFINED_
// #endif


// Parsed from google/protobuf/arena.h

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This file defines an Arena allocator for better allocation performance.

// #ifndef GOOGLE_PROTOBUF_ARENA_H__
// #define GOOGLE_PROTOBUF_ARENA_H__


// #include <limits>
// #include <type_traits>
// #include <utility>
// #if defined(_MSC_VER) && !defined(_LIBCPP_STD_VER) && !_HAS_EXCEPTIONS
// Work around bugs in MSVC <typeinfo> header when _HAS_EXCEPTIONS=0.
// #include <exception>
// #include <typeinfo>

// #else
// #include <typeinfo>
// #endif

// #include <type_traits>
// #include <google/protobuf/arena_impl.h>
// #include <google/protobuf/port.h>

// Must be included last.
// #include <google/protobuf/port_def.inc>

// #ifdef SWIG
// #error "You cannot SWIG proto headers"
// #endif  // defined below    // defined below  // defined in message.h




// Targeting ../ReflectionTester.java

  // defined in test_util.h

// Targeting ../ArenaTestPeer.java


// Targeting ../InternalMetadata.java


// Targeting ../LazyField.java


// Targeting ../EpsCopyInputStream.java


// Targeting ../RepeatedPtrFieldBase.java

  // defined in repeated_ptr_field.h  // defined in repeated_field.h

@Namespace("google::protobuf::internal") public static native Pointer AlignTo(Pointer ptr, @Cast("size_t") long align);

// Templated cleanup methods.

// Targeting ../ArenaOptions.java



// Support for non-RTTI environments. (The metrics hooks API uses type
// information.)
// #if PROTOBUF_RTTI
// #define RTTI_TYPE_ID(type) (&typeid(type))
// Targeting ../Arena.java



// Defined above for supporting environments without RTTI.
// #undef RTTI_TYPE_ID

  // namespace protobuf
  // namespace google

// #include <google/protobuf/port_undef.inc>

// #endif  // GOOGLE_PROTOBUF_ARENA_H__


// Parsed from google/protobuf/message_lite.h

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Authors: wink@google.com (Wink Saville),
//          kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// Defines MessageLite, the abstract interface implemented by all (lite
// and non-lite) protocol message objects.

// #ifndef GOOGLE_PROTOBUF_MESSAGE_LITE_H__
// #define GOOGLE_PROTOBUF_MESSAGE_LITE_H__


// #include <climits>
// #include <string>

// #include <google/protobuf/stubs/common.h>
// #include <google/protobuf/stubs/logging.h>
// #include <google/protobuf/io/coded_stream.h>
// #include <google/protobuf/arena.h>
// #include <google/protobuf/stubs/once.h>
// #include <google/protobuf/port.h>
// #include <google/protobuf/stubs/strutil.h>
// #include <google/protobuf/explicitly_constructed.h>
// #include <google/protobuf/metadata_lite.h>
// #include <google/protobuf/stubs/hash.h>  // TODO(b/211442718): cleanup

// clang-format off
// #include <google/protobuf/port_def.inc>
// clang-format on

// #ifdef SWIG
// #error "You cannot SWIG proto headers"
// #endif
// Targeting ../FastReflectionMessageMutator.java


// Targeting ../FastReflectionStringSetter.java


// Targeting ../Reflection.java


// Targeting ../CodedInputStream.java


// Targeting ../CodedOutputStream.java


// Targeting ../ZeroCopyInputStream.java


// Targeting ../ZeroCopyOutputStream.java




// Targeting ../SwapFieldHelper.java


// Targeting ../ParseContext.java


// Targeting ../ExtensionSet.java


// Targeting ../TcParser.java


// Targeting ../WireFormatLite.java


// Targeting ../WeakFieldMap.java

  // defined in repeated_field.h

// We compute sizes as size_t but cache them as int.  This function converts a
// computed size to a cached size.  Since we don't proceed with serialization
// if the total size was > INT_MAX, it is not important what this function
// returns for inputs > INT_MAX.  However this case should not error or
// GOOGLE_CHECK-fail, because the full size_t resolution is still returned from
// ByteSizeLong() and checked against INT_MAX; we can catch the overflow
// there.
@Namespace("google::protobuf::internal") public static native int ToCachedSize(@Cast("size_t") long size);

// We mainly calculate sizes in terms of size_t, but some functions that
// compute sizes return "int".  These int sizes are expected to always be
// positive. This function is more efficient than casting an int to size_t
// directly on 64-bit platforms because it avoids making the compiler emit a
// sign extending instruction, which we don't want and don't want to pay for.
@Namespace("google::protobuf::internal") public static native @Cast("size_t") long FromIntSize(int size);

// For cases where a legacy function returns an integer size.  We GOOGLE_DCHECK()
// that the conversion will fit within an integer; if this is false then we
// are losing information.
@Namespace("google::protobuf::internal") public static native int ToIntSize(@Cast("size_t") long size);

// Default empty string object. Don't use this directly. Instead, call
// GetEmptyString() to get the reference. This empty string is aligned with a
// minimum alignment of 8 bytes to match the requirement of ArenaStringPtr.


@Namespace("google::protobuf::internal") public static native @StdString BytePointer GetEmptyStringAlreadyInited();

@Namespace("google::protobuf::internal") public static native @Cast("size_t") long StringSpaceUsedExcludingSelfLong(@StdString BytePointer str);
@Namespace("google::protobuf::internal") public static native @Cast("size_t") long StringSpaceUsedExcludingSelfLong(@StdString String str);


// Targeting ../MessageLite.java










// Targeting ../BoundedZCIS.java









  // namespace internal



// ===================================================================
// Shutdown support.


// Shut down the entire protocol buffers library, deleting all static-duration
// objects allocated by the library or by generated .pb.cc files.
//
// There are two reasons you might want to call this:
// * You use a draconian definition of "memory leak" in which you expect
//   every single malloc() to have a corresponding free(), even for objects
//   which live until program exit.
// * You are writing a dynamically-loaded library which needs to clean up
//   after itself when the library is unloaded.
//
// It is safe to call this multiple times.  However, it is not safe to use
// any other part of the protocol buffers library after
// ShutdownProtobufLibrary() has been called. Furthermore this call is not
// thread safe, user needs to synchronize multiple calls.
@Namespace("google::protobuf") public static native void ShutdownProtobufLibrary();
// Targeting ../Func.java


@Namespace("google::protobuf::internal") public static native void OnShutdown(Func func);
// Targeting ../F_Pointer.java


@Namespace("google::protobuf::internal") public static native void OnShutdownRun(F_Pointer f, @Const Pointer arg);

  // namespace internal
  // namespace protobuf
  // namespace google

// #include <google/protobuf/port_undef.inc>

// #endif  // GOOGLE_PROTOBUF_MESSAGE_LITE_H__


// Parsed from google/protobuf/unknown_field_set.h

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// Contains classes used to keep track of unrecognized fields seen while
// parsing a protocol message.

// #ifndef GOOGLE_PROTOBUF_UNKNOWN_FIELD_SET_H__
// #define GOOGLE_PROTOBUF_UNKNOWN_FIELD_SET_H__


// #include <assert.h>

// #include <string>
// #include <vector>

// #include <google/protobuf/stubs/common.h>
// #include <google/protobuf/stubs/logging.h>
// #include <google/protobuf/io/coded_stream.h>
// #include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// #include <google/protobuf/port.h>
// #include <google/protobuf/message_lite.h>
// #include <google/protobuf/parse_context.h>

// Must be included last.
// #include <google/protobuf/port_def.inc>

// #ifdef SWIG
// #error "You cannot SWIG proto headers"
// #endif
// Targeting ../WireFormat.java


// Targeting ../MessageSetFieldSkipperUsingCord.java


// extension_set_heavy.cc
  // namespace internal       // message.h
// Targeting ../UnknownFieldSet.java



@Namespace("google::protobuf::internal") public static native void WriteVarint(@Cast("uint32_t") int num, @Cast("uint64_t") long val, UnknownFieldSet unknown);


@Namespace("google::protobuf::internal") public static native @Cast("const char*") BytePointer UnknownGroupParse(UnknownFieldSet unknown, @Cast("const char*") BytePointer ptr,
                              ParseContext ctx);
@Namespace("google::protobuf::internal") public static native String UnknownGroupParse(UnknownFieldSet unknown, String ptr,
                              ParseContext ctx);



// Targeting ../UnknownField.java



// ===================================================================
// inline implementations













































  // namespace protobuf
  // namespace google

// #include <google/protobuf/port_undef.inc>
// #endif  // GOOGLE_PROTOBUF_UNKNOWN_FIELD_SET_H__


// Parsed from google/protobuf/descriptor.h

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// This file contains classes which describe a type of protocol message.
// You can use a message's descriptor to learn at runtime what fields
// it contains and what the types of those fields are.  The Message
// interface also allows you to dynamically access and modify individual
// fields by passing the FieldDescriptor of the field you are interested
// in.
//
// Most users will not care about descriptors, because they will write
// code specific to certain protocol types and will simply use the classes
// generated by the protocol compiler directly.  Advanced users who want
// to operate on arbitrary types (not known at compile time) may want to
// read descriptors in order to learn about the contents of a message.
// A very small number of users will want to construct their own
// Descriptors, either because they are implementing Message manually or
// because they are writing something like the protocol compiler.
//
// For an example of how you might use descriptors, see the code example
// at the top of message.h.

// #ifndef GOOGLE_PROTOBUF_DESCRIPTOR_H__
// #define GOOGLE_PROTOBUF_DESCRIPTOR_H__


// #include <atomic>
// #include <map>
// #include <memory>
// #include <set>
// #include <string>
// #include <vector>

// #include <google/protobuf/stubs/common.h>
// #include <google/protobuf/stubs/logging.h>
// #include <google/protobuf/stubs/mutex.h>
// #include <google/protobuf/stubs/once.h>
// #include <google/protobuf/port.h>

// Must be included last.
// #include <google/protobuf/port_def.inc>

// TYPE_BOOL is defined in the MacOS's ConditionalMacros.h.
// #ifdef TYPE_BOOL
// #undef TYPE_BOOL
// #endif  // TYPE_BOOL

// #ifdef SWIG
// #define PROTOBUF_EXPORT
// #endif
// Targeting ../DescriptorDatabase.java


// Targeting ../DescriptorProto.java


// Targeting ../DescriptorProto_ExtensionRange.java


// Targeting ../FieldDescriptorProto.java


// Targeting ../OneofDescriptorProto.java


// Targeting ../EnumDescriptorProto.java


// Targeting ../EnumValueDescriptorProto.java


// Targeting ../ServiceDescriptorProto.java


// Targeting ../MethodDescriptorProto.java


// Targeting ../FileDescriptorProto.java


// Targeting ../MessageOptions.java


// Targeting ../FieldOptions.java


// Targeting ../OneofOptions.java


// Targeting ../EnumOptions.java


// Targeting ../EnumValueOptions.java


// Targeting ../ExtensionRangeOptions.java


// Targeting ../ServiceOptions.java


// Targeting ../MethodOptions.java


// Targeting ../FileOptions.java


// Targeting ../UninterpretedOption.java


// Targeting ../SourceCodeInfo.java



// Defined in message.h
// Targeting ../DescriptorBuilder.java


// Targeting ../FileDescriptorTables.java


// Targeting ../Symbol.java



// Defined in unknown_field_set.h.
// Targeting ../CommandLineInterface.java


// Targeting ../Formatter.java


  // namespace cpp

// Targeting ../DescriptorTest.java



// Targeting ../Printer.java



// Targeting ../SourceLocation.java


// Targeting ../DebugStringOptions.java



// A class to handle the simplest cases of a lazily linked descriptor
// for a message type that isn't built at the time of cross linking,
// which is needed when a pool has lazily_build_dependencies_ set.
// Must be instantiated as mutable in a descriptor.

// The classes in this file represent a significant memory footprint for the
// library. We make sure we are not accidentally making them larger by
// hardcoding the struct size for a specific platform. Use as:
//
//   PROTOBUF_INTERNAL_CHECK_CLASS_SIZE(type, expected_size_in_x84-64);
//

// #if !defined(PROTOBUF_INTERNAL_CHECK_CLASS_SIZE)
// #define PROTOBUF_INTERNAL_CHECK_CLASS_SIZE(t, expected)
// Targeting ../FlatAllocator.java


// Targeting ../LazyDescriptor.java


// Targeting ../SymbolBase.java



// Some types have more than one SymbolBase because they have multiple
// identities in the table. We can't have duplicate direct bases, so we use this
// intermediate base to do so.
// See BuildEnumValue for details.

  // namespace internal

// Describes a type of protocol message, or a particular group within a
// message.  To obtain the Descriptor for a given message object, call
// Message::GetDescriptor().  Generated message classes also have a
// static method called descriptor() which returns the type's descriptor.
// Use DescriptorPool to construct your own descriptors.
// Targeting ../FieldDescriptor.java


// Targeting ../OneofDescriptor.java


// Targeting ../EnumDescriptor.java


// Targeting ../EnumValueDescriptor.java


// Targeting ../ServiceDescriptor.java


// Targeting ../MethodDescriptor.java


// Targeting ../FileDescriptor.java


// Targeting ../DescriptorPool.java




// inline methods ====================================================

// These macros makes this repetitive code more readable.
// #define PROTOBUF_DEFINE_ACCESSOR(CLASS, FIELD, TYPE)
//   inline TYPE CLASS::FIELD() const { return FIELD##_; }

// Strings fields are stored as pointers but returned as const references.
// #define PROTOBUF_DEFINE_STRING_ACCESSOR(CLASS, FIELD)
//   inline const std::string& CLASS::FIELD() const { return *FIELD##_; }

// Name and full name are stored in a single array to save space.
// #define PROTOBUF_DEFINE_NAME_ACCESSOR(CLASS)
//   inline const std::string& CLASS::name() const { return all_names_[0]; }
//   inline const std::string& CLASS::full_name() const { return all_names_[1]; }

// Arrays take an index parameter, obviously.
// #define PROTOBUF_DEFINE_ARRAY_ACCESSOR(CLASS, FIELD, TYPE)
//   inline TYPE CLASS::FIELD(int index) const { return FIELD##s_ + index; }

// #define PROTOBUF_DEFINE_OPTIONS_ACCESSOR(CLASS, TYPE)
//   inline const TYPE& CLASS::options() const { return *options_; }


  



























  

















  






  











  





  






  























// #undef PROTOBUF_DEFINE_ACCESSOR
// #undef PROTOBUF_DEFINE_STRING_ACCESSOR
// #undef PROTOBUF_DEFINE_ARRAY_ACCESSOR

// A few accessors differ from the macros...









// Can't use PROTOBUF_DEFINE_ARRAY_ACCESSOR because reserved_names_ is actually
// an array of pointers rather than the usual array of objects.






// Can't use PROTOBUF_DEFINE_ARRAY_ACCESSOR because reserved_names_ is actually
// an array of pointers rather than the usual array of objects.


































// To save space, index() is computed by looking at the descriptor's position
// in the parent's array of children.










































  // namespace protobuf
  // namespace google

// #undef PROTOBUF_INTERNAL_CHECK_CLASS_SIZE
// #include <google/protobuf/port_undef.inc>

// #endif  // GOOGLE_PROTOBUF_DESCRIPTOR_H__


// Parsed from onnx/onnx-data.pb.h

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: onnx/onnx-data.proto

// #ifndef GOOGLE_PROTOBUF_INCLUDED_onnx_2fonnx_2ddata_2eproto
// #define GOOGLE_PROTOBUF_INCLUDED_onnx_2fonnx_2ddata_2eproto

// #include <limits>
// #include <string>

// #include <google/protobuf/port_def.inc>
// #if PROTOBUF_VERSION < 3020000
// #error This file was generated by a newer version of protoc which is
// #error incompatible with your Protocol Buffer headers. Please update
// #error your headers.
// #endif
// #if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
// #error This file was generated by an older version of protoc which is
// #error incompatible with your Protocol Buffer headers. Please
// #error regenerate this file with a newer version of protoc.
// #endif

// #include <google/protobuf/port_undef.inc>
// #include <google/protobuf/io/coded_stream.h>
// #include <google/protobuf/arena.h>
// #include <google/protobuf/arenastring.h>
// #include <google/protobuf/generated_message_util.h>
// #include <google/protobuf/metadata_lite.h>
// #include <google/protobuf/message_lite.h>
// #include <google/protobuf/repeated_field.h>  // IWYU pragma: export
// #include <google/protobuf/extension_set.h>  // IWYU pragma: export
// #include <google/protobuf/generated_enum_util.h>
// #include "onnx/onnx-ml.pb.h"
// @@protoc_insertion_point(includes)
// #include <google/protobuf/port_def.inc>
// #define PROTOBUF_INTERNAL_EXPORT_onnx_2fonnx_2ddata_2eproto ONNX_API
// Targeting ../AnyMetadata.java


  // namespace internal
 /* namespace protobuf */
   /* namespace google */

// Internal implementation detail -- do not use these members.
// Targeting ../MapProtoDefaultTypeInternal.java



// Targeting ../OptionalProtoDefaultTypeInternal.java



// Targeting ../SequenceProtoDefaultTypeInternal.java



  // namespace onnx



 /* namespace protobuf */
   /* namespace google */

/** enum onnx::SequenceProto_DataType */
public static final int
  SequenceProto_DataType_UNDEFINED = 0,
  SequenceProto_DataType_TENSOR = 1,
  SequenceProto_DataType_SPARSE_TENSOR = 2,
  SequenceProto_DataType_SEQUENCE = 3,
  SequenceProto_DataType_MAP = 4,
  SequenceProto_DataType_OPTIONAL = 5;
@Namespace("onnx") public static native @Cast("bool") boolean SequenceProto_DataType_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::SequenceProto_DataType") int SequenceProto_DataType_DataType_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::SequenceProto_DataType") int SequenceProto_DataType_DataType_MAX();
@Namespace("onnx") @MemberGetter public static native int SequenceProto_DataType_DataType_ARRAYSIZE();

@Namespace("onnx") public static native @StdString BytePointer SequenceProto_DataType_Name(@Cast("onnx::SequenceProto_DataType") int value);
@Namespace("onnx") public static native @Cast("bool") boolean SequenceProto_DataType_Parse(
    @StdString BytePointer name, @Cast("onnx::SequenceProto_DataType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean SequenceProto_DataType_Parse(
    @StdString String name, @Cast("onnx::SequenceProto_DataType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean SequenceProto_DataType_Parse(
    @StdString BytePointer name, @Cast("onnx::SequenceProto_DataType*") int[] value);
@Namespace("onnx") public static native @Cast("bool") boolean SequenceProto_DataType_Parse(
    @StdString String name, @Cast("onnx::SequenceProto_DataType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean SequenceProto_DataType_Parse(
    @StdString BytePointer name, @Cast("onnx::SequenceProto_DataType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean SequenceProto_DataType_Parse(
    @StdString String name, @Cast("onnx::SequenceProto_DataType*") int[] value);
/** enum onnx::OptionalProto_DataType */
public static final int
  OptionalProto_DataType_UNDEFINED = 0,
  OptionalProto_DataType_TENSOR = 1,
  OptionalProto_DataType_SPARSE_TENSOR = 2,
  OptionalProto_DataType_SEQUENCE = 3,
  OptionalProto_DataType_MAP = 4,
  OptionalProto_DataType_OPTIONAL = 5;
@Namespace("onnx") public static native @Cast("bool") boolean OptionalProto_DataType_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::OptionalProto_DataType") int OptionalProto_DataType_DataType_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::OptionalProto_DataType") int OptionalProto_DataType_DataType_MAX();
@Namespace("onnx") @MemberGetter public static native int OptionalProto_DataType_DataType_ARRAYSIZE();

@Namespace("onnx") public static native @StdString BytePointer OptionalProto_DataType_Name(@Cast("onnx::OptionalProto_DataType") int value);
@Namespace("onnx") public static native @Cast("bool") boolean OptionalProto_DataType_Parse(
    @StdString BytePointer name, @Cast("onnx::OptionalProto_DataType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean OptionalProto_DataType_Parse(
    @StdString String name, @Cast("onnx::OptionalProto_DataType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean OptionalProto_DataType_Parse(
    @StdString BytePointer name, @Cast("onnx::OptionalProto_DataType*") int[] value);
@Namespace("onnx") public static native @Cast("bool") boolean OptionalProto_DataType_Parse(
    @StdString String name, @Cast("onnx::OptionalProto_DataType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean OptionalProto_DataType_Parse(
    @StdString BytePointer name, @Cast("onnx::OptionalProto_DataType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean OptionalProto_DataType_Parse(
    @StdString String name, @Cast("onnx::OptionalProto_DataType*") int[] value);
// Targeting ../SequenceProto.java


// Targeting ../MapProto.java


// Targeting ../OptionalProto.java


// ===================================================================


// ===================================================================

// #ifdef __GNUC__
//   #pragma GCC diagnostic push
//   #pragma GCC diagnostic ignored "-Wstrict-aliasing"
// #endif  // __GNUC__
// SequenceProto

// optional string name = 1;












// optional int32 elem_type = 2;








// repeated .onnx.TensorProto tensor_values = 3;










// repeated .onnx.SparseTensorProto sparse_tensor_values = 4;










// repeated .onnx.SequenceProto sequence_values = 5;











// repeated .onnx.MapProto map_values = 6;











// repeated .onnx.OptionalProto optional_values = 7;











// -------------------------------------------------------------------

// MapProto

// optional string name = 1;












// optional int32 key_type = 2;








// repeated int64 keys = 3;













// repeated bytes string_keys = 4;



















// optional .onnx.SequenceProto values = 5;












// -------------------------------------------------------------------

// OptionalProto

// optional string name = 1;












// optional int32 elem_type = 2;








// optional .onnx.TensorProto tensor_value = 3;











// optional .onnx.SparseTensorProto sparse_tensor_value = 4;











// optional .onnx.SequenceProto sequence_value = 5;












// optional .onnx.MapProto map_value = 6;












// optional .onnx.OptionalProto optional_value = 7;












// #ifdef __GNUC__
//   #pragma GCC diagnostic pop
// #endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

  // namespace onnx

 /* namespace protobuf */
   /* namespace google */

// @@protoc_insertion_point(global_scope)

// #include <google/protobuf/port_undef.inc>
// #endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_onnx_2fonnx_2ddata_2eproto


// Parsed from onnx/onnx-operators-ml.pb.h

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: onnx/onnx-operators-ml.proto

// #ifndef GOOGLE_PROTOBUF_INCLUDED_onnx_2fonnx_2doperators_2dml_2eproto
// #define GOOGLE_PROTOBUF_INCLUDED_onnx_2fonnx_2doperators_2dml_2eproto

// #include <limits>
// #include <string>

// #include <google/protobuf/port_def.inc>
// #if PROTOBUF_VERSION < 3020000
// #error This file was generated by a newer version of protoc which is
// #error incompatible with your Protocol Buffer headers. Please update
// #error your headers.
// #endif
// #if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
// #error This file was generated by an older version of protoc which is
// #error incompatible with your Protocol Buffer headers. Please
// #error regenerate this file with a newer version of protoc.
// #endif

// #include <google/protobuf/port_undef.inc>
// #include <google/protobuf/io/coded_stream.h>
// #include <google/protobuf/arena.h>
// #include <google/protobuf/arenastring.h>
// #include <google/protobuf/generated_message_util.h>
// #include <google/protobuf/metadata_lite.h>
// #include <google/protobuf/message_lite.h>
// #include <google/protobuf/repeated_field.h>  // IWYU pragma: export
// #include <google/protobuf/extension_set.h>  // IWYU pragma: export
// #include "onnx/onnx-ml.pb.h"
// @@protoc_insertion_point(includes)
// #include <google/protobuf/port_def.inc>
// #define PROTOBUF_INTERNAL_EXPORT_onnx_2fonnx_2doperators_2dml_2eproto ONNX_API
  // namespace internal
 /* namespace protobuf */
   /* namespace google */

// Internal implementation detail -- do not use these members.
// Targeting ../OperatorProtoDefaultTypeInternal.java



// Targeting ../OperatorSetProtoDefaultTypeInternal.java



  // namespace onnx


 /* namespace protobuf */
   /* namespace google */
// Targeting ../OperatorProto.java


// Targeting ../OperatorSetProto.java


// ===================================================================


// ===================================================================

// #ifdef __GNUC__
//   #pragma GCC diagnostic push
//   #pragma GCC diagnostic ignored "-Wstrict-aliasing"
// #endif  // __GNUC__
// OperatorProto

// optional string op_type = 1;












// optional int64 since_version = 2;








// optional .onnx.OperatorStatus status = 3;








// optional string doc_string = 10;












// -------------------------------------------------------------------

// OperatorSetProto

// optional string magic = 1;












// optional int64 ir_version = 2;








// optional string ir_version_prerelease = 3;












// optional string ir_build_metadata = 7;












// optional string domain = 4;












// optional int64 opset_version = 5;








// optional string doc_string = 6;












// repeated .onnx.OperatorProto operator = 8;











// repeated .onnx.FunctionProto functions = 9;










// #ifdef __GNUC__
//   #pragma GCC diagnostic pop
// #endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

  // namespace onnx

// @@protoc_insertion_point(global_scope)

// #include <google/protobuf/port_undef.inc>
// #endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_onnx_2fonnx_2doperators_2dml_2eproto


// Parsed from onnx/onnx-ml.pb.h

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: onnx/onnx-ml.proto

// #ifndef GOOGLE_PROTOBUF_INCLUDED_onnx_2fonnx_2dml_2eproto
// #define GOOGLE_PROTOBUF_INCLUDED_onnx_2fonnx_2dml_2eproto

// #include <limits>
// #include <string>

// #include <google/protobuf/port_def.inc>
// #if PROTOBUF_VERSION < 3020000
// #error This file was generated by a newer version of protoc which is
// #error incompatible with your Protocol Buffer headers. Please update
// #error your headers.
// #endif
// #if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
// #error This file was generated by an older version of protoc which is
// #error incompatible with your Protocol Buffer headers. Please
// #error regenerate this file with a newer version of protoc.
// #endif

// #include <google/protobuf/port_undef.inc>
// #include <google/protobuf/io/coded_stream.h>
// #include <google/protobuf/arena.h>
// #include <google/protobuf/arenastring.h>
// #include <google/protobuf/generated_message_util.h>
// #include <google/protobuf/metadata_lite.h>
// #include <google/protobuf/message_lite.h>
// #include <google/protobuf/repeated_field.h>  // IWYU pragma: export
// #include <google/protobuf/extension_set.h>  // IWYU pragma: export
// #include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
// #include <google/protobuf/port_def.inc>
// #define PROTOBUF_INTERNAL_EXPORT_onnx_2fonnx_2dml_2eproto ONNX_API
  // namespace internal
 /* namespace protobuf */
   /* namespace google */

// Internal implementation detail -- do not use these members.
// Targeting ../AttributeProtoDefaultTypeInternal.java



// Targeting ../FunctionProtoDefaultTypeInternal.java



// Targeting ../GraphProtoDefaultTypeInternal.java



// Targeting ../ModelProtoDefaultTypeInternal.java



// Targeting ../NodeProtoDefaultTypeInternal.java



// Targeting ../OperatorSetIdProtoDefaultTypeInternal.java



// Targeting ../SparseTensorProtoDefaultTypeInternal.java



// Targeting ../StringStringEntryProtoDefaultTypeInternal.java



// Targeting ../TensorAnnotationDefaultTypeInternal.java



// Targeting ../TensorProtoDefaultTypeInternal.java



// Targeting ../TensorProto_SegmentDefaultTypeInternal.java



// Targeting ../TensorShapeProtoDefaultTypeInternal.java



// Targeting ../TensorShapeProto_DimensionDefaultTypeInternal.java



// Targeting ../TrainingInfoProtoDefaultTypeInternal.java



// Targeting ../TypeProtoDefaultTypeInternal.java



// Targeting ../TypeProto_MapDefaultTypeInternal.java



// Targeting ../TypeProto_OpaqueDefaultTypeInternal.java



// Targeting ../TypeProto_OptionalDefaultTypeInternal.java



// Targeting ../TypeProto_SequenceDefaultTypeInternal.java



// Targeting ../TypeProto_SparseTensorDefaultTypeInternal.java



// Targeting ../TypeProto_TensorDefaultTypeInternal.java



// Targeting ../ValueInfoProtoDefaultTypeInternal.java



  // namespace onnx






















 /* namespace protobuf */
   /* namespace google */

/** enum onnx::AttributeProto_AttributeType */
public static final int
  AttributeProto_AttributeType_UNDEFINED = 0,
  AttributeProto_AttributeType_FLOAT = 1,
  AttributeProto_AttributeType_INT = 2,
  AttributeProto_AttributeType_STRING = 3,
  AttributeProto_AttributeType_TENSOR = 4,
  AttributeProto_AttributeType_GRAPH = 5,
  AttributeProto_AttributeType_SPARSE_TENSOR = 11,
  AttributeProto_AttributeType_TYPE_PROTO = 13,
  AttributeProto_AttributeType_FLOATS = 6,
  AttributeProto_AttributeType_INTS = 7,
  AttributeProto_AttributeType_STRINGS = 8,
  AttributeProto_AttributeType_TENSORS = 9,
  AttributeProto_AttributeType_GRAPHS = 10,
  AttributeProto_AttributeType_SPARSE_TENSORS = 12,
  AttributeProto_AttributeType_TYPE_PROTOS = 14;
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::AttributeProto_AttributeType") int AttributeProto_AttributeType_AttributeType_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::AttributeProto_AttributeType") int AttributeProto_AttributeType_AttributeType_MAX();
@Namespace("onnx") @MemberGetter public static native int AttributeProto_AttributeType_AttributeType_ARRAYSIZE();

@Namespace("onnx") public static native @StdString BytePointer AttributeProto_AttributeType_Name(@Cast("onnx::AttributeProto_AttributeType") int value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString BytePointer name, @Cast("onnx::AttributeProto_AttributeType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString String name, @Cast("onnx::AttributeProto_AttributeType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString BytePointer name, @Cast("onnx::AttributeProto_AttributeType*") int[] value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString String name, @Cast("onnx::AttributeProto_AttributeType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString BytePointer name, @Cast("onnx::AttributeProto_AttributeType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean AttributeProto_AttributeType_Parse(
    @StdString String name, @Cast("onnx::AttributeProto_AttributeType*") int[] value);
/** enum onnx::TensorProto_DataType */
public static final int
  TensorProto_DataType_UNDEFINED = 0,
  TensorProto_DataType_FLOAT = 1,
  TensorProto_DataType_UINT8 = 2,
  TensorProto_DataType_INT8 = 3,
  TensorProto_DataType_UINT16 = 4,
  TensorProto_DataType_INT16 = 5,
  TensorProto_DataType_INT32 = 6,
  TensorProto_DataType_INT64 = 7,
  TensorProto_DataType_STRING = 8,
  TensorProto_DataType_BOOL = 9,
  TensorProto_DataType_FLOAT16 = 10,
  TensorProto_DataType_DOUBLE = 11,
  TensorProto_DataType_UINT32 = 12,
  TensorProto_DataType_UINT64 = 13,
  TensorProto_DataType_COMPLEX64 = 14,
  TensorProto_DataType_COMPLEX128 = 15,
  TensorProto_DataType_BFLOAT16 = 16,
  TensorProto_DataType_FLOAT8E4M3FN = 17,
  TensorProto_DataType_FLOAT8E4M3FNUZ = 18,
  TensorProto_DataType_FLOAT8E5M2 = 19,
  TensorProto_DataType_FLOAT8E5M2FNUZ = 20;
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::TensorProto_DataType") int TensorProto_DataType_DataType_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::TensorProto_DataType") int TensorProto_DataType_DataType_MAX();
@Namespace("onnx") @MemberGetter public static native int TensorProto_DataType_DataType_ARRAYSIZE();

@Namespace("onnx") public static native @StdString BytePointer TensorProto_DataType_Name(@Cast("onnx::TensorProto_DataType") int value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString BytePointer name, @Cast("onnx::TensorProto_DataType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString String name, @Cast("onnx::TensorProto_DataType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString BytePointer name, @Cast("onnx::TensorProto_DataType*") int... value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString String name, @Cast("onnx::TensorProto_DataType*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString BytePointer name, @Cast("onnx::TensorProto_DataType*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataType_Parse(
    @StdString String name, @Cast("onnx::TensorProto_DataType*") int... value);
/** enum onnx::TensorProto_DataLocation */
public static final int
  TensorProto_DataLocation_DEFAULT = 0,
  TensorProto_DataLocation_EXTERNAL = 1;
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataLocation_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::TensorProto_DataLocation") int TensorProto_DataLocation_DataLocation_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::TensorProto_DataLocation") int TensorProto_DataLocation_DataLocation_MAX();
@Namespace("onnx") @MemberGetter public static native int TensorProto_DataLocation_DataLocation_ARRAYSIZE();

@Namespace("onnx") public static native @StdString BytePointer TensorProto_DataLocation_Name(@Cast("onnx::TensorProto_DataLocation") int value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataLocation_Parse(
    @StdString BytePointer name, @Cast("onnx::TensorProto_DataLocation*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataLocation_Parse(
    @StdString String name, @Cast("onnx::TensorProto_DataLocation*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataLocation_Parse(
    @StdString BytePointer name, @Cast("onnx::TensorProto_DataLocation*") int[] value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataLocation_Parse(
    @StdString String name, @Cast("onnx::TensorProto_DataLocation*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataLocation_Parse(
    @StdString BytePointer name, @Cast("onnx::TensorProto_DataLocation*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean TensorProto_DataLocation_Parse(
    @StdString String name, @Cast("onnx::TensorProto_DataLocation*") int[] value);
/** enum onnx::Version */
public static final int
  _START_VERSION = 0,
  IR_VERSION_2017_10_10 = 1,
  IR_VERSION_2017_10_30 = 2,
  IR_VERSION_2017_11_3 = 3,
  IR_VERSION_2019_1_22 = 4,
  IR_VERSION_2019_3_18 = 5,
  IR_VERSION_2019_9_19 = 6,
  IR_VERSION_2020_5_8 = 7,
  IR_VERSION_2021_7_30 = 8,
  IR_VERSION = 9;
@Namespace("onnx") public static native @Cast("bool") boolean Version_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::Version") int Version_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::Version") int Version_MAX();
@Namespace("onnx") @MemberGetter public static native int Version_ARRAYSIZE();

@Namespace("onnx") public static native @StdString BytePointer Version_Name(@Cast("onnx::Version") int value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString BytePointer name, @Cast("onnx::Version*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString String name, @Cast("onnx::Version*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString BytePointer name, @Cast("onnx::Version*") int[] value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString String name, @Cast("onnx::Version*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString BytePointer name, @Cast("onnx::Version*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean Version_Parse(
    @StdString String name, @Cast("onnx::Version*") int[] value);
/** enum onnx::OperatorStatus */
public static final int
  EXPERIMENTAL = 0,
  STABLE = 1;
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_IsValid(int value);
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::OperatorStatus") int OperatorStatus_MIN();
@Namespace("onnx") @MemberGetter public static native @Cast("const onnx::OperatorStatus") int OperatorStatus_MAX();
@Namespace("onnx") @MemberGetter public static native int OperatorStatus_ARRAYSIZE();

@Namespace("onnx") public static native @StdString BytePointer OperatorStatus_Name(@Cast("onnx::OperatorStatus") int value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString BytePointer name, @Cast("onnx::OperatorStatus*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString String name, @Cast("onnx::OperatorStatus*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString BytePointer name, @Cast("onnx::OperatorStatus*") int... value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString String name, @Cast("onnx::OperatorStatus*") IntPointer value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString BytePointer name, @Cast("onnx::OperatorStatus*") IntBuffer value);
@Namespace("onnx") public static native @Cast("bool") boolean OperatorStatus_Parse(
    @StdString String name, @Cast("onnx::OperatorStatus*") int... value);
// Targeting ../AttributeProto.java


// Targeting ../ValueInfoProto.java


// Targeting ../NodeProto.java


// Targeting ../TrainingInfoProto.java


// Targeting ../ModelProto.java


// Targeting ../StringStringEntryProto.java


// Targeting ../TensorAnnotation.java


// Targeting ../GraphProto.java


// Targeting ../TensorProto_Segment.java


// Targeting ../TensorProto.java


// Targeting ../SparseTensorProto.java


// Targeting ../Dimension.java


// Targeting ../TensorShapeProto.java


// Targeting ../TypeProto_Tensor.java


// Targeting ../TypeProto_Sequence.java


// Targeting ../TypeProto_Map.java


// Targeting ../TypeProto_Optional.java


// Targeting ../TypeProto_SparseTensor.java


// Targeting ../TypeProto_Opaque.java


// Targeting ../TypeProto.java


// Targeting ../OperatorSetIdProto.java


// Targeting ../FunctionProto.java


// ===================================================================


// ===================================================================

// #ifdef __GNUC__
//   #pragma GCC diagnostic push
//   #pragma GCC diagnostic ignored "-Wstrict-aliasing"
// #endif  // __GNUC__
// AttributeProto

// optional string name = 1;












// optional string ref_attr_name = 21;












// optional string doc_string = 13;












// optional .onnx.AttributeProto.AttributeType type = 20;








// optional float f = 2;








// optional int64 i = 3;








// optional bytes s = 4;












// optional .onnx.TensorProto t = 5;












// optional .onnx.GraphProto g = 6;












// optional .onnx.SparseTensorProto sparse_tensor = 22;












// optional .onnx.TypeProto tp = 14;












// repeated float floats = 7;













// repeated int64 ints = 8;













// repeated bytes strings = 9;



















// repeated .onnx.TensorProto tensors = 10;











// repeated .onnx.GraphProto graphs = 11;











// repeated .onnx.SparseTensorProto sparse_tensors = 23;











// repeated .onnx.TypeProto type_protos = 15;











// -------------------------------------------------------------------

// ValueInfoProto

// optional string name = 1;












// optional .onnx.TypeProto type = 2;












// optional string doc_string = 3;












// -------------------------------------------------------------------

// NodeProto

// repeated string input = 1;



















// repeated string output = 2;



















// optional string name = 3;












// optional string op_type = 4;












// optional string domain = 7;












// repeated .onnx.AttributeProto attribute = 5;











// optional string doc_string = 6;












// -------------------------------------------------------------------

// TrainingInfoProto

// optional .onnx.GraphProto initialization = 1;












// optional .onnx.GraphProto algorithm = 2;












// repeated .onnx.StringStringEntryProto initialization_binding = 3;











// repeated .onnx.StringStringEntryProto update_binding = 4;











// -------------------------------------------------------------------

// ModelProto

// optional int64 ir_version = 1;








// repeated .onnx.OperatorSetIdProto opset_import = 8;











// optional string producer_name = 2;












// optional string producer_version = 3;












// optional string domain = 4;












// optional int64 model_version = 5;








// optional string doc_string = 6;












// optional .onnx.GraphProto graph = 7;












// repeated .onnx.StringStringEntryProto metadata_props = 14;











// repeated .onnx.TrainingInfoProto training_info = 20;











// repeated .onnx.FunctionProto functions = 25;











// -------------------------------------------------------------------

// StringStringEntryProto

// optional string key = 1;












// optional string value = 2;












// -------------------------------------------------------------------

// TensorAnnotation

// optional string tensor_name = 1;












// repeated .onnx.StringStringEntryProto quant_parameter_tensor_names = 2;











// -------------------------------------------------------------------

// GraphProto

// repeated .onnx.NodeProto node = 1;











// optional string name = 2;












// repeated .onnx.TensorProto initializer = 5;











// repeated .onnx.SparseTensorProto sparse_initializer = 15;











// optional string doc_string = 10;












// repeated .onnx.ValueInfoProto input = 11;











// repeated .onnx.ValueInfoProto output = 12;











// repeated .onnx.ValueInfoProto value_info = 13;











// repeated .onnx.TensorAnnotation quantization_annotation = 14;











// -------------------------------------------------------------------

// TensorProto_Segment

// optional int64 begin = 1;








// optional int64 end = 2;








// -------------------------------------------------------------------

// TensorProto

// repeated int64 dims = 1;













// optional int32 data_type = 2;








// optional .onnx.TensorProto.Segment segment = 3;












// repeated float float_data = 4 [packed = true];













// repeated int32 int32_data = 5 [packed = true];













// repeated bytes string_data = 6;



















// repeated int64 int64_data = 7 [packed = true];













// optional string name = 8;












// optional string doc_string = 12;












// optional bytes raw_data = 9;












// repeated .onnx.StringStringEntryProto external_data = 13;











// optional .onnx.TensorProto.DataLocation data_location = 14;








// repeated double double_data = 10 [packed = true];













// repeated uint64 uint64_data = 11 [packed = true];













// -------------------------------------------------------------------

// SparseTensorProto

// optional .onnx.TensorProto values = 1;












// optional .onnx.TensorProto indices = 2;












// repeated int64 dims = 3;













// -------------------------------------------------------------------

// TensorShapeProto_Dimension

// int64 dim_value = 1;









// string dim_param = 2;













// optional string denotation = 3;















// -------------------------------------------------------------------

// TensorShapeProto

// repeated .onnx.TensorShapeProto.Dimension dim = 1;











// -------------------------------------------------------------------

// TypeProto_Tensor

// optional int32 elem_type = 1;








// optional .onnx.TensorShapeProto shape = 2;












// -------------------------------------------------------------------

// TypeProto_Sequence

// optional .onnx.TypeProto elem_type = 1;












// -------------------------------------------------------------------

// TypeProto_Map

// optional int32 key_type = 1;








// optional .onnx.TypeProto value_type = 2;












// -------------------------------------------------------------------

// TypeProto_Optional

// optional .onnx.TypeProto elem_type = 1;












// -------------------------------------------------------------------

// TypeProto_SparseTensor

// optional int32 elem_type = 1;








// optional .onnx.TensorShapeProto shape = 2;












// -------------------------------------------------------------------

// TypeProto_Opaque

// optional string domain = 1;












// optional string name = 2;












// -------------------------------------------------------------------

// TypeProto

// .onnx.TypeProto.Tensor tensor_type = 1;












// .onnx.TypeProto.Sequence sequence_type = 4;












// .onnx.TypeProto.Map map_type = 5;












// .onnx.TypeProto.Optional optional_type = 9;












// .onnx.TypeProto.SparseTensor sparse_tensor_type = 8;












// .onnx.TypeProto.Opaque opaque_type = 7;












// optional string denotation = 6;















// -------------------------------------------------------------------

// OperatorSetIdProto

// optional string domain = 1;












// optional int64 version = 2;








// -------------------------------------------------------------------

// FunctionProto

// optional string name = 1;












// repeated string input = 4;



















// repeated string output = 5;



















// repeated string attribute = 6;



















// repeated .onnx.AttributeProto attribute_proto = 11;











// repeated .onnx.NodeProto node = 7;











// optional string doc_string = 8;












// repeated .onnx.OperatorSetIdProto opset_import = 9;











// optional string domain = 10;












// #ifdef __GNUC__
//   #pragma GCC diagnostic pop
// #endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

  // namespace onnx

 /* namespace protobuf */
   /* namespace google */

// @@protoc_insertion_point(global_scope)

// #include <google/protobuf/port_undef.inc>
// #endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_onnx_2fonnx_2dml_2eproto


// Parsed from onnx/proto_utils.h

// Copyright (c) ONNX Project Contributors
//
// SPDX-License-Identifier: Apache-2.0

// #pragma once

// #include <google/protobuf/io/coded_stream.h>
// #include <google/protobuf/io/zero_copy_stream_impl_lite.h>

// #include <string>
// #include <vector>

// #include "onnx/onnx_pb.h"

// #ifdef ONNX_USE_LITE_PROTO
// #include <google/protobuf/message_lite.h>
// #else // ONNX_USE_LITE_PROTO
// #include <google/protobuf/message.h>
// #endif // !ONNX_USE_LITE_PROTO

// #ifdef ONNX_USE_LITE_PROTO
@Namespace("onnx") public static native @StdString BytePointer ProtoDebugString(@Const @ByRef MessageLite proto);
// #else
// #endif

@Namespace("onnx") public static native @Cast("bool") @Name("ParseProtoFromBytes<google::protobuf::MessageLite>") boolean ParseProtoFromBytes(MessageLite proto, @Cast("const char*") BytePointer buffer, @Cast("size_t") long length);
@Namespace("onnx") public static native @Cast("bool") @Name("ParseProtoFromBytes<google::protobuf::MessageLite>") boolean ParseProtoFromBytes(MessageLite proto, String buffer, @Cast("size_t") long length);

@Namespace("onnx") public static native @ByVal @Name("RetrieveValues<float>") FloatVector RetrieveValuesFloat(@Const @ByRef AttributeProto attr);

@Namespace("onnx") public static native @ByVal @Name("RetrieveValues<int64_t>") LongVector RetrieveValuesLong(@Const @ByRef AttributeProto attr);

@Namespace("onnx") public static native @ByVal @Name("RetrieveValues<std::string>") StringVector RetrieveValuesString(@Const @ByRef AttributeProto attr);
@Namespace("onnx") public static native @ByVal LongVector RetrieveValues(@Const @ByRef AttributeProto attr);

 // namespace ONNX_NAMESPACE


// Parsed from onnx/defs/function.h

/*
 * SPDX-License-Identifier: Apache-2.0
 */

// #pragma once

// #include <mutex>
// #include <string>
// #include <unordered_map>
// #include <utility>
// #include <vector>

// #include "attr_proto_util.h"
// #include "onnx/common/constants.h"
// #include "onnx/common/status.h"
// #include "onnx/defs/parser.h"
// #include "onnx/defs/schema.h"
// #include "tensor_proto_util.h"
// Helper function to expand a function node given the function proto
@Namespace("onnx") public static native void FunctionExpandHelper(
    @Const @ByRef NodeProto node,
    @Const @ByRef FunctionProto func,
    @ByRef GraphProto g,
    @StdString BytePointer node_prefix/*=""*/);
@Namespace("onnx") public static native void FunctionExpandHelper(
    @Const @ByRef NodeProto node,
    @Const @ByRef FunctionProto func,
    @ByRef GraphProto g);
@Namespace("onnx") public static native void FunctionExpandHelper(
    @Const @ByRef NodeProto node,
    @Const @ByRef FunctionProto func,
    @ByRef GraphProto g,
    @StdString String node_prefix/*=""*/);
// Targeting ../FunctionBodyHelper.java


// Targeting ../FunctionBuilder.java



 // namespace ONNX_NAMESPACE


// Parsed from onnx/checker.h

// Copyright (c) ONNX Project Contributors
//
// SPDX-License-Identifier: Apache-2.0

// #pragma once

// #include <stdexcept>
// #include <string>
// #include <unordered_map>
// #include <unordered_set>
// #include <utility>

// #include "onnx/defs/function.h"
// #include "onnx/defs/schema.h"
// #include "onnx/onnx-data_pb.h"
// #include "onnx/onnx-operators_pb.h"
// #include "onnx/onnx_pb.h"
// #include "onnx/string_utils.h"
// Targeting ../ValidationError.java



// #define fail_check(...)
//   ONNX_THROW_EX(ONNX_NAMESPACE::checker::ValidationError(ONNX_NAMESPACE::MakeString(__VA_ARGS__)));
// Targeting ../CheckerContext.java


// Targeting ../LexicalScopeContext.java


@Namespace("onnx::checker") public static native void check_value_info(@Const @ByRef ValueInfoProto value_info, @Const @ByRef CheckerContext arg1);
@Namespace("onnx::checker") public static native void check_tensor(@Const @ByRef TensorProto tensor, @Const @ByRef CheckerContext arg1);
@Namespace("onnx::checker") public static native void check_sparse_tensor(@Const @ByRef SparseTensorProto sparse_tensor, @Const @ByRef CheckerContext arg1);
@Namespace("onnx::checker") public static native void check_sequence(@Const @ByRef SequenceProto sequence, @Const @ByRef CheckerContext arg1);
@Namespace("onnx::checker") public static native void check_map(@Const @ByRef MapProto map, @Const @ByRef CheckerContext arg1);
@Namespace("onnx::checker") public static native void check_optional(@Const @ByRef OptionalProto opt, @Const @ByRef CheckerContext arg1);
@Namespace("onnx::checker") public static native void check_attribute(@Const @ByRef AttributeProto attr, @Const @ByRef CheckerContext arg1, @Const @ByRef LexicalScopeContext arg2);
@Namespace("onnx::checker") public static native void check_node(@Const @ByRef NodeProto node, @Const @ByRef CheckerContext arg1, @Const @ByRef LexicalScopeContext arg2);
@Namespace("onnx::checker") public static native void check_graph(@Const @ByRef GraphProto graph, @Const @ByRef CheckerContext arg1, @Const @ByRef LexicalScopeContext arg2);
@Namespace("onnx::checker") public static native void check_function(@Const @ByRef FunctionProto function, @Const @ByRef CheckerContext arg1, @Const @ByRef LexicalScopeContext arg2);

// Check schema compatibility for 2 opset versions for a given node.
// Checks whether the schema for 2 versions is same, this is true when the opschema
// does not change between versions.
@Namespace("onnx::checker") public static native void check_opset_compatibility(
    @Const @ByRef NodeProto node,
    @Const @ByRef CheckerContext ctx,
    @Const @ByRef StringIntMap func_opset_imports,
    @Const @ByRef StringIntMap model_opset_imports);

// Checks all model local functions present in ModelProto
@Namespace("onnx::checker") public static native void check_model_local_functions(
    @Const @ByRef ModelProto model,
    @Const @ByRef CheckerContext ctx,
    @Const @ByRef LexicalScopeContext parent_lex);

@Namespace("onnx::checker") public static native void check_model(@Const @ByRef ModelProto model, @Cast("bool") boolean full_check/*=false*/, @Cast("bool") boolean skip_opset_compatibility_check/*=false*/);
@Namespace("onnx::checker") public static native void check_model(@Const @ByRef ModelProto model);
@Namespace("onnx::checker") public static native void check_model(@StdString BytePointer model_path, @Cast("bool") boolean full_check/*=false*/, @Cast("bool") boolean skip_opset_compatibility_check/*=false*/);
@Namespace("onnx::checker") public static native void check_model(@StdString BytePointer model_path);
@Namespace("onnx::checker") public static native void check_model(@StdString String model_path, @Cast("bool") boolean full_check/*=false*/, @Cast("bool") boolean skip_opset_compatibility_check/*=false*/);
@Namespace("onnx::checker") public static native void check_model(@StdString String model_path);

@Namespace("onnx::checker") public static native @Cast("bool") boolean check_is_experimental_op(@Const @ByRef NodeProto node);

 // namespace checker
 // namespace ONNX_NAMESPACE


// Parsed from onnx/shape_inference/implementation.h

// Copyright (c) ONNX Project Contributors
//
// SPDX-License-Identifier: Apache-2.0

// #pragma once

// #include <map>
// #include <memory>
// #include <string>
// #include <unordered_map>
// #include <unordered_set>
// #include <utility>
// #include <vector>

// #include "onnx/defs/function.h"
// #include "onnx/defs/schema.h"
// #include "onnx/proto_utils.h"
// #include "onnx/string_utils.h"

// We reuse TensorShapeProto to propagate statically known (partial) information about
// the values of tensors. It is intended for tensors used to store shape information
// (the return values of ops like Shape and input values of ops like Reshape/Expand).

// A DataValueMap is used to store the statically known (partial) values of variables.
// Targeting ../SymbolTableImpl.java


// Targeting ../DataPropagationContextImpl.java





@Namespace("onnx::shape_inference") public static native void checkShapesAndTypes(@Const @ByRef TypeProto inferredType, @Const @ByRef TypeProto existingType);

@Namespace("onnx::shape_inference") public static native void MaterializeSymbolicShape(TypeProto inferredType, @ByRef SymbolTable symbolTable);

@Namespace("onnx::shape_inference") public static native void mergeShapesAndTypes(@Const @ByRef TypeProto_Tensor inferredType, TypeProto_Tensor existingType);

@Namespace("onnx::shape_inference") public static native void mergeShapesAndTypes(@Const @ByRef TypeProto_SparseTensor inferredType, TypeProto_SparseTensor existingType);





///
///
@Namespace("onnx::shape_inference") public static native void mergeShapesAndTypes(@Const @ByRef TypeProto inferredType, TypeProto existingType);

/**
 *  ModelLocalFunctionsMap is a map of function id -> model local function proto
 *  All the ONNX helper utilities expect the function id == <function_proto.domain>:<function_proto.name>
 *  */
@Namespace("onnx::shape_inference") public static native void InferShapes(
    GraphProto g,
    @Const @ByRef StringIntMap opset_imports,
    @Const ISchemaRegistry schema_registry/*=onnx::OpSchemaRegistry::Instance()*/,
    @Const @ByRef(nullValue = "onnx::ShapeInferenceOptions{}") ShapeInferenceOptions options,
    @Cast("const onnx::shape_inference::ModelLocalFunctionsMap*") @ByRef(nullValue = "onnx::shape_inference::ModelLocalFunctionsMap{}") SizeTStringMap in_model_functions);
@Namespace("onnx::shape_inference") public static native void InferShapes(
    GraphProto g,
    @Const @ByRef StringIntMap opset_imports);

@Namespace("onnx::shape_inference") public static native void InferShapes(
    @ByRef ModelProto m,
    @Const ISchemaRegistry schema_registry/*=onnx::OpSchemaRegistry::Instance()*/,
    @Const @ByRef(nullValue = "onnx::ShapeInferenceOptions{}") ShapeInferenceOptions options,
    @Cast("onnx::shape_inference::DataValueMap*") StringTensorShapeProtoMap generated_shape_data_by_name/*=nullptr*/);
@Namespace("onnx::shape_inference") public static native void InferShapes(
    @ByRef ModelProto m);



///
///
@Namespace("onnx::shape_inference") public static native void InferShapes(
    @StdString BytePointer model_path,
    @StdString BytePointer save_path/*=""*/,
    @Const ISchemaRegistry schema_registry/*=onnx::OpSchemaRegistry::Instance()*/,
    @Const @ByRef(nullValue = "onnx::ShapeInferenceOptions{}") ShapeInferenceOptions options,
    @Cast("onnx::shape_inference::DataValueMap*") StringTensorShapeProtoMap generated_shape_data_by_name/*=nullptr*/);
@Namespace("onnx::shape_inference") public static native void InferShapes(
    @StdString BytePointer model_path);
@Namespace("onnx::shape_inference") public static native void InferShapes(
    @StdString String model_path,
    @StdString String save_path/*=""*/,
    @Const ISchemaRegistry schema_registry/*=onnx::OpSchemaRegistry::Instance()*/,
    @Const @ByRef(nullValue = "onnx::ShapeInferenceOptions{}") ShapeInferenceOptions options,
    @Cast("onnx::shape_inference::DataValueMap*") StringTensorShapeProtoMap generated_shape_data_by_name/*=nullptr*/);
@Namespace("onnx::shape_inference") public static native void InferShapes(
    @StdString String model_path);

/**
 *  ModelLocalFunctionsMap is a map of function id -> model local function proto
 *  All the ONNX helper utilities expect the function id == <function_proto.domain>:<function_proto.name>
 *  */


///
///
@Namespace("onnx::shape_inference") public static native void InferShapeForFunctionNode(
    @Const @ByRef FunctionProto func,
    @Const ISchemaRegistry schema_registry,
    @ByRef InferenceContext ctx,
    @Const @ByRef(nullValue = "onnx::ShapeInferenceOptions{}") ShapeInferenceOptions options,
    @Cast("const onnx::shape_inference::ModelLocalFunctionsMap*") @ByRef(nullValue = "onnx::shape_inference::ModelLocalFunctionsMap{}") SizeTStringMap model_local_functions_map,
    SymbolTable symbolTable/*=nullptr*/,
    @Cast("onnx::shape_inference::DataValueMap*") StringTensorShapeProtoMap generated_shape_data_by_name/*=nullptr*/);
@Namespace("onnx::shape_inference") public static native void InferShapeForFunctionNode(
    @Const @ByRef FunctionProto func,
    @Const ISchemaRegistry schema_registry,
    @ByRef InferenceContext ctx);

/**
 *  ModelLocalFunctionsMap is a map of function id -> model local function proto
 *  All the ONNX helper utilities expect the function id == <function_proto.domain>:<function_proto.name>
 *  */


///
///
@Namespace("onnx::shape_inference") public static native void InferShapeForFunctionNode(
    @Const @ByRef FunctionProto func_proto,
    @Const @ByRef StringIntMap func_opset_imports,
    @Const ISchemaRegistry schema_registry,
    @ByRef InferenceContext ctx,
    @Const @ByRef(nullValue = "onnx::ShapeInferenceOptions{}") ShapeInferenceOptions options,
    @Cast("const onnx::shape_inference::ModelLocalFunctionsMap*") @ByRef(nullValue = "onnx::shape_inference::ModelLocalFunctionsMap{}") SizeTStringMap model_local_functions_map,
    SymbolTable symbolTable/*=nullptr*/,
    @Cast("onnx::shape_inference::DataValueMap*") StringTensorShapeProtoMap generated_shape_data_by_name/*=nullptr*/);
@Namespace("onnx::shape_inference") public static native void InferShapeForFunctionNode(
    @Const @ByRef FunctionProto func_proto,
    @Const @ByRef StringIntMap func_opset_imports,
    @Const ISchemaRegistry schema_registry,
    @ByRef InferenceContext ctx);

/**
 *  Apply type-and-shape-inference based checks to a Function body.
 *  Returns the inferred types of the outputs of the function.
 *  Inference depends on the types of the inputs of the function as well as
 *  the attribute values supplied.
 *  A TypeProto with value_case() == TypeProto::ValueCase::VALUE_NOT_SET is used
 *  for missing optional parameters.
 *  */
@Namespace("onnx::shape_inference") public static native @StdVector TypeProto InferFunctionOutputTypes(
    @Const @ByRef FunctionProto func_proto,
    @StdVector TypeProto input_types,
    @StdVector AttributeProto attributes);

@Namespace("onnx::shape_inference") public static native @StdString BytePointer GetErrorWithNodeInfo(@Const @ByRef NodeProto n, @Cast("const std::runtime_error*") @ByRef Pointer err);

@Namespace("onnx::shape_inference") public static native void TraverseGraphsToAddExistingSymbols(@Const @ByRef GraphProto g, @ByRef SymbolTable symbolTable);

 // namespace shape_inference
 // namespace ONNX_NAMESPACE


// Parsed from onnx/common/tensor.h

// Copyright (c) ONNX Project Contributors

/*
 * SPDX-License-Identifier: Apache-2.0
 */

// ATTENTION: The code in this file is highly EXPERIMENTAL.
// Adventurous users should note that the APIs will probably change.

// #pragma once

// #include <cmath>
// #include <functional>
// #include <numeric>
// #include <string>
// #include <utility>
// #include <vector>

// #include "onnx/common/assertions.h"
// #include "onnx/onnx_pb.h"
// #include "onnx/string_utils.h"
// Targeting ../Tensor.java






// #define define_data(type, field)
//   template <>
//   inline type* Tensor::data<type>() {
//     if (is_raw_data_) {
//       return (type*)const_cast<char*>(&raw_data_.data()[0]);
//     } else {
//       return field.data();
//     }
//   }
// 
//   template <>
//   inline const type* Tensor::data<type>() const {
//     if (is_raw_data_) {
//       return (const type*)(raw_data_.data());
//     } else {
//       return field.data();
//     }
//   }



  


  


  


  


  
// #undef define_data

 // namespace ONNX_NAMESPACE


// Parsed from onnx/common/array_ref.h

// Copyright (c) ONNX Project Contributors

/*
 * SPDX-License-Identifier: Apache-2.0
 */

// ATTENTION: The code in this file is highly EXPERIMENTAL.
// Adventurous users should note that the APIs will probably change.

//===--- ArrayRef.h - Array Reference Wrapper -------------------*- C++ -*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

// ONNX: modified from llvm::ArrayRef.
// removed llvm-specific functionality
// removed some implicit const -> non-const conversions that rely on
// complicated std::enable_if meta-programming
// removed a bunch of slice variants for simplicity...

// #pragma once
// #include <assert.h>

// #include <array>
// #include <vector>
/** ArrayRef - Represent a constant reference to an array (0 or more elements
 *  consecutively in memory), i.e. a start pointer and a length.  It allows
 *  various APIs to take consecutive elements easily and conveniently.
 * 
 *  This class does not own the underlying data, it is expected to be used in
 *  situations where the data resides in some other buffer, whose lifetime
 *  extends past that of the ArrayRef. For this reason, it is not in general
 *  safe to store an ArrayRef.
 * 
 *  This is intended to be trivially copyable, so it should be passed by
 *  value. */

 // namespace ONNX_NAMESPACE


// Parsed from onnx/common/status.h

// Copyright (c) ONNX Project Contributors

/*
 * SPDX-License-Identifier: Apache-2.0
 */

// #pragma once

// #include <memory>
// #include <ostream>
// #include <string>
// #include <utility>

/** enum onnx::Common::StatusCategory */
public static final int
  NONE = 0,
  CHECKER = 1,
  OPTIMIZER = 2;

/** enum onnx::Common::StatusCode */
public static final int
  OK = 0,
  FAIL = 1,
  INVALID_ARGUMENT = 2,
  INVALID_PROTOBUF = 3;
// Targeting ../Status.java



@Namespace("onnx::Common") public static native @Cast("std::ostream*") @ByRef @Name("operator <<") Pointer shiftLeft(@Cast("std::ostream*") @ByRef Pointer out, @Const @ByRef Status status);

 // namespace Common
 // namespace ONNX_NAMESPACE


// Parsed from onnx/common/ir.h

// Copyright (c) ONNX Project Contributors

/*
 * SPDX-License-Identifier: Apache-2.0
 */

// ATTENTION: The code in this file is highly EXPERIMENTAL.
// Adventurous users should note that the APIs will probably change.

// #pragma once

// #include <stdint.h>

// #include <algorithm>
// #include <atomic>
// #include <cstdint>
// #include <functional>
// #include <iostream>
// #include <limits>
// #include <memory>
// #include <set>
// #include <sstream>
// #include <string>
// #include <unordered_set>
// #include <utility>
// #include <vector>

// #include "onnx/common/array_ref.h"
// #include "onnx/common/assertions.h"
// #include "onnx/common/common.h"
// #include "onnx/common/graph_node_list.h"
// #include "onnx/common/interned_strings.h"
// #include "onnx/common/tensor.h"
// #include "onnx/string_utils.h"

// #define ONNX_DISALLOW_COPY_AND_ASSIGN(TypeName)
//   TypeName(const TypeName&) = delete;
//   TypeName& operator=(const TypeName&) = delete

// Graph represents one "function" of computation.
// It uses a simple ownership model where the graph owns all the nodes inside it.
// All references inside the graph are raw pointers.
// Destroying the Graph will invalidate any pointers to nodes in the graph.
// Targeting ../Node.java



// A Value represents an input or output to node that is either a
// Tensor or an opaque Handle object, as determined by type().
// Targeting ../DimensionIR.java



/** enum class onnx::AttributeKind */
public static final byte
  // float, float list, int, int list, string, string list,
  // tensor, tensor list, subgraph, subgraph list. type proto, type proto list
  f = (byte)(0),
  fs = (byte)(1),
  i = (byte)(2),
  is = (byte)(3),
  s = (byte)(4),
  ss = (byte)(5),
  t = (byte)(6),
  ts = (byte)(7),
  g = (byte)(8),
  gs = (byte)(9),
  tp = (byte)(10),
  tps = (byte)(11);


// Targeting ../AttributeValue.java



// CRTP so that Node which inherits Attributes can be return for
// method chaining e.g:
// Node * n = g->create(kSelect)->set_i(kOffset,3)->set_f(kValue,3.5);
// we return Derived* pointers because Nodes are normally held as pointers.
// Targeting ../Use.java



@Namespace("onnx") public static native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef Use a, @Const @ByRef Use b);

// the list types are intentionally simple, but we type-def
// them here so if we need to change them, refactoring will be easier
// Targeting ../Value.java


// Targeting ../OpSetID.java


// Targeting ../Graph.java









// `captured` nodes in subgraph determines which value it captures
// by storing the value's unique name, so old unique names in `captured` nodes
// should also be updated.
// Initializer names are also storaged in graph.initializer_names_, it should be
// updated too.












/************* All nodes not required to be defined before Graph **************/






// Returns a list about which nodes are using this value,
// nodes in subgraph are also included.
// This method is usually used to check whether it is
// safe to delete a Value.


 // namespace ONNX_NAMESPACE


// Parsed from onnx/common/ir_pb_converter.h

// Copyright (c) ONNX Project Contributors

/*
 * SPDX-License-Identifier: Apache-2.0
 */

// ATTENTION: The code in this file is highly EXPERIMENTAL.
// Adventurous users should note that the APIs will probably change.

// #pragma once
// #include <memory>
// #include <string>

// #include "onnx/common/common.h"
// #include "onnx/common/ir.h"
// #include "onnx/onnx_pb.h"
// Targeting ../ConvertError.java



// #define fail_convert(...) ONNX_THROW_EX(ConvertError(MakeString(__VA_ARGS__)));

@Namespace("onnx") public static native void ExportModelProto(ModelProto p_m, @SharedPtr Graph g);

@Namespace("onnx") public static native @UniquePtr Graph ImportModelProto(@Const @ByRef ModelProto mp);

@Namespace("onnx") public static native @ByVal ModelProto PrepareOutput(@Const @ByRef ModelProto mp_in);

@Namespace("onnx") public static native void assertNonNull(@SharedPtr Graph g);
 // namespace ONNX_NAMESPACE


// Parsed from onnx/version_converter/adapters/adapter.h

// Copyright (c) ONNX Project Contributors

/*
 * SPDX-License-Identifier: Apache-2.0
 */

// Interface for Op Version Adapters

// #pragma once

// #include <functional>
// #include <memory>
// #include <string>

// #include "onnx/onnx_pb.h"
// #include "onnx/version_converter/helper.h"
// Targeting ../Adapter.java


// Targeting ../GenericAdapter.java



 // namespace version_conversion
 // namespace ONNX_NAMESPACE


// Parsed from onnx/version_converter/helper.h

// Copyright (c) ONNX Project Contributors
//
// SPDX-License-Identifier: Apache-2.0

// Helper Methods for Adapters

// #pragma once

// #include <vector>

// #include "onnx/common/ir.h"
@Namespace("onnx::version_conversion") public static native int check_numpy_unibroadcastable_and_require_broadcast(
    @StdVector DimensionIR input1_sizes,
    @StdVector DimensionIR input2_sizes);

@Namespace("onnx::version_conversion") public static native void assert_numpy_multibroadcastable(
    @StdVector DimensionIR input1_sizes,
    @StdVector DimensionIR input2_sizes);

@Namespace("onnx::version_conversion") public static native void assertNotParams(@StdVector DimensionIR sizes);
 // namespace version_conversion
 // namespace ONNX_NAMESPACE


// Parsed from onnx/version_converter/BaseConverter.h

// Copyright (c) ONNX Project Contributors

/*
 * SPDX-License-Identifier: Apache-2.0
 */

// Version converter interface for ONNX models between different opset versions.

// #pragma once

// #include <stdlib.h>

// #include <iostream>
// #include <map>
// #include <memory>
// #include <string>
// #include <unordered_map>
// #include <utility>

// #include "onnx/common/ir.h"
// #include "onnx/common/ir_pb_converter.h"
// #include "onnx/defs/schema.h"
// #include "onnx/proto_utils.h"
// #include "onnx/version_converter/adapters/adapter.h"
// Targeting ../BaseVersionConverter.java



 // namespace version_conversion
 // namespace ONNX_NAMESPACE


// Parsed from onnx/version_converter/convert.h

// Copyright (c) ONNX Project Contributors

/*
 * SPDX-License-Identifier: Apache-2.0
 */

// Default converter for ONNX models between different opset versions
// in the default domain ("" or "ai.onnx").

// #pragma once

// #include <map>
// #include <memory>
// #include <string>
// #include <unordered_map>
// #include <utility>
// #include <vector>

// #include "onnx/version_converter/BaseConverter.h"
// #include "onnx/version_converter/adapters/axes_attribute_to_input.h"
// #include "onnx/version_converter/adapters/axes_input_to_attribute.h"
// #include "onnx/version_converter/adapters/axis_attribute_to_input.h"
// #include "onnx/version_converter/adapters/axis_input_to_attribute.h"
// #include "onnx/version_converter/adapters/batch_normalization_13_14.h"
// #include "onnx/version_converter/adapters/broadcast_backward_compatibility.h"
// #include "onnx/version_converter/adapters/broadcast_forward_compatibility.h"
// #include "onnx/version_converter/adapters/cast_9_8.h"
// #include "onnx/version_converter/adapters/clip_10_11.h"
// #include "onnx/version_converter/adapters/compatible.h"
// #include "onnx/version_converter/adapters/dropout_11_12.h"
// #include "onnx/version_converter/adapters/extend_supported_types.h"
// #include "onnx/version_converter/adapters/gemm_6_7.h"
// #include "onnx/version_converter/adapters/gemm_7_6.h"
// #include "onnx/version_converter/adapters/gridsample_19_20.h"
// #include "onnx/version_converter/adapters/maxpool_8_7.h"
// #include "onnx/version_converter/adapters/no_previous_version.h"
// #include "onnx/version_converter/adapters/pad_10_11.h"
// #include "onnx/version_converter/adapters/reshape_4_5.h"
// #include "onnx/version_converter/adapters/reshape_5_4.h"
// #include "onnx/version_converter/adapters/resize_10_11.h"
// #include "onnx/version_converter/adapters/scan_8_9.h"
// #include "onnx/version_converter/adapters/scan_9_8.h"
// #include "onnx/version_converter/adapters/scatter_10_11.h"
// #include "onnx/version_converter/adapters/slice_9_10.h"
// #include "onnx/version_converter/adapters/softmax_12_13.h"
// #include "onnx/version_converter/adapters/split_12_13.h"
// #include "onnx/version_converter/adapters/split_13_12.h"
// #include "onnx/version_converter/adapters/split_17_18.h"
// #include "onnx/version_converter/adapters/sum_8_7.h"
// #include "onnx/version_converter/adapters/topk_9_10.h"
// #include "onnx/version_converter/adapters/transformers.h"
// #include "onnx/version_converter/adapters/type_restriction.h"
// #include "onnx/version_converter/adapters/upsample_6_7.h"
// #include "onnx/version_converter/adapters/upsample_8_9.h"
// #include "onnx/version_converter/adapters/upsample_9_10.h"
// #include "onnx/version_converter/adapters/upsample_9_8.h"
// Targeting ../DefaultVersionConverter.java



@Namespace("onnx::version_conversion") public static native @ByVal ModelProto ConvertVersion(@Const @ByRef ModelProto mp_in, int target_version);
 // namespace version_conversion
 // namespace ONNX_NAMESPACE


}
