// Targeted by JavaCPP version 1.4.1-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class Vimba extends org.bytedeco.javacpp.presets.Vimba {
    static { Loader.load(); }

// Parsed from <VimbaC/Include/VmbCommonTypes.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this header file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------
 
  File:        VmbCommonTypes.h

  Description: Main header file for the common types of the Vimba APIs.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef VMBCOMMONTYPES_H_INCLUDE_
// #define VMBCOMMONTYPES_H_INCLUDE_

// #ifdef __cplusplus
// #endif

// This file describes all necessary definitions for types used within 
// Allied Vision's Vimba APIs. These type definitions are designed to be
// portable from other languages and other operating systems.

// #if defined (_MSC_VER)

    // 8 bit signed integer on Microsoft systems
    // 8 bit unsigned integer on Microsoft systems
    // 16 bit signed integer on Microsoft systems
    // 16 bit unsigned integer on Microsoft systems
    // 32 bit signed integer on Microsoft systems
    // 32 bit unsigned integer on Microsoft systems
    // 64 bit signed integer on Microsoft systems
    // 64 bit unsigned integer on Microsoft systems

// #else // for non MS or GNU compilers without any warranty for the size

    //#pragma message("Compatibility warning: typedefs in " __FILE__ " may not have the correct number of bits")

    // 8 bit signed integer on non-Microsoft systems
    // 8 bit unsigned integer on non-Microsoft systems
    // 16 bit signed integer on non-Microsoft systems
    // 16 bit unsigned integer on non-Microsoft systems
    // 32 bit signed integer on non-Microsoft systems
    // 32 bit signed integer on non-Microsoft systems
    // 64 bit signed integer on non-Microsoft systems
    // 64 bit unsigned integer on non-Microsoft systems

// #endif

    // Handle; e.g. for a camera
    @Namespace @Name("void") @Opaque public static class VmbHandle_t extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public VmbHandle_t() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public VmbHandle_t(Pointer p) { super(p); }
    }

// Standard type for boolean values
// #if defined(__cplusplus) || defined(__bool_true_false_are_defined)
// #else
    // Boolean type (equivalent to char)      // 1 means true and 0 means false
// #endif
    //
    // enum for bool values
    //
    /** enum VmbBoolVal */
    public static final int
        VmbBoolTrue = 1,
        VmbBoolFalse = 0;

    // char type

    //
    // Error codes, returned by most functions: (not yet complete)
    //
    /** enum VmbErrorType */
    public static final int
        VmbErrorSuccess         = 0,           // No error
        VmbErrorInternalFault   = -1,           // Unexpected fault in VimbaC or driver
        VmbErrorApiNotStarted   = -2,           // VmbStartup() was not called before the current command
        VmbErrorNotFound        = -3,           // The designated instance (camera, feature etc.) cannot be found
        VmbErrorBadHandle       = -4,           // The given handle is not valid
        VmbErrorDeviceNotOpen   = -5,           // Device was not opened for usage
        VmbErrorInvalidAccess   = -6,           // Operation is invalid with the current access mode
        VmbErrorBadParameter    = -7,           // One of the parameters is invalid (usually an illegal pointer)
        VmbErrorStructSize      = -8,           // The given struct size is not valid for this version of the API
        VmbErrorMoreData        = -9,           // More data available in a string/list than space is provided
        VmbErrorWrongType       = -10,          // Wrong feature type for this access function 
        VmbErrorInvalidValue    = -11,          // The value is not valid; either out of bounds or not an increment of the minimum
        VmbErrorTimeout         = -12,          // Timeout during wait
        VmbErrorOther           = -13,          // Other error
        VmbErrorResources       = -14,          // Resources not available (e.g. memory)
        VmbErrorInvalidCall     = -15,          // Call is invalid in the current context (e.g. callback)
        VmbErrorNoTL            = -16,          // No transport layers are found 
        VmbErrorNotImplemented  = -17,          // API feature is not implemented
        VmbErrorNotSupported    = -18,          // API feature is not supported
        VmbErrorIncomplete      = -19;          // A multiple registers read or write is partially completed              // Type for an error returned by API methods; for values see VmbErrorType

    //
    // Version information
    //
    public static class VmbVersionInfo_t extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public VmbVersionInfo_t() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public VmbVersionInfo_t(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public VmbVersionInfo_t(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public VmbVersionInfo_t position(long position) {
            return (VmbVersionInfo_t)super.position(position);
        }
    
        public native @Cast("VmbUint32_t") int major(); public native VmbVersionInfo_t major(int major);          // Major version number
        public native @Cast("VmbUint32_t") int minor(); public native VmbVersionInfo_t minor(int minor);          // Minor version number
        public native @Cast("VmbUint32_t") int patch(); public native VmbVersionInfo_t patch(int patch);          // Patch version number

    }

    //
    // Indicate if pixel is monochrome or RGB.
    //
    /** enum VmbPixelType */
    public static final int
        VmbPixelMono  =          0x01000000,     // Monochrome pixel
        VmbPixelColor =          0x02000000;      // Pixel bearing color information

    //
    // Indicate number of bits for a pixel. Needed for building values of VmbPixelFormatType
    //
    /** enum VmbPixelOccupyType */
    public static final int
        VmbPixelOccupy8Bit  =    0x00080000,     // Pixel effectively occupies 8 bits
        VmbPixelOccupy10Bit =    0x000A0000,     // Pixel effectively occupies 10 bits
        VmbPixelOccupy12Bit =    0x000C0000,     // Pixel effectively occupies 12 bits
        VmbPixelOccupy14Bit =    0x000E0000,     // Pixel effectively occupies 14 bits
        VmbPixelOccupy16Bit =    0x00100000,     // Pixel effectively occupies 16 bits
        VmbPixelOccupy24Bit =    0x00180000,     // Pixel effectively occupies 24 bits
        VmbPixelOccupy32Bit =    0x00200000,     // Pixel effectively occupies 32 bits
        VmbPixelOccupy48Bit =    0x00300000,     // Pixel effectively occupies 48 bits
        VmbPixelOccupy64Bit =    0x00400000;     // Pixel effectively occupies 48 bits

    //
    // Pixel format types.
    // As far as possible, the Pixel Format Naming Convention (PFNC) has been followed, allowing a few deviations.
    // If data spans more than one byte, it is always LSB aligned, except if stated differently.
    //
    /** enum VmbPixelFormatType */
    public static final int
        // mono formats
        VmbPixelFormatMono8               =  VmbPixelMono  | VmbPixelOccupy8Bit  | 0x0001,  // Monochrome, 8 bits (PFNC:Mono8)
        VmbPixelFormatMono10              =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0003,  // Monochrome, 10 bits in 16 bits (PFNC:Mono10)
        VmbPixelFormatMono10p             =  VmbPixelMono  | VmbPixelOccupy10Bit | 0x0046,  // Monochrome, 10 bits in 16 bits (PFNC:Mono10p)
        VmbPixelFormatMono12              =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0005,  // Monochrome, 12 bits in 16 bits (PFNC:Mono12)
        VmbPixelFormatMono12Packed        =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x0006,  // Monochrome, 2x12 bits in 24 bits (GEV:Mono12Packed)
        VmbPixelFormatMono12p             =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x0047,  // Monochrome, 2x12 bits in 24 bits (PFNC:MonoPacked)
        VmbPixelFormatMono14              =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0025,  // Monochrome, 14 bits in 16 bits (PFNC:Mono14)
        VmbPixelFormatMono16              =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0007,  // Monochrome, 16 bits (PFNC:Mono16)
        // bayer formats
        VmbPixelFormatBayerGR8            =  VmbPixelMono  | VmbPixelOccupy8Bit  | 0x0008,  // Bayer-color, 8 bits, starting with GR line (PFNC:BayerGR8)
        VmbPixelFormatBayerRG8            =  VmbPixelMono  | VmbPixelOccupy8Bit  | 0x0009,  // Bayer-color, 8 bits, starting with RG line (PFNC:BayerRG8)
        VmbPixelFormatBayerGB8            =  VmbPixelMono  | VmbPixelOccupy8Bit  | 0x000A,  // Bayer-color, 8 bits, starting with GB line (PFNC:BayerGB8)
        VmbPixelFormatBayerBG8            =  VmbPixelMono  | VmbPixelOccupy8Bit  | 0x000B,  // Bayer-color, 8 bits, starting with BG line (PFNC:BayerBG8)
        VmbPixelFormatBayerGR10           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x000C,  // Bayer-color, 10 bits in 16 bits, starting with GR line (PFNC:BayerGR10)
        VmbPixelFormatBayerRG10           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x000D,  // Bayer-color, 10 bits in 16 bits, starting with RG line (PFNC:BayerRG10)
        VmbPixelFormatBayerGB10           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x000E,  // Bayer-color, 10 bits in 16 bits, starting with GB line (PFNC:BayerGB10)
        VmbPixelFormatBayerBG10           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x000F,  // Bayer-color, 10 bits in 16 bits, starting with BG line (PFNC:BayerBG10)
        VmbPixelFormatBayerGR12           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0010,  // Bayer-color, 12 bits in 16 bits, starting with GR line (PFNC:BayerGR12)
        VmbPixelFormatBayerRG12           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0011,  // Bayer-color, 12 bits in 16 bits, starting with RG line (PFNC:BayerRG12)
        VmbPixelFormatBayerGB12           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0012,  // Bayer-color, 12 bits in 16 bits, starting with GB line (PFNC:BayerGB12)
        VmbPixelFormatBayerBG12           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0013,  // Bayer-color, 12 bits in 16 bits, starting with BG line (PFNC:BayerBG12)
        VmbPixelFormatBayerGR12Packed     =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x002A,  // Bayer-color, 2x12 bits in 24 bits, starting with GR line (GEV:BayerGR12Packed)
        VmbPixelFormatBayerRG12Packed     =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x002B,  // Bayer-color, 2x12 bits in 24 bits, starting with RG line (GEV:BayerRG12Packed)
        VmbPixelFormatBayerGB12Packed     =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x002C,  // Bayer-color, 2x12 bits in 24 bits, starting with GB line (GEV:BayerGB12Packed)
        VmbPixelFormatBayerBG12Packed     =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x002D,  // Bayer-color, 2x12 bits in 24 bits, starting with BG line (GEV:BayerBG12Packed)
        VmbPixelFormatBayerGR10p          =  VmbPixelMono  | VmbPixelOccupy10Bit | 0x0056,  // Bayer-color, 12 bits continuous packed, starting with GR line (PFNC:BayerGR10p)
        VmbPixelFormatBayerRG10p          =  VmbPixelMono  | VmbPixelOccupy10Bit | 0x0058,  // Bayer-color, 12 bits continuous packed, starting with RG line (PFNC:BayerRG10p)
        VmbPixelFormatBayerGB10p          =  VmbPixelMono  | VmbPixelOccupy10Bit | 0x0054,  // Bayer-color, 12 bits continuous packed, starting with GB line (PFNC:BayerGB10p)
        VmbPixelFormatBayerBG10p          =  VmbPixelMono  | VmbPixelOccupy10Bit | 0x0052,  // Bayer-color, 12 bits continuous packed, starting with BG line (PFNC:BayerBG10p)
        VmbPixelFormatBayerGR12p          =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x0057,  // Bayer-color, 12 bits continuous packed, starting with GR line (PFNC:BayerGR12p)
        VmbPixelFormatBayerRG12p          =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x0059,  // Bayer-color, 12 bits continuous packed, starting with RG line (PFNC:BayerRG12p)
        VmbPixelFormatBayerGB12p          =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x0055,  // Bayer-color, 12 bits continuous packed, starting with GB line (PFNC:BayerGB12p)
        VmbPixelFormatBayerBG12p          =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x0053,  // Bayer-color, 12 bits continuous packed, starting with BG line (PFNC:BayerBG12p)
        VmbPixelFormatBayerGR16           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x002E,  // Bayer-color, 16 bits, starting with GR line (PFNC:BayerGR16)
        VmbPixelFormatBayerRG16           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x002F,  // Bayer-color, 16 bits, starting with RG line (PFNC:BayerRG16)
        VmbPixelFormatBayerGB16           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0030,  // Bayer-color, 16 bits, starting with GB line (PFNC:BayerGB16)
        VmbPixelFormatBayerBG16           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0031,  // Bayer-color, 16 bits, starting with BG line (PFNC:BayerBG16)
        // rgb formats
        VmbPixelFormatRgb8                =  VmbPixelColor | VmbPixelOccupy24Bit | 0x0014,  // RGB, 8 bits x 3 (PFNC:RGB8)
        VmbPixelFormatBgr8                =  VmbPixelColor | VmbPixelOccupy24Bit | 0x0015,  // BGR, 8 bits x 3 (PFNC:BGR8)
        VmbPixelFormatRgb10               =  VmbPixelColor | VmbPixelOccupy48Bit | 0x0018,  // RGB, 12 bits in 16 bits x 3 (PFNC:RGB12)
        VmbPixelFormatBgr10               =  VmbPixelColor | VmbPixelOccupy48Bit | 0x0019,  // RGB, 12 bits in 16 bits x 3 (PFNC:RGB12)
        VmbPixelFormatRgb12               =  VmbPixelColor | VmbPixelOccupy48Bit | 0x001A,  // RGB, 12 bits in 16 bits x 3 (PFNC:RGB12)
        VmbPixelFormatBgr12               =  VmbPixelColor | VmbPixelOccupy48Bit | 0x001B,  // RGB, 12 bits in 16 bits x 3 (PFNC:RGB12)

        VmbPixelFormatRgb14               =  VmbPixelColor | VmbPixelOccupy48Bit | 0x005E,  // RGB, 14 bits in 16 bits x 3 (PFNC:RGB12)
        VmbPixelFormatBgr14               =  VmbPixelColor | VmbPixelOccupy48Bit | 0x004A,  // RGB, 14 bits in 16 bits x 3 (PFNC:RGB12)

        VmbPixelFormatRgb16               =  VmbPixelColor | VmbPixelOccupy48Bit | 0x0033,  // RGB, 16 bits x 3 (PFNC:RGB16)
        VmbPixelFormatBgr16               =  VmbPixelColor | VmbPixelOccupy48Bit | 0x004B,  // RGB, 16 bits x 3 (PFNC:RGB16)
        // rgba formats
        VmbPixelFormatArgb8               =  VmbPixelColor | VmbPixelOccupy32Bit | 0x0016,  // ARGB, 8 bits x 4 (PFNC:RGBa8)
        VmbPixelFormatRgba8               =  VmbPixelFormatArgb8,                           // RGBA, 8 bits x 4, legacy name
        VmbPixelFormatBgra8               =  VmbPixelColor | VmbPixelOccupy32Bit | 0x0017,  // BGRA, 8 bits x 4 (PFNC:BGRa8)
        VmbPixelFormatRgba10              =  VmbPixelColor | VmbPixelOccupy64Bit | 0x005F,                           // RGBA, 8 bits x 4, legacy name
        VmbPixelFormatBgra10              =  VmbPixelColor | VmbPixelOccupy64Bit | 0x004C,                           // RGBA, 8 bits x 4, legacy name
        VmbPixelFormatRgba12              =  VmbPixelColor | VmbPixelOccupy64Bit | 0x0061,                           // RGBA, 8 bits x 4, legacy name
        VmbPixelFormatBgra12              =  VmbPixelColor | VmbPixelOccupy64Bit | 0x004E,                           // RGBA, 8 bits x 4, legacy name

        VmbPixelFormatRgba14              =  VmbPixelColor | VmbPixelOccupy64Bit | 0x0063,                           // RGBA, 8 bits x 4, legacy name
        VmbPixelFormatBgra14              =  VmbPixelColor | VmbPixelOccupy64Bit | 0x0050,                           // RGBA, 8 bits x 4, legacy name

        VmbPixelFormatRgba16              =  VmbPixelColor | VmbPixelOccupy64Bit | 0x0064,                           // RGBA, 8 bits x 4, legacy name
        VmbPixelFormatBgra16              =  VmbPixelColor | VmbPixelOccupy64Bit | 0x0051,                           // RGBA, 8 bits x 4, legacy name
        // yuv/ycbcr formats
        VmbPixelFormatYuv411              =  VmbPixelColor | VmbPixelOccupy12Bit | 0x001E,  // YUV 411 with 8 bits (GEV:YUV411Packed)
        VmbPixelFormatYuv422              =  VmbPixelColor | VmbPixelOccupy16Bit | 0x001F,  // YUV 422 with 8 bits (GEV:YUV422Packed)
        VmbPixelFormatYuv444              =  VmbPixelColor | VmbPixelOccupy24Bit | 0x0020,  // YUV 444 with 8 bits (GEV:YUV444Packed)
        VmbPixelFormatYCbCr411_8_CbYYCrYY =  VmbPixelColor | VmbPixelOccupy12Bit | 0x003C,  // Y�CbCr 411 with 8 bits (PFNC:YCbCr411_8_CbYYCrYY) - identical to VmbPixelFormatYuv411
        VmbPixelFormatYCbCr422_8_CbYCrY   =  VmbPixelColor | VmbPixelOccupy16Bit | 0x0043,  // Y�CbCr 422 with 8 bits (PFNC:YCbCr422_8_CbYCrY) - identical to VmbPixelFormatYuv422
        VmbPixelFormatYCbCr8_CbYCr        =  VmbPixelColor | VmbPixelOccupy24Bit | 0x003A,  // Y�CbCr 444 with 8 bits (PFNC:YCbCr8_CbYCr) - identical to VmbPixelFormatYuv444
        VmbPixelFormatLast =  VmbPixelColor | VmbPixelOccupy24Bit | 0x003A + 1;       // Type for the pixel format; for values see VmbPixelFormatType

// #ifdef __cplusplus
// #endif

// #endif // VMBCOMMONTYPES_H_INCLUDE_


// Parsed from <VimbaC/Include/VimbaC.h>

/*=============================================================================
  Copyright (C) 2012 - 2017 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this header file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------
 
  File:        VimbaC.h

  Description: Main header file for the VimbaC API.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef VIMBAC_H_INCLUDE_
// #define VIMBAC_H_INCLUDE_

// This file describes all necessary definitions for using Allied Vision's
// VimbaC API. These type definitions are designed to be portable from other
// languages and other operating systems.
//
// General conventions:
// - Method names are composed in the following manner:
//    - Vmb"Action"                                        example: VmbStartup()
//    - Vmb"Entity""Action" or Vmb"ActionTarget""Action"   example: VmbInterfaceOpen()
//    - Vmb"Entity""SubEntity/ActionTarget""Action"        example: VmbFeatureCommandRun()
// - Methods dealing with features, memory or registers accept a handle from the following
//   entity list as first parameter: System, Camera, Interface and AncillaryData.
//   All other methods taking handles accept only a specific handle.
// - Strings (generally declared as "const char *") are assumed to have a trailing 0 character
// - All pointer parameters should of course be valid, except if stated otherwise.
// - To ensure compatibility with older programs linked against a former version of the API,
//   all struct* parameters have an accompanying sizeofstruct parameter.
// - Functions returning lists are usually called twice: once with a zero buffer
//   to get the length of the list, and then again with a buffer of the correct length.

//===== #DEFINES ==============================================================

// #if defined (_WIN32)
// #elif defined (__GNUC__) && (__GNUC__ >= 4) && defined (__ELF__)
    // SO exports (requires compiler option -fvisibility=hidden)
//     #ifdef AVT_VMBAPI_C_EXPORTS
        public static native @MemberGetter String IMEXPORTC();
        public static final String IMEXPORTC = IMEXPORTC();
//     #else
//         #define IMEXPORTC
//     #endif
    
//     #ifdef __i386__
        // Calling convention
        public static native @MemberGetter int VMB_CALL();
        public static final int VMB_CALL = VMB_CALL();
//     #else
        // Calling convention
//         #define VMB_CALL
//     #endif
// #elif defined (__APPLE__)
    // Calling convention
//     #define VMB_CALL
// #else
//     #error Unknown platform, file needs adaption
// #endif

//===== TYPES ==============================================================
// #include "VmbCommonTypes.h"

// #ifdef __cplusplus
// #endif

// Timeout parameter signaling a blocking call
public static final int VMBINFINITE =        0xFFFFFFFF;

// Constant for the Vimba handle to be able to access Vimba system features
@MemberGetter public static native VmbHandle_t gVimbaHandle();

//
// Camera interface type (for instance FireWire, Ethernet);
//
/** enum VmbInterfaceType */
public static final int
    VmbInterfaceUnknown      = 0,           // Interface is not known to this version of the API
    VmbInterfaceFirewire     = 1,           // 1394
    VmbInterfaceEthernet     = 2,           // GigE
    VmbInterfaceUsb          = 3,           // USB 3.0
    VmbInterfaceCL           = 4,           // Camera Link
    VmbInterfaceCSI2         = 5;           // CSI-2         // Type for an Interface; for values see VmbInterfaceType

//
// Access mode for configurable devices (interfaces, cameras).
// Used in VmbCameraInfo_t, VmbInterfaceInfo_t as flags, so multiple modes can be
// announced, while in VmbCameraOpen(), no combination must be used.
//
/** enum VmbAccessModeType */
public static final int
    VmbAccessModeNone       = 0,            // No access
    VmbAccessModeFull       = 1,            // Read and write access
    VmbAccessModeRead       = 2,            // Read-only access
    VmbAccessModeConfig     = 4,            // Configuration access (GeV)
    VmbAccessModeLite       = 8;            // Read and write access without feature access (only addresses)        // Type for an AccessMode; for values see VmbAccessModeType

//
// Interface information.
// Holds read-only information about an interface.
//
public static class VmbInterfaceInfo_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public VmbInterfaceInfo_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public VmbInterfaceInfo_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VmbInterfaceInfo_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public VmbInterfaceInfo_t position(long position) {
        return (VmbInterfaceInfo_t)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer interfaceIdString();      // Unique identifier for each interface
    public native @Cast("VmbInterface_t") int interfaceType(); public native VmbInterfaceInfo_t interfaceType(int interfaceType);          // Interface type, see VmbInterfaceType
    @MemberGetter public native @Cast("const char*") BytePointer interfaceName();          // Interface name, given by the transport layer
    @MemberGetter public native @Cast("const char*") BytePointer serialString();           // Serial number
    public native @Cast("VmbAccessMode_t") int permittedAccess(); public native VmbInterfaceInfo_t permittedAccess(int permittedAccess);        // Used access mode, see VmbAccessModeType
}

//
// Camera information.
// Holds read-only information about a camera.
//
public static class VmbCameraInfo_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public VmbCameraInfo_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public VmbCameraInfo_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VmbCameraInfo_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public VmbCameraInfo_t position(long position) {
        return (VmbCameraInfo_t)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer cameraIdString();         // Unique identifier for each camera
    @MemberGetter public native @Cast("const char*") BytePointer cameraName();             // Name of the camera
    @MemberGetter public native @Cast("const char*") BytePointer modelName();              // Model name
    @MemberGetter public native @Cast("const char*") BytePointer serialString();           // Serial number
    public native @Cast("VmbAccessMode_t") int permittedAccess(); public native VmbCameraInfo_t permittedAccess(int permittedAccess);        // Used access mode, see VmbAccessModeType
    @MemberGetter public native @Cast("const char*") BytePointer interfaceIdString();      // Unique value for each interface or bus
}

//
// Supported feature data types
//
/** enum VmbFeatureDataType */
public static final int
    VmbFeatureDataUnknown     = 0,          // Unknown feature type
    VmbFeatureDataInt         = 1,          // 64 bit integer feature
    VmbFeatureDataFloat       = 2,          // 64 bit floating point feature
    VmbFeatureDataEnum        = 3,          // Enumeration feature
    VmbFeatureDataString      = 4,          // String feature
    VmbFeatureDataBool        = 5,          // Boolean feature
    VmbFeatureDataCommand     = 6,          // Command feature
    VmbFeatureDataRaw         = 7,          // Raw (direct register access) feature
    VmbFeatureDataNone        = 8;          // Feature with no data       // Data type for a Feature; for values see VmbFeatureDataType

//
// Feature visibility
//
/** enum VmbFeatureVisibilityType */
public static final int
    VmbFeatureVisibilityUnknown      = 0,   // Feature visibility is not known
    VmbFeatureVisibilityBeginner     = 1,   // Feature is visible in feature list (beginner level)
    VmbFeatureVisibilityExpert       = 2,   // Feature is visible in feature list (expert level)
    VmbFeatureVisibilityGuru         = 3,   // Feature is visible in feature list (guru level)
    VmbFeatureVisibilityInvisible    = 4;   // Feature is not visible in feature list // Type for Feature visibility; for values see VmbFeatureVisibilityType

//
// Feature flags
//
/** enum VmbFeatureFlagsType */
public static final int
    VmbFeatureFlagsNone         = 0,        // No additional information is provided
    VmbFeatureFlagsRead         = 1,        // Static info about read access. Current status depends on access mode, check with VmbFeachtureAccessQuery()
    VmbFeatureFlagsWrite        = 2,        // Static info about write access. Current status depends on access mode, check with VmbFeachtureAccessQuery()
    VmbFeatureFlagsVolatile     = 8,        // Value may change at any time
    VmbFeatureFlagsModifyWrite  = 16;       // Value may change after a write      // Type for Feature flags; for values see VmbFeatureFlagsType

//
// Feature information.
// Holds read-only information about a feature.
//
public static class VmbFeatureInfo_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public VmbFeatureInfo_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public VmbFeatureInfo_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VmbFeatureInfo_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public VmbFeatureInfo_t position(long position) {
        return (VmbFeatureInfo_t)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer name();                   // Name used in the API
    public native @Cast("VmbFeatureData_t") int featureDataType(); public native VmbFeatureInfo_t featureDataType(int featureDataType);        // Data type of this feature
    public native @Cast("VmbFeatureFlags_t") int featureFlags(); public native VmbFeatureInfo_t featureFlags(int featureFlags);           // Access flags for this feature
    @MemberGetter public native @Cast("const char*") BytePointer category();               // Category this feature can be found in
    @MemberGetter public native @Cast("const char*") BytePointer displayName();            // Feature name to be used in GUIs
    public native @Cast("VmbUint32_t") int pollingTime(); public native VmbFeatureInfo_t pollingTime(int pollingTime);            // Predefined polling time for volatile features
    @MemberGetter public native @Cast("const char*") BytePointer unit();                   // Measuring unit as given in the XML file
    @MemberGetter public native @Cast("const char*") BytePointer representation();         // Representation of a numeric feature
    public native @Cast("VmbFeatureVisibility_t") int visibility(); public native VmbFeatureInfo_t visibility(int visibility);             // GUI visibility
    @MemberGetter public native @Cast("const char*") BytePointer tooltip();                // Short description, e.g. for a tooltip
    @MemberGetter public native @Cast("const char*") BytePointer description();            // Longer description
    @MemberGetter public native @Cast("const char*") BytePointer sfncNamespace();          // Namespace this feature resides in
    public native @Cast("VmbBool_t") boolean isStreamable(); public native VmbFeatureInfo_t isStreamable(boolean isStreamable);           // Indicates if a feature can be stored to / loaded from a file
    public native @Cast("VmbBool_t") boolean hasAffectedFeatures(); public native VmbFeatureInfo_t hasAffectedFeatures(boolean hasAffectedFeatures);    // Indicates if the feature potentially affects other features
    public native @Cast("VmbBool_t") boolean hasSelectedFeatures(); public native VmbFeatureInfo_t hasSelectedFeatures(boolean hasSelectedFeatures);    // Indicates if the feature selects other features
}

//
// Info about possible entries of an enumeration feature
//
public static class VmbFeatureEnumEntry_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public VmbFeatureEnumEntry_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public VmbFeatureEnumEntry_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VmbFeatureEnumEntry_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public VmbFeatureEnumEntry_t position(long position) {
        return (VmbFeatureEnumEntry_t)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer name();           // Name used in the API
    @MemberGetter public native @Cast("const char*") BytePointer displayName();    // Enumeration entry name to be used in GUIs
    public native @Cast("VmbFeatureVisibility_t") int visibility(); public native VmbFeatureEnumEntry_t visibility(int visibility);     // GUI visibility
    @MemberGetter public native @Cast("const char*") BytePointer tooltip();        // Short description, e.g. for a tooltip
    @MemberGetter public native @Cast("const char*") BytePointer description();    // Longer description
    @MemberGetter public native @Cast("const char*") BytePointer sfncNamespace();  // Namespace this feature resides in
    public native @Cast("VmbInt64_t") long intValue(); public native VmbFeatureEnumEntry_t intValue(long intValue);       // Integer value of this enumeration entry
}

//
// Status of a frame transfer
//
/** enum VmbFrameStatusType */
public static final int
    VmbFrameStatusComplete       = 0,      // Frame has been completed without errors
    VmbFrameStatusIncomplete     = -1,      // Frame could not be filled to the end
    VmbFrameStatusTooSmall       = -2,      // Frame buffer was too small
    VmbFrameStatusInvalid        = -3;      // Frame buffer was invalid        // Type for the frame status; for values see VmbFrameStatusType

//
// Frame flags
//
/** enum VmbFrameFlagsType */
public static final int
    VmbFrameFlagsNone       = 0,            // No additional information is provided
    VmbFrameFlagsDimension  = 1,            // Frame's dimension is provided
    VmbFrameFlagsOffset     = 2,            // Frame's offset is provided (ROI)
    VmbFrameFlagsFrameID    = 4,            // Frame's ID is provided
    VmbFrameFlagsTimestamp  = 8;            // Frame's timestamp is provided        // Type for Frame flags; for values see VmbFrameFlagsType

//
// Frame delivered by the camera
//
public static class VmbFrame_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public VmbFrame_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public VmbFrame_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VmbFrame_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public VmbFrame_t position(long position) {
        return (VmbFrame_t)super.position(position);
    }

    //----- In -----
    public native Pointer buffer(); public native VmbFrame_t buffer(Pointer buffer);             // Comprises image and ancillary data
    public native @Cast("VmbUint32_t") int bufferSize(); public native VmbFrame_t bufferSize(int bufferSize);         // Size of the data buffer

    public native Pointer context(int i); public native VmbFrame_t context(int i, Pointer context);
    @MemberGetter public native @Cast("void**") PointerPointer context();         // 4 void pointers that can be employed by the user (e.g. for storing handles)

    //----- Out -----
    public native @Cast("VmbFrameStatus_t") int receiveStatus(); public native VmbFrame_t receiveStatus(int receiveStatus);      // Resulting status of the receive operation
    public native @Cast("VmbFrameFlags_t") int receiveFlags(); public native VmbFrame_t receiveFlags(int receiveFlags);       // Flags indicating which additional frame information is available

    public native @Cast("VmbUint32_t") int imageSize(); public native VmbFrame_t imageSize(int imageSize);          // Size of the image data inside the data buffer
    public native @Cast("VmbUint32_t") int ancillarySize(); public native VmbFrame_t ancillarySize(int ancillarySize);      // Size of the ancillary data inside the data buffer

    public native @Cast("VmbPixelFormat_t") int pixelFormat(); public native VmbFrame_t pixelFormat(int pixelFormat);        // Pixel format of the image

    public native @Cast("VmbUint32_t") int width(); public native VmbFrame_t width(int width);              // Width of an image
    public native @Cast("VmbUint32_t") int height(); public native VmbFrame_t height(int height);             // Height of an image
    public native @Cast("VmbUint32_t") int offsetX(); public native VmbFrame_t offsetX(int offsetX);            // Horizontal offset of an image
    public native @Cast("VmbUint32_t") int offsetY(); public native VmbFrame_t offsetY(int offsetY);            // Vertical offset of an image

    public native @Cast("VmbUint64_t") int frameID(); public native VmbFrame_t frameID(int frameID);            // Unique ID of this frame in this stream
    public native @Cast("VmbUint64_t") int timestamp(); public native VmbFrame_t timestamp(int timestamp);          // Timestamp set by the camera
}

//
// Type of features that are to be saved (persisted) to the XML file when using VmbCameraSettingsSave
//
/** enum VmbFeaturePersistType */
public static final int
    VmbFeaturePersistAll        = 0,        // Save all features to XML, including look-up tables
    VmbFeaturePersistStreamable = 1,        // Save only features marked as streamable, excluding look-up tables
    VmbFeaturePersistNoLUT      = 2;         // Save all features except look-up tables (default)    // Type for feature persistence; for values see VmbFeaturePersistType

//
// Parameters determining the operation mode of VmbCameraSettingsSave and VmbCameraSettingsLoad
//
public static class VmbFeaturePersistSettings_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public VmbFeaturePersistSettings_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public VmbFeaturePersistSettings_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VmbFeaturePersistSettings_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public VmbFeaturePersistSettings_t position(long position) {
        return (VmbFeaturePersistSettings_t)super.position(position);
    }

    public native @Cast("VmbFeaturePersist_t") int persistType(); public native VmbFeaturePersistSettings_t persistType(int persistType);        // Type of features that are to be saved
    public native @Cast("VmbUint32_t") int maxIterations(); public native VmbFeaturePersistSettings_t maxIterations(int maxIterations);      // Number of iterations when loading settings
    public native @Cast("VmbUint32_t") int loggingLevel(); public native VmbFeaturePersistSettings_t loggingLevel(int loggingLevel);       // Determines level of detail for load/save settings logging
}


// ----- Callbacks ------------------------------------------------------------

//
// Name: VmbInvalidationCallback
//
// Purpose: Invalidation Callback type for a function that gets called in a separate thread
//          and has been registered with VmbFeatureInvalidationRegister()
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle          Handle for an entity that exposes features
//  [in ]  const char*          name            Name of the feature
//  [in ]  void*                pUserContext    Pointer to the user context, see VmbFeatureInvalidationRegister
//
// Details:     While the callback is run, all feature data is atomic.  After the
//              callback finishes, the feature data might be updated with new values.
//
// Note:        Do not spend too much time in this thread; it will prevent the feature values
//              from being updated from any other thread or the lower-level drivers.
//
@Convention("VMB_CALL") public static class VmbInvalidationCallback extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    VmbInvalidationCallback(Pointer p) { super(p); }
    protected VmbInvalidationCallback() { allocate(); }
    private native void allocate();
    public native void call( VmbHandle_t handle, @Cast("const char*") BytePointer name, Pointer pUserContext );
}

//
// Name: VmbFrameCallback
//
// Purpose: Frame Callback type for a function that gets called in a separate thread
//          if a frame has been queued with VmbCaptureFrameQueue()
//
// Parameters:
//
//  [in ]  const VmbHandle_t    cameraHandle    Handle of the camera
//  [out]  VmbFrame_t*          pFrame          Frame completed
//
@Convention("VMB_CALL") public static class VmbFrameCallback extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    VmbFrameCallback(Pointer p) { super(p); }
    protected VmbFrameCallback() { allocate(); }
    private native void allocate();
    public native void call( VmbHandle_t cameraHandle, VmbFrame_t pFrame );
}


//===== FUNCTION PROTOTYPES ===================================================

//----- API Version -----------------------------------------------------------

//
// Method:      VmbVersionQuery()
//
// Purpose:     Retrieve the version number of VimbaC.
//
// Parameters:
//
//  [out]  VmbVersionInfo_t*    pVersionInfo        Pointer to the struct where version information
//                                                  is copied
//  [in ]  VmbUint32_t          sizeofVersionInfo   Size of structure in bytes
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorStructSize:    The given struct size is not valid for this version of the API
//  - VmbErrorBadParameter:  If "pVersionInfo" is NULL.
//
// Details:     This function can be called at anytime, even before the API is
//              initialized. All other version numbers may be queried via feature access.
//
public static native @Cast("const char*") BytePointer VmbVersionQuery( VmbVersionInfo_t pVersionInfo,
                                                @Cast("VmbUint32_t") int sizeofVersionInfo );


//----- API Initialization ----------------------------------------------------

//
// Method:      VmbStartup()
//
// Purpose:     Initialize the VimbaC API.
//
// Parameters:
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorInternalFault: An internal fault occurred
//
// Details:     On successful return, the API is initialized; this is a necessary call.
//
// Note:        This method must be called before any VimbaC function other than VmbVersionQuery() is run.
//
public static native @Cast("const char*") BytePointer VmbStartup( );

//
// Method:      VmbShutdown()
//
// Purpose:     Perform a shutdown on the API.
//
// Parameters:  none
//
// Returns:     none
//
// Details:     This will free some resources and deallocate all physical resources if applicable.
//
public static native @Cast("const char*") BytePointer VmbShutdown( );


//----- Camera Enumeration & Information --------------------------------------

//
// Method:      VmbCamerasList()
//
// Purpose:     Retrieve a list of all cameras.
//
// Parameters:
//
//  [out]  VmbCameraInfo_t*  pCameraInfo        Array of VmbCameraInfo_t, allocated by
//                                              the caller. The camera list is
//                                              copied here. May be NULL if pNumFound is used for size query.
//  [in ]  VmbUint32_t       listLength         Number of VmbCameraInfo_t elements provided
//  [out]  VmbUint32_t*      pNumFound          Number of VmbCameraInfo_t elements found.
//  [in ]  VmbUint32_t       sizeofCameraInfo   Size of the structure (if pCameraInfo == NULL this parameter is ignored)
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorStructSize:    The given struct size is not valid for this API version
//  - VmbErrorMoreData:      The given list length was insufficient to hold all available entries
//  - VmbErrorBadParameter:  If "pNumFound" was NULL
//
// Details:     Camera detection is started with the registration of the "DiscoveryCameraEvent"
//              event or the first call of VmbCamerasList(), which may be delayed if no
//              "DiscoveryCameraEvent" event is registered (see examples).
//              VmbCamerasList() is usually called twice: once with an empty array to query the
//              list length, and then again with an array of the correct length. If camera
//              lists change between the calls, pNumFound may deviate from the query return.
//
public static native @Cast("const char*") BytePointer VmbCamerasList( VmbCameraInfo_t pCameraInfo,
                                               @Cast("VmbUint32_t") int listLength,
                                               @Cast("VmbUint32_t*") IntPointer pNumFound,
                                               @Cast("VmbUint32_t") int sizeofCameraInfo );
public static native String VmbCamerasList( VmbCameraInfo_t pCameraInfo,
                                               @Cast("VmbUint32_t") int listLength,
                                               @Cast("VmbUint32_t*") IntBuffer pNumFound,
                                               @Cast("VmbUint32_t") int sizeofCameraInfo );
public static native @Cast("const char*") BytePointer VmbCamerasList( VmbCameraInfo_t pCameraInfo,
                                               @Cast("VmbUint32_t") int listLength,
                                               @Cast("VmbUint32_t*") int[] pNumFound,
                                               @Cast("VmbUint32_t") int sizeofCameraInfo );

//
// Method:      VmbCameraInfoQuery()
//
// Purpose:     Retrieve information on a camera given by an ID.
//
// Parameters:
//
//  [in ] const char*       idString           ID of the camera
//  [out] VmbCameraInfo_t*  pInfo              Structure where information will be copied. May be NULL.
//  [in ] VmbUint32_t       sizeofCameraInfo   Size of the structure
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorNotFound:      The designated camera cannot be found
//  - VmbErrorStructSize:    The given struct size is not valid for this API version
//  - VmbErrorBadParameter:  If "idString" was NULL
//
// Details:     May be called if a camera has not been opened by the application yet.
//              Examples for "idString": 
//              "DEV_81237473991" for an ID given by a transport layer,
//              "169.254.12.13" for an IP address,
//              "000F314C4BE5" for a MAC address or 
//              "DEV_1234567890" for an ID as reported by Vimba
//
public static native @Cast("const char*") BytePointer VmbCameraInfoQuery( @Cast("const char*") BytePointer idString,
                                                   VmbCameraInfo_t pInfo,
                                                   @Cast("VmbUint32_t") int sizeofCameraInfo );
public static native String VmbCameraInfoQuery( String idString,
                                                   VmbCameraInfo_t pInfo,
                                                   @Cast("VmbUint32_t") int sizeofCameraInfo );

//
// Method:      VmbCameraOpen()
//
// Purpose:     Open the specified camera.
//
// Parameters:
//
//  [in ]  const char*      idString        ID of the camera
//  [in ]  VmbAccessMode_t  accessMode      Determines the level of control you have on the camera
//  [out]  VmbHandle_t*     pCameraHandle   A camera handle
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorNotFound:      The designated camera cannot be found
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorInvalidCall:   If called from frame callback
//  - VmbErrorBadParameter:  If "idString" or "pCameraHandle" is NULL
//
// Details:     A camera may be opened in a specific access mode, which determines
//              the level of control you have on a camera.
//              Examples for "idString": 
//              "DEV_81237473991" for an ID given by a transport layer,
//              "169.254.12.13" for an IP address,
//              "000F314C4BE5" for a MAC address or 
//              "DEV_1234567890" for an ID as reported by Vimba
//
public static native @Cast("const char*") BytePointer VmbCameraOpen( @Cast("const char*") BytePointer idString,
                                              @Cast("VmbAccessMode_t") int accessMode,
                                              @ByPtrPtr VmbHandle_t pCameraHandle );
public static native String VmbCameraOpen( String idString,
                                              @Cast("VmbAccessMode_t") int accessMode,
                                              @ByPtrPtr VmbHandle_t pCameraHandle );

//
// Method:      VmbCameraClose()
//
// Purpose:     Close the specified camera.
//
// Parameters:
//
//  [in ]  const VmbHandle_t  cameraHandle      A valid camera handle
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorInvalidCall:   If called from frame callback
//
// Details:     Depending on the access mode this camera was opened with, events are killed,
//              callbacks are unregistered, and camera control is released.
//
public static native @Cast("const char*") BytePointer VmbCameraClose( VmbHandle_t cameraHandle );


//----- Features ----------------------------------------------------------

//
// Method:      VmbFeaturesList()
//
// Purpose:     List all the features for this entity.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle            Handle for an entity that exposes features
//  [out]  VmbFeatureInfo_t*    pFeatureInfoList  An array of VmbFeatureInfo_t to be filled by the API. May be NULL if pNumFund is used for size query.
//  [in ]  VmbUint32_t          listLength        Number of VmbFeatureInfo_t elements provided
//  [out]  VmbUint32_t*         pNumFound         Number of VmbFeatureInfo_t elements found. May be NULL if pFeatureInfoList is not NULL.
//  [in ]  VmbUint32_t          sizeofFeatureInfo Size of a VmbFeatureInfo_t entry
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorStructSize:    The given struct size of VmbFeatureInfo_t is not valid for this version of the API
//  - VmbErrorMoreData:      The given list length was insufficient to hold all available entries
//
// Details:     This method lists all implemented features, whether they are currently available or not.
//              The list of features does not change as long as the camera/interface is connected.
//              "pNumFound" returns the number of VmbFeatureInfo elements.
//              This function is usually called twice: once with an empty list to query the length
//              of the list, and then again with an list of the correct length.
//              
//
public static native @Cast("const char*") BytePointer VmbFeaturesList( VmbHandle_t handle,
                                                VmbFeatureInfo_t pFeatureInfoList,
                                                @Cast("VmbUint32_t") int listLength,
                                                @Cast("VmbUint32_t*") IntPointer pNumFound,
                                                @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native String VmbFeaturesList( VmbHandle_t handle,
                                                VmbFeatureInfo_t pFeatureInfoList,
                                                @Cast("VmbUint32_t") int listLength,
                                                @Cast("VmbUint32_t*") IntBuffer pNumFound,
                                                @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("const char*") BytePointer VmbFeaturesList( VmbHandle_t handle,
                                                VmbFeatureInfo_t pFeatureInfoList,
                                                @Cast("VmbUint32_t") int listLength,
                                                @Cast("VmbUint32_t*") int[] pNumFound,
                                                @Cast("VmbUint32_t") int sizeofFeatureInfo );

//
// Method:      VmbFeatureInfoQuery()
//
// Purpose:     Query information about the constant properties of a feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t        handle             Handle for an entity that exposes features
//  [in ]  const char*              name               Name of the feature
//  [out]  VmbFeatureInfo_t*        pFeatureInfo       The feature info to query
//  [in ]  VmbUint32_t              sizeofFeatureInfo  Size of the structure
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorStructSize:    The given struct size is not valid for this version of the API
//
// Details:     Users provide a pointer to VmbFeatureInfo_t, which is then set to the internal representation.
//
public static native @Cast("const char*") BytePointer VmbFeatureInfoQuery( VmbHandle_t handle,
                                                    @Cast("const char*") BytePointer name,
                                                    VmbFeatureInfo_t pFeatureInfo,
                                                    @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native String VmbFeatureInfoQuery( VmbHandle_t handle,
                                                    String name,
                                                    VmbFeatureInfo_t pFeatureInfo,
                                                    @Cast("VmbUint32_t") int sizeofFeatureInfo );

//
// Method:      VmbFeatureListAffected()
//
// Purpose:     List all the features that might be affected by changes to this feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle              Handle for an entity that exposes features
//  [in ]  const char*          name                Name of the feature
//  [out]  VmbFeatureInfo_t*    pFeatureInfoList    An array of VmbFeatureInfo_t to be filled by the API. May be NULL if pNumFound is used for size query.
//  [in ]  VmbUint32_t          listLength          Number of VmbFeatureInfo_t elements provided
//  [out]  VmbUint32_t*         pNumFound           Number of VmbFeatureInfo_t elements found. May be NULL is pFeatureInfoList is not NULL.
//  [in ]  VmbUint32_t          sizeofFeatureInfo   Size of a VmbFeatureInfo_t entry
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorStructSize:    The given struct size of VmbFeatureInfo_t is not valid for this version of the API
//  - VmbErrorMoreData:      The given list length was insufficient to hold all available entries
//
// Details:     This method lists all affected features, whether they are currently available or not.
//              The value of affected features depends directly or indirectly on this feature
//              (including all selected features).
//              The list of features does not change as long as the camera/interface is connected.
//              This function is usually called twice: once with an empty array to query the length
//              of the list, and then again with an array of the correct length.
//
public static native @Cast("const char*") BytePointer VmbFeatureListAffected( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") IntPointer pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native String VmbFeatureListAffected( VmbHandle_t handle,
                                                       String name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") IntBuffer pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("const char*") BytePointer VmbFeatureListAffected( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") int[] pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native String VmbFeatureListAffected( VmbHandle_t handle,
                                                       String name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") IntPointer pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("const char*") BytePointer VmbFeatureListAffected( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") IntBuffer pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native String VmbFeatureListAffected( VmbHandle_t handle,
                                                       String name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") int[] pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );

//
// Method:      VmbFeatureListSelected()
//
// Purpose:     List all the features selected by a given feature for this module.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle              Handle for an entity that exposes features
//  [in ]  const char*          name                Name of the feature
//  [out]  VmbFeatureInfo_t*    pFeatureInfoList    An array of VmbFeatureInfo_t to be filled by the API. May be NULL if pNumFound is used for size query.
//  [in ]  VmbUint32_t          listLength          Number of VmbFeatureInfo_t elements provided
//  [out]  VmbUint32_t*         pNumFound           Number of VmbFeatureInfo_t elements found. May be NULL if pFeatureInfoList is not NULL.
//  [in ]  VmbUint32_t          sizeofFeatureInfo   Size of a VmbFeatureInfo_t entry
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorStructSize:    The given struct size is not valid for this version of the API
//  - VmbErrorMoreData:      The given list length was insufficient to hold all available entries
//
// Details:     This method lists all selected features, whether they are currently available or not.
//              Features with selected features ("selectors") have no direct impact on the camera,
//              but only influence the register address that selected features point to.
//              The list of features does not change while the camera/interface is connected.
//              This function is usually called twice: once with an empty array to query the length
//              of the list, and then again with an array of the correct length.
//
public static native @Cast("const char*") BytePointer VmbFeatureListSelected( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") IntPointer pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native String VmbFeatureListSelected( VmbHandle_t handle,
                                                       String name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") IntBuffer pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("const char*") BytePointer VmbFeatureListSelected( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") int[] pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native String VmbFeatureListSelected( VmbHandle_t handle,
                                                       String name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") IntPointer pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("const char*") BytePointer VmbFeatureListSelected( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") IntBuffer pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native String VmbFeatureListSelected( VmbHandle_t handle,
                                                       String name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") int[] pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );

//
// Method:      VmbFeatureAccessQuery()
//
// Purpose:     Return the dynamic read and write capabilities of this feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t  handle          Handle for an entity that exposes features.
//  [in ]  const char *       name            Name of the feature.
//  [out]  VmbBool_t *        pIsReadable     Indicates if this feature is readable. May be NULL.
//  [out]  VmbBool_t *        pIsWriteable    Indicates if this feature is writable. May be NULL.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorBadParameter:  If "pIsReadable" and "pIsWriteable" were both NULL
//  - VmbErrorNotFound:      The feature was not found
//
// Details:     The access mode of a feature may change. For example, if "PacketSize"
//              is locked while image data is streamed, it is only readable.
//
public static native @Cast("const char*") BytePointer VmbFeatureAccessQuery( VmbHandle_t handle,
                                                      @Cast("const char*") BytePointer name,
                                                      @Cast("VmbBool_t*") BoolPointer pIsReadable,
                                                      @Cast("VmbBool_t*") BoolPointer pIsWriteable );
public static native String VmbFeatureAccessQuery( VmbHandle_t handle,
                                                      String name,
                                                      @Cast("VmbBool_t*") boolean[] pIsReadable,
                                                      @Cast("VmbBool_t*") boolean[] pIsWriteable );


//-----Integer --------

//
// Method:      VmbFeatureIntGet()
//
// Purpose:     Get the value of an integer feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the feature
//  [out]  VmbInt64_t*          pValue      Value to get
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Integer
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "name" or "pValue" is NULL
//
public static native @Cast("const char*") BytePointer VmbFeatureIntGet( VmbHandle_t handle,
                                                 @Cast("const char*") BytePointer name,
                                                 @Cast("VmbInt64_t*") LongPointer pValue );
public static native String VmbFeatureIntGet( VmbHandle_t handle,
                                                 String name,
                                                 @Cast("VmbInt64_t*") LongBuffer pValue );
public static native @Cast("const char*") BytePointer VmbFeatureIntGet( VmbHandle_t handle,
                                                 @Cast("const char*") BytePointer name,
                                                 @Cast("VmbInt64_t*") long[] pValue );
public static native String VmbFeatureIntGet( VmbHandle_t handle,
                                                 String name,
                                                 @Cast("VmbInt64_t*") LongPointer pValue );
public static native @Cast("const char*") BytePointer VmbFeatureIntGet( VmbHandle_t handle,
                                                 @Cast("const char*") BytePointer name,
                                                 @Cast("VmbInt64_t*") LongBuffer pValue );
public static native String VmbFeatureIntGet( VmbHandle_t handle,
                                                 String name,
                                                 @Cast("VmbInt64_t*") long[] pValue );

//
// Method:      VmbFeatureIntSet()
//
// Purpose:     Set the value of an integer feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle    Handle for an entity that exposes features
//  [in ]  const char*          name      Name of the feature
//  [in ]  VmbInt64_t           value     Value to set
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Integer
//  - VmbErrorInvalidValue:  If "value" is either out of bounds or not an increment of the minimum
//  - VmbErrorBadParameter:  If "name" is NULL
//  - VmbErrorNotFound:      If the feature was not found
//  - VmbErrorInvalidCall:   If called from frame callback
//
public static native @Cast("const char*") BytePointer VmbFeatureIntSet( VmbHandle_t handle,
                                                 @Cast("const char*") BytePointer name,
                                                 @Cast("VmbInt64_t") long value );
public static native String VmbFeatureIntSet( VmbHandle_t handle,
                                                 String name,
                                                 @Cast("VmbInt64_t") long value );

//
// Method:      VmbFeatureIntRangeQuery()
//
// Purpose:     Query the range of an integer feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the feature
//  [out]  VmbInt64_t*          pMin        Minimum value to be returned. May be NULL.
//  [out]  VmbInt64_t*          pMax        Maximum value to be returned. May be NULL.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorBadParameter:  If "name" is NULL or "pMin" and "pMax" are NULL
//  - VmbErrorWrongType:     The type of feature "name" is not Integer
//  - VmbErrorNotFound:      If the feature was not found
//
public static native @Cast("const char*") BytePointer VmbFeatureIntRangeQuery( VmbHandle_t handle,
                                                        @Cast("const char*") BytePointer name,
                                                        @Cast("VmbInt64_t*") LongPointer pMin,
                                                        @Cast("VmbInt64_t*") LongPointer pMax );
public static native String VmbFeatureIntRangeQuery( VmbHandle_t handle,
                                                        String name,
                                                        @Cast("VmbInt64_t*") LongBuffer pMin,
                                                        @Cast("VmbInt64_t*") LongBuffer pMax );
public static native @Cast("const char*") BytePointer VmbFeatureIntRangeQuery( VmbHandle_t handle,
                                                        @Cast("const char*") BytePointer name,
                                                        @Cast("VmbInt64_t*") long[] pMin,
                                                        @Cast("VmbInt64_t*") long[] pMax );
public static native String VmbFeatureIntRangeQuery( VmbHandle_t handle,
                                                        String name,
                                                        @Cast("VmbInt64_t*") LongPointer pMin,
                                                        @Cast("VmbInt64_t*") LongPointer pMax );
public static native @Cast("const char*") BytePointer VmbFeatureIntRangeQuery( VmbHandle_t handle,
                                                        @Cast("const char*") BytePointer name,
                                                        @Cast("VmbInt64_t*") LongBuffer pMin,
                                                        @Cast("VmbInt64_t*") LongBuffer pMax );
public static native String VmbFeatureIntRangeQuery( VmbHandle_t handle,
                                                        String name,
                                                        @Cast("VmbInt64_t*") long[] pMin,
                                                        @Cast("VmbInt64_t*") long[] pMax );

//
// Method:      VmbFeatureIntIncrementQuery()
//
// Purpose:     Query the increment of an integer feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle         Handle for an entity that exposes features
//  [in ]  const char*          name           Name of the feature
//  [out]  VmbInt64_t*          pValue         Value of the increment to get.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Integer
//  - VmbErrorNotFound:      The feature was not found
//    VmbErrorBadParameter:  If "name" or "pValue" is NULL
//
public static native @Cast("const char*") BytePointer VmbFeatureIntIncrementQuery( VmbHandle_t handle,
                                                            @Cast("const char*") BytePointer name,
                                                            @Cast("VmbInt64_t*") LongPointer pValue );
public static native String VmbFeatureIntIncrementQuery( VmbHandle_t handle,
                                                            String name,
                                                            @Cast("VmbInt64_t*") LongBuffer pValue );
public static native @Cast("const char*") BytePointer VmbFeatureIntIncrementQuery( VmbHandle_t handle,
                                                            @Cast("const char*") BytePointer name,
                                                            @Cast("VmbInt64_t*") long[] pValue );
public static native String VmbFeatureIntIncrementQuery( VmbHandle_t handle,
                                                            String name,
                                                            @Cast("VmbInt64_t*") LongPointer pValue );
public static native @Cast("const char*") BytePointer VmbFeatureIntIncrementQuery( VmbHandle_t handle,
                                                            @Cast("const char*") BytePointer name,
                                                            @Cast("VmbInt64_t*") LongBuffer pValue );
public static native String VmbFeatureIntIncrementQuery( VmbHandle_t handle,
                                                            String name,
                                                            @Cast("VmbInt64_t*") long[] pValue );

//-----Float --------

//
// Method:      VmbFeatureFloatGet()
//
// Purpose:     Get the value of a float feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the feature
//  [out]  double*              pValue      Value to get
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Float
//  - VmbErrorBadParameter:  If "name" or "pValue" is NULL
//  - VmbErrorNotFound:      The feature was not found
//
public static native @Cast("const char*") BytePointer VmbFeatureFloatGet( VmbHandle_t handle,
                                                   @Cast("const char*") BytePointer name,
                                                   DoublePointer pValue );
public static native String VmbFeatureFloatGet( VmbHandle_t handle,
                                                   String name,
                                                   DoubleBuffer pValue );
public static native @Cast("const char*") BytePointer VmbFeatureFloatGet( VmbHandle_t handle,
                                                   @Cast("const char*") BytePointer name,
                                                   double[] pValue );
public static native String VmbFeatureFloatGet( VmbHandle_t handle,
                                                   String name,
                                                   DoublePointer pValue );
public static native @Cast("const char*") BytePointer VmbFeatureFloatGet( VmbHandle_t handle,
                                                   @Cast("const char*") BytePointer name,
                                                   DoubleBuffer pValue );
public static native String VmbFeatureFloatGet( VmbHandle_t handle,
                                                   String name,
                                                   double[] pValue );

//
// Method:      VmbFeatureFloatSet()
//
// Purpose:     Set the value of a float feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the feature
//  [in ]  double               value       Value to set
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Float
//  - VmbErrorInvalidValue:  If "value" is not within valid bounds
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "name" is NULL
//  - VmbErrorInvalidCall:   If called from frame callback
//
public static native @Cast("const char*") BytePointer VmbFeatureFloatSet( VmbHandle_t handle,
                                                   @Cast("const char*") BytePointer name,
                                                   double value );
public static native String VmbFeatureFloatSet( VmbHandle_t handle,
                                                   String name,
                                                   double value );

//
// Method:      VmbFeatureFloatRangeQuery()
//
// Purpose:     Query the range of a float feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the feature
//  [out]  double*              pMin        Minimum value to be returned. May be NULL.
//  [out]  double*              pMax        Maximum value to be returned. May be NULL.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Float
//  - VmbErrorNotFound:      The feature was not found
//  - VmbBadParameter:       If "name" is NULL or "pMin" and "pMax" are NULL
//
// Details:     Only one of the values may be queried if the other parameter is set to NULL,
//              but if both parameters are NULL, an error is returned.
//
public static native @Cast("const char*") BytePointer VmbFeatureFloatRangeQuery( VmbHandle_t handle,
                                                          @Cast("const char*") BytePointer name,
                                                          DoublePointer pMin,
                                                          DoublePointer pMax );
public static native String VmbFeatureFloatRangeQuery( VmbHandle_t handle,
                                                          String name,
                                                          DoubleBuffer pMin,
                                                          DoubleBuffer pMax );
public static native @Cast("const char*") BytePointer VmbFeatureFloatRangeQuery( VmbHandle_t handle,
                                                          @Cast("const char*") BytePointer name,
                                                          double[] pMin,
                                                          double[] pMax );
public static native String VmbFeatureFloatRangeQuery( VmbHandle_t handle,
                                                          String name,
                                                          DoublePointer pMin,
                                                          DoublePointer pMax );
public static native @Cast("const char*") BytePointer VmbFeatureFloatRangeQuery( VmbHandle_t handle,
                                                          @Cast("const char*") BytePointer name,
                                                          DoubleBuffer pMin,
                                                          DoubleBuffer pMax );
public static native String VmbFeatureFloatRangeQuery( VmbHandle_t handle,
                                                          String name,
                                                          double[] pMin,
                                                          double[] pMax );

//
// Method:      VmbFeatureFloatIncrementQuery()
//
// Purpose:     Query the increment of an float feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle         Handle for an entity that exposes features
//  [in ]  const char*          name           Name of the feature
//  [out]  double*              pValue         Value of the increment to get.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Integer
//  - VmbErrorNotFound:      The feature was not found
//    VmbErrorBadParameter:  If "name" or "pValue" is NULL
//
public static native @Cast("const char*") BytePointer VmbFeatureFloatIncrementQuery( VmbHandle_t handle,
                                                              @Cast("const char*") BytePointer name,
                                                              @Cast("VmbBool_t*") BoolPointer hasIncrement,
                                                              DoublePointer pValue );
public static native String VmbFeatureFloatIncrementQuery( VmbHandle_t handle,
                                                              String name,
                                                              @Cast("VmbBool_t*") boolean[] hasIncrement,
                                                              DoubleBuffer pValue );
public static native @Cast("const char*") BytePointer VmbFeatureFloatIncrementQuery( VmbHandle_t handle,
                                                              @Cast("const char*") BytePointer name,
                                                              @Cast("VmbBool_t*") BoolPointer hasIncrement,
                                                              double[] pValue );
public static native String VmbFeatureFloatIncrementQuery( VmbHandle_t handle,
                                                              String name,
                                                              @Cast("VmbBool_t*") boolean[] hasIncrement,
                                                              DoublePointer pValue );
public static native @Cast("const char*") BytePointer VmbFeatureFloatIncrementQuery( VmbHandle_t handle,
                                                              @Cast("const char*") BytePointer name,
                                                              @Cast("VmbBool_t*") BoolPointer hasIncrement,
                                                              DoubleBuffer pValue );
public static native String VmbFeatureFloatIncrementQuery( VmbHandle_t handle,
                                                              String name,
                                                              @Cast("VmbBool_t*") boolean[] hasIncrement,
                                                              double[] pValue );
//-----Enum --------

//
// Method:      VmbFeatureEnumGet()
//
// Purpose:     Get the value of an enumeration feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the feature
//  [out]  const char**         pValue      The current enumeration value. The returned value
//                                          is a reference to the API value
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Enumeration
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "name" or "pValue" is NULL
//
public static native @Cast("const char*") BytePointer VmbFeatureEnumGet( VmbHandle_t handle,
                                                  @Cast("const char*") BytePointer name,
                                                  @Cast("const char**") PointerPointer pValue );
public static native @Cast("const char*") BytePointer VmbFeatureEnumGet( VmbHandle_t handle,
                                                  @Cast("const char*") BytePointer name,
                                                  @Cast("const char**") @ByPtrPtr BytePointer pValue );
public static native String VmbFeatureEnumGet( VmbHandle_t handle,
                                                  String name,
                                                  @Cast("const char**") @ByPtrPtr ByteBuffer pValue );
public static native @Cast("const char*") BytePointer VmbFeatureEnumGet( VmbHandle_t handle,
                                                  @Cast("const char*") BytePointer name,
                                                  @Cast("const char**") @ByPtrPtr byte[] pValue );
public static native String VmbFeatureEnumGet( VmbHandle_t handle,
                                                  String name,
                                                  @Cast("const char**") @ByPtrPtr BytePointer pValue );
public static native @Cast("const char*") BytePointer VmbFeatureEnumGet( VmbHandle_t handle,
                                                  @Cast("const char*") BytePointer name,
                                                  @Cast("const char**") @ByPtrPtr ByteBuffer pValue );
public static native String VmbFeatureEnumGet( VmbHandle_t handle,
                                                  String name,
                                                  @Cast("const char**") @ByPtrPtr byte[] pValue );

//
// Method:      VmbFeatureEnumSet()
//
// Purpose:     Set the value of an enumeration feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the feature
//  [in ]  const char*          value       Value to set
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Enumeration
//  - VmbErrorInvalidValue:  If "value" is not within valid bounds
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "name" ore "value" is NULL
//  - VmbErrorInvalidCall:   If called from frame callback
//
public static native @Cast("const char*") BytePointer VmbFeatureEnumSet( VmbHandle_t handle,
                                                  @Cast("const char*") BytePointer name,
                                                  @Cast("const char*") BytePointer value );
public static native String VmbFeatureEnumSet( VmbHandle_t handle,
                                                  String name,
                                                  String value );

//
// Method:      VmbFeatureEnumRangeQuery()
//
// Purpose:     Query the value range of an enumeration feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle          Handle for an entity that exposes features
//  [in ]  const char*          name            Name of the feature
//  [out]  const char**         pNameArray      An array of enumeration value names; may be NULL if pNumFilled is used for size query
//  [in ]  VmbUint32_t          arrayLength     Number of elements in the array
//  [out]  VmbUint32_t *        pNumFilled      Number of filled elements; may be NULL if pNameArray is not NULL
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorMoreData:      The given array length was insufficient to hold all available entries
//  - VmbErrorWrongType:     The type of feature "name" is not Enumeration
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "name" is NULL or "pNameArray" and "pNumFilled" are NULL
//
public static native @Cast("const char*") BytePointer VmbFeatureEnumRangeQuery( VmbHandle_t handle,
                                                         @Cast("const char*") BytePointer name,
                                                         @Cast("const char**") PointerPointer pNameArray,
                                                         @Cast("VmbUint32_t") int arrayLength,
                                                         @Cast("VmbUint32_t*") IntPointer pNumFilled );
public static native @Cast("const char*") BytePointer VmbFeatureEnumRangeQuery( VmbHandle_t handle,
                                                         @Cast("const char*") BytePointer name,
                                                         @Cast("const char**") @ByPtrPtr BytePointer pNameArray,
                                                         @Cast("VmbUint32_t") int arrayLength,
                                                         @Cast("VmbUint32_t*") IntPointer pNumFilled );
public static native String VmbFeatureEnumRangeQuery( VmbHandle_t handle,
                                                         String name,
                                                         @Cast("const char**") @ByPtrPtr ByteBuffer pNameArray,
                                                         @Cast("VmbUint32_t") int arrayLength,
                                                         @Cast("VmbUint32_t*") IntBuffer pNumFilled );
public static native @Cast("const char*") BytePointer VmbFeatureEnumRangeQuery( VmbHandle_t handle,
                                                         @Cast("const char*") BytePointer name,
                                                         @Cast("const char**") @ByPtrPtr byte[] pNameArray,
                                                         @Cast("VmbUint32_t") int arrayLength,
                                                         @Cast("VmbUint32_t*") int[] pNumFilled );
public static native String VmbFeatureEnumRangeQuery( VmbHandle_t handle,
                                                         String name,
                                                         @Cast("const char**") @ByPtrPtr BytePointer pNameArray,
                                                         @Cast("VmbUint32_t") int arrayLength,
                                                         @Cast("VmbUint32_t*") IntPointer pNumFilled );
public static native @Cast("const char*") BytePointer VmbFeatureEnumRangeQuery( VmbHandle_t handle,
                                                         @Cast("const char*") BytePointer name,
                                                         @Cast("const char**") @ByPtrPtr ByteBuffer pNameArray,
                                                         @Cast("VmbUint32_t") int arrayLength,
                                                         @Cast("VmbUint32_t*") IntBuffer pNumFilled );
public static native String VmbFeatureEnumRangeQuery( VmbHandle_t handle,
                                                         String name,
                                                         @Cast("const char**") @ByPtrPtr byte[] pNameArray,
                                                         @Cast("VmbUint32_t") int arrayLength,
                                                         @Cast("VmbUint32_t*") int[] pNumFilled );

//
// Method:      VmbFeatureEnumIsAvailable()
//
// Purpose:     Check if a certain value of an enumeration is available.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle          Handle for an entity that exposes features
//  [in ]  const char*          name            Name of the feature
//  [in ]  const char*          value           Value to check
//  [out]  VmbBool_t *          pIsAvailable    Indicates if the given enumeration value is available
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Enumeration
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "name" or "value" or "pIsAvailable" is NULL
//
public static native @Cast("const char*") BytePointer VmbFeatureEnumIsAvailable( VmbHandle_t handle,
                                                          @Cast("const char*") BytePointer name,
                                                          @Cast("const char*") BytePointer value,
                                                          @Cast("VmbBool_t*") BoolPointer pIsAvailable );
public static native String VmbFeatureEnumIsAvailable( VmbHandle_t handle,
                                                          String name,
                                                          String value,
                                                          @Cast("VmbBool_t*") boolean[] pIsAvailable );

//
// Method:      VmbFeatureEnumAsInt()
//
// Purpose:     Get the integer value for a given enumeration string value.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle     Handle for an entity that exposes features
//  [in ]  const char*          name       Name of the feature
//  [in ]  const char*          value      The enumeration value to get the integer value for
//  [out]  VmbInt64_t*          pIntVal    The integer value for this enumeration entry
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Enumeration
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "name" or "value" or "pIntVal" is NULL
//
// Details:     Converts a name of an enum member into an int value ("Mono12Packed" to 0x10C0006)
//
public static native @Cast("const char*") BytePointer VmbFeatureEnumAsInt( VmbHandle_t handle,
                                                    @Cast("const char*") BytePointer name,
                                                    @Cast("const char*") BytePointer value,
                                                    @Cast("VmbInt64_t*") LongPointer pIntVal );
public static native String VmbFeatureEnumAsInt( VmbHandle_t handle,
                                                    String name,
                                                    String value,
                                                    @Cast("VmbInt64_t*") LongBuffer pIntVal );
public static native @Cast("const char*") BytePointer VmbFeatureEnumAsInt( VmbHandle_t handle,
                                                    @Cast("const char*") BytePointer name,
                                                    @Cast("const char*") BytePointer value,
                                                    @Cast("VmbInt64_t*") long[] pIntVal );
public static native String VmbFeatureEnumAsInt( VmbHandle_t handle,
                                                    String name,
                                                    String value,
                                                    @Cast("VmbInt64_t*") LongPointer pIntVal );
public static native @Cast("const char*") BytePointer VmbFeatureEnumAsInt( VmbHandle_t handle,
                                                    @Cast("const char*") BytePointer name,
                                                    @Cast("const char*") BytePointer value,
                                                    @Cast("VmbInt64_t*") LongBuffer pIntVal );
public static native String VmbFeatureEnumAsInt( VmbHandle_t handle,
                                                    String name,
                                                    String value,
                                                    @Cast("VmbInt64_t*") long[] pIntVal );

//
// Method:      VmbFeatureEnumAsString()
//
// Purpose:     Get the enumeration string value for a given integer value.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle          Handle for an entity that exposes features
//  [in ]  const char*          name            Name of the feature
//  [in ]  VmbInt64_t           intValue        The numeric value
//  [out]  const char**         pStringValue    The string value for the numeric value
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Enumeration
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "name" or "pStringValue" is NULL
//
// Details:     Converts an int value to a name of an enum member (e.g. 0x10C0006 to "Mono12Packed")
//
public static native @Cast("const char*") BytePointer VmbFeatureEnumAsString( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       @Cast("VmbInt64_t") long intValue,
                                                       @Cast("const char**") PointerPointer pStringValue );
public static native @Cast("const char*") BytePointer VmbFeatureEnumAsString( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       @Cast("VmbInt64_t") long intValue,
                                                       @Cast("const char**") @ByPtrPtr BytePointer pStringValue );
public static native String VmbFeatureEnumAsString( VmbHandle_t handle,
                                                       String name,
                                                       @Cast("VmbInt64_t") long intValue,
                                                       @Cast("const char**") @ByPtrPtr ByteBuffer pStringValue );
public static native @Cast("const char*") BytePointer VmbFeatureEnumAsString( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       @Cast("VmbInt64_t") long intValue,
                                                       @Cast("const char**") @ByPtrPtr byte[] pStringValue );
public static native String VmbFeatureEnumAsString( VmbHandle_t handle,
                                                       String name,
                                                       @Cast("VmbInt64_t") long intValue,
                                                       @Cast("const char**") @ByPtrPtr BytePointer pStringValue );
public static native @Cast("const char*") BytePointer VmbFeatureEnumAsString( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       @Cast("VmbInt64_t") long intValue,
                                                       @Cast("const char**") @ByPtrPtr ByteBuffer pStringValue );
public static native String VmbFeatureEnumAsString( VmbHandle_t handle,
                                                       String name,
                                                       @Cast("VmbInt64_t") long intValue,
                                                       @Cast("const char**") @ByPtrPtr byte[] pStringValue );

//
// Method:      VmbFeatureEnumEntryGet()
//
// Purpose:     Get infos about an entry of an enumeration feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t        handle                  Handle for an entity that exposes features
//  [in ]  const char*              featureName             Name of the feature
//  [in ]  const char*              entryName               Name of the enum entry of that feature
//  [out]  VmbFeatureEnumEntry_t*   pFeatureEnumEntry       Infos about that entry returned by the API
//  [in]   VmbUint32_t              sizeofFeatureEnumEntry  Size of the structure
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorStructSize     Size of VmbFeatureEnumEntry_t is not compatible with the API version
//  - VmbErrorWrongType:     The type of feature "name" is not Enumeration
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "featureName" or "entryName" or "pFeatureEnumEntry" is NULL
//
public static native @Cast("const char*") BytePointer VmbFeatureEnumEntryGet( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer featureName,
                                                       @Cast("const char*") BytePointer entryName,
                                                       VmbFeatureEnumEntry_t pFeatureEnumEntry,
                                                       @Cast("VmbUint32_t") int sizeofFeatureEnumEntry );
public static native String VmbFeatureEnumEntryGet( VmbHandle_t handle,
                                                       String featureName,
                                                       String entryName,
                                                       VmbFeatureEnumEntry_t pFeatureEnumEntry,
                                                       @Cast("VmbUint32_t") int sizeofFeatureEnumEntry );

//-----String --------

//
// Method:      VmbFeatureStringGet()
//
// Purpose:     Get the value of a string feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle          Handle for an entity that exposes features
//  [in ]  const char*          name            Name of the string feature
//  [out]  char*                buffer          String buffer to fill. May be NULL if pSizeFilled is used for size query.
//  [in ]  VmbUint32_t          bufferSize      Size of the input buffer
//  [out]  VmbUint32_t*         pSizeFilled     Size actually filled. May be NULL if buffer is not NULL.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorMoreData:      The given buffer size was too small
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorWrongType:     The type of feature "name" is not String
//
// Details:     This function is usually called twice: once with an empty buffer to query the length
//              of the string, and then again with a buffer of the correct length.

public static native @Cast("const char*") BytePointer VmbFeatureStringGet( VmbHandle_t handle,
                                                    @Cast("const char*") BytePointer name,
                                                    @Cast("char*") BytePointer buffer,
                                                    @Cast("VmbUint32_t") int bufferSize,
                                                    @Cast("VmbUint32_t*") IntPointer pSizeFilled );
public static native String VmbFeatureStringGet( VmbHandle_t handle,
                                                    String name,
                                                    @Cast("char*") ByteBuffer buffer,
                                                    @Cast("VmbUint32_t") int bufferSize,
                                                    @Cast("VmbUint32_t*") IntBuffer pSizeFilled );
public static native @Cast("const char*") BytePointer VmbFeatureStringGet( VmbHandle_t handle,
                                                    @Cast("const char*") BytePointer name,
                                                    @Cast("char*") byte[] buffer,
                                                    @Cast("VmbUint32_t") int bufferSize,
                                                    @Cast("VmbUint32_t*") int[] pSizeFilled );
public static native String VmbFeatureStringGet( VmbHandle_t handle,
                                                    String name,
                                                    @Cast("char*") BytePointer buffer,
                                                    @Cast("VmbUint32_t") int bufferSize,
                                                    @Cast("VmbUint32_t*") IntPointer pSizeFilled );
public static native @Cast("const char*") BytePointer VmbFeatureStringGet( VmbHandle_t handle,
                                                    @Cast("const char*") BytePointer name,
                                                    @Cast("char*") ByteBuffer buffer,
                                                    @Cast("VmbUint32_t") int bufferSize,
                                                    @Cast("VmbUint32_t*") IntBuffer pSizeFilled );
public static native String VmbFeatureStringGet( VmbHandle_t handle,
                                                    String name,
                                                    @Cast("char*") byte[] buffer,
                                                    @Cast("VmbUint32_t") int bufferSize,
                                                    @Cast("VmbUint32_t*") int[] pSizeFilled );

//
// Method:    VmbFeatureStringSet()
//
// Purpose:   Set the value of a string feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the string feature
//  [in ]  const char*          value       Value to set
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorWrongType:     The type of feature "name" is not String
//  - VmbErrorInvalidValue:  If length of "value" exceeded the maximum length
//  - VmbErrorBadParameter:  If "name" or "value" is NULL
//  - VmbErrorInvalidCall:   If called from frame callback
//
public static native @Cast("const char*") BytePointer VmbFeatureStringSet( VmbHandle_t handle,
                                                    @Cast("const char*") BytePointer name,
                                                    @Cast("const char*") BytePointer value );
public static native String VmbFeatureStringSet( VmbHandle_t handle,
                                                    String name,
                                                    String value );

//
// Method:      VmbFeatureStringMaxlengthQuery()
//
// Purpose:     Get the maximum length of a string feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle        Handle for an entity that exposes features
//  [in ]  const char*          name          Name of the string feature
//  [out]  VmbUint32_t*         pMaxLength    Maximum length of this string feature
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not String
//  - VmbErrorBadParameter:  If "name" or "pMaxLength" is NULL
//
public static native @Cast("const char*") BytePointer VmbFeatureStringMaxlengthQuery( VmbHandle_t handle,
                                                               @Cast("const char*") BytePointer name,
                                                               @Cast("VmbUint32_t*") IntPointer pMaxLength );
public static native String VmbFeatureStringMaxlengthQuery( VmbHandle_t handle,
                                                               String name,
                                                               @Cast("VmbUint32_t*") IntBuffer pMaxLength );
public static native @Cast("const char*") BytePointer VmbFeatureStringMaxlengthQuery( VmbHandle_t handle,
                                                               @Cast("const char*") BytePointer name,
                                                               @Cast("VmbUint32_t*") int[] pMaxLength );
public static native String VmbFeatureStringMaxlengthQuery( VmbHandle_t handle,
                                                               String name,
                                                               @Cast("VmbUint32_t*") IntPointer pMaxLength );
public static native @Cast("const char*") BytePointer VmbFeatureStringMaxlengthQuery( VmbHandle_t handle,
                                                               @Cast("const char*") BytePointer name,
                                                               @Cast("VmbUint32_t*") IntBuffer pMaxLength );
public static native String VmbFeatureStringMaxlengthQuery( VmbHandle_t handle,
                                                               String name,
                                                               @Cast("VmbUint32_t*") int[] pMaxLength );

//-----Boolean --------

//
// Method:      VmbFeatureBoolGet()
//
// Purpose:     Get the value of a boolean feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle    Handle for an entity that exposes features
//  [in ]  const char*          name      Name of the boolean feature
//  [out]  VmbBool_t *          pValue    Value to be read
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Boolean
//  - VmbErrorNotFound:      If feature is not found
//  - VmbErrorBadParameter:  If "name" or "pValue" is NULL
//
public static native @Cast("const char*") BytePointer VmbFeatureBoolGet( VmbHandle_t handle,
                                                  @Cast("const char*") BytePointer name,
                                                  @Cast("VmbBool_t*") BoolPointer pValue );
public static native String VmbFeatureBoolGet( VmbHandle_t handle,
                                                  String name,
                                                  @Cast("VmbBool_t*") boolean[] pValue );

//
// Method:      VmbFeatureBoolSet()
//
// Purpose:     Set the value of a boolean feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the boolean feature
//  [in ]  VmbBool_t            value       Value to write
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Boolean
//  - VmbErrorInvalidValue:  If "value" is not within valid bounds
//  - VmbErrorNotFound:      If the feature is not found
//  - VmbErrorBadParameter:  If "name" is NULL
//  - VmbErrorInvalidCall:   If called from frame callback
//
public static native @Cast("const char*") BytePointer VmbFeatureBoolSet( VmbHandle_t handle,
                                                  @Cast("const char*") BytePointer name,
                                                  @Cast("VmbBool_t") boolean value );
public static native String VmbFeatureBoolSet( VmbHandle_t handle,
                                                  String name,
                                                  @Cast("VmbBool_t") boolean value );

//-----Command ------

//
// Method:    VmbFeatureCommandRun()
//
// Purpose:   Run a feature command.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the command feature
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Command
//  - VmbErrorNotFound:      Feature was not found
//  - VmbErrorBadParameter:  If "name" is NULL
//
public static native @Cast("const char*") BytePointer VmbFeatureCommandRun( VmbHandle_t handle,
                                                     @Cast("const char*") BytePointer name );
public static native String VmbFeatureCommandRun( VmbHandle_t handle,
                                                     String name );

//
// Method:      VmbFeatureCommandIsDone()
//
// Purpose:     Check if a feature command is done.
//
// Parameters:
//
//  [in ]     const VmbHandle_t handle     Handle for an entity that exposes features
//  [in ]     const char*       name       Name of the command feature
//  [out]     VmbBool_t *       pIsDone    State of the command.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Command
//  - VmbErrorNotFound:      Feature was not found
//  - VmbErrorBadParameter:  If "name" or "pIsDone" is NULL
//
public static native @Cast("const char*") BytePointer VmbFeatureCommandIsDone( VmbHandle_t handle,
                                                        @Cast("const char*") BytePointer name,
                                                        @Cast("VmbBool_t*") BoolPointer pIsDone );
public static native String VmbFeatureCommandIsDone( VmbHandle_t handle,
                                                        String name,
                                                        @Cast("VmbBool_t*") boolean[] pIsDone );

//-----Raw --------

//
// Method:      VmbFeatureRawGet()
//
// Purpose:     Read the memory contents of an area given by a feature name.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle         Handle for an entity that exposes features
//  [in ]  const char*          name           Name of the raw feature
//  [out]  char*                pBuffer        Buffer to fill
//  [in ]  VmbUint32_t          bufferSize     Size of the buffer to be filled
//  [out]  VmbUint32_t*         pSizeFilled    Number of bytes actually filled
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Register
//  - VmbErrorNotFound:      Feature was not found
//  - VmbErrorBadParameter:  If "name" or "pBuffer" or "pSizeFilled" is NULL
//
// Details:     This feature type corresponds to a top-level "Register" feature in GenICam.
//              Data transfer is split up by the transport layer if the feature length is too large.
//              You can get the size of the memory area addressed by the feature "name" by VmbFeatureRawLengthQuery().
//
public static native @Cast("const char*") BytePointer VmbFeatureRawGet( VmbHandle_t handle,
                                                 @Cast("const char*") BytePointer name,
                                                 @Cast("char*") BytePointer pBuffer,
                                                 @Cast("VmbUint32_t") int bufferSize,
                                                 @Cast("VmbUint32_t*") IntPointer pSizeFilled );
public static native String VmbFeatureRawGet( VmbHandle_t handle,
                                                 String name,
                                                 @Cast("char*") ByteBuffer pBuffer,
                                                 @Cast("VmbUint32_t") int bufferSize,
                                                 @Cast("VmbUint32_t*") IntBuffer pSizeFilled );
public static native @Cast("const char*") BytePointer VmbFeatureRawGet( VmbHandle_t handle,
                                                 @Cast("const char*") BytePointer name,
                                                 @Cast("char*") byte[] pBuffer,
                                                 @Cast("VmbUint32_t") int bufferSize,
                                                 @Cast("VmbUint32_t*") int[] pSizeFilled );
public static native String VmbFeatureRawGet( VmbHandle_t handle,
                                                 String name,
                                                 @Cast("char*") BytePointer pBuffer,
                                                 @Cast("VmbUint32_t") int bufferSize,
                                                 @Cast("VmbUint32_t*") IntPointer pSizeFilled );
public static native @Cast("const char*") BytePointer VmbFeatureRawGet( VmbHandle_t handle,
                                                 @Cast("const char*") BytePointer name,
                                                 @Cast("char*") ByteBuffer pBuffer,
                                                 @Cast("VmbUint32_t") int bufferSize,
                                                 @Cast("VmbUint32_t*") IntBuffer pSizeFilled );
public static native String VmbFeatureRawGet( VmbHandle_t handle,
                                                 String name,
                                                 @Cast("char*") byte[] pBuffer,
                                                 @Cast("VmbUint32_t") int bufferSize,
                                                 @Cast("VmbUint32_t*") int[] pSizeFilled );

//
// Method:      VmbFeatureRawSet()
//
// Purpose:     Write to a memory area given by a feature name.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the raw feature
//  [in ]  const char*          pBuffer     Data buffer to use
//  [in ]  VmbUint32_t          bufferSize  Size of the buffer
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Register
//  - VmbErrorNotFound:      Feature was not found
//  - VmbErrorBadParameter:  If "name" or "pBuffer" is NULL
//  - VmbErrorInvalidCall:   If called from frame callback
//
// Details:     This feature type corresponds to a first-level "Register" node in the XML file.
//              Data transfer is split up by the transport layer if the feature length is too large.
//              You can get the size of the memory area addressed by the feature "name" by VmbFeatureRawLengthQuery().
//
public static native @Cast("const char*") BytePointer VmbFeatureRawSet( VmbHandle_t handle,
                                                 @Cast("const char*") BytePointer name,
                                                 @Cast("const char*") BytePointer pBuffer,
                                                 @Cast("VmbUint32_t") int bufferSize );
public static native String VmbFeatureRawSet( VmbHandle_t handle,
                                                 String name,
                                                 String pBuffer,
                                                 @Cast("VmbUint32_t") int bufferSize );

//
// Method:      VmbFeatureRawLengthQuery()
//
// Purpose:     Get the length of a raw feature for memory transfers.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the raw feature
//  [out]  VmbUint32_t*         pLength     Length of the raw feature area (in bytes)
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Register
//  - VmbErrorNotFound:      Feature not found
//  - VmbErrorBadParameter:  If "name" or "pLength" is NULL
//
// Details:     This feature type corresponds to a first-level "Register" node in the XML file.
//
public static native @Cast("const char*") BytePointer VmbFeatureRawLengthQuery( VmbHandle_t handle,
                                                         @Cast("const char*") BytePointer name,
                                                         @Cast("VmbUint32_t*") IntPointer pLength );
public static native String VmbFeatureRawLengthQuery( VmbHandle_t handle,
                                                         String name,
                                                         @Cast("VmbUint32_t*") IntBuffer pLength );
public static native @Cast("const char*") BytePointer VmbFeatureRawLengthQuery( VmbHandle_t handle,
                                                         @Cast("const char*") BytePointer name,
                                                         @Cast("VmbUint32_t*") int[] pLength );
public static native String VmbFeatureRawLengthQuery( VmbHandle_t handle,
                                                         String name,
                                                         @Cast("VmbUint32_t*") IntPointer pLength );
public static native @Cast("const char*") BytePointer VmbFeatureRawLengthQuery( VmbHandle_t handle,
                                                         @Cast("const char*") BytePointer name,
                                                         @Cast("VmbUint32_t*") IntBuffer pLength );
public static native String VmbFeatureRawLengthQuery( VmbHandle_t handle,
                                                         String name,
                                                         @Cast("VmbUint32_t*") int[] pLength );

//----- Feature invalidation --------------------------------------------------------

//
// Method:      VmbFeatureInvalidationRegister()
//
// Purpose:     Register a VmbInvalidationCallback callback for feature invalidation signaling.
//
// Parameters:
//
//  [in ]  const VmbHandle_t        handle          Handle for an entity that emits events
//  [in ]  const char*              name            Name of the event
//  [in ]  VmbInvalidationCallback  callback        Callback to be run, when invalidation occurs
//  [in ]  void*                    pUserContext    User context passed to function
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//
// Details:     Any feature change, either of its value or of its access state, may be tracked
//              by registering an invalidation callback.
//              Registering multiple callbacks for one feature invalidation event is possible because
//              only the combination of handle, name, and callback is used as key. If the same
//              combination of handle, name, and callback is registered a second time, it overwrites
//              the previous one.
//
public static native @Cast("const char*") BytePointer VmbFeatureInvalidationRegister( VmbHandle_t handle,
                                                               @Cast("const char*") BytePointer name,
                                                               VmbInvalidationCallback callback,
                                                               Pointer pUserContext );
public static native String VmbFeatureInvalidationRegister( VmbHandle_t handle,
                                                               String name,
                                                               VmbInvalidationCallback callback,
                                                               Pointer pUserContext );

//
// Method:      VmbFeatureInvalidationUnregister()
//
// Purpose:     Unregister a previously registered feature invalidation callback.
//
// Parameters:
//
//  [in ]  const VmbHandle_t        handle          Handle for an entity that emits events
//  [in ]  const char*              name            Name of the event
//  [in ]  VmbInvalidationCallback  callback        Callback to be removed
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//
// Details:     Since multiple callbacks may be registered for a feature invalidation event,
//              a combination of handle, name, and callback is needed for unregistering, too.
//
public static native @Cast("const char*") BytePointer VmbFeatureInvalidationUnregister( VmbHandle_t handle,
                                                                 @Cast("const char*") BytePointer name,
                                                                 VmbInvalidationCallback callback );
public static native String VmbFeatureInvalidationUnregister( VmbHandle_t handle,
                                                                 String name,
                                                                 VmbInvalidationCallback callback );


//-----  Image preparation and acquisition ---------------------------------------------------

//
// Method:      VmbFrameAnnounce()
//
// Purpose:     Announce frames to the API that may be queued for frame capturing later.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    cameraHandle    Handle for a camera
//  [in ]  const VmbFrame_t*    pFrame          Frame buffer to announce
//  [in ]  VmbUint32_t          sizeofFrame     Size of the frame structure
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given camera handle is not valid
//  - VmbErrorBadParameter:  The given frame pointer is not valid or "sizeofFrame" is 0
//  - VmbErrorStructSize:    The given struct size is not valid for this version of the API
//
// Details:     Allows some preparation for frames like DMA preparation depending on the transport layer.
//              The order in which the frames are announced is not taken into consideration by the API.
//
public static native @Cast("const char*") BytePointer VmbFrameAnnounce( VmbHandle_t cameraHandle,
                                                 @Const VmbFrame_t pFrame,
                                                 @Cast("VmbUint32_t") int sizeofFrame );


//
// Method:      VmbFrameRevoke()
//
// Purpose:     Revoke a frame from the API.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    cameraHandle    Handle for a camera
//  [in ]  const VmbFrame_t*    pFrame          Frame buffer to be removed from the list of announced frames
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given camera handle is not valid
//  - VmbErrorBadParameter:  The given frame pointer is not valid
//  - VmbErrorStructSize:    The given struct size is not valid for this version of the API
//
// Details:    The referenced frame is removed from the pool of frames for capturing images.
//
public static native @Cast("const char*") BytePointer VmbFrameRevoke( VmbHandle_t cameraHandle,
                                               @Const VmbFrame_t pFrame );


//
// Method:      VmbFrameRevokeAll()
//
// Purpose:     Revoke all frames assigned to a certain camera.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    cameraHandle    Handle for a camera
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given camera handle is not valid
//
public static native @Cast("const char*") BytePointer VmbFrameRevokeAll( VmbHandle_t cameraHandle );


//
// Method:      VmbCaptureStart()
//
// Purpose:     Prepare the API for incoming frames.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    cameraHandle    Handle for a camera
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorDeviceNotOpen: Camera was not opened for usage
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//
public static native @Cast("const char*") BytePointer VmbCaptureStart( VmbHandle_t cameraHandle );


//
// Method:      VmbCaptureEnd()
//
// Purpose:     Stop the API from being able to receive frames.
//
// Parameters:
//
//  [in ]  const VmbHandle_t  cameraHandle    Handle for a camera
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//
// Details:     Consequences of VmbCaptureEnd():
//                  - The frame callback will not be called anymore
//
public static native @Cast("const char*") BytePointer VmbCaptureEnd( VmbHandle_t cameraHandle );


//
// Method:      VmbCaptureFrameQueue()
//
// Purpose:     Queue frames that may be filled during frame capturing.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    cameraHandle    Handle of the camera
//  [in ]  const VmbFrame_t*    pFrame          Pointer to an already announced frame
//  [in ]  VmbFrameCallback     callback        Callback to be run when the frame is complete.  NULL is Ok.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given frame is not valid
//  - VmbErrorStructSize:    The given struct size is not valid for this version of the API
//
// Details:     The given frame is put into a queue that will be filled sequentially.
//              The order in which the frames are filled is determined by the order in which they are queued.
//              If the frame was announced with VmbFrameAnnounce() before, the application
//              has to ensure that the frame is also revoked by calling VmbFrameRevoke() or
//              VmbFrameRevokeAll() when cleaning up.
//
public static native @Cast("const char*") BytePointer VmbCaptureFrameQueue( VmbHandle_t cameraHandle,
                                                     @Const VmbFrame_t pFrame,
                                                     VmbFrameCallback callback );


//
// Method:      VmbCaptureFrameWait()
//
// Purpose:     Wait for a queued frame to be filled (or dequeued).
//
// Parameters:
//
//  [in ]  const VmbHandle_t    cameraHandle    Handle of the camera
//  [in ]  const VmbFrame_t*    pFrame          Pointer to an already announced & queued frame
//  [in ]  VmbUint32_t          timeout         Timeout (in milliseconds)
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorTimeout:       Call timed out
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//
public static native @Cast("const char*") BytePointer VmbCaptureFrameWait( VmbHandle_t cameraHandle,
                                                    @Const VmbFrame_t pFrame,
                                                    @Cast("VmbUint32_t") int timeout);


//
// Method:      VmbCaptureQueueFlush()
//
// Purpose:     Flush the capture queue.
//
// Parameters:
//
//  [in ]  const VmbHandle_t cameraHandle   Handle of the camera to flush
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//
// Details:     Control of all the currently queued frames will be returned to the user,
//              leaving no frames in the capture queue.
//              After this call, no frame notification will occur until frames are queued again.
//
public static native @Cast("const char*") BytePointer VmbCaptureQueueFlush( VmbHandle_t cameraHandle );


//----- Interface Enumeration & Information --------------------------------------

//
// Method:      VmbInterfacesList()
//
// Purpose:     List all the interfaces currently visible to VimbaC.
//
// Parameters:
//
//  [out]  VmbInterfaceInfo_t*  pInterfaceInfo          Array of VmbInterfaceInfo_t, allocated by the caller.
//                                                      The interface list is copied here. May be NULL.
//  [in ]  VmbUint32_t          listLength              Number of entries in the caller's pList array
//  [out]  VmbUint32_t*         pNumFound               Number of interfaces found (may be more than
//                                                      listLength!) returned here.
//  [in ]  VmbUint32_t          sizeofInterfaceInfo     Size of one VmbInterfaceInfo_t entry
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorStructSize:    The given struct size is not valid for this API version
//  - VmbErrorMoreData:      The given list length was insufficient to hold all available entries
//  - VmbErrorBadParameter:  If "pNumFound" was NULL
//
// Details:     All the interfaces known via GenICam TransportLayers are listed by this 
//              command and filled into the provided array. Interfaces may correspond to 
//              adapter cards or frame grabber cards or, in the case of FireWire to the 
//              whole 1394 infrastructure, for instance.
//              This function is usually called twice: once with an empty array to query the length
//              of the list, and then again with an array of the correct length.
//
public static native @Cast("const char*") BytePointer VmbInterfacesList( VmbInterfaceInfo_t pInterfaceInfo,
                                                  @Cast("VmbUint32_t") int listLength,
                                                  @Cast("VmbUint32_t*") IntPointer pNumFound,
                                                  @Cast("VmbUint32_t") int sizeofInterfaceInfo );
public static native String VmbInterfacesList( VmbInterfaceInfo_t pInterfaceInfo,
                                                  @Cast("VmbUint32_t") int listLength,
                                                  @Cast("VmbUint32_t*") IntBuffer pNumFound,
                                                  @Cast("VmbUint32_t") int sizeofInterfaceInfo );
public static native @Cast("const char*") BytePointer VmbInterfacesList( VmbInterfaceInfo_t pInterfaceInfo,
                                                  @Cast("VmbUint32_t") int listLength,
                                                  @Cast("VmbUint32_t*") int[] pNumFound,
                                                  @Cast("VmbUint32_t") int sizeofInterfaceInfo );

//
// Method:      VmbInterfaceOpen()
//
// Purpose:     Open an interface handle for feature access.
//
// Parameters:
//
//  [in ]  const char*      idString           The ID of the interface to get the handle for
//                                             (returned by VmbInterfacesList())
//  [out]  VmbHandle_t*     pInterfaceHandle   The handle for this interface.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorNotFound:      The designated interface cannot be found
//  - VmbErrorBadParameter:  If "pInterfaceHandle" was NULL
//
// Details:     An interface can be opened if interface-specific control or information
//              is required, e.g. the number of devices attached to a specific interface.
//              Access is then possible via feature access methods.
//
public static native @Cast("const char*") BytePointer VmbInterfaceOpen( @Cast("const char*") BytePointer idString,
                                                 @ByPtrPtr VmbHandle_t pInterfaceHandle );
public static native String VmbInterfaceOpen( String idString,
                                                 @ByPtrPtr VmbHandle_t pInterfaceHandle );

//
// Method:      VmbInterfaceClose()
//
// Purpose:     Close an interface.
//
// Parameters:
//
//  [in ]  const VmbHandle_t   interfaceHandle    The handle of the interface to close.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//
// Details:     After configuration of the interface, close it by calling this function.
//
public static native @Cast("const char*") BytePointer VmbInterfaceClose( VmbHandle_t interfaceHandle );


//----- Ancillary data --------------------------------------------------------

//
// Method:      VmbAncillaryDataOpen()
//
// Purpose:     Get a working handle to allow access to the elements of the ancillary data via feature access.
//
// Parameters:
//
//  [in ]  VmbFrame_t*   pFrame                 Pointer to a filled frame
//  [out]  VmbHandle_t*  pAncillaryDataHandle   Handle to the ancillary data inside the frame
//
// Returns:
//
//  - VmbErrorSuccess:			No error
//  - VmbErrorBadHandle:		Chunk mode of the camera was not activated. See feature ChunkModeActive
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//
// Details:     This function can only succeed if the given frame has been filled by the API.
//
public static native @Cast("const char*") BytePointer VmbAncillaryDataOpen( VmbFrame_t pFrame,
                                                     @ByPtrPtr VmbHandle_t pAncillaryDataHandle );

//
// Method:      VmbAncillaryDataClose()
//
// Purpose:     Destroy the working handle to the ancillary data inside a frame.
//
// Parameters:
//
//  [in ]  VmbHandle_t  ancillaryDataHandle  Handle to ancillary frame data
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//
// Details:     After reading the ancillary data and before re-queuing the frame, ancillary data
//              must be closed.
//
public static native @Cast("const char*") BytePointer VmbAncillaryDataClose( VmbHandle_t ancillaryDataHandle );


//----- Memory/Register access --------------------------------------------
//----- Memory/Register access --------------------------------------------

//
// Method:      VmbMemoryRead()
//
// Purpose:     Read an array of bytes.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle          Handle for an entity that allows memory access
//  [in ]  VmbUint64_t          address         Address to be used for this read operation
//  [in ]  VmbUint32_t          bufferSize      Size of the data buffer to read
//  [out]  char*                dataBuffer      Buffer to be filled
//  [out]  VmbUint32_t*         pSizeComplete   Size of the data actually read
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//
public static native @Cast("const char*") BytePointer VmbMemoryRead( VmbHandle_t handle,
                                              @Cast("VmbUint64_t") int address,
                                              @Cast("VmbUint32_t") int bufferSize,
                                              @Cast("char*") BytePointer dataBuffer,
                                              @Cast("VmbUint32_t*") IntPointer pSizeComplete );
public static native String VmbMemoryRead( VmbHandle_t handle,
                                              @Cast("VmbUint64_t") int address,
                                              @Cast("VmbUint32_t") int bufferSize,
                                              @Cast("char*") ByteBuffer dataBuffer,
                                              @Cast("VmbUint32_t*") IntBuffer pSizeComplete );
public static native @Cast("const char*") BytePointer VmbMemoryRead( VmbHandle_t handle,
                                              @Cast("VmbUint64_t") int address,
                                              @Cast("VmbUint32_t") int bufferSize,
                                              @Cast("char*") byte[] dataBuffer,
                                              @Cast("VmbUint32_t*") int[] pSizeComplete );

//
// Method:      VmbMemoryWrite()
//
// Purpose:     Write an array of bytes.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle          Handle for an entity that allows memory access
//  [in ]  VmbUint64_t          address         Address to be used for this read operation
//  [in ]  VmbUint32_t          bufferSize      Size of the data buffer to write
//  [in ]  const char*          dataBuffer      Data to write
//  [out]  VmbUint32_t*         pSizeComplete   Number of bytes successfully written; if an
//                                              error occurs this is less than bufferSize
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorMoreData:      Not all data were written; see pSizeComplete value for the number of bytes written
//
public static native @Cast("const char*") BytePointer VmbMemoryWrite( VmbHandle_t handle,
                                               @Cast("VmbUint64_t") int address,
                                               @Cast("VmbUint32_t") int bufferSize,
                                               @Cast("const char*") BytePointer dataBuffer,
                                               @Cast("VmbUint32_t*") IntPointer pSizeComplete );
public static native String VmbMemoryWrite( VmbHandle_t handle,
                                               @Cast("VmbUint64_t") int address,
                                               @Cast("VmbUint32_t") int bufferSize,
                                               String dataBuffer,
                                               @Cast("VmbUint32_t*") IntBuffer pSizeComplete );
public static native @Cast("const char*") BytePointer VmbMemoryWrite( VmbHandle_t handle,
                                               @Cast("VmbUint64_t") int address,
                                               @Cast("VmbUint32_t") int bufferSize,
                                               @Cast("const char*") BytePointer dataBuffer,
                                               @Cast("VmbUint32_t*") int[] pSizeComplete );
public static native String VmbMemoryWrite( VmbHandle_t handle,
                                               @Cast("VmbUint64_t") int address,
                                               @Cast("VmbUint32_t") int bufferSize,
                                               String dataBuffer,
                                               @Cast("VmbUint32_t*") IntPointer pSizeComplete );
public static native @Cast("const char*") BytePointer VmbMemoryWrite( VmbHandle_t handle,
                                               @Cast("VmbUint64_t") int address,
                                               @Cast("VmbUint32_t") int bufferSize,
                                               @Cast("const char*") BytePointer dataBuffer,
                                               @Cast("VmbUint32_t*") IntBuffer pSizeComplete );
public static native String VmbMemoryWrite( VmbHandle_t handle,
                                               @Cast("VmbUint64_t") int address,
                                               @Cast("VmbUint32_t") int bufferSize,
                                               String dataBuffer,
                                               @Cast("VmbUint32_t*") int[] pSizeComplete );

//
// Method:      VmbRegistersRead()
//
// Purpose:     Read an array of registers.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle              Handle for an entity that allows register access
//  [in ]  VmbUint32_t          readCount           Number of registers to be read
//  [in ]  const VmbUint64_t*   pAddressArray       Array of addresses to be used for this read operation
//  [out]  VmbUint64_t*         pDataArray          Array of registers to be used for this read operation
//  [out]  VmbUint32_t*         pNumCompleteReads   Number of reads completed
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorIncomplete:    Not all the requested reads could be completed
//
// Details:     Two arrays of data must be provided: an array of register addresses and one
//              for corresponding values to be read. The registers are read consecutively
//              until an error occurs or all registers are written successfully.
//
public static native @Cast("const char*") BytePointer VmbRegistersRead( VmbHandle_t handle,
                                                 @Cast("VmbUint32_t") int readCount,
                                                 @Cast("const VmbUint64_t*") IntPointer pAddressArray,
                                                 @Cast("VmbUint64_t*") IntPointer pDataArray,
                                                 @Cast("VmbUint32_t*") IntPointer pNumCompleteReads );
public static native String VmbRegistersRead( VmbHandle_t handle,
                                                 @Cast("VmbUint32_t") int readCount,
                                                 @Cast("const VmbUint64_t*") IntBuffer pAddressArray,
                                                 @Cast("VmbUint64_t*") IntBuffer pDataArray,
                                                 @Cast("VmbUint32_t*") IntBuffer pNumCompleteReads );
public static native @Cast("const char*") BytePointer VmbRegistersRead( VmbHandle_t handle,
                                                 @Cast("VmbUint32_t") int readCount,
                                                 @Cast("const VmbUint64_t*") int[] pAddressArray,
                                                 @Cast("VmbUint64_t*") int[] pDataArray,
                                                 @Cast("VmbUint32_t*") int[] pNumCompleteReads );

//
// Method:      VmbRegistersWrite()
//
// Purpose:     Write an array of registers.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle                  Handle for an entity that allows register access
//  [in ]  VmbUint32_t          writeCount              Number of registers to be written
//  [in ]  const VmbUint64_t*   pAddressArray           Array of addresses to be used for this write operation
//  [in ]  const VmbUint64_t*   pDataArray              Array of reads to be used for this write operation
//  [out]  VmbUint32_t*         pNumCompleteWrites      Number of writes completed
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorIncomplete:    Not all the requested writes could be completed
//
// Details:     Two arrays of data must be provided: an array of register addresses and one with the
//              corresponding values to be written to these addresses. The registers are written
//              consecutively until an error occurs or all registers are written successfully.
//
public static native @Cast("const char*") BytePointer VmbRegistersWrite( VmbHandle_t handle,
                                                  @Cast("VmbUint32_t") int writeCount,
                                                  @Cast("const VmbUint64_t*") IntPointer pAddressArray,
                                                  @Cast("const VmbUint64_t*") IntPointer pDataArray,
                                                  @Cast("VmbUint32_t*") IntPointer pNumCompleteWrites );
public static native String VmbRegistersWrite( VmbHandle_t handle,
                                                  @Cast("VmbUint32_t") int writeCount,
                                                  @Cast("const VmbUint64_t*") IntBuffer pAddressArray,
                                                  @Cast("const VmbUint64_t*") IntBuffer pDataArray,
                                                  @Cast("VmbUint32_t*") IntBuffer pNumCompleteWrites );
public static native @Cast("const char*") BytePointer VmbRegistersWrite( VmbHandle_t handle,
                                                  @Cast("VmbUint32_t") int writeCount,
                                                  @Cast("const VmbUint64_t*") int[] pAddressArray,
                                                  @Cast("const VmbUint64_t*") int[] pDataArray,
                                                  @Cast("VmbUint32_t*") int[] pNumCompleteWrites );

//
// Method:      VmbCameraSettingsSave()
//
// Purpose:     Saves all feature values to XML file.
//
// Parameters:
//
//  [in ]  const VmbHandle_t             handle              Handle for an entity that allows register access
//  [in ]  const char*                   fileName            Name of XML file to save settings
//  [in ]  VmbFeaturePersistSettings_t*  pSettings           Settings struct
//  [in ]  VmbUint32_t                   sizeofSettings      Size of settings struct
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorBadParameter:  If "fileName" is NULL
//
// Details:     Camera must be opened beforehand and function needs corresponding handle.
//              With given filename parameter path and name of XML file can be determined.
//              Additionally behaviour of function can be set with providing 'persistent struct'.
//
public static native @Cast("const char*") BytePointer VmbCameraSettingsSave( VmbHandle_t handle, 
                                                      @Cast("const char*") BytePointer fileName, 
                                                      VmbFeaturePersistSettings_t pSettings, 
                                                      @Cast("VmbUint32_t") int sizeofSettings );
public static native String VmbCameraSettingsSave( VmbHandle_t handle, 
                                                      String fileName, 
                                                      VmbFeaturePersistSettings_t pSettings, 
                                                      @Cast("VmbUint32_t") int sizeofSettings );

//
// Method:      VmbCameraSettingsLoad()
//
// Purpose:     Load all feature values from XML file to device.
//
// Parameters:
//
//  [in ]  const VmbHandle_t             handle              Handle for an entity that allows register access
//  [in ]  const char*                   fileName            Name of XML file to save settings
//  [in ]  VmbFeaturePersistSettings_t*  pSettings           Settings struct
//  [in ]  VmbUint32_t                   sizeofSettings      Size of settings struct
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorBadParameter:  If "fileName" is NULL
//
// Details:     Camera must be opened beforehand and function needs corresponding handle.
//              With given filename parameter path and name of XML file can be determined.
//              Additionally behaviour of function can be set with providing 'settings struct'.
//
public static native @Cast("const char*") BytePointer VmbCameraSettingsLoad( VmbHandle_t handle, 
                                                      @Cast("const char*") BytePointer fileName, 
                                                      VmbFeaturePersistSettings_t pSettings, 
                                                      @Cast("VmbUint32_t") int sizeofSettings );
public static native String VmbCameraSettingsLoad( VmbHandle_t handle, 
                                                      String fileName, 
                                                      VmbFeaturePersistSettings_t pSettings, 
                                                      @Cast("VmbUint32_t") int sizeofSettings );

// #ifdef __cplusplus
// #endif

// #endif // VIMBAC_H_INCLUDE_


// Parsed from <VimbaCPP/Include/VimbaCPPCommon.h>

/*=============================================================================
  Copyright (C) 2012 - 2017 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        VimbaCPPCommon.h

  Description: Common type definitions used in Vimba CPP API.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_CPPCOMMON_H
// #define AVT_VMBAPI_CPPCOMMON_H

// #if defined (_WIN32)
// #elif defined (__GNUC__) && (__GNUC__ >= 4) && defined (__ELF__)
//     #define IMEXPORT
// #elif defined (__APPLE__)
//     #define IMEXPORT
// #else
//     #error Unknown platform, file needs adaption
// #endif

// #include <vector>
// #include <string>
// #include "VimbaC/Include/VmbCommonTypes.h"

/** enum AVT::VmbAPI::UpdateTriggerType */
public static final int
    UpdateTriggerPluggedIn           = 0,           // A new camera was discovered by Vimba
    UpdateTriggerPluggedOut          = 1,           // A camera has disappeared from the bus
    UpdateTriggerOpenStateChanged    = 3;            // The possible opening mode of a camera has changed (e.g., because it was opened by another application)

 // AVT::VmbAPI

// #endif

// Parsed from <VimbaCPP/Include/UserSharedPointerDefines.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        UserSharedPointerDefines.h

  Description: Definition of macros for using different shared pointer 
               implementations.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_USERSHAREDPOINTERDEFINES_H
// #define AVT_VMBAPI_USERSHAREDPOINTERDEFINES_H

// 
// Vimba C++ API does not necessarily rely on AVT::VmbAPI::shared_ptr. You might want to use your own shared pointer type or the one that ships with your
// implementation of the C++ standard.
// To use a custom shared pointer implementation simply add the define USER_SHARED_POINTER to your project / compiler settings and complete this header file.
//


// Add all your required shared pointer implementation headers here.
// HINT: #include <memory> is used for std::shared_ptr

// Set the calls for your implementation of the shared pointer functions
// a) Declaration
// b) Reset with argument
// c) Reset without argument
// d) == operator
// e) NULL test
// f) Access to underlying raw pointer
// g) Dynamic cast of shared pointer

// a) This is the define for a declaration.
// #define SP_DECL( T )            std::shared_ptr<T>
// b) This is the define for setting an existing shared pointer.
// #define SP_SET( sp, rawPtr )    (sp).reset( rawPtr )
// c) This is the define for resetting without an argument to decrease the ref count.
// #define SP_RESET( sp )          (sp).reset()
// d) This is the define for the equal operator. Shared pointers are usually considered equal when the raw pointers point to the same address.
// #define SP_ISEQUAL( sp1, sp2 )  ( (sp1) == (sp2) )
// e) This is the define for the NULL check.
// #define SP_ISNULL( sp )         ( NULL == (sp) )
// f) This is the define for the raw pointer access. This is usually accomplished through the dereferencing operator (->).
// #define SP_ACCESS( sp )         (sp).get()
// g) This is the define for the dynamic cast of the pointer.
// #define SP_DYN_CAST( sp, T )    std::dynamic_pointer_cast<T>(sp)

// These are all uses of a SP_DECL shared_ptr declaration

@Namespace("AVT::VmbAPI") @Opaque public static class FrameHandler extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public FrameHandler() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FrameHandler(Pointer p) { super(p); }
}

@Namespace("AVT::VmbAPI") @Opaque public static class ConstAncillaryData extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ConstAncillaryData() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ConstAncillaryData(Pointer p) { super(p); }
}

 // Namespace AVT::VmbAPI
   

// #endif //AVT_VMBAPI_USERSHAREDPOINTERDEFINES_H


// Parsed from <VimbaCPP/Include/Mutex.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        Mutex.h

  Description: Definition of class AVT::VmbAPI::Mutex.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_MUTEX
// #define AVT_VMBAPI_MUTEX

// #include <VimbaCPP/Include/VimbaCPPCommon.h>

// #ifdef _WIN32
//     #include <windows.h>
// #else
//     #include <pthread.h>
// #endif

@Namespace("AVT::VmbAPI") @NoOffset public static class Mutex extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Mutex(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Mutex(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Mutex position(long position) {
        return (Mutex)super.position(position);
    }

    public Mutex( @Cast("bool") boolean bInitLock/*=false*/ ) { super((Pointer)null); allocate(bInitLock); }
    private native void allocate( @Cast("bool") boolean bInitLock/*=false*/ );
    public Mutex( ) { super((Pointer)null); allocate(); }
    private native void allocate( );

    public native void Lock();
    public native void Unlock();
}

 //namespace AVT::VmbAPI

// #endif //AVT_VMBAPI_MUTEX


// Parsed from <VimbaCPP/Include/BasicLockable.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        BasicLockable.h

  Description: Definition of class AVT::VmbAPI::BasicLockable.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_BASICLOCKABLE
// #define AVT_VMBAPI_BASICLOCKABLE

// #include <VimbaCPP/Include/VimbaCPPCommon.h>
// #include <VimbaCPP/Include/SharedPointerDefines.h>
// #include <VimbaCPP/Include/Mutex.h>

@Namespace("AVT::VmbAPI") @NoOffset public static class BasicLockable extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public BasicLockable(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public BasicLockable(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public BasicLockable position(long position) {
        return (BasicLockable)super.position(position);
    }

    public BasicLockable() { super((Pointer)null); allocate(); }
    private native void allocate();
    public BasicLockable( @SharedPtr @ByVal Mutex pMutex ) { super((Pointer)null); allocate(pMutex); }
    private native void allocate( @SharedPtr @ByVal Mutex pMutex );

    public native @SharedPtr @ByVal Mutex GetMutex();

    public native void Lock();
    public native void Unlock();
}

 //namespace AVT::VmbAPI

// #endif 

// Parsed from <VimbaCPP/Include/AncillaryData.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        AncillaryData.h

  Description: Definition of class AVT::VmbAPI::AncillaryData.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_ANCILLARYDATA_H
// #define AVT_VMBAPI_ANCILLARYDATA_H

// #include <VimbaC/Include/VmbCommonTypes.h>
// #include <VimbaCPP/Include/VimbaCPPCommon.h>
// #include <VimbaCPP/Include/FeatureContainer.h>

@Namespace("AVT::VmbAPI") @NoOffset public static class AncillaryData extends FeatureContainer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AncillaryData(Pointer p) { super(p); }

    public AncillaryData( VmbFrame_t pFrame ) { super((Pointer)null); allocate(pFrame); }
    private native void allocate( VmbFrame_t pFrame );

    //
    // Method:      Open()
    //
    // Purpose:     Opens the ancillary data to allow access to the elements of the ancillary data via feature access.
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //
    // Details:     This function can only succeed if the given frame has been filled by the API.
    //    
    public native @Cast("VmbErrorType") int Open();

    //
    // Method:      Close()
    //
    // Purpose:     Closes the ancillary data inside a frame.
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //  - VmbErrorBadHandle:     The given handle is not valid
    //
    // Details:     After reading the ancillary data and before re-queuing the frame, ancillary data
    //              must be closed.
    //
    public native @Cast("VmbError_t") int Close();

    //
    // Method:      GetBuffer()
    //
    // Purpose:     Returns the underlying buffer
    //
    // Parameters:  [out]       VmbUchar_t*&        pBuffer     A pointer to the buffer
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetBuffer( @Cast("VmbUchar_t*&") @ByPtrRef BytePointer pBuffer );
    public native @Cast("VmbErrorType") int GetBuffer( @Cast("VmbUchar_t*&") @ByPtrRef ByteBuffer pBuffer );
    public native @Cast("VmbErrorType") int GetBuffer( @Cast("VmbUchar_t*&") @ByPtrRef byte[] pBuffer );

    //
    // Method:      GetBuffer()
    //
    // Purpose:     Returns the underlying buffer
    //
    // Parameters:  [out]       const VmbUchar_t*&  pBuffer     A pointer to the buffer
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetBuffer( @Cast("const VmbUchar_t*") byte pBuffer );

    //
    // Method:      GetSize()
    //
    // Purpose:     Returns the size of the underlying buffer
    //
    // Parameters:  [out]       VmbUint32_t&        size    The size of the buffer
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetSize( @Cast("VmbUint32_t*") @ByRef IntPointer size );
    public native @Cast("VmbErrorType") int GetSize( @Cast("VmbUint32_t*") @ByRef IntBuffer size );
    public native @Cast("VmbErrorType") int GetSize( @Cast("VmbUint32_t*") @ByRef int[] size );
}

 // namespace AVT::VmbAPI

// #endif


// Parsed from <VimbaCPP/Include/ICameraFactory.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        ICameraFactory.h

  Description: Definition of interface AVT::VmbAPI::ICameraFactory.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_ICAMERAFACTORY_H
// #define AVT_VMBAPI_ICAMERAFACTORY_H

// #include <VimbaC/Include/VimbaC.h>
// #include <VimbaCPP/Include/VimbaCPPCommon.h>
// #include <VimbaCPP/Include/SharedPointerDefines.h>
// #include <VimbaCPP/Include/Camera.h>

@Namespace("AVT::VmbAPI") public static class ICameraFactory extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ICameraFactory(Pointer p) { super(p); }

    //
    // Method:      CreateCamera()
    //
    // Purpose:     Factory method to create a camera that extends the Camera class
    //
    // Parameters:
    //
    // [in ]    const char*         pCameraID                   The ID of the camera
    // [in ]    const char*         pCameraName                 The name of the camera
    // [in ]    const char*         pCameraModel                The model name of the camera
    // [in ]    const char*         pCameraSerialNumber         The serial number of the camera
    // [in ]    const char*         pInterfaceID                The ID of the interface the camera is connected to
    // [in ]    VmbInterfaceType    interfaceType               The type of the interface the camera is connected to
    // [in ]    const char*         pInterfaceName              The name of the interface
    // [in ]    const char*         pInterfaceSerialNumber      The serial number of the interface
    // [in ]    VmbAccessModeType   interfacePermittedAccess    The access privileges for the interface
    //
    // Details:   The ID of the camera may be, among others, one of the following: "169.254.12.13",
    //            "000f31000001", a plain serial number: "1234567890", or the device ID 
    //            of the underlying transport layer.
    //
    public native @SharedPtr @ByVal Camera CreateCamera(    @Cast("const char*") BytePointer pCameraID,
                                                    @Cast("const char*") BytePointer pCameraName,
                                                    @Cast("const char*") BytePointer pCameraModel,
                                                    @Cast("const char*") BytePointer pCameraSerialNumber,
                                                    @Cast("const char*") BytePointer pInterfaceID,
                                                    @Cast("VmbInterfaceType") int interfaceType,
                                                    @Cast("const char*") BytePointer pInterfaceName,
                                                    @Cast("const char*") BytePointer pInterfaceSerialNumber,
                                                    @Cast("VmbAccessModeType") int interfacePermittedAccess);
    public native @SharedPtr @ByVal Camera CreateCamera(    String pCameraID,
                                                    String pCameraName,
                                                    String pCameraModel,
                                                    String pCameraSerialNumber,
                                                    String pInterfaceID,
                                                    @Cast("VmbInterfaceType") int interfaceType,
                                                    String pInterfaceName,
                                                    String pInterfaceSerialNumber,
                                                    @Cast("VmbAccessModeType") int interfacePermittedAccess);

    //
    // Method:      ICameraFactory destructor
    //
    // Purpose:     Destroys an instance of class Camera
    //

}

 // namespace AVT::VmbAPI

// #endif


// Parsed from <VimbaCPP/Include/IFrameObserver.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        IFrameObserver.h

  Description: Definition of interface AVT::VmbAPI::IFrameObserver.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_IFRAMEOBSERVER_H
// #define AVT_VMBAPI_IFRAMEOBSERVER_H

// #include <VimbaCPP/Include/VimbaCPPCommon.h>
// #include <VimbaCPP/Include/SharedPointerDefines.h>
// #include <VimbaCPP/Include/Frame.h>

@Namespace("AVT::VmbAPI") @NoOffset public static class IFrameObserver extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IFrameObserver(Pointer p) { super(p); }

    //
    // Method:      FrameReceived()
    //
    // Purpose:     The event handler function that gets called whenever
    //              a new frame is received
    //
    // Parameters:
    //
    // [in]     const FramePtr      pFrame                  The frame that was received
    //
    public native void FrameReceived( @Const @SharedPtr @ByVal Frame pFrame );

    //
    // Method:      IFrameObserver destructor
    //
    // Purpose:     Destroys an instance of class IFrameObserver
    //
}

 // namespace AVT::VmbAPI

// #endif


// Parsed from <VimbaCPP/Include/EnumEntry.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        EnumEntry.h

  Description:  Definition of class AVT::VmbAPI::EnumEntry.
                An EnumEntry consists of
                Name
                DisplayName
                Value
                of one particular enumeration

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_ENUMENTRY_H
// #define AVT_VMBAPI_ENUMENTRY_H

// #include <string>

// #include <VimbaC/Include/VimbaC.h>
// #include <VimbaCPP/Include/VimbaCPPCommon.h>
// #include <VimbaCPP/Include/SharedPointerDefines.h>

@Namespace("AVT::VmbAPI") @NoOffset public static class EnumEntry extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public EnumEntry(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public EnumEntry(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public EnumEntry position(long position) {
        return (EnumEntry)super.position(position);
    }

    //
    // Method:      EnumEntry constructor
    //
    // Purpose:     Creates an instance of class EnumEntry
    //
    // Parameters:
    //
    // [in ]    const char*             pName           The name of the enum
    // [in ]    const char*             pDisplayName    The declarative name of the enum
    // [in ]    const char*             pDescription    The description of the enum
    // [in ]    const char*             pTooltip        A tooltip that can be used by a GUI
    // [in ]    const char*             pSNFCNamespace  The SFNC namespace of the enum
    // [in ]    VmbFeatureVisibility_t  visibility      The visibility of the enum
    // [in ]    VmbInt64_t              value           The integer value of the enum
    //
    public EnumEntry(  @Cast("const char*") BytePointer pName,
                    @Cast("const char*") BytePointer pDisplayName,
                    @Cast("const char*") BytePointer pDescription,
                    @Cast("const char*") BytePointer pTooltip,
                    @Cast("const char*") BytePointer pSNFCNamespace,
                    @Cast("VmbFeatureVisibility_t") int visibility,
                    @Cast("VmbInt64_t") long value) { super((Pointer)null); allocate(pName, pDisplayName, pDescription, pTooltip, pSNFCNamespace, visibility, value); }
    private native void allocate(  @Cast("const char*") BytePointer pName,
                    @Cast("const char*") BytePointer pDisplayName,
                    @Cast("const char*") BytePointer pDescription,
                    @Cast("const char*") BytePointer pTooltip,
                    @Cast("const char*") BytePointer pSNFCNamespace,
                    @Cast("VmbFeatureVisibility_t") int visibility,
                    @Cast("VmbInt64_t") long value);
    public EnumEntry(  String pName,
                    String pDisplayName,
                    String pDescription,
                    String pTooltip,
                    String pSNFCNamespace,
                    @Cast("VmbFeatureVisibility_t") int visibility,
                    @Cast("VmbInt64_t") long value) { super((Pointer)null); allocate(pName, pDisplayName, pDescription, pTooltip, pSNFCNamespace, visibility, value); }
    private native void allocate(  String pName,
                    String pDisplayName,
                    String pDescription,
                    String pTooltip,
                    String pSNFCNamespace,
                    @Cast("VmbFeatureVisibility_t") int visibility,
                    @Cast("VmbInt64_t") long value);

    //
    // Method:      EnumEntry constructor
    //
    // Purpose:     Creates an instance of class EnumEntry
    //
    public EnumEntry() { super((Pointer)null); allocate(); }
    private native void allocate();
    //
    // Method:      EnumEntry copy constructor
    //
    // Purpose:     Creates a copy of class EnumEntry
    //
    public EnumEntry( @Const @ByRef EnumEntry other) { super((Pointer)null); allocate(other); }
    private native void allocate( @Const @ByRef EnumEntry other);
    
    //
    // Method:      EnumEntry assignment operator
    //
    // Purpose:     assigns EnumEntry to existing instance
    //
    public native @ByRef @Name("operator =") EnumEntry put( @Const @ByRef EnumEntry o);

    //
    // Method:      EnumEntry destructor
    //
    // Purpose:     Destroys an instance of class EnumEntry
    //

    //
    // Method:      GetName()
    //
    // Purpose:     Gets the name of an enumeration
    //
    // Parameters:
    //
    // [out]        std::string& name   The name of the enumeration
    //
    public native @Cast("VmbErrorType") int GetName( @StdString BytePointer name );
    public native @Cast("VmbErrorType") int GetName( @StdString String name );

    //
    // Method:      GetDisplayName()
    //
    // Purpose:     Gets a more declarative name of an enumeration
    //
    // Parameters:
    //
    // [out]        std::string& displayName    The display name of the enumeration
    //
    public native @Cast("VmbErrorType") int GetDisplayName( @StdString BytePointer displayName );
    public native @Cast("VmbErrorType") int GetDisplayName( @StdString String displayName );

    //
    // Method:      GetDescription()
    //
    // Purpose:     Gets the description of an enumeration
    //
    // Parameters:
    //
    // [out]        std::string& description    The description of the enumeration
    //
    public native @Cast("VmbErrorType") int GetDescription( @StdString BytePointer description );
    public native @Cast("VmbErrorType") int GetDescription( @StdString String description );

    //
    // Method:      GetTooltip()
    //
    // Purpose:     Gets a tooltip that can be used as pop up help in a GUI
    //
    // Parameters:
    //
    // [out]        std::string& tooltip    The tooltip as string
    //
    public native @Cast("VmbErrorType") int GetTooltip( @StdString BytePointer tooltip );
    public native @Cast("VmbErrorType") int GetTooltip( @StdString String tooltip );

    //
    // Method:      GetValue()
    //
    // Purpose:     Gets the integer value of an enumeration
    //
    // Parameters:
    //
    // [out]        VmbInt64_t& value   The integer value of the enumeration
    //
    public native @Cast("VmbErrorType") int GetValue( @Cast("VmbInt64_t*") @ByRef LongPointer value );
    public native @Cast("VmbErrorType") int GetValue( @Cast("VmbInt64_t*") @ByRef LongBuffer value );
    public native @Cast("VmbErrorType") int GetValue( @Cast("VmbInt64_t*") @ByRef long[] value );

    //
    // Method:      GetVisibility()
    //
    // Purpose:     Gets the visibility of an enumeration
    //
    // Parameters:
    //
    // [out]        VmbFeatureVisibilityType&   value   The visibility of the enumeration
    //
    public native @Cast("VmbErrorType") int GetVisibility( @Cast("VmbFeatureVisibilityType*") @ByRef IntPointer value );
    public native @Cast("VmbErrorType") int GetVisibility( @Cast("VmbFeatureVisibilityType*") @ByRef IntBuffer value );
    public native @Cast("VmbErrorType") int GetVisibility( @Cast("VmbFeatureVisibilityType*") @ByRef int[] value );

    //
    // Method:      GetSNFCNamespace()
    //
    // Purpose:     Gets the standard feature naming convention namespace of the enumeration
    //
    // Parameters:
    //
    // [out]        std::string& sFNCNamespace    The feature's SFNC namespace
    //
    public native @Cast("VmbErrorType") int GetSFNCNamespace( @StdString BytePointer sFNCNamespace );
    public native @Cast("VmbErrorType") int GetSFNCNamespace( @StdString String sFNCNamespace );

}

// #include <VimbaCPP/Include/EnumEntry.hpp>

 // namespace AVT::VmbAPI

// #endif


// Parsed from <VimbaCPP/Include/ICameraListObserver.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        ICameraListObserver.h

  Description: Definition of interface AVT::VmbAPI::ICameraListObserver.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_ICAMERALISTOBSERVER_H
// #define AVT_VMBAPI_ICAMERALISTOBSERVER_H

// #include <VimbaCPP/Include/VimbaCPPCommon.h>
// #include <VimbaCPP/Include/SharedPointerDefines.h>
// #include <VimbaCPP/Include/Camera.h>
// #include <vector>

@Namespace("AVT::VmbAPI") public static class ICameraListObserver extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ICameraListObserver(Pointer p) { super(p); }

    //
    // Method:      CameraListChanged()
    //
    // Purpose:     The event handler function that gets called whenever
    //              an ICameraListObserver is triggered. This occurs most
    //              likely when a camera was plugged in or out.
    //
    // Parameters:
    //
    // [out]    CameraPtr           pCam                    The camera that triggered the event
    // [out]    UpdateTriggerType   reason                  The reason why the callback routine was triggered
    //                                                      (e.g., a new camera was plugged in)
    //
    public native void CameraListChanged( @SharedPtr @ByVal Camera pCam, @Cast("AVT::VmbAPI::UpdateTriggerType") int reason );

    //
    // Method:      ICameraListObserver destructor
    //
    // Purpose:     Destroys an instance of class ICameraListObserver
    //
}

 // namespace AVT::VmbAPI

// #endif


// Parsed from <VimbaCPP/Include/IInterfaceListObserver.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        IInterfaceListObserver.h

  Description: Definition of interface AVT::VmbAPI::IInterfaceListObserver.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_IINTERFACELISTOBSERVER_H
// #define AVT_VMBAPI_IINTERFACELISTOBSERVER_H

// #include <VimbaCPP/Include/VimbaCPPCommon.h>
// #include <VimbaCPP/Include/SharedPointerDefines.h>
// #include <VimbaCPP/Include/Interface.h>
// #include <vector>

@Namespace("AVT::VmbAPI") public static class IInterfaceListObserver extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IInterfaceListObserver(Pointer p) { super(p); }

    //
    // Method:      InterfaceListChanged()
    //
    // Purpose:     The event handler function that gets called whenever
    //              an IInterfaceListObserver is triggered.
    //
    // Parameters:
    //
    // [out]    InterfacePtr        pInterface              The interface that triggered the event
    // [out]    UpdateTriggerType   reason                  The reason why the callback routine was triggered
    //
    public native void InterfaceListChanged( @SharedPtr @ByVal Interface pInterface, @Cast("AVT::VmbAPI::UpdateTriggerType") int reason );

    //
    // Method:      IInterfaceListObserver destructor
    //
    // Purpose:     Destroys an instance of class IInterfaceListObserver
    //
    
}

 // namespace AVT::VmbAPI

// #endif


// Parsed from <VimbaCPP/Include/IFeatureObserver.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        IFeatureObserver.h

  Description: Definition of interface AVT::VmbAPI::IFeatureObserver.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_IFEATUREOBSERVER_H
// #define AVT_VMBAPI_IFEATUREOBSERVER_H

// #include <VimbaCPP/Include/VimbaCPPCommon.h>
// #include <VimbaCPP/Include/SharedPointerDefines.h>
// #include <VimbaCPP/Include/Feature.h>
// #include <vector>

@Namespace("AVT::VmbAPI") public static class IFeatureObserver extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IFeatureObserver(Pointer p) { super(p); }

    //
    // Method:      FeatureChanged()
    //
    // Purpose:     The event handler function that gets called whenever
    //              a feature has changed
    //
    // Parameters:
    //
    // [in]     const FeaturePtr&      pFeature          The frame that has changed
    //
    public native void FeatureChanged( @Const @SharedPtr @ByRef Feature pFeature );

    //
    // Method:      IFeatureObserver destructor
    //
    // Purpose:     Destroys an instance of class IFeatureObserver
    //
}

 // namespace AVT::VmbAPI

// #endif


// Parsed from <VimbaCPP/Include/Interface.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        Interface.h

  Description: Definition of class AVT::VmbAPI::Interface.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_INTERFACE_H
// #define AVT_VMBAPI_INTERFACE_H

// #include <VimbaC/Include/VimbaC.h>
// #include <VimbaCPP/Include/VimbaCPPCommon.h>
// #include <VimbaCPP/Include/FeatureContainer.h>
// #include <vector>

@Namespace("AVT::VmbAPI") @NoOffset public static class Interface extends FeatureContainer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Interface(Pointer p) { super(p); }


    public Interface( @Const VmbInterfaceInfo_t pInterfaceInfo ) { super((Pointer)null); allocate(pInterfaceInfo); }
    private native void allocate( @Const VmbInterfaceInfo_t pInterfaceInfo );

    //
    // Method:      Open()
    //
    // Purpose:     Open an interface handle for feature access.
    //
    // Parameters:  none
    //
    // Returns:
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //  - VmbErrorNotFound:      The designated interface cannot be found   
    //
    // Details:   An interface can be opened if interface-specific control is required, such as I/O pins
    //            on a frame grabber card. Control is then possible via feature access methods.
    //
    public native @Cast("VmbErrorType") int Open();

    //
    // Method:      Close()
    //
    // Purpose:     Close an interface.
    //
    // Parameters:  none    
    //
    // Returns:
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //  - VmbErrorBadHandle:     The handle is not valid
    //
    public native @Cast("VmbErrorType") int Close();

    //
    // Method:      GetID()
    //
    // Purpose:     Gets the ID of an interface.
    //
    // Parameters:  [out]   std::string&        interfaceID          The ID of the interface
    //
    // Returns:
    //  - VmbErrorSuccess:       If no error
    //
    // Details:    This information remains static throughout the object's lifetime
    //
    public native @Cast("VmbErrorType") int GetID( @StdString BytePointer interfaceID );
    public native @Cast("VmbErrorType") int GetID( @StdString String interfaceID );

    //
    // Method:      GetType()
    //
    // Purpose:     Gets the type, e.g. FireWire, GigE or USB of an interface.
    //
    // Parameters:  [out]   VmbInterfaceType&   type        The type of the interface
    //
    // Returns:
    //  - VmbErrorSuccess:       If no error
    //
    //  Details:    This information remains static throughout the object's lifetime
    //
    public native @Cast("VmbErrorType") int GetType( @Cast("VmbInterfaceType*") @ByRef IntPointer type );
    public native @Cast("VmbErrorType") int GetType( @Cast("VmbInterfaceType*") @ByRef IntBuffer type );
    public native @Cast("VmbErrorType") int GetType( @Cast("VmbInterfaceType*") @ByRef int[] type );

    //
    // Method:      GetName()
    //
    // Purpose:     Gets the name of an interface.
    //
    // Parameters:  [out]   std::string&        name        The name of the interface
    //
    // Returns:
    //  - VmbErrorSuccess:       If no error
    //
    //              This information remains static throughout the object's lifetime
    //
    public native @Cast("VmbErrorType") int GetName( @StdString BytePointer name );
    public native @Cast("VmbErrorType") int GetName( @StdString String name );

    //
    // Method:      GetSerialNumber()
    //
    // Purpose:     Gets the serial number of an interface.
    //
    // Parameters:  [out]   std::string&    serialNumber    The serial number of the interface
    //
    // Returns:
    //  - VmbErrorSuccess:       If no error
    //
    //              This information remains static throughout the object's lifetime
    //
    public native @Cast("VmbErrorType") int GetSerialNumber( @StdString BytePointer serialNumber );
    public native @Cast("VmbErrorType") int GetSerialNumber( @StdString String serialNumber );

    //
    // Method:      GetPermittedAccess()
    //
    // Purpose:     Gets the access mode of an interface.
    //
    // Parameters:  [out]   VmbAccessModeType&  accessMode  The possible access mode of the interface
    //
    // Returns:
    //  - VmbErrorSuccess:       If no error
    //
    public native @Cast("VmbErrorType") int GetPermittedAccess( @Cast("VmbAccessModeType*") @ByRef IntPointer accessMode );
    public native @Cast("VmbErrorType") int GetPermittedAccess( @Cast("VmbAccessModeType*") @ByRef IntBuffer accessMode );
    public native @Cast("VmbErrorType") int GetPermittedAccess( @Cast("VmbAccessModeType*") @ByRef int[] accessMode );
}

// #include <VimbaCPP/Include/Interface.hpp>

 // namespace AVT::VmbAPI

// #endif


// Parsed from <VimbaCPP/Include/Frame.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        Frame.h

  Description: Definition of class AVT::VmbAPI::Frame.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_FRAME_H
// #define AVT_VMBAPI_FRAME_H

// #include <VimbaC/Include/VimbaC.h>
// #include <VimbaCPP/Include/VimbaCPPCommon.h>
// #include <VimbaCPP/Include/SharedPointerDefines.h>
// #include <VimbaCPP/Include/IFrameObserver.h>
// #include <VimbaCPP/Include/AncillaryData.h>
// #include <vector> // forward declaration of camera class for befriending

@Namespace("AVT::VmbAPI") @NoOffset public static class Frame extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Frame(Pointer p) { super(p); }

    //
    // Method:      Frame constructor
    //
    // Purpose:     Creates an instance of class Frame of a certain size
    //
    // Parameters:  [in ]   VmbInt64_t      bufferSize  The size of the underlying buffer
    //
    public Frame( @Cast("VmbInt64_t") long bufferSize ) { super((Pointer)null); allocate(bufferSize); }
    private native void allocate( @Cast("VmbInt64_t") long bufferSize );

    //
    // Method:      Frame constructor
    //
    // Purpose:     Creates an instance of class Frame with the given user buffer of the given size
    //
    // Parameters:  [in ]   VmbUchar_t*     pBuffer     A pointer to an allocated buffer
    // Parameters:  [in ]   VmbInt64_t      bufferSize  The size of the underlying buffer
    //
    public Frame( @Cast("VmbUchar_t*") BytePointer pBuffer, @Cast("VmbInt64_t") long bufferSize ) { super((Pointer)null); allocate(pBuffer, bufferSize); }
    private native void allocate( @Cast("VmbUchar_t*") BytePointer pBuffer, @Cast("VmbInt64_t") long bufferSize );
    public Frame( @Cast("VmbUchar_t*") ByteBuffer pBuffer, @Cast("VmbInt64_t") long bufferSize ) { super((Pointer)null); allocate(pBuffer, bufferSize); }
    private native void allocate( @Cast("VmbUchar_t*") ByteBuffer pBuffer, @Cast("VmbInt64_t") long bufferSize );
    public Frame( @Cast("VmbUchar_t*") byte[] pBuffer, @Cast("VmbInt64_t") long bufferSize ) { super((Pointer)null); allocate(pBuffer, bufferSize); }
    private native void allocate( @Cast("VmbUchar_t*") byte[] pBuffer, @Cast("VmbInt64_t") long bufferSize );

    //
    // Method:      Frame destructor
    //
    // Purpose:     Destroys an instance of class Frame
    //

    //
    // Method:      RegisterObserver()
    //
    // Purpose:     Registers an observer that will be called whenever a new frame arrives
    //
    // Parameters:  [in ]   const IFrameObserverPtr&   pObserver   An object that implements the IObserver interface
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //  - VmbErrorBadParameter: "pObserver" is NULL.
    //  - VmbErrorResources:    The observer was in use
    //
    // Details:     As new frames arrive, the observer's FrameReceived method will be called.
    //              Only one observer can be registered.
    //
    public native @Cast("VmbErrorType") int RegisterObserver( @Const @SharedPtr @ByRef IFrameObserver pObserver );

    //
    // Method:      UnregisterObserver()
    //
    // Purpose:     Unregisters the observer that was called whenever a new frame arrived
    //
    public native @Cast("VmbErrorType") int UnregisterObserver();

    //
    // Method:      GetAncillaryData()
    //
    // Purpose:     Returns the part of a frame that describes the chunk data as an object
    //
    // Parameters:  [out]   AncillaryDataPtr&        pAncillaryData      The wrapped chunk data
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //  - VmbErrorNotFound:     No chunk data present
    //
    public native @Cast("VmbErrorType") int GetAncillaryData( @SharedPtr @ByRef AncillaryData pAncillaryData );

    //
    // Method:      GetAncillaryData()
    //
    // Purpose:     Returns the part of a frame that describes the chunk data as an object
    //
    // Parameters:  [out]   ConstAncillaryDataPtr&    pAncillaryData     The wrapped chunk data
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //  - VmbErrorNotFound:     No chunk data present
    //
    public native @Cast("VmbErrorType") int GetAncillaryData( @SharedPtr @ByRef ConstAncillaryData pAncillaryData );

    //
    // Method:      GetBuffer()
    //
    // Purpose:     Returns the complete buffer including image and chunk data
    //
    // Parameters:  [out]   VmbUchar_t*      pBuffer        A pointer to the buffer
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetBuffer( @Cast("VmbUchar_t*&") @ByPtrRef BytePointer pBuffer );
    public native @Cast("VmbErrorType") int GetBuffer( @Cast("VmbUchar_t*&") @ByPtrRef ByteBuffer pBuffer );
    public native @Cast("VmbErrorType") int GetBuffer( @Cast("VmbUchar_t*&") @ByPtrRef byte[] pBuffer );

    //
    // Method:      GetBuffer()
    //
    // Purpose:     Returns the complete buffer including image and chunk data
    //
    // Parameters:  [out]   const VmbUchar_t*      pBuffer  A pointer to the buffer
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetBuffer( @Cast("const VmbUchar_t*") byte pBuffer );

    //
    // Method:      GetImage()
    //
    // Purpose:     Returns only the image data
    //
    // Parameters:  [out]   VmbUchar_t*         pBuffer     A pointer to the buffer
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetImage( @Cast("VmbUchar_t*&") @ByPtrRef BytePointer pBuffer );
    public native @Cast("VmbErrorType") int GetImage( @Cast("VmbUchar_t*&") @ByPtrRef ByteBuffer pBuffer );
    public native @Cast("VmbErrorType") int GetImage( @Cast("VmbUchar_t*&") @ByPtrRef byte[] pBuffer );

    //
    // Method:      GetImage()
    //
    // Purpose:     Returns only the image data
    //
    // Parameters:  [out]   const VmbUchar_t*    pBuffer    A pointer to the buffer
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetImage( @Cast("const VmbUchar_t*") byte pBuffer );

    //
    // Method:      GetReceiveStatus()
    //
    // Purpose:     Returns the receive status of a frame
    //
    // Parameters:  [out]   VmbFrameStatusType&   status    The receive status
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetReceiveStatus( @Cast("VmbFrameStatusType*") @ByRef IntPointer status );
    public native @Cast("VmbErrorType") int GetReceiveStatus( @Cast("VmbFrameStatusType*") @ByRef IntBuffer status );
    public native @Cast("VmbErrorType") int GetReceiveStatus( @Cast("VmbFrameStatusType*") @ByRef int[] status );
    
    //
    // Method:      GetImageSize()
    //
    // Purpose:     Returns the memory size of the image
    //
    // Parameters:  [out]   VmbUint32_t&    imageSize       The size in bytes
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetImageSize( @Cast("VmbUint32_t*") @ByRef IntPointer imageSize );
    public native @Cast("VmbErrorType") int GetImageSize( @Cast("VmbUint32_t*") @ByRef IntBuffer imageSize );
    public native @Cast("VmbErrorType") int GetImageSize( @Cast("VmbUint32_t*") @ByRef int[] imageSize );
    
    //
    // Method:      GetAncillarySize()
    //
    // Purpose:     Returns memory size of the chunk data
    //
    // Parameters:  [out]   VmbUint32_t&    ancillarySize   The size in bytes
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetAncillarySize( @Cast("VmbUint32_t*") @ByRef IntPointer ancillarySize );
    public native @Cast("VmbErrorType") int GetAncillarySize( @Cast("VmbUint32_t*") @ByRef IntBuffer ancillarySize );
    public native @Cast("VmbErrorType") int GetAncillarySize( @Cast("VmbUint32_t*") @ByRef int[] ancillarySize );
    
    //
    // Method:      GetBufferSize()
    //
    // Purpose:     Returns the memory size of the frame buffer holding 
    //              both the image data and the ancillary data
    //
    // Parameters:  [out]   VmbUint32_t&    bufferSize      The size in bytes
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetBufferSize( @Cast("VmbUint32_t*") @ByRef IntPointer bufferSize );
    public native @Cast("VmbErrorType") int GetBufferSize( @Cast("VmbUint32_t*") @ByRef IntBuffer bufferSize );
    public native @Cast("VmbErrorType") int GetBufferSize( @Cast("VmbUint32_t*") @ByRef int[] bufferSize );

    //
    // Method:      GetPixelFormat()
    //
    // Purpose:     Returns the GenICam pixel format
    //
    // Parameters:  [out]   VmbPixelFormatType&      pixelFormat    The GenICam pixel format
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetPixelFormat( @Cast("VmbPixelFormatType*") @ByRef IntPointer pixelFormat );
    public native @Cast("VmbErrorType") int GetPixelFormat( @Cast("VmbPixelFormatType*") @ByRef IntBuffer pixelFormat );
    public native @Cast("VmbErrorType") int GetPixelFormat( @Cast("VmbPixelFormatType*") @ByRef int[] pixelFormat );

    //
    // Method:      GetWidth()
    //
    // Purpose:     Returns the width of the image
    //
    // Parameters:  [out]   VmbUint32_t&    width       The width in pixels
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetWidth( @Cast("VmbUint32_t*") @ByRef IntPointer width );
    public native @Cast("VmbErrorType") int GetWidth( @Cast("VmbUint32_t*") @ByRef IntBuffer width );
    public native @Cast("VmbErrorType") int GetWidth( @Cast("VmbUint32_t*") @ByRef int[] width );

    //
    // Method:      GetHeight()
    //
    // Purpose:     Returns the height of the image
    //
    // Parameters:  [out]   VmbUint32_t&    height       The height in pixels
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetHeight( @Cast("VmbUint32_t*") @ByRef IntPointer height );
    public native @Cast("VmbErrorType") int GetHeight( @Cast("VmbUint32_t*") @ByRef IntBuffer height );
    public native @Cast("VmbErrorType") int GetHeight( @Cast("VmbUint32_t*") @ByRef int[] height );

    //
    // Method:      GetOffsetX()
    //
    // Purpose:     Returns the x offset of the image
    //
    // Parameters:  [out]   VmbUint32_t&    offsetX     The x offset in pixels
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetOffsetX( @Cast("VmbUint32_t*") @ByRef IntPointer offsetX );
    public native @Cast("VmbErrorType") int GetOffsetX( @Cast("VmbUint32_t*") @ByRef IntBuffer offsetX );
    public native @Cast("VmbErrorType") int GetOffsetX( @Cast("VmbUint32_t*") @ByRef int[] offsetX );

    //
    // Method:      GetOffsetY()
    //
    // Purpose:     Returns the y offset of the image
    //
    // Parameters:  [out]   VmbUint32_t&    offsetY     The y offset in pixels
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetOffsetY( @Cast("VmbUint32_t*") @ByRef IntPointer offsetY );
    public native @Cast("VmbErrorType") int GetOffsetY( @Cast("VmbUint32_t*") @ByRef IntBuffer offsetY );
    public native @Cast("VmbErrorType") int GetOffsetY( @Cast("VmbUint32_t*") @ByRef int[] offsetY );

    //
    // Method:      GetFrameID()
    //
    // Purpose:     Returns the frame ID
    //
    // Parameters:  [out]   VmbUint64_t&     frameID    The frame ID
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetFrameID( @Cast("VmbUint64_t*") @ByRef IntPointer frameID );
    public native @Cast("VmbErrorType") int GetFrameID( @Cast("VmbUint64_t*") @ByRef IntBuffer frameID );
    public native @Cast("VmbErrorType") int GetFrameID( @Cast("VmbUint64_t*") @ByRef int[] frameID );

    //
    // Method:      GetTimeStamp()
    //
    // Purpose:     Returns the time stamp
    //
    // Parameters:  [out]   VmbUint64_t&     timestamp  The time stamp
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int GetTimestamp( @Cast("VmbUint64_t*") @ByRef IntPointer timestamp );
    public native @Cast("VmbErrorType") int GetTimestamp( @Cast("VmbUint64_t*") @ByRef IntBuffer timestamp );
    public native @Cast("VmbErrorType") int GetTimestamp( @Cast("VmbUint64_t*") @ByRef int[] timestamp );

    public native @Cast("bool") boolean GetObserver( @SharedPtr @ByRef IFrameObserver observer );
}

 // namespace AVT::VmbAPI

// #endif


// Parsed from <VimbaCPP/Include/IRegisterDevice.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        IRegisterDevice.h

  Description: Definition of interface AVT::VmbAPI::IRegisterDevice.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_IREGISTERDEVICE_H
// #define AVT_VMBAPI_IREGISTERDEVICE_H

// #include <VimbaC/Include/VmbCommonTypes.h>
// #include <vector>

@Namespace("AVT::VmbAPI") public static class IRegisterDevice extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IRegisterDevice(Pointer p) { super(p); }


    //
    // Method:      ReadRegisters()
    //
    // Purpose:     Reads one or more registers consecutively. The number of registers to be read is determined by the number of provided addresses.
    //
    // Parameters:  [in ]   const Uint64Vector&   addresses     A list of register addresses
    //              [out]   Uint64Vector&         buffer        The returned data as vector
    //
    // Returns:
    //  - VmbErrorSuccess:      If all requested registers have been read
    //  - VmbErrorBadParameter: Vectors "addresses" and/or "buffer" are empty.
    //  - VmbErrorIncomplete:   If at least one, but not all registers have been read. See overload ReadRegisters( const Uint64Vector&, Uint64Vector&, VmbUint32_t& ).
    //
    public native @Cast("VmbErrorType") int ReadRegisters( @Cast("VmbUint64_t*") @StdVector IntPointer addresses, @Cast("VmbUint64_t*") @StdVector IntPointer buffer );
    public native @Cast("VmbErrorType") int ReadRegisters( @Cast("VmbUint64_t*") @StdVector IntBuffer addresses, @Cast("VmbUint64_t*") @StdVector IntBuffer buffer );
    public native @Cast("VmbErrorType") int ReadRegisters( @Cast("VmbUint64_t*") @StdVector int[] addresses, @Cast("VmbUint64_t*") @StdVector int[] buffer );

    //
    // Method:      ReadRegisters()
    //
    // Purpose:     Same as ReadRegisters( const Uint64Vector&, Uint64Vector& ), but returns the number of successful read operations in case of an error.
    //
    // Parameters:  [in ]   const Uint64Vector&   addresses         A list of register addresses
    //              [out]   Uint64Vector&         buffer            The returned data as vector
    //              [out]   VmbUint32_t&          completedReads    The number of successfully read registers
    //
    // Returns:
    //  - VmbErrorSuccess:      If all requested registers have been read
    //  - VmbErrorBadParameter: Vectors "addresses" and/or "buffer" are empty.
    //  - VmbErrorIncomplete:   If at least one, but not all registers have been read.
    //
    public native @Cast("VmbErrorType") int ReadRegisters( @Cast("VmbUint64_t*") @StdVector IntPointer addresses, @Cast("VmbUint64_t*") @StdVector IntPointer buffer, @Cast("VmbUint32_t*") @ByRef IntPointer completedReads );
    public native @Cast("VmbErrorType") int ReadRegisters( @Cast("VmbUint64_t*") @StdVector IntBuffer addresses, @Cast("VmbUint64_t*") @StdVector IntBuffer buffer, @Cast("VmbUint32_t*") @ByRef IntBuffer completedReads );
    public native @Cast("VmbErrorType") int ReadRegisters( @Cast("VmbUint64_t*") @StdVector int[] addresses, @Cast("VmbUint64_t*") @StdVector int[] buffer, @Cast("VmbUint32_t*") @ByRef int[] completedReads );
    
    //
    // Method:      WriteRegisters()
    //
    // Purpose:     Writes one or more registers consecutively. The number of registers to be written is determined by the number of provided addresses.
    //
    // Parameters:  [in ]    const Uint64Vector&   addresses    A list of register addresses
    //              [in ]    const Uint64Vector&   buffer       The data to write as vector
    //
    // Returns:
    //  - VmbErrorSuccess:      If all requested registers have been written
    //  - VmbErrorBadParameter: Vectors "addresses" and/or "buffer" are empty.
    //  - VmbErrorIncomplete:   If at least one, but not all registers have been written. See overload WriteRegisters( const Uint64Vector&, const Uint64Vector&, VmbUint32_t& ).
    //
    public native @Cast("VmbErrorType") int WriteRegisters( @Cast("VmbUint64_t*") @StdVector IntPointer addresses, @Cast("VmbUint64_t*") @StdVector IntPointer buffer );
    public native @Cast("VmbErrorType") int WriteRegisters( @Cast("VmbUint64_t*") @StdVector IntBuffer addresses, @Cast("VmbUint64_t*") @StdVector IntBuffer buffer );
    public native @Cast("VmbErrorType") int WriteRegisters( @Cast("VmbUint64_t*") @StdVector int[] addresses, @Cast("VmbUint64_t*") @StdVector int[] buffer );

    //
    // Method:      WriteRegisters()
    //
    // Purpose:     Same as WriteRegisters( const Uint64Vector&, const Uint64Vector& ), but returns the number of successful write operations in case of an error VmbErrorIncomplete.
    //
    // Parameters:  [in ]   const Uint64Vector&   addresses         A list of register addresses
    //              [in ]   const Uint64Vector&   buffer            The data to write as vector
    //              [out]   VmbUint32_t&          completedWrites   The number of successfully read registers
    //
    // Returns:
    //  - VmbErrorSuccess:      If all requested registers have been written
    //  - VmbErrorBadParameter: Vectors "addresses" and/or "buffer" are empty.
    //  - VmbErrorIncomplete:   If at least one, but not all registers have been written.
    //
    public native @Cast("VmbErrorType") int WriteRegisters( @Cast("VmbUint64_t*") @StdVector IntPointer addresses, @Cast("VmbUint64_t*") @StdVector IntPointer buffer, @Cast("VmbUint32_t*") @ByRef IntPointer completedWrites );
    public native @Cast("VmbErrorType") int WriteRegisters( @Cast("VmbUint64_t*") @StdVector IntBuffer addresses, @Cast("VmbUint64_t*") @StdVector IntBuffer buffer, @Cast("VmbUint32_t*") @ByRef IntBuffer completedWrites );
    public native @Cast("VmbErrorType") int WriteRegisters( @Cast("VmbUint64_t*") @StdVector int[] addresses, @Cast("VmbUint64_t*") @StdVector int[] buffer, @Cast("VmbUint32_t*") @ByRef int[] completedWrites );
    
    //
    // Method:      ReadMemory()
    //
    // Purpose:     Reads a block of memory. The number of bytes to read is determined by the size of the provided buffer.
    //
    // Parameters:  [in ]   const VmbUint64_t&   address    The address to read from
    //              [out]   UcharVector&         buffer     The returned data as vector
    //
    // Returns:
    //  - VmbErrorSuccess:      If all requested bytes have been read
    //  - VmbErrorBadParameter: Vector "buffer" is empty.
    //  - VmbErrorIncomplete:   If at least one, but not all bytes have been read. See overload ReadMemory( const VmbUint64_t&, UcharVector&, VmbUint32_t& ).
    //
    public native @Cast("VmbErrorType") int ReadMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector BytePointer buffer );
    public native @Cast("VmbErrorType") int ReadMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector ByteBuffer buffer );
    public native @Cast("VmbErrorType") int ReadMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector byte[] buffer );

    //
    // Method:      ReadMemory()
    //
    // Purpose:     Same as ReadMemory( const Uint64Vector&, UcharVector& ), but returns the number of bytes successfully read in case of an error VmbErrorIncomplete.
    //
    // Parameters:  [in ]   const VmbUint64_t&   address        The address to read from
    //              [out]   UcharVector&         buffer         The returned data as vector
    //              [out]   VmbUint32_t&         sizeComplete   The number of successfully read bytes
    //
    // Returns:
    //  - VmbErrorSuccess:      If all requested bytes have been read
    //  - VmbErrorBadParameter: Vector "buffer" is empty.
    //  - VmbErrorIncomplete:   If at least one, but not all bytes have been read.
    //
    public native @Cast("VmbErrorType") int ReadMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector BytePointer buffer, @Cast("VmbUint32_t*") @ByRef IntPointer sizeComplete );
    public native @Cast("VmbErrorType") int ReadMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector ByteBuffer buffer, @Cast("VmbUint32_t*") @ByRef IntBuffer sizeComplete );
    public native @Cast("VmbErrorType") int ReadMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector byte[] buffer, @Cast("VmbUint32_t*") @ByRef int[] sizeComplete );
    
    //
    // Method:      WriteMemory()
    //
    // Purpose:     Writes a block of memory. The number of bytes to write is determined by the size of the provided buffer.
    //
    // Parameters:  [in]    const VmbUint64_t&   address    The address to write to
    //              [in]    const UcharVector&   buffer     The data to write as vector
    //
    // Returns:
    //  - VmbErrorSuccess:      If all requested bytes have been written
    //  - VmbErrorBadParameter: Vector "buffer" is empty.
    //  - VmbErrorIncomplete:   If at least one, but not all bytes have been written. See overload WriteMemory( const VmbUint64_t&, const UcharVector&, VmbUint32_t& ).
    //
    public native @Cast("VmbErrorType") int WriteMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector BytePointer buffer );
    public native @Cast("VmbErrorType") int WriteMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector ByteBuffer buffer );
    public native @Cast("VmbErrorType") int WriteMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector byte[] buffer );

    //
    // Method:      WriteMemory()
    //
    // Purpose:     Same as WriteMemory( const Uint64Vector&, const UcharVector& ), but returns the number of bytes successfully written in case of an error VmbErrorIncomplete.
    //
    // Parameters:  [in]    const VmbUint64_t&   address        The address to write to
    //              [in]    const UcharVector&   buffer         The data to write as vector
    //              [out]   VmbUint32_t&         sizeComplete   The number of successfully written bytes
    //
    // Returns:
    //  - VmbErrorSuccess:      If all requested bytes have been written
    //  - VmbErrorBadParameter: Vector "buffer" is empty.
    //  - VmbErrorIncomplete:   If at least one, but not all bytes have been written.
    //
    public native @Cast("VmbErrorType") int WriteMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector BytePointer buffer, @Cast("VmbUint32_t*") @ByRef IntPointer sizeComplete );
    public native @Cast("VmbErrorType") int WriteMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector ByteBuffer buffer, @Cast("VmbUint32_t*") @ByRef IntBuffer sizeComplete );
    public native @Cast("VmbErrorType") int WriteMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector byte[] buffer, @Cast("VmbUint32_t*") @ByRef int[] sizeComplete );
}

 // namespace AVT::VmbAPI

// #endif


// Parsed from <VimbaCPP/Include/Camera.h>

/*=============================================================================
  Copyright (C) 2012 - 2016 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        Camera.h

  Description: Definition of class AVT::VmbAPI::Camera.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_CAMERA_H
// #define AVT_VMBAPI_CAMERA_H

// #include <vector>
// #include <string>

// #include <VimbaC/Include/VimbaC.h>
// #include <VimbaCPP/Include/VimbaCPPCommon.h>
// #include <VimbaCPP/Include/IRegisterDevice.h>
// #include <VimbaCPP/Include/FeatureContainer.h>
// #include <VimbaCPP/Include/Frame.h>
// #include <VimbaCPP/Include/IFrameObserver.h>
// #include <VimbaCPP/Include/SharedPointerDefines.h>

@Namespace("AVT::VmbAPI") @NoOffset public static class Camera extends FeatureContainer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Camera(Pointer p) { super(p); }
    public IRegisterDevice asIRegisterDevice() { return asIRegisterDevice(this); }
    @Namespace public static native @Name("static_cast<AVT::VmbAPI::IRegisterDevice*>") IRegisterDevice asIRegisterDevice(Camera pointer);

    //
    // Method:      Camera constructor
    //
    // Purpose:     Creates an instance of class Camera
    //
    // Parameters:
    //
    // [in ]    const char*      pID            The ID of the camera    
    // [in ]    const char*      pName          The name of the camera
    // [in ]    const char*      pModel         The model name of the camera
    // [in ]    const char*      pSerialNumber  The serial number of the camera
    // [in ]    const char*      pInterfaceID   The ID of the interface the camera is connected to
    // [in ]    VmbInterfaceType interfaceType  The type of the interface the camera is connected to
    //
    // Details:   The ID of the camera may be, among others, one of the following: "169.254.12.13",
    //            "000f31000001", a plain serial number: "1234567890", or the device ID 
    //            of the underlying transport layer.
    //
    public Camera(    @Cast("const char*") BytePointer pID,
                            @Cast("const char*") BytePointer pName,
                            @Cast("const char*") BytePointer pModel,
                            @Cast("const char*") BytePointer pSerialNumber,
                            @Cast("const char*") BytePointer pInterfaceID,
                            @Cast("VmbInterfaceType") int interfaceType ) { super((Pointer)null); allocate(pID, pName, pModel, pSerialNumber, pInterfaceID, interfaceType); }
    private native void allocate(    @Cast("const char*") BytePointer pID,
                            @Cast("const char*") BytePointer pName,
                            @Cast("const char*") BytePointer pModel,
                            @Cast("const char*") BytePointer pSerialNumber,
                            @Cast("const char*") BytePointer pInterfaceID,
                            @Cast("VmbInterfaceType") int interfaceType );
    public Camera(    String pID,
                            String pName,
                            String pModel,
                            String pSerialNumber,
                            String pInterfaceID,
                            @Cast("VmbInterfaceType") int interfaceType ) { super((Pointer)null); allocate(pID, pName, pModel, pSerialNumber, pInterfaceID, interfaceType); }
    private native void allocate(    String pID,
                            String pName,
                            String pModel,
                            String pSerialNumber,
                            String pInterfaceID,
                            @Cast("VmbInterfaceType") int interfaceType );

    //
    // Method:      Camera destructor
    //
    // Purpose:     Destroys an instance of class Camera
    //
    // Details:     Destroying a camera implicitly closes it beforehand.
    //

    //
    // Method:      Open()
    //
    // Purpose:     Opens the specified camera.
    //
    // Parameters:
    //
    //  [in ]  VmbAccessMode_t  accessMode      Access mode determines the level of control you have on the camera
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //  - VmbErrorNotFound:      The designated camera cannot be found
    //  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
    //
    // Details:   A camera may be opened in a specific access mode. This mode determines
    //            the level of control you have on a camera.
    //  
    public native @Cast("VmbErrorType") int Open( @Cast("VmbAccessModeType") int accessMode );

    //
    // Method:      Close()
    //
    // Purpose:     Closes the specified camera.
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //
    // Details:     Depending on the access mode this camera was opened in, events are killed,
    //              callbacks are unregistered, the frame queue is cleared, and camera control is released.
    //
    public native @Cast("VmbErrorType") int Close();

    //
    // Method:      GetID()
    //
    // Purpose:     Gets the ID of a camera.
    //
    // Parameters:  [out]   std::string&     cameraID         The ID of the camera
    //
    // Returns:
    //  - VmbErrorSuccess:       If no error
    //
    //              This information remains static throughout the object's lifetime
    //
    public native @Cast("VmbErrorType") int GetID( @StdString BytePointer cameraID );
    public native @Cast("VmbErrorType") int GetID( @StdString String cameraID );

    //
    // Method:      GetName()
    //
    // Purpose:     Gets the name of a camera.
    //
    // Parameters:  [out]   std::string&     name         The name of the camera
    //
    // Returns:
    //  - VmbErrorSuccess:       If no error
    //
    //              This information remains static throughout the object's lifetime
    //
    public native @Cast("VmbErrorType") int GetName( @StdString BytePointer name );
    public native @Cast("VmbErrorType") int GetName( @StdString String name );
    
    //
    // Method:      GetModel()
    //
    // Purpose:     Gets the model name of a camera.
    //
    // Parameters:  [out]   std::string&     model         The model name of the camera
    //
    // Returns:
    //  - VmbErrorSuccess:       If no error
    //
    //              This information remains static throughout the object's lifetime
    //
    public native @Cast("VmbErrorType") int GetModel( @StdString BytePointer model );
    public native @Cast("VmbErrorType") int GetModel( @StdString String model );

    //
    // Method:      GetSerialNumber()
    //
    // Purpose:     Gets the serial number of a camera.
    //
    // Parameters:  [out]   std::string&     serialNumber         The serial number of the camera
    //
    // Returns:
    //  - VmbErrorSuccess:       If no error
    //
    //              This information remains static throughout the object's lifetime
    //
    public native @Cast("VmbErrorType") int GetSerialNumber( @StdString BytePointer serialNumber );
    public native @Cast("VmbErrorType") int GetSerialNumber( @StdString String serialNumber );

    //
    // Method:      GetInterfaceID()
    //
    // Purpose:     Gets the interface ID of a camera.
    //
    // Parameters:  [out]   std::string&     interfaceID         The interface ID of the camera
    //
    // Returns:
    //  - VmbErrorSuccess:       If no error
    //
    //              This information remains static throughout the object's lifetime
    //
    public native @Cast("VmbErrorType") int GetInterfaceID( @StdString BytePointer interfaceID );
    public native @Cast("VmbErrorType") int GetInterfaceID( @StdString String interfaceID );

    //
    // Method:      GetInterfaceType()
    //
    // Purpose:     Gets the type of the interface the camera is connected to. And therefore the type of the camera itself.
    //
    // Parameters:  [out]   VmbInterfaceType&    interfaceType The interface type of the camera
    //
    // Returns:
    //  - VmbErrorSuccess:       If no error
    //
    public native @Cast("VmbErrorType") int GetInterfaceType( @Cast("VmbInterfaceType*") @ByRef IntPointer interfaceType );
    public native @Cast("VmbErrorType") int GetInterfaceType( @Cast("VmbInterfaceType*") @ByRef IntBuffer interfaceType );
    public native @Cast("VmbErrorType") int GetInterfaceType( @Cast("VmbInterfaceType*") @ByRef int[] interfaceType );

    //
    // Method:      GetPermittedAccess()
    //
    // Purpose:     Gets the access modes of a camera.
    //
    // Parameters:  [out]   VmbAccessModeType&   permittedAccess The possible access modes of the camera
    //
    // Returns:
    //  - VmbErrorSuccess:       If no error
    //
    public native @Cast("VmbErrorType") int GetPermittedAccess( @Cast("VmbAccessModeType*") @ByRef IntPointer permittedAccess );
    public native @Cast("VmbErrorType") int GetPermittedAccess( @Cast("VmbAccessModeType*") @ByRef IntBuffer permittedAccess );
    public native @Cast("VmbErrorType") int GetPermittedAccess( @Cast("VmbAccessModeType*") @ByRef int[] permittedAccess );

    //
    // Method:      ReadRegisters()
    //
    // Purpose:     Reads one or more registers consecutively. The number of registers to read is determined by the number of provided addresses.
    //
    // Parameters:  [in ]   const Uint64Vector&   addresses  A list of register addresses
    //              [out]   Uint64Vector&         buffer     The returned data as vector
    //
    // Returns:
    //  - VmbErrorSuccess:      If all requested registers have been read
    //  - VmbErrorBadParameter: Vectors "addresses" and/or "buffer" are empty.
    //  - VmbErrorIncomplete:   If at least one, but not all registers have been read. See overload ReadRegisters( const Uint64Vector&, Uint64Vector&, VmbUint32_t& ).
    //
    public native @Cast("VmbErrorType") int ReadRegisters( @Cast("VmbUint64_t*") @StdVector IntPointer addresses, @Cast("VmbUint64_t*") @StdVector IntPointer buffer );
    public native @Cast("VmbErrorType") int ReadRegisters( @Cast("VmbUint64_t*") @StdVector IntBuffer addresses, @Cast("VmbUint64_t*") @StdVector IntBuffer buffer );
    public native @Cast("VmbErrorType") int ReadRegisters( @Cast("VmbUint64_t*") @StdVector int[] addresses, @Cast("VmbUint64_t*") @StdVector int[] buffer );
    
    //
    // Method:      ReadRegisters()
    //
    // Purpose:     Same as ReadRegisters( const Uint64Vector&, Uint64Vector& ), but returns the number of successful read operations in case of an error.
    //
    // Parameters:  [in ]   const Uint64Vector&   addresses       A list of register addresses
    //              [out]   Uint64Vector&         buffer          The returned data as vector
    //              [out]   VmbUint32_t&          completedReads  The number of successfully read registers
    //
    // Returns:
    //  - VmbErrorSuccess:      If all requested registers have been read
    //  - VmbErrorBadParameter: Vectors "addresses" and/or "buffer" are empty.
    //  - VmbErrorIncomplete:   If at least one, but not all registers have been read.
    //
    public native @Cast("VmbErrorType") int ReadRegisters( @Cast("VmbUint64_t*") @StdVector IntPointer addresses, @Cast("VmbUint64_t*") @StdVector IntPointer buffer, @Cast("VmbUint32_t*") @ByRef IntPointer completedReads );
    public native @Cast("VmbErrorType") int ReadRegisters( @Cast("VmbUint64_t*") @StdVector IntBuffer addresses, @Cast("VmbUint64_t*") @StdVector IntBuffer buffer, @Cast("VmbUint32_t*") @ByRef IntBuffer completedReads );
    public native @Cast("VmbErrorType") int ReadRegisters( @Cast("VmbUint64_t*") @StdVector int[] addresses, @Cast("VmbUint64_t*") @StdVector int[] buffer, @Cast("VmbUint32_t*") @ByRef int[] completedReads );
    
    //
    // Method:      WriteRegisters()
    //
    // Purpose:     Writes one or more registers consecutively. The number of registers to write is determined by the number of provided addresses.
    //
    // Parameters:  [in]    const Uint64Vector&     addresses  A list of register addresses
    //              [in]    const Uint64Vector&     buffer     The data to write as vector
    //
    // Returns:
    //  - VmbErrorSuccess:      If all requested registers have been written
    //  - VmbErrorBadParameter: Vectors "addresses" and/or "buffer" are empty.
    //  - VmbErrorIncomplete:   If at least one, but not all registers have been written. See overload WriteRegisters( const Uint64Vector&, const Uint64Vector&, VmbUint32_t& ).
    //
    public native @Cast("VmbErrorType") int WriteRegisters( @Cast("VmbUint64_t*") @StdVector IntPointer addresses, @Cast("VmbUint64_t*") @StdVector IntPointer buffer );
    public native @Cast("VmbErrorType") int WriteRegisters( @Cast("VmbUint64_t*") @StdVector IntBuffer addresses, @Cast("VmbUint64_t*") @StdVector IntBuffer buffer );
    public native @Cast("VmbErrorType") int WriteRegisters( @Cast("VmbUint64_t*") @StdVector int[] addresses, @Cast("VmbUint64_t*") @StdVector int[] buffer );

    //
    // Method:      WriteRegisters()
    //
    // Purpose:     Same as WriteRegisters( const Uint64Vector&, const Uint64Vector& ), but returns the number of successful write operations in case of an error.
    //
    // Parameters:  [in ]   const Uint64Vector&   addresses        A list of register addresses
    //              [in ]   const Uint64Vector&   buffer           The data to write as vector
    //              [out]   VmbUint32_t&          completedWrites  The number of successfully read registers
    //
    // Returns:
    //  - VmbErrorSuccess:      If all requested registers have been written
    //  - VmbErrorBadParameter: Vectors "addresses" and/or "buffer" are empty.
    //  - VmbErrorIncomplete:   If at least one, but not all registers have been written.
    //
    public native @Cast("VmbErrorType") int WriteRegisters( @Cast("VmbUint64_t*") @StdVector IntPointer addresses, @Cast("VmbUint64_t*") @StdVector IntPointer buffer, @Cast("VmbUint32_t*") @ByRef IntPointer completedWrites );
    public native @Cast("VmbErrorType") int WriteRegisters( @Cast("VmbUint64_t*") @StdVector IntBuffer addresses, @Cast("VmbUint64_t*") @StdVector IntBuffer buffer, @Cast("VmbUint32_t*") @ByRef IntBuffer completedWrites );
    public native @Cast("VmbErrorType") int WriteRegisters( @Cast("VmbUint64_t*") @StdVector int[] addresses, @Cast("VmbUint64_t*") @StdVector int[] buffer, @Cast("VmbUint32_t*") @ByRef int[] completedWrites );

    //
    // Method:      ReadMemory()
    //
    // Purpose:     Reads a block of memory. The number of bytes to read is determined by the size of the provided buffer.
    //
    // Parameters:  [in ]   const VmbUint64_t&   address    The address to read from
    //              [out]   UcharVector&         buffer     The returned data as vector
    //
    // Returns:
    //  - VmbErrorSuccess:      If all requested bytes have been read
    //  - VmbErrorBadParameter: Vector "buffer" is empty.
    //  - VmbErrorIncomplete:   If at least one, but not all bytes have been read. See overload ReadMemory( const VmbUint64_t&, UcharVector&, VmbUint32_t& ).
    //
    public native @Cast("VmbErrorType") int ReadMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector BytePointer buffer );
    public native @Cast("VmbErrorType") int ReadMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector ByteBuffer buffer );
    public native @Cast("VmbErrorType") int ReadMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector byte[] buffer );

    //
    // Method:      ReadMemory()
    //
    // Purpose:     Same as ReadMemory( const Uint64Vector&, UcharVector& ), but returns the number of bytes successfully read in case of an error VmbErrorIncomplete.
    //
    // Parameters:  [in]    const VmbUint64_t&   address        The address to read from
    //              [out]   UcharVector&         buffer         The returned data as vector
    //              [out]   VmbUint32_t&         completeReads  The number of successfully read bytes
    //
    // Returns:
    //  - VmbErrorSuccess:      If all requested bytes have been read
    //  - VmbErrorBadParameter: Vector "buffer" is empty.
    //  - VmbErrorIncomplete:   If at least one, but not all bytes have been read.
    //
    public native @Cast("VmbErrorType") int ReadMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector BytePointer buffer, @Cast("VmbUint32_t*") @ByRef IntPointer completeReads );
    public native @Cast("VmbErrorType") int ReadMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector ByteBuffer buffer, @Cast("VmbUint32_t*") @ByRef IntBuffer completeReads );
    public native @Cast("VmbErrorType") int ReadMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector byte[] buffer, @Cast("VmbUint32_t*") @ByRef int[] completeReads );

    //
    // Method:      WriteMemory()
    //
    // Purpose:     Writes a block of memory. The number of bytes to write is determined by the size of the provided buffer.
    //
    // Parameters:  [in]    const VmbUint64_t&   address    The address to write to
    //              [in]    const UcharVector&   buffer     The data to write as vector
    //
    // Returns:
    //  - VmbErrorSuccess:      If all requested bytes have been written
    //  - VmbErrorBadParameter: Vector "buffer" is empty.
    //  - VmbErrorIncomplete:   If at least one, but not all bytes have been written. See overload WriteMemory( const VmbUint64_t&, const UcharVector&, VmbUint32_t& ).
    //
    public native @Cast("VmbErrorType") int WriteMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector BytePointer buffer );
    public native @Cast("VmbErrorType") int WriteMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector ByteBuffer buffer );
    public native @Cast("VmbErrorType") int WriteMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector byte[] buffer );

    //
    // Method:      WriteMemory()
    //
    // Purpose:     Same as WriteMemory( const Uint64Vector&, const UcharVector& ), but returns the number of bytes successfully written in case of an error VmbErrorIncomplete.
    //
    // Parameters:  [in]    const VmbUint64_t&   address        The address to write to
    //              [in]    const UcharVector&   buffer         The data to write as vector
    //              [out]   VmbUint32_t&         sizeComplete   The number of successfully written bytes
    //
    // Returns:
    //  - VmbErrorSuccess:      If all requested bytes have been written
    //  - VmbErrorBadParameter: Vector "buffer" is empty.
    //  - VmbErrorIncomplete:   If at least one, but not all bytes have been written.
    //
    public native @Cast("VmbErrorType") int WriteMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector BytePointer buffer, @Cast("VmbUint32_t*") @ByRef IntPointer sizeComplete );
    public native @Cast("VmbErrorType") int WriteMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector ByteBuffer buffer, @Cast("VmbUint32_t*") @ByRef IntBuffer sizeComplete );
    public native @Cast("VmbErrorType") int WriteMemory( @Cast("const VmbUint64_t") int address, @Cast("VmbUchar_t*") @StdVector byte[] buffer, @Cast("VmbUint32_t*") @ByRef int[] sizeComplete );

    //
    // Method:      AcquireSingleImage()
    //
    // Purpose:     Gets one image synchronously.
    //
    // Parameters:  [out]   FramePtr&       pFrame          The frame that gets filled
    //              [in ]   VmbUint32_t     timeout         The time to wait until the frame got filled
    //
    // Returns:
    //  - VmbErrorSuccess:      If no error
    //  - VmbErrorBadParameter: "pFrame" is NULL.
    //  - VmbErrorTimeout:      Call timed out
    //
    public native @Cast("VmbErrorType") int AcquireSingleImage( @SharedPtr @ByRef Frame pFrame, @Cast("VmbUint32_t") int timeout );

    //
    // Method:      AcquireMultipleImages()
    //
    // Purpose:     Gets a certain number of images synchronously.
    //
    // Parameters:  [out]   FramePtrVector& frames          The frames that get filled
    //              [in ]   VmbUint32_t     timeout         The time to wait until one frame got filled
    //
    // Details:     The size of the frame vector determines the number of frames to use.
    //
    // Returns:
    //  - VmbErrorSuccess:          If no error
    //  - VmbErrorInternalFault:    Filling all the frames was not successful.
    //  - VmbErrorBadParameter:     Vector "frames" is empty.
    //
    public native @Cast("VmbErrorType") int AcquireMultipleImages( @SharedPtr @StdVector Frame frames, @Cast("VmbUint32_t") int timeout );

    //
    // Method:      AcquireMultipleImages()
    //
    // Purpose:     Same as AcquireMultipleImages(FramePtrVector&, VmbUint32_t), but returns the number of frames that were filled completely.
    //
    // Parameters:  [out]   FramePtrVector& frames              The frames that get filled
    //              [in ]   VmbUint32_t     timeout             The time to wait until one frame got filled
    //              [out]   VmbUint32_t&    numFramesCompleted  The number of frames that were filled completely
    //
    // Details:     The size of the frame vector determines the number of frames to use.
    //              On return, "numFramesCompleted" holds the number of frames actually filled.
    //
    // Returns:
    //  - VmbErrorSuccess:      If no error
    //  - VmbErrorBadParameter: Vector "frames" is empty.
    //
    public native @Cast("VmbErrorType") int AcquireMultipleImages( @SharedPtr @StdVector Frame frames, @Cast("VmbUint32_t") int timeout, @Cast("VmbUint32_t*") @ByRef IntPointer numFramesCompleted );
    public native @Cast("VmbErrorType") int AcquireMultipleImages( @SharedPtr @StdVector Frame frames, @Cast("VmbUint32_t") int timeout, @Cast("VmbUint32_t*") @ByRef IntBuffer numFramesCompleted );
    public native @Cast("VmbErrorType") int AcquireMultipleImages( @SharedPtr @StdVector Frame frames, @Cast("VmbUint32_t") int timeout, @Cast("VmbUint32_t*") @ByRef int[] numFramesCompleted );

    //
    // Method:      StartContinuousImageAcquisition()
    //
    // Purpose:     Starts streaming and allocates the needed frames
    //
    // Parameters:  [in ]   int                         bufferCount    The number of frames to use
    //              [out]   const IFrameObserverPtr&    pObserver      The observer to use on arrival of new frames
    //
    // Returns:
    //
    //  - VmbErrorSuccess:        If no error
    //  - VmbErrorDeviceNotOpen:  The camera has not been opened before
    //  - VmbErrorApiNotStarted:  VmbStartup() was not called before the current command
    //  - VmbErrorBadHandle:      The given handle is not valid
    //  - VmbErrorInvalidAccess:  Operation is invalid with the current access mode
    //
    public native @Cast("VmbErrorType") int StartContinuousImageAcquisition( int bufferCount, @Const @SharedPtr @ByRef IFrameObserver pObserver );

    //
    // Method:      StopContinuousImageAcquisition()
    //
    // Purpose:     Stops streaming and deallocates the needed frames
    //
    public native @Cast("VmbErrorType") int StopContinuousImageAcquisition();

    //
    // Method:      AnnounceFrame()
    //
    // Purpose:     Announces a frame to the API that may be queued for frame capturing later.
    //
    // Parameters:
    //
    //  [in ]  const FramePtr&    pFrame         Shared pointer to a frame to announce
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //  - VmbErrorBadHandle:     The given handle is not valid
    //  - VmbErrorBadParameter:  "pFrame" is NULL.
    //  - VmbErrorStructSize:    The given struct size is not valid for this version of the API
    //
    // Details:     Allows some preparation for frames like DMA preparation depending on the transport layer.
    //              The order in which the frames are announced is not taken in consideration by the API.
    //
    public native @Cast("VmbErrorType") int AnnounceFrame( @Const @SharedPtr @ByRef Frame pFrame );
    
    //
    // Method:      RevokeFrame()
    //
    // Purpose:     Revoke a frame from the API.
    //
    // Parameters:
    //
    //  [in ]  const FramePtr&    pFrame         Shared pointer to a frame that is to be removed from the list of announced frames
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //  - VmbErrorBadHandle:     The given frame pointer is not valid
    //  - VmbErrorBadParameter:  "pFrame" is NULL.
    //  - VmbErrorStructSize:    The given struct size is not valid for this version of the API
    //
    // Details:    The referenced frame is removed from the pool of frames for capturing images.
    //
    public native @Cast("VmbErrorType") int RevokeFrame( @Const @SharedPtr @ByRef Frame pFrame );

    //
    // Method:      RevokeAllFrames()
    //
    // Purpose:     Revoke all frames assigned to this certain camera.
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //  - VmbErrorBadHandle:     The given handle is not valid
    //
    public native @Cast("VmbErrorType") int RevokeAllFrames();
    
    //
    // Method:      QueueFrame()
    //
    // Purpose:     Queues a frame that may be filled during frame capturing.
    //
    // Parameters:
    //
    //  [in ]  const FramePtr&    pFrame    A shared pointer to a frame
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //  - VmbErrorBadHandle:     The given frame is not valid
    //  - VmbErrorBadParameter:  "pFrame" is NULL.
    //  - VmbErrorStructSize:    The given struct size is not valid for this version of the API
    //  - VmbErrorInvalidCall:   StopContinuousImageAcquisition is currently running in another thread
    //
    // Details:     The given frame is put into a queue that will be filled sequentially.
    //              The order in which the frames are filled is determined by the order in which they are queued.
    //              If the frame was announced with AnnounceFrame() before, the application
    //              has to ensure that the frame is also revoked by calling RevokeFrame() or RevokeAll()
    //              when cleaning up.
    //
    public native @Cast("VmbErrorType") int QueueFrame( @Const @SharedPtr @ByRef Frame pFrame );

    //
    // Method:      FlushQueue()
    //
    // Purpose:     Flushes the capture queue.
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //  - VmbErrorBadHandle:     The given handle is not valid
    //
    // Details:     All the currently queued frames will be returned to the user, leaving no frames in the input queue.
    //              After this call, no frame notification will occur until frames are queued again.
    //
    public native @Cast("VmbErrorType") int FlushQueue();
    
    //
    // Method:      StartCapture()
    //
    // Purpose:     Prepare the API for incoming frames from this camera.
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //  - VmbErrorBadHandle:     The given handle is not valid
    //  - VmbErrorDeviceNotOpen: Camera was not opened for usage
    //  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
    //
    public native @Cast("VmbErrorType") int StartCapture();

    //
    // Method:      EndCapture()
    //
    // Purpose:     Stop the API from being able to receive frames from this camera.
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //  - VmbErrorBadHandle:     The given handle is not valid
    //
    // Details:     Consequences of VmbCaptureEnd():
    //                  - The frame queue is flushed
    //                  - The frame callback will not be called any more
    //
    public native @Cast("VmbErrorType") int EndCapture();

    //
    // Method:      SaveCameraSettings()
    //
    // Purpose:     Saves the current camera setup to an XML file
    //
    // Parameters:
    //
    //  [in ]   std::string                     pStrFileName    xml file name
    //  [in ]   VmbFeaturePersistSettings_t*    pSettings       pointer to settings struct
    //
    // Returns:
    //
    //  - VmbErrorSuccess:          If no error
    //  - VmbErrorApiNotStarted:    VmbStartup() was not called before the current command
    //  - VmbErrorBadHandle:        The given handle is not valid
    //  - VmbErrorInternalFault:    When something unexpected happens in VimbaC function
    //  - VmbErrorOther:            Every other failure in load/save settings implementation class
    //
    public native @Cast("VmbErrorType") int SaveCameraSettings( @StdString BytePointer fileName, VmbFeaturePersistSettings_t pSettings/*=0*/ );
    public native @Cast("VmbErrorType") int SaveCameraSettings( @StdString BytePointer fileName );
    public native @Cast("VmbErrorType") int SaveCameraSettings( @StdString String fileName, VmbFeaturePersistSettings_t pSettings/*=0*/ );
    public native @Cast("VmbErrorType") int SaveCameraSettings( @StdString String fileName );

    //
    // Method:      LoadCameraSettings()
    //
    // Purpose:     Loads the current camera setup from an XML file into the camera
    //
    // Parameters:
    //
    //  [in] std::string                    pStrFileName    xml file name
    //  [in] VmbFeaturePersistSettings_t*   pSettings       pointer to settings struct
    //
    // Returns:
    //
    //  - VmbErrorSuccess:          If no error
    //  - VmbErrorApiNotStarted:    VmbStartup() was not called before the current command
    //  - VmbErrorBadHandle:        The given handle is not valid
    //  - VmbErrorInternalFault:    When something unexpected happens in VimbaC function
    //  - VmbErrorOther:            Every other failure in load/save settings implementation class
    //
    public native @Cast("VmbErrorType") int LoadCameraSettings( @StdString BytePointer fileName, VmbFeaturePersistSettings_t pSettings/*=0*/ );
    public native @Cast("VmbErrorType") int LoadCameraSettings( @StdString BytePointer fileName );
    public native @Cast("VmbErrorType") int LoadCameraSettings( @StdString String fileName, VmbFeaturePersistSettings_t pSettings/*=0*/ );
    public native @Cast("VmbErrorType") int LoadCameraSettings( @StdString String fileName );

    //
    // Method:      LoadSaveSettingsSetup()
    //
    // Purpose:     Sets Load/Save settings behaviour (alternative to settings struct)
    //
    // Parameters:
    //
    //  [in] VmbFeaturePersist_t  persistType    determines which feature shall be considered during load/save settings
    //  [in] VmbUint32_t          maxIterations  determines how many 'tries' during loading feature values shall be performed
    //  [in] VmbUint32_t          loggingLevel   determines level of detail for load/save settings logging
    //
    public native void LoadSaveSettingsSetup( @Cast("VmbFeaturePersist_t") int persistType, @Cast("VmbUint32_t") int maxIterations, @Cast("VmbUint32_t") int loggingLevel );
}

// #include <VimbaCPP/Include/Camera.hpp>

 // namespace AVT::VmbAPI

// #endif


// Parsed from <VimbaCPP/Include/Feature.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        Feature.h

  Description:  Definition of base class AVT::VmbAPI::Feature.
                This class wraps every call to BaseFeature resp. its concrete
                subclass. That way  polymorphism is hidden away from the user.
                

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_FEATURE_H
// #define AVT_VMBAPI_FEATURE_H

// #include <vector>
// #include <map>

// #include <VimbaC/Include/VimbaC.h>
// #include <VimbaCPP/Include/VimbaCPPCommon.h>
// #include <VimbaCPP/Include/SharedPointerDefines.h>
// #include <VimbaCPP/Include/IFeatureObserver.h>
// #include <VimbaCPP/Include/EnumEntry.h>

@Namespace("AVT::VmbAPI") @Opaque public static class BaseFeature extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public BaseFeature() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public BaseFeature(Pointer p) { super(p); }
}

@Namespace("AVT::VmbAPI") @NoOffset public static class Feature extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Feature(Pointer p) { super(p); }

    public Feature( @Const VmbFeatureInfo_t pFeatureInfo, FeatureContainer pFeatureContainer ) { super((Pointer)null); allocate(pFeatureInfo, pFeatureContainer); }
    private native void allocate( @Const VmbFeatureInfo_t pFeatureInfo, FeatureContainer pFeatureContainer );

    //
    // Method:      GetValue()
    //
    // Purpose:     Queries the value of a feature of type VmbInt64
    //
    // Parameters:
    //
    // [out]    VmbInt64_t&     value       The feature's value
    //
    public native @Cast("VmbErrorType") int GetValue( @Cast("VmbInt64_t*") @ByRef LongPointer value );
    public native @Cast("VmbErrorType") int GetValue( @Cast("VmbInt64_t*") @ByRef LongBuffer value );
    public native @Cast("VmbErrorType") int GetValue( @Cast("VmbInt64_t*") @ByRef long[] value );
    
    //
    // Method:      GetValue()
    //
    // Purpose:     Queries the value of a feature of type double
    //
    // Parameters:
    //
    // [out]    double&     value       The feature's value
    //
    public native @Cast("VmbErrorType") int GetValue( @ByRef DoublePointer value );
    public native @Cast("VmbErrorType") int GetValue( @ByRef DoubleBuffer value );
    public native @Cast("VmbErrorType") int GetValue( @ByRef double[] value );

    //
    // Method:      GetValue()
    //
    // Purpose:     Queries the value of a feature of type string
    //
    // Parameters:
    //
    // [out]    std::string&    value       The feature's value
    //
    // Details:     When an empty string is returned, its size
    //              indicates the maximum length
    public native @Cast("VmbErrorType") int GetValue( @StdString BytePointer value );
    public native @Cast("VmbErrorType") int GetValue( @StdString String value );

    //
    // Method:      GetValue()
    //
    // Purpose:     Queries the value of a feature of type bool
    //
    // Parameters:
    //
    // [out]    bool&       value       The feature's value
    //
    public native @Cast("VmbErrorType") int GetValue( @Cast("bool*") @ByRef BoolPointer value );
    public native @Cast("VmbErrorType") int GetValue( @Cast("bool*") @ByRef boolean[] value );

    //
    // Method:      GetValue()
    //
    // Purpose:     Queries the value of a feature of type UcharVector
    //
    // Parameters:
    //
    // [out]    UcharVector&    value       The feature's value
    //
    public native @Cast("VmbErrorType") int GetValue( @Cast("VmbUchar_t*") @StdVector ByteBuffer value );
    public native @Cast("VmbErrorType") int GetValue( @Cast("VmbUchar_t*") @StdVector byte[] value );

    //
    // Method:      GetValue()
    //
    // Purpose:     Queries the value of a feature of type const UcharVector
    //
    // Parameters:
    //
    // [out]    UcharVector&      value       The feature's value
    // [out]    VmbUint32_t&            sizeFilled  The number of actually received values
    //
    public native @Cast("VmbErrorType") int GetValue( @Cast("VmbUchar_t*") @StdVector BytePointer value, @Cast("VmbUint32_t*") @ByRef IntPointer sizeFilled );
    public native @Cast("VmbErrorType") int GetValue( @Cast("VmbUchar_t*") @StdVector ByteBuffer value, @Cast("VmbUint32_t*") @ByRef IntBuffer sizeFilled );
    public native @Cast("VmbErrorType") int GetValue( @Cast("VmbUchar_t*") @StdVector byte[] value, @Cast("VmbUint32_t*") @ByRef int[] sizeFilled );

    //
    // Method:      GetValues()
    //
    // Purpose:     Queries the values of a feature of type Int64Vector
    //
    // Parameters:
    //
    // [out]    Int64Vector&    values       The feature's values
    //
    public native @Cast("VmbErrorType") int GetValues( @Cast("VmbInt64_t*") @StdVector LongPointer values );
    public native @Cast("VmbErrorType") int GetValues( @Cast("VmbInt64_t*") @StdVector LongBuffer values );
    public native @Cast("VmbErrorType") int GetValues( @Cast("VmbInt64_t*") @StdVector long[] values );

    //
    // Method:      GetValues()
    //
    // Purpose:     Queries the values of a feature of type StringVector
    //
    // Parameters:
    //
    // [out]    StringVector&    values       The feature's values
    //
    public native @Cast("VmbErrorType") int GetValues( @StdString @StdVector BytePointer values );
    public native @Cast("VmbErrorType") int GetValues( @StdString @StdVector String values );

    //
    // Method:      GetEntry()
    //
    // Purpose:     Queries a single enum entry of a feature of type Enumeration
    //
    // Parameters:
    //
    // [out]    EnumEntry&    entry       An enum feature's enum entry
    // [in ]    const char*   pEntryName  The name of the enum entry
    //
    public native @Cast("VmbErrorType") int GetEntry( @ByRef EnumEntry entry, @Cast("const char*") BytePointer pEntryName );
    public native @Cast("VmbErrorType") int GetEntry( @ByRef EnumEntry entry, String pEntryName );

    //
    // Method:      GetEntries()
    //
    // Purpose:     Queries all enum entries of a feature of type Enumeration
    //
    // Parameters:
    //
    // [out]    EnumEntryVector&   entries       An enum feature's enum entries
    //
    public native @Cast("VmbErrorType") int GetEntries( @StdVector EnumEntry entries );

    //
    // Method:      GetRange()
    //
    // Purpose:     Queries the range of a feature of type double
    //
    // Parameters:
    //
    // [out]    double&    minimum   The feature's min value
    // [out]    double&    maximum   The feature's max value
    //
    public native @Cast("VmbErrorType") int GetRange( @ByRef DoublePointer minimum, @ByRef DoublePointer maximum );
    public native @Cast("VmbErrorType") int GetRange( @ByRef DoubleBuffer minimum, @ByRef DoubleBuffer maximum );
    public native @Cast("VmbErrorType") int GetRange( @ByRef double[] minimum, @ByRef double[] maximum );

    //
    // Method:      GetRange()
    //
    // Purpose:     Queries the range of a feature of type VmbInt64
    //
    // Parameters:
    //
    // [out]    VmbInt64_t&    minimum   The feature's min value
    // [out]    VmbInt64_t&    maximum   The feature's max value
    //
    public native @Cast("VmbErrorType") int GetRange( @Cast("VmbInt64_t*") @ByRef LongPointer minimum, @Cast("VmbInt64_t*") @ByRef LongPointer maximum );
    public native @Cast("VmbErrorType") int GetRange( @Cast("VmbInt64_t*") @ByRef LongBuffer minimum, @Cast("VmbInt64_t*") @ByRef LongBuffer maximum );
    public native @Cast("VmbErrorType") int GetRange( @Cast("VmbInt64_t*") @ByRef long[] minimum, @Cast("VmbInt64_t*") @ByRef long[] maximum );

    //
    // Method:      SetValue()
    //
    // Purpose:     Sets the value of a feature of type VmbInt32
    //
    // Parameters:
    //
    // [in ]    const VmbInt32_t&    value       The feature's value
    //
    public native @Cast("VmbErrorType") int SetValue( @Cast("const VmbInt32_t") int value );

    //
    // Method:      SetValue()
    //
    // Purpose:     Sets the value of a feature of type VmbInt64
    //
    // Parameters:
    //
    // [in ]    const VmbInt64_t&   value       The feature's value
    //
    public native @Cast("VmbErrorType") int SetValue( @Cast("const VmbInt64_t") long value );

    //
    // Method:      SetValue()
    //
    // Purpose:     Sets the value of a feature of type double
    //
    // Parameters:
    //
    // [in ]    const double&    value       The feature's value
    //
    public native @Cast("VmbErrorType") int SetValue( double value );

    //
    // Method:      SetValue()
    //
    // Purpose:     Sets the value of a feature of type char*
    //
    // Parameters:
    //
    // [in ]    const char*    pValue       The feature's value
    //
    public native @Cast("VmbErrorType") int SetValue( @Cast("const char*") BytePointer pValue );
    public native @Cast("VmbErrorType") int SetValue( String pValue );

    //
    // Method:      SetValue()
    //
    // Purpose:     Sets the value of a feature of type bool
    //
    // Parameters:
    //
    // [in ]    bool    value       The feature's value
    //
    public native @Cast("VmbErrorType") int SetValue( @Cast("bool") boolean value );

    //
    // Method:      SetValue()
    //
    // Purpose:     Sets the value of a feature of type UcharVector
    //
    // Parameters:
    //
    // [in ]    const UcharVector&    value       The feature's value
    //
    public native @Cast("VmbErrorType") int SetValue( @Cast("VmbUchar_t*") @StdVector ByteBuffer value );
    public native @Cast("VmbErrorType") int SetValue( @Cast("VmbUchar_t*") @StdVector byte[] value );

    // Method:      HasIncrement()
    //
    // Purpose:     Gets the support state increment of a feature
    //
    // Parameters:
    //
    // [out]    VmbBool_t&    incrementsupported       The feature's increment support state
    //
    public native @Cast("VmbErrorType") int HasIncrement( @Cast("VmbBool_t*") @ByRef BoolPointer incrementSupported );
    public native @Cast("VmbErrorType") int HasIncrement( @Cast("VmbBool_t*") @ByRef boolean[] incrementSupported );


    //
    // Method:      GetIncrement()
    //
    // Purpose:     Gets the increment of a feature of type VmbInt64
    //
    // Parameters:
    //
    // [out]    VmbInt64_t&    increment       The feature's increment
    //
    public native @Cast("VmbErrorType") int GetIncrement( @Cast("VmbInt64_t*") @ByRef LongPointer increment );
    public native @Cast("VmbErrorType") int GetIncrement( @Cast("VmbInt64_t*") @ByRef LongBuffer increment );
    public native @Cast("VmbErrorType") int GetIncrement( @Cast("VmbInt64_t*") @ByRef long[] increment );

    // Method:      GetIncrement()
    //
    // Purpose:     Gets the increment of a feature of type double
    //
    // Parameters:
    //
    // [out]    double&    increment       The feature's increment
    //
    public native @Cast("VmbErrorType") int GetIncrement( @ByRef DoublePointer increment );
    public native @Cast("VmbErrorType") int GetIncrement( @ByRef DoubleBuffer increment );
    public native @Cast("VmbErrorType") int GetIncrement( @ByRef double[] increment );

    //
    // Method:      IsValueAvailable()
    //
    // Purpose:     Indicates whether an existing enumeration value is currently available.
    //              An enumeration value might not be selectable due to the camera's
    //              current configuration.
    //
    // Parameters:
    //
    // [in ]        const char*     pValue      The enumeration value as string
    // [out]        bool&           available   True when the given value is available
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorInvalidValue:  If the given value is not a valid enumeration value for this enum
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
    //  - VmbErrorWrongType:     The feature is not an enumeration
    //
    public native @Cast("VmbErrorType") int IsValueAvailable( @Cast("const char*") BytePointer pValue, @Cast("bool*") @ByRef BoolPointer available );
    public native @Cast("VmbErrorType") int IsValueAvailable( String pValue, @Cast("bool*") @ByRef boolean[] available );

    //
    // Method:      IsValueAvailable()
    //
    // Purpose:     Indicates whether an existing enumeration value is currently available.
    //              An enumeration value might not be selectable due to the camera's
    //              current configuration.
    //
    // Parameters:
    //
    // [in ]        const VmbInt64_t    value       The enumeration value as int
    // [out]        bool&               available   True when the given value is available
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorInvalidValue:  If the given value is not a valid enumeration value for this enum
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
    //  - VmbErrorWrongType:     The feature is not an enumeration
    //
    public native @Cast("VmbErrorType") int IsValueAvailable( @Cast("const VmbInt64_t") long value, @Cast("bool*") @ByRef BoolPointer available );
    public native @Cast("VmbErrorType") int IsValueAvailable( @Cast("const VmbInt64_t") long value, @Cast("bool*") @ByRef boolean[] available );

    //
    // Method:      RunCommand()
    //
    // Purpose:     Executes a feature of type Command
    //
    public native @Cast("VmbErrorType") int RunCommand();

    //
    // Method:      IsCommandDone()
    //
    // Purpose:     Indicates whether the execution of a feature of type Command has finished
    //
    // Parameters:
    //
    // [out]    bool&    isDone     True when execution has finished
    //
    public native @Cast("VmbErrorType") int IsCommandDone( @Cast("bool*") @ByRef BoolPointer isDone );
    public native @Cast("VmbErrorType") int IsCommandDone( @Cast("bool*") @ByRef boolean[] isDone );

    //
    // Method:      GetName()
    //
    // Purpose:     Queries a feature's name
    //
    // Parameters:
    //
    // [out]    std::string&    name    The feature's name
    //
    public native @Cast("VmbErrorType") int GetName( @StdString BytePointer name );
    public native @Cast("VmbErrorType") int GetName( @StdString String name );

    //
    // Method:      GetDisplayName()
    //
    // Purpose:     Queries a feature's display name
    //
    // Parameters:
    //
    // [out]    std::string&    displayName    The feature's display name
    //
    public native @Cast("VmbErrorType") int GetDisplayName( @StdString BytePointer displayName );
    public native @Cast("VmbErrorType") int GetDisplayName( @StdString String displayName );

    //
    // Method:      GetDataType()
    //
    // Purpose:     Queries a feature's type
    //
    // Parameters:
    //
    // [out]    VmbFeatureDataType&    dataType    The feature's type
    //
    public native @Cast("VmbErrorType") int GetDataType( @Cast("VmbFeatureDataType*") @ByRef IntPointer dataType );
    public native @Cast("VmbErrorType") int GetDataType( @Cast("VmbFeatureDataType*") @ByRef IntBuffer dataType );
    public native @Cast("VmbErrorType") int GetDataType( @Cast("VmbFeatureDataType*") @ByRef int[] dataType );

    //
    // Method:      GetFlags()
    //
    // Purpose:     Queries a feature's access status
    //
    // Parameters:
    //
    // [out]    VmbFeatureFlagsType&    flags    The feature's access status
    //    
    public native @Cast("VmbErrorType") int GetFlags( @Cast("VmbFeatureFlagsType*") @ByRef IntPointer flags );
    public native @Cast("VmbErrorType") int GetFlags( @Cast("VmbFeatureFlagsType*") @ByRef IntBuffer flags );
    public native @Cast("VmbErrorType") int GetFlags( @Cast("VmbFeatureFlagsType*") @ByRef int[] flags );

    //
    // Method:      GetCategory()
    //
    // Purpose:     Queries a feature's category in the feature tress
    //
    // Parameters:
    //
    // [out]    std::string&    category    The feature's position in the feature tree
    //    
    public native @Cast("VmbErrorType") int GetCategory( @StdString BytePointer category );
    public native @Cast("VmbErrorType") int GetCategory( @StdString String category );

    //
    // Method:      GetPollingTime()
    //
    // Purpose:     Queries a feature's polling time
    //
    // Parameters:
    //
    // [out]    VmbUint32_t&    pollingTime    The interval to poll the feature
    //    
    public native @Cast("VmbErrorType") int GetPollingTime( @Cast("VmbUint32_t*") @ByRef IntPointer pollingTime );
    public native @Cast("VmbErrorType") int GetPollingTime( @Cast("VmbUint32_t*") @ByRef IntBuffer pollingTime );
    public native @Cast("VmbErrorType") int GetPollingTime( @Cast("VmbUint32_t*") @ByRef int[] pollingTime );

    //
    // Method:      GetUnit()
    //
    // Purpose:     Queries a feature's unit
    //
    // Parameters:
    //
    // [out]    std::string&    unit    The feature's unit
    //
    public native @Cast("VmbErrorType") int GetUnit( @StdString BytePointer unit );
    public native @Cast("VmbErrorType") int GetUnit( @StdString String unit );

    //
    // Method:      GetRepresentation()
    //
    // Purpose:     Queries a feature's representation
    //
    // Parameters:
    //
    // [out]    std::string&    representation    The feature's representation
    //
    public native @Cast("VmbErrorType") int GetRepresentation( @StdString BytePointer representation );
    public native @Cast("VmbErrorType") int GetRepresentation( @StdString String representation );

    //
    // Method:      GetVisibility()
    //
    // Purpose:     Queries a feature's visibility
    //
    // Parameters:
    //
    // [out]    VmbFeatureVisibilityType&    visibility    The feature's visibility
    //
    public native @Cast("VmbErrorType") int GetVisibility( @Cast("VmbFeatureVisibilityType*") @ByRef IntPointer visibility );
    public native @Cast("VmbErrorType") int GetVisibility( @Cast("VmbFeatureVisibilityType*") @ByRef IntBuffer visibility );
    public native @Cast("VmbErrorType") int GetVisibility( @Cast("VmbFeatureVisibilityType*") @ByRef int[] visibility );

    //
    // Method:      GetToolTip()
    //
    // Purpose:     Queries a feature's tool tip to display in the GUI
    //
    // Parameters:
    //
    // [out]    std::string&    toolTip    The feature's tool tip
    //
    public native @Cast("VmbErrorType") int GetToolTip( @StdString BytePointer toolTip );
    public native @Cast("VmbErrorType") int GetToolTip( @StdString String toolTip );

    //
    // Method:      GetDescription()
    //
    // Purpose:     Queries a feature's description
    //
    // Parameters:
    //
    // [out]    std::string&    description    The feature'sdescription
    //
    public native @Cast("VmbErrorType") int GetDescription( @StdString BytePointer description );
    public native @Cast("VmbErrorType") int GetDescription( @StdString String description );

    //
    // Method:      GetSFNCNamespace()
    //
    // Purpose:     Queries a feature's Standard Feature Naming Convention namespace
    //
    // Parameters:
    //
    // [out]    std::string&    sFNCNamespace    The feature's SFNC namespace
    //
    public native @Cast("VmbErrorType") int GetSFNCNamespace( @StdString BytePointer sFNCNamespace );
    public native @Cast("VmbErrorType") int GetSFNCNamespace( @StdString String sFNCNamespace );

    //
    // Method:      GetAffectedFeatures()
    //
    // Purpose:     Queries the feature's that are dependent from the current feature
    //
    // Parameters:
    //
    // [out]    FeaturePtrVector&    affectedFeatures    The features that get invalidated through the current feature
    //
    public native @Cast("VmbErrorType") int GetAffectedFeatures( @SharedPtr @StdVector Feature affectedFeatures );

    //
    // Method:      GetSelectedFeatures()
    //
    // Purpose:     Gets the features that get selected by the current feature
    //
    // Parameters:
    //
    // [out]    FeaturePtrVector&    selectedFeatures    The selected features
    //
    public native @Cast("VmbErrorType") int GetSelectedFeatures( @SharedPtr @StdVector Feature selectedFeatures );

    //
    // Method:      IsReadable()
    //
    // Purpose:     Queries the read access status of a feature
    //
    // Parameters:
    //
    // [out]    bool&    isReadable    True when feature can be read
    //
    public native @Cast("VmbErrorType") int IsReadable( @Cast("bool*") @ByRef BoolPointer isReadable );
    public native @Cast("VmbErrorType") int IsReadable( @Cast("bool*") @ByRef boolean[] isReadable );

    //
    // Method:      IsWritable()
    //
    // Purpose:     Queries the write access status of a feature
    //
    // Parameters:
    //
    // [out]    bool&    isWritable    True when feature can be written
    //
    public native @Cast("VmbErrorType") int IsWritable( @Cast("bool*") @ByRef BoolPointer isWritable );
    public native @Cast("VmbErrorType") int IsWritable( @Cast("bool*") @ByRef boolean[] isWritable );

    //
    // Method:      IsStreamable()
    //
    // Purpose:     Queries whether a feature's value can be transferred as a stream
    //
    // Parameters:
    //
    // [out]    bool&    isStreamable    True when streamable
    //
    public native @Cast("VmbErrorType") int IsStreamable( @Cast("bool*") @ByRef BoolPointer isStreamable );
    public native @Cast("VmbErrorType") int IsStreamable( @Cast("bool*") @ByRef boolean[] isStreamable );

    //
    // Method:      RegisterObserver()
    //
    // Purpose:     Registers an observer that notifies the application whenever a features value changes
    //
    // Parameters:
    //
    // [out]    const IFeatureObserverPtr&    pObserver    The observer to be registered
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorBadParameter:  "pObserver" is NULL.
    //
    public native @Cast("VmbErrorType") int RegisterObserver( @Const @SharedPtr @ByRef IFeatureObserver pObserver );

    //
    // Method:      UnregisterObserver()
    //
    // Purpose:     Unregisters an observer
    //
    // Parameters:
    //
    // [out]    const IFeatureObserverPtr&    pObserver    The observer to be unregistered
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorBadParameter:  "pObserver" is NULL.
    //
    public native @Cast("VmbErrorType") int UnregisterObserver( @Const @SharedPtr @ByRef IFeatureObserver pObserver );

    public native void ResetFeatureContainer();
}

// #include <VimbaCPP/Include/Feature.hpp>

 // namespace AVT::VmbAPI

// #endif


// Parsed from <VimbaCPP/Include/FeatureContainer.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        FeatureContainer.h

  Description: Definition of class AVT::VmbAPI::FeatureContainer.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_FEATURECONTAINER_H
// #define AVT_VMBAPI_FEATURECONTAINER_H

// #include <VimbaC/Include/VmbCommonTypes.h>
// #include <VimbaCPP/Include/VimbaCPPCommon.h>
// #include <VimbaCPP/Include/BasicLockable.h>
// #include <VimbaCPP/Include/SharedPointerDefines.h>
// #include <VimbaCPP/Include/Feature.h>

@Namespace("AVT::VmbAPI") @NoOffset public static class FeatureContainer extends BasicLockable {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FeatureContainer(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public FeatureContainer(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public FeatureContainer position(long position) {
        return (FeatureContainer)super.position(position);
    }


    //
    // Method:      FeatureContainer constructor
    //
    // Purpose:     Creates an instance of class FeatureContainer
    //
    public FeatureContainer() { super((Pointer)null); allocate(); }
    private native void allocate();

    //
    // Method:      FeatureContainer destructor
    //
    // Purpose:     Destroys an instance of class FeatureContainer
    //

    //
    // Method:      GetFeatureByName()
    //
    // Purpose:     Gets one particular feature of a feature container (e.g. a camera)
    //
    // Parameters:
    //
    // [in ]    const char*         name                The name of the feature to get
    // [out]    FeaturePtr&         pFeature            The queried feature
    //
    // Returns:
    //
    //  - VmbErrorSuccess:          If no error
    //  - VmbErrorDeviceNotOpen:    Base feature class (e.g. Camera) was not opened.
    //  - VmbErrorBadParameter:     "name" is NULL.
    //
    public native @Cast("VmbErrorType") int GetFeatureByName( @Cast("const char*") BytePointer pName, @SharedPtr @ByRef Feature pFeature );
    public native @Cast("VmbErrorType") int GetFeatureByName( String pName, @SharedPtr @ByRef Feature pFeature );
    
    //
    // Method:      GetFeatures()
    //
    // Purpose:     Gets all features of a feature container (e.g. a camera)
    //
    // Parameters:
    //
    // [out]    FeaturePtrVector&   features        The container for all queried features
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorBadParameter:  "features" is empty.
    //
    // Details:   Once queried, this information remains static throughout the object's lifetime
    //
    public native @Cast("VmbErrorType") int GetFeatures( @SharedPtr @StdVector Feature features );

    public native VmbHandle_t GetHandle();
}

// #include <VimbaCPP/Include/FeatureContainer.hpp>

 // namespace AVT::VmbAPI

// #endif


// Parsed from <VimbaCPP/Include/VimbaSystem.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------
 
  File:        VimbaSystem.h

  Description: Definition of class AVT::VmbAPI::VimbaSystem.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_SYSTEM_H
// #define AVT_VMBAPI_SYSTEM_H

// #include <vector>

// #include <VimbaC/Include/VimbaC.h>
// #include <VimbaCPP/Include/VimbaCPPCommon.h>
// #include <VimbaCPP/Include/LoggerDefines.h>
// #include <VimbaCPP/Include/SharedPointerDefines.h>
// #include <VimbaCPP/Include/Interface.h>
// #include <VimbaCPP/Include/Camera.h>
// #include <VimbaCPP/Include/ICameraFactory.h>
// #include <VimbaCPP/Include/ICameraListObserver.h>
// #include <VimbaCPP/Include/IInterfaceListObserver.h>

@Namespace("AVT::VmbAPI") @NoOffset public static class VimbaSystem extends FeatureContainer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VimbaSystem(Pointer p) { super(p); }

    //
    // Method:      GetInstance()
    //
    // Purpose:     Returns a reference to the System singleton.
    //
    // Parameters:  none
    //
    // Returns:
    //
    //  - VimbaSystem&
    //
    public static native @ByRef VimbaSystem GetInstance();

    //
    // Method:    QueryVersion()
    //
    // Purpose:   Retrieve the version number of VmbAPI.
    //
    // Parameters:
    //
    //  [out]  VmbVersionInfo_t&   version      Reference to the struct where version information
    //                                          is copied
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       always returned
    //
    // Details:    This function can be called at any time, even before the API is
    //             initialized. All other version numbers may be queried via feature access
    //
    public native @Cast("VmbErrorType") int QueryVersion( @ByRef VmbVersionInfo_t version );
    
    //
    // Method:      Startup()
    //
    // Purpose:     Initialize the VmbAPI module.
    //
    // Parameters:  none
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorInternalFault: An internal fault occurred
    //
    // Details:   On successful return, the API is initialized; this is a necessary call.
    //            This method must be called before any other VmbAPI function is run.
    //
    public native @Cast("VmbErrorType") int Startup();

    //
    // Method:    Shutdown()
    //
    // Purpose:   Perform a shutdown on the API module.
    //
    // Parameters: none
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       always returned
    //
    // Details:   This will free some resources and deallocate all physical resources if applicable.
    //
    public native @Cast("VmbErrorType") int Shutdown();

    //
    // Method:    GetInterfaces()
    //
    // Purpose:   List all the interfaces currently visible to VmbAPI.
    //
    // Parameters:
    //
    //  [out]  InterfacePtrVector& interfaces            Vector of shared pointer to Interface object
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //  - VmbErrorStructSize:    The given struct size is not valid for this API version
    //  - VmbErrorMoreData:      More data were returned than space was provided
    //  - VmbErrorInternalFault: An internal fault occurred
    //
    // Details:     All the interfaces known via a GenTL are listed by this command and filled into the vector provided.
    //              If the vector is not empty, new elements will be appended.
    //              Interfaces can be adapter cards or frame grabber cards, for instance.
    //
    public native @Cast("VmbErrorType") int GetInterfaces( @SharedPtr @StdVector Interface interfaces );

    //
    // Method:    GetInterfaceByID()
    //
    // Purpose:   Gets a specific interface identified by an ID.
    //
    // Parameters:
    //
    //  [in ]  const char*          pID                 The ID of the interface to get (returned by GetInterfaces())
    //  [out]  InterfacePtr&        pInterface          Shared pointer to Interface object
    //
    // Returns:
    //
    //  - VmbErrorSuccess:          If no error
    //  - VmbErrorApiNotStarted:    VmbStartup() was not called before the current command
    //  - VmbErrorBadParameter:     "pID" is NULL.
    //  - VmbErrorStructSize:       The given struct size is not valid for this API version
    //  - VmbErrorMoreData:         More data were returned than space was provided
    //
    // Details:     An interface known via a GenTL is listed by this command and filled into the pointer provided.
    //              Interface can be an adapter card or a frame grabber card, for instance.
    //
    public native @Cast("VmbErrorType") int GetInterfaceByID( @Cast("const char*") BytePointer pID, @SharedPtr @ByRef Interface pInterface );
    public native @Cast("VmbErrorType") int GetInterfaceByID( String pID, @SharedPtr @ByRef Interface pInterface );

    //
    // Method:      OpenInterfaceByID()
    //
    // Purpose:     Open an interface for feature access.
    //
    // Parameters:
    //
    //  [in ]  const char*      pID                 The ID of the interface to open (returned by GetInterfaces())
    //  [out]  InterfacePtr&    pInterface          A shared pointer to the interface
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //  - VmbErrorNotFound:      The designated interface cannot be found
    //  - VmbErrorBadParameter:  "pID" is NULL.
    //
    //
    // Details:     An interface can be opened if interface-specific control is required, such as I/O pins
    //              on a frame grabber card. Control is then possible via feature access methods.
    //
    public native @Cast("VmbErrorType") int OpenInterfaceByID( @Cast("const char*") BytePointer pID, @SharedPtr @ByRef Interface pInterface );
    public native @Cast("VmbErrorType") int OpenInterfaceByID( String pID, @SharedPtr @ByRef Interface pInterface );

    //
    // Method:    GetCameras()
    //
    // Purpose:   Retrieve a list of all cameras.
    //
    // Parameters:
    //
    //  [out]  CameraPtrVector& cameras            Vector of shared pointer to Camera object
    //
    // Returns:
    //
    //  - VmbErrorSuccess:       If no error
    //  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
    //  - VmbErrorStructSize:    The given struct size is not valid for this API version
    //  - VmbErrorMoreData:      More data were returned than space was provided
    //
    // Details:     A camera known via a GenTL is listed by this command and filled into the pointer provided.
    //
    public native @Cast("VmbErrorType") int GetCameras( @SharedPtr @StdVector Camera cameras );

    //
    // Method:    GetCameraByID()
    //
    // Purpose:   Gets a specific camera identified by an ID. The returned camera is still closed.
    //
    // Parameters:
    //
    //  [in ]  const char*          pID                 The ID of the camera to get
    //  [out]  CameraPtr&           pCamera             Shared pointer to camera object
    //
    // Returns:
    //
    //  - VmbErrorSuccess:          If no error
    //  - VmbErrorApiNotStarted:    VmbStartup() was not called before the current command
    //  - VmbErrorBadParameter:     "pID" is NULL.
    //  - VmbErrorStructSize:       The given struct size is not valid for this API version
    //  - VmbErrorMoreData:         More data were returned than space was provided
    //
    // Details:     A camera known via a GenTL is listed by this command and filled into the pointer provided.
    //              Only static properties of the camera can be fetched until the camera has been opened.
    //              "pID" might be one of the following: 
    //              "169.254.12.13" for an IP address,
    //              "000F314C4BE5" for a MAC address or 
    //              "DEV_1234567890" for an ID as reported by Vimba
    //
    public native @Cast("VmbErrorType") int GetCameraByID( @Cast("const char*") BytePointer pID, @SharedPtr @ByRef Camera pCamera );
    public native @Cast("VmbErrorType") int GetCameraByID( String pID, @SharedPtr @ByRef Camera pCamera );
    
    //
    // Method:      OpenCameraByID()
    //
    // Purpose:     Gets a specific camera identified by an ID. The returned camera is already open.
    //
    // Parameters:
    //
    //  [in ]   const char*         pID                 The unique ID of the camera to get
    //  [in ]   VmbAccessModeType   eAccessMode         The requested access mode
    //  [out]   CameraPtr&          pCamera             A shared pointer to the camera
    //
    // Returns:
    //
    //  - VmbErrorSuccess:          If no error
    //  - VmbErrorApiNotStarted:    VmbStartup() was not called before the current command
    //  - VmbErrorNotFound:         The designated interface cannot be found
    //  - VmbErrorBadParameter:     "pID" is NULL.
    //
    // Details:     A camera can be opened if camera-specific control is required, such as I/O pins
    //              on a frame grabber card. Control is then possible via feature access methods.
    //              "pID" might be one of the following: 
    //              "169.254.12.13" for an IP address,
    //              "000F314C4BE5" for a MAC address or 
    //              "DEV_1234567890" for an ID as reported by Vimba
    //
    public native @Cast("VmbErrorType") int OpenCameraByID( @Cast("const char*") BytePointer pID, @Cast("VmbAccessModeType") int eAccessMode, @SharedPtr @ByRef Camera pCamera );
    public native @Cast("VmbErrorType") int OpenCameraByID( String pID, @Cast("VmbAccessModeType") int eAccessMode, @SharedPtr @ByRef Camera pCamera );

    //
    // Method:      RegisterCameraListObserver()
    //
    // Purpose:     Registers an instance of camera observer whose CameraListChanged() method gets called
    //              as soon as a camera is plugged in, plugged out, or changes its access status
    //
    // Parameters:
    //
    //  [in ]       const ICameraListObserverPtr&   pObserver   A shared pointer to an object derived from ICameraListObserver
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //  - VmbErrorBadParameter: "pObserver" is NULL.
    //  - VmbErrorInvalidCall:  If the very same observer is already registered
    //
    public native @Cast("VmbErrorType") int RegisterCameraListObserver( @Const @SharedPtr @ByRef ICameraListObserver pObserver );

    //
    // Method:      UnregisterCameraListObserver()
    //
    // Purpose:     Unregisters a camera observer
    //
    // Parameters:
    //
    //  [in ]       const ICameraListObserverPtr&   pObserver   A shared pointer to an object derived from ICameraListObserver
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //  - VmbErrorNotFound:     If the observer is not registered
    //  - VmbErrorBadParameter: "pObserver" is NULL.
    //
    public native @Cast("VmbErrorType") int UnregisterCameraListObserver( @Const @SharedPtr @ByRef ICameraListObserver pObserver );

    //
    // Method:      RegisterInterfaceListObserver()
    //
    // Purpose:     Registers an instance of interface observer whose InterfaceListChanged() method gets called
    //              as soon as an interface is plugged in, plugged out, or changes its access status
    //
    // Parameters:
    //
    //  [in ]       const IInterfaceListObserverPtr&    pObserver   A shared pointer to an object derived from IInterfaceListObserver
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //  - VmbErrorBadParameter: "pObserver" is NULL.
    //  - VmbErrorInvalidCall:  If the very same observer is already registered
    //
    public native @Cast("VmbErrorType") int RegisterInterfaceListObserver( @Const @SharedPtr @ByRef IInterfaceListObserver pObserver );

    //
    // Method:      UnregisterInterfaceListObserver()
    //
    // Purpose:     Unregisters an interface observer
    //
    // Parameters:
    //
    //  [in ]       const IInterfaceListObserverPtr&    pObserver   A shared pointer to an object derived from IInterfaceListObserver
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //  - VmbErrorNotFound:     If the observer is not registered
    //  - VmbErrorBadParameter: "pObserver" is NULL.
    //
    public native @Cast("VmbErrorType") int UnregisterInterfaceListObserver( @Const @SharedPtr @ByRef IInterfaceListObserver pObserver );

    //
    // Method:      RegisterCameraFactory()
    //
    // Purpose:     Registers an instance of camera factory. When a custom camera factory is registered, all instances of type camera
    //              will be set up accordingly.
    //
    // Parameters:
    //
    //  [in ]       const ICameraFactoryPtr&        pCameraFactory  A shared pointer to an object derived from ICameraFactory
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //  - VmbErrorBadParameter: "pCameraFactory" is NULL.
    //
    public native @Cast("VmbErrorType") int RegisterCameraFactory( @Const @SharedPtr @ByRef ICameraFactory pCameraFactory );

    //
    // Method:      UnregisterCameraFactory()
    //
    // Purpose:     Unregisters the camera factory. After unregistering the default camera class is used.
    //
    // Returns:
    //
    //  - VmbErrorSuccess:      If no error
    //
    public native @Cast("VmbErrorType") int UnregisterCameraFactory();

    // Mapping of handle to CameraPtr
    public native @SharedPtr @ByVal Camera GetCameraPtrByHandle( VmbHandle_t handle );
}

// #include <VimbaCPP/Include/VimbaSystem.hpp>

 // namespace AVT::VmbAPI
// #endif


}
