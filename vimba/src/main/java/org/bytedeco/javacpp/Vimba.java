// Targeted by JavaCPP version 1.4.1-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import org.bytedeco.javacpp.annotation.*;

import java.nio.ByteBuffer;
import java.nio.DoubleBuffer;
import java.nio.IntBuffer;
import java.nio.LongBuffer;

public class Vimba extends org.bytedeco.javacpp.presets.Vimba {
    static { Loader.load(); }

// Parsed from <VimbaC/Include/VmbCommonTypes.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this header file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------
 
  File:        VmbCommonTypes.h

  Description: Main header file for the common types of the Vimba APIs.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef VMBCOMMONTYPES_H_INCLUDE_
// #define VMBCOMMONTYPES_H_INCLUDE_

// #ifdef __cplusplus
// #endif

// This file describes all necessary definitions for types used within 
// Allied Vision's Vimba APIs. These type definitions are designed to be
// portable from other languages and other operating systems.

// #if defined (_MSC_VER)

    // 8 bit signed integer on Microsoft systems
    // 8 bit unsigned integer on Microsoft systems
    // 16 bit signed integer on Microsoft systems
    // 16 bit unsigned integer on Microsoft systems
    // 32 bit signed integer on Microsoft systems
    // 32 bit unsigned integer on Microsoft systems
    // 64 bit signed integer on Microsoft systems
    // 64 bit unsigned integer on Microsoft systems

// #else // for non MS or GNU compilers without any warranty for the size

    //#pragma message("Compatibility warning: typedefs in " __FILE__ " may not have the correct number of bits")

    // 8 bit signed integer on non-Microsoft systems
    // 8 bit unsigned integer on non-Microsoft systems
    // 16 bit signed integer on non-Microsoft systems
    // 16 bit unsigned integer on non-Microsoft systems
    // 32 bit signed integer on non-Microsoft systems
    // 32 bit signed integer on non-Microsoft systems
    // 64 bit signed integer on non-Microsoft systems
    // 64 bit unsigned integer on non-Microsoft systems

// #endif

    // Handle; e.g. for a camera
    @Namespace @Name("void") @Opaque public static class VmbHandle_t extends Pointer {
        /** Empty constructor. Calls {@code super((Pointer)null)}. */
        public VmbHandle_t() { super((Pointer)null); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public VmbHandle_t(Pointer p) { super(p); }
    }

// Standard type for boolean values
// #if defined(__cplusplus) || defined(__bool_true_false_are_defined)
// #else
    // Boolean type (equivalent to char)      // 1 means true and 0 means false
// #endif
    //
    // enum for bool values
    //
    /** enum VmbBoolVal */
    public static final int
        VmbBoolTrue = 1,
        VmbBoolFalse = 0;

    // char type

    //
    // Error codes, returned by most functions: (not yet complete)
    //
    /** enum VmbErrorType */
    public static final int
        VmbErrorSuccess         = 0,           // No error
        VmbErrorInternalFault   = -1,           // Unexpected fault in VimbaC or driver
        VmbErrorApiNotStarted   = -2,           // VmbStartup() was not called before the current command
        VmbErrorNotFound        = -3,           // The designated instance (camera, feature etc.) cannot be found
        VmbErrorBadHandle       = -4,           // The given handle is not valid
        VmbErrorDeviceNotOpen   = -5,           // Device was not opened for usage
        VmbErrorInvalidAccess   = -6,           // Operation is invalid with the current access mode
        VmbErrorBadParameter    = -7,           // One of the parameters is invalid (usually an illegal pointer)
        VmbErrorStructSize      = -8,           // The given struct size is not valid for this version of the API
        VmbErrorMoreData        = -9,           // More data available in a string/list than space is provided
        VmbErrorWrongType       = -10,          // Wrong feature type for this access function 
        VmbErrorInvalidValue    = -11,          // The value is not valid; either out of bounds or not an increment of the minimum
        VmbErrorTimeout         = -12,          // Timeout during wait
        VmbErrorOther           = -13,          // Other error
        VmbErrorResources       = -14,          // Resources not available (e.g. memory)
        VmbErrorInvalidCall     = -15,          // Call is invalid in the current context (e.g. callback)
        VmbErrorNoTL            = -16,          // No transport layers are found 
        VmbErrorNotImplemented  = -17,          // API feature is not implemented
        VmbErrorNotSupported    = -18,          // API feature is not supported
        VmbErrorIncomplete      = -19;          // A multiple registers read or write is partially completed              // Type for an error returned by API methods; for values see VmbErrorType

    //
    // Version information
    //
    public static class VmbVersionInfo_t extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public VmbVersionInfo_t() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public VmbVersionInfo_t(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public VmbVersionInfo_t(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public VmbVersionInfo_t position(long position) {
            return (VmbVersionInfo_t)super.position(position);
        }
    
        public native @Cast("VmbUint32_t") int major(); public native VmbVersionInfo_t major(int major);          // Major version number
        public native @Cast("VmbUint32_t") int minor(); public native VmbVersionInfo_t minor(int minor);          // Minor version number
        public native @Cast("VmbUint32_t") int patch(); public native VmbVersionInfo_t patch(int patch);          // Patch version number

    }

    //
    // Indicate if pixel is monochrome or RGB.
    //
    /** enum VmbPixelType */
    public static final int
        VmbPixelMono  =          0x01000000,     // Monochrome pixel
        VmbPixelColor =          0x02000000;      // Pixel bearing color information

    //
    // Indicate number of bits for a pixel. Needed for building values of VmbPixelFormatType
    //
    /** enum VmbPixelOccupyType */
    public static final int
        VmbPixelOccupy8Bit  =    0x00080000,     // Pixel effectively occupies 8 bits
        VmbPixelOccupy10Bit =    0x000A0000,     // Pixel effectively occupies 10 bits
        VmbPixelOccupy12Bit =    0x000C0000,     // Pixel effectively occupies 12 bits
        VmbPixelOccupy14Bit =    0x000E0000,     // Pixel effectively occupies 14 bits
        VmbPixelOccupy16Bit =    0x00100000,     // Pixel effectively occupies 16 bits
        VmbPixelOccupy24Bit =    0x00180000,     // Pixel effectively occupies 24 bits
        VmbPixelOccupy32Bit =    0x00200000,     // Pixel effectively occupies 32 bits
        VmbPixelOccupy48Bit =    0x00300000,     // Pixel effectively occupies 48 bits
        VmbPixelOccupy64Bit =    0x00400000;     // Pixel effectively occupies 48 bits

    //
    // Pixel format types.
    // As far as possible, the Pixel Format Naming Convention (PFNC) has been followed, allowing a few deviations.
    // If data spans more than one byte, it is always LSB aligned, except if stated differently.
    //
    /** enum VmbPixelFormatType */
    public static final int
        // mono formats
        VmbPixelFormatMono8               =  VmbPixelMono  | VmbPixelOccupy8Bit  | 0x0001,  // Monochrome, 8 bits (PFNC:Mono8)
        VmbPixelFormatMono10              =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0003,  // Monochrome, 10 bits in 16 bits (PFNC:Mono10)
        VmbPixelFormatMono10p             =  VmbPixelMono  | VmbPixelOccupy10Bit | 0x0046,  // Monochrome, 10 bits in 16 bits (PFNC:Mono10p)
        VmbPixelFormatMono12              =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0005,  // Monochrome, 12 bits in 16 bits (PFNC:Mono12)
        VmbPixelFormatMono12Packed        =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x0006,  // Monochrome, 2x12 bits in 24 bits (GEV:Mono12Packed)
        VmbPixelFormatMono12p             =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x0047,  // Monochrome, 2x12 bits in 24 bits (PFNC:MonoPacked)
        VmbPixelFormatMono14              =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0025,  // Monochrome, 14 bits in 16 bits (PFNC:Mono14)
        VmbPixelFormatMono16              =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0007,  // Monochrome, 16 bits (PFNC:Mono16)
        // bayer formats
        VmbPixelFormatBayerGR8            =  VmbPixelMono  | VmbPixelOccupy8Bit  | 0x0008,  // Bayer-color, 8 bits, starting with GR line (PFNC:BayerGR8)
        VmbPixelFormatBayerRG8            =  VmbPixelMono  | VmbPixelOccupy8Bit  | 0x0009,  // Bayer-color, 8 bits, starting with RG line (PFNC:BayerRG8)
        VmbPixelFormatBayerGB8            =  VmbPixelMono  | VmbPixelOccupy8Bit  | 0x000A,  // Bayer-color, 8 bits, starting with GB line (PFNC:BayerGB8)
        VmbPixelFormatBayerBG8            =  VmbPixelMono  | VmbPixelOccupy8Bit  | 0x000B,  // Bayer-color, 8 bits, starting with BG line (PFNC:BayerBG8)
        VmbPixelFormatBayerGR10           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x000C,  // Bayer-color, 10 bits in 16 bits, starting with GR line (PFNC:BayerGR10)
        VmbPixelFormatBayerRG10           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x000D,  // Bayer-color, 10 bits in 16 bits, starting with RG line (PFNC:BayerRG10)
        VmbPixelFormatBayerGB10           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x000E,  // Bayer-color, 10 bits in 16 bits, starting with GB line (PFNC:BayerGB10)
        VmbPixelFormatBayerBG10           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x000F,  // Bayer-color, 10 bits in 16 bits, starting with BG line (PFNC:BayerBG10)
        VmbPixelFormatBayerGR12           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0010,  // Bayer-color, 12 bits in 16 bits, starting with GR line (PFNC:BayerGR12)
        VmbPixelFormatBayerRG12           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0011,  // Bayer-color, 12 bits in 16 bits, starting with RG line (PFNC:BayerRG12)
        VmbPixelFormatBayerGB12           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0012,  // Bayer-color, 12 bits in 16 bits, starting with GB line (PFNC:BayerGB12)
        VmbPixelFormatBayerBG12           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0013,  // Bayer-color, 12 bits in 16 bits, starting with BG line (PFNC:BayerBG12)
        VmbPixelFormatBayerGR12Packed     =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x002A,  // Bayer-color, 2x12 bits in 24 bits, starting with GR line (GEV:BayerGR12Packed)
        VmbPixelFormatBayerRG12Packed     =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x002B,  // Bayer-color, 2x12 bits in 24 bits, starting with RG line (GEV:BayerRG12Packed)
        VmbPixelFormatBayerGB12Packed     =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x002C,  // Bayer-color, 2x12 bits in 24 bits, starting with GB line (GEV:BayerGB12Packed)
        VmbPixelFormatBayerBG12Packed     =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x002D,  // Bayer-color, 2x12 bits in 24 bits, starting with BG line (GEV:BayerBG12Packed)
        VmbPixelFormatBayerGR10p          =  VmbPixelMono  | VmbPixelOccupy10Bit | 0x0056,  // Bayer-color, 12 bits continuous packed, starting with GR line (PFNC:BayerGR10p)
        VmbPixelFormatBayerRG10p          =  VmbPixelMono  | VmbPixelOccupy10Bit | 0x0058,  // Bayer-color, 12 bits continuous packed, starting with RG line (PFNC:BayerRG10p)
        VmbPixelFormatBayerGB10p          =  VmbPixelMono  | VmbPixelOccupy10Bit | 0x0054,  // Bayer-color, 12 bits continuous packed, starting with GB line (PFNC:BayerGB10p)
        VmbPixelFormatBayerBG10p          =  VmbPixelMono  | VmbPixelOccupy10Bit | 0x0052,  // Bayer-color, 12 bits continuous packed, starting with BG line (PFNC:BayerBG10p)
        VmbPixelFormatBayerGR12p          =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x0057,  // Bayer-color, 12 bits continuous packed, starting with GR line (PFNC:BayerGR12p)
        VmbPixelFormatBayerRG12p          =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x0059,  // Bayer-color, 12 bits continuous packed, starting with RG line (PFNC:BayerRG12p)
        VmbPixelFormatBayerGB12p          =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x0055,  // Bayer-color, 12 bits continuous packed, starting with GB line (PFNC:BayerGB12p)
        VmbPixelFormatBayerBG12p          =  VmbPixelMono  | VmbPixelOccupy12Bit | 0x0053,  // Bayer-color, 12 bits continuous packed, starting with BG line (PFNC:BayerBG12p)
        VmbPixelFormatBayerGR16           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x002E,  // Bayer-color, 16 bits, starting with GR line (PFNC:BayerGR16)
        VmbPixelFormatBayerRG16           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x002F,  // Bayer-color, 16 bits, starting with RG line (PFNC:BayerRG16)
        VmbPixelFormatBayerGB16           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0030,  // Bayer-color, 16 bits, starting with GB line (PFNC:BayerGB16)
        VmbPixelFormatBayerBG16           =  VmbPixelMono  | VmbPixelOccupy16Bit | 0x0031,  // Bayer-color, 16 bits, starting with BG line (PFNC:BayerBG16)
        // rgb formats
        VmbPixelFormatRgb8                =  VmbPixelColor | VmbPixelOccupy24Bit | 0x0014,  // RGB, 8 bits x 3 (PFNC:RGB8)
        VmbPixelFormatBgr8                =  VmbPixelColor | VmbPixelOccupy24Bit | 0x0015,  // BGR, 8 bits x 3 (PFNC:BGR8)
        VmbPixelFormatRgb10               =  VmbPixelColor | VmbPixelOccupy48Bit | 0x0018,  // RGB, 12 bits in 16 bits x 3 (PFNC:RGB12)
        VmbPixelFormatBgr10               =  VmbPixelColor | VmbPixelOccupy48Bit | 0x0019,  // RGB, 12 bits in 16 bits x 3 (PFNC:RGB12)
        VmbPixelFormatRgb12               =  VmbPixelColor | VmbPixelOccupy48Bit | 0x001A,  // RGB, 12 bits in 16 bits x 3 (PFNC:RGB12)
        VmbPixelFormatBgr12               =  VmbPixelColor | VmbPixelOccupy48Bit | 0x001B,  // RGB, 12 bits in 16 bits x 3 (PFNC:RGB12)

        VmbPixelFormatRgb14               =  VmbPixelColor | VmbPixelOccupy48Bit | 0x005E,  // RGB, 14 bits in 16 bits x 3 (PFNC:RGB12)
        VmbPixelFormatBgr14               =  VmbPixelColor | VmbPixelOccupy48Bit | 0x004A,  // RGB, 14 bits in 16 bits x 3 (PFNC:RGB12)

        VmbPixelFormatRgb16               =  VmbPixelColor | VmbPixelOccupy48Bit | 0x0033,  // RGB, 16 bits x 3 (PFNC:RGB16)
        VmbPixelFormatBgr16               =  VmbPixelColor | VmbPixelOccupy48Bit | 0x004B,  // RGB, 16 bits x 3 (PFNC:RGB16)
        // rgba formats
        VmbPixelFormatArgb8               =  VmbPixelColor | VmbPixelOccupy32Bit | 0x0016,  // ARGB, 8 bits x 4 (PFNC:RGBa8)
        VmbPixelFormatRgba8               =  VmbPixelFormatArgb8,                           // RGBA, 8 bits x 4, legacy name
        VmbPixelFormatBgra8               =  VmbPixelColor | VmbPixelOccupy32Bit | 0x0017,  // BGRA, 8 bits x 4 (PFNC:BGRa8)
        VmbPixelFormatRgba10              =  VmbPixelColor | VmbPixelOccupy64Bit | 0x005F,                           // RGBA, 8 bits x 4, legacy name
        VmbPixelFormatBgra10              =  VmbPixelColor | VmbPixelOccupy64Bit | 0x004C,                           // RGBA, 8 bits x 4, legacy name
        VmbPixelFormatRgba12              =  VmbPixelColor | VmbPixelOccupy64Bit | 0x0061,                           // RGBA, 8 bits x 4, legacy name
        VmbPixelFormatBgra12              =  VmbPixelColor | VmbPixelOccupy64Bit | 0x004E,                           // RGBA, 8 bits x 4, legacy name

        VmbPixelFormatRgba14              =  VmbPixelColor | VmbPixelOccupy64Bit | 0x0063,                           // RGBA, 8 bits x 4, legacy name
        VmbPixelFormatBgra14              =  VmbPixelColor | VmbPixelOccupy64Bit | 0x0050,                           // RGBA, 8 bits x 4, legacy name

        VmbPixelFormatRgba16              =  VmbPixelColor | VmbPixelOccupy64Bit | 0x0064,                           // RGBA, 8 bits x 4, legacy name
        VmbPixelFormatBgra16              =  VmbPixelColor | VmbPixelOccupy64Bit | 0x0051,                           // RGBA, 8 bits x 4, legacy name
        // yuv/ycbcr formats
        VmbPixelFormatYuv411              =  VmbPixelColor | VmbPixelOccupy12Bit | 0x001E,  // YUV 411 with 8 bits (GEV:YUV411Packed)
        VmbPixelFormatYuv422              =  VmbPixelColor | VmbPixelOccupy16Bit | 0x001F,  // YUV 422 with 8 bits (GEV:YUV422Packed)
        VmbPixelFormatYuv444              =  VmbPixelColor | VmbPixelOccupy24Bit | 0x0020,  // YUV 444 with 8 bits (GEV:YUV444Packed)
        VmbPixelFormatYCbCr411_8_CbYYCrYY =  VmbPixelColor | VmbPixelOccupy12Bit | 0x003C,  // Y�CbCr 411 with 8 bits (PFNC:YCbCr411_8_CbYYCrYY) - identical to VmbPixelFormatYuv411
        VmbPixelFormatYCbCr422_8_CbYCrY   =  VmbPixelColor | VmbPixelOccupy16Bit | 0x0043,  // Y�CbCr 422 with 8 bits (PFNC:YCbCr422_8_CbYCrY) - identical to VmbPixelFormatYuv422
        VmbPixelFormatYCbCr8_CbYCr        =  VmbPixelColor | VmbPixelOccupy24Bit | 0x003A,  // Y�CbCr 444 with 8 bits (PFNC:YCbCr8_CbYCr) - identical to VmbPixelFormatYuv444
        VmbPixelFormatLast =  VmbPixelColor | VmbPixelOccupy24Bit | 0x003A + 1;       // Type for the pixel format; for values see VmbPixelFormatType

// #ifdef __cplusplus
// #endif

// #endif // VMBCOMMONTYPES_H_INCLUDE_


// Parsed from <VimbaC/Include/VimbaC.h>

/*=============================================================================
  Copyright (C) 2012 - 2017 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this header file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------
 
  File:        VimbaC.h

  Description: Main header file for the VimbaC API.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef VIMBAC_H_INCLUDE_
// #define VIMBAC_H_INCLUDE_

// This file describes all necessary definitions for using Allied Vision's
// VimbaC API. These type definitions are designed to be portable from other
// languages and other operating systems.
//
// General conventions:
// - Method names are composed in the following manner:
//    - Vmb"Action"                                        example: VmbStartup()
//    - Vmb"Entity""Action" or Vmb"ActionTarget""Action"   example: VmbInterfaceOpen()
//    - Vmb"Entity""SubEntity/ActionTarget""Action"        example: VmbFeatureCommandRun()
// - Methods dealing with features, memory or registers accept a handle from the following
//   entity list as first parameter: System, Camera, Interface and AncillaryData.
//   All other methods taking handles accept only a specific handle.
// - Strings (generally declared as "const char *") are assumed to have a trailing 0 character
// - All pointer parameters should of course be valid, except if stated otherwise.
// - To ensure compatibility with older programs linked against a former version of the API,
//   all struct* parameters have an accompanying sizeofstruct parameter.
// - Functions returning lists are usually called twice: once with a zero buffer
//   to get the length of the list, and then again with a buffer of the correct length.

//===== #DEFINES ==============================================================

// #if defined (_WIN32)
// #elif defined (__GNUC__) && (__GNUC__ >= 4) && defined (__ELF__)
    // SO exports (requires compiler option -fvisibility=hidden)
//     #ifdef AVT_VMBAPI_C_EXPORTS
//         #define IMEXPORTC __attribute__((visibility("default")))
//     #else
//         #define IMEXPORTC
//     #endif
    
//     #ifdef __i386__
//     #else
        // Calling convention
//         #define VMB_CALL
//     #endif
// #elif defined (__APPLE__)
//     #define IMEXPORTC __attribute__((visibility("default")))
    // Calling convention
//     #define VMB_CALL
// #else
//     #error Unknown platform, file needs adaption
// #endif

//===== TYPES ==============================================================
// #include "VmbCommonTypes.h"

// #ifdef __cplusplus
// #endif

// Timeout parameter signaling a blocking call
public static final int VMBINFINITE =        0xFFFFFFFF;

// Constant for the Vimba handle to be able to access Vimba system features
@MemberGetter public static native VmbHandle_t gVimbaHandle();

//
// Camera interface type (for instance FireWire, Ethernet);
//
/** enum VmbInterfaceType */
public static final int
    VmbInterfaceUnknown      = 0,           // Interface is not known to this version of the API
    VmbInterfaceFirewire     = 1,           // 1394
    VmbInterfaceEthernet     = 2,           // GigE
    VmbInterfaceUsb          = 3,           // USB 3.0
    VmbInterfaceCL           = 4,           // Camera Link
    VmbInterfaceCSI2         = 5;           // CSI-2         // Type for an Interface; for values see VmbInterfaceType

//
// Access mode for configurable devices (interfaces, cameras).
// Used in VmbCameraInfo_t, VmbInterfaceInfo_t as flags, so multiple modes can be
// announced, while in VmbCameraOpen(), no combination must be used.
//
/** enum VmbAccessModeType */
public static final int
    VmbAccessModeNone       = 0,            // No access
    VmbAccessModeFull       = 1,            // Read and write access
    VmbAccessModeRead       = 2,            // Read-only access
    VmbAccessModeConfig     = 4,            // Configuration access (GeV)
    VmbAccessModeLite       = 8;            // Read and write access without feature access (only addresses)        // Type for an AccessMode; for values see VmbAccessModeType

//
// Interface information.
// Holds read-only information about an interface.
//
public static class VmbInterfaceInfo_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public VmbInterfaceInfo_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public VmbInterfaceInfo_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VmbInterfaceInfo_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public VmbInterfaceInfo_t position(long position) {
        return (VmbInterfaceInfo_t)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer interfaceIdString();      // Unique identifier for each interface
    public native @Cast("VmbInterface_t") int interfaceType(); public native VmbInterfaceInfo_t interfaceType(int interfaceType);          // Interface type, see VmbInterfaceType
    @MemberGetter public native @Cast("const char*") BytePointer interfaceName();          // Interface name, given by the transport layer
    @MemberGetter public native @Cast("const char*") BytePointer serialString();           // Serial number
    public native @Cast("VmbAccessMode_t") int permittedAccess(); public native VmbInterfaceInfo_t permittedAccess(int permittedAccess);        // Used access mode, see VmbAccessModeType
}

//
// Camera information.
// Holds read-only information about a camera.
//
public static class VmbCameraInfo_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public VmbCameraInfo_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public VmbCameraInfo_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VmbCameraInfo_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public VmbCameraInfo_t position(long position) {
        return (VmbCameraInfo_t)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer cameraIdString();         // Unique identifier for each camera
    @MemberGetter public native @Cast("const char*") BytePointer cameraName();             // Name of the camera
    @MemberGetter public native @Cast("const char*") BytePointer modelName();              // Model name
    @MemberGetter public native @Cast("const char*") BytePointer serialString();           // Serial number
    public native @Cast("VmbAccessMode_t") int permittedAccess(); public native VmbCameraInfo_t permittedAccess(int permittedAccess);        // Used access mode, see VmbAccessModeType
    @MemberGetter public native @Cast("const char*") BytePointer interfaceIdString();      // Unique value for each interface or bus
}

//
// Supported feature data types
//
/** enum VmbFeatureDataType */
public static final int
    VmbFeatureDataUnknown     = 0,          // Unknown feature type
    VmbFeatureDataInt         = 1,          // 64 bit integer feature
    VmbFeatureDataFloat       = 2,          // 64 bit floating point feature
    VmbFeatureDataEnum        = 3,          // Enumeration feature
    VmbFeatureDataString      = 4,          // String feature
    VmbFeatureDataBool        = 5,          // Boolean feature
    VmbFeatureDataCommand     = 6,          // Command feature
    VmbFeatureDataRaw         = 7,          // Raw (direct register access) feature
    VmbFeatureDataNone        = 8;          // Feature with no data       // Data type for a Feature; for values see VmbFeatureDataType

//
// Feature visibility
//
/** enum VmbFeatureVisibilityType */
public static final int
    VmbFeatureVisibilityUnknown      = 0,   // Feature visibility is not known
    VmbFeatureVisibilityBeginner     = 1,   // Feature is visible in feature list (beginner level)
    VmbFeatureVisibilityExpert       = 2,   // Feature is visible in feature list (expert level)
    VmbFeatureVisibilityGuru         = 3,   // Feature is visible in feature list (guru level)
    VmbFeatureVisibilityInvisible    = 4;   // Feature is not visible in feature list // Type for Feature visibility; for values see VmbFeatureVisibilityType

//
// Feature flags
//
/** enum VmbFeatureFlagsType */
public static final int
    VmbFeatureFlagsNone         = 0,        // No additional information is provided
    VmbFeatureFlagsRead         = 1,        // Static info about read access. Current status depends on access mode, check with VmbFeachtureAccessQuery()
    VmbFeatureFlagsWrite        = 2,        // Static info about write access. Current status depends on access mode, check with VmbFeachtureAccessQuery()
    VmbFeatureFlagsVolatile     = 8,        // Value may change at any time
    VmbFeatureFlagsModifyWrite  = 16;       // Value may change after a write      // Type for Feature flags; for values see VmbFeatureFlagsType

//
// Feature information.
// Holds read-only information about a feature.
//
public static class VmbFeatureInfo_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public VmbFeatureInfo_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public VmbFeatureInfo_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VmbFeatureInfo_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public VmbFeatureInfo_t position(long position) {
        return (VmbFeatureInfo_t)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer name();                   // Name used in the API
    public native @Cast("VmbFeatureData_t") int featureDataType(); public native VmbFeatureInfo_t featureDataType(int featureDataType);        // Data type of this feature
    public native @Cast("VmbFeatureFlags_t") int featureFlags(); public native VmbFeatureInfo_t featureFlags(int featureFlags);           // Access flags for this feature
    @MemberGetter public native @Cast("const char*") BytePointer category();               // Category this feature can be found in
    @MemberGetter public native @Cast("const char*") BytePointer displayName();            // Feature name to be used in GUIs
    public native @Cast("VmbUint32_t") int pollingTime(); public native VmbFeatureInfo_t pollingTime(int pollingTime);            // Predefined polling time for volatile features
    @MemberGetter public native @Cast("const char*") BytePointer unit();                   // Measuring unit as given in the XML file
    @MemberGetter public native @Cast("const char*") BytePointer representation();         // Representation of a numeric feature
    public native @Cast("VmbFeatureVisibility_t") int visibility(); public native VmbFeatureInfo_t visibility(int visibility);             // GUI visibility
    @MemberGetter public native @Cast("const char*") BytePointer tooltip();                // Short description, e.g. for a tooltip
    @MemberGetter public native @Cast("const char*") BytePointer description();            // Longer description
    @MemberGetter public native @Cast("const char*") BytePointer sfncNamespace();          // Namespace this feature resides in
    public native @Cast("VmbBool_t") boolean isStreamable(); public native VmbFeatureInfo_t isStreamable(boolean isStreamable);           // Indicates if a feature can be stored to / loaded from a file
    public native @Cast("VmbBool_t") boolean hasAffectedFeatures(); public native VmbFeatureInfo_t hasAffectedFeatures(boolean hasAffectedFeatures);    // Indicates if the feature potentially affects other features
    public native @Cast("VmbBool_t") boolean hasSelectedFeatures(); public native VmbFeatureInfo_t hasSelectedFeatures(boolean hasSelectedFeatures);    // Indicates if the feature selects other features
}

//
// Info about possible entries of an enumeration feature
//
public static class VmbFeatureEnumEntry_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public VmbFeatureEnumEntry_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public VmbFeatureEnumEntry_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VmbFeatureEnumEntry_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public VmbFeatureEnumEntry_t position(long position) {
        return (VmbFeatureEnumEntry_t)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer name();           // Name used in the API
    @MemberGetter public native @Cast("const char*") BytePointer displayName();    // Enumeration entry name to be used in GUIs
    public native @Cast("VmbFeatureVisibility_t") int visibility(); public native VmbFeatureEnumEntry_t visibility(int visibility);     // GUI visibility
    @MemberGetter public native @Cast("const char*") BytePointer tooltip();        // Short description, e.g. for a tooltip
    @MemberGetter public native @Cast("const char*") BytePointer description();    // Longer description
    @MemberGetter public native @Cast("const char*") BytePointer sfncNamespace();  // Namespace this feature resides in
    public native @Cast("VmbInt64_t") long intValue(); public native VmbFeatureEnumEntry_t intValue(long intValue);       // Integer value of this enumeration entry
}

//
// Status of a frame transfer
//
/** enum VmbFrameStatusType */
public static final int
    VmbFrameStatusComplete       = 0,      // Frame has been completed without errors
    VmbFrameStatusIncomplete     = -1,      // Frame could not be filled to the end
    VmbFrameStatusTooSmall       = -2,      // Frame buffer was too small
    VmbFrameStatusInvalid        = -3;      // Frame buffer was invalid        // Type for the frame status; for values see VmbFrameStatusType

//
// Frame flags
//
/** enum VmbFrameFlagsType */
public static final int
    VmbFrameFlagsNone       = 0,            // No additional information is provided
    VmbFrameFlagsDimension  = 1,            // Frame's dimension is provided
    VmbFrameFlagsOffset     = 2,            // Frame's offset is provided (ROI)
    VmbFrameFlagsFrameID    = 4,            // Frame's ID is provided
    VmbFrameFlagsTimestamp  = 8;            // Frame's timestamp is provided        // Type for Frame flags; for values see VmbFrameFlagsType

//
// Frame delivered by the camera
//
public static class VmbFrame_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public VmbFrame_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public VmbFrame_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VmbFrame_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public VmbFrame_t position(long position) {
        return (VmbFrame_t)super.position(position);
    }

    //----- In -----
    public native Pointer buffer(); public native VmbFrame_t buffer(Pointer buffer);             // Comprises image and ancillary data
    public native @Cast("VmbUint32_t") int bufferSize(); public native VmbFrame_t bufferSize(int bufferSize);         // Size of the data buffer

    public native Pointer context(int i); public native VmbFrame_t context(int i, Pointer context);
    @MemberGetter public native @Cast("void**") PointerPointer context();         // 4 void pointers that can be employed by the user (e.g. for storing handles)

    //----- Out -----
    public native @Cast("VmbFrameStatus_t") int receiveStatus(); public native VmbFrame_t receiveStatus(int receiveStatus);      // Resulting status of the receive operation
    public native @Cast("VmbFrameFlags_t") int receiveFlags(); public native VmbFrame_t receiveFlags(int receiveFlags);       // Flags indicating which additional frame information is available

    public native @Cast("VmbUint32_t") int imageSize(); public native VmbFrame_t imageSize(int imageSize);          // Size of the image data inside the data buffer
    public native @Cast("VmbUint32_t") int ancillarySize(); public native VmbFrame_t ancillarySize(int ancillarySize);      // Size of the ancillary data inside the data buffer

    public native @Cast("VmbPixelFormat_t") int pixelFormat(); public native VmbFrame_t pixelFormat(int pixelFormat);        // Pixel format of the image

    public native @Cast("VmbUint32_t") int width(); public native VmbFrame_t width(int width);              // Width of an image
    public native @Cast("VmbUint32_t") int height(); public native VmbFrame_t height(int height);             // Height of an image
    public native @Cast("VmbUint32_t") int offsetX(); public native VmbFrame_t offsetX(int offsetX);            // Horizontal offset of an image
    public native @Cast("VmbUint32_t") int offsetY(); public native VmbFrame_t offsetY(int offsetY);            // Vertical offset of an image

    public native @Cast("VmbUint64_t") int frameID(); public native VmbFrame_t frameID(int frameID);            // Unique ID of this frame in this stream
    public native @Cast("VmbUint64_t") int timestamp(); public native VmbFrame_t timestamp(int timestamp);          // Timestamp set by the camera
}

//
// Type of features that are to be saved (persisted) to the XML file when using VmbCameraSettingsSave
//
/** enum VmbFeaturePersistType */
public static final int
    VmbFeaturePersistAll        = 0,        // Save all features to XML, including look-up tables
    VmbFeaturePersistStreamable = 1,        // Save only features marked as streamable, excluding look-up tables
    VmbFeaturePersistNoLUT      = 2;         // Save all features except look-up tables (default)    // Type for feature persistence; for values see VmbFeaturePersistType

//
// Parameters determining the operation mode of VmbCameraSettingsSave and VmbCameraSettingsLoad
//
public static class VmbFeaturePersistSettings_t extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public VmbFeaturePersistSettings_t() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public VmbFeaturePersistSettings_t(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VmbFeaturePersistSettings_t(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public VmbFeaturePersistSettings_t position(long position) {
        return (VmbFeaturePersistSettings_t)super.position(position);
    }

    public native @Cast("VmbFeaturePersist_t") int persistType(); public native VmbFeaturePersistSettings_t persistType(int persistType);        // Type of features that are to be saved
    public native @Cast("VmbUint32_t") int maxIterations(); public native VmbFeaturePersistSettings_t maxIterations(int maxIterations);      // Number of iterations when loading settings
    public native @Cast("VmbUint32_t") int loggingLevel(); public native VmbFeaturePersistSettings_t loggingLevel(int loggingLevel);       // Determines level of detail for load/save settings logging
}


// ----- Callbacks ------------------------------------------------------------

//
// Name: VmbInvalidationCallback
//
// Purpose: Invalidation Callback type for a function that gets called in a separate thread
//          and has been registered with VmbFeatureInvalidationRegister()
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle          Handle for an entity that exposes features
//  [in ]  const char*          name            Name of the feature
//  [in ]  void*                pUserContext    Pointer to the user context, see VmbFeatureInvalidationRegister
//
// Details:     While the callback is run, all feature data is atomic.  After the
//              callback finishes, the feature data might be updated with new values.
//
// Note:        Do not spend too much time in this thread; it will prevent the feature values
//              from being updated from any other thread or the lower-level drivers.
//
public static class VmbInvalidationCallback extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    VmbInvalidationCallback(Pointer p) { super(p); }
    protected VmbInvalidationCallback() { allocate(); }
    private native void allocate();
    public native void call( VmbHandle_t handle, @Cast("const char*") BytePointer name, Pointer pUserContext );
}

//
// Name: VmbFrameCallback
//
// Purpose: Frame Callback type for a function that gets called in a separate thread
//          if a frame has been queued with VmbCaptureFrameQueue()
//
// Parameters:
//
//  [in ]  const VmbHandle_t    cameraHandle    Handle of the camera
//  [out]  VmbFrame_t*          pFrame          Frame completed
//
public static class VmbFrameCallback extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    VmbFrameCallback(Pointer p) { super(p); }
    protected VmbFrameCallback() { allocate(); }
    private native void allocate();
    public native void call( VmbHandle_t cameraHandle, VmbFrame_t pFrame );
}


//===== FUNCTION PROTOTYPES ===================================================

//----- API Version -----------------------------------------------------------

//
// Method:      VmbVersionQuery()
//
// Purpose:     Retrieve the version number of VimbaC.
//
// Parameters:
//
//  [out]  VmbVersionInfo_t*    pVersionInfo        Pointer to the struct where version information
//                                                  is copied
//  [in ]  VmbUint32_t          sizeofVersionInfo   Size of structure in bytes
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorStructSize:    The given struct size is not valid for this version of the API
//  - VmbErrorBadParameter:  If "pVersionInfo" is NULL.
//
// Details:     This function can be called at anytime, even before the API is
//              initialized. All other version numbers may be queried via feature access.
//
public static native @Cast("VmbError_t") int VmbVersionQuery( VmbVersionInfo_t pVersionInfo,
                                                @Cast("VmbUint32_t") int sizeofVersionInfo );


//----- API Initialization ----------------------------------------------------

//
// Method:      VmbStartup()
//
// Purpose:     Initialize the VimbaC API.
//
// Parameters:
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorInternalFault: An internal fault occurred
//
// Details:     On successful return, the API is initialized; this is a necessary call.
//
// Note:        This method must be called before any VimbaC function other than VmbVersionQuery() is run.
//
public static native @Cast("VmbError_t") int VmbStartup( );

//
// Method:      VmbShutdown()
//
// Purpose:     Perform a shutdown on the API.
//
// Parameters:  none
//
// Returns:     none
//
// Details:     This will free some resources and deallocate all physical resources if applicable.
//
public static native void VmbShutdown( );


//----- Camera Enumeration & Information --------------------------------------

//
// Method:      VmbCamerasList()
//
// Purpose:     Retrieve a list of all cameras.
//
// Parameters:
//
//  [out]  VmbCameraInfo_t*  pCameraInfo        Array of VmbCameraInfo_t, allocated by
//                                              the caller. The camera list is
//                                              copied here. May be NULL if pNumFound is used for size query.
//  [in ]  VmbUint32_t       listLength         Number of VmbCameraInfo_t elements provided
//  [out]  VmbUint32_t*      pNumFound          Number of VmbCameraInfo_t elements found.
//  [in ]  VmbUint32_t       sizeofCameraInfo   Size of the structure (if pCameraInfo == NULL this parameter is ignored)
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorStructSize:    The given struct size is not valid for this API version
//  - VmbErrorMoreData:      The given list length was insufficient to hold all available entries
//  - VmbErrorBadParameter:  If "pNumFound" was NULL
//
// Details:     Camera detection is started with the registration of the "DiscoveryCameraEvent"
//              event or the first call of VmbCamerasList(), which may be delayed if no
//              "DiscoveryCameraEvent" event is registered (see examples).
//              VmbCamerasList() is usually called twice: once with an empty array to query the
//              list length, and then again with an array of the correct length. If camera
//              lists change between the calls, pNumFound may deviate from the query return.
//
public static native @Cast("VmbError_t") int VmbCamerasList( VmbCameraInfo_t pCameraInfo,
                                               @Cast("VmbUint32_t") int listLength,
                                               @Cast("VmbUint32_t*") IntPointer pNumFound,
                                               @Cast("VmbUint32_t") int sizeofCameraInfo );
public static native @Cast("VmbError_t") int VmbCamerasList( VmbCameraInfo_t pCameraInfo,
                                               @Cast("VmbUint32_t") int listLength,
                                               @Cast("VmbUint32_t*") IntBuffer pNumFound,
                                               @Cast("VmbUint32_t") int sizeofCameraInfo );
public static native @Cast("VmbError_t") int VmbCamerasList( VmbCameraInfo_t pCameraInfo,
                                               @Cast("VmbUint32_t") int listLength,
                                               @Cast("VmbUint32_t*") int[] pNumFound,
                                               @Cast("VmbUint32_t") int sizeofCameraInfo );

//
// Method:      VmbCameraInfoQuery()
//
// Purpose:     Retrieve information on a camera given by an ID.
//
// Parameters:
//
//  [in ] const char*       idString           ID of the camera
//  [out] VmbCameraInfo_t*  pInfo              Structure where information will be copied. May be NULL.
//  [in ] VmbUint32_t       sizeofCameraInfo   Size of the structure
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorNotFound:      The designated camera cannot be found
//  - VmbErrorStructSize:    The given struct size is not valid for this API version
//  - VmbErrorBadParameter:  If "idString" was NULL
//
// Details:     May be called if a camera has not been opened by the application yet.
//              Examples for "idString": 
//              "DEV_81237473991" for an ID given by a transport layer,
//              "169.254.12.13" for an IP address,
//              "000F314C4BE5" for a MAC address or 
//              "DEV_1234567890" for an ID as reported by Vimba
//
public static native @Cast("VmbError_t") int VmbCameraInfoQuery( @Cast("const char*") BytePointer idString,
                                                   VmbCameraInfo_t pInfo,
                                                   @Cast("VmbUint32_t") int sizeofCameraInfo );
public static native @Cast("VmbError_t") int VmbCameraInfoQuery( String idString,
                                                   VmbCameraInfo_t pInfo,
                                                   @Cast("VmbUint32_t") int sizeofCameraInfo );

//
// Method:      VmbCameraOpen()
//
// Purpose:     Open the specified camera.
//
// Parameters:
//
//  [in ]  const char*      idString        ID of the camera
//  [in ]  VmbAccessMode_t  accessMode      Determines the level of control you have on the camera
//  [out]  VmbHandle_t*     pCameraHandle   A camera handle
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorNotFound:      The designated camera cannot be found
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorInvalidCall:   If called from frame callback
//  - VmbErrorBadParameter:  If "idString" or "pCameraHandle" is NULL
//
// Details:     A camera may be opened in a specific access mode, which determines
//              the level of control you have on a camera.
//              Examples for "idString": 
//              "DEV_81237473991" for an ID given by a transport layer,
//              "169.254.12.13" for an IP address,
//              "000F314C4BE5" for a MAC address or 
//              "DEV_1234567890" for an ID as reported by Vimba
//
public static native @Cast("VmbError_t") int VmbCameraOpen( @Cast("const char*") BytePointer idString,
                                              @Cast("VmbAccessMode_t") int accessMode,
                                              @ByPtrPtr VmbHandle_t pCameraHandle );
public static native @Cast("VmbError_t") int VmbCameraOpen( String idString,
                                              @Cast("VmbAccessMode_t") int accessMode,
                                              @ByPtrPtr VmbHandle_t pCameraHandle );

//
// Method:      VmbCameraClose()
//
// Purpose:     Close the specified camera.
//
// Parameters:
//
//  [in ]  const VmbHandle_t  cameraHandle      A valid camera handle
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorInvalidCall:   If called from frame callback
//
// Details:     Depending on the access mode this camera was opened with, events are killed,
//              callbacks are unregistered, and camera control is released.
//
public static native @Cast("VmbError_t") int VmbCameraClose( VmbHandle_t cameraHandle );


//----- Features ----------------------------------------------------------

//
// Method:      VmbFeaturesList()
//
// Purpose:     List all the features for this entity.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle            Handle for an entity that exposes features
//  [out]  VmbFeatureInfo_t*    pFeatureInfoList  An array of VmbFeatureInfo_t to be filled by the API. May be NULL if pNumFund is used for size query.
//  [in ]  VmbUint32_t          listLength        Number of VmbFeatureInfo_t elements provided
//  [out]  VmbUint32_t*         pNumFound         Number of VmbFeatureInfo_t elements found. May be NULL if pFeatureInfoList is not NULL.
//  [in ]  VmbUint32_t          sizeofFeatureInfo Size of a VmbFeatureInfo_t entry
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorStructSize:    The given struct size of VmbFeatureInfo_t is not valid for this version of the API
//  - VmbErrorMoreData:      The given list length was insufficient to hold all available entries
//
// Details:     This method lists all implemented features, whether they are currently available or not.
//              The list of features does not change as long as the camera/interface is connected.
//              "pNumFound" returns the number of VmbFeatureInfo elements.
//              This function is usually called twice: once with an empty list to query the length
//              of the list, and then again with an list of the correct length.
//              
//
public static native @Cast("VmbError_t") int VmbFeaturesList( VmbHandle_t handle,
                                                VmbFeatureInfo_t pFeatureInfoList,
                                                @Cast("VmbUint32_t") int listLength,
                                                @Cast("VmbUint32_t*") IntPointer pNumFound,
                                                @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("VmbError_t") int VmbFeaturesList( VmbHandle_t handle,
                                                VmbFeatureInfo_t pFeatureInfoList,
                                                @Cast("VmbUint32_t") int listLength,
                                                @Cast("VmbUint32_t*") IntBuffer pNumFound,
                                                @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("VmbError_t") int VmbFeaturesList( VmbHandle_t handle,
                                                VmbFeatureInfo_t pFeatureInfoList,
                                                @Cast("VmbUint32_t") int listLength,
                                                @Cast("VmbUint32_t*") int[] pNumFound,
                                                @Cast("VmbUint32_t") int sizeofFeatureInfo );

//
// Method:      VmbFeatureInfoQuery()
//
// Purpose:     Query information about the constant properties of a feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t        handle             Handle for an entity that exposes features
//  [in ]  const char*              name               Name of the feature
//  [out]  VmbFeatureInfo_t*        pFeatureInfo       The feature info to query
//  [in ]  VmbUint32_t              sizeofFeatureInfo  Size of the structure
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorStructSize:    The given struct size is not valid for this version of the API
//
// Details:     Users provide a pointer to VmbFeatureInfo_t, which is then set to the internal representation.
//
public static native @Cast("VmbError_t") int VmbFeatureInfoQuery( VmbHandle_t handle,
                                                    @Cast("const char*") BytePointer name,
                                                    VmbFeatureInfo_t pFeatureInfo,
                                                    @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("VmbError_t") int VmbFeatureInfoQuery( VmbHandle_t handle,
                                                    String name,
                                                    VmbFeatureInfo_t pFeatureInfo,
                                                    @Cast("VmbUint32_t") int sizeofFeatureInfo );

//
// Method:      VmbFeatureListAffected()
//
// Purpose:     List all the features that might be affected by changes to this feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle              Handle for an entity that exposes features
//  [in ]  const char*          name                Name of the feature
//  [out]  VmbFeatureInfo_t*    pFeatureInfoList    An array of VmbFeatureInfo_t to be filled by the API. May be NULL if pNumFound is used for size query.
//  [in ]  VmbUint32_t          listLength          Number of VmbFeatureInfo_t elements provided
//  [out]  VmbUint32_t*         pNumFound           Number of VmbFeatureInfo_t elements found. May be NULL is pFeatureInfoList is not NULL.
//  [in ]  VmbUint32_t          sizeofFeatureInfo   Size of a VmbFeatureInfo_t entry
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorStructSize:    The given struct size of VmbFeatureInfo_t is not valid for this version of the API
//  - VmbErrorMoreData:      The given list length was insufficient to hold all available entries
//
// Details:     This method lists all affected features, whether they are currently available or not.
//              The value of affected features depends directly or indirectly on this feature
//              (including all selected features).
//              The list of features does not change as long as the camera/interface is connected.
//              This function is usually called twice: once with an empty array to query the length
//              of the list, and then again with an array of the correct length.
//
public static native @Cast("VmbError_t") int VmbFeatureListAffected( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") IntPointer pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("VmbError_t") int VmbFeatureListAffected( VmbHandle_t handle,
                                                       String name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") IntBuffer pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("VmbError_t") int VmbFeatureListAffected( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") int[] pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("VmbError_t") int VmbFeatureListAffected( VmbHandle_t handle,
                                                       String name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") IntPointer pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("VmbError_t") int VmbFeatureListAffected( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") IntBuffer pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("VmbError_t") int VmbFeatureListAffected( VmbHandle_t handle,
                                                       String name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") int[] pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );

//
// Method:      VmbFeatureListSelected()
//
// Purpose:     List all the features selected by a given feature for this module.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle              Handle for an entity that exposes features
//  [in ]  const char*          name                Name of the feature
//  [out]  VmbFeatureInfo_t*    pFeatureInfoList    An array of VmbFeatureInfo_t to be filled by the API. May be NULL if pNumFound is used for size query.
//  [in ]  VmbUint32_t          listLength          Number of VmbFeatureInfo_t elements provided
//  [out]  VmbUint32_t*         pNumFound           Number of VmbFeatureInfo_t elements found. May be NULL if pFeatureInfoList is not NULL.
//  [in ]  VmbUint32_t          sizeofFeatureInfo   Size of a VmbFeatureInfo_t entry
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorStructSize:    The given struct size is not valid for this version of the API
//  - VmbErrorMoreData:      The given list length was insufficient to hold all available entries
//
// Details:     This method lists all selected features, whether they are currently available or not.
//              Features with selected features ("selectors") have no direct impact on the camera,
//              but only influence the register address that selected features point to.
//              The list of features does not change while the camera/interface is connected.
//              This function is usually called twice: once with an empty array to query the length
//              of the list, and then again with an array of the correct length.
//
public static native @Cast("VmbError_t") int VmbFeatureListSelected( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") IntPointer pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("VmbError_t") int VmbFeatureListSelected( VmbHandle_t handle,
                                                       String name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") IntBuffer pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("VmbError_t") int VmbFeatureListSelected( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") int[] pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("VmbError_t") int VmbFeatureListSelected( VmbHandle_t handle,
                                                       String name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") IntPointer pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("VmbError_t") int VmbFeatureListSelected( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") IntBuffer pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );
public static native @Cast("VmbError_t") int VmbFeatureListSelected( VmbHandle_t handle,
                                                       String name,
                                                       VmbFeatureInfo_t pFeatureInfoList,
                                                       @Cast("VmbUint32_t") int listLength,
                                                       @Cast("VmbUint32_t*") int[] pNumFound,
                                                       @Cast("VmbUint32_t") int sizeofFeatureInfo );

//
// Method:      VmbFeatureAccessQuery()
//
// Purpose:     Return the dynamic read and write capabilities of this feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t  handle          Handle for an entity that exposes features.
//  [in ]  const char *       name            Name of the feature.
//  [out]  VmbBool_t *        pIsReadable     Indicates if this feature is readable. May be NULL.
//  [out]  VmbBool_t *        pIsWriteable    Indicates if this feature is writable. May be NULL.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorBadParameter:  If "pIsReadable" and "pIsWriteable" were both NULL
//  - VmbErrorNotFound:      The feature was not found
//
// Details:     The access mode of a feature may change. For example, if "PacketSize"
//              is locked while image data is streamed, it is only readable.
//
public static native @Cast("VmbError_t") int VmbFeatureAccessQuery( VmbHandle_t handle,
                                                      @Cast("const char*") BytePointer name,
                                                      @Cast("VmbBool_t*") BoolPointer pIsReadable,
                                                      @Cast("VmbBool_t*") BoolPointer pIsWriteable );
public static native @Cast("VmbError_t") int VmbFeatureAccessQuery( VmbHandle_t handle,
                                                      String name,
                                                      @Cast("VmbBool_t*") boolean[] pIsReadable,
                                                      @Cast("VmbBool_t*") boolean[] pIsWriteable );


//-----Integer --------

//
// Method:      VmbFeatureIntGet()
//
// Purpose:     Get the value of an integer feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the feature
//  [out]  VmbInt64_t*          pValue      Value to get
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Integer
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "name" or "pValue" is NULL
//
public static native @Cast("VmbError_t") int VmbFeatureIntGet( VmbHandle_t handle,
                                                 @Cast("const char*") BytePointer name,
                                                 @Cast("VmbInt64_t*") LongPointer pValue );
public static native @Cast("VmbError_t") int VmbFeatureIntGet( VmbHandle_t handle,
                                                 String name,
                                                 @Cast("VmbInt64_t*") LongBuffer pValue );
public static native @Cast("VmbError_t") int VmbFeatureIntGet( VmbHandle_t handle,
                                                 @Cast("const char*") BytePointer name,
                                                 @Cast("VmbInt64_t*") long[] pValue );
public static native @Cast("VmbError_t") int VmbFeatureIntGet( VmbHandle_t handle,
                                                 String name,
                                                 @Cast("VmbInt64_t*") LongPointer pValue );
public static native @Cast("VmbError_t") int VmbFeatureIntGet( VmbHandle_t handle,
                                                 @Cast("const char*") BytePointer name,
                                                 @Cast("VmbInt64_t*") LongBuffer pValue );
public static native @Cast("VmbError_t") int VmbFeatureIntGet( VmbHandle_t handle,
                                                 String name,
                                                 @Cast("VmbInt64_t*") long[] pValue );

//
// Method:      VmbFeatureIntSet()
//
// Purpose:     Set the value of an integer feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle    Handle for an entity that exposes features
//  [in ]  const char*          name      Name of the feature
//  [in ]  VmbInt64_t           value     Value to set
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Integer
//  - VmbErrorInvalidValue:  If "value" is either out of bounds or not an increment of the minimum
//  - VmbErrorBadParameter:  If "name" is NULL
//  - VmbErrorNotFound:      If the feature was not found
//  - VmbErrorInvalidCall:   If called from frame callback
//
public static native @Cast("VmbError_t") int VmbFeatureIntSet( VmbHandle_t handle,
                                                 @Cast("const char*") BytePointer name,
                                                 @Cast("VmbInt64_t") long value );
public static native @Cast("VmbError_t") int VmbFeatureIntSet( VmbHandle_t handle,
                                                 String name,
                                                 @Cast("VmbInt64_t") long value );

//
// Method:      VmbFeatureIntRangeQuery()
//
// Purpose:     Query the range of an integer feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the feature
//  [out]  VmbInt64_t*          pMin        Minimum value to be returned. May be NULL.
//  [out]  VmbInt64_t*          pMax        Maximum value to be returned. May be NULL.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorBadParameter:  If "name" is NULL or "pMin" and "pMax" are NULL
//  - VmbErrorWrongType:     The type of feature "name" is not Integer
//  - VmbErrorNotFound:      If the feature was not found
//
public static native @Cast("VmbError_t") int VmbFeatureIntRangeQuery( VmbHandle_t handle,
                                                        @Cast("const char*") BytePointer name,
                                                        @Cast("VmbInt64_t*") LongPointer pMin,
                                                        @Cast("VmbInt64_t*") LongPointer pMax );
public static native @Cast("VmbError_t") int VmbFeatureIntRangeQuery( VmbHandle_t handle,
                                                        String name,
                                                        @Cast("VmbInt64_t*") LongBuffer pMin,
                                                        @Cast("VmbInt64_t*") LongBuffer pMax );
public static native @Cast("VmbError_t") int VmbFeatureIntRangeQuery( VmbHandle_t handle,
                                                        @Cast("const char*") BytePointer name,
                                                        @Cast("VmbInt64_t*") long[] pMin,
                                                        @Cast("VmbInt64_t*") long[] pMax );
public static native @Cast("VmbError_t") int VmbFeatureIntRangeQuery( VmbHandle_t handle,
                                                        String name,
                                                        @Cast("VmbInt64_t*") LongPointer pMin,
                                                        @Cast("VmbInt64_t*") LongPointer pMax );
public static native @Cast("VmbError_t") int VmbFeatureIntRangeQuery( VmbHandle_t handle,
                                                        @Cast("const char*") BytePointer name,
                                                        @Cast("VmbInt64_t*") LongBuffer pMin,
                                                        @Cast("VmbInt64_t*") LongBuffer pMax );
public static native @Cast("VmbError_t") int VmbFeatureIntRangeQuery( VmbHandle_t handle,
                                                        String name,
                                                        @Cast("VmbInt64_t*") long[] pMin,
                                                        @Cast("VmbInt64_t*") long[] pMax );

//
// Method:      VmbFeatureIntIncrementQuery()
//
// Purpose:     Query the increment of an integer feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle         Handle for an entity that exposes features
//  [in ]  const char*          name           Name of the feature
//  [out]  VmbInt64_t*          pValue         Value of the increment to get.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Integer
//  - VmbErrorNotFound:      The feature was not found
//    VmbErrorBadParameter:  If "name" or "pValue" is NULL
//
public static native @Cast("VmbError_t") int VmbFeatureIntIncrementQuery( VmbHandle_t handle,
                                                            @Cast("const char*") BytePointer name,
                                                            @Cast("VmbInt64_t*") LongPointer pValue );
public static native @Cast("VmbError_t") int VmbFeatureIntIncrementQuery( VmbHandle_t handle,
                                                            String name,
                                                            @Cast("VmbInt64_t*") LongBuffer pValue );
public static native @Cast("VmbError_t") int VmbFeatureIntIncrementQuery( VmbHandle_t handle,
                                                            @Cast("const char*") BytePointer name,
                                                            @Cast("VmbInt64_t*") long[] pValue );
public static native @Cast("VmbError_t") int VmbFeatureIntIncrementQuery( VmbHandle_t handle,
                                                            String name,
                                                            @Cast("VmbInt64_t*") LongPointer pValue );
public static native @Cast("VmbError_t") int VmbFeatureIntIncrementQuery( VmbHandle_t handle,
                                                            @Cast("const char*") BytePointer name,
                                                            @Cast("VmbInt64_t*") LongBuffer pValue );
public static native @Cast("VmbError_t") int VmbFeatureIntIncrementQuery( VmbHandle_t handle,
                                                            String name,
                                                            @Cast("VmbInt64_t*") long[] pValue );

//-----Float --------

//
// Method:      VmbFeatureFloatGet()
//
// Purpose:     Get the value of a float feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the feature
//  [out]  double*              pValue      Value to get
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Float
//  - VmbErrorBadParameter:  If "name" or "pValue" is NULL
//  - VmbErrorNotFound:      The feature was not found
//
public static native @Cast("VmbError_t") int VmbFeatureFloatGet( VmbHandle_t handle,
                                                   @Cast("const char*") BytePointer name,
                                                   DoublePointer pValue );
public static native @Cast("VmbError_t") int VmbFeatureFloatGet( VmbHandle_t handle,
                                                   String name,
                                                   DoubleBuffer pValue );
public static native @Cast("VmbError_t") int VmbFeatureFloatGet( VmbHandle_t handle,
                                                   @Cast("const char*") BytePointer name,
                                                   double[] pValue );
public static native @Cast("VmbError_t") int VmbFeatureFloatGet( VmbHandle_t handle,
                                                   String name,
                                                   DoublePointer pValue );
public static native @Cast("VmbError_t") int VmbFeatureFloatGet( VmbHandle_t handle,
                                                   @Cast("const char*") BytePointer name,
                                                   DoubleBuffer pValue );
public static native @Cast("VmbError_t") int VmbFeatureFloatGet( VmbHandle_t handle,
                                                   String name,
                                                   double[] pValue );

//
// Method:      VmbFeatureFloatSet()
//
// Purpose:     Set the value of a float feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the feature
//  [in ]  double               value       Value to set
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Float
//  - VmbErrorInvalidValue:  If "value" is not within valid bounds
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "name" is NULL
//  - VmbErrorInvalidCall:   If called from frame callback
//
public static native @Cast("VmbError_t") int VmbFeatureFloatSet( VmbHandle_t handle,
                                                   @Cast("const char*") BytePointer name,
                                                   double value );
public static native @Cast("VmbError_t") int VmbFeatureFloatSet( VmbHandle_t handle,
                                                   String name,
                                                   double value );

//
// Method:      VmbFeatureFloatRangeQuery()
//
// Purpose:     Query the range of a float feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the feature
//  [out]  double*              pMin        Minimum value to be returned. May be NULL.
//  [out]  double*              pMax        Maximum value to be returned. May be NULL.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Float
//  - VmbErrorNotFound:      The feature was not found
//  - VmbBadParameter:       If "name" is NULL or "pMin" and "pMax" are NULL
//
// Details:     Only one of the values may be queried if the other parameter is set to NULL,
//              but if both parameters are NULL, an error is returned.
//
public static native @Cast("VmbError_t") int VmbFeatureFloatRangeQuery( VmbHandle_t handle,
                                                          @Cast("const char*") BytePointer name,
                                                          DoublePointer pMin,
                                                          DoublePointer pMax );
public static native @Cast("VmbError_t") int VmbFeatureFloatRangeQuery( VmbHandle_t handle,
                                                          String name,
                                                          DoubleBuffer pMin,
                                                          DoubleBuffer pMax );
public static native @Cast("VmbError_t") int VmbFeatureFloatRangeQuery( VmbHandle_t handle,
                                                          @Cast("const char*") BytePointer name,
                                                          double[] pMin,
                                                          double[] pMax );
public static native @Cast("VmbError_t") int VmbFeatureFloatRangeQuery( VmbHandle_t handle,
                                                          String name,
                                                          DoublePointer pMin,
                                                          DoublePointer pMax );
public static native @Cast("VmbError_t") int VmbFeatureFloatRangeQuery( VmbHandle_t handle,
                                                          @Cast("const char*") BytePointer name,
                                                          DoubleBuffer pMin,
                                                          DoubleBuffer pMax );
public static native @Cast("VmbError_t") int VmbFeatureFloatRangeQuery( VmbHandle_t handle,
                                                          String name,
                                                          double[] pMin,
                                                          double[] pMax );

//
// Method:      VmbFeatureFloatIncrementQuery()
//
// Purpose:     Query the increment of an float feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle         Handle for an entity that exposes features
//  [in ]  const char*          name           Name of the feature
//  [out]  double*              pValue         Value of the increment to get.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Integer
//  - VmbErrorNotFound:      The feature was not found
//    VmbErrorBadParameter:  If "name" or "pValue" is NULL
//
public static native @Cast("VmbError_t") int VmbFeatureFloatIncrementQuery( VmbHandle_t handle,
                                                              @Cast("const char*") BytePointer name,
                                                              @Cast("VmbBool_t*") BoolPointer hasIncrement,
                                                              DoublePointer pValue );
public static native @Cast("VmbError_t") int VmbFeatureFloatIncrementQuery( VmbHandle_t handle,
                                                              String name,
                                                              @Cast("VmbBool_t*") boolean[] hasIncrement,
                                                              DoubleBuffer pValue );
public static native @Cast("VmbError_t") int VmbFeatureFloatIncrementQuery( VmbHandle_t handle,
                                                              @Cast("const char*") BytePointer name,
                                                              @Cast("VmbBool_t*") BoolPointer hasIncrement,
                                                              double[] pValue );
public static native @Cast("VmbError_t") int VmbFeatureFloatIncrementQuery( VmbHandle_t handle,
                                                              String name,
                                                              @Cast("VmbBool_t*") boolean[] hasIncrement,
                                                              DoublePointer pValue );
public static native @Cast("VmbError_t") int VmbFeatureFloatIncrementQuery( VmbHandle_t handle,
                                                              @Cast("const char*") BytePointer name,
                                                              @Cast("VmbBool_t*") BoolPointer hasIncrement,
                                                              DoubleBuffer pValue );
public static native @Cast("VmbError_t") int VmbFeatureFloatIncrementQuery( VmbHandle_t handle,
                                                              String name,
                                                              @Cast("VmbBool_t*") boolean[] hasIncrement,
                                                              double[] pValue );
//-----Enum --------

//
// Method:      VmbFeatureEnumGet()
//
// Purpose:     Get the value of an enumeration feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the feature
//  [out]  const char**         pValue      The current enumeration value. The returned value
//                                          is a reference to the API value
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Enumeration
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "name" or "pValue" is NULL
//
public static native @Cast("VmbError_t") int VmbFeatureEnumGet( VmbHandle_t handle,
                                                  @Cast("const char*") BytePointer name,
                                                  @Cast("const char**") PointerPointer pValue );
public static native @Cast("VmbError_t") int VmbFeatureEnumGet( VmbHandle_t handle,
                                                  @Cast("const char*") BytePointer name,
                                                  @Cast("const char**") @ByPtrPtr BytePointer pValue );
public static native @Cast("VmbError_t") int VmbFeatureEnumGet( VmbHandle_t handle,
                                                  String name,
                                                  @Cast("const char**") @ByPtrPtr ByteBuffer pValue );
public static native @Cast("VmbError_t") int VmbFeatureEnumGet( VmbHandle_t handle,
                                                  @Cast("const char*") BytePointer name,
                                                  @Cast("const char**") @ByPtrPtr byte[] pValue );
public static native @Cast("VmbError_t") int VmbFeatureEnumGet( VmbHandle_t handle,
                                                  String name,
                                                  @Cast("const char**") @ByPtrPtr BytePointer pValue );
public static native @Cast("VmbError_t") int VmbFeatureEnumGet( VmbHandle_t handle,
                                                  @Cast("const char*") BytePointer name,
                                                  @Cast("const char**") @ByPtrPtr ByteBuffer pValue );
public static native @Cast("VmbError_t") int VmbFeatureEnumGet( VmbHandle_t handle,
                                                  String name,
                                                  @Cast("const char**") @ByPtrPtr byte[] pValue );

//
// Method:      VmbFeatureEnumSet()
//
// Purpose:     Set the value of an enumeration feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the feature
//  [in ]  const char*          value       Value to set
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Enumeration
//  - VmbErrorInvalidValue:  If "value" is not within valid bounds
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "name" ore "value" is NULL
//  - VmbErrorInvalidCall:   If called from frame callback
//
public static native @Cast("VmbError_t") int VmbFeatureEnumSet( VmbHandle_t handle,
                                                  @Cast("const char*") BytePointer name,
                                                  @Cast("const char*") BytePointer value );
public static native @Cast("VmbError_t") int VmbFeatureEnumSet( VmbHandle_t handle,
                                                  String name,
                                                  String value );

//
// Method:      VmbFeatureEnumRangeQuery()
//
// Purpose:     Query the value range of an enumeration feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle          Handle for an entity that exposes features
//  [in ]  const char*          name            Name of the feature
//  [out]  const char**         pNameArray      An array of enumeration value names; may be NULL if pNumFilled is used for size query
//  [in ]  VmbUint32_t          arrayLength     Number of elements in the array
//  [out]  VmbUint32_t *        pNumFilled      Number of filled elements; may be NULL if pNameArray is not NULL
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorMoreData:      The given array length was insufficient to hold all available entries
//  - VmbErrorWrongType:     The type of feature "name" is not Enumeration
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "name" is NULL or "pNameArray" and "pNumFilled" are NULL
//
public static native @Cast("VmbError_t") int VmbFeatureEnumRangeQuery( VmbHandle_t handle,
                                                         @Cast("const char*") BytePointer name,
                                                         @Cast("const char**") PointerPointer pNameArray,
                                                         @Cast("VmbUint32_t") int arrayLength,
                                                         @Cast("VmbUint32_t*") IntPointer pNumFilled );
public static native @Cast("VmbError_t") int VmbFeatureEnumRangeQuery( VmbHandle_t handle,
                                                         @Cast("const char*") BytePointer name,
                                                         @Cast("const char**") @ByPtrPtr BytePointer pNameArray,
                                                         @Cast("VmbUint32_t") int arrayLength,
                                                         @Cast("VmbUint32_t*") IntPointer pNumFilled );
public static native @Cast("VmbError_t") int VmbFeatureEnumRangeQuery( VmbHandle_t handle,
                                                         String name,
                                                         @Cast("const char**") @ByPtrPtr ByteBuffer pNameArray,
                                                         @Cast("VmbUint32_t") int arrayLength,
                                                         @Cast("VmbUint32_t*") IntBuffer pNumFilled );
public static native @Cast("VmbError_t") int VmbFeatureEnumRangeQuery( VmbHandle_t handle,
                                                         @Cast("const char*") BytePointer name,
                                                         @Cast("const char**") @ByPtrPtr byte[] pNameArray,
                                                         @Cast("VmbUint32_t") int arrayLength,
                                                         @Cast("VmbUint32_t*") int[] pNumFilled );
public static native @Cast("VmbError_t") int VmbFeatureEnumRangeQuery( VmbHandle_t handle,
                                                         String name,
                                                         @Cast("const char**") @ByPtrPtr BytePointer pNameArray,
                                                         @Cast("VmbUint32_t") int arrayLength,
                                                         @Cast("VmbUint32_t*") IntPointer pNumFilled );
public static native @Cast("VmbError_t") int VmbFeatureEnumRangeQuery( VmbHandle_t handle,
                                                         @Cast("const char*") BytePointer name,
                                                         @Cast("const char**") @ByPtrPtr ByteBuffer pNameArray,
                                                         @Cast("VmbUint32_t") int arrayLength,
                                                         @Cast("VmbUint32_t*") IntBuffer pNumFilled );
public static native @Cast("VmbError_t") int VmbFeatureEnumRangeQuery( VmbHandle_t handle,
                                                         String name,
                                                         @Cast("const char**") @ByPtrPtr byte[] pNameArray,
                                                         @Cast("VmbUint32_t") int arrayLength,
                                                         @Cast("VmbUint32_t*") int[] pNumFilled );

//
// Method:      VmbFeatureEnumIsAvailable()
//
// Purpose:     Check if a certain value of an enumeration is available.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle          Handle for an entity that exposes features
//  [in ]  const char*          name            Name of the feature
//  [in ]  const char*          value           Value to check
//  [out]  VmbBool_t *          pIsAvailable    Indicates if the given enumeration value is available
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Enumeration
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "name" or "value" or "pIsAvailable" is NULL
//
public static native @Cast("VmbError_t") int VmbFeatureEnumIsAvailable( VmbHandle_t handle,
                                                          @Cast("const char*") BytePointer name,
                                                          @Cast("const char*") BytePointer value,
                                                          @Cast("VmbBool_t*") BoolPointer pIsAvailable );
public static native @Cast("VmbError_t") int VmbFeatureEnumIsAvailable( VmbHandle_t handle,
                                                          String name,
                                                          String value,
                                                          @Cast("VmbBool_t*") boolean[] pIsAvailable );

//
// Method:      VmbFeatureEnumAsInt()
//
// Purpose:     Get the integer value for a given enumeration string value.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle     Handle for an entity that exposes features
//  [in ]  const char*          name       Name of the feature
//  [in ]  const char*          value      The enumeration value to get the integer value for
//  [out]  VmbInt64_t*          pIntVal    The integer value for this enumeration entry
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Enumeration
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "name" or "value" or "pIntVal" is NULL
//
// Details:     Converts a name of an enum member into an int value ("Mono12Packed" to 0x10C0006)
//
public static native @Cast("VmbError_t") int VmbFeatureEnumAsInt( VmbHandle_t handle,
                                                    @Cast("const char*") BytePointer name,
                                                    @Cast("const char*") BytePointer value,
                                                    @Cast("VmbInt64_t*") LongPointer pIntVal );
public static native @Cast("VmbError_t") int VmbFeatureEnumAsInt( VmbHandle_t handle,
                                                    String name,
                                                    String value,
                                                    @Cast("VmbInt64_t*") LongBuffer pIntVal );
public static native @Cast("VmbError_t") int VmbFeatureEnumAsInt( VmbHandle_t handle,
                                                    @Cast("const char*") BytePointer name,
                                                    @Cast("const char*") BytePointer value,
                                                    @Cast("VmbInt64_t*") long[] pIntVal );
public static native @Cast("VmbError_t") int VmbFeatureEnumAsInt( VmbHandle_t handle,
                                                    String name,
                                                    String value,
                                                    @Cast("VmbInt64_t*") LongPointer pIntVal );
public static native @Cast("VmbError_t") int VmbFeatureEnumAsInt( VmbHandle_t handle,
                                                    @Cast("const char*") BytePointer name,
                                                    @Cast("const char*") BytePointer value,
                                                    @Cast("VmbInt64_t*") LongBuffer pIntVal );
public static native @Cast("VmbError_t") int VmbFeatureEnumAsInt( VmbHandle_t handle,
                                                    String name,
                                                    String value,
                                                    @Cast("VmbInt64_t*") long[] pIntVal );

//
// Method:      VmbFeatureEnumAsString()
//
// Purpose:     Get the enumeration string value for a given integer value.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle          Handle for an entity that exposes features
//  [in ]  const char*          name            Name of the feature
//  [in ]  VmbInt64_t           intValue        The numeric value
//  [out]  const char**         pStringValue    The string value for the numeric value
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Enumeration
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "name" or "pStringValue" is NULL
//
// Details:     Converts an int value to a name of an enum member (e.g. 0x10C0006 to "Mono12Packed")
//
public static native @Cast("VmbError_t") int VmbFeatureEnumAsString( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       @Cast("VmbInt64_t") long intValue,
                                                       @Cast("const char**") PointerPointer pStringValue );
public static native @Cast("VmbError_t") int VmbFeatureEnumAsString( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       @Cast("VmbInt64_t") long intValue,
                                                       @Cast("const char**") @ByPtrPtr BytePointer pStringValue );
public static native @Cast("VmbError_t") int VmbFeatureEnumAsString( VmbHandle_t handle,
                                                       String name,
                                                       @Cast("VmbInt64_t") long intValue,
                                                       @Cast("const char**") @ByPtrPtr ByteBuffer pStringValue );
public static native @Cast("VmbError_t") int VmbFeatureEnumAsString( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       @Cast("VmbInt64_t") long intValue,
                                                       @Cast("const char**") @ByPtrPtr byte[] pStringValue );
public static native @Cast("VmbError_t") int VmbFeatureEnumAsString( VmbHandle_t handle,
                                                       String name,
                                                       @Cast("VmbInt64_t") long intValue,
                                                       @Cast("const char**") @ByPtrPtr BytePointer pStringValue );
public static native @Cast("VmbError_t") int VmbFeatureEnumAsString( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer name,
                                                       @Cast("VmbInt64_t") long intValue,
                                                       @Cast("const char**") @ByPtrPtr ByteBuffer pStringValue );
public static native @Cast("VmbError_t") int VmbFeatureEnumAsString( VmbHandle_t handle,
                                                       String name,
                                                       @Cast("VmbInt64_t") long intValue,
                                                       @Cast("const char**") @ByPtrPtr byte[] pStringValue );

//
// Method:      VmbFeatureEnumEntryGet()
//
// Purpose:     Get infos about an entry of an enumeration feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t        handle                  Handle for an entity that exposes features
//  [in ]  const char*              featureName             Name of the feature
//  [in ]  const char*              entryName               Name of the enum entry of that feature
//  [out]  VmbFeatureEnumEntry_t*   pFeatureEnumEntry       Infos about that entry returned by the API
//  [in]   VmbUint32_t              sizeofFeatureEnumEntry  Size of the structure
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorStructSize     Size of VmbFeatureEnumEntry_t is not compatible with the API version
//  - VmbErrorWrongType:     The type of feature "name" is not Enumeration
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorBadParameter:  If "featureName" or "entryName" or "pFeatureEnumEntry" is NULL
//
public static native @Cast("VmbError_t") int VmbFeatureEnumEntryGet( VmbHandle_t handle,
                                                       @Cast("const char*") BytePointer featureName,
                                                       @Cast("const char*") BytePointer entryName,
                                                       VmbFeatureEnumEntry_t pFeatureEnumEntry,
                                                       @Cast("VmbUint32_t") int sizeofFeatureEnumEntry );
public static native @Cast("VmbError_t") int VmbFeatureEnumEntryGet( VmbHandle_t handle,
                                                       String featureName,
                                                       String entryName,
                                                       VmbFeatureEnumEntry_t pFeatureEnumEntry,
                                                       @Cast("VmbUint32_t") int sizeofFeatureEnumEntry );

//-----String --------

//
// Method:      VmbFeatureStringGet()
//
// Purpose:     Get the value of a string feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle          Handle for an entity that exposes features
//  [in ]  const char*          name            Name of the string feature
//  [out]  char*                buffer          String buffer to fill. May be NULL if pSizeFilled is used for size query.
//  [in ]  VmbUint32_t          bufferSize      Size of the input buffer
//  [out]  VmbUint32_t*         pSizeFilled     Size actually filled. May be NULL if buffer is not NULL.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorMoreData:      The given buffer size was too small
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorWrongType:     The type of feature "name" is not String
//
// Details:     This function is usually called twice: once with an empty buffer to query the length
//              of the string, and then again with a buffer of the correct length.

public static native @Cast("VmbError_t") int VmbFeatureStringGet( VmbHandle_t handle,
                                                    @Cast("const char*") BytePointer name,
                                                    @Cast("char*") BytePointer buffer,
                                                    @Cast("VmbUint32_t") int bufferSize,
                                                    @Cast("VmbUint32_t*") IntPointer pSizeFilled );
public static native @Cast("VmbError_t") int VmbFeatureStringGet( VmbHandle_t handle,
                                                    String name,
                                                    @Cast("char*") ByteBuffer buffer,
                                                    @Cast("VmbUint32_t") int bufferSize,
                                                    @Cast("VmbUint32_t*") IntBuffer pSizeFilled );
public static native @Cast("VmbError_t") int VmbFeatureStringGet( VmbHandle_t handle,
                                                    @Cast("const char*") BytePointer name,
                                                    @Cast("char*") byte[] buffer,
                                                    @Cast("VmbUint32_t") int bufferSize,
                                                    @Cast("VmbUint32_t*") int[] pSizeFilled );
public static native @Cast("VmbError_t") int VmbFeatureStringGet( VmbHandle_t handle,
                                                    String name,
                                                    @Cast("char*") BytePointer buffer,
                                                    @Cast("VmbUint32_t") int bufferSize,
                                                    @Cast("VmbUint32_t*") IntPointer pSizeFilled );
public static native @Cast("VmbError_t") int VmbFeatureStringGet( VmbHandle_t handle,
                                                    @Cast("const char*") BytePointer name,
                                                    @Cast("char*") ByteBuffer buffer,
                                                    @Cast("VmbUint32_t") int bufferSize,
                                                    @Cast("VmbUint32_t*") IntBuffer pSizeFilled );
public static native @Cast("VmbError_t") int VmbFeatureStringGet( VmbHandle_t handle,
                                                    String name,
                                                    @Cast("char*") byte[] buffer,
                                                    @Cast("VmbUint32_t") int bufferSize,
                                                    @Cast("VmbUint32_t*") int[] pSizeFilled );

//
// Method:    VmbFeatureStringSet()
//
// Purpose:   Set the value of a string feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the string feature
//  [in ]  const char*          value       Value to set
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorNotFound:      The feature was not found
//  - VmbErrorWrongType:     The type of feature "name" is not String
//  - VmbErrorInvalidValue:  If length of "value" exceeded the maximum length
//  - VmbErrorBadParameter:  If "name" or "value" is NULL
//  - VmbErrorInvalidCall:   If called from frame callback
//
public static native @Cast("VmbError_t") int VmbFeatureStringSet( VmbHandle_t handle,
                                                    @Cast("const char*") BytePointer name,
                                                    @Cast("const char*") BytePointer value );
public static native @Cast("VmbError_t") int VmbFeatureStringSet( VmbHandle_t handle,
                                                    String name,
                                                    String value );

//
// Method:      VmbFeatureStringMaxlengthQuery()
//
// Purpose:     Get the maximum length of a string feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle        Handle for an entity that exposes features
//  [in ]  const char*          name          Name of the string feature
//  [out]  VmbUint32_t*         pMaxLength    Maximum length of this string feature
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not String
//  - VmbErrorBadParameter:  If "name" or "pMaxLength" is NULL
//
public static native @Cast("VmbError_t") int VmbFeatureStringMaxlengthQuery( VmbHandle_t handle,
                                                               @Cast("const char*") BytePointer name,
                                                               @Cast("VmbUint32_t*") IntPointer pMaxLength );
public static native @Cast("VmbError_t") int VmbFeatureStringMaxlengthQuery( VmbHandle_t handle,
                                                               String name,
                                                               @Cast("VmbUint32_t*") IntBuffer pMaxLength );
public static native @Cast("VmbError_t") int VmbFeatureStringMaxlengthQuery( VmbHandle_t handle,
                                                               @Cast("const char*") BytePointer name,
                                                               @Cast("VmbUint32_t*") int[] pMaxLength );
public static native @Cast("VmbError_t") int VmbFeatureStringMaxlengthQuery( VmbHandle_t handle,
                                                               String name,
                                                               @Cast("VmbUint32_t*") IntPointer pMaxLength );
public static native @Cast("VmbError_t") int VmbFeatureStringMaxlengthQuery( VmbHandle_t handle,
                                                               @Cast("const char*") BytePointer name,
                                                               @Cast("VmbUint32_t*") IntBuffer pMaxLength );
public static native @Cast("VmbError_t") int VmbFeatureStringMaxlengthQuery( VmbHandle_t handle,
                                                               String name,
                                                               @Cast("VmbUint32_t*") int[] pMaxLength );

//-----Boolean --------

//
// Method:      VmbFeatureBoolGet()
//
// Purpose:     Get the value of a boolean feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle    Handle for an entity that exposes features
//  [in ]  const char*          name      Name of the boolean feature
//  [out]  VmbBool_t *          pValue    Value to be read
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Boolean
//  - VmbErrorNotFound:      If feature is not found
//  - VmbErrorBadParameter:  If "name" or "pValue" is NULL
//
public static native @Cast("VmbError_t") int VmbFeatureBoolGet( VmbHandle_t handle,
                                                  @Cast("const char*") BytePointer name,
                                                  @Cast("VmbBool_t*") BoolPointer pValue );
public static native @Cast("VmbError_t") int VmbFeatureBoolGet( VmbHandle_t handle,
                                                  String name,
                                                  @Cast("VmbBool_t*") boolean[] pValue );

//
// Method:      VmbFeatureBoolSet()
//
// Purpose:     Set the value of a boolean feature.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the boolean feature
//  [in ]  VmbBool_t            value       Value to write
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Boolean
//  - VmbErrorInvalidValue:  If "value" is not within valid bounds
//  - VmbErrorNotFound:      If the feature is not found
//  - VmbErrorBadParameter:  If "name" is NULL
//  - VmbErrorInvalidCall:   If called from frame callback
//
public static native @Cast("VmbError_t") int VmbFeatureBoolSet( VmbHandle_t handle,
                                                  @Cast("const char*") BytePointer name,
                                                  @Cast("VmbBool_t") boolean value );
public static native @Cast("VmbError_t") int VmbFeatureBoolSet( VmbHandle_t handle,
                                                  String name,
                                                  @Cast("VmbBool_t") boolean value );

//-----Command ------

//
// Method:    VmbFeatureCommandRun()
//
// Purpose:   Run a feature command.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the command feature
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Command
//  - VmbErrorNotFound:      Feature was not found
//  - VmbErrorBadParameter:  If "name" is NULL
//
public static native @Cast("VmbError_t") int VmbFeatureCommandRun( VmbHandle_t handle,
                                                     @Cast("const char*") BytePointer name );
public static native @Cast("VmbError_t") int VmbFeatureCommandRun( VmbHandle_t handle,
                                                     String name );

//
// Method:      VmbFeatureCommandIsDone()
//
// Purpose:     Check if a feature command is done.
//
// Parameters:
//
//  [in ]     const VmbHandle_t handle     Handle for an entity that exposes features
//  [in ]     const char*       name       Name of the command feature
//  [out]     VmbBool_t *       pIsDone    State of the command.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Command
//  - VmbErrorNotFound:      Feature was not found
//  - VmbErrorBadParameter:  If "name" or "pIsDone" is NULL
//
public static native @Cast("VmbError_t") int VmbFeatureCommandIsDone( VmbHandle_t handle,
                                                        @Cast("const char*") BytePointer name,
                                                        @Cast("VmbBool_t*") BoolPointer pIsDone );
public static native @Cast("VmbError_t") int VmbFeatureCommandIsDone( VmbHandle_t handle,
                                                        String name,
                                                        @Cast("VmbBool_t*") boolean[] pIsDone );

//-----Raw --------

//
// Method:      VmbFeatureRawGet()
//
// Purpose:     Read the memory contents of an area given by a feature name.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle         Handle for an entity that exposes features
//  [in ]  const char*          name           Name of the raw feature
//  [out]  char*                pBuffer        Buffer to fill
//  [in ]  VmbUint32_t          bufferSize     Size of the buffer to be filled
//  [out]  VmbUint32_t*         pSizeFilled    Number of bytes actually filled
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Register
//  - VmbErrorNotFound:      Feature was not found
//  - VmbErrorBadParameter:  If "name" or "pBuffer" or "pSizeFilled" is NULL
//
// Details:     This feature type corresponds to a top-level "Register" feature in GenICam.
//              Data transfer is split up by the transport layer if the feature length is too large.
//              You can get the size of the memory area addressed by the feature "name" by VmbFeatureRawLengthQuery().
//
public static native @Cast("VmbError_t") int VmbFeatureRawGet( VmbHandle_t handle,
                                                 @Cast("const char*") BytePointer name,
                                                 @Cast("char*") BytePointer pBuffer,
                                                 @Cast("VmbUint32_t") int bufferSize,
                                                 @Cast("VmbUint32_t*") IntPointer pSizeFilled );
public static native @Cast("VmbError_t") int VmbFeatureRawGet( VmbHandle_t handle,
                                                 String name,
                                                 @Cast("char*") ByteBuffer pBuffer,
                                                 @Cast("VmbUint32_t") int bufferSize,
                                                 @Cast("VmbUint32_t*") IntBuffer pSizeFilled );
public static native @Cast("VmbError_t") int VmbFeatureRawGet( VmbHandle_t handle,
                                                 @Cast("const char*") BytePointer name,
                                                 @Cast("char*") byte[] pBuffer,
                                                 @Cast("VmbUint32_t") int bufferSize,
                                                 @Cast("VmbUint32_t*") int[] pSizeFilled );
public static native @Cast("VmbError_t") int VmbFeatureRawGet( VmbHandle_t handle,
                                                 String name,
                                                 @Cast("char*") BytePointer pBuffer,
                                                 @Cast("VmbUint32_t") int bufferSize,
                                                 @Cast("VmbUint32_t*") IntPointer pSizeFilled );
public static native @Cast("VmbError_t") int VmbFeatureRawGet( VmbHandle_t handle,
                                                 @Cast("const char*") BytePointer name,
                                                 @Cast("char*") ByteBuffer pBuffer,
                                                 @Cast("VmbUint32_t") int bufferSize,
                                                 @Cast("VmbUint32_t*") IntBuffer pSizeFilled );
public static native @Cast("VmbError_t") int VmbFeatureRawGet( VmbHandle_t handle,
                                                 String name,
                                                 @Cast("char*") byte[] pBuffer,
                                                 @Cast("VmbUint32_t") int bufferSize,
                                                 @Cast("VmbUint32_t*") int[] pSizeFilled );

//
// Method:      VmbFeatureRawSet()
//
// Purpose:     Write to a memory area given by a feature name.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the raw feature
//  [in ]  const char*          pBuffer     Data buffer to use
//  [in ]  VmbUint32_t          bufferSize  Size of the buffer
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Register
//  - VmbErrorNotFound:      Feature was not found
//  - VmbErrorBadParameter:  If "name" or "pBuffer" is NULL
//  - VmbErrorInvalidCall:   If called from frame callback
//
// Details:     This feature type corresponds to a first-level "Register" node in the XML file.
//              Data transfer is split up by the transport layer if the feature length is too large.
//              You can get the size of the memory area addressed by the feature "name" by VmbFeatureRawLengthQuery().
//
public static native @Cast("VmbError_t") int VmbFeatureRawSet( VmbHandle_t handle,
                                                 @Cast("const char*") BytePointer name,
                                                 @Cast("const char*") BytePointer pBuffer,
                                                 @Cast("VmbUint32_t") int bufferSize );
public static native @Cast("VmbError_t") int VmbFeatureRawSet( VmbHandle_t handle,
                                                 String name,
                                                 String pBuffer,
                                                 @Cast("VmbUint32_t") int bufferSize );

//
// Method:      VmbFeatureRawLengthQuery()
//
// Purpose:     Get the length of a raw feature for memory transfers.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle      Handle for an entity that exposes features
//  [in ]  const char*          name        Name of the raw feature
//  [out]  VmbUint32_t*         pLength     Length of the raw feature area (in bytes)
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorWrongType:     The type of feature "name" is not Register
//  - VmbErrorNotFound:      Feature not found
//  - VmbErrorBadParameter:  If "name" or "pLength" is NULL
//
// Details:     This feature type corresponds to a first-level "Register" node in the XML file.
//
public static native @Cast("VmbError_t") int VmbFeatureRawLengthQuery( VmbHandle_t handle,
                                                         @Cast("const char*") BytePointer name,
                                                         @Cast("VmbUint32_t*") IntPointer pLength );
public static native @Cast("VmbError_t") int VmbFeatureRawLengthQuery( VmbHandle_t handle,
                                                         String name,
                                                         @Cast("VmbUint32_t*") IntBuffer pLength );
public static native @Cast("VmbError_t") int VmbFeatureRawLengthQuery( VmbHandle_t handle,
                                                         @Cast("const char*") BytePointer name,
                                                         @Cast("VmbUint32_t*") int[] pLength );
public static native @Cast("VmbError_t") int VmbFeatureRawLengthQuery( VmbHandle_t handle,
                                                         String name,
                                                         @Cast("VmbUint32_t*") IntPointer pLength );
public static native @Cast("VmbError_t") int VmbFeatureRawLengthQuery( VmbHandle_t handle,
                                                         @Cast("const char*") BytePointer name,
                                                         @Cast("VmbUint32_t*") IntBuffer pLength );
public static native @Cast("VmbError_t") int VmbFeatureRawLengthQuery( VmbHandle_t handle,
                                                         String name,
                                                         @Cast("VmbUint32_t*") int[] pLength );

//----- Feature invalidation --------------------------------------------------------

//
// Method:      VmbFeatureInvalidationRegister()
//
// Purpose:     Register a VmbInvalidationCallback callback for feature invalidation signaling.
//
// Parameters:
//
//  [in ]  const VmbHandle_t        handle          Handle for an entity that emits events
//  [in ]  const char*              name            Name of the event
//  [in ]  VmbInvalidationCallback  callback        Callback to be run, when invalidation occurs
//  [in ]  void*                    pUserContext    User context passed to function
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//
// Details:     Any feature change, either of its value or of its access state, may be tracked
//              by registering an invalidation callback.
//              Registering multiple callbacks for one feature invalidation event is possible because
//              only the combination of handle, name, and callback is used as key. If the same
//              combination of handle, name, and callback is registered a second time, it overwrites
//              the previous one.
//
public static native @Cast("VmbError_t") int VmbFeatureInvalidationRegister( VmbHandle_t handle,
                                                               @Cast("const char*") BytePointer name,
                                                               VmbInvalidationCallback callback,
                                                               Pointer pUserContext );
public static native @Cast("VmbError_t") int VmbFeatureInvalidationRegister( VmbHandle_t handle,
                                                               String name,
                                                               VmbInvalidationCallback callback,
                                                               Pointer pUserContext );

//
// Method:      VmbFeatureInvalidationUnregister()
//
// Purpose:     Unregister a previously registered feature invalidation callback.
//
// Parameters:
//
//  [in ]  const VmbHandle_t        handle          Handle for an entity that emits events
//  [in ]  const char*              name            Name of the event
//  [in ]  VmbInvalidationCallback  callback        Callback to be removed
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//
// Details:     Since multiple callbacks may be registered for a feature invalidation event,
//              a combination of handle, name, and callback is needed for unregistering, too.
//
public static native @Cast("VmbError_t") int VmbFeatureInvalidationUnregister( VmbHandle_t handle,
                                                                 @Cast("const char*") BytePointer name,
                                                                 VmbInvalidationCallback callback );
public static native @Cast("VmbError_t") int VmbFeatureInvalidationUnregister( VmbHandle_t handle,
                                                                 String name,
                                                                 VmbInvalidationCallback callback );


//-----  Image preparation and acquisition ---------------------------------------------------

//
// Method:      VmbFrameAnnounce()
//
// Purpose:     Announce frames to the API that may be queued for frame capturing later.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    cameraHandle    Handle for a camera
//  [in ]  const VmbFrame_t*    pFrame          Frame buffer to announce
//  [in ]  VmbUint32_t          sizeofFrame     Size of the frame structure
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given camera handle is not valid
//  - VmbErrorBadParameter:  The given frame pointer is not valid or "sizeofFrame" is 0
//  - VmbErrorStructSize:    The given struct size is not valid for this version of the API
//
// Details:     Allows some preparation for frames like DMA preparation depending on the transport layer.
//              The order in which the frames are announced is not taken into consideration by the API.
//
public static native @Cast("VmbError_t") int VmbFrameAnnounce( VmbHandle_t cameraHandle,
                                                 @Const VmbFrame_t pFrame,
                                                 @Cast("VmbUint32_t") int sizeofFrame );


//
// Method:      VmbFrameRevoke()
//
// Purpose:     Revoke a frame from the API.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    cameraHandle    Handle for a camera
//  [in ]  const VmbFrame_t*    pFrame          Frame buffer to be removed from the list of announced frames
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given camera handle is not valid
//  - VmbErrorBadParameter:  The given frame pointer is not valid
//  - VmbErrorStructSize:    The given struct size is not valid for this version of the API
//
// Details:    The referenced frame is removed from the pool of frames for capturing images.
//
public static native @Cast("VmbError_t") int VmbFrameRevoke( VmbHandle_t cameraHandle,
                                               @Const VmbFrame_t pFrame );


//
// Method:      VmbFrameRevokeAll()
//
// Purpose:     Revoke all frames assigned to a certain camera.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    cameraHandle    Handle for a camera
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given camera handle is not valid
//
public static native @Cast("VmbError_t") int VmbFrameRevokeAll( VmbHandle_t cameraHandle );


//
// Method:      VmbCaptureStart()
//
// Purpose:     Prepare the API for incoming frames.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    cameraHandle    Handle for a camera
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorDeviceNotOpen: Camera was not opened for usage
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//
public static native @Cast("VmbError_t") int VmbCaptureStart( VmbHandle_t cameraHandle );


//
// Method:      VmbCaptureEnd()
//
// Purpose:     Stop the API from being able to receive frames.
//
// Parameters:
//
//  [in ]  const VmbHandle_t  cameraHandle    Handle for a camera
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//
// Details:     Consequences of VmbCaptureEnd():
//                  - The frame callback will not be called anymore
//
public static native @Cast("VmbError_t") int VmbCaptureEnd( VmbHandle_t cameraHandle );


//
// Method:      VmbCaptureFrameQueue()
//
// Purpose:     Queue frames that may be filled during frame capturing.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    cameraHandle    Handle of the camera
//  [in ]  const VmbFrame_t*    pFrame          Pointer to an already announced frame
//  [in ]  VmbFrameCallback     callback        Callback to be run when the frame is complete.  NULL is Ok.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given frame is not valid
//  - VmbErrorStructSize:    The given struct size is not valid for this version of the API
//
// Details:     The given frame is put into a queue that will be filled sequentially.
//              The order in which the frames are filled is determined by the order in which they are queued.
//              If the frame was announced with VmbFrameAnnounce() before, the application
//              has to ensure that the frame is also revoked by calling VmbFrameRevoke() or
//              VmbFrameRevokeAll() when cleaning up.
//
public static native @Cast("VmbError_t") int VmbCaptureFrameQueue( VmbHandle_t cameraHandle,
                                                     @Const VmbFrame_t pFrame,
                                                     VmbFrameCallback callback );


//
// Method:      VmbCaptureFrameWait()
//
// Purpose:     Wait for a queued frame to be filled (or dequeued).
//
// Parameters:
//
//  [in ]  const VmbHandle_t    cameraHandle    Handle of the camera
//  [in ]  const VmbFrame_t*    pFrame          Pointer to an already announced & queued frame
//  [in ]  VmbUint32_t          timeout         Timeout (in milliseconds)
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorTimeout:       Call timed out
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//
public static native @Cast("VmbError_t") int VmbCaptureFrameWait( VmbHandle_t cameraHandle,
                                                    @Const VmbFrame_t pFrame,
                                                    @Cast("VmbUint32_t") int timeout);


//
// Method:      VmbCaptureQueueFlush()
//
// Purpose:     Flush the capture queue.
//
// Parameters:
//
//  [in ]  const VmbHandle_t cameraHandle   Handle of the camera to flush
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//
// Details:     Control of all the currently queued frames will be returned to the user,
//              leaving no frames in the capture queue.
//              After this call, no frame notification will occur until frames are queued again.
//
public static native @Cast("VmbError_t") int VmbCaptureQueueFlush( VmbHandle_t cameraHandle );


//----- Interface Enumeration & Information --------------------------------------

//
// Method:      VmbInterfacesList()
//
// Purpose:     List all the interfaces currently visible to VimbaC.
//
// Parameters:
//
//  [out]  VmbInterfaceInfo_t*  pInterfaceInfo          Array of VmbInterfaceInfo_t, allocated by the caller.
//                                                      The interface list is copied here. May be NULL.
//  [in ]  VmbUint32_t          listLength              Number of entries in the caller's pList array
//  [out]  VmbUint32_t*         pNumFound               Number of interfaces found (may be more than
//                                                      listLength!) returned here.
//  [in ]  VmbUint32_t          sizeofInterfaceInfo     Size of one VmbInterfaceInfo_t entry
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorStructSize:    The given struct size is not valid for this API version
//  - VmbErrorMoreData:      The given list length was insufficient to hold all available entries
//  - VmbErrorBadParameter:  If "pNumFound" was NULL
//
// Details:     All the interfaces known via GenICam TransportLayers are listed by this 
//              command and filled into the provided array. Interfaces may correspond to 
//              adapter cards or frame grabber cards or, in the case of FireWire to the 
//              whole 1394 infrastructure, for instance.
//              This function is usually called twice: once with an empty array to query the length
//              of the list, and then again with an array of the correct length.
//
public static native @Cast("VmbError_t") int VmbInterfacesList( VmbInterfaceInfo_t pInterfaceInfo,
                                                  @Cast("VmbUint32_t") int listLength,
                                                  @Cast("VmbUint32_t*") IntPointer pNumFound,
                                                  @Cast("VmbUint32_t") int sizeofInterfaceInfo );
public static native @Cast("VmbError_t") int VmbInterfacesList( VmbInterfaceInfo_t pInterfaceInfo,
                                                  @Cast("VmbUint32_t") int listLength,
                                                  @Cast("VmbUint32_t*") IntBuffer pNumFound,
                                                  @Cast("VmbUint32_t") int sizeofInterfaceInfo );
public static native @Cast("VmbError_t") int VmbInterfacesList( VmbInterfaceInfo_t pInterfaceInfo,
                                                  @Cast("VmbUint32_t") int listLength,
                                                  @Cast("VmbUint32_t*") int[] pNumFound,
                                                  @Cast("VmbUint32_t") int sizeofInterfaceInfo );

//
// Method:      VmbInterfaceOpen()
//
// Purpose:     Open an interface handle for feature access.
//
// Parameters:
//
//  [in ]  const char*      idString           The ID of the interface to get the handle for
//                                             (returned by VmbInterfacesList())
//  [out]  VmbHandle_t*     pInterfaceHandle   The handle for this interface.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorNotFound:      The designated interface cannot be found
//  - VmbErrorBadParameter:  If "pInterfaceHandle" was NULL
//
// Details:     An interface can be opened if interface-specific control or information
//              is required, e.g. the number of devices attached to a specific interface.
//              Access is then possible via feature access methods.
//
public static native @Cast("VmbError_t") int VmbInterfaceOpen( @Cast("const char*") BytePointer idString,
                                                 @ByPtrPtr VmbHandle_t pInterfaceHandle );
public static native @Cast("VmbError_t") int VmbInterfaceOpen( String idString,
                                                 @ByPtrPtr VmbHandle_t pInterfaceHandle );

//
// Method:      VmbInterfaceClose()
//
// Purpose:     Close an interface.
//
// Parameters:
//
//  [in ]  const VmbHandle_t   interfaceHandle    The handle of the interface to close.
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//
// Details:     After configuration of the interface, close it by calling this function.
//
public static native @Cast("VmbError_t") int VmbInterfaceClose( VmbHandle_t interfaceHandle );


//----- Ancillary data --------------------------------------------------------

//
// Method:      VmbAncillaryDataOpen()
//
// Purpose:     Get a working handle to allow access to the elements of the ancillary data via feature access.
//
// Parameters:
//
//  [in ]  VmbFrame_t*   pFrame                 Pointer to a filled frame
//  [out]  VmbHandle_t*  pAncillaryDataHandle   Handle to the ancillary data inside the frame
//
// Returns:
//
//  - VmbErrorSuccess:			No error
//  - VmbErrorBadHandle:		Chunk mode of the camera was not activated. See feature ChunkModeActive
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//
// Details:     This function can only succeed if the given frame has been filled by the API.
//
public static native @Cast("VmbError_t") int VmbAncillaryDataOpen( VmbFrame_t pFrame,
                                                     @ByPtrPtr VmbHandle_t pAncillaryDataHandle );

//
// Method:      VmbAncillaryDataClose()
//
// Purpose:     Destroy the working handle to the ancillary data inside a frame.
//
// Parameters:
//
//  [in ]  VmbHandle_t  ancillaryDataHandle  Handle to ancillary frame data
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//
// Details:     After reading the ancillary data and before re-queuing the frame, ancillary data
//              must be closed.
//
public static native @Cast("VmbError_t") int VmbAncillaryDataClose( VmbHandle_t ancillaryDataHandle );


//----- Memory/Register access --------------------------------------------
//----- Memory/Register access --------------------------------------------

//
// Method:      VmbMemoryRead()
//
// Purpose:     Read an array of bytes.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle          Handle for an entity that allows memory access
//  [in ]  VmbUint64_t          address         Address to be used for this read operation
//  [in ]  VmbUint32_t          bufferSize      Size of the data buffer to read
//  [out]  char*                dataBuffer      Buffer to be filled
//  [out]  VmbUint32_t*         pSizeComplete   Size of the data actually read
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//
public static native @Cast("VmbError_t") int VmbMemoryRead( VmbHandle_t handle,
                                              @Cast("VmbUint64_t") int address,
                                              @Cast("VmbUint32_t") int bufferSize,
                                              @Cast("char*") BytePointer dataBuffer,
                                              @Cast("VmbUint32_t*") IntPointer pSizeComplete );
public static native @Cast("VmbError_t") int VmbMemoryRead( VmbHandle_t handle,
                                              @Cast("VmbUint64_t") int address,
                                              @Cast("VmbUint32_t") int bufferSize,
                                              @Cast("char*") ByteBuffer dataBuffer,
                                              @Cast("VmbUint32_t*") IntBuffer pSizeComplete );
public static native @Cast("VmbError_t") int VmbMemoryRead( VmbHandle_t handle,
                                              @Cast("VmbUint64_t") int address,
                                              @Cast("VmbUint32_t") int bufferSize,
                                              @Cast("char*") byte[] dataBuffer,
                                              @Cast("VmbUint32_t*") int[] pSizeComplete );

//
// Method:      VmbMemoryWrite()
//
// Purpose:     Write an array of bytes.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle          Handle for an entity that allows memory access
//  [in ]  VmbUint64_t          address         Address to be used for this read operation
//  [in ]  VmbUint32_t          bufferSize      Size of the data buffer to write
//  [in ]  const char*          dataBuffer      Data to write
//  [out]  VmbUint32_t*         pSizeComplete   Number of bytes successfully written; if an
//                                              error occurs this is less than bufferSize
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorMoreData:      Not all data were written; see pSizeComplete value for the number of bytes written
//
public static native @Cast("VmbError_t") int VmbMemoryWrite( VmbHandle_t handle,
                                               @Cast("VmbUint64_t") int address,
                                               @Cast("VmbUint32_t") int bufferSize,
                                               @Cast("const char*") BytePointer dataBuffer,
                                               @Cast("VmbUint32_t*") IntPointer pSizeComplete );
public static native @Cast("VmbError_t") int VmbMemoryWrite( VmbHandle_t handle,
                                               @Cast("VmbUint64_t") int address,
                                               @Cast("VmbUint32_t") int bufferSize,
                                               String dataBuffer,
                                               @Cast("VmbUint32_t*") IntBuffer pSizeComplete );
public static native @Cast("VmbError_t") int VmbMemoryWrite( VmbHandle_t handle,
                                               @Cast("VmbUint64_t") int address,
                                               @Cast("VmbUint32_t") int bufferSize,
                                               @Cast("const char*") BytePointer dataBuffer,
                                               @Cast("VmbUint32_t*") int[] pSizeComplete );
public static native @Cast("VmbError_t") int VmbMemoryWrite( VmbHandle_t handle,
                                               @Cast("VmbUint64_t") int address,
                                               @Cast("VmbUint32_t") int bufferSize,
                                               String dataBuffer,
                                               @Cast("VmbUint32_t*") IntPointer pSizeComplete );
public static native @Cast("VmbError_t") int VmbMemoryWrite( VmbHandle_t handle,
                                               @Cast("VmbUint64_t") int address,
                                               @Cast("VmbUint32_t") int bufferSize,
                                               @Cast("const char*") BytePointer dataBuffer,
                                               @Cast("VmbUint32_t*") IntBuffer pSizeComplete );
public static native @Cast("VmbError_t") int VmbMemoryWrite( VmbHandle_t handle,
                                               @Cast("VmbUint64_t") int address,
                                               @Cast("VmbUint32_t") int bufferSize,
                                               String dataBuffer,
                                               @Cast("VmbUint32_t*") int[] pSizeComplete );

//
// Method:      VmbRegistersRead()
//
// Purpose:     Read an array of registers.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle              Handle for an entity that allows register access
//  [in ]  VmbUint32_t          readCount           Number of registers to be read
//  [in ]  const VmbUint64_t*   pAddressArray       Array of addresses to be used for this read operation
//  [out]  VmbUint64_t*         pDataArray          Array of registers to be used for this read operation
//  [out]  VmbUint32_t*         pNumCompleteReads   Number of reads completed
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorIncomplete:    Not all the requested reads could be completed
//
// Details:     Two arrays of data must be provided: an array of register addresses and one
//              for corresponding values to be read. The registers are read consecutively
//              until an error occurs or all registers are written successfully.
//
public static native @Cast("VmbError_t") int VmbRegistersRead( VmbHandle_t handle,
                                                 @Cast("VmbUint32_t") int readCount,
                                                 @Cast("const VmbUint64_t*") IntPointer pAddressArray,
                                                 @Cast("VmbUint64_t*") IntPointer pDataArray,
                                                 @Cast("VmbUint32_t*") IntPointer pNumCompleteReads );
public static native @Cast("VmbError_t") int VmbRegistersRead( VmbHandle_t handle,
                                                 @Cast("VmbUint32_t") int readCount,
                                                 @Cast("const VmbUint64_t*") IntBuffer pAddressArray,
                                                 @Cast("VmbUint64_t*") IntBuffer pDataArray,
                                                 @Cast("VmbUint32_t*") IntBuffer pNumCompleteReads );
public static native @Cast("VmbError_t") int VmbRegistersRead( VmbHandle_t handle,
                                                 @Cast("VmbUint32_t") int readCount,
                                                 @Cast("const VmbUint64_t*") int[] pAddressArray,
                                                 @Cast("VmbUint64_t*") int[] pDataArray,
                                                 @Cast("VmbUint32_t*") int[] pNumCompleteReads );

//
// Method:      VmbRegistersWrite()
//
// Purpose:     Write an array of registers.
//
// Parameters:
//
//  [in ]  const VmbHandle_t    handle                  Handle for an entity that allows register access
//  [in ]  VmbUint32_t          writeCount              Number of registers to be written
//  [in ]  const VmbUint64_t*   pAddressArray           Array of addresses to be used for this write operation
//  [in ]  const VmbUint64_t*   pDataArray              Array of reads to be used for this write operation
//  [out]  VmbUint32_t*         pNumCompleteWrites      Number of writes completed
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorIncomplete:    Not all the requested writes could be completed
//
// Details:     Two arrays of data must be provided: an array of register addresses and one with the
//              corresponding values to be written to these addresses. The registers are written
//              consecutively until an error occurs or all registers are written successfully.
//
public static native @Cast("VmbError_t") int VmbRegistersWrite( VmbHandle_t handle,
                                                  @Cast("VmbUint32_t") int writeCount,
                                                  @Cast("const VmbUint64_t*") IntPointer pAddressArray,
                                                  @Cast("const VmbUint64_t*") IntPointer pDataArray,
                                                  @Cast("VmbUint32_t*") IntPointer pNumCompleteWrites );
public static native @Cast("VmbError_t") int VmbRegistersWrite( VmbHandle_t handle,
                                                  @Cast("VmbUint32_t") int writeCount,
                                                  @Cast("const VmbUint64_t*") IntBuffer pAddressArray,
                                                  @Cast("const VmbUint64_t*") IntBuffer pDataArray,
                                                  @Cast("VmbUint32_t*") IntBuffer pNumCompleteWrites );
public static native @Cast("VmbError_t") int VmbRegistersWrite( VmbHandle_t handle,
                                                  @Cast("VmbUint32_t") int writeCount,
                                                  @Cast("const VmbUint64_t*") int[] pAddressArray,
                                                  @Cast("const VmbUint64_t*") int[] pDataArray,
                                                  @Cast("VmbUint32_t*") int[] pNumCompleteWrites );

//
// Method:      VmbCameraSettingsSave()
//
// Purpose:     Saves all feature values to XML file.
//
// Parameters:
//
//  [in ]  const VmbHandle_t             handle              Handle for an entity that allows register access
//  [in ]  const char*                   fileName            Name of XML file to save settings
//  [in ]  VmbFeaturePersistSettings_t*  pSettings           Settings struct
//  [in ]  VmbUint32_t                   sizeofSettings      Size of settings struct
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorBadParameter:  If "fileName" is NULL
//
// Details:     Camera must be opened beforehand and function needs corresponding handle.
//              With given filename parameter path and name of XML file can be determined.
//              Additionally behaviour of function can be set with providing 'persistent struct'.
//
public static native @Cast("VmbError_t") int VmbCameraSettingsSave( VmbHandle_t handle, 
                                                      @Cast("const char*") BytePointer fileName, 
                                                      VmbFeaturePersistSettings_t pSettings, 
                                                      @Cast("VmbUint32_t") int sizeofSettings );
public static native @Cast("VmbError_t") int VmbCameraSettingsSave( VmbHandle_t handle, 
                                                      String fileName, 
                                                      VmbFeaturePersistSettings_t pSettings, 
                                                      @Cast("VmbUint32_t") int sizeofSettings );

//
// Method:      VmbCameraSettingsLoad()
//
// Purpose:     Load all feature values from XML file to device.
//
// Parameters:
//
//  [in ]  const VmbHandle_t             handle              Handle for an entity that allows register access
//  [in ]  const char*                   fileName            Name of XML file to save settings
//  [in ]  VmbFeaturePersistSettings_t*  pSettings           Settings struct
//  [in ]  VmbUint32_t                   sizeofSettings      Size of settings struct
//
// Returns:
//
//  - VmbErrorSuccess:       If no error
//  - VmbErrorApiNotStarted: VmbStartup() was not called before the current command
//  - VmbErrorBadHandle:     The given handle is not valid
//  - VmbErrorInvalidAccess: Operation is invalid with the current access mode
//  - VmbErrorBadParameter:  If "fileName" is NULL
//
// Details:     Camera must be opened beforehand and function needs corresponding handle.
//              With given filename parameter path and name of XML file can be determined.
//              Additionally behaviour of function can be set with providing 'settings struct'.
//
public static native @Cast("VmbError_t") int VmbCameraSettingsLoad( VmbHandle_t handle, 
                                                      @Cast("const char*") BytePointer fileName, 
                                                      VmbFeaturePersistSettings_t pSettings, 
                                                      @Cast("VmbUint32_t") int sizeofSettings );
public static native @Cast("VmbError_t") int VmbCameraSettingsLoad( VmbHandle_t handle, 
                                                      String fileName, 
                                                      VmbFeaturePersistSettings_t pSettings, 
                                                      @Cast("VmbUint32_t") int sizeofSettings );

// #ifdef __cplusplus
// #endif

// #endif // VIMBAC_H_INCLUDE_


// Parsed from <VimbaCPP/Include/VimbaCPPCommon.h>

/*=============================================================================
  Copyright (C) 2012 - 2017 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        VimbaCPPCommon.h

  Description: Common type definitions used in Vimba CPP API.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_CPPCOMMON_H
// #define AVT_VMBAPI_CPPCOMMON_H

// #if defined (_WIN32)
// #elif defined (__GNUC__) && (__GNUC__ >= 4) && defined (__ELF__)
//     #define IMEXPORT
// #elif defined (__APPLE__)
//     #define IMEXPORT
// #else
//     #error Unknown platform, file needs adaption
// #endif

// #include <vector>
// #include <string>
// #include "VimbaC/Include/VmbCommonTypes.h"

/** enum AVT::VmbAPI::UpdateTriggerType */
public static final int
    UpdateTriggerPluggedIn           = 0,           // A new camera was discovered by Vimba
    UpdateTriggerPluggedOut          = 1,           // A camera has disappeared from the bus
    UpdateTriggerOpenStateChanged    = 3;            // The possible opening mode of a camera has changed (e.g., because it was opened by another application)
@Namespace("AVT::VmbAPI") @Opaque public static class EnumEntry extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public EnumEntry() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public EnumEntry(Pointer p) { super(p); }
}

 // AVT::VmbAPI

// #endif

// Parsed from <VimbaCPP/Include/UserSharedPointerDefines.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        UserSharedPointerDefines.h

  Description: Definition of macros for using different shared pointer 
               implementations.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_USERSHAREDPOINTERDEFINES_H
// #define AVT_VMBAPI_USERSHAREDPOINTERDEFINES_H

// 
// Vimba C++ API does not necessarily rely on AVT::VmbAPI::shared_ptr. You might want to use your own shared pointer type or the one that ships with your
// implementation of the C++ standard.
// To use a custom shared pointer implementation simply add the define USER_SHARED_POINTER to your project / compiler settings and complete this header file.
//


// Add all your required shared pointer implementation headers here.
// HINT: #include <memory> is used for std::shared_ptr

// Set the calls for your implementation of the shared pointer functions
// a) Declaration
// b) Reset with argument
// c) Reset without argument
// d) == operator
// e) NULL test
// f) Access to underlying raw pointer
// g) Dynamic cast of shared pointer

// a) This is the define for a declaration.
// #define SP_DECL( T )            std::shared_ptr<T>
// b) This is the define for setting an existing shared pointer.
// #define SP_SET( sp, rawPtr )    (sp).reset( rawPtr )
// c) This is the define for resetting without an argument to decrease the ref count.
// #define SP_RESET( sp )          (sp).reset()
// d) This is the define for the equal operator. Shared pointers are usually considered equal when the raw pointers point to the same address.
// #define SP_ISEQUAL( sp1, sp2 )  ( (sp1) == (sp2) )
// e) This is the define for the NULL check.
// #define SP_ISNULL( sp )         ( NULL == (sp) )
// f) This is the define for the raw pointer access. This is usually accomplished through the dereferencing operator (->).
// #define SP_ACCESS( sp )         (sp).get()
// g) This is the define for the dynamic cast of the pointer.
// #define SP_DYN_CAST( sp, T )    std::dynamic_pointer_cast<T>(sp)

// These are all uses of a SP_DECL shared_ptr declaration
@Namespace("AVT::VmbAPI") @Opaque public static class Interface extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Interface() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Interface(Pointer p) { super(p); }
}

@Namespace("AVT::VmbAPI") @Opaque public static class Camera extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Camera() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Camera(Pointer p) { super(p); }
}

@Namespace("AVT::VmbAPI") @Opaque public static class Feature extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Feature() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Feature(Pointer p) { super(p); }
}

@Namespace("AVT::VmbAPI") @Opaque public static class FeatureContainer extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public FeatureContainer() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FeatureContainer(Pointer p) { super(p); }
}

@Namespace("AVT::VmbAPI") @Opaque public static class IFeatureObserver extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public IFeatureObserver() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IFeatureObserver(Pointer p) { super(p); }
}

@Namespace("AVT::VmbAPI") @Opaque public static class Frame extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Frame() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Frame(Pointer p) { super(p); }
}

@Namespace("AVT::VmbAPI") @Opaque public static class FrameHandler extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public FrameHandler() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FrameHandler(Pointer p) { super(p); }
}

@Namespace("AVT::VmbAPI") @Opaque public static class IFrameObserver extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public IFrameObserver() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IFrameObserver(Pointer p) { super(p); }
}

@Namespace("AVT::VmbAPI") @Opaque public static class AncillaryData extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public AncillaryData() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public AncillaryData(Pointer p) { super(p); }
}

@Namespace("AVT::VmbAPI") @Opaque public static class ConstAncillaryData extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ConstAncillaryData() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ConstAncillaryData(Pointer p) { super(p); }
}

@Namespace("AVT::VmbAPI") @Opaque public static class ICameraFactory extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ICameraFactory() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ICameraFactory(Pointer p) { super(p); }
}

@Namespace("AVT::VmbAPI") @Opaque public static class ICameraListObserver extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public ICameraListObserver() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ICameraListObserver(Pointer p) { super(p); }
}

@Namespace("AVT::VmbAPI") @Opaque public static class IInterfaceListObserver extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public IInterfaceListObserver() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public IInterfaceListObserver(Pointer p) { super(p); }
}

 // Namespace AVT::VmbAPI
   

// #endif //AVT_VMBAPI_USERSHAREDPOINTERDEFINES_H


// Parsed from <VimbaCPP/Include/Mutex.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        Mutex.h

  Description: Definition of class AVT::VmbAPI::Mutex.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_MUTEX
// #define AVT_VMBAPI_MUTEX

// #include <VimbaCPP/Include/VimbaCPPCommon.h>

// #ifdef _WIN32
//     #include <windows.h>
// #else
//     #include <pthread.h>
// #endif

@Namespace("AVT::VmbAPI") @NoOffset public static class Mutex extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Mutex(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Mutex(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Mutex position(long position) {
        return (Mutex)super.position(position);
    }

    public Mutex( @Cast("bool") boolean bInitLock/*=false*/ ) { super((Pointer)null); allocate(bInitLock); }
    private native void allocate( @Cast("bool") boolean bInitLock/*=false*/ );
    public Mutex( ) { super((Pointer)null); allocate(); }
    private native void allocate( );

    public native void Lock();
    public native void Unlock();
}

 //namespace AVT::VmbAPI

// #endif //AVT_VMBAPI_MUTEX


// Parsed from <VimbaCPP/Include/BasicLockable.h>

/*=============================================================================
  Copyright (C) 2012 Allied Vision Technologies.  All Rights Reserved.

  Redistribution of this file, in original or modified form, without
  prior written consent of Allied Vision Technologies is prohibited.

-------------------------------------------------------------------------------

  File:        BasicLockable.h

  Description: Definition of class AVT::VmbAPI::BasicLockable.

-------------------------------------------------------------------------------

  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF TITLE,
  NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR  PURPOSE ARE
  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  
  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=============================================================================*/

// #ifndef AVT_VMBAPI_BASICLOCKABLE
// #define AVT_VMBAPI_BASICLOCKABLE

// #include <VimbaCPP/Include/VimbaCPPCommon.h>
// #include <VimbaCPP/Include/SharedPointerDefines.h>
// #include <VimbaCPP/Include/Mutex.h>

@Namespace("AVT::VmbAPI") @NoOffset public static class BasicLockable extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public BasicLockable(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public BasicLockable(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public BasicLockable position(long position) {
        return (BasicLockable)super.position(position);
    }

    public BasicLockable() { super((Pointer)null); allocate(); }
    private native void allocate();
    public BasicLockable( @SharedPtr Mutex pMutex ) { super((Pointer)null); allocate(pMutex); }
    private native void allocate( @SharedPtr Mutex pMutex );

    public native @SharedPtr Mutex GetMutex();

    public native void Lock();
    public native void Unlock();
}

 //namespace AVT::VmbAPI

// #endif 

}
