<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_452) on Mon Jun 30 18:08:51 UTC 2025 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Core (JavaCPP Presets for OpenCV 4.11.0-1.5.12 API)</title>
<meta name="date" content="2025-06-30">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Core (JavaCPP Presets for OpenCV 4.11.0-1.5.12 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9,"i40":9,"i41":41,"i42":9,"i43":9,"i44":9,"i45":9,"i46":9,"i47":9,"i48":9,"i49":9,"i50":9,"i51":9,"i52":9,"i53":9,"i54":9,"i55":9,"i56":9,"i57":9,"i58":9,"i59":9,"i60":9,"i61":9,"i62":9,"i63":9,"i64":9,"i65":9,"i66":9,"i67":9,"i68":9,"i69":9,"i70":9,"i71":9,"i72":9,"i73":9,"i74":9,"i75":9,"i76":9,"i77":9,"i78":9,"i79":9,"i80":9,"i81":9,"i82":9,"i83":9,"i84":9,"i85":9,"i86":9,"i87":9,"i88":9,"i89":41,"i90":9,"i91":9,"i92":9,"i93":9,"i94":9,"i95":9,"i96":9,"i97":9,"i98":9,"i99":9,"i100":9,"i101":9,"i102":9,"i103":9,"i104":9,"i105":9,"i106":9,"i107":9,"i108":9,"i109":9,"i110":9,"i111":9,"i112":9,"i113":9,"i114":9,"i115":9,"i116":9,"i117":9,"i118":9,"i119":9,"i120":9,"i121":9,"i122":9,"i123":9,"i124":9,"i125":9,"i126":9,"i127":9,"i128":9,"i129":9,"i130":9,"i131":9,"i132":9,"i133":9,"i134":9,"i135":9,"i136":9,"i137":9,"i138":9,"i139":9,"i140":9,"i141":9,"i142":9,"i143":9,"i144":9,"i145":9,"i146":9,"i147":9,"i148":9,"i149":9,"i150":9,"i151":9,"i152":9,"i153":9,"i154":9,"i155":9,"i156":9,"i157":9,"i158":9,"i159":9,"i160":9,"i161":9,"i162":9,"i163":9,"i164":9,"i165":9,"i166":9,"i167":9,"i168":9,"i169":9,"i170":9,"i171":9,"i172":9,"i173":9,"i174":9,"i175":9,"i176":9,"i177":9,"i178":9,"i179":9,"i180":9,"i181":9,"i182":9,"i183":9,"i184":9,"i185":9,"i186":9,"i187":9,"i188":9,"i189":9,"i190":9,"i191":9,"i192":9,"i193":9,"i194":9,"i195":9,"i196":9,"i197":9,"i198":9,"i199":9,"i200":9,"i201":9,"i202":9,"i203":9,"i204":9,"i205":9,"i206":9,"i207":9,"i208":9,"i209":9,"i210":9,"i211":9,"i212":9,"i213":9,"i214":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Core.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../org/opencv/core/Algorithm.html" title="class in org.opencv.core"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../org/opencv/core/Core.MinMaxLocResult.html" title="class in org.opencv.core"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/opencv/core/Core.html" target="_top">Frames</a></li>
<li><a href="Core.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.opencv.core</div>
<h2 title="Class Core" class="title">Class Core</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>org.opencv.core.Core</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">Core</span>
extends <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></pre>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.MinMaxLocResult.html" title="class in org.opencv.core">Core.MinMaxLocResult</a></span></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#ALGO_HINT_ACCURATE">ALGO_HINT_ACCURATE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#ALGO_HINT_APPROX">ALGO_HINT_APPROX</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#ALGO_HINT_DEFAULT">ALGO_HINT_DEFAULT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BadAlign">BadAlign</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BadAlphaChannel">BadAlphaChannel</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BadCallBack">BadCallBack</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BadCOI">BadCOI</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BadDataPtr">BadDataPtr</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BadDepth">BadDepth</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BadImageSize">BadImageSize</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BadModelOrChSeq">BadModelOrChSeq</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BadNumChannel1U">BadNumChannel1U</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BadNumChannels">BadNumChannels</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BadOffset">BadOffset</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BadOrder">BadOrder</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BadOrigin">BadOrigin</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BadROISize">BadROISize</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BadStep">BadStep</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BadTileSize">BadTileSize</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BORDER_CONSTANT">BORDER_CONSTANT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BORDER_DEFAULT">BORDER_DEFAULT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BORDER_ISOLATED">BORDER_ISOLATED</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BORDER_REFLECT">BORDER_REFLECT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BORDER_REFLECT_101">BORDER_REFLECT_101</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BORDER_REFLECT101">BORDER_REFLECT101</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BORDER_REPLICATE">BORDER_REPLICATE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BORDER_TRANSPARENT">BORDER_TRANSPARENT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#BORDER_WRAP">BORDER_WRAP</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#CMP_EQ">CMP_EQ</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#CMP_GE">CMP_GE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#CMP_GT">CMP_GT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#CMP_LE">CMP_LE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#CMP_LT">CMP_LT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#CMP_NE">CMP_NE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#COVAR_COLS">COVAR_COLS</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#COVAR_NORMAL">COVAR_NORMAL</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#COVAR_ROWS">COVAR_ROWS</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#COVAR_SCALE">COVAR_SCALE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#COVAR_SCRAMBLED">COVAR_SCRAMBLED</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#COVAR_USE_AVG">COVAR_USE_AVG</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#DCT_INVERSE">DCT_INVERSE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#DCT_ROWS">DCT_ROWS</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#DECOMP_CHOLESKY">DECOMP_CHOLESKY</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#DECOMP_EIG">DECOMP_EIG</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#DECOMP_LU">DECOMP_LU</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#DECOMP_NORMAL">DECOMP_NORMAL</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#DECOMP_QR">DECOMP_QR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#DECOMP_SVD">DECOMP_SVD</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#DFT_COMPLEX_INPUT">DFT_COMPLEX_INPUT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#DFT_COMPLEX_OUTPUT">DFT_COMPLEX_OUTPUT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#DFT_INVERSE">DFT_INVERSE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#DFT_REAL_OUTPUT">DFT_REAL_OUTPUT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#DFT_ROWS">DFT_ROWS</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#DFT_SCALE">DFT_SCALE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#FILLED">FILLED</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Formatter_FMT_C">Formatter_FMT_C</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Formatter_FMT_CSV">Formatter_FMT_CSV</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Formatter_FMT_DEFAULT">Formatter_FMT_DEFAULT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Formatter_FMT_MATLAB">Formatter_FMT_MATLAB</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Formatter_FMT_NUMPY">Formatter_FMT_NUMPY</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Formatter_FMT_PYTHON">Formatter_FMT_PYTHON</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#GEMM_1_T">GEMM_1_T</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#GEMM_2_T">GEMM_2_T</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#GEMM_3_T">GEMM_3_T</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#GpuApiCallError">GpuApiCallError</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#GpuNotSupported">GpuNotSupported</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#HeaderIsNull">HeaderIsNull</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#KMEANS_PP_CENTERS">KMEANS_PP_CENTERS</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#KMEANS_RANDOM_CENTERS">KMEANS_RANDOM_CENTERS</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#KMEANS_USE_INITIAL_LABELS">KMEANS_USE_INITIAL_LABELS</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#MaskIsTiled">MaskIsTiled</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#NATIVE_LIBRARY_NAME">NATIVE_LIBRARY_NAME</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#NORM_HAMMING">NORM_HAMMING</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#NORM_HAMMING2">NORM_HAMMING2</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#NORM_INF">NORM_INF</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#NORM_L1">NORM_L1</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#NORM_L2">NORM_L2</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#NORM_L2SQR">NORM_L2SQR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#NORM_MINMAX">NORM_MINMAX</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#NORM_RELATIVE">NORM_RELATIVE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#NORM_TYPE_MASK">NORM_TYPE_MASK</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#OpenCLApiCallError">OpenCLApiCallError</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#OpenCLDoubleNotSupported">OpenCLDoubleNotSupported</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#OpenCLInitError">OpenCLInitError</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#OpenCLNoAMDBlasFft">OpenCLNoAMDBlasFft</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#OpenGlApiCallError">OpenGlApiCallError</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#OpenGlNotSupported">OpenGlNotSupported</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Param_ALGORITHM">Param_ALGORITHM</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Param_BOOLEAN">Param_BOOLEAN</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Param_FLOAT">Param_FLOAT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Param_INT">Param_INT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Param_MAT">Param_MAT</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Param_MAT_VECTOR">Param_MAT_VECTOR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Param_REAL">Param_REAL</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Param_SCALAR">Param_SCALAR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Param_STRING">Param_STRING</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Param_UCHAR">Param_UCHAR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Param_UINT64">Param_UINT64</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Param_UNSIGNED_INT">Param_UNSIGNED_INT</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#PCA_DATA_AS_COL">PCA_DATA_AS_COL</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#PCA_DATA_AS_ROW">PCA_DATA_AS_ROW</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#PCA_USE_AVG">PCA_USE_AVG</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#REDUCE_AVG">REDUCE_AVG</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#REDUCE_MAX">REDUCE_MAX</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#REDUCE_MIN">REDUCE_MIN</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#REDUCE_SUM">REDUCE_SUM</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#REDUCE_SUM2">REDUCE_SUM2</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#RNG_NORMAL">RNG_NORMAL</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#RNG_UNIFORM">RNG_UNIFORM</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#ROTATE_180">ROTATE_180</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#ROTATE_90_CLOCKWISE">ROTATE_90_CLOCKWISE</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#ROTATE_90_COUNTERCLOCKWISE">ROTATE_90_COUNTERCLOCKWISE</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#SORT_ASCENDING">SORT_ASCENDING</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#SORT_DESCENDING">SORT_DESCENDING</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#SORT_EVERY_COLUMN">SORT_EVERY_COLUMN</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#SORT_EVERY_ROW">SORT_EVERY_ROW</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsAssert">StsAssert</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsAutoTrace">StsAutoTrace</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsBackTrace">StsBackTrace</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsBadArg">StsBadArg</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsBadFlag">StsBadFlag</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsBadFunc">StsBadFunc</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsBadMask">StsBadMask</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsBadMemBlock">StsBadMemBlock</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsBadPoint">StsBadPoint</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsBadSize">StsBadSize</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsDivByZero">StsDivByZero</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsError">StsError</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsFilterOffsetErr">StsFilterOffsetErr</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsFilterStructContentErr">StsFilterStructContentErr</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsInplaceNotSupported">StsInplaceNotSupported</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsInternal">StsInternal</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsKernelStructContentErr">StsKernelStructContentErr</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsNoConv">StsNoConv</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsNoMem">StsNoMem</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsNotImplemented">StsNotImplemented</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsNullPtr">StsNullPtr</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsObjectNotFound">StsObjectNotFound</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsOk">StsOk</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsOutOfRange">StsOutOfRange</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsParseError">StsParseError</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsUnmatchedFormats">StsUnmatchedFormats</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsUnmatchedSizes">StsUnmatchedSizes</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsUnsupportedFormat">StsUnsupportedFormat</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#StsVecLengthErr">StsVecLengthErr</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#SVD_FULL_UV">SVD_FULL_UV</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#SVD_MODIFY_A">SVD_MODIFY_A</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#SVD_NO_UV">SVD_NO_UV</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#VERSION">VERSION</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#VERSION_MAJOR">VERSION_MAJOR</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#VERSION_MINOR">VERSION_MINOR</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#VERSION_REVISION">VERSION_REVISION</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#VERSION_STATUS">VERSION_STATUS</a></span></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Core--">Core</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#absdiff-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">absdiff</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Calculates the per-element absolute difference between two arrays or between an array and a scalar.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#absdiff-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-">absdiff</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>&nbsp;</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#add-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">add</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Calculates the per-element sum of two arrays or an array and a scalar.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#add-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">add</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Calculates the per-element sum of two arrays or an array and a scalar.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#add-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">add</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
   int&nbsp;dtype)</code>
<div class="block">Calculates the per-element sum of two arrays or an array and a scalar.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#add-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-">add</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
   <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>&nbsp;</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#add-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-org.opencv.core.Mat-">add</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
   <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>&nbsp;</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#add-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-org.opencv.core.Mat-int-">add</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
   <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
   int&nbsp;dtype)</code>&nbsp;</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#addSamplesDataSearchPath-java.lang.String-">addSamplesDataSearchPath</a></span>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;path)</code>
<div class="block">Override search data path by adding new search location

 Use this only to override default behavior
 Passed paths are used in LIFO order.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#addSamplesDataSearchSubDirectory-java.lang.String-">addSamplesDataSearchSubDirectory</a></span>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;subdir)</code>
<div class="block">Append samples search data sub directory

 General usage is to add OpenCV modules name (<code>&amp;lt;opencv_contrib&amp;gt;/modules/&amp;lt;name&amp;gt;/samples/data</code> -&gt; <code>&amp;lt;name&amp;gt;/samples/data</code> + <code>modules/&amp;lt;name&amp;gt;/samples/data</code>).</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#addWeighted-org.opencv.core.Mat-double-org.opencv.core.Mat-double-double-org.opencv.core.Mat-">addWeighted</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
           double&nbsp;alpha,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
           double&nbsp;beta,
           double&nbsp;gamma,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Calculates the weighted sum of two arrays.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#addWeighted-org.opencv.core.Mat-double-org.opencv.core.Mat-double-double-org.opencv.core.Mat-int-">addWeighted</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
           double&nbsp;alpha,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
           double&nbsp;beta,
           double&nbsp;gamma,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
           int&nbsp;dtype)</code>
<div class="block">Calculates the weighted sum of two arrays.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#batchDistance-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-">batchDistance</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist,
             int&nbsp;dtype,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nidx)</code>
<div class="block">naive nearest neighbor finder

 see http://en.wikipedia.org/wiki/Nearest_neighbor_search
 TODO: document</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#batchDistance-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-int-">batchDistance</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist,
             int&nbsp;dtype,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nidx,
             int&nbsp;normType)</code>
<div class="block">naive nearest neighbor finder

 see http://en.wikipedia.org/wiki/Nearest_neighbor_search
 TODO: document</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#batchDistance-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-int-int-">batchDistance</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist,
             int&nbsp;dtype,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nidx,
             int&nbsp;normType,
             int&nbsp;K)</code>
<div class="block">naive nearest neighbor finder

 see http://en.wikipedia.org/wiki/Nearest_neighbor_search
 TODO: document</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#batchDistance-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-int-int-org.opencv.core.Mat-">batchDistance</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist,
             int&nbsp;dtype,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nidx,
             int&nbsp;normType,
             int&nbsp;K,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">naive nearest neighbor finder

 see http://en.wikipedia.org/wiki/Nearest_neighbor_search
 TODO: document</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#batchDistance-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-int-int-org.opencv.core.Mat-int-">batchDistance</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist,
             int&nbsp;dtype,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nidx,
             int&nbsp;normType,
             int&nbsp;K,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
             int&nbsp;update)</code>
<div class="block">naive nearest neighbor finder

 see http://en.wikipedia.org/wiki/Nearest_neighbor_search
 TODO: document</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#batchDistance-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-int-int-org.opencv.core.Mat-int-boolean-">batchDistance</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist,
             int&nbsp;dtype,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nidx,
             int&nbsp;normType,
             int&nbsp;K,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
             int&nbsp;update,
             boolean&nbsp;crosscheck)</code>
<div class="block">naive nearest neighbor finder

 see http://en.wikipedia.org/wiki/Nearest_neighbor_search
 TODO: document</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#bitwise_and-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">bitwise_and</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">computes bitwise conjunction of the two arrays (dst = src1 &amp; src2)
 Calculates the per-element bit-wise conjunction of two arrays or an
 array and a scalar.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#bitwise_and-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">bitwise_and</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">computes bitwise conjunction of the two arrays (dst = src1 &amp; src2)
 Calculates the per-element bit-wise conjunction of two arrays or an
 array and a scalar.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#bitwise_not-org.opencv.core.Mat-org.opencv.core.Mat-">bitwise_not</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Inverts every bit of an array.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#bitwise_not-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">bitwise_not</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Inverts every bit of an array.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#bitwise_or-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">bitwise_or</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Calculates the per-element bit-wise disjunction of two arrays or an
 array and a scalar.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#bitwise_or-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">bitwise_or</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Calculates the per-element bit-wise disjunction of two arrays or an
 array and a scalar.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#bitwise_xor-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">bitwise_xor</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Calculates the per-element bit-wise "exclusive or" operation on two
 arrays or an array and a scalar.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#bitwise_xor-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">bitwise_xor</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Calculates the per-element bit-wise "exclusive or" operation on two
 arrays or an array and a scalar.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#borderInterpolate-int-int-int-">borderInterpolate</a></span>(int&nbsp;p,
                 int&nbsp;len,
                 int&nbsp;borderType)</code>
<div class="block">Computes the source location of an extrapolated pixel.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#broadcast-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">broadcast</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;shape,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Broadcast the given Mat to the given shape.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#calcCovarMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">calcCovarMatrix</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;samples,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;covar,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
               int&nbsp;flags)</code>
<div class="block"><b>Note:</b> use #COVAR_ROWS or #COVAR_COLS flag</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#calcCovarMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">calcCovarMatrix</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;samples,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;covar,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
               int&nbsp;flags,
               int&nbsp;ctype)</code>
<div class="block"><b>Note:</b> use #COVAR_ROWS or #COVAR_COLS flag</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#cartToPolar-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">cartToPolar</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle)</code>
<div class="block">Calculates the magnitude and angle of 2D vectors.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#cartToPolar-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-boolean-">cartToPolar</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle,
           boolean&nbsp;angleInDegrees)</code>
<div class="block">Calculates the magnitude and angle of 2D vectors.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#checkHardwareSupport-int-">checkHardwareSupport</a></span>(int&nbsp;feature)</code>
<div class="block">Returns true if the specified feature is supported by the host hardware.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#checkRange-org.opencv.core.Mat-">checkRange</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a)</code>
<div class="block">Checks every element of an input array for invalid values.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#checkRange-org.opencv.core.Mat-boolean-">checkRange</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
          boolean&nbsp;quiet)</code>
<div class="block">Checks every element of an input array for invalid values.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#checkRange-org.opencv.core.Mat-boolean-double-">checkRange</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
          boolean&nbsp;quiet,
          double&nbsp;minVal)</code>
<div class="block">Checks every element of an input array for invalid values.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#checkRange-org.opencv.core.Mat-boolean-double-double-">checkRange</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
          boolean&nbsp;quiet,
          double&nbsp;minVal,
          double&nbsp;maxVal)</code>
<div class="block">Checks every element of an input array for invalid values.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#compare-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">compare</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
       int&nbsp;cmpop)</code>
<div class="block">Performs the per-element comparison of two arrays or an array and scalar value.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#compare-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-int-">compare</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
       int&nbsp;cmpop)</code>&nbsp;</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#completeSymm-org.opencv.core.Mat-">completeSymm</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m)</code>
<div class="block">Copies the lower or the upper half of a square matrix to its another half.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#completeSymm-org.opencv.core.Mat-boolean-">completeSymm</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
            boolean&nbsp;lowerToUpper)</code>
<div class="block">Copies the lower or the upper half of a square matrix to its another half.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#convertFp16-org.opencv.core.Mat-org.opencv.core.Mat-">convertFp16</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">Use Mat::convertTo with CV_16F instead.</span></div>
</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#convertScaleAbs-org.opencv.core.Mat-org.opencv.core.Mat-">convertScaleAbs</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Scales, calculates absolute values, and converts the result to 8-bit.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#convertScaleAbs-org.opencv.core.Mat-org.opencv.core.Mat-double-">convertScaleAbs</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               double&nbsp;alpha)</code>
<div class="block">Scales, calculates absolute values, and converts the result to 8-bit.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#convertScaleAbs-org.opencv.core.Mat-org.opencv.core.Mat-double-double-">convertScaleAbs</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
               double&nbsp;alpha,
               double&nbsp;beta)</code>
<div class="block">Scales, calculates absolute values, and converts the result to 8-bit.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#copyMakeBorder-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-int-int-">copyMakeBorder</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
              int&nbsp;top,
              int&nbsp;bottom,
              int&nbsp;left,
              int&nbsp;right,
              int&nbsp;borderType)</code>
<div class="block">Forms a border around an image.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#copyMakeBorder-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-int-int-org.opencv.core.Scalar-">copyMakeBorder</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
              int&nbsp;top,
              int&nbsp;bottom,
              int&nbsp;left,
              int&nbsp;right,
              int&nbsp;borderType,
              <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;value)</code>
<div class="block">Forms a border around an image.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#copyTo-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">copyTo</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">This is an overloaded member function, provided for convenience (python)
 Copies the matrix to another one.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#countNonZero-org.opencv.core.Mat-">countNonZero</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src)</code>
<div class="block">Counts non-zero array elements.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#cubeRoot-float-">cubeRoot</a></span>(float&nbsp;val)</code>
<div class="block">Computes the cube root of an argument.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#dct-org.opencv.core.Mat-org.opencv.core.Mat-">dct</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Performs a forward or inverse discrete Cosine transform of 1D or 2D array.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#dct-org.opencv.core.Mat-org.opencv.core.Mat-int-">dct</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
   int&nbsp;flags)</code>
<div class="block">Performs a forward or inverse discrete Cosine transform of 1D or 2D array.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#determinant-org.opencv.core.Mat-">determinant</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtx)</code>
<div class="block">Returns the determinant of a square floating-point matrix.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#dft-org.opencv.core.Mat-org.opencv.core.Mat-">dft</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#dft-org.opencv.core.Mat-org.opencv.core.Mat-int-">dft</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
   int&nbsp;flags)</code>
<div class="block">Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#dft-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">dft</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
   int&nbsp;flags,
   int&nbsp;nonzeroRows)</code>
<div class="block">Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#divide-double-org.opencv.core.Mat-org.opencv.core.Mat-">divide</a></span>(double&nbsp;scale,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>&nbsp;</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#divide-double-org.opencv.core.Mat-org.opencv.core.Mat-int-">divide</a></span>(double&nbsp;scale,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      int&nbsp;dtype)</code>&nbsp;</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#divide-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">divide</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Performs per-element division of two arrays or a scalar by an array.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#divide-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">divide</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      double&nbsp;scale)</code>
<div class="block">Performs per-element division of two arrays or a scalar by an array.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#divide-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-int-">divide</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      double&nbsp;scale,
      int&nbsp;dtype)</code>
<div class="block">Performs per-element division of two arrays or a scalar by an array.</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#divide-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-">divide</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
      <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>&nbsp;</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#divide-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-double-">divide</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
      <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      double&nbsp;scale)</code>&nbsp;</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#divide-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-double-int-">divide</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
      <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      double&nbsp;scale,
      int&nbsp;dtype)</code>&nbsp;</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#eigen-org.opencv.core.Mat-org.opencv.core.Mat-">eigen</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvalues)</code>
<div class="block">Calculates eigenvalues and eigenvectors of a symmetric matrix.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#eigen-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">eigen</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvalues,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors)</code>
<div class="block">Calculates eigenvalues and eigenvectors of a symmetric matrix.</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#eigenNonSymmetric-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">eigenNonSymmetric</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvalues,
                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors)</code>
<div class="block">Calculates eigenvalues and eigenvectors of a non-symmetric matrix (real eigenvalues only).</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#exp-org.opencv.core.Mat-org.opencv.core.Mat-">exp</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Calculates the exponent of every array element.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#extractChannel-org.opencv.core.Mat-org.opencv.core.Mat-int-">extractChannel</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
              int&nbsp;coi)</code>
<div class="block">Extracts a single channel from src (coi is 0-based index)</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>static float</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#fastAtan2-float-float-">fastAtan2</a></span>(float&nbsp;y,
         float&nbsp;x)</code>
<div class="block">Calculates the angle of a 2D vector in degrees.</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#findFile-java.lang.String-">findFile</a></span>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;relative_path)</code>
<div class="block">Try to find requested data file

 Search directories:

 1.</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#findFile-java.lang.String-boolean-">findFile</a></span>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;relative_path,
        boolean&nbsp;required)</code>
<div class="block">Try to find requested data file

 Search directories:

 1.</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#findFile-java.lang.String-boolean-boolean-">findFile</a></span>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;relative_path,
        boolean&nbsp;required,
        boolean&nbsp;silentMode)</code>
<div class="block">Try to find requested data file

 Search directories:

 1.</div>
</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#findFileOrKeep-java.lang.String-">findFileOrKeep</a></span>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;relative_path)</code>&nbsp;</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#findFileOrKeep-java.lang.String-boolean-">findFileOrKeep</a></span>(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;relative_path,
              boolean&nbsp;silentMode)</code>&nbsp;</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#findNonZero-org.opencv.core.Mat-org.opencv.core.Mat-">findNonZero</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;idx)</code>
<div class="block">Returns the list of locations of non-zero pixels

 Given a binary matrix (likely returned from an operation such
 as threshold(), compare(), &gt;, ==, etc, return all of
 the non-zero indices as a cv::Mat or std::vector&lt;cv::Point&gt; (x,y)
 For example:
 <code>
     cv::Mat binaryImage; // input, binary image
     cv::Mat locations;   // output, locations of non-zero pixels
     cv::findNonZero(binaryImage, locations);

     // access pixel coordinates
     Point pnt = locations.at&lt;Point&gt;(i);
 </code>
 or
 <code>
     cv::Mat binaryImage; // input, binary image
     vector&lt;Point&gt; locations;   // output, locations of non-zero pixels
     cv::findNonZero(binaryImage, locations);

     // access pixel coordinates
     Point pnt = locations[i];
 </code>

 The function do not work with multi-channel arrays.</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#flip-org.opencv.core.Mat-org.opencv.core.Mat-int-">flip</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
    int&nbsp;flipCode)</code>
<div class="block">Flips a 2D array around vertical, horizontal, or both axes.</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#flipND-org.opencv.core.Mat-org.opencv.core.Mat-int-">flipND</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      int&nbsp;axis)</code>
<div class="block">Flips a n-dimensional at given axis</div>
</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#gemm-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Mat-double-org.opencv.core.Mat-">gemm</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
    double&nbsp;alpha,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src3,
    double&nbsp;beta,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Performs generalized matrix multiplication.</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#gemm-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Mat-double-org.opencv.core.Mat-int-">gemm</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
    double&nbsp;alpha,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src3,
    double&nbsp;beta,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
    int&nbsp;flags)</code>
<div class="block">Performs generalized matrix multiplication.</div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#getBuildInformation--">getBuildInformation</a></span>()</code>
<div class="block">Returns full configuration time cmake output.</div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#getCPUFeaturesLine--">getCPUFeaturesLine</a></span>()</code>
<div class="block">Returns list of CPU features enabled during compilation.</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code>static long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#getCPUTickCount--">getCPUTickCount</a></span>()</code>
<div class="block">Returns the number of CPU ticks.</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#getDefaultAlgorithmHint--">getDefaultAlgorithmHint</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#getHardwareFeatureName-int-">getHardwareFeatureName</a></span>(int&nbsp;feature)</code>
<div class="block">Returns feature name by ID

 Returns empty string if feature is not defined</div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#getIppVersion--">getIppVersion</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#getNumberOfCPUs--">getNumberOfCPUs</a></span>()</code>
<div class="block">Returns the number of logical CPUs available for the process.</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#getNumThreads--">getNumThreads</a></span>()</code>
<div class="block">Returns the number of threads used by OpenCV for parallel regions.</div>
</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#getOptimalDFTSize-int-">getOptimalDFTSize</a></span>(int&nbsp;vecsize)</code>
<div class="block">Returns the optimal DFT size for a given vector size.</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#getThreadNum--">getThreadNum</a></span>()</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">Current implementation doesn't corresponding to this documentation.

 The exact meaning of the return value depends on the threading framework used by OpenCV library:
 <ul>
   <li>
  <code>TBB</code> - Unsupported with current 4.1 TBB release. Maybe will be supported in future.
   </li>
   <li>
  <code>OpenMP</code> - The thread number, within the current team, of the calling thread.
   </li>
   <li>
  <code>Concurrency</code> - An ID for the virtual processor that the current context is executing on (0
   for master thread and unique number for others, but not necessary 1,2,3,...).
   </li>
   <li>
  <code>GCD</code> - System calling thread's ID. Never returns 0 inside parallel region.
   </li>
   <li>
  <code>C=</code> - The index of the current parallel task.
 SEE: setNumThreads, getNumThreads
   </li>
 </ul></span></div>
</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code>static long</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#getTickCount--">getTickCount</a></span>()</code>
<div class="block">Returns the number of ticks.</div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#getTickFrequency--">getTickFrequency</a></span>()</code>
<div class="block">Returns the number of ticks per second.</div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#getVersionMajor--">getVersionMajor</a></span>()</code>
<div class="block">Returns major library version</div>
</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#getVersionMinor--">getVersionMinor</a></span>()</code>
<div class="block">Returns minor library version</div>
</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#getVersionRevision--">getVersionRevision</a></span>()</code>
<div class="block">Returns revision field of the library version</div>
</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>static <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#getVersionString--">getVersionString</a></span>()</code>
<div class="block">Returns library version string

 For example "3.4.1-dev".</div>
</td>
</tr>
<tr id="i96" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#hasNonZero-org.opencv.core.Mat-">hasNonZero</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src)</code>
<div class="block">Checks for the presence of at least one non-zero array element.</div>
</td>
</tr>
<tr id="i97" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#hconcat-java.util.List-org.opencv.core.Mat-">hconcat</a></span>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</a>&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;src,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block"><code>
     std::vector&lt;cv::Mat&gt; matrices = { cv::Mat(4, 1, CV_8UC1, cv::Scalar(1)),
                                       cv::Mat(4, 1, CV_8UC1, cv::Scalar(2)),
                                       cv::Mat(4, 1, CV_8UC1, cv::Scalar(3)),};

     cv::Mat out;
     cv::hconcat( matrices, out );
     //out:
     //[1, 2, 3;
     // 1, 2, 3;
     // 1, 2, 3;
     // 1, 2, 3]
  </code></div>
</td>
</tr>
<tr id="i98" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#idct-org.opencv.core.Mat-org.opencv.core.Mat-">idct</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.</div>
</td>
</tr>
<tr id="i99" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#idct-org.opencv.core.Mat-org.opencv.core.Mat-int-">idct</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
    int&nbsp;flags)</code>
<div class="block">Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.</div>
</td>
</tr>
<tr id="i100" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#idft-org.opencv.core.Mat-org.opencv.core.Mat-">idft</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.</div>
</td>
</tr>
<tr id="i101" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#idft-org.opencv.core.Mat-org.opencv.core.Mat-int-">idft</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
    int&nbsp;flags)</code>
<div class="block">Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.</div>
</td>
</tr>
<tr id="i102" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#idft-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">idft</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
    int&nbsp;flags,
    int&nbsp;nonzeroRows)</code>
<div class="block">Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.</div>
</td>
</tr>
<tr id="i103" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#inRange-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Scalar-org.opencv.core.Mat-">inRange</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;lowerb,
       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;upperb,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Checks if array elements lie between the elements of two other arrays.</div>
</td>
</tr>
<tr id="i104" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#insertChannel-org.opencv.core.Mat-org.opencv.core.Mat-int-">insertChannel</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             int&nbsp;coi)</code>
<div class="block">Inserts a single channel to dst (coi is 0-based index)</div>
</td>
</tr>
<tr id="i105" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#invert-org.opencv.core.Mat-org.opencv.core.Mat-">invert</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Finds the inverse or pseudo-inverse of a matrix.</div>
</td>
</tr>
<tr id="i106" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#invert-org.opencv.core.Mat-org.opencv.core.Mat-int-">invert</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      int&nbsp;flags)</code>
<div class="block">Finds the inverse or pseudo-inverse of a matrix.</div>
</td>
</tr>
<tr id="i107" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#kmeans-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.TermCriteria-int-int-">kmeans</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
      int&nbsp;K,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;bestLabels,
      <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria,
      int&nbsp;attempts,
      int&nbsp;flags)</code>
<div class="block">Finds centers of clusters and groups input samples around the clusters.</div>
</td>
</tr>
<tr id="i108" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#kmeans-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.TermCriteria-int-int-org.opencv.core.Mat-">kmeans</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
      int&nbsp;K,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;bestLabels,
      <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria,
      int&nbsp;attempts,
      int&nbsp;flags,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;centers)</code>
<div class="block">Finds centers of clusters and groups input samples around the clusters.</div>
</td>
</tr>
<tr id="i109" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#log-org.opencv.core.Mat-org.opencv.core.Mat-">log</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Calculates the natural logarithm of every array element.</div>
</td>
</tr>
<tr id="i110" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#LUT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">LUT</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lut,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Performs a look-up table transform of an array.</div>
</td>
</tr>
<tr id="i111" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#magnitude-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">magnitude</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude)</code>
<div class="block">Calculates the magnitude of 2D vectors.</div>
</td>
</tr>
<tr id="i112" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#Mahalanobis-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">Mahalanobis</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;v1,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;v2,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;icovar)</code>
<div class="block">Calculates the Mahalanobis distance between two vectors.</div>
</td>
</tr>
<tr id="i113" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#max-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">max</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Calculates per-element maximum of two arrays or an array and a scalar.</div>
</td>
</tr>
<tr id="i114" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#max-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-">max</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
   <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>&nbsp;</td>
</tr>
<tr id="i115" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#mean-org.opencv.core.Mat-">mean</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src)</code>
<div class="block">Calculates an average (mean) of array elements.</div>
</td>
</tr>
<tr id="i116" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#mean-org.opencv.core.Mat-org.opencv.core.Mat-">mean</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Calculates an average (mean) of array elements.</div>
</td>
</tr>
<tr id="i117" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#meanStdDev-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.MatOfDouble-">meanStdDev</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;mean,
          <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;stddev)</code>
<div class="block">Calculates a mean and standard deviation of array elements.</div>
</td>
</tr>
<tr id="i118" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#meanStdDev-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.MatOfDouble-org.opencv.core.Mat-">meanStdDev</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
          <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;mean,
          <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;stddev,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Calculates a mean and standard deviation of array elements.</div>
</td>
</tr>
<tr id="i119" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#merge-java.util.List-org.opencv.core.Mat-">merge</a></span>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</a>&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;mv,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>&nbsp;</td>
</tr>
<tr id="i120" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#min-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">min</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Calculates per-element minimum of two arrays or an array and a scalar.</div>
</td>
</tr>
<tr id="i121" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#min-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-">min</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
   <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>&nbsp;</td>
</tr>
<tr id="i122" class="altColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Core.MinMaxLocResult.html" title="class in org.opencv.core">Core.MinMaxLocResult</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#minMaxLoc-org.opencv.core.Mat-">minMaxLoc</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src)</code>&nbsp;</td>
</tr>
<tr id="i123" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Core.MinMaxLocResult.html" title="class in org.opencv.core">Core.MinMaxLocResult</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#minMaxLoc-org.opencv.core.Mat-org.opencv.core.Mat-">minMaxLoc</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>&nbsp;</td>
</tr>
<tr id="i124" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#mixChannels-java.util.List-java.util.List-org.opencv.core.MatOfInt-">mixChannels</a></span>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</a>&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;src,
           <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</a>&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;dst,
           <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;fromTo)</code>&nbsp;</td>
</tr>
<tr id="i125" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#mulSpectrums-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">mulSpectrums</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;b,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;c,
            int&nbsp;flags)</code>
<div class="block">Performs the per-element multiplication of two Fourier spectrums.</div>
</td>
</tr>
<tr id="i126" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#mulSpectrums-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-boolean-">mulSpectrums</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;b,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;c,
            int&nbsp;flags,
            boolean&nbsp;conjB)</code>
<div class="block">Performs the per-element multiplication of two Fourier spectrums.</div>
</td>
</tr>
<tr id="i127" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#multiply-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">multiply</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Calculates the per-element scaled product of two arrays.</div>
</td>
</tr>
<tr id="i128" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#multiply-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">multiply</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;scale)</code>
<div class="block">Calculates the per-element scaled product of two arrays.</div>
</td>
</tr>
<tr id="i129" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#multiply-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-int-">multiply</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;scale,
        int&nbsp;dtype)</code>
<div class="block">Calculates the per-element scaled product of two arrays.</div>
</td>
</tr>
<tr id="i130" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#multiply-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-">multiply</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>&nbsp;</td>
</tr>
<tr id="i131" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#multiply-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-double-">multiply</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;scale)</code>&nbsp;</td>
</tr>
<tr id="i132" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#multiply-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-double-int-">multiply</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        double&nbsp;scale,
        int&nbsp;dtype)</code>&nbsp;</td>
</tr>
<tr id="i133" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#mulTransposed-org.opencv.core.Mat-org.opencv.core.Mat-boolean-">mulTransposed</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             boolean&nbsp;aTa)</code>
<div class="block">Calculates the product of a matrix and its transposition.</div>
</td>
</tr>
<tr id="i134" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#mulTransposed-org.opencv.core.Mat-org.opencv.core.Mat-boolean-org.opencv.core.Mat-">mulTransposed</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             boolean&nbsp;aTa,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;delta)</code>
<div class="block">Calculates the product of a matrix and its transposition.</div>
</td>
</tr>
<tr id="i135" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#mulTransposed-org.opencv.core.Mat-org.opencv.core.Mat-boolean-org.opencv.core.Mat-double-">mulTransposed</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             boolean&nbsp;aTa,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;delta,
             double&nbsp;scale)</code>
<div class="block">Calculates the product of a matrix and its transposition.</div>
</td>
</tr>
<tr id="i136" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#mulTransposed-org.opencv.core.Mat-org.opencv.core.Mat-boolean-org.opencv.core.Mat-double-int-">mulTransposed</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
             boolean&nbsp;aTa,
             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;delta,
             double&nbsp;scale,
             int&nbsp;dtype)</code>
<div class="block">Calculates the product of a matrix and its transposition.</div>
</td>
</tr>
<tr id="i137" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#norm-org.opencv.core.Mat-">norm</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1)</code>
<div class="block">Calculates the  absolute norm of an array.</div>
</td>
</tr>
<tr id="i138" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#norm-org.opencv.core.Mat-int-">norm</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
    int&nbsp;normType)</code>
<div class="block">Calculates the  absolute norm of an array.</div>
</td>
</tr>
<tr id="i139" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#norm-org.opencv.core.Mat-int-org.opencv.core.Mat-">norm</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
    int&nbsp;normType,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Calculates the  absolute norm of an array.</div>
</td>
</tr>
<tr id="i140" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#norm-org.opencv.core.Mat-org.opencv.core.Mat-">norm</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2)</code>
<div class="block">Calculates an absolute difference norm or a relative difference norm.</div>
</td>
</tr>
<tr id="i141" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#norm-org.opencv.core.Mat-org.opencv.core.Mat-int-">norm</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
    int&nbsp;normType)</code>
<div class="block">Calculates an absolute difference norm or a relative difference norm.</div>
</td>
</tr>
<tr id="i142" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#norm-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-">norm</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
    int&nbsp;normType,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Calculates an absolute difference norm or a relative difference norm.</div>
</td>
</tr>
<tr id="i143" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#normalize-org.opencv.core.Mat-org.opencv.core.Mat-">normalize</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Normalizes the norm or value range of an array.</div>
</td>
</tr>
<tr id="i144" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#normalize-org.opencv.core.Mat-org.opencv.core.Mat-double-">normalize</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         double&nbsp;alpha)</code>
<div class="block">Normalizes the norm or value range of an array.</div>
</td>
</tr>
<tr id="i145" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#normalize-org.opencv.core.Mat-org.opencv.core.Mat-double-double-">normalize</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         double&nbsp;alpha,
         double&nbsp;beta)</code>
<div class="block">Normalizes the norm or value range of an array.</div>
</td>
</tr>
<tr id="i146" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#normalize-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-">normalize</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         double&nbsp;alpha,
         double&nbsp;beta,
         int&nbsp;norm_type)</code>
<div class="block">Normalizes the norm or value range of an array.</div>
</td>
</tr>
<tr id="i147" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#normalize-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-int-">normalize</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         double&nbsp;alpha,
         double&nbsp;beta,
         int&nbsp;norm_type,
         int&nbsp;dtype)</code>
<div class="block">Normalizes the norm or value range of an array.</div>
</td>
</tr>
<tr id="i148" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#normalize-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-int-org.opencv.core.Mat-">normalize</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         double&nbsp;alpha,
         double&nbsp;beta,
         int&nbsp;norm_type,
         int&nbsp;dtype,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Normalizes the norm or value range of an array.</div>
</td>
</tr>
<tr id="i149" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#patchNaNs-org.opencv.core.Mat-">patchNaNs</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a)</code>
<div class="block">Replaces NaNs by given number</div>
</td>
</tr>
<tr id="i150" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#patchNaNs-org.opencv.core.Mat-double-">patchNaNs</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
         double&nbsp;val)</code>
<div class="block">Replaces NaNs by given number</div>
</td>
</tr>
<tr id="i151" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#PCABackProject-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">PCABackProject</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;result)</code>
<div class="block">wrap PCA::backProject</div>
</td>
</tr>
<tr id="i152" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#PCACompute-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">PCACompute</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors)</code>
<div class="block">wrap PCA::operator()</div>
</td>
</tr>
<tr id="i153" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#PCACompute-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">PCACompute</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
          double&nbsp;retainedVariance)</code>
<div class="block">wrap PCA::operator()</div>
</td>
</tr>
<tr id="i154" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#PCACompute-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">PCACompute</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
          int&nbsp;maxComponents)</code>
<div class="block">wrap PCA::operator()</div>
</td>
</tr>
<tr id="i155" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#PCACompute2-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">PCACompute2</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvalues)</code>
<div class="block">wrap PCA::operator() and add eigenvalues output parameter</div>
</td>
</tr>
<tr id="i156" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#PCACompute2-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">PCACompute2</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvalues,
           double&nbsp;retainedVariance)</code>
<div class="block">wrap PCA::operator() and add eigenvalues output parameter</div>
</td>
</tr>
<tr id="i157" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#PCACompute2-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">PCACompute2</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvalues,
           int&nbsp;maxComponents)</code>
<div class="block">wrap PCA::operator() and add eigenvalues output parameter</div>
</td>
</tr>
<tr id="i158" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#PCAProject-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">PCAProject</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;result)</code>
<div class="block">wrap PCA::project</div>
</td>
</tr>
<tr id="i159" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#perspectiveTransform-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">perspectiveTransform</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m)</code>
<div class="block">Performs the perspective matrix transformation of vectors.</div>
</td>
</tr>
<tr id="i160" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#phase-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">phase</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle)</code>
<div class="block">Calculates the rotation angle of 2D vectors.</div>
</td>
</tr>
<tr id="i161" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#phase-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-boolean-">phase</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle,
     boolean&nbsp;angleInDegrees)</code>
<div class="block">Calculates the rotation angle of 2D vectors.</div>
</td>
</tr>
<tr id="i162" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#polarToCart-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">polarToCart</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y)</code>
<div class="block">Calculates x and y coordinates of 2D vectors from their magnitude and angle.</div>
</td>
</tr>
<tr id="i163" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#polarToCart-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-boolean-">polarToCart</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
           boolean&nbsp;angleInDegrees)</code>
<div class="block">Calculates x and y coordinates of 2D vectors from their magnitude and angle.</div>
</td>
</tr>
<tr id="i164" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#pow-org.opencv.core.Mat-double-org.opencv.core.Mat-">pow</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
   double&nbsp;power,
   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Raises every array element to a power.</div>
</td>
</tr>
<tr id="i165" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#PSNR-org.opencv.core.Mat-org.opencv.core.Mat-">PSNR</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2)</code>
<div class="block">Computes the Peak Signal-to-Noise Ratio (PSNR) image quality metric.</div>
</td>
</tr>
<tr id="i166" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#PSNR-org.opencv.core.Mat-org.opencv.core.Mat-double-">PSNR</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
    double&nbsp;R)</code>
<div class="block">Computes the Peak Signal-to-Noise Ratio (PSNR) image quality metric.</div>
</td>
</tr>
<tr id="i167" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#randn-org.opencv.core.Mat-double-double-">randn</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     double&nbsp;mean,
     double&nbsp;stddev)</code>
<div class="block">Fills the array with normally distributed random numbers.</div>
</td>
</tr>
<tr id="i168" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#randShuffle-org.opencv.core.Mat-">randShuffle</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Shuffles the array elements randomly.</div>
</td>
</tr>
<tr id="i169" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#randShuffle-org.opencv.core.Mat-double-">randShuffle</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
           double&nbsp;iterFactor)</code>
<div class="block">Shuffles the array elements randomly.</div>
</td>
</tr>
<tr id="i170" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#randu-org.opencv.core.Mat-double-double-">randu</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     double&nbsp;low,
     double&nbsp;high)</code>
<div class="block">Generates a single uniformly-distributed random number or an array of random numbers.</div>
</td>
</tr>
<tr id="i171" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#reduce-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">reduce</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      int&nbsp;dim,
      int&nbsp;rtype)</code>
<div class="block">Reduces a matrix to a vector.</div>
</td>
</tr>
<tr id="i172" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#reduce-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">reduce</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      int&nbsp;dim,
      int&nbsp;rtype,
      int&nbsp;dtype)</code>
<div class="block">Reduces a matrix to a vector.</div>
</td>
</tr>
<tr id="i173" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#reduceArgMax-org.opencv.core.Mat-org.opencv.core.Mat-int-">reduceArgMax</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;axis)</code>
<div class="block">Finds indices of max elements along provided axis

 <b>Note:</b>
 - If input or output array is not continuous, this function will create an internal copy.</div>
</td>
</tr>
<tr id="i174" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#reduceArgMax-org.opencv.core.Mat-org.opencv.core.Mat-int-boolean-">reduceArgMax</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;axis,
            boolean&nbsp;lastIndex)</code>
<div class="block">Finds indices of max elements along provided axis

 <b>Note:</b>
 - If input or output array is not continuous, this function will create an internal copy.</div>
</td>
</tr>
<tr id="i175" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#reduceArgMin-org.opencv.core.Mat-org.opencv.core.Mat-int-">reduceArgMin</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;axis)</code>
<div class="block">Finds indices of min elements along provided axis

 <b>Note:</b>
 - If input or output array is not continuous, this function will create an internal copy.</div>
</td>
</tr>
<tr id="i176" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#reduceArgMin-org.opencv.core.Mat-org.opencv.core.Mat-int-boolean-">reduceArgMin</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
            int&nbsp;axis,
            boolean&nbsp;lastIndex)</code>
<div class="block">Finds indices of min elements along provided axis

 <b>Note:</b>
 - If input or output array is not continuous, this function will create an internal copy.</div>
</td>
</tr>
<tr id="i177" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#repeat-org.opencv.core.Mat-int-int-org.opencv.core.Mat-">repeat</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      int&nbsp;ny,
      int&nbsp;nx,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Fills the output array with repeated copies of the input array.</div>
</td>
</tr>
<tr id="i178" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#rotate-org.opencv.core.Mat-org.opencv.core.Mat-int-">rotate</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
      <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
      int&nbsp;rotateCode)</code>
<div class="block">Rotates a 2D array in multiples of 90 degrees.</div>
</td>
</tr>
<tr id="i179" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#scaleAdd-org.opencv.core.Mat-double-org.opencv.core.Mat-org.opencv.core.Mat-">scaleAdd</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        double&nbsp;alpha,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Calculates the sum of a scaled array and another array.</div>
</td>
</tr>
<tr id="i180" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#setErrorVerbosity-boolean-">setErrorVerbosity</a></span>(boolean&nbsp;verbose)</code>&nbsp;</td>
</tr>
<tr id="i181" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#setIdentity-org.opencv.core.Mat-">setIdentity</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtx)</code>
<div class="block">Initializes a scaled identity matrix.</div>
</td>
</tr>
<tr id="i182" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#setIdentity-org.opencv.core.Mat-org.opencv.core.Scalar-">setIdentity</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtx,
           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;s)</code>
<div class="block">Initializes a scaled identity matrix.</div>
</td>
</tr>
<tr id="i183" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#setNumThreads-int-">setNumThreads</a></span>(int&nbsp;nthreads)</code>
<div class="block">OpenCV will try to set the number of threads for subsequent parallel regions.</div>
</td>
</tr>
<tr id="i184" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#setRNGSeed-int-">setRNGSeed</a></span>(int&nbsp;seed)</code>
<div class="block">Sets state of default random number generator.</div>
</td>
</tr>
<tr id="i185" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#setUseIPP_NotExact-boolean-">setUseIPP_NotExact</a></span>(boolean&nbsp;flag)</code>&nbsp;</td>
</tr>
<tr id="i186" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#setUseIPP-boolean-">setUseIPP</a></span>(boolean&nbsp;flag)</code>&nbsp;</td>
</tr>
<tr id="i187" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#setUseOptimized-boolean-">setUseOptimized</a></span>(boolean&nbsp;onoff)</code>
<div class="block">Enables or disables the optimized code.</div>
</td>
</tr>
<tr id="i188" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#solve-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">solve</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Solves one or more linear systems or least-squares problems.</div>
</td>
</tr>
<tr id="i189" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#solve-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">solve</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
     int&nbsp;flags)</code>
<div class="block">Solves one or more linear systems or least-squares problems.</div>
</td>
</tr>
<tr id="i190" class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#solveCubic-org.opencv.core.Mat-org.opencv.core.Mat-">solveCubic</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;coeffs,
          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;roots)</code>
<div class="block">Finds the real roots of a cubic equation.</div>
</td>
</tr>
<tr id="i191" class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#solvePoly-org.opencv.core.Mat-org.opencv.core.Mat-">solvePoly</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;coeffs,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;roots)</code>
<div class="block">Finds the real or complex roots of a polynomial equation.</div>
</td>
</tr>
<tr id="i192" class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#solvePoly-org.opencv.core.Mat-org.opencv.core.Mat-int-">solvePoly</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;coeffs,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;roots,
         int&nbsp;maxIters)</code>
<div class="block">Finds the real or complex roots of a polynomial equation.</div>
</td>
</tr>
<tr id="i193" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#sort-org.opencv.core.Mat-org.opencv.core.Mat-int-">sort</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
    int&nbsp;flags)</code>
<div class="block">Sorts each row or each column of a matrix.</div>
</td>
</tr>
<tr id="i194" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#sortIdx-org.opencv.core.Mat-org.opencv.core.Mat-int-">sortIdx</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
       int&nbsp;flags)</code>
<div class="block">Sorts each row or each column of a matrix.</div>
</td>
</tr>
<tr id="i195" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#split-org.opencv.core.Mat-java.util.List-">split</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
     <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</a>&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;mv)</code>&nbsp;</td>
</tr>
<tr id="i196" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#sqrt-org.opencv.core.Mat-org.opencv.core.Mat-">sqrt</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
    <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Calculates a square root of array elements.</div>
</td>
</tr>
<tr id="i197" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#subtract-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">subtract</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Calculates the per-element difference between two arrays or array and a scalar.</div>
</td>
</tr>
<tr id="i198" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#subtract-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">subtract</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>
<div class="block">Calculates the per-element difference between two arrays or array and a scalar.</div>
</td>
</tr>
<tr id="i199" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#subtract-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">subtract</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
        int&nbsp;dtype)</code>
<div class="block">Calculates the per-element difference between two arrays or array and a scalar.</div>
</td>
</tr>
<tr id="i200" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#subtract-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-">subtract</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>&nbsp;</td>
</tr>
<tr id="i201" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#subtract-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-org.opencv.core.Mat-">subtract</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</code>&nbsp;</td>
</tr>
<tr id="i202" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#subtract-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-org.opencv.core.Mat-int-">subtract</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
        <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
        int&nbsp;dtype)</code>&nbsp;</td>
</tr>
<tr id="i203" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#sumElems-org.opencv.core.Mat-">sumElems</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src)</code>
<div class="block">Calculates the sum of array elements.</div>
</td>
</tr>
<tr id="i204" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#SVBackSubst-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">SVBackSubst</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;w,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;u,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vt,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rhs,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">wrap SVD::backSubst</div>
</td>
</tr>
<tr id="i205" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#SVDecomp-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">SVDecomp</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;w,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;u,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vt)</code>
<div class="block">wrap SVD::compute</div>
</td>
</tr>
<tr id="i206" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#SVDecomp-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">SVDecomp</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;w,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;u,
        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vt,
        int&nbsp;flags)</code>
<div class="block">wrap SVD::compute</div>
</td>
</tr>
<tr id="i207" class="rowColor">
<td class="colFirst"><code>static <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#trace-org.opencv.core.Mat-">trace</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtx)</code>
<div class="block">Returns the trace of a matrix.</div>
</td>
</tr>
<tr id="i208" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#transform-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">transform</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m)</code>
<div class="block">Performs the matrix transformation of every array element.</div>
</td>
</tr>
<tr id="i209" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#transpose-org.opencv.core.Mat-org.opencv.core.Mat-">transpose</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Transposes a matrix.</div>
</td>
</tr>
<tr id="i210" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#transposeND-org.opencv.core.Mat-org.opencv.core.MatOfInt-org.opencv.core.Mat-">transposeND</a></span>(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
           <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;order,
           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block">Transpose for n-dimensional matrices.</div>
</td>
</tr>
<tr id="i211" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#useIPP_NotExact--">useIPP_NotExact</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i212" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#useIPP--">useIPP</a></span>()</code>
<div class="block">proxy for hal::Cholesky</div>
</td>
</tr>
<tr id="i213" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#useOptimized--">useOptimized</a></span>()</code>
<div class="block">Returns the status of optimized code usage.</div>
</td>
</tr>
<tr id="i214" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../org/opencv/core/Core.html#vconcat-java.util.List-org.opencv.core.Mat-">vconcat</a></span>(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</a>&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;src,
       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</code>
<div class="block"><code>
     std::vector&lt;cv::Mat&gt; matrices = { cv::Mat(1, 4, CV_8UC1, cv::Scalar(1)),
                                       cv::Mat(1, 4, CV_8UC1, cv::Scalar(2)),
                                       cv::Mat(1, 4, CV_8UC1, cv::Scalar(3)),};

     cv::Mat out;
     cv::vconcat( matrices, out );
     //out:
     //[1,   1,   1,   1;
     // 2,   2,   2,   2;
     // 3,   3,   3,   3]
  </code></div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></h3>
<code><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#clone--" title="class or interface in java.lang">clone</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#equals-java.lang.Object-" title="class or interface in java.lang">equals</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#finalize--" title="class or interface in java.lang">finalize</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#getClass--" title="class or interface in java.lang">getClass</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#hashCode--" title="class or interface in java.lang">hashCode</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#notify--" title="class or interface in java.lang">notify</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#notifyAll--" title="class or interface in java.lang">notifyAll</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#toString--" title="class or interface in java.lang">toString</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#wait--" title="class or interface in java.lang">wait</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#wait-long-" title="class or interface in java.lang">wait</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#wait-long-int-" title="class or interface in java.lang">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="VERSION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VERSION</h4>
<pre>public static final&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a> VERSION</pre>
</li>
</ul>
<a name="NATIVE_LIBRARY_NAME">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NATIVE_LIBRARY_NAME</h4>
<pre>public static final&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a> NATIVE_LIBRARY_NAME</pre>
</li>
</ul>
<a name="VERSION_MAJOR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VERSION_MAJOR</h4>
<pre>public static final&nbsp;int VERSION_MAJOR</pre>
</li>
</ul>
<a name="VERSION_MINOR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VERSION_MINOR</h4>
<pre>public static final&nbsp;int VERSION_MINOR</pre>
</li>
</ul>
<a name="VERSION_REVISION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VERSION_REVISION</h4>
<pre>public static final&nbsp;int VERSION_REVISION</pre>
</li>
</ul>
<a name="VERSION_STATUS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VERSION_STATUS</h4>
<pre>public static final&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a> VERSION_STATUS</pre>
</li>
</ul>
<a name="SVD_MODIFY_A">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SVD_MODIFY_A</h4>
<pre>public static final&nbsp;int SVD_MODIFY_A</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.SVD_MODIFY_A">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SVD_NO_UV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SVD_NO_UV</h4>
<pre>public static final&nbsp;int SVD_NO_UV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.SVD_NO_UV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SVD_FULL_UV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SVD_FULL_UV</h4>
<pre>public static final&nbsp;int SVD_FULL_UV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.SVD_FULL_UV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="FILLED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FILLED</h4>
<pre>public static final&nbsp;int FILLED</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.FILLED">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="REDUCE_SUM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>REDUCE_SUM</h4>
<pre>public static final&nbsp;int REDUCE_SUM</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.REDUCE_SUM">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="REDUCE_AVG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>REDUCE_AVG</h4>
<pre>public static final&nbsp;int REDUCE_AVG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.REDUCE_AVG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="REDUCE_MAX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>REDUCE_MAX</h4>
<pre>public static final&nbsp;int REDUCE_MAX</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.REDUCE_MAX">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="REDUCE_MIN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>REDUCE_MIN</h4>
<pre>public static final&nbsp;int REDUCE_MIN</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.REDUCE_MIN">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RNG_UNIFORM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RNG_UNIFORM</h4>
<pre>public static final&nbsp;int RNG_UNIFORM</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.RNG_UNIFORM">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="RNG_NORMAL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RNG_NORMAL</h4>
<pre>public static final&nbsp;int RNG_NORMAL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.RNG_NORMAL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="ALGO_HINT_DEFAULT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ALGO_HINT_DEFAULT</h4>
<pre>public static final&nbsp;int ALGO_HINT_DEFAULT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.ALGO_HINT_DEFAULT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="ALGO_HINT_ACCURATE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ALGO_HINT_ACCURATE</h4>
<pre>public static final&nbsp;int ALGO_HINT_ACCURATE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.ALGO_HINT_ACCURATE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="ALGO_HINT_APPROX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ALGO_HINT_APPROX</h4>
<pre>public static final&nbsp;int ALGO_HINT_APPROX</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.ALGO_HINT_APPROX">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BORDER_CONSTANT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BORDER_CONSTANT</h4>
<pre>public static final&nbsp;int BORDER_CONSTANT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BORDER_CONSTANT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BORDER_REPLICATE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BORDER_REPLICATE</h4>
<pre>public static final&nbsp;int BORDER_REPLICATE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BORDER_REPLICATE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BORDER_REFLECT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BORDER_REFLECT</h4>
<pre>public static final&nbsp;int BORDER_REFLECT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BORDER_REFLECT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BORDER_WRAP">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BORDER_WRAP</h4>
<pre>public static final&nbsp;int BORDER_WRAP</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BORDER_WRAP">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BORDER_REFLECT_101">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BORDER_REFLECT_101</h4>
<pre>public static final&nbsp;int BORDER_REFLECT_101</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BORDER_REFLECT_101">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BORDER_TRANSPARENT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BORDER_TRANSPARENT</h4>
<pre>public static final&nbsp;int BORDER_TRANSPARENT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BORDER_TRANSPARENT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BORDER_REFLECT101">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BORDER_REFLECT101</h4>
<pre>public static final&nbsp;int BORDER_REFLECT101</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BORDER_REFLECT101">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BORDER_DEFAULT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BORDER_DEFAULT</h4>
<pre>public static final&nbsp;int BORDER_DEFAULT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BORDER_DEFAULT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BORDER_ISOLATED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BORDER_ISOLATED</h4>
<pre>public static final&nbsp;int BORDER_ISOLATED</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BORDER_ISOLATED">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CMP_EQ">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CMP_EQ</h4>
<pre>public static final&nbsp;int CMP_EQ</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.CMP_EQ">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CMP_GT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CMP_GT</h4>
<pre>public static final&nbsp;int CMP_GT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.CMP_GT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CMP_GE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CMP_GE</h4>
<pre>public static final&nbsp;int CMP_GE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.CMP_GE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CMP_LT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CMP_LT</h4>
<pre>public static final&nbsp;int CMP_LT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.CMP_LT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CMP_LE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CMP_LE</h4>
<pre>public static final&nbsp;int CMP_LE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.CMP_LE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="CMP_NE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CMP_NE</h4>
<pre>public static final&nbsp;int CMP_NE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.CMP_NE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COVAR_SCRAMBLED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COVAR_SCRAMBLED</h4>
<pre>public static final&nbsp;int COVAR_SCRAMBLED</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.COVAR_SCRAMBLED">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COVAR_NORMAL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COVAR_NORMAL</h4>
<pre>public static final&nbsp;int COVAR_NORMAL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.COVAR_NORMAL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COVAR_USE_AVG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COVAR_USE_AVG</h4>
<pre>public static final&nbsp;int COVAR_USE_AVG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.COVAR_USE_AVG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COVAR_SCALE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COVAR_SCALE</h4>
<pre>public static final&nbsp;int COVAR_SCALE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.COVAR_SCALE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COVAR_ROWS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COVAR_ROWS</h4>
<pre>public static final&nbsp;int COVAR_ROWS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.COVAR_ROWS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="COVAR_COLS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>COVAR_COLS</h4>
<pre>public static final&nbsp;int COVAR_COLS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.COVAR_COLS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DECOMP_LU">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DECOMP_LU</h4>
<pre>public static final&nbsp;int DECOMP_LU</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.DECOMP_LU">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DECOMP_SVD">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DECOMP_SVD</h4>
<pre>public static final&nbsp;int DECOMP_SVD</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.DECOMP_SVD">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DECOMP_EIG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DECOMP_EIG</h4>
<pre>public static final&nbsp;int DECOMP_EIG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.DECOMP_EIG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DECOMP_CHOLESKY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DECOMP_CHOLESKY</h4>
<pre>public static final&nbsp;int DECOMP_CHOLESKY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.DECOMP_CHOLESKY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DECOMP_QR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DECOMP_QR</h4>
<pre>public static final&nbsp;int DECOMP_QR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.DECOMP_QR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DECOMP_NORMAL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DECOMP_NORMAL</h4>
<pre>public static final&nbsp;int DECOMP_NORMAL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.DECOMP_NORMAL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DFT_INVERSE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DFT_INVERSE</h4>
<pre>public static final&nbsp;int DFT_INVERSE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.DFT_INVERSE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DFT_SCALE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DFT_SCALE</h4>
<pre>public static final&nbsp;int DFT_SCALE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.DFT_SCALE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DFT_ROWS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DFT_ROWS</h4>
<pre>public static final&nbsp;int DFT_ROWS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.DFT_ROWS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DFT_COMPLEX_OUTPUT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DFT_COMPLEX_OUTPUT</h4>
<pre>public static final&nbsp;int DFT_COMPLEX_OUTPUT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.DFT_COMPLEX_OUTPUT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DFT_REAL_OUTPUT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DFT_REAL_OUTPUT</h4>
<pre>public static final&nbsp;int DFT_REAL_OUTPUT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.DFT_REAL_OUTPUT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DFT_COMPLEX_INPUT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DFT_COMPLEX_INPUT</h4>
<pre>public static final&nbsp;int DFT_COMPLEX_INPUT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.DFT_COMPLEX_INPUT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DCT_INVERSE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DCT_INVERSE</h4>
<pre>public static final&nbsp;int DCT_INVERSE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.DCT_INVERSE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="DCT_ROWS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DCT_ROWS</h4>
<pre>public static final&nbsp;int DCT_ROWS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.DCT_ROWS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsOk">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsOk</h4>
<pre>public static final&nbsp;int StsOk</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsOk">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsBackTrace">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsBackTrace</h4>
<pre>public static final&nbsp;int StsBackTrace</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsBackTrace">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsError">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsError</h4>
<pre>public static final&nbsp;int StsError</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsError">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsInternal">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsInternal</h4>
<pre>public static final&nbsp;int StsInternal</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsInternal">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsNoMem">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsNoMem</h4>
<pre>public static final&nbsp;int StsNoMem</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsNoMem">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsBadArg">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsBadArg</h4>
<pre>public static final&nbsp;int StsBadArg</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsBadArg">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsBadFunc">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsBadFunc</h4>
<pre>public static final&nbsp;int StsBadFunc</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsBadFunc">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsNoConv">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsNoConv</h4>
<pre>public static final&nbsp;int StsNoConv</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsNoConv">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsAutoTrace">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsAutoTrace</h4>
<pre>public static final&nbsp;int StsAutoTrace</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsAutoTrace">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="HeaderIsNull">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>HeaderIsNull</h4>
<pre>public static final&nbsp;int HeaderIsNull</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.HeaderIsNull">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BadImageSize">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BadImageSize</h4>
<pre>public static final&nbsp;int BadImageSize</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BadImageSize">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BadOffset">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BadOffset</h4>
<pre>public static final&nbsp;int BadOffset</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BadOffset">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BadDataPtr">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BadDataPtr</h4>
<pre>public static final&nbsp;int BadDataPtr</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BadDataPtr">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BadStep">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BadStep</h4>
<pre>public static final&nbsp;int BadStep</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BadStep">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BadModelOrChSeq">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BadModelOrChSeq</h4>
<pre>public static final&nbsp;int BadModelOrChSeq</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BadModelOrChSeq">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BadNumChannels">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BadNumChannels</h4>
<pre>public static final&nbsp;int BadNumChannels</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BadNumChannels">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BadNumChannel1U">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BadNumChannel1U</h4>
<pre>public static final&nbsp;int BadNumChannel1U</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BadNumChannel1U">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BadDepth">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BadDepth</h4>
<pre>public static final&nbsp;int BadDepth</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BadDepth">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BadAlphaChannel">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BadAlphaChannel</h4>
<pre>public static final&nbsp;int BadAlphaChannel</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BadAlphaChannel">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BadOrder">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BadOrder</h4>
<pre>public static final&nbsp;int BadOrder</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BadOrder">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BadOrigin">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BadOrigin</h4>
<pre>public static final&nbsp;int BadOrigin</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BadOrigin">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BadAlign">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BadAlign</h4>
<pre>public static final&nbsp;int BadAlign</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BadAlign">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BadCallBack">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BadCallBack</h4>
<pre>public static final&nbsp;int BadCallBack</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BadCallBack">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BadTileSize">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BadTileSize</h4>
<pre>public static final&nbsp;int BadTileSize</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BadTileSize">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BadCOI">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BadCOI</h4>
<pre>public static final&nbsp;int BadCOI</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BadCOI">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="BadROISize">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BadROISize</h4>
<pre>public static final&nbsp;int BadROISize</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.BadROISize">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="MaskIsTiled">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MaskIsTiled</h4>
<pre>public static final&nbsp;int MaskIsTiled</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.MaskIsTiled">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsNullPtr">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsNullPtr</h4>
<pre>public static final&nbsp;int StsNullPtr</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsNullPtr">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsVecLengthErr">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsVecLengthErr</h4>
<pre>public static final&nbsp;int StsVecLengthErr</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsVecLengthErr">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsFilterStructContentErr">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsFilterStructContentErr</h4>
<pre>public static final&nbsp;int StsFilterStructContentErr</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsFilterStructContentErr">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsKernelStructContentErr">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsKernelStructContentErr</h4>
<pre>public static final&nbsp;int StsKernelStructContentErr</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsKernelStructContentErr">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsFilterOffsetErr">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsFilterOffsetErr</h4>
<pre>public static final&nbsp;int StsFilterOffsetErr</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsFilterOffsetErr">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsBadSize">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsBadSize</h4>
<pre>public static final&nbsp;int StsBadSize</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsBadSize">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsDivByZero">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsDivByZero</h4>
<pre>public static final&nbsp;int StsDivByZero</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsDivByZero">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsInplaceNotSupported">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsInplaceNotSupported</h4>
<pre>public static final&nbsp;int StsInplaceNotSupported</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsInplaceNotSupported">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsObjectNotFound">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsObjectNotFound</h4>
<pre>public static final&nbsp;int StsObjectNotFound</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsObjectNotFound">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsUnmatchedFormats">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsUnmatchedFormats</h4>
<pre>public static final&nbsp;int StsUnmatchedFormats</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsUnmatchedFormats">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsBadFlag">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsBadFlag</h4>
<pre>public static final&nbsp;int StsBadFlag</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsBadFlag">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsBadPoint">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsBadPoint</h4>
<pre>public static final&nbsp;int StsBadPoint</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsBadPoint">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsBadMask">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsBadMask</h4>
<pre>public static final&nbsp;int StsBadMask</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsBadMask">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsUnmatchedSizes">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsUnmatchedSizes</h4>
<pre>public static final&nbsp;int StsUnmatchedSizes</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsUnmatchedSizes">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsUnsupportedFormat">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsUnsupportedFormat</h4>
<pre>public static final&nbsp;int StsUnsupportedFormat</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsUnsupportedFormat">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsOutOfRange">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsOutOfRange</h4>
<pre>public static final&nbsp;int StsOutOfRange</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsOutOfRange">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsParseError">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsParseError</h4>
<pre>public static final&nbsp;int StsParseError</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsParseError">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsNotImplemented">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsNotImplemented</h4>
<pre>public static final&nbsp;int StsNotImplemented</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsNotImplemented">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsBadMemBlock">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsBadMemBlock</h4>
<pre>public static final&nbsp;int StsBadMemBlock</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsBadMemBlock">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="StsAssert">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>StsAssert</h4>
<pre>public static final&nbsp;int StsAssert</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.StsAssert">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="GpuNotSupported">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GpuNotSupported</h4>
<pre>public static final&nbsp;int GpuNotSupported</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.GpuNotSupported">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="GpuApiCallError">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GpuApiCallError</h4>
<pre>public static final&nbsp;int GpuApiCallError</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.GpuApiCallError">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="OpenGlNotSupported">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>OpenGlNotSupported</h4>
<pre>public static final&nbsp;int OpenGlNotSupported</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.OpenGlNotSupported">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="OpenGlApiCallError">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>OpenGlApiCallError</h4>
<pre>public static final&nbsp;int OpenGlApiCallError</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.OpenGlApiCallError">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="OpenCLApiCallError">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>OpenCLApiCallError</h4>
<pre>public static final&nbsp;int OpenCLApiCallError</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.OpenCLApiCallError">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="OpenCLDoubleNotSupported">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>OpenCLDoubleNotSupported</h4>
<pre>public static final&nbsp;int OpenCLDoubleNotSupported</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.OpenCLDoubleNotSupported">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="OpenCLInitError">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>OpenCLInitError</h4>
<pre>public static final&nbsp;int OpenCLInitError</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.OpenCLInitError">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="OpenCLNoAMDBlasFft">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>OpenCLNoAMDBlasFft</h4>
<pre>public static final&nbsp;int OpenCLNoAMDBlasFft</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.OpenCLNoAMDBlasFft">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Formatter_FMT_DEFAULT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Formatter_FMT_DEFAULT</h4>
<pre>public static final&nbsp;int Formatter_FMT_DEFAULT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Formatter_FMT_DEFAULT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Formatter_FMT_MATLAB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Formatter_FMT_MATLAB</h4>
<pre>public static final&nbsp;int Formatter_FMT_MATLAB</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Formatter_FMT_MATLAB">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Formatter_FMT_CSV">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Formatter_FMT_CSV</h4>
<pre>public static final&nbsp;int Formatter_FMT_CSV</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Formatter_FMT_CSV">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Formatter_FMT_PYTHON">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Formatter_FMT_PYTHON</h4>
<pre>public static final&nbsp;int Formatter_FMT_PYTHON</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Formatter_FMT_PYTHON">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Formatter_FMT_NUMPY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Formatter_FMT_NUMPY</h4>
<pre>public static final&nbsp;int Formatter_FMT_NUMPY</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Formatter_FMT_NUMPY">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Formatter_FMT_C">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Formatter_FMT_C</h4>
<pre>public static final&nbsp;int Formatter_FMT_C</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Formatter_FMT_C">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="GEMM_1_T">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GEMM_1_T</h4>
<pre>public static final&nbsp;int GEMM_1_T</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.GEMM_1_T">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="GEMM_2_T">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GEMM_2_T</h4>
<pre>public static final&nbsp;int GEMM_2_T</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.GEMM_2_T">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="GEMM_3_T">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GEMM_3_T</h4>
<pre>public static final&nbsp;int GEMM_3_T</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.GEMM_3_T">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="KMEANS_RANDOM_CENTERS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>KMEANS_RANDOM_CENTERS</h4>
<pre>public static final&nbsp;int KMEANS_RANDOM_CENTERS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.KMEANS_RANDOM_CENTERS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="KMEANS_PP_CENTERS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>KMEANS_PP_CENTERS</h4>
<pre>public static final&nbsp;int KMEANS_PP_CENTERS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.KMEANS_PP_CENTERS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="KMEANS_USE_INITIAL_LABELS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>KMEANS_USE_INITIAL_LABELS</h4>
<pre>public static final&nbsp;int KMEANS_USE_INITIAL_LABELS</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.KMEANS_USE_INITIAL_LABELS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="NORM_INF">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NORM_INF</h4>
<pre>public static final&nbsp;int NORM_INF</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_INF">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="NORM_L1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NORM_L1</h4>
<pre>public static final&nbsp;int NORM_L1</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_L1">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="NORM_L2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NORM_L2</h4>
<pre>public static final&nbsp;int NORM_L2</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_L2">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="NORM_L2SQR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NORM_L2SQR</h4>
<pre>public static final&nbsp;int NORM_L2SQR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_L2SQR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="NORM_HAMMING">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NORM_HAMMING</h4>
<pre>public static final&nbsp;int NORM_HAMMING</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_HAMMING">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="NORM_HAMMING2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NORM_HAMMING2</h4>
<pre>public static final&nbsp;int NORM_HAMMING2</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_HAMMING2">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="NORM_TYPE_MASK">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NORM_TYPE_MASK</h4>
<pre>public static final&nbsp;int NORM_TYPE_MASK</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_TYPE_MASK">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="NORM_RELATIVE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NORM_RELATIVE</h4>
<pre>public static final&nbsp;int NORM_RELATIVE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_RELATIVE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="NORM_MINMAX">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NORM_MINMAX</h4>
<pre>public static final&nbsp;int NORM_MINMAX</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.NORM_MINMAX">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="PCA_DATA_AS_ROW">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PCA_DATA_AS_ROW</h4>
<pre>public static final&nbsp;int PCA_DATA_AS_ROW</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.PCA_DATA_AS_ROW">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="PCA_DATA_AS_COL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PCA_DATA_AS_COL</h4>
<pre>public static final&nbsp;int PCA_DATA_AS_COL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.PCA_DATA_AS_COL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="PCA_USE_AVG">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PCA_USE_AVG</h4>
<pre>public static final&nbsp;int PCA_USE_AVG</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.PCA_USE_AVG">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Param_INT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Param_INT</h4>
<pre>public static final&nbsp;int Param_INT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Param_INT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Param_BOOLEAN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Param_BOOLEAN</h4>
<pre>public static final&nbsp;int Param_BOOLEAN</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Param_BOOLEAN">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Param_REAL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Param_REAL</h4>
<pre>public static final&nbsp;int Param_REAL</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Param_REAL">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Param_STRING">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Param_STRING</h4>
<pre>public static final&nbsp;int Param_STRING</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Param_STRING">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Param_MAT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Param_MAT</h4>
<pre>public static final&nbsp;int Param_MAT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Param_MAT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Param_MAT_VECTOR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Param_MAT_VECTOR</h4>
<pre>public static final&nbsp;int Param_MAT_VECTOR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Param_MAT_VECTOR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Param_ALGORITHM">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Param_ALGORITHM</h4>
<pre>public static final&nbsp;int Param_ALGORITHM</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Param_ALGORITHM">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Param_FLOAT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Param_FLOAT</h4>
<pre>public static final&nbsp;int Param_FLOAT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Param_FLOAT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Param_UNSIGNED_INT">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Param_UNSIGNED_INT</h4>
<pre>public static final&nbsp;int Param_UNSIGNED_INT</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Param_UNSIGNED_INT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Param_UINT64">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Param_UINT64</h4>
<pre>public static final&nbsp;int Param_UINT64</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Param_UINT64">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Param_UCHAR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Param_UCHAR</h4>
<pre>public static final&nbsp;int Param_UCHAR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Param_UCHAR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="Param_SCALAR">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Param_SCALAR</h4>
<pre>public static final&nbsp;int Param_SCALAR</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.Param_SCALAR">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="REDUCE_SUM2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>REDUCE_SUM2</h4>
<pre>public static final&nbsp;int REDUCE_SUM2</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.REDUCE_SUM2">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="ROTATE_90_CLOCKWISE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ROTATE_90_CLOCKWISE</h4>
<pre>public static final&nbsp;int ROTATE_90_CLOCKWISE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.ROTATE_90_CLOCKWISE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="ROTATE_180">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ROTATE_180</h4>
<pre>public static final&nbsp;int ROTATE_180</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.ROTATE_180">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="ROTATE_90_COUNTERCLOCKWISE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ROTATE_90_COUNTERCLOCKWISE</h4>
<pre>public static final&nbsp;int ROTATE_90_COUNTERCLOCKWISE</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.ROTATE_90_COUNTERCLOCKWISE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SORT_EVERY_ROW">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SORT_EVERY_ROW</h4>
<pre>public static final&nbsp;int SORT_EVERY_ROW</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.SORT_EVERY_ROW">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SORT_EVERY_COLUMN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SORT_EVERY_COLUMN</h4>
<pre>public static final&nbsp;int SORT_EVERY_COLUMN</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.SORT_EVERY_COLUMN">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SORT_ASCENDING">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SORT_ASCENDING</h4>
<pre>public static final&nbsp;int SORT_ASCENDING</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.SORT_ASCENDING">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a name="SORT_DESCENDING">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>SORT_DESCENDING</h4>
<pre>public static final&nbsp;int SORT_DESCENDING</pre>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../constant-values.html#org.opencv.core.Core.SORT_DESCENDING">Constant Field Values</a></dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Core--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Core</h4>
<pre>public&nbsp;Core()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="cubeRoot-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cubeRoot</h4>
<pre>public static&nbsp;float&nbsp;cubeRoot(float&nbsp;val)</pre>
<div class="block">Computes the cube root of an argument.

  The function cubeRoot computes \(\sqrt[3]{\texttt{val}}\). Negative arguments are handled correctly.
  NaN and Inf are not handled. The accuracy approaches the maximum possible accuracy for
  single-precision data.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>val</code> - A function argument.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="fastAtan2-float-float-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fastAtan2</h4>
<pre>public static&nbsp;float&nbsp;fastAtan2(float&nbsp;y,
                              float&nbsp;x)</pre>
<div class="block">Calculates the angle of a 2D vector in degrees.

  The function fastAtan2 calculates the full-range angle of an input 2D vector. The angle is measured
  in degrees and varies from 0 to 360 degrees. The accuracy is about 0.3 degrees.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - x-coordinate of the vector.</dd>
<dd><code>y</code> - y-coordinate of the vector.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="useIPP--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>useIPP</h4>
<pre>public static&nbsp;boolean&nbsp;useIPP()</pre>
<div class="block">proxy for hal::Cholesky</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="setUseIPP-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUseIPP</h4>
<pre>public static&nbsp;void&nbsp;setUseIPP(boolean&nbsp;flag)</pre>
</li>
</ul>
<a name="getIppVersion--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getIppVersion</h4>
<pre>public static&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;getIppVersion()</pre>
</li>
</ul>
<a name="useIPP_NotExact--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>useIPP_NotExact</h4>
<pre>public static&nbsp;boolean&nbsp;useIPP_NotExact()</pre>
</li>
</ul>
<a name="setUseIPP_NotExact-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUseIPP_NotExact</h4>
<pre>public static&nbsp;void&nbsp;setUseIPP_NotExact(boolean&nbsp;flag)</pre>
</li>
</ul>
<a name="borderInterpolate-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>borderInterpolate</h4>
<pre>public static&nbsp;int&nbsp;borderInterpolate(int&nbsp;p,
                                    int&nbsp;len,
                                    int&nbsp;borderType)</pre>
<div class="block">Computes the source location of an extrapolated pixel.

 The function computes and returns the coordinate of a donor pixel corresponding to the specified
 extrapolated pixel when using the specified extrapolation border mode. For example, if you use
 cv::BORDER_WRAP mode in the horizontal direction, cv::BORDER_REFLECT_101 in the vertical direction and
 want to compute value of the "virtual" pixel Point(-5, 100) in a floating-point image img, it
 looks like:
 <code>
     float val = img.at&lt;float&gt;(borderInterpolate(100, img.rows, cv::BORDER_REFLECT_101),
                               borderInterpolate(-5, img.cols, cv::BORDER_WRAP));
 </code>
 Normally, the function is not called directly. It is used inside filtering functions and also in
 copyMakeBorder.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>p</code> - 0-based coordinate of the extrapolated pixel along one of the axes, likely &lt;0 or &gt;= len</dd>
<dd><code>len</code> - Length of the array along the corresponding axis.</dd>
<dd><code>borderType</code> - Border type, one of the #BorderTypes, except for #BORDER_TRANSPARENT and
 #BORDER_ISOLATED. When borderType==#BORDER_CONSTANT, the function always returns -1, regardless
 of p and len.

 SEE: copyMakeBorder</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="copyMakeBorder-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-int-int-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copyMakeBorder</h4>
<pre>public static&nbsp;void&nbsp;copyMakeBorder(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                  int&nbsp;top,
                                  int&nbsp;bottom,
                                  int&nbsp;left,
                                  int&nbsp;right,
                                  int&nbsp;borderType,
                                  <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;value)</pre>
<div class="block">Forms a border around an image.

 The function copies the source image into the middle of the destination image. The areas to the
 left, to the right, above and below the copied source image will be filled with extrapolated
 pixels. This is not what filtering functions based on it do (they extrapolate pixels on-fly), but
 what other more complex functions, including your own, may do to simplify image boundary handling.

 The function supports the mode when src is already in the middle of dst . In this case, the
 function does not copy src itself but simply constructs the border, for example:

 <code>
     // let border be the same in all directions
     int border=2;
     // constructs a larger image to fit both the image and the border
     Mat gray_buf(rgb.rows + border*2, rgb.cols + border*2, rgb.depth());
     // select the middle part of it w/o copying data
     Mat gray(gray_canvas, Rect(border, border, rgb.cols, rgb.rows));
     // convert image from RGB to grayscale
     cvtColor(rgb, gray, COLOR_RGB2GRAY);
     // form a border in-place
     copyMakeBorder(gray, gray_buf, border, border,
                    border, border, BORDER_REPLICATE);
     // now do some custom filtering ...
     ...
 </code>
 <b>Note:</b> When the source image is a part (ROI) of a bigger image, the function will try to use the
 pixels outside of the ROI to form a border. To disable this feature and always do extrapolation, as
 if src was not a ROI, use borderType | #BORDER_ISOLATED.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image.</dd>
<dd><code>dst</code> - Destination image of the same type as src and the size Size(src.cols+left+right,
 src.rows+top+bottom) .</dd>
<dd><code>top</code> - the top pixels</dd>
<dd><code>bottom</code> - the bottom pixels</dd>
<dd><code>left</code> - the left pixels</dd>
<dd><code>right</code> - Parameter specifying how many pixels in each direction from the source image rectangle
 to extrapolate. For example, top=1, bottom=1, left=1, right=1 mean that 1 pixel-wide border needs
 to be built.</dd>
<dd><code>borderType</code> - Border type. See borderInterpolate for details.</dd>
<dd><code>value</code> - Border value if borderType==BORDER_CONSTANT .

 SEE:  borderInterpolate</dd>
</dl>
</li>
</ul>
<a name="copyMakeBorder-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copyMakeBorder</h4>
<pre>public static&nbsp;void&nbsp;copyMakeBorder(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                  int&nbsp;top,
                                  int&nbsp;bottom,
                                  int&nbsp;left,
                                  int&nbsp;right,
                                  int&nbsp;borderType)</pre>
<div class="block">Forms a border around an image.

 The function copies the source image into the middle of the destination image. The areas to the
 left, to the right, above and below the copied source image will be filled with extrapolated
 pixels. This is not what filtering functions based on it do (they extrapolate pixels on-fly), but
 what other more complex functions, including your own, may do to simplify image boundary handling.

 The function supports the mode when src is already in the middle of dst . In this case, the
 function does not copy src itself but simply constructs the border, for example:

 <code>
     // let border be the same in all directions
     int border=2;
     // constructs a larger image to fit both the image and the border
     Mat gray_buf(rgb.rows + border*2, rgb.cols + border*2, rgb.depth());
     // select the middle part of it w/o copying data
     Mat gray(gray_canvas, Rect(border, border, rgb.cols, rgb.rows));
     // convert image from RGB to grayscale
     cvtColor(rgb, gray, COLOR_RGB2GRAY);
     // form a border in-place
     copyMakeBorder(gray, gray_buf, border, border,
                    border, border, BORDER_REPLICATE);
     // now do some custom filtering ...
     ...
 </code>
 <b>Note:</b> When the source image is a part (ROI) of a bigger image, the function will try to use the
 pixels outside of the ROI to form a border. To disable this feature and always do extrapolation, as
 if src was not a ROI, use borderType | #BORDER_ISOLATED.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - Source image.</dd>
<dd><code>dst</code> - Destination image of the same type as src and the size Size(src.cols+left+right,
 src.rows+top+bottom) .</dd>
<dd><code>top</code> - the top pixels</dd>
<dd><code>bottom</code> - the bottom pixels</dd>
<dd><code>left</code> - the left pixels</dd>
<dd><code>right</code> - Parameter specifying how many pixels in each direction from the source image rectangle
 to extrapolate. For example, top=1, bottom=1, left=1, right=1 mean that 1 pixel-wide border needs
 to be built.</dd>
<dd><code>borderType</code> - Border type. See borderInterpolate for details.

 SEE:  borderInterpolate</dd>
</dl>
</li>
</ul>
<a name="add-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre>public static&nbsp;void&nbsp;add(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                       int&nbsp;dtype)</pre>
<div class="block">Calculates the per-element sum of two arrays or an array and a scalar.

 The function add calculates:
 <ul>
   <li>
  Sum of two arrays when both input arrays have the same size and the same number of channels:
 \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) +  \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0\)
   </li>
   <li>
  Sum of an array and a scalar when src2 is constructed from Scalar or has the same number of
 elements as <code>src1.channels()</code>:
 \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) +  \texttt{src2} ) \quad \texttt{if mask}(I) \ne0\)
   </li>
   <li>
  Sum of a scalar and an array when src1 is constructed from Scalar or has the same number of
 elements as <code>src2.channels()</code>:
 \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1} +  \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0\)
 where <code>I</code> is a multi-dimensional index of array elements. In case of multi-channel arrays, each
 channel is processed independently.
   </li>
 </ul>

 The first function in the list above can be replaced with matrix expressions:
 <code>
     dst = src1 + src2;
     dst += src1; // equivalent to add(dst, src1, dst);
 </code>
 The input arrays and the output array can all have the same or different depths. For example, you
 can add a 16-bit unsigned array to a 8-bit signed array and store the sum as a 32-bit
 floating-point array. Depth of the output array is determined by the dtype parameter. In the second
 and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can
 be set to the default -1. In this case, the output array will have the same depth as the input
 array, be it src1, src2 or both.
 <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get
 result of an incorrect sign in the case of overflow.
 <b>Note:</b> (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
 <code>add(src,X)</code> means <code>add(src,(X,X,X,X))</code>.
 <code>add(src,(X,))</code> means <code>add(src,(X,0,0,0))</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array or a scalar.</dd>
<dd><code>src2</code> - second input array or a scalar.</dd>
<dd><code>dst</code> - output array that has the same size and number of channels as the input array(s); the
 depth is defined by dtype or src1/src2.</dd>
<dd><code>mask</code> - optional operation mask - 8-bit single channel array, that specifies elements of the
 output array to be changed.</dd>
<dd><code>dtype</code> - optional depth of the output array (see the discussion below).
 SEE: subtract, addWeighted, scaleAdd, Mat::convertTo</dd>
</dl>
</li>
</ul>
<a name="add-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre>public static&nbsp;void&nbsp;add(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Calculates the per-element sum of two arrays or an array and a scalar.

 The function add calculates:
 <ul>
   <li>
  Sum of two arrays when both input arrays have the same size and the same number of channels:
 \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) +  \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0\)
   </li>
   <li>
  Sum of an array and a scalar when src2 is constructed from Scalar or has the same number of
 elements as <code>src1.channels()</code>:
 \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) +  \texttt{src2} ) \quad \texttt{if mask}(I) \ne0\)
   </li>
   <li>
  Sum of a scalar and an array when src1 is constructed from Scalar or has the same number of
 elements as <code>src2.channels()</code>:
 \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1} +  \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0\)
 where <code>I</code> is a multi-dimensional index of array elements. In case of multi-channel arrays, each
 channel is processed independently.
   </li>
 </ul>

 The first function in the list above can be replaced with matrix expressions:
 <code>
     dst = src1 + src2;
     dst += src1; // equivalent to add(dst, src1, dst);
 </code>
 The input arrays and the output array can all have the same or different depths. For example, you
 can add a 16-bit unsigned array to a 8-bit signed array and store the sum as a 32-bit
 floating-point array. Depth of the output array is determined by the dtype parameter. In the second
 and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can
 be set to the default -1. In this case, the output array will have the same depth as the input
 array, be it src1, src2 or both.
 <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get
 result of an incorrect sign in the case of overflow.
 <b>Note:</b> (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
 <code>add(src,X)</code> means <code>add(src,(X,X,X,X))</code>.
 <code>add(src,(X,))</code> means <code>add(src,(X,0,0,0))</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array or a scalar.</dd>
<dd><code>src2</code> - second input array or a scalar.</dd>
<dd><code>dst</code> - output array that has the same size and number of channels as the input array(s); the
 depth is defined by dtype or src1/src2.</dd>
<dd><code>mask</code> - optional operation mask - 8-bit single channel array, that specifies elements of the
 output array to be changed.
 SEE: subtract, addWeighted, scaleAdd, Mat::convertTo</dd>
</dl>
</li>
</ul>
<a name="add-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre>public static&nbsp;void&nbsp;add(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Calculates the per-element sum of two arrays or an array and a scalar.

 The function add calculates:
 <ul>
   <li>
  Sum of two arrays when both input arrays have the same size and the same number of channels:
 \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) +  \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0\)
   </li>
   <li>
  Sum of an array and a scalar when src2 is constructed from Scalar or has the same number of
 elements as <code>src1.channels()</code>:
 \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) +  \texttt{src2} ) \quad \texttt{if mask}(I) \ne0\)
   </li>
   <li>
  Sum of a scalar and an array when src1 is constructed from Scalar or has the same number of
 elements as <code>src2.channels()</code>:
 \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1} +  \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0\)
 where <code>I</code> is a multi-dimensional index of array elements. In case of multi-channel arrays, each
 channel is processed independently.
   </li>
 </ul>

 The first function in the list above can be replaced with matrix expressions:
 <code>
     dst = src1 + src2;
     dst += src1; // equivalent to add(dst, src1, dst);
 </code>
 The input arrays and the output array can all have the same or different depths. For example, you
 can add a 16-bit unsigned array to a 8-bit signed array and store the sum as a 32-bit
 floating-point array. Depth of the output array is determined by the dtype parameter. In the second
 and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can
 be set to the default -1. In this case, the output array will have the same depth as the input
 array, be it src1, src2 or both.
 <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get
 result of an incorrect sign in the case of overflow.
 <b>Note:</b> (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
 <code>add(src,X)</code> means <code>add(src,(X,X,X,X))</code>.
 <code>add(src,(X,))</code> means <code>add(src,(X,0,0,0))</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array or a scalar.</dd>
<dd><code>src2</code> - second input array or a scalar.</dd>
<dd><code>dst</code> - output array that has the same size and number of channels as the input array(s); the
 depth is defined by dtype or src1/src2.
 output array to be changed.
 SEE: subtract, addWeighted, scaleAdd, Mat::convertTo</dd>
</dl>
</li>
</ul>
<a name="subtract-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subtract</h4>
<pre>public static&nbsp;void&nbsp;subtract(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                            int&nbsp;dtype)</pre>
<div class="block">Calculates the per-element difference between two arrays or array and a scalar.

 The function subtract calculates:
 <ul>
   <li>
  Difference between two arrays, when both input arrays have the same size and the same number of
 channels:
     \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) -  \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0\)
   </li>
   <li>
  Difference between an array and a scalar, when src2 is constructed from Scalar or has the same
 number of elements as <code>src1.channels()</code>:
     \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) -  \texttt{src2} ) \quad \texttt{if mask}(I) \ne0\)
   </li>
   <li>
  Difference between a scalar and an array, when src1 is constructed from Scalar or has the same
 number of elements as <code>src2.channels()</code>:
     \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1} -  \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0\)
   </li>
   <li>
  The reverse difference between a scalar and an array in the case of <code>SubRS</code>:
     \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src2} -  \texttt{src1}(I) ) \quad \texttt{if mask}(I) \ne0\)
 where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each
 channel is processed independently.
   </li>
 </ul>

 The first function in the list above can be replaced with matrix expressions:
 <code>
     dst = src1 - src2;
     dst -= src1; // equivalent to subtract(dst, src1, dst);
 </code>
 The input arrays and the output array can all have the same or different depths. For example, you
 can subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of
 the output array is determined by dtype parameter. In the second and third cases above, as well as
 in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this
 case the output array will have the same depth as the input array, be it src1, src2 or both.
 <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get
 result of an incorrect sign in the case of overflow.
 <b>Note:</b> (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
 <code>subtract(src,X)</code> means <code>subtract(src,(X,X,X,X))</code>.
 <code>subtract(src,(X,))</code> means <code>subtract(src,(X,0,0,0))</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array or a scalar.</dd>
<dd><code>src2</code> - second input array or a scalar.</dd>
<dd><code>dst</code> - output array of the same size and the same number of channels as the input array.</dd>
<dd><code>mask</code> - optional operation mask; this is an 8-bit single channel array that specifies elements
 of the output array to be changed.</dd>
<dd><code>dtype</code> - optional depth of the output array
 SEE:  add, addWeighted, scaleAdd, Mat::convertTo</dd>
</dl>
</li>
</ul>
<a name="subtract-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subtract</h4>
<pre>public static&nbsp;void&nbsp;subtract(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Calculates the per-element difference between two arrays or array and a scalar.

 The function subtract calculates:
 <ul>
   <li>
  Difference between two arrays, when both input arrays have the same size and the same number of
 channels:
     \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) -  \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0\)
   </li>
   <li>
  Difference between an array and a scalar, when src2 is constructed from Scalar or has the same
 number of elements as <code>src1.channels()</code>:
     \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) -  \texttt{src2} ) \quad \texttt{if mask}(I) \ne0\)
   </li>
   <li>
  Difference between a scalar and an array, when src1 is constructed from Scalar or has the same
 number of elements as <code>src2.channels()</code>:
     \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1} -  \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0\)
   </li>
   <li>
  The reverse difference between a scalar and an array in the case of <code>SubRS</code>:
     \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src2} -  \texttt{src1}(I) ) \quad \texttt{if mask}(I) \ne0\)
 where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each
 channel is processed independently.
   </li>
 </ul>

 The first function in the list above can be replaced with matrix expressions:
 <code>
     dst = src1 - src2;
     dst -= src1; // equivalent to subtract(dst, src1, dst);
 </code>
 The input arrays and the output array can all have the same or different depths. For example, you
 can subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of
 the output array is determined by dtype parameter. In the second and third cases above, as well as
 in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this
 case the output array will have the same depth as the input array, be it src1, src2 or both.
 <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get
 result of an incorrect sign in the case of overflow.
 <b>Note:</b> (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
 <code>subtract(src,X)</code> means <code>subtract(src,(X,X,X,X))</code>.
 <code>subtract(src,(X,))</code> means <code>subtract(src,(X,0,0,0))</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array or a scalar.</dd>
<dd><code>src2</code> - second input array or a scalar.</dd>
<dd><code>dst</code> - output array of the same size and the same number of channels as the input array.</dd>
<dd><code>mask</code> - optional operation mask; this is an 8-bit single channel array that specifies elements
 of the output array to be changed.
 SEE:  add, addWeighted, scaleAdd, Mat::convertTo</dd>
</dl>
</li>
</ul>
<a name="subtract-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subtract</h4>
<pre>public static&nbsp;void&nbsp;subtract(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Calculates the per-element difference between two arrays or array and a scalar.

 The function subtract calculates:
 <ul>
   <li>
  Difference between two arrays, when both input arrays have the same size and the same number of
 channels:
     \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) -  \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0\)
   </li>
   <li>
  Difference between an array and a scalar, when src2 is constructed from Scalar or has the same
 number of elements as <code>src1.channels()</code>:
     \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) -  \texttt{src2} ) \quad \texttt{if mask}(I) \ne0\)
   </li>
   <li>
  Difference between a scalar and an array, when src1 is constructed from Scalar or has the same
 number of elements as <code>src2.channels()</code>:
     \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1} -  \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0\)
   </li>
   <li>
  The reverse difference between a scalar and an array in the case of <code>SubRS</code>:
     \(\texttt{dst}(I) =  \texttt{saturate} ( \texttt{src2} -  \texttt{src1}(I) ) \quad \texttt{if mask}(I) \ne0\)
 where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each
 channel is processed independently.
   </li>
 </ul>

 The first function in the list above can be replaced with matrix expressions:
 <code>
     dst = src1 - src2;
     dst -= src1; // equivalent to subtract(dst, src1, dst);
 </code>
 The input arrays and the output array can all have the same or different depths. For example, you
 can subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of
 the output array is determined by dtype parameter. In the second and third cases above, as well as
 in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this
 case the output array will have the same depth as the input array, be it src1, src2 or both.
 <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get
 result of an incorrect sign in the case of overflow.
 <b>Note:</b> (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
 <code>subtract(src,X)</code> means <code>subtract(src,(X,X,X,X))</code>.
 <code>subtract(src,(X,))</code> means <code>subtract(src,(X,0,0,0))</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array or a scalar.</dd>
<dd><code>src2</code> - second input array or a scalar.</dd>
<dd><code>dst</code> - output array of the same size and the same number of channels as the input array.
 of the output array to be changed.
 SEE:  add, addWeighted, scaleAdd, Mat::convertTo</dd>
</dl>
</li>
</ul>
<a name="multiply-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                            double&nbsp;scale,
                            int&nbsp;dtype)</pre>
<div class="block">Calculates the per-element scaled product of two arrays.

 The function multiply calculates the per-element product of two arrays:

 \(\texttt{dst} (I)= \texttt{saturate} ( \texttt{scale} \cdot \texttt{src1} (I)  \cdot \texttt{src2} (I))\)

 There is also a REF: MatrixExpressions -friendly variant of the first function. See Mat::mul .

 For a not-per-element matrix product, see gemm .

 <b>Note:</b> Saturation is not applied when the output array has the depth
 CV_32S. You may even get result of an incorrect sign in the case of
 overflow.
 <b>Note:</b> (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
 <code>multiply(src,X)</code> means <code>multiply(src,(X,X,X,X))</code>.
 <code>multiply(src,(X,))</code> means <code>multiply(src,(X,0,0,0))</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>src2</code> - second input array of the same size and the same type as src1.</dd>
<dd><code>dst</code> - output array of the same size and type as src1.</dd>
<dd><code>scale</code> - optional scale factor.</dd>
<dd><code>dtype</code> - optional depth of the output array
 SEE: add, subtract, divide, scaleAdd, addWeighted, accumulate, accumulateProduct, accumulateSquare,
 Mat::convertTo</dd>
</dl>
</li>
</ul>
<a name="multiply-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                            double&nbsp;scale)</pre>
<div class="block">Calculates the per-element scaled product of two arrays.

 The function multiply calculates the per-element product of two arrays:

 \(\texttt{dst} (I)= \texttt{saturate} ( \texttt{scale} \cdot \texttt{src1} (I)  \cdot \texttt{src2} (I))\)

 There is also a REF: MatrixExpressions -friendly variant of the first function. See Mat::mul .

 For a not-per-element matrix product, see gemm .

 <b>Note:</b> Saturation is not applied when the output array has the depth
 CV_32S. You may even get result of an incorrect sign in the case of
 overflow.
 <b>Note:</b> (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
 <code>multiply(src,X)</code> means <code>multiply(src,(X,X,X,X))</code>.
 <code>multiply(src,(X,))</code> means <code>multiply(src,(X,0,0,0))</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>src2</code> - second input array of the same size and the same type as src1.</dd>
<dd><code>dst</code> - output array of the same size and type as src1.</dd>
<dd><code>scale</code> - optional scale factor.
 SEE: add, subtract, divide, scaleAdd, addWeighted, accumulate, accumulateProduct, accumulateSquare,
 Mat::convertTo</dd>
</dl>
</li>
</ul>
<a name="multiply-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Calculates the per-element scaled product of two arrays.

 The function multiply calculates the per-element product of two arrays:

 \(\texttt{dst} (I)= \texttt{saturate} ( \texttt{scale} \cdot \texttt{src1} (I)  \cdot \texttt{src2} (I))\)

 There is also a REF: MatrixExpressions -friendly variant of the first function. See Mat::mul .

 For a not-per-element matrix product, see gemm .

 <b>Note:</b> Saturation is not applied when the output array has the depth
 CV_32S. You may even get result of an incorrect sign in the case of
 overflow.
 <b>Note:</b> (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
 <code>multiply(src,X)</code> means <code>multiply(src,(X,X,X,X))</code>.
 <code>multiply(src,(X,))</code> means <code>multiply(src,(X,0,0,0))</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>src2</code> - second input array of the same size and the same type as src1.</dd>
<dd><code>dst</code> - output array of the same size and type as src1.
 SEE: add, subtract, divide, scaleAdd, addWeighted, accumulate, accumulateProduct, accumulateSquare,
 Mat::convertTo</dd>
</dl>
</li>
</ul>
<a name="divide-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>divide</h4>
<pre>public static&nbsp;void&nbsp;divide(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          double&nbsp;scale,
                          int&nbsp;dtype)</pre>
<div class="block">Performs per-element division of two arrays or a scalar by an array.

 The function cv::divide divides one array by another:
 \(\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}\)
 or a scalar by an array when there is no src1 :
 \(\texttt{dst(I) = saturate(scale/src2(I))}\)

 Different channels of multi-channel arrays are processed independently.

 For integer types when src2(I) is zero, dst(I) will also be zero.

 <b>Note:</b> In case of floating point data there is no special defined behavior for zero src2(I) values.
 Regular floating-point division is used.
 Expect correct IEEE-754 behaviour for floating-point data (with NaN, Inf result values).

 <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get
 result of an incorrect sign in the case of overflow.
 <b>Note:</b> (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
 <code>divide(src,X)</code> means <code>divide(src,(X,X,X,X))</code>.
 <code>divide(src,(X,))</code> means <code>divide(src,(X,0,0,0))</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>src2</code> - second input array of the same size and type as src1.</dd>
<dd><code>scale</code> - scalar factor.</dd>
<dd><code>dst</code> - output array of the same size and type as src2.</dd>
<dd><code>dtype</code> - optional depth of the output array; if -1, dst will have depth src2.depth(), but in
 case of an array-by-array division, you can only pass -1 when src1.depth()==src2.depth().
 SEE:  multiply, add, subtract</dd>
</dl>
</li>
</ul>
<a name="divide-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>divide</h4>
<pre>public static&nbsp;void&nbsp;divide(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          double&nbsp;scale)</pre>
<div class="block">Performs per-element division of two arrays or a scalar by an array.

 The function cv::divide divides one array by another:
 \(\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}\)
 or a scalar by an array when there is no src1 :
 \(\texttt{dst(I) = saturate(scale/src2(I))}\)

 Different channels of multi-channel arrays are processed independently.

 For integer types when src2(I) is zero, dst(I) will also be zero.

 <b>Note:</b> In case of floating point data there is no special defined behavior for zero src2(I) values.
 Regular floating-point division is used.
 Expect correct IEEE-754 behaviour for floating-point data (with NaN, Inf result values).

 <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get
 result of an incorrect sign in the case of overflow.
 <b>Note:</b> (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
 <code>divide(src,X)</code> means <code>divide(src,(X,X,X,X))</code>.
 <code>divide(src,(X,))</code> means <code>divide(src,(X,0,0,0))</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>src2</code> - second input array of the same size and type as src1.</dd>
<dd><code>scale</code> - scalar factor.</dd>
<dd><code>dst</code> - output array of the same size and type as src2.
 case of an array-by-array division, you can only pass -1 when src1.depth()==src2.depth().
 SEE:  multiply, add, subtract</dd>
</dl>
</li>
</ul>
<a name="divide-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>divide</h4>
<pre>public static&nbsp;void&nbsp;divide(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Performs per-element division of two arrays or a scalar by an array.

 The function cv::divide divides one array by another:
 \(\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}\)
 or a scalar by an array when there is no src1 :
 \(\texttt{dst(I) = saturate(scale/src2(I))}\)

 Different channels of multi-channel arrays are processed independently.

 For integer types when src2(I) is zero, dst(I) will also be zero.

 <b>Note:</b> In case of floating point data there is no special defined behavior for zero src2(I) values.
 Regular floating-point division is used.
 Expect correct IEEE-754 behaviour for floating-point data (with NaN, Inf result values).

 <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get
 result of an incorrect sign in the case of overflow.
 <b>Note:</b> (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
 <code>divide(src,X)</code> means <code>divide(src,(X,X,X,X))</code>.
 <code>divide(src,(X,))</code> means <code>divide(src,(X,0,0,0))</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>src2</code> - second input array of the same size and type as src1.</dd>
<dd><code>dst</code> - output array of the same size and type as src2.
 case of an array-by-array division, you can only pass -1 when src1.depth()==src2.depth().
 SEE:  multiply, add, subtract</dd>
</dl>
</li>
</ul>
<a name="divide-double-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>divide</h4>
<pre>public static&nbsp;void&nbsp;divide(double&nbsp;scale,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          int&nbsp;dtype)</pre>
</li>
</ul>
<a name="divide-double-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>divide</h4>
<pre>public static&nbsp;void&nbsp;divide(double&nbsp;scale,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
</li>
</ul>
<a name="scaleAdd-org.opencv.core.Mat-double-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scaleAdd</h4>
<pre>public static&nbsp;void&nbsp;scaleAdd(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                            double&nbsp;alpha,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Calculates the sum of a scaled array and another array.

 The function scaleAdd is one of the classical primitive linear algebra operations, known as DAXPY
 or SAXPY in [BLAS](http://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms). It calculates
 the sum of a scaled array and another array:
 \(\texttt{dst} (I)= \texttt{scale} \cdot \texttt{src1} (I) +  \texttt{src2} (I)\)
 The function can also be emulated with a matrix expression, for example:
 <code>
     Mat A(3, 3, CV_64F);
     ...
     A.row(0) = A.row(1)*2 + A.row(2);
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>alpha</code> - scale factor for the first array.</dd>
<dd><code>src2</code> - second input array of the same size and type as src1.</dd>
<dd><code>dst</code> - output array of the same size and type as src1.
 SEE: add, addWeighted, subtract, Mat::dot, Mat::convertTo</dd>
</dl>
</li>
</ul>
<a name="addWeighted-org.opencv.core.Mat-double-org.opencv.core.Mat-double-double-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addWeighted</h4>
<pre>public static&nbsp;void&nbsp;addWeighted(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                               double&nbsp;alpha,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                               double&nbsp;beta,
                               double&nbsp;gamma,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                               int&nbsp;dtype)</pre>
<div class="block">Calculates the weighted sum of two arrays.

 The function addWeighted calculates the weighted sum of two arrays as follows:
 \(\texttt{dst} (I)= \texttt{saturate} ( \texttt{src1} (I)* \texttt{alpha} +  \texttt{src2} (I)* \texttt{beta} +  \texttt{gamma} )\)
 where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each
 channel is processed independently.
 The function can be replaced with a matrix expression:
 <code>
     dst = src1*alpha + src2*beta + gamma;
 </code>
 <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get
 result of an incorrect sign in the case of overflow.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>alpha</code> - weight of the first array elements.</dd>
<dd><code>src2</code> - second input array of the same size and channel number as src1.</dd>
<dd><code>beta</code> - weight of the second array elements.</dd>
<dd><code>gamma</code> - scalar added to each sum.</dd>
<dd><code>dst</code> - output array that has the same size and number of channels as the input arrays.</dd>
<dd><code>dtype</code> - optional depth of the output array; when both input arrays have the same depth, dtype
 can be set to -1, which will be equivalent to src1.depth().
 SEE:  add, subtract, scaleAdd, Mat::convertTo</dd>
</dl>
</li>
</ul>
<a name="addWeighted-org.opencv.core.Mat-double-org.opencv.core.Mat-double-double-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addWeighted</h4>
<pre>public static&nbsp;void&nbsp;addWeighted(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                               double&nbsp;alpha,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                               double&nbsp;beta,
                               double&nbsp;gamma,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Calculates the weighted sum of two arrays.

 The function addWeighted calculates the weighted sum of two arrays as follows:
 \(\texttt{dst} (I)= \texttt{saturate} ( \texttt{src1} (I)* \texttt{alpha} +  \texttt{src2} (I)* \texttt{beta} +  \texttt{gamma} )\)
 where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each
 channel is processed independently.
 The function can be replaced with a matrix expression:
 <code>
     dst = src1*alpha + src2*beta + gamma;
 </code>
 <b>Note:</b> Saturation is not applied when the output array has the depth CV_32S. You may even get
 result of an incorrect sign in the case of overflow.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>alpha</code> - weight of the first array elements.</dd>
<dd><code>src2</code> - second input array of the same size and channel number as src1.</dd>
<dd><code>beta</code> - weight of the second array elements.</dd>
<dd><code>gamma</code> - scalar added to each sum.</dd>
<dd><code>dst</code> - output array that has the same size and number of channels as the input arrays.
 can be set to -1, which will be equivalent to src1.depth().
 SEE:  add, subtract, scaleAdd, Mat::convertTo</dd>
</dl>
</li>
</ul>
<a name="convertScaleAbs-org.opencv.core.Mat-org.opencv.core.Mat-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertScaleAbs</h4>
<pre>public static&nbsp;void&nbsp;convertScaleAbs(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                   double&nbsp;alpha,
                                   double&nbsp;beta)</pre>
<div class="block">Scales, calculates absolute values, and converts the result to 8-bit.

 On each element of the input array, the function convertScaleAbs
 performs three operations sequentially: scaling, taking an absolute
 value, conversion to an unsigned 8-bit type:
 \(\texttt{dst} (I)= \texttt{saturate\_cast&lt;uchar&gt;} (| \texttt{src} (I)* \texttt{alpha} +  \texttt{beta} |)\)
 In case of multi-channel arrays, the function processes each channel
 independently. When the output is not 8-bit, the operation can be
 emulated by calling the Mat::convertTo method (or by using matrix
 expressions) and then by calculating an absolute value of the result.
 For example:
 <code>
     Mat_&lt;float&gt; A(30,30);
     randu(A, Scalar(-100), Scalar(100));
     Mat_&lt;float&gt; B = A*5 + 3;
     B = abs(B);
     // Mat_&lt;float&gt; B = abs(A*5+3) will also do the job,
     // but it will allocate a temporary matrix
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>dst</code> - output array.</dd>
<dd><code>alpha</code> - optional scale factor.</dd>
<dd><code>beta</code> - optional delta added to the scaled values.
 SEE:  Mat::convertTo, cv::abs(const Mat&amp;)</dd>
</dl>
</li>
</ul>
<a name="convertScaleAbs-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertScaleAbs</h4>
<pre>public static&nbsp;void&nbsp;convertScaleAbs(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                   double&nbsp;alpha)</pre>
<div class="block">Scales, calculates absolute values, and converts the result to 8-bit.

 On each element of the input array, the function convertScaleAbs
 performs three operations sequentially: scaling, taking an absolute
 value, conversion to an unsigned 8-bit type:
 \(\texttt{dst} (I)= \texttt{saturate\_cast&lt;uchar&gt;} (| \texttt{src} (I)* \texttt{alpha} +  \texttt{beta} |)\)
 In case of multi-channel arrays, the function processes each channel
 independently. When the output is not 8-bit, the operation can be
 emulated by calling the Mat::convertTo method (or by using matrix
 expressions) and then by calculating an absolute value of the result.
 For example:
 <code>
     Mat_&lt;float&gt; A(30,30);
     randu(A, Scalar(-100), Scalar(100));
     Mat_&lt;float&gt; B = A*5 + 3;
     B = abs(B);
     // Mat_&lt;float&gt; B = abs(A*5+3) will also do the job,
     // but it will allocate a temporary matrix
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>dst</code> - output array.</dd>
<dd><code>alpha</code> - optional scale factor.
 SEE:  Mat::convertTo, cv::abs(const Mat&amp;)</dd>
</dl>
</li>
</ul>
<a name="convertScaleAbs-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertScaleAbs</h4>
<pre>public static&nbsp;void&nbsp;convertScaleAbs(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Scales, calculates absolute values, and converts the result to 8-bit.

 On each element of the input array, the function convertScaleAbs
 performs three operations sequentially: scaling, taking an absolute
 value, conversion to an unsigned 8-bit type:
 \(\texttt{dst} (I)= \texttt{saturate\_cast&lt;uchar&gt;} (| \texttt{src} (I)* \texttt{alpha} +  \texttt{beta} |)\)
 In case of multi-channel arrays, the function processes each channel
 independently. When the output is not 8-bit, the operation can be
 emulated by calling the Mat::convertTo method (or by using matrix
 expressions) and then by calculating an absolute value of the result.
 For example:
 <code>
     Mat_&lt;float&gt; A(30,30);
     randu(A, Scalar(-100), Scalar(100));
     Mat_&lt;float&gt; B = A*5 + 3;
     B = abs(B);
     // Mat_&lt;float&gt; B = abs(A*5+3) will also do the job,
     // but it will allocate a temporary matrix
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>dst</code> - output array.
 SEE:  Mat::convertTo, cv::abs(const Mat&amp;)</dd>
</dl>
</li>
</ul>
<a name="convertFp16-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>convertFp16</h4>
<pre><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html?is-external=true" title="class or interface in java.lang">@Deprecated</a>
public static&nbsp;void&nbsp;convertFp16(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">Use Mat::convertTo with CV_16F instead.</span></div>
<div class="block">Converts an array to half precision floating number.

 This function converts FP32 (single precision floating point) from/to FP16 (half precision floating point). CV_16S format is used to represent FP16 data.
 There are two use modes (src -&gt; dst): CV_32F -&gt; CV_16S and CV_16S -&gt; CV_32F. The input array has to have type of CV_32F or
 CV_16S to represent the bit depth. If the input array is neither of them, the function will raise an error.
 The format of half precision floating point is defined in IEEE 754-2008.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>dst</code> - output array.</dd>
</dl>
</li>
</ul>
<a name="LUT-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>LUT</h4>
<pre>public static&nbsp;void&nbsp;LUT(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;lut,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Performs a look-up table transform of an array.

 The function LUT fills the output array with values from the look-up table. Indices of the entries
 are taken from the input array. That is, the function processes each element of src as follows:
 \(\texttt{dst} (I)  \leftarrow \texttt{lut(src(I) + d)}\)
 where
 \(d =  \fork{0}{if \(\texttt{src}\) has depth \(\texttt{CV_8U}\)}{128}{if \(\texttt{src}\) has depth \(\texttt{CV_8S}\)}\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array of 8-bit elements.</dd>
<dd><code>lut</code> - look-up table of 256 elements; in case of multi-channel input array, the table should
 either have a single channel (in this case the same table is used for all channels) or the same
 number of channels as in the input array.</dd>
<dd><code>dst</code> - output array of the same size and number of channels as src, and the same depth as lut.
 SEE:  convertScaleAbs, Mat::convertTo</dd>
</dl>
</li>
</ul>
<a name="sumElems-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sumElems</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;sumElems(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src)</pre>
<div class="block">Calculates the sum of array elements.

 The function cv::sum calculates and returns the sum of array elements,
 independently for each channel.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array that must have from 1 to 4 channels.
 SEE:  countNonZero, mean, meanStdDev, norm, minMaxLoc, reduce</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="hasNonZero-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasNonZero</h4>
<pre>public static&nbsp;boolean&nbsp;hasNonZero(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src)</pre>
<div class="block">Checks for the presence of at least one non-zero array element.

 The function returns whether there are non-zero elements in src

 The function do not work with multi-channel arrays. If you need to check non-zero array
 elements across all the channels, use Mat::reshape first to reinterpret the array as
 single-channel. Or you may extract the particular channel using either extractImageCOI, or
 mixChannels, or split.

 <b>Note:</b>
 <ul>
   <li>
  If the location of non-zero array elements is important, REF: findNonZero is helpful.
   </li>
   <li>
  If the count of non-zero array elements is important, REF: countNonZero is helpful.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - single-channel array.
 SEE:  mean, meanStdDev, norm, minMaxLoc, calcCovarMatrix
 SEE:  findNonZero, countNonZero</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="countNonZero-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countNonZero</h4>
<pre>public static&nbsp;int&nbsp;countNonZero(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src)</pre>
<div class="block">Counts non-zero array elements.

 The function returns the number of non-zero elements in src :
 \(\sum _{I: \; \texttt{src} (I) \ne0 } 1\)

 The function do not work with multi-channel arrays. If you need to count non-zero array
 elements across all the channels, use Mat::reshape first to reinterpret the array as
 single-channel. Or you may extract the particular channel using either extractImageCOI, or
 mixChannels, or split.

 <b>Note:</b>
 <ul>
   <li>
  If only whether there are non-zero elements is important, REF: hasNonZero is helpful.
   </li>
   <li>
  If the location of non-zero array elements is important, REF: findNonZero is helpful.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - single-channel array.
 SEE:  mean, meanStdDev, norm, minMaxLoc, calcCovarMatrix
 SEE:  findNonZero, hasNonZero</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findNonZero-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findNonZero</h4>
<pre>public static&nbsp;void&nbsp;findNonZero(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;idx)</pre>
<div class="block">Returns the list of locations of non-zero pixels

 Given a binary matrix (likely returned from an operation such
 as threshold(), compare(), &gt;, ==, etc, return all of
 the non-zero indices as a cv::Mat or std::vector&lt;cv::Point&gt; (x,y)
 For example:
 <code>
     cv::Mat binaryImage; // input, binary image
     cv::Mat locations;   // output, locations of non-zero pixels
     cv::findNonZero(binaryImage, locations);

     // access pixel coordinates
     Point pnt = locations.at&lt;Point&gt;(i);
 </code>
 or
 <code>
     cv::Mat binaryImage; // input, binary image
     vector&lt;Point&gt; locations;   // output, locations of non-zero pixels
     cv::findNonZero(binaryImage, locations);

     // access pixel coordinates
     Point pnt = locations[i];
 </code>

 The function do not work with multi-channel arrays. If you need to find non-zero
 elements across all the channels, use Mat::reshape first to reinterpret the array as
 single-channel. Or you may extract the particular channel using either extractImageCOI, or
 mixChannels, or split.

 <b>Note:</b>
 <ul>
   <li>
  If only count of non-zero array elements is important, REF: countNonZero is helpful.
   </li>
   <li>
  If only whether there are non-zero elements is important, REF: hasNonZero is helpful.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - single-channel array</dd>
<dd><code>idx</code> - the output array, type of cv::Mat or std::vector&lt;Point&gt;, corresponding to non-zero indices in the input
 SEE:  countNonZero, hasNonZero</dd>
</dl>
</li>
</ul>
<a name="mean-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mean</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;mean(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Calculates an average (mean) of array elements.

 The function cv::mean calculates the mean value M of array elements,
 independently for each channel, and return it:
 \(\begin{array}{l} N =  \sum _{I: \; \texttt{mask} (I) \ne 0} 1 \\ M_c =  \left ( \sum _{I: \; \texttt{mask} (I) \ne 0}{ \texttt{mtx} (I)_c} \right )/N \end{array}\)
 When all the mask elements are 0's, the function returns Scalar::all(0)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array that should have from 1 to 4 channels so that the result can be stored in
 Scalar_ .</dd>
<dd><code>mask</code> - optional operation mask.
 SEE:  countNonZero, meanStdDev, norm, minMaxLoc</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="mean-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mean</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;mean(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src)</pre>
<div class="block">Calculates an average (mean) of array elements.

 The function cv::mean calculates the mean value M of array elements,
 independently for each channel, and return it:
 \(\begin{array}{l} N =  \sum _{I: \; \texttt{mask} (I) \ne 0} 1 \\ M_c =  \left ( \sum _{I: \; \texttt{mask} (I) \ne 0}{ \texttt{mtx} (I)_c} \right )/N \end{array}\)
 When all the mask elements are 0's, the function returns Scalar::all(0)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array that should have from 1 to 4 channels so that the result can be stored in
 Scalar_ .
 SEE:  countNonZero, meanStdDev, norm, minMaxLoc</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="meanStdDev-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.MatOfDouble-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>meanStdDev</h4>
<pre>public static&nbsp;void&nbsp;meanStdDev(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                              <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;mean,
                              <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;stddev,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Calculates a mean and standard deviation of array elements.

 The function cv::meanStdDev calculates the mean and the standard deviation M
 of array elements independently for each channel and returns it via the
 output parameters:
 \(\begin{array}{l} N =  \sum _{I, \texttt{mask} (I)  \ne 0} 1 \\ \texttt{mean} _c =  \frac{\sum_{ I: \; \texttt{mask}(I) \ne 0} \texttt{src} (I)_c}{N} \\ \texttt{stddev} _c =  \sqrt{\frac{\sum_{ I: \; \texttt{mask}(I) \ne 0} \left ( \texttt{src} (I)_c -  \texttt{mean} _c \right )^2}{N}} \end{array}\)
 When all the mask elements are 0's, the function returns
 mean=stddev=Scalar::all(0).
 <b>Note:</b> The calculated standard deviation is only the diagonal of the
 complete normalized covariance matrix. If the full matrix is needed, you
 can reshape the multi-channel array M x N to the single-channel array
 M\*N x mtx.channels() (only possible when the matrix is continuous) and
 then pass the matrix to calcCovarMatrix .</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array that should have from 1 to 4 channels so that the results can be stored in
 Scalar_ 's.</dd>
<dd><code>mean</code> - output parameter: calculated mean value.</dd>
<dd><code>stddev</code> - output parameter: calculated standard deviation.</dd>
<dd><code>mask</code> - optional operation mask.
 SEE:  countNonZero, mean, norm, minMaxLoc, calcCovarMatrix</dd>
</dl>
</li>
</ul>
<a name="meanStdDev-org.opencv.core.Mat-org.opencv.core.MatOfDouble-org.opencv.core.MatOfDouble-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>meanStdDev</h4>
<pre>public static&nbsp;void&nbsp;meanStdDev(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                              <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;mean,
                              <a href="../../../org/opencv/core/MatOfDouble.html" title="class in org.opencv.core">MatOfDouble</a>&nbsp;stddev)</pre>
<div class="block">Calculates a mean and standard deviation of array elements.

 The function cv::meanStdDev calculates the mean and the standard deviation M
 of array elements independently for each channel and returns it via the
 output parameters:
 \(\begin{array}{l} N =  \sum _{I, \texttt{mask} (I)  \ne 0} 1 \\ \texttt{mean} _c =  \frac{\sum_{ I: \; \texttt{mask}(I) \ne 0} \texttt{src} (I)_c}{N} \\ \texttt{stddev} _c =  \sqrt{\frac{\sum_{ I: \; \texttt{mask}(I) \ne 0} \left ( \texttt{src} (I)_c -  \texttt{mean} _c \right )^2}{N}} \end{array}\)
 When all the mask elements are 0's, the function returns
 mean=stddev=Scalar::all(0).
 <b>Note:</b> The calculated standard deviation is only the diagonal of the
 complete normalized covariance matrix. If the full matrix is needed, you
 can reshape the multi-channel array M x N to the single-channel array
 M\*N x mtx.channels() (only possible when the matrix is continuous) and
 then pass the matrix to calcCovarMatrix .</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array that should have from 1 to 4 channels so that the results can be stored in
 Scalar_ 's.</dd>
<dd><code>mean</code> - output parameter: calculated mean value.</dd>
<dd><code>stddev</code> - output parameter: calculated standard deviation.
 SEE:  countNonZero, mean, norm, minMaxLoc, calcCovarMatrix</dd>
</dl>
</li>
</ul>
<a name="norm-org.opencv.core.Mat-int-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>norm</h4>
<pre>public static&nbsp;double&nbsp;norm(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                          int&nbsp;normType,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Calculates the  absolute norm of an array.

 This version of #norm calculates the absolute norm of src1. The type of norm to calculate is specified using #NormTypes.

 As example for one array consider the function \(r(x)= \begin{pmatrix} x \\ 1-x \end{pmatrix}, x \in [-1;1]\).
 The \( L_{1}, L_{2} \) and \( L_{\infty} \) norm for the sample value \(r(-1) = \begin{pmatrix} -1 \\ 2 \end{pmatrix}\)
 is calculated as follows
 \(align*}
     \| r(-1) \|_{L_1} &amp;= |-1| + |2| = 3 \\
     \| r(-1) \|_{L_2} &amp;= \sqrt{(-1)^{2} + (2)^{2}} = \sqrt{5} \\
     \| r(-1) \|_{L_\infty} &amp;= \max(|-1|,|2|) = 2
 \)
 and for \(r(0.5) = \begin{pmatrix} 0.5 \\ 0.5 \end{pmatrix}\) the calculation is
 \(align*}
     \| r(0.5) \|_{L_1} &amp;= |0.5| + |0.5| = 1 \\
     \| r(0.5) \|_{L_2} &amp;= \sqrt{(0.5)^{2} + (0.5)^{2}} = \sqrt{0.5} \\
     \| r(0.5) \|_{L_\infty} &amp;= \max(|0.5|,|0.5|) = 0.5.
 \)
 The following graphic shows all values for the three norm functions \(\| r(x) \|_{L_1}, \| r(x) \|_{L_2}\) and \(\| r(x) \|_{L_\infty}\).
 It is notable that the \( L_{1} \) norm forms the upper and the \( L_{\infty} \) norm forms the lower border for the example function \( r(x) \).
 ![Graphs for the different norm functions from the above example](pics/NormTypes_OneArray_1-2-INF.png)

 When the mask parameter is specified and it is not empty, the norm is

 If normType is not specified, #NORM_L2 is used.
 calculated only over the region specified by the mask.

 Multi-channel input arrays are treated as single-channel arrays, that is,
 the results for all channels are combined.

 Hamming norms can only be calculated with CV_8U depth arrays.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>normType</code> - type of the norm (see #NormTypes).</dd>
<dd><code>mask</code> - optional operation mask; it must have the same size as src1 and CV_8UC1 type.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="norm-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>norm</h4>
<pre>public static&nbsp;double&nbsp;norm(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                          int&nbsp;normType)</pre>
<div class="block">Calculates the  absolute norm of an array.

 This version of #norm calculates the absolute norm of src1. The type of norm to calculate is specified using #NormTypes.

 As example for one array consider the function \(r(x)= \begin{pmatrix} x \\ 1-x \end{pmatrix}, x \in [-1;1]\).
 The \( L_{1}, L_{2} \) and \( L_{\infty} \) norm for the sample value \(r(-1) = \begin{pmatrix} -1 \\ 2 \end{pmatrix}\)
 is calculated as follows
 \(align*}
     \| r(-1) \|_{L_1} &amp;= |-1| + |2| = 3 \\
     \| r(-1) \|_{L_2} &amp;= \sqrt{(-1)^{2} + (2)^{2}} = \sqrt{5} \\
     \| r(-1) \|_{L_\infty} &amp;= \max(|-1|,|2|) = 2
 \)
 and for \(r(0.5) = \begin{pmatrix} 0.5 \\ 0.5 \end{pmatrix}\) the calculation is
 \(align*}
     \| r(0.5) \|_{L_1} &amp;= |0.5| + |0.5| = 1 \\
     \| r(0.5) \|_{L_2} &amp;= \sqrt{(0.5)^{2} + (0.5)^{2}} = \sqrt{0.5} \\
     \| r(0.5) \|_{L_\infty} &amp;= \max(|0.5|,|0.5|) = 0.5.
 \)
 The following graphic shows all values for the three norm functions \(\| r(x) \|_{L_1}, \| r(x) \|_{L_2}\) and \(\| r(x) \|_{L_\infty}\).
 It is notable that the \( L_{1} \) norm forms the upper and the \( L_{\infty} \) norm forms the lower border for the example function \( r(x) \).
 ![Graphs for the different norm functions from the above example](pics/NormTypes_OneArray_1-2-INF.png)

 When the mask parameter is specified and it is not empty, the norm is

 If normType is not specified, #NORM_L2 is used.
 calculated only over the region specified by the mask.

 Multi-channel input arrays are treated as single-channel arrays, that is,
 the results for all channels are combined.

 Hamming norms can only be calculated with CV_8U depth arrays.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>normType</code> - type of the norm (see #NormTypes).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="norm-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>norm</h4>
<pre>public static&nbsp;double&nbsp;norm(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1)</pre>
<div class="block">Calculates the  absolute norm of an array.

 This version of #norm calculates the absolute norm of src1. The type of norm to calculate is specified using #NormTypes.

 As example for one array consider the function \(r(x)= \begin{pmatrix} x \\ 1-x \end{pmatrix}, x \in [-1;1]\).
 The \( L_{1}, L_{2} \) and \( L_{\infty} \) norm for the sample value \(r(-1) = \begin{pmatrix} -1 \\ 2 \end{pmatrix}\)
 is calculated as follows
 \(align*}
     \| r(-1) \|_{L_1} &amp;= |-1| + |2| = 3 \\
     \| r(-1) \|_{L_2} &amp;= \sqrt{(-1)^{2} + (2)^{2}} = \sqrt{5} \\
     \| r(-1) \|_{L_\infty} &amp;= \max(|-1|,|2|) = 2
 \)
 and for \(r(0.5) = \begin{pmatrix} 0.5 \\ 0.5 \end{pmatrix}\) the calculation is
 \(align*}
     \| r(0.5) \|_{L_1} &amp;= |0.5| + |0.5| = 1 \\
     \| r(0.5) \|_{L_2} &amp;= \sqrt{(0.5)^{2} + (0.5)^{2}} = \sqrt{0.5} \\
     \| r(0.5) \|_{L_\infty} &amp;= \max(|0.5|,|0.5|) = 0.5.
 \)
 The following graphic shows all values for the three norm functions \(\| r(x) \|_{L_1}, \| r(x) \|_{L_2}\) and \(\| r(x) \|_{L_\infty}\).
 It is notable that the \( L_{1} \) norm forms the upper and the \( L_{\infty} \) norm forms the lower border for the example function \( r(x) \).
 ![Graphs for the different norm functions from the above example](pics/NormTypes_OneArray_1-2-INF.png)

 When the mask parameter is specified and it is not empty, the norm is

 If normType is not specified, #NORM_L2 is used.
 calculated only over the region specified by the mask.

 Multi-channel input arrays are treated as single-channel arrays, that is,
 the results for all channels are combined.

 Hamming norms can only be calculated with CV_8U depth arrays.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="norm-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>norm</h4>
<pre>public static&nbsp;double&nbsp;norm(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                          int&nbsp;normType,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Calculates an absolute difference norm or a relative difference norm.

 This version of cv::norm calculates the absolute difference norm
 or the relative difference norm of arrays src1 and src2.
 The type of norm to calculate is specified using #NormTypes.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>src2</code> - second input array of the same size and the same type as src1.</dd>
<dd><code>normType</code> - type of the norm (see #NormTypes).</dd>
<dd><code>mask</code> - optional operation mask; it must have the same size as src1 and CV_8UC1 type.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="norm-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>norm</h4>
<pre>public static&nbsp;double&nbsp;norm(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                          int&nbsp;normType)</pre>
<div class="block">Calculates an absolute difference norm or a relative difference norm.

 This version of cv::norm calculates the absolute difference norm
 or the relative difference norm of arrays src1 and src2.
 The type of norm to calculate is specified using #NormTypes.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>src2</code> - second input array of the same size and the same type as src1.</dd>
<dd><code>normType</code> - type of the norm (see #NormTypes).</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="norm-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>norm</h4>
<pre>public static&nbsp;double&nbsp;norm(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2)</pre>
<div class="block">Calculates an absolute difference norm or a relative difference norm.

 This version of cv::norm calculates the absolute difference norm
 or the relative difference norm of arrays src1 and src2.
 The type of norm to calculate is specified using #NormTypes.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>src2</code> - second input array of the same size and the same type as src1.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="PSNR-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PSNR</h4>
<pre>public static&nbsp;double&nbsp;PSNR(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                          double&nbsp;R)</pre>
<div class="block">Computes the Peak Signal-to-Noise Ratio (PSNR) image quality metric.

 This function calculates the Peak Signal-to-Noise Ratio (PSNR) image quality metric in decibels (dB),
 between two input arrays src1 and src2. The arrays must have the same type.

 The PSNR is calculated as follows:

 \(
 \texttt{PSNR} = 10 \cdot \log_{10}{\left( \frac{R^2}{MSE} \right) }
 \)

 where R is the maximum integer value of depth (e.g. 255 in the case of CV_8U data)
 and MSE is the mean squared error between the two arrays.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>src2</code> - second input array of the same size as src1.</dd>
<dd><code>R</code> - the maximum pixel value (255 by default)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="PSNR-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PSNR</h4>
<pre>public static&nbsp;double&nbsp;PSNR(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2)</pre>
<div class="block">Computes the Peak Signal-to-Noise Ratio (PSNR) image quality metric.

 This function calculates the Peak Signal-to-Noise Ratio (PSNR) image quality metric in decibels (dB),
 between two input arrays src1 and src2. The arrays must have the same type.

 The PSNR is calculated as follows:

 \(
 \texttt{PSNR} = 10 \cdot \log_{10}{\left( \frac{R^2}{MSE} \right) }
 \)

 where R is the maximum integer value of depth (e.g. 255 in the case of CV_8U data)
 and MSE is the mean squared error between the two arrays.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>src2</code> - second input array of the same size as src1.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="batchDistance-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-int-int-org.opencv.core.Mat-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>batchDistance</h4>
<pre>public static&nbsp;void&nbsp;batchDistance(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist,
                                 int&nbsp;dtype,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nidx,
                                 int&nbsp;normType,
                                 int&nbsp;K,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                 int&nbsp;update,
                                 boolean&nbsp;crosscheck)</pre>
<div class="block">naive nearest neighbor finder

 see http://en.wikipedia.org/wiki/Nearest_neighbor_search
 TODO: document</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - automatically generated</dd>
<dd><code>src2</code> - automatically generated</dd>
<dd><code>dist</code> - automatically generated</dd>
<dd><code>dtype</code> - automatically generated</dd>
<dd><code>nidx</code> - automatically generated</dd>
<dd><code>normType</code> - automatically generated</dd>
<dd><code>K</code> - automatically generated</dd>
<dd><code>mask</code> - automatically generated</dd>
<dd><code>update</code> - automatically generated</dd>
<dd><code>crosscheck</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="batchDistance-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-int-int-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>batchDistance</h4>
<pre>public static&nbsp;void&nbsp;batchDistance(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist,
                                 int&nbsp;dtype,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nidx,
                                 int&nbsp;normType,
                                 int&nbsp;K,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                                 int&nbsp;update)</pre>
<div class="block">naive nearest neighbor finder

 see http://en.wikipedia.org/wiki/Nearest_neighbor_search
 TODO: document</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - automatically generated</dd>
<dd><code>src2</code> - automatically generated</dd>
<dd><code>dist</code> - automatically generated</dd>
<dd><code>dtype</code> - automatically generated</dd>
<dd><code>nidx</code> - automatically generated</dd>
<dd><code>normType</code> - automatically generated</dd>
<dd><code>K</code> - automatically generated</dd>
<dd><code>mask</code> - automatically generated</dd>
<dd><code>update</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="batchDistance-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-int-int-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>batchDistance</h4>
<pre>public static&nbsp;void&nbsp;batchDistance(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist,
                                 int&nbsp;dtype,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nidx,
                                 int&nbsp;normType,
                                 int&nbsp;K,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">naive nearest neighbor finder

 see http://en.wikipedia.org/wiki/Nearest_neighbor_search
 TODO: document</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - automatically generated</dd>
<dd><code>src2</code> - automatically generated</dd>
<dd><code>dist</code> - automatically generated</dd>
<dd><code>dtype</code> - automatically generated</dd>
<dd><code>nidx</code> - automatically generated</dd>
<dd><code>normType</code> - automatically generated</dd>
<dd><code>K</code> - automatically generated</dd>
<dd><code>mask</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="batchDistance-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>batchDistance</h4>
<pre>public static&nbsp;void&nbsp;batchDistance(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist,
                                 int&nbsp;dtype,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nidx,
                                 int&nbsp;normType,
                                 int&nbsp;K)</pre>
<div class="block">naive nearest neighbor finder

 see http://en.wikipedia.org/wiki/Nearest_neighbor_search
 TODO: document</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - automatically generated</dd>
<dd><code>src2</code> - automatically generated</dd>
<dd><code>dist</code> - automatically generated</dd>
<dd><code>dtype</code> - automatically generated</dd>
<dd><code>nidx</code> - automatically generated</dd>
<dd><code>normType</code> - automatically generated</dd>
<dd><code>K</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="batchDistance-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>batchDistance</h4>
<pre>public static&nbsp;void&nbsp;batchDistance(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist,
                                 int&nbsp;dtype,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nidx,
                                 int&nbsp;normType)</pre>
<div class="block">naive nearest neighbor finder

 see http://en.wikipedia.org/wiki/Nearest_neighbor_search
 TODO: document</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - automatically generated</dd>
<dd><code>src2</code> - automatically generated</dd>
<dd><code>dist</code> - automatically generated</dd>
<dd><code>dtype</code> - automatically generated</dd>
<dd><code>nidx</code> - automatically generated</dd>
<dd><code>normType</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="batchDistance-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>batchDistance</h4>
<pre>public static&nbsp;void&nbsp;batchDistance(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dist,
                                 int&nbsp;dtype,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;nidx)</pre>
<div class="block">naive nearest neighbor finder

 see http://en.wikipedia.org/wiki/Nearest_neighbor_search
 TODO: document</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - automatically generated</dd>
<dd><code>src2</code> - automatically generated</dd>
<dd><code>dist</code> - automatically generated</dd>
<dd><code>dtype</code> - automatically generated</dd>
<dd><code>nidx</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="normalize-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-int-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normalize</h4>
<pre>public static&nbsp;void&nbsp;normalize(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             double&nbsp;alpha,
                             double&nbsp;beta,
                             int&nbsp;norm_type,
                             int&nbsp;dtype,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Normalizes the norm or value range of an array.

 The function cv::normalize normalizes scale and shift the input array elements so that
 \(\| \texttt{dst} \| _{L_p}= \texttt{alpha}\)
 (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that
 \(\min _I  \texttt{dst} (I)= \texttt{alpha} , \, \, \max _I  \texttt{dst} (I)= \texttt{beta}\)

 when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be
 normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this
 sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or
 min-max but modify the whole array, you can use norm and Mat::convertTo.

 In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this,
 the range transformation for sparse matrices is not allowed since it can shift the zero level.

 Possible usage with some positive example data:
 <code>
     vector&lt;double&gt; positiveData = { 2.0, 8.0, 10.0 };
     vector&lt;double&gt; normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;

     // Norm to probability (total count)
     // sum(numbers) = 20.0
     // 2.0      0.1     (2.0/20.0)
     // 8.0      0.4     (8.0/20.0)
     // 10.0     0.5     (10.0/20.0)
     normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);

     // Norm to unit vector: ||positiveData|| = 1.0
     // 2.0      0.15
     // 8.0      0.62
     // 10.0     0.77
     normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);

     // Norm to max element
     // 2.0      0.2     (2.0/10.0)
     // 8.0      0.8     (8.0/10.0)
     // 10.0     1.0     (10.0/10.0)
     normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);

     // Norm to range [0.0;1.0]
     // 2.0      0.0     (shift to left border)
     // 8.0      0.75    (6.0/8.0)
     // 10.0     1.0     (shift to right border)
     normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX);
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>dst</code> - output array of the same size as src .</dd>
<dd><code>alpha</code> - norm value to normalize to or the lower range boundary in case of the range
 normalization.</dd>
<dd><code>beta</code> - upper range boundary in case of the range normalization; it is not used for the norm
 normalization.</dd>
<dd><code>norm_type</code> - normalization type (see cv::NormTypes).</dd>
<dd><code>dtype</code> - when negative, the output array has the same type as src; otherwise, it has the same
 number of channels as src and the depth =CV_MAT_DEPTH(dtype).</dd>
<dd><code>mask</code> - optional operation mask.
 SEE: norm, Mat::convertTo, SparseMat::convertTo</dd>
</dl>
</li>
</ul>
<a name="normalize-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normalize</h4>
<pre>public static&nbsp;void&nbsp;normalize(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             double&nbsp;alpha,
                             double&nbsp;beta,
                             int&nbsp;norm_type,
                             int&nbsp;dtype)</pre>
<div class="block">Normalizes the norm or value range of an array.

 The function cv::normalize normalizes scale and shift the input array elements so that
 \(\| \texttt{dst} \| _{L_p}= \texttt{alpha}\)
 (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that
 \(\min _I  \texttt{dst} (I)= \texttt{alpha} , \, \, \max _I  \texttt{dst} (I)= \texttt{beta}\)

 when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be
 normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this
 sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or
 min-max but modify the whole array, you can use norm and Mat::convertTo.

 In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this,
 the range transformation for sparse matrices is not allowed since it can shift the zero level.

 Possible usage with some positive example data:
 <code>
     vector&lt;double&gt; positiveData = { 2.0, 8.0, 10.0 };
     vector&lt;double&gt; normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;

     // Norm to probability (total count)
     // sum(numbers) = 20.0
     // 2.0      0.1     (2.0/20.0)
     // 8.0      0.4     (8.0/20.0)
     // 10.0     0.5     (10.0/20.0)
     normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);

     // Norm to unit vector: ||positiveData|| = 1.0
     // 2.0      0.15
     // 8.0      0.62
     // 10.0     0.77
     normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);

     // Norm to max element
     // 2.0      0.2     (2.0/10.0)
     // 8.0      0.8     (8.0/10.0)
     // 10.0     1.0     (10.0/10.0)
     normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);

     // Norm to range [0.0;1.0]
     // 2.0      0.0     (shift to left border)
     // 8.0      0.75    (6.0/8.0)
     // 10.0     1.0     (shift to right border)
     normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX);
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>dst</code> - output array of the same size as src .</dd>
<dd><code>alpha</code> - norm value to normalize to or the lower range boundary in case of the range
 normalization.</dd>
<dd><code>beta</code> - upper range boundary in case of the range normalization; it is not used for the norm
 normalization.</dd>
<dd><code>norm_type</code> - normalization type (see cv::NormTypes).</dd>
<dd><code>dtype</code> - when negative, the output array has the same type as src; otherwise, it has the same
 number of channels as src and the depth =CV_MAT_DEPTH(dtype).
 SEE: norm, Mat::convertTo, SparseMat::convertTo</dd>
</dl>
</li>
</ul>
<a name="normalize-org.opencv.core.Mat-org.opencv.core.Mat-double-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normalize</h4>
<pre>public static&nbsp;void&nbsp;normalize(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             double&nbsp;alpha,
                             double&nbsp;beta,
                             int&nbsp;norm_type)</pre>
<div class="block">Normalizes the norm or value range of an array.

 The function cv::normalize normalizes scale and shift the input array elements so that
 \(\| \texttt{dst} \| _{L_p}= \texttt{alpha}\)
 (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that
 \(\min _I  \texttt{dst} (I)= \texttt{alpha} , \, \, \max _I  \texttt{dst} (I)= \texttt{beta}\)

 when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be
 normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this
 sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or
 min-max but modify the whole array, you can use norm and Mat::convertTo.

 In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this,
 the range transformation for sparse matrices is not allowed since it can shift the zero level.

 Possible usage with some positive example data:
 <code>
     vector&lt;double&gt; positiveData = { 2.0, 8.0, 10.0 };
     vector&lt;double&gt; normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;

     // Norm to probability (total count)
     // sum(numbers) = 20.0
     // 2.0      0.1     (2.0/20.0)
     // 8.0      0.4     (8.0/20.0)
     // 10.0     0.5     (10.0/20.0)
     normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);

     // Norm to unit vector: ||positiveData|| = 1.0
     // 2.0      0.15
     // 8.0      0.62
     // 10.0     0.77
     normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);

     // Norm to max element
     // 2.0      0.2     (2.0/10.0)
     // 8.0      0.8     (8.0/10.0)
     // 10.0     1.0     (10.0/10.0)
     normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);

     // Norm to range [0.0;1.0]
     // 2.0      0.0     (shift to left border)
     // 8.0      0.75    (6.0/8.0)
     // 10.0     1.0     (shift to right border)
     normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX);
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>dst</code> - output array of the same size as src .</dd>
<dd><code>alpha</code> - norm value to normalize to or the lower range boundary in case of the range
 normalization.</dd>
<dd><code>beta</code> - upper range boundary in case of the range normalization; it is not used for the norm
 normalization.</dd>
<dd><code>norm_type</code> - normalization type (see cv::NormTypes).
 number of channels as src and the depth =CV_MAT_DEPTH(dtype).
 SEE: norm, Mat::convertTo, SparseMat::convertTo</dd>
</dl>
</li>
</ul>
<a name="normalize-org.opencv.core.Mat-org.opencv.core.Mat-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normalize</h4>
<pre>public static&nbsp;void&nbsp;normalize(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             double&nbsp;alpha,
                             double&nbsp;beta)</pre>
<div class="block">Normalizes the norm or value range of an array.

 The function cv::normalize normalizes scale and shift the input array elements so that
 \(\| \texttt{dst} \| _{L_p}= \texttt{alpha}\)
 (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that
 \(\min _I  \texttt{dst} (I)= \texttt{alpha} , \, \, \max _I  \texttt{dst} (I)= \texttt{beta}\)

 when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be
 normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this
 sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or
 min-max but modify the whole array, you can use norm and Mat::convertTo.

 In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this,
 the range transformation for sparse matrices is not allowed since it can shift the zero level.

 Possible usage with some positive example data:
 <code>
     vector&lt;double&gt; positiveData = { 2.0, 8.0, 10.0 };
     vector&lt;double&gt; normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;

     // Norm to probability (total count)
     // sum(numbers) = 20.0
     // 2.0      0.1     (2.0/20.0)
     // 8.0      0.4     (8.0/20.0)
     // 10.0     0.5     (10.0/20.0)
     normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);

     // Norm to unit vector: ||positiveData|| = 1.0
     // 2.0      0.15
     // 8.0      0.62
     // 10.0     0.77
     normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);

     // Norm to max element
     // 2.0      0.2     (2.0/10.0)
     // 8.0      0.8     (8.0/10.0)
     // 10.0     1.0     (10.0/10.0)
     normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);

     // Norm to range [0.0;1.0]
     // 2.0      0.0     (shift to left border)
     // 8.0      0.75    (6.0/8.0)
     // 10.0     1.0     (shift to right border)
     normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX);
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>dst</code> - output array of the same size as src .</dd>
<dd><code>alpha</code> - norm value to normalize to or the lower range boundary in case of the range
 normalization.</dd>
<dd><code>beta</code> - upper range boundary in case of the range normalization; it is not used for the norm
 normalization.
 number of channels as src and the depth =CV_MAT_DEPTH(dtype).
 SEE: norm, Mat::convertTo, SparseMat::convertTo</dd>
</dl>
</li>
</ul>
<a name="normalize-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normalize</h4>
<pre>public static&nbsp;void&nbsp;normalize(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             double&nbsp;alpha)</pre>
<div class="block">Normalizes the norm or value range of an array.

 The function cv::normalize normalizes scale and shift the input array elements so that
 \(\| \texttt{dst} \| _{L_p}= \texttt{alpha}\)
 (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that
 \(\min _I  \texttt{dst} (I)= \texttt{alpha} , \, \, \max _I  \texttt{dst} (I)= \texttt{beta}\)

 when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be
 normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this
 sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or
 min-max but modify the whole array, you can use norm and Mat::convertTo.

 In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this,
 the range transformation for sparse matrices is not allowed since it can shift the zero level.

 Possible usage with some positive example data:
 <code>
     vector&lt;double&gt; positiveData = { 2.0, 8.0, 10.0 };
     vector&lt;double&gt; normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;

     // Norm to probability (total count)
     // sum(numbers) = 20.0
     // 2.0      0.1     (2.0/20.0)
     // 8.0      0.4     (8.0/20.0)
     // 10.0     0.5     (10.0/20.0)
     normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);

     // Norm to unit vector: ||positiveData|| = 1.0
     // 2.0      0.15
     // 8.0      0.62
     // 10.0     0.77
     normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);

     // Norm to max element
     // 2.0      0.2     (2.0/10.0)
     // 8.0      0.8     (8.0/10.0)
     // 10.0     1.0     (10.0/10.0)
     normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);

     // Norm to range [0.0;1.0]
     // 2.0      0.0     (shift to left border)
     // 8.0      0.75    (6.0/8.0)
     // 10.0     1.0     (shift to right border)
     normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX);
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>dst</code> - output array of the same size as src .</dd>
<dd><code>alpha</code> - norm value to normalize to or the lower range boundary in case of the range
 normalization.
 normalization.
 number of channels as src and the depth =CV_MAT_DEPTH(dtype).
 SEE: norm, Mat::convertTo, SparseMat::convertTo</dd>
</dl>
</li>
</ul>
<a name="normalize-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normalize</h4>
<pre>public static&nbsp;void&nbsp;normalize(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Normalizes the norm or value range of an array.

 The function cv::normalize normalizes scale and shift the input array elements so that
 \(\| \texttt{dst} \| _{L_p}= \texttt{alpha}\)
 (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that
 \(\min _I  \texttt{dst} (I)= \texttt{alpha} , \, \, \max _I  \texttt{dst} (I)= \texttt{beta}\)

 when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be
 normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this
 sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or
 min-max but modify the whole array, you can use norm and Mat::convertTo.

 In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this,
 the range transformation for sparse matrices is not allowed since it can shift the zero level.

 Possible usage with some positive example data:
 <code>
     vector&lt;double&gt; positiveData = { 2.0, 8.0, 10.0 };
     vector&lt;double&gt; normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;

     // Norm to probability (total count)
     // sum(numbers) = 20.0
     // 2.0      0.1     (2.0/20.0)
     // 8.0      0.4     (8.0/20.0)
     // 10.0     0.5     (10.0/20.0)
     normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);

     // Norm to unit vector: ||positiveData|| = 1.0
     // 2.0      0.15
     // 8.0      0.62
     // 10.0     0.77
     normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);

     // Norm to max element
     // 2.0      0.2     (2.0/10.0)
     // 8.0      0.8     (8.0/10.0)
     // 10.0     1.0     (10.0/10.0)
     normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);

     // Norm to range [0.0;1.0]
     // 2.0      0.0     (shift to left border)
     // 8.0      0.75    (6.0/8.0)
     // 10.0     1.0     (shift to right border)
     normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX);
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>dst</code> - output array of the same size as src .
 normalization.
 normalization.
 number of channels as src and the depth =CV_MAT_DEPTH(dtype).
 SEE: norm, Mat::convertTo, SparseMat::convertTo</dd>
</dl>
</li>
</ul>
<a name="reduceArgMin-org.opencv.core.Mat-org.opencv.core.Mat-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduceArgMin</h4>
<pre>public static&nbsp;void&nbsp;reduceArgMin(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                int&nbsp;axis,
                                boolean&nbsp;lastIndex)</pre>
<div class="block">Finds indices of min elements along provided axis

 <b>Note:</b>
 - If input or output array is not continuous, this function will create an internal copy.
 - NaN handling is left unspecified, see patchNaNs().
 - The returned index is always in bounds of input matrix.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input single-channel array.</dd>
<dd><code>dst</code> - output array of type CV_32SC1 with the same dimensionality as src,
 except for axis being reduced - it should be set to 1.</dd>
<dd><code>lastIndex</code> - whether to get the index of first or last occurrence of min.</dd>
<dd><code>axis</code> - axis to reduce along.
 SEE: reduceArgMax, minMaxLoc, min, max, compare, reduce</dd>
</dl>
</li>
</ul>
<a name="reduceArgMin-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduceArgMin</h4>
<pre>public static&nbsp;void&nbsp;reduceArgMin(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                int&nbsp;axis)</pre>
<div class="block">Finds indices of min elements along provided axis

 <b>Note:</b>
 - If input or output array is not continuous, this function will create an internal copy.
 - NaN handling is left unspecified, see patchNaNs().
 - The returned index is always in bounds of input matrix.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input single-channel array.</dd>
<dd><code>dst</code> - output array of type CV_32SC1 with the same dimensionality as src,
 except for axis being reduced - it should be set to 1.</dd>
<dd><code>axis</code> - axis to reduce along.
 SEE: reduceArgMax, minMaxLoc, min, max, compare, reduce</dd>
</dl>
</li>
</ul>
<a name="reduceArgMax-org.opencv.core.Mat-org.opencv.core.Mat-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduceArgMax</h4>
<pre>public static&nbsp;void&nbsp;reduceArgMax(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                int&nbsp;axis,
                                boolean&nbsp;lastIndex)</pre>
<div class="block">Finds indices of max elements along provided axis

 <b>Note:</b>
 - If input or output array is not continuous, this function will create an internal copy.
 - NaN handling is left unspecified, see patchNaNs().
 - The returned index is always in bounds of input matrix.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input single-channel array.</dd>
<dd><code>dst</code> - output array of type CV_32SC1 with the same dimensionality as src,
 except for axis being reduced - it should be set to 1.</dd>
<dd><code>lastIndex</code> - whether to get the index of first or last occurrence of max.</dd>
<dd><code>axis</code> - axis to reduce along.
 SEE: reduceArgMin, minMaxLoc, min, max, compare, reduce</dd>
</dl>
</li>
</ul>
<a name="reduceArgMax-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduceArgMax</h4>
<pre>public static&nbsp;void&nbsp;reduceArgMax(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                int&nbsp;axis)</pre>
<div class="block">Finds indices of max elements along provided axis

 <b>Note:</b>
 - If input or output array is not continuous, this function will create an internal copy.
 - NaN handling is left unspecified, see patchNaNs().
 - The returned index is always in bounds of input matrix.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input single-channel array.</dd>
<dd><code>dst</code> - output array of type CV_32SC1 with the same dimensionality as src,
 except for axis being reduced - it should be set to 1.</dd>
<dd><code>axis</code> - axis to reduce along.
 SEE: reduceArgMin, minMaxLoc, min, max, compare, reduce</dd>
</dl>
</li>
</ul>
<a name="reduce-org.opencv.core.Mat-org.opencv.core.Mat-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre>public static&nbsp;void&nbsp;reduce(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          int&nbsp;dim,
                          int&nbsp;rtype,
                          int&nbsp;dtype)</pre>
<div class="block">Reduces a matrix to a vector.

 The function #reduce reduces the matrix to a vector by treating the matrix rows/columns as a set of
 1D vectors and performing the specified operation on the vectors until a single row/column is
 obtained. For example, the function can be used to compute horizontal and vertical projections of a
 raster image. In case of #REDUCE_MAX and #REDUCE_MIN, the output image should have the same type as the source one.
 In case of #REDUCE_SUM, #REDUCE_SUM2 and #REDUCE_AVG, the output may have a larger element bit-depth to preserve accuracy.
 And multi-channel arrays are also supported in these two reduction modes.

 The following code demonstrates its usage for a single channel matrix.
 SNIPPET: snippets/core_reduce.cpp example

 And the following code demonstrates its usage for a two-channel matrix.
 SNIPPET: snippets/core_reduce.cpp example2</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input 2D matrix.</dd>
<dd><code>dst</code> - output vector. Its size and type is defined by dim and dtype parameters.</dd>
<dd><code>dim</code> - dimension index along which the matrix is reduced. 0 means that the matrix is reduced to
 a single row. 1 means that the matrix is reduced to a single column.</dd>
<dd><code>rtype</code> - reduction operation that could be one of #ReduceTypes</dd>
<dd><code>dtype</code> - when negative, the output vector will have the same type as the input matrix,
 otherwise, its type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), src.channels()).
 SEE: repeat, reduceArgMin, reduceArgMax</dd>
</dl>
</li>
</ul>
<a name="reduce-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre>public static&nbsp;void&nbsp;reduce(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          int&nbsp;dim,
                          int&nbsp;rtype)</pre>
<div class="block">Reduces a matrix to a vector.

 The function #reduce reduces the matrix to a vector by treating the matrix rows/columns as a set of
 1D vectors and performing the specified operation on the vectors until a single row/column is
 obtained. For example, the function can be used to compute horizontal and vertical projections of a
 raster image. In case of #REDUCE_MAX and #REDUCE_MIN, the output image should have the same type as the source one.
 In case of #REDUCE_SUM, #REDUCE_SUM2 and #REDUCE_AVG, the output may have a larger element bit-depth to preserve accuracy.
 And multi-channel arrays are also supported in these two reduction modes.

 The following code demonstrates its usage for a single channel matrix.
 SNIPPET: snippets/core_reduce.cpp example

 And the following code demonstrates its usage for a two-channel matrix.
 SNIPPET: snippets/core_reduce.cpp example2</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input 2D matrix.</dd>
<dd><code>dst</code> - output vector. Its size and type is defined by dim and dtype parameters.</dd>
<dd><code>dim</code> - dimension index along which the matrix is reduced. 0 means that the matrix is reduced to
 a single row. 1 means that the matrix is reduced to a single column.</dd>
<dd><code>rtype</code> - reduction operation that could be one of #ReduceTypes
 otherwise, its type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), src.channels()).
 SEE: repeat, reduceArgMin, reduceArgMax</dd>
</dl>
</li>
</ul>
<a name="merge-java.util.List-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge</h4>
<pre>public static&nbsp;void&nbsp;merge(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</a>&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;mv,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mv</code> - input vector of matrices to be merged; all the matrices in mv must have the same
 size and the same depth.</dd>
<dd><code>dst</code> - output array of the same size and the same depth as mv[0]; The number of channels will
 be the total number of channels in the matrix array.</dd>
</dl>
</li>
</ul>
<a name="split-org.opencv.core.Mat-java.util.List-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>split</h4>
<pre>public static&nbsp;void&nbsp;split(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
                         <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</a>&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;mv)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - input multi-channel array.</dd>
<dd><code>mv</code> - output vector of arrays; the arrays themselves are reallocated, if needed.</dd>
</dl>
</li>
</ul>
<a name="mixChannels-java.util.List-java.util.List-org.opencv.core.MatOfInt-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mixChannels</h4>
<pre>public static&nbsp;void&nbsp;mixChannels(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</a>&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;src,
                               <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</a>&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;dst,
                               <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;fromTo)</pre>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array or vector of matrices; all of the matrices must have the same size and the
 same depth.</dd>
<dd><code>dst</code> - output array or vector of matrices; all the matrices <b>must be allocated</b>; their size and
 depth must be the same as in src[0].</dd>
<dd><code>fromTo</code> - array of index pairs specifying which channels are copied and where; fromTo[k\*2] is
 a 0-based index of the input channel in src, fromTo[k\*2+1] is an index of the output channel in
 dst; the continuous channel numbering is used: the first input image channels are indexed from 0 to
 src[0].channels()-1, the second input image channels are indexed from src[0].channels() to
 src[0].channels() + src[1].channels()-1, and so on, the same scheme is used for the output image
 channels; as a special case, when fromTo[k\*2] is negative, the corresponding output channel is
 filled with zero .</dd>
</dl>
</li>
</ul>
<a name="extractChannel-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>extractChannel</h4>
<pre>public static&nbsp;void&nbsp;extractChannel(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                  int&nbsp;coi)</pre>
<div class="block">Extracts a single channel from src (coi is 0-based index)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array</dd>
<dd><code>dst</code> - output array</dd>
<dd><code>coi</code> - index of channel to extract
 SEE: mixChannels, split</dd>
</dl>
</li>
</ul>
<a name="insertChannel-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>insertChannel</h4>
<pre>public static&nbsp;void&nbsp;insertChannel(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                 int&nbsp;coi)</pre>
<div class="block">Inserts a single channel to dst (coi is 0-based index)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array</dd>
<dd><code>dst</code> - output array</dd>
<dd><code>coi</code> - index of channel for insertion
 SEE: mixChannels, merge</dd>
</dl>
</li>
</ul>
<a name="flip-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flip</h4>
<pre>public static&nbsp;void&nbsp;flip(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                        int&nbsp;flipCode)</pre>
<div class="block">Flips a 2D array around vertical, horizontal, or both axes.

 The function cv::flip flips the array in one of three different ways (row
 and column indices are 0-based):
 \(\texttt{dst} _{ij} =
 \left\{
 \begin{array}{l l}
 \texttt{src} _{\texttt{src.rows}-i-1,j} &amp; if\;  \texttt{flipCode} = 0 \\
 \texttt{src} _{i, \texttt{src.cols} -j-1} &amp; if\;  \texttt{flipCode} &gt; 0 \\
 \texttt{src} _{ \texttt{src.rows} -i-1, \texttt{src.cols} -j-1} &amp; if\; \texttt{flipCode} &lt; 0 \\
 \end{array}
 \right.\)
 The example scenarios of using the function are the following:
 Vertical flipping of the image (flipCode == 0) to switch between
     top-left and bottom-left image origin. This is a typical operation
     in video processing on Microsoft Windows\* OS.
 Horizontal flipping of the image with the subsequent horizontal
     shift and absolute difference calculation to check for a
     vertical-axis symmetry (flipCode &gt; 0).
 Simultaneous horizontal and vertical flipping of the image with
     the subsequent shift and absolute difference calculation to check
     for a central symmetry (flipCode &lt; 0).
 Reversing the order of point arrays (flipCode &gt; 0 or
     flipCode == 0).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>dst</code> - output array of the same size and type as src.</dd>
<dd><code>flipCode</code> - a flag to specify how to flip the array; 0 means
 flipping around the x-axis and positive value (for example, 1) means
 flipping around y-axis. Negative value (for example, -1) means flipping
 around both axes.
 SEE: transpose, repeat, completeSymm</dd>
</dl>
</li>
</ul>
<a name="flipND-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flipND</h4>
<pre>public static&nbsp;void&nbsp;flipND(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          int&nbsp;axis)</pre>
<div class="block">Flips a n-dimensional at given axis</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array</dd>
<dd><code>dst</code> - output array that has the same shape of src</dd>
<dd><code>axis</code> - axis that performs a flip on. 0 &lt;= axis &lt; src.dims.</dd>
</dl>
</li>
</ul>
<a name="broadcast-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>broadcast</h4>
<pre>public static&nbsp;void&nbsp;broadcast(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;shape,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Broadcast the given Mat to the given shape.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array</dd>
<dd><code>shape</code> - target shape. Should be a list of CV_32S numbers. Note that negative values are not supported.</dd>
<dd><code>dst</code> - output array that has the given shape</dd>
</dl>
</li>
</ul>
<a name="rotate-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rotate</h4>
<pre>public static&nbsp;void&nbsp;rotate(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          int&nbsp;rotateCode)</pre>
<div class="block">Rotates a 2D array in multiples of 90 degrees.
 The function cv::rotate rotates the array in one of three different ways:
 Rotate by 90 degrees clockwise (rotateCode = ROTATE_90_CLOCKWISE).
 Rotate by 180 degrees clockwise (rotateCode = ROTATE_180).
 Rotate by 270 degrees clockwise (rotateCode = ROTATE_90_COUNTERCLOCKWISE).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>dst</code> - output array of the same type as src.  The size is the same with ROTATE_180,
 and the rows and cols are switched for ROTATE_90_CLOCKWISE and ROTATE_90_COUNTERCLOCKWISE.</dd>
<dd><code>rotateCode</code> - an enum to specify how to rotate the array; see the enum #RotateFlags
 SEE: transpose, repeat, completeSymm, flip, RotateFlags</dd>
</dl>
</li>
</ul>
<a name="repeat-org.opencv.core.Mat-int-int-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeat</h4>
<pre>public static&nbsp;void&nbsp;repeat(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          int&nbsp;ny,
                          int&nbsp;nx,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Fills the output array with repeated copies of the input array.

 The function cv::repeat duplicates the input array one or more times along each of the two axes:
 \(\texttt{dst} _{ij}= \texttt{src} _{i\mod src.rows, \; j\mod src.cols }\)
 The second variant of the function is more convenient to use with REF: MatrixExpressions.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array to replicate.</dd>
<dd><code>ny</code> - Flag to specify how many times the <code>src</code> is repeated along the
 vertical axis.</dd>
<dd><code>nx</code> - Flag to specify how many times the <code>src</code> is repeated along the
 horizontal axis.</dd>
<dd><code>dst</code> - output array of the same type as <code>src</code>.
 SEE: cv::reduce</dd>
</dl>
</li>
</ul>
<a name="hconcat-java.util.List-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hconcat</h4>
<pre>public static&nbsp;void&nbsp;hconcat(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</a>&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;src,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block"><code>
     std::vector&lt;cv::Mat&gt; matrices = { cv::Mat(4, 1, CV_8UC1, cv::Scalar(1)),
                                       cv::Mat(4, 1, CV_8UC1, cv::Scalar(2)),
                                       cv::Mat(4, 1, CV_8UC1, cv::Scalar(3)),};

     cv::Mat out;
     cv::hconcat( matrices, out );
     //out:
     //[1, 2, 3;
     // 1, 2, 3;
     // 1, 2, 3;
     // 1, 2, 3]
  </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array or vector of matrices. all of the matrices must have the same number of rows and the same depth.</dd>
<dd><code>dst</code> - output array. It has the same number of rows and depth as the src, and the sum of cols of the src.
 same depth.</dd>
</dl>
</li>
</ul>
<a name="vconcat-java.util.List-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>vconcat</h4>
<pre>public static&nbsp;void&nbsp;vconcat(<a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true" title="class or interface in java.util">List</a>&lt;<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&gt;&nbsp;src,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block"><code>
     std::vector&lt;cv::Mat&gt; matrices = { cv::Mat(1, 4, CV_8UC1, cv::Scalar(1)),
                                       cv::Mat(1, 4, CV_8UC1, cv::Scalar(2)),
                                       cv::Mat(1, 4, CV_8UC1, cv::Scalar(3)),};

     cv::Mat out;
     cv::vconcat( matrices, out );
     //out:
     //[1,   1,   1,   1;
     // 2,   2,   2,   2;
     // 3,   3,   3,   3]
  </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array or vector of matrices. all of the matrices must have the same number of cols and the same depth</dd>
<dd><code>dst</code> - output array. It has the same number of cols and depth as the src, and the sum of rows of the src.
 same depth.</dd>
</dl>
</li>
</ul>
<a name="bitwise_and-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bitwise_and</h4>
<pre>public static&nbsp;void&nbsp;bitwise_and(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">computes bitwise conjunction of the two arrays (dst = src1 &amp; src2)
 Calculates the per-element bit-wise conjunction of two arrays or an
 array and a scalar.

 The function cv::bitwise_and calculates the per-element bit-wise logical conjunction for:
 Two arrays when src1 and src2 have the same size:
     \(\texttt{dst} (I) =  \texttt{src1} (I)  \wedge \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\)
 An array and a scalar when src2 is constructed from Scalar or has
     the same number of elements as <code>src1.channels()</code>:
     \(\texttt{dst} (I) =  \texttt{src1} (I)  \wedge \texttt{src2} \quad \texttt{if mask} (I) \ne0\)
 A scalar and an array when src1 is constructed from Scalar or has
     the same number of elements as <code>src2.channels()</code>:
     \(\texttt{dst} (I) =  \texttt{src1}  \wedge \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\)
 In case of floating-point arrays, their machine-specific bit
 representations (usually IEEE754-compliant) are used for the operation.
 In case of multi-channel arrays, each channel is processed
 independently. In the second and third cases above, the scalar is first
 converted to the array type.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array or a scalar.</dd>
<dd><code>src2</code> - second input array or a scalar.</dd>
<dd><code>dst</code> - output array that has the same size and type as the input
 arrays.</dd>
<dd><code>mask</code> - optional operation mask, 8-bit single channel array, that
 specifies elements of the output array to be changed.</dd>
</dl>
</li>
</ul>
<a name="bitwise_and-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bitwise_and</h4>
<pre>public static&nbsp;void&nbsp;bitwise_and(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">computes bitwise conjunction of the two arrays (dst = src1 &amp; src2)
 Calculates the per-element bit-wise conjunction of two arrays or an
 array and a scalar.

 The function cv::bitwise_and calculates the per-element bit-wise logical conjunction for:
 Two arrays when src1 and src2 have the same size:
     \(\texttt{dst} (I) =  \texttt{src1} (I)  \wedge \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\)
 An array and a scalar when src2 is constructed from Scalar or has
     the same number of elements as <code>src1.channels()</code>:
     \(\texttt{dst} (I) =  \texttt{src1} (I)  \wedge \texttt{src2} \quad \texttt{if mask} (I) \ne0\)
 A scalar and an array when src1 is constructed from Scalar or has
     the same number of elements as <code>src2.channels()</code>:
     \(\texttt{dst} (I) =  \texttt{src1}  \wedge \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\)
 In case of floating-point arrays, their machine-specific bit
 representations (usually IEEE754-compliant) are used for the operation.
 In case of multi-channel arrays, each channel is processed
 independently. In the second and third cases above, the scalar is first
 converted to the array type.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array or a scalar.</dd>
<dd><code>src2</code> - second input array or a scalar.</dd>
<dd><code>dst</code> - output array that has the same size and type as the input
 arrays.
 specifies elements of the output array to be changed.</dd>
</dl>
</li>
</ul>
<a name="bitwise_or-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bitwise_or</h4>
<pre>public static&nbsp;void&nbsp;bitwise_or(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Calculates the per-element bit-wise disjunction of two arrays or an
 array and a scalar.

 The function cv::bitwise_or calculates the per-element bit-wise logical disjunction for:
 Two arrays when src1 and src2 have the same size:
     \(\texttt{dst} (I) =  \texttt{src1} (I)  \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\)
 An array and a scalar when src2 is constructed from Scalar or has
     the same number of elements as <code>src1.channels()</code>:
     \(\texttt{dst} (I) =  \texttt{src1} (I)  \vee \texttt{src2} \quad \texttt{if mask} (I) \ne0\)
 A scalar and an array when src1 is constructed from Scalar or has
     the same number of elements as <code>src2.channels()</code>:
     \(\texttt{dst} (I) =  \texttt{src1}  \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\)
 In case of floating-point arrays, their machine-specific bit
 representations (usually IEEE754-compliant) are used for the operation.
 In case of multi-channel arrays, each channel is processed
 independently. In the second and third cases above, the scalar is first
 converted to the array type.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array or a scalar.</dd>
<dd><code>src2</code> - second input array or a scalar.</dd>
<dd><code>dst</code> - output array that has the same size and type as the input
 arrays.</dd>
<dd><code>mask</code> - optional operation mask, 8-bit single channel array, that
 specifies elements of the output array to be changed.</dd>
</dl>
</li>
</ul>
<a name="bitwise_or-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bitwise_or</h4>
<pre>public static&nbsp;void&nbsp;bitwise_or(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Calculates the per-element bit-wise disjunction of two arrays or an
 array and a scalar.

 The function cv::bitwise_or calculates the per-element bit-wise logical disjunction for:
 Two arrays when src1 and src2 have the same size:
     \(\texttt{dst} (I) =  \texttt{src1} (I)  \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\)
 An array and a scalar when src2 is constructed from Scalar or has
     the same number of elements as <code>src1.channels()</code>:
     \(\texttt{dst} (I) =  \texttt{src1} (I)  \vee \texttt{src2} \quad \texttt{if mask} (I) \ne0\)
 A scalar and an array when src1 is constructed from Scalar or has
     the same number of elements as <code>src2.channels()</code>:
     \(\texttt{dst} (I) =  \texttt{src1}  \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\)
 In case of floating-point arrays, their machine-specific bit
 representations (usually IEEE754-compliant) are used for the operation.
 In case of multi-channel arrays, each channel is processed
 independently. In the second and third cases above, the scalar is first
 converted to the array type.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array or a scalar.</dd>
<dd><code>src2</code> - second input array or a scalar.</dd>
<dd><code>dst</code> - output array that has the same size and type as the input
 arrays.
 specifies elements of the output array to be changed.</dd>
</dl>
</li>
</ul>
<a name="bitwise_xor-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bitwise_xor</h4>
<pre>public static&nbsp;void&nbsp;bitwise_xor(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Calculates the per-element bit-wise "exclusive or" operation on two
 arrays or an array and a scalar.

 The function cv::bitwise_xor calculates the per-element bit-wise logical "exclusive-or"
 operation for:
 Two arrays when src1 and src2 have the same size:
     \(\texttt{dst} (I) =  \texttt{src1} (I)  \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\)
 An array and a scalar when src2 is constructed from Scalar or has
     the same number of elements as <code>src1.channels()</code>:
     \(\texttt{dst} (I) =  \texttt{src1} (I)  \oplus \texttt{src2} \quad \texttt{if mask} (I) \ne0\)
 A scalar and an array when src1 is constructed from Scalar or has
     the same number of elements as <code>src2.channels()</code>:
     \(\texttt{dst} (I) =  \texttt{src1}  \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\)
 In case of floating-point arrays, their machine-specific bit
 representations (usually IEEE754-compliant) are used for the operation.
 In case of multi-channel arrays, each channel is processed
 independently. In the 2nd and 3rd cases above, the scalar is first
 converted to the array type.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array or a scalar.</dd>
<dd><code>src2</code> - second input array or a scalar.</dd>
<dd><code>dst</code> - output array that has the same size and type as the input
 arrays.</dd>
<dd><code>mask</code> - optional operation mask, 8-bit single channel array, that
 specifies elements of the output array to be changed.</dd>
</dl>
</li>
</ul>
<a name="bitwise_xor-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bitwise_xor</h4>
<pre>public static&nbsp;void&nbsp;bitwise_xor(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Calculates the per-element bit-wise "exclusive or" operation on two
 arrays or an array and a scalar.

 The function cv::bitwise_xor calculates the per-element bit-wise logical "exclusive-or"
 operation for:
 Two arrays when src1 and src2 have the same size:
     \(\texttt{dst} (I) =  \texttt{src1} (I)  \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\)
 An array and a scalar when src2 is constructed from Scalar or has
     the same number of elements as <code>src1.channels()</code>:
     \(\texttt{dst} (I) =  \texttt{src1} (I)  \oplus \texttt{src2} \quad \texttt{if mask} (I) \ne0\)
 A scalar and an array when src1 is constructed from Scalar or has
     the same number of elements as <code>src2.channels()</code>:
     \(\texttt{dst} (I) =  \texttt{src1}  \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0\)
 In case of floating-point arrays, their machine-specific bit
 representations (usually IEEE754-compliant) are used for the operation.
 In case of multi-channel arrays, each channel is processed
 independently. In the 2nd and 3rd cases above, the scalar is first
 converted to the array type.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array or a scalar.</dd>
<dd><code>src2</code> - second input array or a scalar.</dd>
<dd><code>dst</code> - output array that has the same size and type as the input
 arrays.
 specifies elements of the output array to be changed.</dd>
</dl>
</li>
</ul>
<a name="bitwise_not-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bitwise_not</h4>
<pre>public static&nbsp;void&nbsp;bitwise_not(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">Inverts every bit of an array.

 The function cv::bitwise_not calculates per-element bit-wise inversion of the input
 array:
 \(\texttt{dst} (I) =  \neg \texttt{src} (I)\)
 In case of a floating-point input array, its machine-specific bit
 representation (usually IEEE754-compliant) is used for the operation. In
 case of multi-channel arrays, each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>dst</code> - output array that has the same size and type as the input
 array.</dd>
<dd><code>mask</code> - optional operation mask, 8-bit single channel array, that
 specifies elements of the output array to be changed.</dd>
</dl>
</li>
</ul>
<a name="bitwise_not-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bitwise_not</h4>
<pre>public static&nbsp;void&nbsp;bitwise_not(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Inverts every bit of an array.

 The function cv::bitwise_not calculates per-element bit-wise inversion of the input
 array:
 \(\texttt{dst} (I) =  \neg \texttt{src} (I)\)
 In case of a floating-point input array, its machine-specific bit
 representation (usually IEEE754-compliant) is used for the operation. In
 case of multi-channel arrays, each channel is processed independently.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>dst</code> - output array that has the same size and type as the input
 array.
 specifies elements of the output array to be changed.</dd>
</dl>
</li>
</ul>
<a name="absdiff-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>absdiff</h4>
<pre>public static&nbsp;void&nbsp;absdiff(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Calculates the per-element absolute difference between two arrays or between an array and a scalar.

 The function cv::absdiff calculates:
 Absolute difference between two arrays when they have the same
     size and type:
     \(\texttt{dst}(I) =  \texttt{saturate} (| \texttt{src1}(I) -  \texttt{src2}(I)|)\)
 Absolute difference between an array and a scalar when the second
     array is constructed from Scalar or has as many elements as the
     number of channels in <code>src1</code>:
     \(\texttt{dst}(I) =  \texttt{saturate} (| \texttt{src1}(I) -  \texttt{src2} |)\)
 Absolute difference between a scalar and an array when the first
     array is constructed from Scalar or has as many elements as the
     number of channels in <code>src2</code>:
     \(\texttt{dst}(I) =  \texttt{saturate} (| \texttt{src1} -  \texttt{src2}(I) |)\)
     where I is a multi-dimensional index of array elements. In case of
     multi-channel arrays, each channel is processed independently.
 <b>Note:</b> Saturation is not applied when the arrays have the depth CV_32S.
 You may even get a negative value in the case of overflow.
 <b>Note:</b> (Python) Be careful to difference behaviour between src1/src2 are single number and they are tuple/array.
 <code>absdiff(src,X)</code> means <code>absdiff(src,(X,X,X,X))</code>.
 <code>absdiff(src,(X,))</code> means <code>absdiff(src,(X,0,0,0))</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array or a scalar.</dd>
<dd><code>src2</code> - second input array or a scalar.</dd>
<dd><code>dst</code> - output array that has the same size and type as input arrays.
 SEE: cv::abs(const Mat&amp;)</dd>
</dl>
</li>
</ul>
<a name="copyTo-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copyTo</h4>
<pre>public static&nbsp;void&nbsp;copyTo(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
<div class="block">This is an overloaded member function, provided for convenience (python)
 Copies the matrix to another one.
 When the operation mask is specified, if the Mat::create call shown above reallocates the matrix, the newly allocated matrix is initialized with all zeros before copying the data.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - source matrix.</dd>
<dd><code>dst</code> - Destination matrix. If it does not have a proper size or type before the operation, it is
 reallocated.</dd>
<dd><code>mask</code> - Operation mask of the same size as \*this. Its non-zero elements indicate which matrix
 elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels.</dd>
</dl>
</li>
</ul>
<a name="inRange-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Scalar-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inRange</h4>
<pre>public static&nbsp;void&nbsp;inRange(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;lowerb,
                           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;upperb,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Checks if array elements lie between the elements of two other arrays.

 The function checks the range as follows:
 <ul>
   <li>
    For every element of a single-channel input array:
     \(\texttt{dst} (I)= \texttt{lowerb} (I)_0  \leq \texttt{src} (I)_0 \leq  \texttt{upperb} (I)_0\)
   </li>
   <li>
    For two-channel arrays:
     \(\texttt{dst} (I)= \texttt{lowerb} (I)_0  \leq \texttt{src} (I)_0 \leq  \texttt{upperb} (I)_0  \land \texttt{lowerb} (I)_1  \leq \texttt{src} (I)_1 \leq  \texttt{upperb} (I)_1\)
   </li>
   <li>
    and so forth.
   </li>
 </ul>

 That is, dst (I) is set to 255 (all 1 -bits) if src (I) is within the
 specified 1D, 2D, 3D, ... box and 0 otherwise.

 When the lower and/or upper boundary parameters are scalars, the indexes
 (I) at lowerb and upperb in the above formulas should be omitted.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - first input array.</dd>
<dd><code>lowerb</code> - inclusive lower boundary array or a scalar.</dd>
<dd><code>upperb</code> - inclusive upper boundary array or a scalar.</dd>
<dd><code>dst</code> - output array of the same size as src and CV_8U type.</dd>
</dl>
</li>
</ul>
<a name="compare-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>compare</h4>
<pre>public static&nbsp;void&nbsp;compare(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                           int&nbsp;cmpop)</pre>
<div class="block">Performs the per-element comparison of two arrays or an array and scalar value.

 The function compares:
 Elements of two arrays when src1 and src2 have the same size:
     \(\texttt{dst} (I) =  \texttt{src1} (I)  \,\texttt{cmpop}\, \texttt{src2} (I)\)
 Elements of src1 with a scalar src2 when src2 is constructed from
     Scalar or has a single element:
     \(\texttt{dst} (I) =  \texttt{src1}(I) \,\texttt{cmpop}\,  \texttt{src2}\)
 src1 with elements of src2 when src1 is constructed from Scalar or
     has a single element:
     \(\texttt{dst} (I) =  \texttt{src1}  \,\texttt{cmpop}\, \texttt{src2} (I)\)
 When the comparison result is true, the corresponding element of output
 array is set to 255. The comparison operations can be replaced with the
 equivalent matrix expressions:
 <code>
     Mat dst1 = src1 &gt;= src2;
     Mat dst2 = src1 &lt; 8;
     ...
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array or a scalar; when it is an array, it must have a single channel.</dd>
<dd><code>src2</code> - second input array or a scalar; when it is an array, it must have a single channel.</dd>
<dd><code>dst</code> - output array of type ref CV_8U that has the same size and the same number of channels as
     the input arrays.</dd>
<dd><code>cmpop</code> - a flag, that specifies correspondence between the arrays (cv::CmpTypes)
 SEE: checkRange, min, max, threshold</dd>
</dl>
</li>
</ul>
<a name="min-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>min</h4>
<pre>public static&nbsp;void&nbsp;min(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Calculates per-element minimum of two arrays or an array and a scalar.

 The function cv::min calculates the per-element minimum of two arrays:
 \(\texttt{dst} (I)= \min ( \texttt{src1} (I), \texttt{src2} (I))\)
 or array and a scalar:
 \(\texttt{dst} (I)= \min ( \texttt{src1} (I), \texttt{value} )\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>src2</code> - second input array of the same size and type as src1.</dd>
<dd><code>dst</code> - output array of the same size and type as src1.
 SEE: max, compare, inRange, minMaxLoc</dd>
</dl>
</li>
</ul>
<a name="max-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>max</h4>
<pre>public static&nbsp;void&nbsp;max(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Calculates per-element maximum of two arrays or an array and a scalar.

 The function cv::max calculates the per-element maximum of two arrays:
 \(\texttt{dst} (I)= \max ( \texttt{src1} (I), \texttt{src2} (I))\)
 or array and a scalar:
 \(\texttt{dst} (I)= \max ( \texttt{src1} (I), \texttt{value} )\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first input array.</dd>
<dd><code>src2</code> - second input array of the same size and type as src1 .</dd>
<dd><code>dst</code> - output array of the same size and type as src1.
 SEE:  min, compare, inRange, minMaxLoc, REF: MatrixExpressions</dd>
</dl>
</li>
</ul>
<a name="sqrt-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sqrt</h4>
<pre>public static&nbsp;void&nbsp;sqrt(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Calculates a square root of array elements.

 The function cv::sqrt calculates a square root of each input array element.
 In case of multi-channel arrays, each channel is processed
 independently. The accuracy is approximately the same as of the built-in
 std::sqrt .</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input floating-point array.</dd>
<dd><code>dst</code> - output array of the same size and type as src.</dd>
</dl>
</li>
</ul>
<a name="pow-org.opencv.core.Mat-double-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pow</h4>
<pre>public static&nbsp;void&nbsp;pow(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                       double&nbsp;power,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Raises every array element to a power.

 The function cv::pow raises every element of the input array to power :
 \(\texttt{dst} (I) =  \fork{\texttt{src}(I)^{power}}{if \(\texttt{power}\) is integer}{|\texttt{src}(I)|^{power}}{otherwise}\)

 So, for a non-integer power exponent, the absolute values of input array
 elements are used. However, it is possible to get true values for
 negative values using some extra operations. In the example below,
 computing the 5th root of array src shows:
 <code>
     Mat mask = src &lt; 0;
     pow(src, 1./5, dst);
     subtract(Scalar::all(0), dst, dst, mask);
 </code>
 For some values of power, such as integer values, 0.5 and -0.5,
 specialized faster algorithms are used.

 Special values (NaN, Inf) are not handled.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>power</code> - exponent of power.</dd>
<dd><code>dst</code> - output array of the same size and type as src.
 SEE: sqrt, exp, log, cartToPolar, polarToCart</dd>
</dl>
</li>
</ul>
<a name="exp-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>exp</h4>
<pre>public static&nbsp;void&nbsp;exp(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Calculates the exponent of every array element.

 The function cv::exp calculates the exponent of every element of the input
 array:
 \(\texttt{dst} [I] = e^{ src(I) }\)

 The maximum relative error is about 7e-6 for single-precision input and
 less than 1e-10 for double-precision input. Currently, the function
 converts denormalized values to zeros on output. Special values (NaN,
 Inf) are not handled.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>dst</code> - output array of the same size and type as src.
 SEE: log, cartToPolar, polarToCart, phase, pow, sqrt, magnitude</dd>
</dl>
</li>
</ul>
<a name="log-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>log</h4>
<pre>public static&nbsp;void&nbsp;log(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Calculates the natural logarithm of every array element.

 The function cv::log calculates the natural logarithm of every element of the input array:
 \(\texttt{dst} (I) =  \log (\texttt{src}(I)) \)

 Output on zero, negative and special (NaN, Inf) values is undefined.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>dst</code> - output array of the same size and type as src .
 SEE: exp, cartToPolar, polarToCart, phase, pow, sqrt, magnitude</dd>
</dl>
</li>
</ul>
<a name="polarToCart-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>polarToCart</h4>
<pre>public static&nbsp;void&nbsp;polarToCart(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
                               boolean&nbsp;angleInDegrees)</pre>
<div class="block">Calculates x and y coordinates of 2D vectors from their magnitude and angle.

 The function cv::polarToCart calculates the Cartesian coordinates of each 2D
 vector represented by the corresponding elements of magnitude and angle:
 \(\begin{array}{l} \texttt{x} (I) =  \texttt{magnitude} (I) \cos ( \texttt{angle} (I)) \\ \texttt{y} (I) =  \texttt{magnitude} (I) \sin ( \texttt{angle} (I)) \\ \end{array}\)

 The relative accuracy of the estimated coordinates is about 1e-6.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>magnitude</code> - input floating-point array of magnitudes of 2D vectors;
 it can be an empty matrix (=Mat()), in this case, the function assumes
 that all the magnitudes are =1; if it is not empty, it must have the
 same size and type as angle.</dd>
<dd><code>angle</code> - input floating-point array of angles of 2D vectors.</dd>
<dd><code>x</code> - output array of x-coordinates of 2D vectors; it has the same
 size and type as angle.</dd>
<dd><code>y</code> - output array of y-coordinates of 2D vectors; it has the same
 size and type as angle.</dd>
<dd><code>angleInDegrees</code> - when true, the input angles are measured in
 degrees, otherwise, they are measured in radians.
 SEE: cartToPolar, magnitude, phase, exp, log, pow, sqrt</dd>
</dl>
</li>
</ul>
<a name="polarToCart-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>polarToCart</h4>
<pre>public static&nbsp;void&nbsp;polarToCart(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y)</pre>
<div class="block">Calculates x and y coordinates of 2D vectors from their magnitude and angle.

 The function cv::polarToCart calculates the Cartesian coordinates of each 2D
 vector represented by the corresponding elements of magnitude and angle:
 \(\begin{array}{l} \texttt{x} (I) =  \texttt{magnitude} (I) \cos ( \texttt{angle} (I)) \\ \texttt{y} (I) =  \texttt{magnitude} (I) \sin ( \texttt{angle} (I)) \\ \end{array}\)

 The relative accuracy of the estimated coordinates is about 1e-6.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>magnitude</code> - input floating-point array of magnitudes of 2D vectors;
 it can be an empty matrix (=Mat()), in this case, the function assumes
 that all the magnitudes are =1; if it is not empty, it must have the
 same size and type as angle.</dd>
<dd><code>angle</code> - input floating-point array of angles of 2D vectors.</dd>
<dd><code>x</code> - output array of x-coordinates of 2D vectors; it has the same
 size and type as angle.</dd>
<dd><code>y</code> - output array of y-coordinates of 2D vectors; it has the same
 size and type as angle.
 degrees, otherwise, they are measured in radians.
 SEE: cartToPolar, magnitude, phase, exp, log, pow, sqrt</dd>
</dl>
</li>
</ul>
<a name="cartToPolar-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cartToPolar</h4>
<pre>public static&nbsp;void&nbsp;cartToPolar(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle,
                               boolean&nbsp;angleInDegrees)</pre>
<div class="block">Calculates the magnitude and angle of 2D vectors.

 The function cv::cartToPolar calculates either the magnitude, angle, or both
 for every 2D vector (x(I),y(I)):
 \(\begin{array}{l} \texttt{magnitude} (I)= \sqrt{\texttt{x}(I)^2+\texttt{y}(I)^2} , \\ \texttt{angle} (I)= \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I))[ \cdot180 / \pi ] \end{array}\)

 The angles are calculated with accuracy about 0.3 degrees. For the point
 (0,0), the angle is set to 0.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - array of x-coordinates; this must be a single-precision or
 double-precision floating-point array.</dd>
<dd><code>y</code> - array of y-coordinates, that must have the same size and same type as x.</dd>
<dd><code>magnitude</code> - output array of magnitudes of the same size and type as x.</dd>
<dd><code>angle</code> - output array of angles that has the same size and type as
 x; the angles are measured in radians (from 0 to 2\*Pi) or in degrees (0 to 360 degrees).</dd>
<dd><code>angleInDegrees</code> - a flag, indicating whether the angles are measured
 in radians (which is by default), or in degrees.
 SEE: Sobel, Scharr</dd>
</dl>
</li>
</ul>
<a name="cartToPolar-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cartToPolar</h4>
<pre>public static&nbsp;void&nbsp;cartToPolar(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle)</pre>
<div class="block">Calculates the magnitude and angle of 2D vectors.

 The function cv::cartToPolar calculates either the magnitude, angle, or both
 for every 2D vector (x(I),y(I)):
 \(\begin{array}{l} \texttt{magnitude} (I)= \sqrt{\texttt{x}(I)^2+\texttt{y}(I)^2} , \\ \texttt{angle} (I)= \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I))[ \cdot180 / \pi ] \end{array}\)

 The angles are calculated with accuracy about 0.3 degrees. For the point
 (0,0), the angle is set to 0.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - array of x-coordinates; this must be a single-precision or
 double-precision floating-point array.</dd>
<dd><code>y</code> - array of y-coordinates, that must have the same size and same type as x.</dd>
<dd><code>magnitude</code> - output array of magnitudes of the same size and type as x.</dd>
<dd><code>angle</code> - output array of angles that has the same size and type as
 x; the angles are measured in radians (from 0 to 2\*Pi) or in degrees (0 to 360 degrees).
 in radians (which is by default), or in degrees.
 SEE: Sobel, Scharr</dd>
</dl>
</li>
</ul>
<a name="phase-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>phase</h4>
<pre>public static&nbsp;void&nbsp;phase(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle,
                         boolean&nbsp;angleInDegrees)</pre>
<div class="block">Calculates the rotation angle of 2D vectors.

 The function cv::phase calculates the rotation angle of each 2D vector that
 is formed from the corresponding elements of x and y :
 \(\texttt{angle} (I) =  \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I))\)

 The angle estimation accuracy is about 0.3 degrees. When x(I)=y(I)=0 ,
 the corresponding angle(I) is set to 0.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - input floating-point array of x-coordinates of 2D vectors.</dd>
<dd><code>y</code> - input array of y-coordinates of 2D vectors; it must have the
 same size and the same type as x.</dd>
<dd><code>angle</code> - output array of vector angles; it has the same size and
 same type as x .</dd>
<dd><code>angleInDegrees</code> - when true, the function calculates the angle in
 degrees, otherwise, they are measured in radians.</dd>
</dl>
</li>
</ul>
<a name="phase-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>phase</h4>
<pre>public static&nbsp;void&nbsp;phase(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
                         <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;angle)</pre>
<div class="block">Calculates the rotation angle of 2D vectors.

 The function cv::phase calculates the rotation angle of each 2D vector that
 is formed from the corresponding elements of x and y :
 \(\texttt{angle} (I) =  \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I))\)

 The angle estimation accuracy is about 0.3 degrees. When x(I)=y(I)=0 ,
 the corresponding angle(I) is set to 0.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - input floating-point array of x-coordinates of 2D vectors.</dd>
<dd><code>y</code> - input array of y-coordinates of 2D vectors; it must have the
 same size and the same type as x.</dd>
<dd><code>angle</code> - output array of vector angles; it has the same size and
 same type as x .
 degrees, otherwise, they are measured in radians.</dd>
</dl>
</li>
</ul>
<a name="magnitude-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>magnitude</h4>
<pre>public static&nbsp;void&nbsp;magnitude(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;x,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;y,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;magnitude)</pre>
<div class="block">Calculates the magnitude of 2D vectors.

 The function cv::magnitude calculates the magnitude of 2D vectors formed
 from the corresponding elements of x and y arrays:
 \(\texttt{dst} (I) =  \sqrt{\texttt{x}(I)^2 + \texttt{y}(I)^2}\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - floating-point array of x-coordinates of the vectors.</dd>
<dd><code>y</code> - floating-point array of y-coordinates of the vectors; it must
 have the same size as x.</dd>
<dd><code>magnitude</code> - output array of the same size and type as x.
 SEE: cartToPolar, polarToCart, phase, sqrt</dd>
</dl>
</li>
</ul>
<a name="checkRange-org.opencv.core.Mat-boolean-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkRange</h4>
<pre>public static&nbsp;boolean&nbsp;checkRange(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
                                 boolean&nbsp;quiet,
                                 double&nbsp;minVal,
                                 double&nbsp;maxVal)</pre>
<div class="block">Checks every element of an input array for invalid values.

 The function cv::checkRange checks that every array element is neither NaN nor infinite. When minVal &gt;
 <ul>
   <li>
 DBL_MAX and maxVal &lt; DBL_MAX, the function also checks that each value is between minVal and
 maxVal. In case of multi-channel arrays, each channel is processed independently. If some values
 are out of range, position of the first outlier is stored in pos (when pos != NULL). Then, the
 function either returns false (when quiet=true) or throws an exception.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - input array.</dd>
<dd><code>quiet</code> - a flag, indicating whether the functions quietly return false when the array elements
 are out of range or they throw an exception.
 elements.</dd>
<dd><code>minVal</code> - inclusive lower boundary of valid values range.</dd>
<dd><code>maxVal</code> - exclusive upper boundary of valid values range.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="checkRange-org.opencv.core.Mat-boolean-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkRange</h4>
<pre>public static&nbsp;boolean&nbsp;checkRange(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
                                 boolean&nbsp;quiet,
                                 double&nbsp;minVal)</pre>
<div class="block">Checks every element of an input array for invalid values.

 The function cv::checkRange checks that every array element is neither NaN nor infinite. When minVal &gt;
 <ul>
   <li>
 DBL_MAX and maxVal &lt; DBL_MAX, the function also checks that each value is between minVal and
 maxVal. In case of multi-channel arrays, each channel is processed independently. If some values
 are out of range, position of the first outlier is stored in pos (when pos != NULL). Then, the
 function either returns false (when quiet=true) or throws an exception.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - input array.</dd>
<dd><code>quiet</code> - a flag, indicating whether the functions quietly return false when the array elements
 are out of range or they throw an exception.
 elements.</dd>
<dd><code>minVal</code> - inclusive lower boundary of valid values range.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="checkRange-org.opencv.core.Mat-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkRange</h4>
<pre>public static&nbsp;boolean&nbsp;checkRange(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
                                 boolean&nbsp;quiet)</pre>
<div class="block">Checks every element of an input array for invalid values.

 The function cv::checkRange checks that every array element is neither NaN nor infinite. When minVal &gt;
 <ul>
   <li>
 DBL_MAX and maxVal &lt; DBL_MAX, the function also checks that each value is between minVal and
 maxVal. In case of multi-channel arrays, each channel is processed independently. If some values
 are out of range, position of the first outlier is stored in pos (when pos != NULL). Then, the
 function either returns false (when quiet=true) or throws an exception.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - input array.</dd>
<dd><code>quiet</code> - a flag, indicating whether the functions quietly return false when the array elements
 are out of range or they throw an exception.
 elements.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="checkRange-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkRange</h4>
<pre>public static&nbsp;boolean&nbsp;checkRange(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a)</pre>
<div class="block">Checks every element of an input array for invalid values.

 The function cv::checkRange checks that every array element is neither NaN nor infinite. When minVal &gt;
 <ul>
   <li>
 DBL_MAX and maxVal &lt; DBL_MAX, the function also checks that each value is between minVal and
 maxVal. In case of multi-channel arrays, each channel is processed independently. If some values
 are out of range, position of the first outlier is stored in pos (when pos != NULL). Then, the
 function either returns false (when quiet=true) or throws an exception.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - input array.
 are out of range or they throw an exception.
 elements.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="patchNaNs-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>patchNaNs</h4>
<pre>public static&nbsp;void&nbsp;patchNaNs(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
                             double&nbsp;val)</pre>
<div class="block">Replaces NaNs by given number</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - input/output matrix (CV_32F type).</dd>
<dd><code>val</code> - value to convert the NaNs</dd>
</dl>
</li>
</ul>
<a name="patchNaNs-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>patchNaNs</h4>
<pre>public static&nbsp;void&nbsp;patchNaNs(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a)</pre>
<div class="block">Replaces NaNs by given number</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - input/output matrix (CV_32F type).</dd>
</dl>
</li>
</ul>
<a name="gemm-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Mat-double-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>gemm</h4>
<pre>public static&nbsp;void&nbsp;gemm(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                        double&nbsp;alpha,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src3,
                        double&nbsp;beta,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                        int&nbsp;flags)</pre>
<div class="block">Performs generalized matrix multiplication.

 The function cv::gemm performs generalized matrix multiplication similar to the
 gemm functions in BLAS level 3. For example,
 <code>gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T)</code>
 corresponds to
 \(\texttt{dst} =  \texttt{alpha} \cdot \texttt{src1} ^T  \cdot \texttt{src2} +  \texttt{beta} \cdot \texttt{src3} ^T\)

 In case of complex (two-channel) data, performed a complex matrix
 multiplication.

 The function can be replaced with a matrix expression. For example, the
 above call can be replaced with:
 <code>
     dst = alpha*src1.t()*src2 + beta*src3.t();
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first multiplied input matrix that could be real(CV_32FC1,
 CV_64FC1) or complex(CV_32FC2, CV_64FC2).</dd>
<dd><code>src2</code> - second multiplied input matrix of the same type as src1.</dd>
<dd><code>alpha</code> - weight of the matrix product.</dd>
<dd><code>src3</code> - third optional delta matrix added to the matrix product; it
 should have the same type as src1 and src2.</dd>
<dd><code>beta</code> - weight of src3.</dd>
<dd><code>dst</code> - output matrix; it has the proper size and the same type as
 input matrices.</dd>
<dd><code>flags</code> - operation flags (cv::GemmFlags)
 SEE: mulTransposed, transform</dd>
</dl>
</li>
</ul>
<a name="gemm-org.opencv.core.Mat-org.opencv.core.Mat-double-org.opencv.core.Mat-double-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>gemm</h4>
<pre>public static&nbsp;void&nbsp;gemm(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                        double&nbsp;alpha,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src3,
                        double&nbsp;beta,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Performs generalized matrix multiplication.

 The function cv::gemm performs generalized matrix multiplication similar to the
 gemm functions in BLAS level 3. For example,
 <code>gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T)</code>
 corresponds to
 \(\texttt{dst} =  \texttt{alpha} \cdot \texttt{src1} ^T  \cdot \texttt{src2} +  \texttt{beta} \cdot \texttt{src3} ^T\)

 In case of complex (two-channel) data, performed a complex matrix
 multiplication.

 The function can be replaced with a matrix expression. For example, the
 above call can be replaced with:
 <code>
     dst = alpha*src1.t()*src2 + beta*src3.t();
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - first multiplied input matrix that could be real(CV_32FC1,
 CV_64FC1) or complex(CV_32FC2, CV_64FC2).</dd>
<dd><code>src2</code> - second multiplied input matrix of the same type as src1.</dd>
<dd><code>alpha</code> - weight of the matrix product.</dd>
<dd><code>src3</code> - third optional delta matrix added to the matrix product; it
 should have the same type as src1 and src2.</dd>
<dd><code>beta</code> - weight of src3.</dd>
<dd><code>dst</code> - output matrix; it has the proper size and the same type as
 input matrices.
 SEE: mulTransposed, transform</dd>
</dl>
</li>
</ul>
<a name="mulTransposed-org.opencv.core.Mat-org.opencv.core.Mat-boolean-org.opencv.core.Mat-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mulTransposed</h4>
<pre>public static&nbsp;void&nbsp;mulTransposed(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                 boolean&nbsp;aTa,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;delta,
                                 double&nbsp;scale,
                                 int&nbsp;dtype)</pre>
<div class="block">Calculates the product of a matrix and its transposition.

 The function cv::mulTransposed calculates the product of src and its
 transposition:
 \(\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} )^T ( \texttt{src} - \texttt{delta} )\)
 if aTa=true, and
 \(\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} ) ( \texttt{src} - \texttt{delta} )^T\)
 otherwise. The function is used to calculate the covariance matrix. With
 zero delta, it can be used as a faster substitute for general matrix
 product A\*B when B=A'</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input single-channel matrix. Note that unlike gemm, the
 function can multiply not only floating-point matrices.</dd>
<dd><code>dst</code> - output square matrix.</dd>
<dd><code>aTa</code> - Flag specifying the multiplication ordering. See the
 description below.</dd>
<dd><code>delta</code> - Optional delta matrix subtracted from src before the
 multiplication. When the matrix is empty ( delta=noArray() ), it is
 assumed to be zero, that is, nothing is subtracted. If it has the same
 size as src, it is simply subtracted. Otherwise, it is "repeated" (see
 repeat ) to cover the full src and then subtracted. Type of the delta
 matrix, when it is not empty, must be the same as the type of created
 output matrix. See the dtype parameter description below.</dd>
<dd><code>scale</code> - Optional scale factor for the matrix product.</dd>
<dd><code>dtype</code> - Optional type of the output matrix. When it is negative,
 the output matrix will have the same type as src . Otherwise, it will be
 type=CV_MAT_DEPTH(dtype) that should be either CV_32F or CV_64F .
 SEE: calcCovarMatrix, gemm, repeat, reduce</dd>
</dl>
</li>
</ul>
<a name="mulTransposed-org.opencv.core.Mat-org.opencv.core.Mat-boolean-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mulTransposed</h4>
<pre>public static&nbsp;void&nbsp;mulTransposed(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                 boolean&nbsp;aTa,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;delta,
                                 double&nbsp;scale)</pre>
<div class="block">Calculates the product of a matrix and its transposition.

 The function cv::mulTransposed calculates the product of src and its
 transposition:
 \(\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} )^T ( \texttt{src} - \texttt{delta} )\)
 if aTa=true, and
 \(\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} ) ( \texttt{src} - \texttt{delta} )^T\)
 otherwise. The function is used to calculate the covariance matrix. With
 zero delta, it can be used as a faster substitute for general matrix
 product A\*B when B=A'</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input single-channel matrix. Note that unlike gemm, the
 function can multiply not only floating-point matrices.</dd>
<dd><code>dst</code> - output square matrix.</dd>
<dd><code>aTa</code> - Flag specifying the multiplication ordering. See the
 description below.</dd>
<dd><code>delta</code> - Optional delta matrix subtracted from src before the
 multiplication. When the matrix is empty ( delta=noArray() ), it is
 assumed to be zero, that is, nothing is subtracted. If it has the same
 size as src, it is simply subtracted. Otherwise, it is "repeated" (see
 repeat ) to cover the full src and then subtracted. Type of the delta
 matrix, when it is not empty, must be the same as the type of created
 output matrix. See the dtype parameter description below.</dd>
<dd><code>scale</code> - Optional scale factor for the matrix product.
 the output matrix will have the same type as src . Otherwise, it will be
 type=CV_MAT_DEPTH(dtype) that should be either CV_32F or CV_64F .
 SEE: calcCovarMatrix, gemm, repeat, reduce</dd>
</dl>
</li>
</ul>
<a name="mulTransposed-org.opencv.core.Mat-org.opencv.core.Mat-boolean-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mulTransposed</h4>
<pre>public static&nbsp;void&nbsp;mulTransposed(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                 boolean&nbsp;aTa,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;delta)</pre>
<div class="block">Calculates the product of a matrix and its transposition.

 The function cv::mulTransposed calculates the product of src and its
 transposition:
 \(\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} )^T ( \texttt{src} - \texttt{delta} )\)
 if aTa=true, and
 \(\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} ) ( \texttt{src} - \texttt{delta} )^T\)
 otherwise. The function is used to calculate the covariance matrix. With
 zero delta, it can be used as a faster substitute for general matrix
 product A\*B when B=A'</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input single-channel matrix. Note that unlike gemm, the
 function can multiply not only floating-point matrices.</dd>
<dd><code>dst</code> - output square matrix.</dd>
<dd><code>aTa</code> - Flag specifying the multiplication ordering. See the
 description below.</dd>
<dd><code>delta</code> - Optional delta matrix subtracted from src before the
 multiplication. When the matrix is empty ( delta=noArray() ), it is
 assumed to be zero, that is, nothing is subtracted. If it has the same
 size as src, it is simply subtracted. Otherwise, it is "repeated" (see
 repeat ) to cover the full src and then subtracted. Type of the delta
 matrix, when it is not empty, must be the same as the type of created
 output matrix. See the dtype parameter description below.
 the output matrix will have the same type as src . Otherwise, it will be
 type=CV_MAT_DEPTH(dtype) that should be either CV_32F or CV_64F .
 SEE: calcCovarMatrix, gemm, repeat, reduce</dd>
</dl>
</li>
</ul>
<a name="mulTransposed-org.opencv.core.Mat-org.opencv.core.Mat-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mulTransposed</h4>
<pre>public static&nbsp;void&nbsp;mulTransposed(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                 boolean&nbsp;aTa)</pre>
<div class="block">Calculates the product of a matrix and its transposition.

 The function cv::mulTransposed calculates the product of src and its
 transposition:
 \(\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} )^T ( \texttt{src} - \texttt{delta} )\)
 if aTa=true, and
 \(\texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} ) ( \texttt{src} - \texttt{delta} )^T\)
 otherwise. The function is used to calculate the covariance matrix. With
 zero delta, it can be used as a faster substitute for general matrix
 product A\*B when B=A'</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input single-channel matrix. Note that unlike gemm, the
 function can multiply not only floating-point matrices.</dd>
<dd><code>dst</code> - output square matrix.</dd>
<dd><code>aTa</code> - Flag specifying the multiplication ordering. See the
 description below.
 multiplication. When the matrix is empty ( delta=noArray() ), it is
 assumed to be zero, that is, nothing is subtracted. If it has the same
 size as src, it is simply subtracted. Otherwise, it is "repeated" (see
 repeat ) to cover the full src and then subtracted. Type of the delta
 matrix, when it is not empty, must be the same as the type of created
 output matrix. See the dtype parameter description below.
 the output matrix will have the same type as src . Otherwise, it will be
 type=CV_MAT_DEPTH(dtype) that should be either CV_32F or CV_64F .
 SEE: calcCovarMatrix, gemm, repeat, reduce</dd>
</dl>
</li>
</ul>
<a name="transpose-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transpose</h4>
<pre>public static&nbsp;void&nbsp;transpose(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Transposes a matrix.

 The function cv::transpose transposes the matrix src :
 \(\texttt{dst} (i,j) =  \texttt{src} (j,i)\)
 <b>Note:</b> No complex conjugation is done in case of a complex matrix. It
 should be done separately if needed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>dst</code> - output array of the same type as src.</dd>
</dl>
</li>
</ul>
<a name="transposeND-org.opencv.core.Mat-org.opencv.core.MatOfInt-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transposeND</h4>
<pre>public static&nbsp;void&nbsp;transposeND(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                               <a href="../../../org/opencv/core/MatOfInt.html" title="class in org.opencv.core">MatOfInt</a>&nbsp;order,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Transpose for n-dimensional matrices.

 <b>Note:</b> Input should be continuous single-channel matrix.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array.</dd>
<dd><code>order</code> - a permutation of [0,1,..,N-1] where N is the number of axes of src.
 The i'th axis of dst will correspond to the axis numbered order[i] of the input.</dd>
<dd><code>dst</code> - output array of the same type as src.</dd>
</dl>
</li>
</ul>
<a name="transform-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transform</h4>
<pre>public static&nbsp;void&nbsp;transform(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m)</pre>
<div class="block">Performs the matrix transformation of every array element.

 The function cv::transform performs the matrix transformation of every
 element of the array src and stores the results in dst :
 \(\texttt{dst} (I) =  \texttt{m} \cdot \texttt{src} (I)\)
 (when m.cols=src.channels() ), or
 \(\texttt{dst} (I) =  \texttt{m} \cdot [ \texttt{src} (I); 1]\)
 (when m.cols=src.channels()+1 )

 Every element of the N -channel array src is interpreted as N -element
 vector that is transformed using the M x N or M x (N+1) matrix m to
 M-element vector - the corresponding element of the output array dst .

 The function may be used for geometrical transformation of
 N -dimensional points, arbitrary linear color space transformation (such
 as various kinds of RGB to YUV transforms), shuffling the image
 channels, and so forth.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array that must have as many channels (1 to 4) as
 m.cols or m.cols-1.</dd>
<dd><code>dst</code> - output array of the same size and depth as src; it has as
 many channels as m.rows.</dd>
<dd><code>m</code> - transformation 2x2 or 2x3 floating-point matrix.
 SEE: perspectiveTransform, getAffineTransform, estimateAffine2D, warpAffine, warpPerspective</dd>
</dl>
</li>
</ul>
<a name="perspectiveTransform-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>perspectiveTransform</h4>
<pre>public static&nbsp;void&nbsp;perspectiveTransform(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m)</pre>
<div class="block">Performs the perspective matrix transformation of vectors.

 The function cv::perspectiveTransform transforms every element of src by
 treating it as a 2D or 3D vector, in the following way:
 \((x, y, z)  \rightarrow (x'/w, y'/w, z'/w)\)
 where
 \((x', y', z', w') =  \texttt{mat} \cdot \begin{bmatrix} x &amp; y &amp; z &amp; 1  \end{bmatrix}\)
 and
 \(w =  \fork{w'}{if \(w' \ne 0\)}{\infty}{otherwise}\)

 Here a 3D vector transformation is shown. In case of a 2D vector
 transformation, the z component is omitted.

 <b>Note:</b> The function transforms a sparse set of 2D or 3D vectors. If you
 want to transform an image using perspective transformation, use
 warpPerspective . If you have an inverse problem, that is, you want to
 compute the most probable perspective transformation out of several
 pairs of corresponding points, you can use getPerspectiveTransform or
 findHomography .</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input two-channel or three-channel floating-point array; each
 element is a 2D/3D vector to be transformed.</dd>
<dd><code>dst</code> - output array of the same size and type as src.</dd>
<dd><code>m</code> - 3x3 or 4x4 floating-point transformation matrix.
 SEE:  transform, warpPerspective, getPerspectiveTransform, findHomography</dd>
</dl>
</li>
</ul>
<a name="completeSymm-org.opencv.core.Mat-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>completeSymm</h4>
<pre>public static&nbsp;void&nbsp;completeSymm(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m,
                                boolean&nbsp;lowerToUpper)</pre>
<div class="block">Copies the lower or the upper half of a square matrix to its another half.

 The function cv::completeSymm copies the lower or the upper half of a square matrix to
 its another half. The matrix diagonal remains unchanged:
 <ul>
   <li>
   \(\texttt{m}_{ij}=\texttt{m}_{ji}\) for \(i &gt; j\) if
     lowerToUpper=false
   </li>
   <li>
   \(\texttt{m}_{ij}=\texttt{m}_{ji}\) for \(i &lt; j\) if
     lowerToUpper=true
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - input-output floating-point square matrix.</dd>
<dd><code>lowerToUpper</code> - operation flag; if true, the lower half is copied to
 the upper half. Otherwise, the upper half is copied to the lower half.
 SEE: flip, transpose</dd>
</dl>
</li>
</ul>
<a name="completeSymm-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>completeSymm</h4>
<pre>public static&nbsp;void&nbsp;completeSymm(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;m)</pre>
<div class="block">Copies the lower or the upper half of a square matrix to its another half.

 The function cv::completeSymm copies the lower or the upper half of a square matrix to
 its another half. The matrix diagonal remains unchanged:
 <ul>
   <li>
   \(\texttt{m}_{ij}=\texttt{m}_{ji}\) for \(i &gt; j\) if
     lowerToUpper=false
   </li>
   <li>
   \(\texttt{m}_{ij}=\texttt{m}_{ji}\) for \(i &lt; j\) if
     lowerToUpper=true
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>m</code> - input-output floating-point square matrix.
 the upper half. Otherwise, the upper half is copied to the lower half.
 SEE: flip, transpose</dd>
</dl>
</li>
</ul>
<a name="setIdentity-org.opencv.core.Mat-org.opencv.core.Scalar-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setIdentity</h4>
<pre>public static&nbsp;void&nbsp;setIdentity(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtx,
                               <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;s)</pre>
<div class="block">Initializes a scaled identity matrix.

 The function cv::setIdentity initializes a scaled identity matrix:
 \(\texttt{mtx} (i,j)= \fork{\texttt{value}}{ if \(i=j\)}{0}{otherwise}\)

 The function can also be emulated using the matrix initializers and the
 matrix expressions:
 <code>
     Mat A = Mat::eye(4, 3, CV_32F)*5;
     // A will be set to [[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]]
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mtx</code> - matrix to initialize (not necessarily square).</dd>
<dd><code>s</code> - value to assign to diagonal elements.
 SEE: Mat::zeros, Mat::ones, Mat::setTo, Mat::operator=</dd>
</dl>
</li>
</ul>
<a name="setIdentity-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setIdentity</h4>
<pre>public static&nbsp;void&nbsp;setIdentity(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtx)</pre>
<div class="block">Initializes a scaled identity matrix.

 The function cv::setIdentity initializes a scaled identity matrix:
 \(\texttt{mtx} (i,j)= \fork{\texttt{value}}{ if \(i=j\)}{0}{otherwise}\)

 The function can also be emulated using the matrix initializers and the
 matrix expressions:
 <code>
     Mat A = Mat::eye(4, 3, CV_32F)*5;
     // A will be set to [[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]]
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mtx</code> - matrix to initialize (not necessarily square).
 SEE: Mat::zeros, Mat::ones, Mat::setTo, Mat::operator=</dd>
</dl>
</li>
</ul>
<a name="determinant-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>determinant</h4>
<pre>public static&nbsp;double&nbsp;determinant(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtx)</pre>
<div class="block">Returns the determinant of a square floating-point matrix.

 The function cv::determinant calculates and returns the determinant of the
 specified matrix. For small matrices ( mtx.cols=mtx.rows&lt;=3 ), the
 direct method is used. For larger matrices, the function uses LU
 factorization with partial pivoting.

 For symmetric positively-determined matrices, it is also possible to use
 eigen decomposition to calculate the determinant.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mtx</code> - input matrix that must have CV_32FC1 or CV_64FC1 type and
 square size.
 SEE: trace, invert, solve, eigen, REF: MatrixExpressions</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="trace-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>trace</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;trace(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mtx)</pre>
<div class="block">Returns the trace of a matrix.

 The function cv::trace returns the sum of the diagonal elements of the
 matrix mtx .
 \(\mathrm{tr} ( \texttt{mtx} ) =  \sum _i  \texttt{mtx} (i,i)\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mtx</code> - input matrix.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="invert-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>invert</h4>
<pre>public static&nbsp;double&nbsp;invert(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                            int&nbsp;flags)</pre>
<div class="block">Finds the inverse or pseudo-inverse of a matrix.

 The function cv::invert inverts the matrix src and stores the result in dst
 . When the matrix src is singular or non-square, the function calculates
 the pseudo-inverse matrix (the dst matrix) so that norm(src\*dst - I) is
 minimal, where I is an identity matrix.

 In case of the #DECOMP_LU method, the function returns non-zero value if
 the inverse has been successfully calculated and 0 if src is singular.

 In case of the #DECOMP_SVD method, the function returns the inverse
 condition number of src (the ratio of the smallest singular value to the
 largest singular value) and 0 if src is singular. The SVD method
 calculates a pseudo-inverse matrix if src is singular.

 Similarly to #DECOMP_LU, the method #DECOMP_CHOLESKY works only with
 non-singular square matrices that should also be symmetrical and
 positively defined. In this case, the function stores the inverted
 matrix in dst and returns non-zero. Otherwise, it returns 0.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input floating-point M x N matrix.</dd>
<dd><code>dst</code> - output matrix of N x M size and the same type as src.</dd>
<dd><code>flags</code> - inversion method (cv::DecompTypes)
 SEE: solve, SVD</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="invert-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>invert</h4>
<pre>public static&nbsp;double&nbsp;invert(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Finds the inverse or pseudo-inverse of a matrix.

 The function cv::invert inverts the matrix src and stores the result in dst
 . When the matrix src is singular or non-square, the function calculates
 the pseudo-inverse matrix (the dst matrix) so that norm(src\*dst - I) is
 minimal, where I is an identity matrix.

 In case of the #DECOMP_LU method, the function returns non-zero value if
 the inverse has been successfully calculated and 0 if src is singular.

 In case of the #DECOMP_SVD method, the function returns the inverse
 condition number of src (the ratio of the smallest singular value to the
 largest singular value) and 0 if src is singular. The SVD method
 calculates a pseudo-inverse matrix if src is singular.

 Similarly to #DECOMP_LU, the method #DECOMP_CHOLESKY works only with
 non-singular square matrices that should also be symmetrical and
 positively defined. In this case, the function stores the inverted
 matrix in dst and returns non-zero. Otherwise, it returns 0.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input floating-point M x N matrix.</dd>
<dd><code>dst</code> - output matrix of N x M size and the same type as src.
 SEE: solve, SVD</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solve-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solve</h4>
<pre>public static&nbsp;boolean&nbsp;solve(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                            int&nbsp;flags)</pre>
<div class="block">Solves one or more linear systems or least-squares problems.

 The function cv::solve solves a linear system or least-squares problem (the
 latter is possible with SVD or QR methods, or by specifying the flag
 #DECOMP_NORMAL ):
 \(\texttt{dst} =  \arg \min _X \| \texttt{src1} \cdot \texttt{X} -  \texttt{src2} \|\)

 If #DECOMP_LU or #DECOMP_CHOLESKY method is used, the function returns 1
 if src1 (or \(\texttt{src1}^T\texttt{src1}\) ) is non-singular. Otherwise,
 it returns 0. In the latter case, dst is not valid. Other methods find a
 pseudo-solution in case of a singular left-hand side part.

 <b>Note:</b> If you want to find a unity-norm solution of an under-defined
 singular system \(\texttt{src1}\cdot\texttt{dst}=0\) , the function solve
 will not do the work. Use SVD::solveZ instead.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - input matrix on the left-hand side of the system.</dd>
<dd><code>src2</code> - input matrix on the right-hand side of the system.</dd>
<dd><code>dst</code> - output solution.</dd>
<dd><code>flags</code> - solution (matrix inversion) method (#DecompTypes)
 SEE: invert, SVD, eigen</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solve-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solve</h4>
<pre>public static&nbsp;boolean&nbsp;solve(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src2,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Solves one or more linear systems or least-squares problems.

 The function cv::solve solves a linear system or least-squares problem (the
 latter is possible with SVD or QR methods, or by specifying the flag
 #DECOMP_NORMAL ):
 \(\texttt{dst} =  \arg \min _X \| \texttt{src1} \cdot \texttt{X} -  \texttt{src2} \|\)

 If #DECOMP_LU or #DECOMP_CHOLESKY method is used, the function returns 1
 if src1 (or \(\texttt{src1}^T\texttt{src1}\) ) is non-singular. Otherwise,
 it returns 0. In the latter case, dst is not valid. Other methods find a
 pseudo-solution in case of a singular left-hand side part.

 <b>Note:</b> If you want to find a unity-norm solution of an under-defined
 singular system \(\texttt{src1}\cdot\texttt{dst}=0\) , the function solve
 will not do the work. Use SVD::solveZ instead.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src1</code> - input matrix on the left-hand side of the system.</dd>
<dd><code>src2</code> - input matrix on the right-hand side of the system.</dd>
<dd><code>dst</code> - output solution.
 SEE: invert, SVD, eigen</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="sort-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sort</h4>
<pre>public static&nbsp;void&nbsp;sort(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                        int&nbsp;flags)</pre>
<div class="block">Sorts each row or each column of a matrix.

 The function cv::sort sorts each matrix row or each matrix column in
 ascending or descending order. So you should pass two operation flags to
 get desired behaviour. If you want to sort matrix rows or columns
 lexicographically, you can use STL std::sort generic function with the
 proper comparison predicate.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input single-channel array.</dd>
<dd><code>dst</code> - output array of the same size and type as src.</dd>
<dd><code>flags</code> - operation flags, a combination of #SortFlags
 SEE: sortIdx, randShuffle</dd>
</dl>
</li>
</ul>
<a name="sortIdx-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sortIdx</h4>
<pre>public static&nbsp;void&nbsp;sortIdx(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                           int&nbsp;flags)</pre>
<div class="block">Sorts each row or each column of a matrix.

 The function cv::sortIdx sorts each matrix row or each matrix column in the
 ascending or descending order. So you should pass two operation flags to
 get desired behaviour. Instead of reordering the elements themselves, it
 stores the indices of sorted elements in the output array. For example:
 <code>
     Mat A = Mat::eye(3,3,CV_32F), B;
     sortIdx(A, B, SORT_EVERY_ROW + SORT_ASCENDING);
     // B will probably contain
     // (because of equal elements in A some permutations are possible):
     // [[1, 2, 0], [0, 2, 1], [0, 1, 2]]
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input single-channel array.</dd>
<dd><code>dst</code> - output integer array of the same size as src.</dd>
<dd><code>flags</code> - operation flags that could be a combination of cv::SortFlags
 SEE: sort, randShuffle</dd>
</dl>
</li>
</ul>
<a name="solveCubic-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solveCubic</h4>
<pre>public static&nbsp;int&nbsp;solveCubic(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;coeffs,
                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;roots)</pre>
<div class="block">Finds the real roots of a cubic equation.

 The function solveCubic finds the real roots of a cubic equation:
 <ul>
   <li>
    if coeffs is a 4-element vector:
 \(\texttt{coeffs} [0] x^3 +  \texttt{coeffs} [1] x^2 +  \texttt{coeffs} [2] x +  \texttt{coeffs} [3] = 0\)
   </li>
   <li>
    if coeffs is a 3-element vector:
 \(x^3 +  \texttt{coeffs} [0] x^2 +  \texttt{coeffs} [1] x +  \texttt{coeffs} [2] = 0\)
   </li>
 </ul>

 The roots are stored in the roots array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>coeffs</code> - equation coefficients, an array of 3 or 4 elements.</dd>
<dd><code>roots</code> - output array of real roots that has 1 or 3 elements.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>number of real roots. It can be 0, 1 or 2.</dd>
</dl>
</li>
</ul>
<a name="solvePoly-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePoly</h4>
<pre>public static&nbsp;double&nbsp;solvePoly(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;coeffs,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;roots,
                               int&nbsp;maxIters)</pre>
<div class="block">Finds the real or complex roots of a polynomial equation.

 The function cv::solvePoly finds real and complex roots of a polynomial equation:
 \(\texttt{coeffs} [n] x^{n} +  \texttt{coeffs} [n-1] x^{n-1} + ... +  \texttt{coeffs} [1] x +  \texttt{coeffs} [0] = 0\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>coeffs</code> - array of polynomial coefficients.</dd>
<dd><code>roots</code> - output (complex) array of roots.</dd>
<dd><code>maxIters</code> - maximum number of iterations the algorithm does.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="solvePoly-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solvePoly</h4>
<pre>public static&nbsp;double&nbsp;solvePoly(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;coeffs,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;roots)</pre>
<div class="block">Finds the real or complex roots of a polynomial equation.

 The function cv::solvePoly finds real and complex roots of a polynomial equation:
 \(\texttt{coeffs} [n] x^{n} +  \texttt{coeffs} [n-1] x^{n-1} + ... +  \texttt{coeffs} [1] x +  \texttt{coeffs} [0] = 0\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>coeffs</code> - array of polynomial coefficients.</dd>
<dd><code>roots</code> - output (complex) array of roots.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="eigen-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eigen</h4>
<pre>public static&nbsp;boolean&nbsp;eigen(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvalues,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors)</pre>
<div class="block">Calculates eigenvalues and eigenvectors of a symmetric matrix.

 The function cv::eigen calculates just eigenvalues, or eigenvalues and eigenvectors of the symmetric
 matrix src:
 <code>
     src*eigenvectors.row(i).t() = eigenvalues.at&lt;srcType&gt;(i)*eigenvectors.row(i).t()
 </code>

 <b>Note:</b> Use cv::eigenNonSymmetric for calculation of real eigenvalues and eigenvectors of non-symmetric matrix.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input matrix that must have CV_32FC1 or CV_64FC1 type, square size and be symmetrical
 (src ^T^ == src).</dd>
<dd><code>eigenvalues</code> - output vector of eigenvalues of the same type as src; the eigenvalues are stored
 in the descending order.</dd>
<dd><code>eigenvectors</code> - output matrix of eigenvectors; it has the same size and type as src; the
 eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding
 eigenvalues.
 SEE: eigenNonSymmetric, completeSymm, PCA</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="eigen-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eigen</h4>
<pre>public static&nbsp;boolean&nbsp;eigen(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvalues)</pre>
<div class="block">Calculates eigenvalues and eigenvectors of a symmetric matrix.

 The function cv::eigen calculates just eigenvalues, or eigenvalues and eigenvectors of the symmetric
 matrix src:
 <code>
     src*eigenvectors.row(i).t() = eigenvalues.at&lt;srcType&gt;(i)*eigenvectors.row(i).t()
 </code>

 <b>Note:</b> Use cv::eigenNonSymmetric for calculation of real eigenvalues and eigenvectors of non-symmetric matrix.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input matrix that must have CV_32FC1 or CV_64FC1 type, square size and be symmetrical
 (src ^T^ == src).</dd>
<dd><code>eigenvalues</code> - output vector of eigenvalues of the same type as src; the eigenvalues are stored
 in the descending order.
 eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding
 eigenvalues.
 SEE: eigenNonSymmetric, completeSymm, PCA</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="eigenNonSymmetric-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eigenNonSymmetric</h4>
<pre>public static&nbsp;void&nbsp;eigenNonSymmetric(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvalues,
                                     <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors)</pre>
<div class="block">Calculates eigenvalues and eigenvectors of a non-symmetric matrix (real eigenvalues only).

 <b>Note:</b> Assumes real eigenvalues.

 The function calculates eigenvalues and eigenvectors (optional) of the square matrix src:
 <code>
     src*eigenvectors.row(i).t() = eigenvalues.at&lt;srcType&gt;(i)*eigenvectors.row(i).t()
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input matrix (CV_32FC1 or CV_64FC1 type).</dd>
<dd><code>eigenvalues</code> - output vector of eigenvalues (type is the same type as src).</dd>
<dd><code>eigenvectors</code> - output matrix of eigenvectors (type is the same type as src). The eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues.
 SEE: eigen</dd>
</dl>
</li>
</ul>
<a name="calcCovarMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calcCovarMatrix</h4>
<pre>public static&nbsp;void&nbsp;calcCovarMatrix(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;samples,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;covar,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
                                   int&nbsp;flags,
                                   int&nbsp;ctype)</pre>
<div class="block"><b>Note:</b> use #COVAR_ROWS or #COVAR_COLS flag</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>samples</code> - samples stored as rows/columns of a single matrix.</dd>
<dd><code>covar</code> - output covariance matrix of the type ctype and square size.</dd>
<dd><code>mean</code> - input or output (depending on the flags) array as the average value of the input vectors.</dd>
<dd><code>flags</code> - operation flags as a combination of #CovarFlags</dd>
<dd><code>ctype</code> - type of the matrixl; it equals 'CV_64F' by default.</dd>
</dl>
</li>
</ul>
<a name="calcCovarMatrix-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calcCovarMatrix</h4>
<pre>public static&nbsp;void&nbsp;calcCovarMatrix(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;samples,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;covar,
                                   <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
                                   int&nbsp;flags)</pre>
<div class="block"><b>Note:</b> use #COVAR_ROWS or #COVAR_COLS flag</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>samples</code> - samples stored as rows/columns of a single matrix.</dd>
<dd><code>covar</code> - output covariance matrix of the type ctype and square size.</dd>
<dd><code>mean</code> - input or output (depending on the flags) array as the average value of the input vectors.</dd>
<dd><code>flags</code> - operation flags as a combination of #CovarFlags</dd>
</dl>
</li>
</ul>
<a name="PCACompute-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PCACompute</h4>
<pre>public static&nbsp;void&nbsp;PCACompute(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
                              int&nbsp;maxComponents)</pre>
<div class="block">wrap PCA::operator()</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>data</code> - automatically generated</dd>
<dd><code>mean</code> - automatically generated</dd>
<dd><code>eigenvectors</code> - automatically generated</dd>
<dd><code>maxComponents</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="PCACompute-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PCACompute</h4>
<pre>public static&nbsp;void&nbsp;PCACompute(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors)</pre>
<div class="block">wrap PCA::operator()</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>data</code> - automatically generated</dd>
<dd><code>mean</code> - automatically generated</dd>
<dd><code>eigenvectors</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="PCACompute2-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PCACompute2</h4>
<pre>public static&nbsp;void&nbsp;PCACompute2(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvalues,
                               int&nbsp;maxComponents)</pre>
<div class="block">wrap PCA::operator() and add eigenvalues output parameter</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>data</code> - automatically generated</dd>
<dd><code>mean</code> - automatically generated</dd>
<dd><code>eigenvectors</code> - automatically generated</dd>
<dd><code>eigenvalues</code> - automatically generated</dd>
<dd><code>maxComponents</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="PCACompute2-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PCACompute2</h4>
<pre>public static&nbsp;void&nbsp;PCACompute2(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvalues)</pre>
<div class="block">wrap PCA::operator() and add eigenvalues output parameter</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>data</code> - automatically generated</dd>
<dd><code>mean</code> - automatically generated</dd>
<dd><code>eigenvectors</code> - automatically generated</dd>
<dd><code>eigenvalues</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="PCACompute-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PCACompute</h4>
<pre>public static&nbsp;void&nbsp;PCACompute(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
                              double&nbsp;retainedVariance)</pre>
<div class="block">wrap PCA::operator()</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>data</code> - automatically generated</dd>
<dd><code>mean</code> - automatically generated</dd>
<dd><code>eigenvectors</code> - automatically generated</dd>
<dd><code>retainedVariance</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="PCACompute2-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PCACompute2</h4>
<pre>public static&nbsp;void&nbsp;PCACompute2(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvalues,
                               double&nbsp;retainedVariance)</pre>
<div class="block">wrap PCA::operator() and add eigenvalues output parameter</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>data</code> - automatically generated</dd>
<dd><code>mean</code> - automatically generated</dd>
<dd><code>eigenvectors</code> - automatically generated</dd>
<dd><code>eigenvalues</code> - automatically generated</dd>
<dd><code>retainedVariance</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="PCAProject-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PCAProject</h4>
<pre>public static&nbsp;void&nbsp;PCAProject(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
                              <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;result)</pre>
<div class="block">wrap PCA::project</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>data</code> - automatically generated</dd>
<dd><code>mean</code> - automatically generated</dd>
<dd><code>eigenvectors</code> - automatically generated</dd>
<dd><code>result</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="PCABackProject-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PCABackProject</h4>
<pre>public static&nbsp;void&nbsp;PCABackProject(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mean,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;eigenvectors,
                                  <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;result)</pre>
<div class="block">wrap PCA::backProject</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>data</code> - automatically generated</dd>
<dd><code>mean</code> - automatically generated</dd>
<dd><code>eigenvectors</code> - automatically generated</dd>
<dd><code>result</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="SVDecomp-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SVDecomp</h4>
<pre>public static&nbsp;void&nbsp;SVDecomp(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;w,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;u,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vt,
                            int&nbsp;flags)</pre>
<div class="block">wrap SVD::compute</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - automatically generated</dd>
<dd><code>w</code> - automatically generated</dd>
<dd><code>u</code> - automatically generated</dd>
<dd><code>vt</code> - automatically generated</dd>
<dd><code>flags</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="SVDecomp-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SVDecomp</h4>
<pre>public static&nbsp;void&nbsp;SVDecomp(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;w,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;u,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vt)</pre>
<div class="block">wrap SVD::compute</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - automatically generated</dd>
<dd><code>w</code> - automatically generated</dd>
<dd><code>u</code> - automatically generated</dd>
<dd><code>vt</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="SVBackSubst-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SVBackSubst</h4>
<pre>public static&nbsp;void&nbsp;SVBackSubst(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;w,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;u,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;vt,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;rhs,
                               <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">wrap SVD::backSubst</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>w</code> - automatically generated</dd>
<dd><code>u</code> - automatically generated</dd>
<dd><code>vt</code> - automatically generated</dd>
<dd><code>rhs</code> - automatically generated</dd>
<dd><code>dst</code> - automatically generated</dd>
</dl>
</li>
</ul>
<a name="Mahalanobis-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Mahalanobis</h4>
<pre>public static&nbsp;double&nbsp;Mahalanobis(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;v1,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;v2,
                                 <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;icovar)</pre>
<div class="block">Calculates the Mahalanobis distance between two vectors.

 The function cv::Mahalanobis calculates and returns the weighted distance between two vectors:
 \(d( \texttt{vec1} , \texttt{vec2} )= \sqrt{\sum_{i,j}{\texttt{icovar(i,j)}\cdot(\texttt{vec1}(I)-\texttt{vec2}(I))\cdot(\texttt{vec1(j)}-\texttt{vec2(j)})} }\)
 The covariance matrix may be calculated using the #calcCovarMatrix function and then inverted using
 the invert function (preferably using the #DECOMP_SVD method, as the most accurate).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>v1</code> - first 1D input vector.</dd>
<dd><code>v2</code> - second 1D input vector.</dd>
<dd><code>icovar</code> - inverse covariance matrix.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="dft-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dft</h4>
<pre>public static&nbsp;void&nbsp;dft(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                       int&nbsp;flags,
                       int&nbsp;nonzeroRows)</pre>
<div class="block">Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array.

 The function cv::dft performs one of the following:
 <ul>
   <li>
    Forward the Fourier transform of a 1D vector of N elements:
     \(Y = F^{(N)}  \cdot X,\)
     where \(F^{(N)}_{jk}=\exp(-2\pi i j k/N)\) and \(i=\sqrt{-1}\)
   </li>
   <li>
    Inverse the Fourier transform of a 1D vector of N elements:
     \(\begin{array}{l} X'=  \left (F^{(N)} \right )^{-1}  \cdot Y =  \left (F^{(N)} \right )^*  \cdot y  \\ X = (1/N)  \cdot X, \end{array}\)
     where \(F^*=\left(\textrm{Re}(F^{(N)})-\textrm{Im}(F^{(N)})\right)^T\)
   </li>
   <li>
    Forward the 2D Fourier transform of a M x N matrix:
     \(Y = F^{(M)}  \cdot X  \cdot F^{(N)}\)
   </li>
   <li>
    Inverse the 2D Fourier transform of a M x N matrix:
     \(\begin{array}{l} X'=  \left (F^{(M)} \right )^*  \cdot Y  \cdot \left (F^{(N)} \right )^* \\ X =  \frac{1}{M \cdot N} \cdot X' \end{array}\)
   </li>
 </ul>

 In case of real (single-channel) data, the output spectrum of the forward Fourier transform or input
 spectrum of the inverse Fourier transform can be represented in a packed format called *CCS*
 (complex-conjugate-symmetrical). It was borrowed from IPL (Intel\* Image Processing Library). Here
 is how 2D *CCS* spectrum looks:
 \(\begin{bmatrix} Re Y_{0,0} &amp; Re Y_{0,1} &amp; Im Y_{0,1} &amp; Re Y_{0,2} &amp; Im Y_{0,2} &amp;  \cdots &amp; Re Y_{0,N/2-1} &amp; Im Y_{0,N/2-1} &amp; Re Y_{0,N/2}  \\ Re Y_{1,0} &amp; Re Y_{1,1} &amp; Im Y_{1,1} &amp; Re Y_{1,2} &amp; Im Y_{1,2} &amp;  \cdots &amp; Re Y_{1,N/2-1} &amp; Im Y_{1,N/2-1} &amp; Re Y_{1,N/2}  \\ Im Y_{1,0} &amp; Re Y_{2,1} &amp; Im Y_{2,1} &amp; Re Y_{2,2} &amp; Im Y_{2,2} &amp;  \cdots &amp; Re Y_{2,N/2-1} &amp; Im Y_{2,N/2-1} &amp; Im Y_{1,N/2}  \\ \hdotsfor{9} \\ Re Y_{M/2-1,0} &amp;  Re Y_{M-3,1}  &amp; Im Y_{M-3,1} &amp;  \hdotsfor{3} &amp; Re Y_{M-3,N/2-1} &amp; Im Y_{M-3,N/2-1}&amp; Re Y_{M/2-1,N/2}  \\ Im Y_{M/2-1,0} &amp;  Re Y_{M-2,1}  &amp; Im Y_{M-2,1} &amp;  \hdotsfor{3} &amp; Re Y_{M-2,N/2-1} &amp; Im Y_{M-2,N/2-1}&amp; Im Y_{M/2-1,N/2}  \\ Re Y_{M/2,0}  &amp;  Re Y_{M-1,1} &amp;  Im Y_{M-1,1} &amp;  \hdotsfor{3} &amp; Re Y_{M-1,N/2-1} &amp; Im Y_{M-1,N/2-1}&amp; Re Y_{M/2,N/2} \end{bmatrix}\)

 In case of 1D transform of a real vector, the output looks like the first row of the matrix above.

 So, the function chooses an operation mode depending on the flags and size of the input array:
 <ul>
   <li>
    If #DFT_ROWS is set or the input array has a single row or single column, the function
     performs a 1D forward or inverse transform of each row of a matrix when #DFT_ROWS is set.
     Otherwise, it performs a 2D transform.
   </li>
   <li>
    If the input array is real and #DFT_INVERSE is not set, the function performs a forward 1D or
     2D transform:
   <ul>
     <li>
        When #DFT_COMPLEX_OUTPUT is set, the output is a complex matrix of the same size as
         input.
     </li>
     <li>
        When #DFT_COMPLEX_OUTPUT is not set, the output is a real matrix of the same size as
         input. In case of 2D transform, it uses the packed format as shown above. In case of a
         single 1D transform, it looks like the first row of the matrix above. In case of
         multiple 1D transforms (when using the #DFT_ROWS flag), each row of the output matrix
         looks like the first row of the matrix above.
     </li>
   </ul>
   <li>
    If the input array is complex and either #DFT_INVERSE or #DFT_REAL_OUTPUT are not set, the
     output is a complex array of the same size as input. The function performs a forward or
     inverse 1D or 2D transform of the whole input array or each row of the input array
     independently, depending on the flags DFT_INVERSE and DFT_ROWS.
   </li>
   <li>
    When #DFT_INVERSE is set and the input array is real, or it is complex but #DFT_REAL_OUTPUT
     is set, the output is a real array of the same size as input. The function performs a 1D or 2D
     inverse transformation of the whole input array or each individual row, depending on the flags
     #DFT_INVERSE and #DFT_ROWS.
   </li>
 </ul>

 If #DFT_SCALE is set, the scaling is done after the transformation.

 Unlike dct, the function supports arrays of arbitrary size. But only those arrays are processed
 efficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the
 current implementation). Such an efficient DFT size can be calculated using the getOptimalDFTSize
 method.

 The sample below illustrates how to calculate a DFT-based convolution of two 2D real arrays:
 <code>
     void convolveDFT(InputArray A, InputArray B, OutputArray C)
     {
         // reallocate the output array if needed
         C.create(abs(A.rows - B.rows)+1, abs(A.cols - B.cols)+1, A.type());
         Size dftSize;
         // calculate the size of DFT transform
         dftSize.width = getOptimalDFTSize(A.cols + B.cols - 1);
         dftSize.height = getOptimalDFTSize(A.rows + B.rows - 1);

         // allocate temporary buffers and initialize them with 0's
         Mat tempA(dftSize, A.type(), Scalar::all(0));
         Mat tempB(dftSize, B.type(), Scalar::all(0));

         // copy A and B to the top-left corners of tempA and tempB, respectively
         Mat roiA(tempA, Rect(0,0,A.cols,A.rows));
         A.copyTo(roiA);
         Mat roiB(tempB, Rect(0,0,B.cols,B.rows));
         B.copyTo(roiB);

         // now transform the padded A &amp; B in-place;
         // use "nonzeroRows" hint for faster processing
         dft(tempA, tempA, 0, A.rows);
         dft(tempB, tempB, 0, B.rows);

         // multiply the spectrums;
         // the function handles packed spectrum representations well
         mulSpectrums(tempA, tempB, tempA);

         // transform the product back from the frequency domain.
         // Even though all the result rows will be non-zero,
         // you need only the first C.rows of them, and thus you
         // pass nonzeroRows == C.rows
         dft(tempA, tempA, DFT_INVERSE + DFT_SCALE, C.rows);

         // now copy the result back to C.
         tempA(Rect(0, 0, C.cols, C.rows)).copyTo(C);

         // all the temporary buffers will be deallocated automatically
     }
 </code>
 To optimize this sample, consider the following approaches:
 <ul>
   <li>
    Since nonzeroRows != 0 is passed to the forward transform calls and since A and B are copied to
     the top-left corners of tempA and tempB, respectively, it is not necessary to clear the whole
     tempA and tempB. It is only necessary to clear the tempA.cols - A.cols ( tempB.cols - B.cols)
     rightmost columns of the matrices.
   </li>
   <li>
    This DFT-based convolution does not have to be applied to the whole big arrays, especially if B
     is significantly smaller than A or vice versa. Instead, you can calculate convolution by parts.
     To do this, you need to split the output array C into multiple tiles. For each tile, estimate
     which parts of A and B are required to calculate convolution in this tile. If the tiles in C are
     too small, the speed will decrease a lot because of repeated work. In the ultimate case, when
     each tile in C is a single pixel, the algorithm becomes equivalent to the naive convolution
     algorithm. If the tiles are too big, the temporary arrays tempA and tempB become too big and
     there is also a slowdown because of bad cache locality. So, there is an optimal tile size
     somewhere in the middle.
   </li>
   <li>
    If different tiles in C can be calculated in parallel and, thus, the convolution is done by
     parts, the loop can be threaded.
   </li>
 </ul>

 All of the above improvements have been implemented in #matchTemplate and #filter2D . Therefore, by
 using them, you can get the performance even better than with the above theoretically optimal
 implementation. Though, those two functions actually calculate cross-correlation, not convolution,
 so you need to "flip" the second convolution operand B vertically and horizontally using flip .
 <b>Note:</b>
 <ul>
   <li>
    An example using the discrete fourier transform can be found at
     opencv_source_code/samples/cpp/dft.cpp
   </li>
   <li>
    (Python) An example using the dft functionality to perform Wiener deconvolution can be found
     at opencv_source/samples/python/deconvolution.py
   </li>
   <li>
    (Python) An example rearranging the quadrants of a Fourier image can be found at
     opencv_source/samples/python/dft.py
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array that could be real or complex.</dd>
<dd><code>dst</code> - output array whose size and type depends on the flags .</dd>
<dd><code>flags</code> - transformation flags, representing a combination of the #DftFlags</dd>
<dd><code>nonzeroRows</code> - when the parameter is not zero, the function assumes that only the first
 nonzeroRows rows of the input array (#DFT_INVERSE is not set) or only the first nonzeroRows of the
 output array (#DFT_INVERSE is set) contain non-zeros, thus, the function can handle the rest of the
 rows more efficiently and save some time; this technique is very useful for calculating array
 cross-correlation or convolution using DFT.
 SEE: dct, getOptimalDFTSize, mulSpectrums, filter2D, matchTemplate, flip, cartToPolar,
 magnitude, phase</dd>
</dl>
</li>
</ul>
<a name="dft-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dft</h4>
<pre>public static&nbsp;void&nbsp;dft(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                       int&nbsp;flags)</pre>
<div class="block">Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array.

 The function cv::dft performs one of the following:
 <ul>
   <li>
    Forward the Fourier transform of a 1D vector of N elements:
     \(Y = F^{(N)}  \cdot X,\)
     where \(F^{(N)}_{jk}=\exp(-2\pi i j k/N)\) and \(i=\sqrt{-1}\)
   </li>
   <li>
    Inverse the Fourier transform of a 1D vector of N elements:
     \(\begin{array}{l} X'=  \left (F^{(N)} \right )^{-1}  \cdot Y =  \left (F^{(N)} \right )^*  \cdot y  \\ X = (1/N)  \cdot X, \end{array}\)
     where \(F^*=\left(\textrm{Re}(F^{(N)})-\textrm{Im}(F^{(N)})\right)^T\)
   </li>
   <li>
    Forward the 2D Fourier transform of a M x N matrix:
     \(Y = F^{(M)}  \cdot X  \cdot F^{(N)}\)
   </li>
   <li>
    Inverse the 2D Fourier transform of a M x N matrix:
     \(\begin{array}{l} X'=  \left (F^{(M)} \right )^*  \cdot Y  \cdot \left (F^{(N)} \right )^* \\ X =  \frac{1}{M \cdot N} \cdot X' \end{array}\)
   </li>
 </ul>

 In case of real (single-channel) data, the output spectrum of the forward Fourier transform or input
 spectrum of the inverse Fourier transform can be represented in a packed format called *CCS*
 (complex-conjugate-symmetrical). It was borrowed from IPL (Intel\* Image Processing Library). Here
 is how 2D *CCS* spectrum looks:
 \(\begin{bmatrix} Re Y_{0,0} &amp; Re Y_{0,1} &amp; Im Y_{0,1} &amp; Re Y_{0,2} &amp; Im Y_{0,2} &amp;  \cdots &amp; Re Y_{0,N/2-1} &amp; Im Y_{0,N/2-1} &amp; Re Y_{0,N/2}  \\ Re Y_{1,0} &amp; Re Y_{1,1} &amp; Im Y_{1,1} &amp; Re Y_{1,2} &amp; Im Y_{1,2} &amp;  \cdots &amp; Re Y_{1,N/2-1} &amp; Im Y_{1,N/2-1} &amp; Re Y_{1,N/2}  \\ Im Y_{1,0} &amp; Re Y_{2,1} &amp; Im Y_{2,1} &amp; Re Y_{2,2} &amp; Im Y_{2,2} &amp;  \cdots &amp; Re Y_{2,N/2-1} &amp; Im Y_{2,N/2-1} &amp; Im Y_{1,N/2}  \\ \hdotsfor{9} \\ Re Y_{M/2-1,0} &amp;  Re Y_{M-3,1}  &amp; Im Y_{M-3,1} &amp;  \hdotsfor{3} &amp; Re Y_{M-3,N/2-1} &amp; Im Y_{M-3,N/2-1}&amp; Re Y_{M/2-1,N/2}  \\ Im Y_{M/2-1,0} &amp;  Re Y_{M-2,1}  &amp; Im Y_{M-2,1} &amp;  \hdotsfor{3} &amp; Re Y_{M-2,N/2-1} &amp; Im Y_{M-2,N/2-1}&amp; Im Y_{M/2-1,N/2}  \\ Re Y_{M/2,0}  &amp;  Re Y_{M-1,1} &amp;  Im Y_{M-1,1} &amp;  \hdotsfor{3} &amp; Re Y_{M-1,N/2-1} &amp; Im Y_{M-1,N/2-1}&amp; Re Y_{M/2,N/2} \end{bmatrix}\)

 In case of 1D transform of a real vector, the output looks like the first row of the matrix above.

 So, the function chooses an operation mode depending on the flags and size of the input array:
 <ul>
   <li>
    If #DFT_ROWS is set or the input array has a single row or single column, the function
     performs a 1D forward or inverse transform of each row of a matrix when #DFT_ROWS is set.
     Otherwise, it performs a 2D transform.
   </li>
   <li>
    If the input array is real and #DFT_INVERSE is not set, the function performs a forward 1D or
     2D transform:
   <ul>
     <li>
        When #DFT_COMPLEX_OUTPUT is set, the output is a complex matrix of the same size as
         input.
     </li>
     <li>
        When #DFT_COMPLEX_OUTPUT is not set, the output is a real matrix of the same size as
         input. In case of 2D transform, it uses the packed format as shown above. In case of a
         single 1D transform, it looks like the first row of the matrix above. In case of
         multiple 1D transforms (when using the #DFT_ROWS flag), each row of the output matrix
         looks like the first row of the matrix above.
     </li>
   </ul>
   <li>
    If the input array is complex and either #DFT_INVERSE or #DFT_REAL_OUTPUT are not set, the
     output is a complex array of the same size as input. The function performs a forward or
     inverse 1D or 2D transform of the whole input array or each row of the input array
     independently, depending on the flags DFT_INVERSE and DFT_ROWS.
   </li>
   <li>
    When #DFT_INVERSE is set and the input array is real, or it is complex but #DFT_REAL_OUTPUT
     is set, the output is a real array of the same size as input. The function performs a 1D or 2D
     inverse transformation of the whole input array or each individual row, depending on the flags
     #DFT_INVERSE and #DFT_ROWS.
   </li>
 </ul>

 If #DFT_SCALE is set, the scaling is done after the transformation.

 Unlike dct, the function supports arrays of arbitrary size. But only those arrays are processed
 efficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the
 current implementation). Such an efficient DFT size can be calculated using the getOptimalDFTSize
 method.

 The sample below illustrates how to calculate a DFT-based convolution of two 2D real arrays:
 <code>
     void convolveDFT(InputArray A, InputArray B, OutputArray C)
     {
         // reallocate the output array if needed
         C.create(abs(A.rows - B.rows)+1, abs(A.cols - B.cols)+1, A.type());
         Size dftSize;
         // calculate the size of DFT transform
         dftSize.width = getOptimalDFTSize(A.cols + B.cols - 1);
         dftSize.height = getOptimalDFTSize(A.rows + B.rows - 1);

         // allocate temporary buffers and initialize them with 0's
         Mat tempA(dftSize, A.type(), Scalar::all(0));
         Mat tempB(dftSize, B.type(), Scalar::all(0));

         // copy A and B to the top-left corners of tempA and tempB, respectively
         Mat roiA(tempA, Rect(0,0,A.cols,A.rows));
         A.copyTo(roiA);
         Mat roiB(tempB, Rect(0,0,B.cols,B.rows));
         B.copyTo(roiB);

         // now transform the padded A &amp; B in-place;
         // use "nonzeroRows" hint for faster processing
         dft(tempA, tempA, 0, A.rows);
         dft(tempB, tempB, 0, B.rows);

         // multiply the spectrums;
         // the function handles packed spectrum representations well
         mulSpectrums(tempA, tempB, tempA);

         // transform the product back from the frequency domain.
         // Even though all the result rows will be non-zero,
         // you need only the first C.rows of them, and thus you
         // pass nonzeroRows == C.rows
         dft(tempA, tempA, DFT_INVERSE + DFT_SCALE, C.rows);

         // now copy the result back to C.
         tempA(Rect(0, 0, C.cols, C.rows)).copyTo(C);

         // all the temporary buffers will be deallocated automatically
     }
 </code>
 To optimize this sample, consider the following approaches:
 <ul>
   <li>
    Since nonzeroRows != 0 is passed to the forward transform calls and since A and B are copied to
     the top-left corners of tempA and tempB, respectively, it is not necessary to clear the whole
     tempA and tempB. It is only necessary to clear the tempA.cols - A.cols ( tempB.cols - B.cols)
     rightmost columns of the matrices.
   </li>
   <li>
    This DFT-based convolution does not have to be applied to the whole big arrays, especially if B
     is significantly smaller than A or vice versa. Instead, you can calculate convolution by parts.
     To do this, you need to split the output array C into multiple tiles. For each tile, estimate
     which parts of A and B are required to calculate convolution in this tile. If the tiles in C are
     too small, the speed will decrease a lot because of repeated work. In the ultimate case, when
     each tile in C is a single pixel, the algorithm becomes equivalent to the naive convolution
     algorithm. If the tiles are too big, the temporary arrays tempA and tempB become too big and
     there is also a slowdown because of bad cache locality. So, there is an optimal tile size
     somewhere in the middle.
   </li>
   <li>
    If different tiles in C can be calculated in parallel and, thus, the convolution is done by
     parts, the loop can be threaded.
   </li>
 </ul>

 All of the above improvements have been implemented in #matchTemplate and #filter2D . Therefore, by
 using them, you can get the performance even better than with the above theoretically optimal
 implementation. Though, those two functions actually calculate cross-correlation, not convolution,
 so you need to "flip" the second convolution operand B vertically and horizontally using flip .
 <b>Note:</b>
 <ul>
   <li>
    An example using the discrete fourier transform can be found at
     opencv_source_code/samples/cpp/dft.cpp
   </li>
   <li>
    (Python) An example using the dft functionality to perform Wiener deconvolution can be found
     at opencv_source/samples/python/deconvolution.py
   </li>
   <li>
    (Python) An example rearranging the quadrants of a Fourier image can be found at
     opencv_source/samples/python/dft.py
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array that could be real or complex.</dd>
<dd><code>dst</code> - output array whose size and type depends on the flags .</dd>
<dd><code>flags</code> - transformation flags, representing a combination of the #DftFlags
 nonzeroRows rows of the input array (#DFT_INVERSE is not set) or only the first nonzeroRows of the
 output array (#DFT_INVERSE is set) contain non-zeros, thus, the function can handle the rest of the
 rows more efficiently and save some time; this technique is very useful for calculating array
 cross-correlation or convolution using DFT.
 SEE: dct, getOptimalDFTSize, mulSpectrums, filter2D, matchTemplate, flip, cartToPolar,
 magnitude, phase</dd>
</dl>
</li>
</ul>
<a name="dft-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dft</h4>
<pre>public static&nbsp;void&nbsp;dft(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array.

 The function cv::dft performs one of the following:
 <ul>
   <li>
    Forward the Fourier transform of a 1D vector of N elements:
     \(Y = F^{(N)}  \cdot X,\)
     where \(F^{(N)}_{jk}=\exp(-2\pi i j k/N)\) and \(i=\sqrt{-1}\)
   </li>
   <li>
    Inverse the Fourier transform of a 1D vector of N elements:
     \(\begin{array}{l} X'=  \left (F^{(N)} \right )^{-1}  \cdot Y =  \left (F^{(N)} \right )^*  \cdot y  \\ X = (1/N)  \cdot X, \end{array}\)
     where \(F^*=\left(\textrm{Re}(F^{(N)})-\textrm{Im}(F^{(N)})\right)^T\)
   </li>
   <li>
    Forward the 2D Fourier transform of a M x N matrix:
     \(Y = F^{(M)}  \cdot X  \cdot F^{(N)}\)
   </li>
   <li>
    Inverse the 2D Fourier transform of a M x N matrix:
     \(\begin{array}{l} X'=  \left (F^{(M)} \right )^*  \cdot Y  \cdot \left (F^{(N)} \right )^* \\ X =  \frac{1}{M \cdot N} \cdot X' \end{array}\)
   </li>
 </ul>

 In case of real (single-channel) data, the output spectrum of the forward Fourier transform or input
 spectrum of the inverse Fourier transform can be represented in a packed format called *CCS*
 (complex-conjugate-symmetrical). It was borrowed from IPL (Intel\* Image Processing Library). Here
 is how 2D *CCS* spectrum looks:
 \(\begin{bmatrix} Re Y_{0,0} &amp; Re Y_{0,1} &amp; Im Y_{0,1} &amp; Re Y_{0,2} &amp; Im Y_{0,2} &amp;  \cdots &amp; Re Y_{0,N/2-1} &amp; Im Y_{0,N/2-1} &amp; Re Y_{0,N/2}  \\ Re Y_{1,0} &amp; Re Y_{1,1} &amp; Im Y_{1,1} &amp; Re Y_{1,2} &amp; Im Y_{1,2} &amp;  \cdots &amp; Re Y_{1,N/2-1} &amp; Im Y_{1,N/2-1} &amp; Re Y_{1,N/2}  \\ Im Y_{1,0} &amp; Re Y_{2,1} &amp; Im Y_{2,1} &amp; Re Y_{2,2} &amp; Im Y_{2,2} &amp;  \cdots &amp; Re Y_{2,N/2-1} &amp; Im Y_{2,N/2-1} &amp; Im Y_{1,N/2}  \\ \hdotsfor{9} \\ Re Y_{M/2-1,0} &amp;  Re Y_{M-3,1}  &amp; Im Y_{M-3,1} &amp;  \hdotsfor{3} &amp; Re Y_{M-3,N/2-1} &amp; Im Y_{M-3,N/2-1}&amp; Re Y_{M/2-1,N/2}  \\ Im Y_{M/2-1,0} &amp;  Re Y_{M-2,1}  &amp; Im Y_{M-2,1} &amp;  \hdotsfor{3} &amp; Re Y_{M-2,N/2-1} &amp; Im Y_{M-2,N/2-1}&amp; Im Y_{M/2-1,N/2}  \\ Re Y_{M/2,0}  &amp;  Re Y_{M-1,1} &amp;  Im Y_{M-1,1} &amp;  \hdotsfor{3} &amp; Re Y_{M-1,N/2-1} &amp; Im Y_{M-1,N/2-1}&amp; Re Y_{M/2,N/2} \end{bmatrix}\)

 In case of 1D transform of a real vector, the output looks like the first row of the matrix above.

 So, the function chooses an operation mode depending on the flags and size of the input array:
 <ul>
   <li>
    If #DFT_ROWS is set or the input array has a single row or single column, the function
     performs a 1D forward or inverse transform of each row of a matrix when #DFT_ROWS is set.
     Otherwise, it performs a 2D transform.
   </li>
   <li>
    If the input array is real and #DFT_INVERSE is not set, the function performs a forward 1D or
     2D transform:
   <ul>
     <li>
        When #DFT_COMPLEX_OUTPUT is set, the output is a complex matrix of the same size as
         input.
     </li>
     <li>
        When #DFT_COMPLEX_OUTPUT is not set, the output is a real matrix of the same size as
         input. In case of 2D transform, it uses the packed format as shown above. In case of a
         single 1D transform, it looks like the first row of the matrix above. In case of
         multiple 1D transforms (when using the #DFT_ROWS flag), each row of the output matrix
         looks like the first row of the matrix above.
     </li>
   </ul>
   <li>
    If the input array is complex and either #DFT_INVERSE or #DFT_REAL_OUTPUT are not set, the
     output is a complex array of the same size as input. The function performs a forward or
     inverse 1D or 2D transform of the whole input array or each row of the input array
     independently, depending on the flags DFT_INVERSE and DFT_ROWS.
   </li>
   <li>
    When #DFT_INVERSE is set and the input array is real, or it is complex but #DFT_REAL_OUTPUT
     is set, the output is a real array of the same size as input. The function performs a 1D or 2D
     inverse transformation of the whole input array or each individual row, depending on the flags
     #DFT_INVERSE and #DFT_ROWS.
   </li>
 </ul>

 If #DFT_SCALE is set, the scaling is done after the transformation.

 Unlike dct, the function supports arrays of arbitrary size. But only those arrays are processed
 efficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the
 current implementation). Such an efficient DFT size can be calculated using the getOptimalDFTSize
 method.

 The sample below illustrates how to calculate a DFT-based convolution of two 2D real arrays:
 <code>
     void convolveDFT(InputArray A, InputArray B, OutputArray C)
     {
         // reallocate the output array if needed
         C.create(abs(A.rows - B.rows)+1, abs(A.cols - B.cols)+1, A.type());
         Size dftSize;
         // calculate the size of DFT transform
         dftSize.width = getOptimalDFTSize(A.cols + B.cols - 1);
         dftSize.height = getOptimalDFTSize(A.rows + B.rows - 1);

         // allocate temporary buffers and initialize them with 0's
         Mat tempA(dftSize, A.type(), Scalar::all(0));
         Mat tempB(dftSize, B.type(), Scalar::all(0));

         // copy A and B to the top-left corners of tempA and tempB, respectively
         Mat roiA(tempA, Rect(0,0,A.cols,A.rows));
         A.copyTo(roiA);
         Mat roiB(tempB, Rect(0,0,B.cols,B.rows));
         B.copyTo(roiB);

         // now transform the padded A &amp; B in-place;
         // use "nonzeroRows" hint for faster processing
         dft(tempA, tempA, 0, A.rows);
         dft(tempB, tempB, 0, B.rows);

         // multiply the spectrums;
         // the function handles packed spectrum representations well
         mulSpectrums(tempA, tempB, tempA);

         // transform the product back from the frequency domain.
         // Even though all the result rows will be non-zero,
         // you need only the first C.rows of them, and thus you
         // pass nonzeroRows == C.rows
         dft(tempA, tempA, DFT_INVERSE + DFT_SCALE, C.rows);

         // now copy the result back to C.
         tempA(Rect(0, 0, C.cols, C.rows)).copyTo(C);

         // all the temporary buffers will be deallocated automatically
     }
 </code>
 To optimize this sample, consider the following approaches:
 <ul>
   <li>
    Since nonzeroRows != 0 is passed to the forward transform calls and since A and B are copied to
     the top-left corners of tempA and tempB, respectively, it is not necessary to clear the whole
     tempA and tempB. It is only necessary to clear the tempA.cols - A.cols ( tempB.cols - B.cols)
     rightmost columns of the matrices.
   </li>
   <li>
    This DFT-based convolution does not have to be applied to the whole big arrays, especially if B
     is significantly smaller than A or vice versa. Instead, you can calculate convolution by parts.
     To do this, you need to split the output array C into multiple tiles. For each tile, estimate
     which parts of A and B are required to calculate convolution in this tile. If the tiles in C are
     too small, the speed will decrease a lot because of repeated work. In the ultimate case, when
     each tile in C is a single pixel, the algorithm becomes equivalent to the naive convolution
     algorithm. If the tiles are too big, the temporary arrays tempA and tempB become too big and
     there is also a slowdown because of bad cache locality. So, there is an optimal tile size
     somewhere in the middle.
   </li>
   <li>
    If different tiles in C can be calculated in parallel and, thus, the convolution is done by
     parts, the loop can be threaded.
   </li>
 </ul>

 All of the above improvements have been implemented in #matchTemplate and #filter2D . Therefore, by
 using them, you can get the performance even better than with the above theoretically optimal
 implementation. Though, those two functions actually calculate cross-correlation, not convolution,
 so you need to "flip" the second convolution operand B vertically and horizontally using flip .
 <b>Note:</b>
 <ul>
   <li>
    An example using the discrete fourier transform can be found at
     opencv_source_code/samples/cpp/dft.cpp
   </li>
   <li>
    (Python) An example using the dft functionality to perform Wiener deconvolution can be found
     at opencv_source/samples/python/deconvolution.py
   </li>
   <li>
    (Python) An example rearranging the quadrants of a Fourier image can be found at
     opencv_source/samples/python/dft.py
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input array that could be real or complex.</dd>
<dd><code>dst</code> - output array whose size and type depends on the flags .
 nonzeroRows rows of the input array (#DFT_INVERSE is not set) or only the first nonzeroRows of the
 output array (#DFT_INVERSE is set) contain non-zeros, thus, the function can handle the rest of the
 rows more efficiently and save some time; this technique is very useful for calculating array
 cross-correlation or convolution using DFT.
 SEE: dct, getOptimalDFTSize, mulSpectrums, filter2D, matchTemplate, flip, cartToPolar,
 magnitude, phase</dd>
</dl>
</li>
</ul>
<a name="idft-org.opencv.core.Mat-org.opencv.core.Mat-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idft</h4>
<pre>public static&nbsp;void&nbsp;idft(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                        int&nbsp;flags,
                        int&nbsp;nonzeroRows)</pre>
<div class="block">Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.

 idft(src, dst, flags) is equivalent to dft(src, dst, flags | #DFT_INVERSE) .
 <b>Note:</b> None of dft and idft scales the result by default. So, you should pass #DFT_SCALE to one of
 dft or idft explicitly to make these transforms mutually inverse.
 SEE: dft, dct, idct, mulSpectrums, getOptimalDFTSize</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input floating-point real or complex array.</dd>
<dd><code>dst</code> - output array whose size and type depend on the flags.</dd>
<dd><code>flags</code> - operation flags (see dft and #DftFlags).</dd>
<dd><code>nonzeroRows</code> - number of dst rows to process; the rest of the rows have undefined content (see
 the convolution sample in dft description.</dd>
</dl>
</li>
</ul>
<a name="idft-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idft</h4>
<pre>public static&nbsp;void&nbsp;idft(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                        int&nbsp;flags)</pre>
<div class="block">Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.

 idft(src, dst, flags) is equivalent to dft(src, dst, flags | #DFT_INVERSE) .
 <b>Note:</b> None of dft and idft scales the result by default. So, you should pass #DFT_SCALE to one of
 dft or idft explicitly to make these transforms mutually inverse.
 SEE: dft, dct, idct, mulSpectrums, getOptimalDFTSize</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input floating-point real or complex array.</dd>
<dd><code>dst</code> - output array whose size and type depend on the flags.</dd>
<dd><code>flags</code> - operation flags (see dft and #DftFlags).
 the convolution sample in dft description.</dd>
</dl>
</li>
</ul>
<a name="idft-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idft</h4>
<pre>public static&nbsp;void&nbsp;idft(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.

 idft(src, dst, flags) is equivalent to dft(src, dst, flags | #DFT_INVERSE) .
 <b>Note:</b> None of dft and idft scales the result by default. So, you should pass #DFT_SCALE to one of
 dft or idft explicitly to make these transforms mutually inverse.
 SEE: dft, dct, idct, mulSpectrums, getOptimalDFTSize</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input floating-point real or complex array.</dd>
<dd><code>dst</code> - output array whose size and type depend on the flags.
 the convolution sample in dft description.</dd>
</dl>
</li>
</ul>
<a name="dct-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dct</h4>
<pre>public static&nbsp;void&nbsp;dct(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                       int&nbsp;flags)</pre>
<div class="block">Performs a forward or inverse discrete Cosine transform of 1D or 2D array.

 The function cv::dct performs a forward or inverse discrete Cosine transform (DCT) of a 1D or 2D
 floating-point array:
 <ul>
   <li>
    Forward Cosine transform of a 1D vector of N elements:
     \(Y = C^{(N)}  \cdot X\)
     where
     \(C^{(N)}_{jk}= \sqrt{\alpha_j/N} \cos \left ( \frac{\pi(2k+1)j}{2N} \right )\)
     and
     \(\alpha_0=1\), \(\alpha_j=2\) for *j &gt; 0*.
   </li>
   <li>
    Inverse Cosine transform of a 1D vector of N elements:
     \(X =  \left (C^{(N)} \right )^{-1}  \cdot Y =  \left (C^{(N)} \right )^T  \cdot Y\)
     (since \(C^{(N)}\) is an orthogonal matrix, \(C^{(N)} \cdot \left(C^{(N)}\right)^T = I\) )
   </li>
   <li>
    Forward 2D Cosine transform of M x N matrix:
     \(Y = C^{(N)}  \cdot X  \cdot \left (C^{(N)} \right )^T\)
   </li>
   <li>
    Inverse 2D Cosine transform of M x N matrix:
     \(X =  \left (C^{(N)} \right )^T  \cdot X  \cdot C^{(N)}\)
   </li>
 </ul>

 The function chooses the mode of operation by looking at the flags and size of the input array:
 <ul>
   <li>
    If (flags &amp; #DCT_INVERSE) == 0, the function does a forward 1D or 2D transform. Otherwise, it
     is an inverse 1D or 2D transform.
   </li>
   <li>
    If (flags &amp; #DCT_ROWS) != 0, the function performs a 1D transform of each row.
   </li>
   <li>
    If the array is a single column or a single row, the function performs a 1D transform.
   </li>
   <li>
    If none of the above is true, the function performs a 2D transform.
   </li>
 </ul>

 <b>Note:</b> Currently dct supports even-size arrays (2, 4, 6 ...). For data analysis and approximation, you
 can pad the array when necessary.
 Also, the function performance depends very much, and not monotonically, on the array size (see
 getOptimalDFTSize ). In the current implementation DCT of a vector of size N is calculated via DFT
 of a vector of size N/2 . Thus, the optimal DCT size N1 &gt;= N can be calculated as:
 <code>
     size_t getOptimalDCTSize(size_t N) { return 2*getOptimalDFTSize((N+1)/2); }
     N1 = getOptimalDCTSize(N);
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input floating-point array.</dd>
<dd><code>dst</code> - output array of the same size and type as src .</dd>
<dd><code>flags</code> - transformation flags as a combination of cv::DftFlags (DCT_*)
 SEE: dft, getOptimalDFTSize, idct</dd>
</dl>
</li>
</ul>
<a name="dct-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dct</h4>
<pre>public static&nbsp;void&nbsp;dct(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Performs a forward or inverse discrete Cosine transform of 1D or 2D array.

 The function cv::dct performs a forward or inverse discrete Cosine transform (DCT) of a 1D or 2D
 floating-point array:
 <ul>
   <li>
    Forward Cosine transform of a 1D vector of N elements:
     \(Y = C^{(N)}  \cdot X\)
     where
     \(C^{(N)}_{jk}= \sqrt{\alpha_j/N} \cos \left ( \frac{\pi(2k+1)j}{2N} \right )\)
     and
     \(\alpha_0=1\), \(\alpha_j=2\) for *j &gt; 0*.
   </li>
   <li>
    Inverse Cosine transform of a 1D vector of N elements:
     \(X =  \left (C^{(N)} \right )^{-1}  \cdot Y =  \left (C^{(N)} \right )^T  \cdot Y\)
     (since \(C^{(N)}\) is an orthogonal matrix, \(C^{(N)} \cdot \left(C^{(N)}\right)^T = I\) )
   </li>
   <li>
    Forward 2D Cosine transform of M x N matrix:
     \(Y = C^{(N)}  \cdot X  \cdot \left (C^{(N)} \right )^T\)
   </li>
   <li>
    Inverse 2D Cosine transform of M x N matrix:
     \(X =  \left (C^{(N)} \right )^T  \cdot X  \cdot C^{(N)}\)
   </li>
 </ul>

 The function chooses the mode of operation by looking at the flags and size of the input array:
 <ul>
   <li>
    If (flags &amp; #DCT_INVERSE) == 0, the function does a forward 1D or 2D transform. Otherwise, it
     is an inverse 1D or 2D transform.
   </li>
   <li>
    If (flags &amp; #DCT_ROWS) != 0, the function performs a 1D transform of each row.
   </li>
   <li>
    If the array is a single column or a single row, the function performs a 1D transform.
   </li>
   <li>
    If none of the above is true, the function performs a 2D transform.
   </li>
 </ul>

 <b>Note:</b> Currently dct supports even-size arrays (2, 4, 6 ...). For data analysis and approximation, you
 can pad the array when necessary.
 Also, the function performance depends very much, and not monotonically, on the array size (see
 getOptimalDFTSize ). In the current implementation DCT of a vector of size N is calculated via DFT
 of a vector of size N/2 . Thus, the optimal DCT size N1 &gt;= N can be calculated as:
 <code>
     size_t getOptimalDCTSize(size_t N) { return 2*getOptimalDFTSize((N+1)/2); }
     N1 = getOptimalDCTSize(N);
 </code></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input floating-point array.</dd>
<dd><code>dst</code> - output array of the same size and type as src .
 SEE: dft, getOptimalDFTSize, idct</dd>
</dl>
</li>
</ul>
<a name="idct-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idct</h4>
<pre>public static&nbsp;void&nbsp;idct(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                        int&nbsp;flags)</pre>
<div class="block">Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.

 idct(src, dst, flags) is equivalent to dct(src, dst, flags | DCT_INVERSE).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input floating-point single-channel array.</dd>
<dd><code>dst</code> - output array of the same size and type as src.</dd>
<dd><code>flags</code> - operation flags.
 SEE:  dct, dft, idft, getOptimalDFTSize</dd>
</dl>
</li>
</ul>
<a name="idct-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idct</h4>
<pre>public static&nbsp;void&nbsp;idct(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                        <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.

 idct(src, dst, flags) is equivalent to dct(src, dst, flags | DCT_INVERSE).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>src</code> - input floating-point single-channel array.</dd>
<dd><code>dst</code> - output array of the same size and type as src.
 SEE:  dct, dft, idft, getOptimalDFTSize</dd>
</dl>
</li>
</ul>
<a name="mulSpectrums-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mulSpectrums</h4>
<pre>public static&nbsp;void&nbsp;mulSpectrums(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;b,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;c,
                                int&nbsp;flags,
                                boolean&nbsp;conjB)</pre>
<div class="block">Performs the per-element multiplication of two Fourier spectrums.

 The function cv::mulSpectrums performs the per-element multiplication of the two CCS-packed or complex
 matrices that are results of a real or complex Fourier transform.

 The function, together with dft and idft, may be used to calculate convolution (pass conjB=false )
 or correlation (pass conjB=true ) of two arrays rapidly. When the arrays are complex, they are
 simply multiplied (per element) with an optional conjugation of the second-array elements. When the
 arrays are real, they are assumed to be CCS-packed (see dft for details).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - first input array.</dd>
<dd><code>b</code> - second input array of the same size and type as src1 .</dd>
<dd><code>c</code> - output array of the same size and type as src1 .</dd>
<dd><code>flags</code> - operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that
 each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a <code>0</code> as value.</dd>
<dd><code>conjB</code> - optional flag that conjugates the second input array before the multiplication (true)
 or not (false).</dd>
</dl>
</li>
</ul>
<a name="mulSpectrums-org.opencv.core.Mat-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mulSpectrums</h4>
<pre>public static&nbsp;void&nbsp;mulSpectrums(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;a,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;b,
                                <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;c,
                                int&nbsp;flags)</pre>
<div class="block">Performs the per-element multiplication of two Fourier spectrums.

 The function cv::mulSpectrums performs the per-element multiplication of the two CCS-packed or complex
 matrices that are results of a real or complex Fourier transform.

 The function, together with dft and idft, may be used to calculate convolution (pass conjB=false )
 or correlation (pass conjB=true ) of two arrays rapidly. When the arrays are complex, they are
 simply multiplied (per element) with an optional conjugation of the second-array elements. When the
 arrays are real, they are assumed to be CCS-packed (see dft for details).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - first input array.</dd>
<dd><code>b</code> - second input array of the same size and type as src1 .</dd>
<dd><code>c</code> - output array of the same size and type as src1 .</dd>
<dd><code>flags</code> - operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that
 each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a <code>0</code> as value.
 or not (false).</dd>
</dl>
</li>
</ul>
<a name="getOptimalDFTSize-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOptimalDFTSize</h4>
<pre>public static&nbsp;int&nbsp;getOptimalDFTSize(int&nbsp;vecsize)</pre>
<div class="block">Returns the optimal DFT size for a given vector size.

 DFT performance is not a monotonic function of a vector size. Therefore, when you calculate
 convolution of two arrays or perform the spectral analysis of an array, it usually makes sense to
 pad the input data with zeros to get a bit larger array that can be transformed much faster than the
 original one. Arrays whose size is a power-of-two (2, 4, 8, 16, 32, ...) are the fastest to process.
 Though, the arrays whose size is a product of 2's, 3's, and 5's (for example, 300 = 5\*5\*3\*2\*2)
 are also processed quite efficiently.

 The function cv::getOptimalDFTSize returns the minimum number N that is greater than or equal to vecsize
 so that the DFT of a vector of size N can be processed efficiently. In the current implementation N
 = 2 ^p^ \* 3 ^q^ \* 5 ^r^ for some integer p, q, r.

 The function returns a negative number if vecsize is too large (very close to INT_MAX ).

 While the function cannot be used directly to estimate the optimal vector size for DCT transform
 (since the current DCT implementation supports only even-size vectors), it can be easily processed
 as getOptimalDFTSize((vecsize+1)/2)\*2.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vecsize</code> - vector size.
 SEE: dft, dct, idft, idct, mulSpectrums</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="setRNGSeed-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setRNGSeed</h4>
<pre>public static&nbsp;void&nbsp;setRNGSeed(int&nbsp;seed)</pre>
<div class="block">Sets state of default random number generator.

 The function cv::setRNGSeed sets state of default random number generator to custom value.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>seed</code> - new state for default random number generator
 SEE: RNG, randu, randn</dd>
</dl>
</li>
</ul>
<a name="randu-org.opencv.core.Mat-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randu</h4>
<pre>public static&nbsp;void&nbsp;randu(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         double&nbsp;low,
                         double&nbsp;high)</pre>
<div class="block">Generates a single uniformly-distributed random number or an array of random numbers.

 Non-template variant of the function fills the matrix dst with uniformly-distributed
 random numbers from the specified range:
 \(\texttt{low} _c  \leq \texttt{dst} (I)_c &lt;  \texttt{high} _c\)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dst</code> - output array of random numbers; the array must be pre-allocated.</dd>
<dd><code>low</code> - inclusive lower boundary of the generated random numbers.</dd>
<dd><code>high</code> - exclusive upper boundary of the generated random numbers.
 SEE: RNG, randn, theRNG</dd>
</dl>
</li>
</ul>
<a name="randn-org.opencv.core.Mat-double-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randn</h4>
<pre>public static&nbsp;void&nbsp;randn(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                         double&nbsp;mean,
                         double&nbsp;stddev)</pre>
<div class="block">Fills the array with normally distributed random numbers.

 The function cv::randn fills the matrix dst with normally distributed random numbers with the specified
 mean vector and the standard deviation matrix. The generated random numbers are clipped to fit the
 value range of the output array data type.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dst</code> - output array of random numbers; the array must be pre-allocated and have 1 to 4 channels.</dd>
<dd><code>mean</code> - mean value (expectation) of the generated random numbers.</dd>
<dd><code>stddev</code> - standard deviation of the generated random numbers; it can be either a vector (in
 which case a diagonal standard deviation matrix is assumed) or a square matrix.
 SEE: RNG, randu</dd>
</dl>
</li>
</ul>
<a name="randShuffle-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randShuffle</h4>
<pre>public static&nbsp;void&nbsp;randShuffle(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                               double&nbsp;iterFactor)</pre>
<div class="block">Shuffles the array elements randomly.

 The function cv::randShuffle shuffles the specified 1D array by randomly choosing pairs of elements and
 swapping them. The number of such swap operations will be dst.rows\*dst.cols\*iterFactor .</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dst</code> - input/output numerical 1D array.</dd>
<dd><code>iterFactor</code> - scale factor that determines the number of random swap operations (see the details
 below).
 instead.
 SEE: RNG, sort</dd>
</dl>
</li>
</ul>
<a name="randShuffle-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>randShuffle</h4>
<pre>public static&nbsp;void&nbsp;randShuffle(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
<div class="block">Shuffles the array elements randomly.

 The function cv::randShuffle shuffles the specified 1D array by randomly choosing pairs of elements and
 swapping them. The number of such swap operations will be dst.rows\*dst.cols\*iterFactor .</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dst</code> - input/output numerical 1D array.
 below).
 instead.
 SEE: RNG, sort</dd>
</dl>
</li>
</ul>
<a name="kmeans-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.TermCriteria-int-int-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>kmeans</h4>
<pre>public static&nbsp;double&nbsp;kmeans(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
                            int&nbsp;K,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;bestLabels,
                            <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria,
                            int&nbsp;attempts,
                            int&nbsp;flags,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;centers)</pre>
<div class="block">Finds centers of clusters and groups input samples around the clusters.

 The function kmeans implements a k-means algorithm that finds the centers of cluster_count clusters
 and groups the input samples around the clusters. As an output, \(\texttt{bestLabels}_i\) contains a
 0-based cluster index for the sample stored in the \(i^{th}\) row of the samples matrix.

 <b>Note:</b>
 <ul>
   <li>
    (Python) An example on k-means clustering can be found at
     opencv_source_code/samples/python/kmeans.py
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>data</code> - Data for clustering. An array of N-Dimensional points with float coordinates is needed.
 Examples of this array can be:
 <ul>
   <li>
    Mat points(count, 2, CV_32F);
   </li>
   <li>
    Mat points(count, 1, CV_32FC2);
   </li>
   <li>
    Mat points(1, count, CV_32FC2);
   </li>
   <li>
    std::vector&lt;cv::Point2f&gt; points(sampleCount);
   </li>
 </ul></dd>
<dd><code>K</code> - Number of clusters to split the set by.</dd>
<dd><code>bestLabels</code> - Input/output integer array that stores the cluster indices for every sample.</dd>
<dd><code>criteria</code> - The algorithm termination criteria, that is, the maximum number of iterations and/or
 the desired accuracy. The accuracy is specified as criteria.epsilon. As soon as each of the cluster
 centers moves by less than criteria.epsilon on some iteration, the algorithm stops.</dd>
<dd><code>attempts</code> - Flag to specify the number of times the algorithm is executed using different
 initial labellings. The algorithm returns the labels that yield the best compactness (see the last
 function parameter).</dd>
<dd><code>flags</code> - Flag that can take values of cv::KmeansFlags</dd>
<dd><code>centers</code> - Output matrix of the cluster centers, one row per each cluster center.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The function returns the compactness measure that is computed as
 \(\sum _i  \| \texttt{samples} _i -  \texttt{centers} _{ \texttt{labels} _i} \| ^2\)
 after every attempt. The best (minimum) value is chosen and the corresponding labels and the
 compactness value are returned by the function. Basically, you can use only the core of the
 function, set the number of attempts to 1, initialize labels each time using a custom algorithm,
 pass them with the ( flags = #KMEANS_USE_INITIAL_LABELS ) flag, and then choose the best
 (most-compact) clustering.</dd>
</dl>
</li>
</ul>
<a name="kmeans-org.opencv.core.Mat-int-org.opencv.core.Mat-org.opencv.core.TermCriteria-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>kmeans</h4>
<pre>public static&nbsp;double&nbsp;kmeans(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;data,
                            int&nbsp;K,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;bestLabels,
                            <a href="../../../org/opencv/core/TermCriteria.html" title="class in org.opencv.core">TermCriteria</a>&nbsp;criteria,
                            int&nbsp;attempts,
                            int&nbsp;flags)</pre>
<div class="block">Finds centers of clusters and groups input samples around the clusters.

 The function kmeans implements a k-means algorithm that finds the centers of cluster_count clusters
 and groups the input samples around the clusters. As an output, \(\texttt{bestLabels}_i\) contains a
 0-based cluster index for the sample stored in the \(i^{th}\) row of the samples matrix.

 <b>Note:</b>
 <ul>
   <li>
    (Python) An example on k-means clustering can be found at
     opencv_source_code/samples/python/kmeans.py
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>data</code> - Data for clustering. An array of N-Dimensional points with float coordinates is needed.
 Examples of this array can be:
 <ul>
   <li>
    Mat points(count, 2, CV_32F);
   </li>
   <li>
    Mat points(count, 1, CV_32FC2);
   </li>
   <li>
    Mat points(1, count, CV_32FC2);
   </li>
   <li>
    std::vector&lt;cv::Point2f&gt; points(sampleCount);
   </li>
 </ul></dd>
<dd><code>K</code> - Number of clusters to split the set by.</dd>
<dd><code>bestLabels</code> - Input/output integer array that stores the cluster indices for every sample.</dd>
<dd><code>criteria</code> - The algorithm termination criteria, that is, the maximum number of iterations and/or
 the desired accuracy. The accuracy is specified as criteria.epsilon. As soon as each of the cluster
 centers moves by less than criteria.epsilon on some iteration, the algorithm stops.</dd>
<dd><code>attempts</code> - Flag to specify the number of times the algorithm is executed using different
 initial labellings. The algorithm returns the labels that yield the best compactness (see the last
 function parameter).</dd>
<dd><code>flags</code> - Flag that can take values of cv::KmeansFlags</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The function returns the compactness measure that is computed as
 \(\sum _i  \| \texttt{samples} _i -  \texttt{centers} _{ \texttt{labels} _i} \| ^2\)
 after every attempt. The best (minimum) value is chosen and the corresponding labels and the
 compactness value are returned by the function. Basically, you can use only the core of the
 function, set the number of attempts to 1, initialize labels each time using a custom algorithm,
 pass them with the ( flags = #KMEANS_USE_INITIAL_LABELS ) flag, and then choose the best
 (most-compact) clustering.</dd>
</dl>
</li>
</ul>
<a name="setNumThreads-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNumThreads</h4>
<pre>public static&nbsp;void&nbsp;setNumThreads(int&nbsp;nthreads)</pre>
<div class="block">OpenCV will try to set the number of threads for subsequent parallel regions.

 If threads == 1, OpenCV will disable threading optimizations and run all it's functions
 sequentially. Passing threads &lt; 0 will reset threads number to system default.
 The function is not thread-safe. It must not be called in parallel region or concurrent threads.

 OpenCV will try to run its functions with specified threads number, but some behaviour differs from
 framework:
 <ul>
   <li>
    <code>TBB</code> - User-defined parallel constructions will run with the same threads number, if
     another is not specified. If later on user creates his own scheduler, OpenCV will use it.
   </li>
   <li>
    <code>OpenMP</code> - No special defined behaviour.
   </li>
   <li>
    <code>Concurrency</code> - If threads == 1, OpenCV will disable threading optimizations and run its
     functions sequentially.
   </li>
   <li>
    <code>GCD</code> - Supports only values &lt;= 0.
   </li>
   <li>
    <code>C=</code> - No special defined behaviour.
   </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nthreads</code> - Number of threads used by OpenCV.
 SEE: getNumThreads, getThreadNum</dd>
</dl>
</li>
</ul>
<a name="getNumThreads--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNumThreads</h4>
<pre>public static&nbsp;int&nbsp;getNumThreads()</pre>
<div class="block">Returns the number of threads used by OpenCV for parallel regions.

 Always returns 1 if OpenCV is built without threading support.

 The exact meaning of return value depends on the threading framework used by OpenCV library:
 <ul>
   <li>
  <code>TBB</code> - The number of threads, that OpenCV will try to use for parallel regions. If there is
   any tbb::thread_scheduler_init in user code conflicting with OpenCV, then function returns
   default number of threads used by TBB library.
   </li>
   <li>
  <code>OpenMP</code> - An upper bound on the number of threads that could be used to form a new team.
   </li>
   <li>
  <code>Concurrency</code> - The number of threads, that OpenCV will try to use for parallel regions.
   </li>
   <li>
  <code>GCD</code> - Unsupported; returns the GCD thread pool limit (512) for compatibility.
   </li>
   <li>
  <code>C=</code> - The number of threads, that OpenCV will try to use for parallel regions, if before
   called setNumThreads with threads &gt; 0, otherwise returns the number of logical CPUs,
   available for the process.
 SEE: setNumThreads, getThreadNum
   </li>
 </ul></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getThreadNum--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getThreadNum</h4>
<pre><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html?is-external=true" title="class or interface in java.lang">@Deprecated</a>
public static&nbsp;int&nbsp;getThreadNum()</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">Current implementation doesn't corresponding to this documentation.

 The exact meaning of the return value depends on the threading framework used by OpenCV library:
 <ul>
   <li>
  <code>TBB</code> - Unsupported with current 4.1 TBB release. Maybe will be supported in future.
   </li>
   <li>
  <code>OpenMP</code> - The thread number, within the current team, of the calling thread.
   </li>
   <li>
  <code>Concurrency</code> - An ID for the virtual processor that the current context is executing on (0
   for master thread and unique number for others, but not necessary 1,2,3,...).
   </li>
   <li>
  <code>GCD</code> - System calling thread's ID. Never returns 0 inside parallel region.
   </li>
   <li>
  <code>C=</code> - The index of the current parallel task.
 SEE: setNumThreads, getNumThreads
   </li>
 </ul></span></div>
<div class="block">Returns the index of the currently executed thread within the current parallel region. Always
 returns 0 if called outside of parallel region.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getBuildInformation--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBuildInformation</h4>
<pre>public static&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;getBuildInformation()</pre>
<div class="block">Returns full configuration time cmake output.

 Returned value is raw cmake output including version control system revision, compiler version,
 compiler flags, enabled modules and third party libraries, etc. Output format depends on target
 architecture.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getVersionString--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getVersionString</h4>
<pre>public static&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;getVersionString()</pre>
<div class="block">Returns library version string

 For example "3.4.1-dev".

 SEE: getMajorVersion, getMinorVersion, getRevisionVersion</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getVersionMajor--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getVersionMajor</h4>
<pre>public static&nbsp;int&nbsp;getVersionMajor()</pre>
<div class="block">Returns major library version</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getVersionMinor--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getVersionMinor</h4>
<pre>public static&nbsp;int&nbsp;getVersionMinor()</pre>
<div class="block">Returns minor library version</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getVersionRevision--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getVersionRevision</h4>
<pre>public static&nbsp;int&nbsp;getVersionRevision()</pre>
<div class="block">Returns revision field of the library version</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getTickCount--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTickCount</h4>
<pre>public static&nbsp;long&nbsp;getTickCount()</pre>
<div class="block">Returns the number of ticks.

 The function returns the number of ticks after the certain event (for example, when the machine was
 turned on). It can be used to initialize RNG or to measure a function execution time by reading the
 tick count before and after the function call.
 SEE: getTickFrequency, TickMeter</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getTickFrequency--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTickFrequency</h4>
<pre>public static&nbsp;double&nbsp;getTickFrequency()</pre>
<div class="block">Returns the number of ticks per second.

 The function returns the number of ticks per second. That is, the following code computes the
 execution time in seconds:
 <code>
     double t = (double)getTickCount();
     // do something ...
     t = ((double)getTickCount() - t)/getTickFrequency();
 </code>
 SEE: getTickCount, TickMeter</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getCPUTickCount--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCPUTickCount</h4>
<pre>public static&nbsp;long&nbsp;getCPUTickCount()</pre>
<div class="block">Returns the number of CPU ticks.

 The function returns the current number of CPU ticks on some architectures (such as x86, x64,
 PowerPC). On other platforms the function is equivalent to getTickCount. It can also be used for
 very accurate time measurements, as well as for RNG initialization. Note that in case of multi-CPU
 systems a thread, from which getCPUTickCount is called, can be suspended and resumed at another CPU
 with its own counter. So, theoretically (and practically) the subsequent calls to the function do
 not necessary return the monotonously increasing values. Also, since a modern CPU varies the CPU
 frequency depending on the load, the number of CPU clocks spent in some code cannot be directly
 converted to time units. Therefore, getTickCount is generally a preferable solution for measuring
 execution time.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="checkHardwareSupport-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkHardwareSupport</h4>
<pre>public static&nbsp;boolean&nbsp;checkHardwareSupport(int&nbsp;feature)</pre>
<div class="block">Returns true if the specified feature is supported by the host hardware.

 The function returns true if the host hardware supports the specified feature. When user calls
 setUseOptimized(false), the subsequent calls to checkHardwareSupport() will return false until
 setUseOptimized(true) is called. This way user can dynamically switch on and off the optimized code
 in OpenCV.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>feature</code> - The feature of interest, one of cv::CpuFeatures</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getHardwareFeatureName-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getHardwareFeatureName</h4>
<pre>public static&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;getHardwareFeatureName(int&nbsp;feature)</pre>
<div class="block">Returns feature name by ID

 Returns empty string if feature is not defined</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>feature</code> - automatically generated</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getCPUFeaturesLine--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCPUFeaturesLine</h4>
<pre>public static&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;getCPUFeaturesLine()</pre>
<div class="block">Returns list of CPU features enabled during compilation.

 Returned value is a string containing space separated list of CPU features with following markers:

 <ul>
   <li>
  no markers - baseline features
   </li>
   <li>
  prefix <code>*</code> - features enabled in dispatcher
   </li>
   <li>
  suffix <code>?</code> - features enabled but not available in HW
   </li>
 </ul>

 Example: <code>SSE SSE2 SSE3 *SSE4.1 *SSE4.2 *FP16 *AVX *AVX2 *AVX512-SKX?</code></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getNumberOfCPUs--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNumberOfCPUs</h4>
<pre>public static&nbsp;int&nbsp;getNumberOfCPUs()</pre>
<div class="block">Returns the number of logical CPUs available for the process.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="getDefaultAlgorithmHint--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getDefaultAlgorithmHint</h4>
<pre>public static&nbsp;int&nbsp;getDefaultAlgorithmHint()</pre>
</li>
</ul>
<a name="setUseOptimized-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUseOptimized</h4>
<pre>public static&nbsp;void&nbsp;setUseOptimized(boolean&nbsp;onoff)</pre>
<div class="block">Enables or disables the optimized code.

 The function can be used to dynamically turn on and off optimized dispatched code (code that uses SSE4.2, AVX/AVX2,
 and other instructions on the platforms that support it). It sets a global flag that is further
 checked by OpenCV functions. Since the flag is not checked in the inner OpenCV loops, it is only
 safe to call the function on the very top level in your application where you can be sure that no
 other OpenCV function is currently executed.

 By default, the optimized code is enabled unless you disable it in CMake. The current status can be
 retrieved using useOptimized.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>onoff</code> - The boolean flag specifying whether the optimized code should be used (onoff=true)
 or not (onoff=false).</dd>
</dl>
</li>
</ul>
<a name="useOptimized--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>useOptimized</h4>
<pre>public static&nbsp;boolean&nbsp;useOptimized()</pre>
<div class="block">Returns the status of optimized code usage.

 The function returns true if the optimized code is enabled. Otherwise, it returns false.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>automatically generated</dd>
</dl>
</li>
</ul>
<a name="findFile-java.lang.String-boolean-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findFile</h4>
<pre>public static&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;findFile(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;relative_path,
                              boolean&nbsp;required,
                              boolean&nbsp;silentMode)</pre>
<div class="block">Try to find requested data file

 Search directories:

 1. Directories passed via <code>addSamplesDataSearchPath()</code>
 2. OPENCV_SAMPLES_DATA_PATH_HINT environment variable
 3. OPENCV_SAMPLES_DATA_PATH environment variable
    If parameter value is not empty and nothing is found then stop searching.
 4. Detects build/install path based on:
    a. current working directory (CWD)
    b. and/or binary module location (opencv_core/opencv_world, doesn't work with static linkage)
 5. Scan <code>&amp;lt;source&amp;gt;/{,data,samples/data}</code> directories if build directory is detected or the current directory is in source tree.
 6. Scan <code>&amp;lt;install&amp;gt;/share/OpenCV</code> directory if install directory is detected.

 SEE: cv::utils::findDataFile</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>relative_path</code> - Relative path to data file</dd>
<dd><code>required</code> - Specify "file not found" handling.
        If true, function prints information message and raises cv::Exception.
        If false, function returns empty result</dd>
<dd><code>silentMode</code> - Disables messages</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns path (absolute or relative to the current directory) or empty string if file is not found</dd>
</dl>
</li>
</ul>
<a name="findFile-java.lang.String-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findFile</h4>
<pre>public static&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;findFile(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;relative_path,
                              boolean&nbsp;required)</pre>
<div class="block">Try to find requested data file

 Search directories:

 1. Directories passed via <code>addSamplesDataSearchPath()</code>
 2. OPENCV_SAMPLES_DATA_PATH_HINT environment variable
 3. OPENCV_SAMPLES_DATA_PATH environment variable
    If parameter value is not empty and nothing is found then stop searching.
 4. Detects build/install path based on:
    a. current working directory (CWD)
    b. and/or binary module location (opencv_core/opencv_world, doesn't work with static linkage)
 5. Scan <code>&amp;lt;source&amp;gt;/{,data,samples/data}</code> directories if build directory is detected or the current directory is in source tree.
 6. Scan <code>&amp;lt;install&amp;gt;/share/OpenCV</code> directory if install directory is detected.

 SEE: cv::utils::findDataFile</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>relative_path</code> - Relative path to data file</dd>
<dd><code>required</code> - Specify "file not found" handling.
        If true, function prints information message and raises cv::Exception.
        If false, function returns empty result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns path (absolute or relative to the current directory) or empty string if file is not found</dd>
</dl>
</li>
</ul>
<a name="findFile-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findFile</h4>
<pre>public static&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;findFile(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;relative_path)</pre>
<div class="block">Try to find requested data file

 Search directories:

 1. Directories passed via <code>addSamplesDataSearchPath()</code>
 2. OPENCV_SAMPLES_DATA_PATH_HINT environment variable
 3. OPENCV_SAMPLES_DATA_PATH environment variable
    If parameter value is not empty and nothing is found then stop searching.
 4. Detects build/install path based on:
    a. current working directory (CWD)
    b. and/or binary module location (opencv_core/opencv_world, doesn't work with static linkage)
 5. Scan <code>&amp;lt;source&amp;gt;/{,data,samples/data}</code> directories if build directory is detected or the current directory is in source tree.
 6. Scan <code>&amp;lt;install&amp;gt;/share/OpenCV</code> directory if install directory is detected.

 SEE: cv::utils::findDataFile</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>relative_path</code> - Relative path to data file
        If true, function prints information message and raises cv::Exception.
        If false, function returns empty result</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Returns path (absolute or relative to the current directory) or empty string if file is not found</dd>
</dl>
</li>
</ul>
<a name="findFileOrKeep-java.lang.String-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findFileOrKeep</h4>
<pre>public static&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;findFileOrKeep(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;relative_path,
                                    boolean&nbsp;silentMode)</pre>
</li>
</ul>
<a name="findFileOrKeep-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findFileOrKeep</h4>
<pre>public static&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;findFileOrKeep(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;relative_path)</pre>
</li>
</ul>
<a name="addSamplesDataSearchPath-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addSamplesDataSearchPath</h4>
<pre>public static&nbsp;void&nbsp;addSamplesDataSearchPath(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;path)</pre>
<div class="block">Override search data path by adding new search location

 Use this only to override default behavior
 Passed paths are used in LIFO order.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>path</code> - Path to used samples data</dd>
</dl>
</li>
</ul>
<a name="addSamplesDataSearchSubDirectory-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addSamplesDataSearchSubDirectory</h4>
<pre>public static&nbsp;void&nbsp;addSamplesDataSearchSubDirectory(<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;subdir)</pre>
<div class="block">Append samples search data sub directory

 General usage is to add OpenCV modules name (<code>&amp;lt;opencv_contrib&amp;gt;/modules/&amp;lt;name&amp;gt;/samples/data</code> -&gt; <code>&amp;lt;name&amp;gt;/samples/data</code> + <code>modules/&amp;lt;name&amp;gt;/samples/data</code>).
 Passed subdirectories are used in LIFO order.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>subdir</code> - samples data sub directory</dd>
</dl>
</li>
</ul>
<a name="setErrorVerbosity-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setErrorVerbosity</h4>
<pre>public static&nbsp;void&nbsp;setErrorVerbosity(boolean&nbsp;verbose)</pre>
</li>
</ul>
<a name="add-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre>public static&nbsp;void&nbsp;add(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                       int&nbsp;dtype)</pre>
</li>
</ul>
<a name="add-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre>public static&nbsp;void&nbsp;add(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
</li>
</ul>
<a name="add-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>add</h4>
<pre>public static&nbsp;void&nbsp;add(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
</li>
</ul>
<a name="subtract-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subtract</h4>
<pre>public static&nbsp;void&nbsp;subtract(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask,
                            int&nbsp;dtype)</pre>
</li>
</ul>
<a name="subtract-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subtract</h4>
<pre>public static&nbsp;void&nbsp;subtract(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
</li>
</ul>
<a name="subtract-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subtract</h4>
<pre>public static&nbsp;void&nbsp;subtract(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
</li>
</ul>
<a name="multiply-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                            double&nbsp;scale,
                            int&nbsp;dtype)</pre>
</li>
</ul>
<a name="multiply-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                            double&nbsp;scale)</pre>
</li>
</ul>
<a name="multiply-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>multiply</h4>
<pre>public static&nbsp;void&nbsp;multiply(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                            <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
                            <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
</li>
</ul>
<a name="divide-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-double-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>divide</h4>
<pre>public static&nbsp;void&nbsp;divide(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          double&nbsp;scale,
                          int&nbsp;dtype)</pre>
</li>
</ul>
<a name="divide-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>divide</h4>
<pre>public static&nbsp;void&nbsp;divide(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                          double&nbsp;scale)</pre>
</li>
</ul>
<a name="divide-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>divide</h4>
<pre>public static&nbsp;void&nbsp;divide(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                          <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
                          <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
</li>
</ul>
<a name="absdiff-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>absdiff</h4>
<pre>public static&nbsp;void&nbsp;absdiff(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
</li>
</ul>
<a name="compare-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>compare</h4>
<pre>public static&nbsp;void&nbsp;compare(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                           <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
                           <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst,
                           int&nbsp;cmpop)</pre>
</li>
</ul>
<a name="min-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>min</h4>
<pre>public static&nbsp;void&nbsp;min(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
</li>
</ul>
<a name="max-org.opencv.core.Mat-org.opencv.core.Scalar-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>max</h4>
<pre>public static&nbsp;void&nbsp;max(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src1,
                       <a href="../../../org/opencv/core/Scalar.html" title="class in org.opencv.core">Scalar</a>&nbsp;src2,
                       <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;dst)</pre>
</li>
</ul>
<a name="minMaxLoc-org.opencv.core.Mat-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>minMaxLoc</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Core.MinMaxLocResult.html" title="class in org.opencv.core">Core.MinMaxLocResult</a>&nbsp;minMaxLoc(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src,
                                             <a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;mask)</pre>
</li>
</ul>
<a name="minMaxLoc-org.opencv.core.Mat-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>minMaxLoc</h4>
<pre>public static&nbsp;<a href="../../../org/opencv/core/Core.MinMaxLocResult.html" title="class in org.opencv.core">Core.MinMaxLocResult</a>&nbsp;minMaxLoc(<a href="../../../org/opencv/core/Mat.html" title="class in org.opencv.core">Mat</a>&nbsp;src)</pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Core.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../org/opencv/core/Algorithm.html" title="class in org.opencv.core"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../org/opencv/core/Core.MinMaxLocResult.html" title="class in org.opencv.core"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?org/opencv/core/Core.html" target="_top">Frames</a></li>
<li><a href="Core.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2025. All rights reserved.</small></p>
</body>
</html>
