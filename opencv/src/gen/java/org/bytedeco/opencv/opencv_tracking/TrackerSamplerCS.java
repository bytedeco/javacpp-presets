// Targeted by JavaCPP version 1.5.4-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.opencv.opencv_tracking;

import org.bytedeco.javacpp.annotation.Index;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;
import org.bytedeco.opencv.opencv_core.*;
import static org.bytedeco.opencv.global.opencv_core.*;
import org.bytedeco.opencv.opencv_imgproc.*;
import static org.bytedeco.opencv.global.opencv_imgproc.*;
import org.bytedeco.opencv.opencv_plot.*;
import static org.bytedeco.opencv.global.opencv_plot.*;
import static org.bytedeco.opencv.global.opencv_imgcodecs.*;
import org.bytedeco.opencv.opencv_videoio.*;
import static org.bytedeco.opencv.global.opencv_videoio.*;
import org.bytedeco.opencv.opencv_highgui.*;
import static org.bytedeco.opencv.global.opencv_highgui.*;
import org.bytedeco.opencv.opencv_flann.*;
import static org.bytedeco.opencv.global.opencv_flann.*;
import org.bytedeco.opencv.opencv_features2d.*;
import static org.bytedeco.opencv.global.opencv_features2d.*;
import org.bytedeco.opencv.opencv_calib3d.*;
import static org.bytedeco.opencv.global.opencv_calib3d.*;
import org.bytedeco.opencv.opencv_video.*;
import static org.bytedeco.opencv.global.opencv_video.*;
import org.bytedeco.opencv.opencv_dnn.*;
import static org.bytedeco.opencv.global.opencv_dnn.*;

import static org.bytedeco.opencv.global.opencv_tracking.*;


/** \brief TrackerSampler based on CS (current state), used by algorithm TrackerBoosting
 */
@Namespace("cv") @NoOffset @Properties(inherit = org.bytedeco.opencv.presets.opencv_tracking.class)
public class TrackerSamplerCS extends TrackerSamplerAlgorithm {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TrackerSamplerCS(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TrackerSamplerCS(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public TrackerSamplerCS position(long position) {
        return (TrackerSamplerCS)super.position(position);
    }
    @Override public TrackerSamplerCS getPointer(long i) {
        return new TrackerSamplerCS(this).position(position + i);
    }

  /** enum cv::TrackerSamplerCS:: */
  public static final int
    /** mode for positive samples */
    MODE_POSITIVE = 1,
    /** mode for negative samples */
    MODE_NEGATIVE = 2,
    /** mode for classify samples */
    MODE_CLASSIFY = 3;

  @NoOffset public static class Params extends Pointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public Params(Pointer p) { super(p); }
      /** Native array allocator. Access with {@link Pointer#position(long)}. */
      public Params(long size) { super((Pointer)null); allocateArray(size); }
      private native void allocateArray(long size);
      @Override public Params position(long position) {
          return (Params)super.position(position);
      }
      @Override public Params getPointer(long i) {
          return new Params(this).position(position + i);
      }
  
    public Params() { super((Pointer)null); allocate(); }
    private native void allocate();
    /**overlapping for the search windows */
    public native float overlap(); public native Params overlap(float setter);
    /**search region parameter */
    public native float searchFactor(); public native Params searchFactor(float setter);
  }
  /** \brief Constructor
    @param parameters TrackerSamplerCS parameters TrackerSamplerCS::Params
     */
  public TrackerSamplerCS( @Const @ByRef(nullValue = "cv::TrackerSamplerCS::Params()") Params parameters ) { super((Pointer)null); allocate(parameters); }
  private native void allocate( @Const @ByRef(nullValue = "cv::TrackerSamplerCS::Params()") Params parameters );
  public TrackerSamplerCS( ) { super((Pointer)null); allocate(); }
  private native void allocate( );

  /** \brief Set the sampling mode of TrackerSamplerCS
    @param samplingMode The sampling mode
    <p>
    The modes are:
    <p>
    -   "MODE_POSITIVE = 1" -- for the positive sampling
    -   "MODE_NEGATIVE = 2" -- for the negative sampling
    -   "MODE_CLASSIFY = 3" -- for the sampling in classification step
     */
  public native void setMode( int samplingMode );

  public native @Cast("bool") boolean samplingImpl( @Const @ByRef Mat image, @ByVal Rect boundingBox, @ByRef MatVector sample );
  public native @ByVal Rect getROI();

}
