// Targeted by JavaCPP version 1.5.7: DO NOT EDIT THIS FILE

package org.bytedeco.opencv.global;

import org.bytedeco.opencv.opencv_cudaimgproc.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;
import org.bytedeco.opencv.opencv_core.*;
import static org.bytedeco.opencv.global.opencv_core.*;
import org.bytedeco.opencv.opencv_imgproc.*;
import static org.bytedeco.opencv.global.opencv_imgproc.*;
import org.bytedeco.opencv.opencv_cudaarithm.*;
import static org.bytedeco.opencv.global.opencv_cudaarithm.*;
import org.bytedeco.opencv.opencv_cudafilters.*;
import static org.bytedeco.opencv.global.opencv_cudafilters.*;

public class opencv_cudaimgproc extends org.bytedeco.opencv.presets.opencv_cudaimgproc {
    static { Loader.load(); }

// Parsed from <opencv2/cudaimgproc.hpp>

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                           License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of the copyright holders may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/

// #ifndef OPENCV_CUDAIMGPROC_HPP
// #define OPENCV_CUDAIMGPROC_HPP

// #ifndef __cplusplus
// #endif

// #include "opencv2/core/cuda.hpp"
// #include "opencv2/imgproc.hpp"

/**
  \addtogroup cuda
  \{
    \defgroup cudaimgproc Image Processing
    \{
      \defgroup cudaimgproc_color Color space processing
      \defgroup cudaimgproc_hist Histogram Calculation
      \defgroup cudaimgproc_hough Hough Transform
      \defgroup cudaimgproc_feature Feature Detection
    \}
  \}
*/

/** \addtogroup cudaimgproc
 *  \{
<p>
/////////////////////////// Color Processing ///////////////////////////
 <p>
 *  \addtogroup cudaimgproc_color
 *  \{
<p>
/** \brief Converts an image from one color space to another.
<p>
@param src Source image with CV_8U , CV_16U , or CV_32F depth and 1, 3, or 4 channels.
@param dst Destination image.
@param code Color space conversion code. For details, see cvtColor .
@param dcn Number of channels in the destination image. If the parameter is 0, the number of the
channels is derived automatically from src and the code .
@param stream Stream for the asynchronous version.
<p>
3-channel color spaces (like HSV, XYZ, and so on) can be stored in a 4-channel image for better
performance.
<p>
@see cvtColor
 */
@Namespace("cv::cuda") public static native void cvtColor(@ByVal Mat src, @ByVal Mat dst, int code, int dcn/*=0*/, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void cvtColor(@ByVal Mat src, @ByVal Mat dst, int code);
@Namespace("cv::cuda") public static native void cvtColor(@ByVal UMat src, @ByVal UMat dst, int code, int dcn/*=0*/, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void cvtColor(@ByVal UMat src, @ByVal UMat dst, int code);
@Namespace("cv::cuda") public static native void cvtColor(@ByVal GpuMat src, @ByVal GpuMat dst, int code, int dcn/*=0*/, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void cvtColor(@ByVal GpuMat src, @ByVal GpuMat dst, int code);

/** enum cv::cuda::DemosaicTypes */
public static final int
    /** Bayer Demosaicing (Malvar, He, and Cutler) */
    COLOR_BayerBG2BGR_MHT = 256,
    COLOR_BayerGB2BGR_MHT = 257,
    COLOR_BayerRG2BGR_MHT = 258,
    COLOR_BayerGR2BGR_MHT = 259,

    COLOR_BayerBG2RGB_MHT = COLOR_BayerRG2BGR_MHT,
    COLOR_BayerGB2RGB_MHT = COLOR_BayerGR2BGR_MHT,
    COLOR_BayerRG2RGB_MHT = COLOR_BayerBG2BGR_MHT,
    COLOR_BayerGR2RGB_MHT = COLOR_BayerGB2BGR_MHT,

    COLOR_BayerBG2GRAY_MHT = 260,
    COLOR_BayerGB2GRAY_MHT = 261,
    COLOR_BayerRG2GRAY_MHT = 262,
    COLOR_BayerGR2GRAY_MHT = 263;

/** \brief Converts an image from Bayer pattern to RGB or grayscale.
<p>
@param src Source image (8-bit or 16-bit single channel).
@param dst Destination image.
@param code Color space conversion code (see the description below).
@param dcn Number of channels in the destination image. If the parameter is 0, the number of the
channels is derived automatically from src and the code .
@param stream Stream for the asynchronous version.
<p>
The function can do the following transformations:
<p>
-   Demosaicing using bilinear interpolation
    <p>
    > -   COLOR_BayerBG2GRAY , COLOR_BayerGB2GRAY , COLOR_BayerRG2GRAY , COLOR_BayerGR2GRAY
    > -   COLOR_BayerBG2BGR , COLOR_BayerGB2BGR , COLOR_BayerRG2BGR , COLOR_BayerGR2BGR
<p>
-   Demosaicing using Malvar-He-Cutler algorithm (\cite MHT2011)
    <p>
    > -   COLOR_BayerBG2GRAY_MHT , COLOR_BayerGB2GRAY_MHT , COLOR_BayerRG2GRAY_MHT ,
    >     COLOR_BayerGR2GRAY_MHT
    > -   COLOR_BayerBG2BGR_MHT , COLOR_BayerGB2BGR_MHT , COLOR_BayerRG2BGR_MHT ,
    >     COLOR_BayerGR2BGR_MHT
<p>
@see cvtColor
 */
@Namespace("cv::cuda") public static native void demosaicing(@ByVal Mat src, @ByVal Mat dst, int code, int dcn/*=-1*/, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void demosaicing(@ByVal Mat src, @ByVal Mat dst, int code);
@Namespace("cv::cuda") public static native void demosaicing(@ByVal UMat src, @ByVal UMat dst, int code, int dcn/*=-1*/, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void demosaicing(@ByVal UMat src, @ByVal UMat dst, int code);
@Namespace("cv::cuda") public static native void demosaicing(@ByVal GpuMat src, @ByVal GpuMat dst, int code, int dcn/*=-1*/, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void demosaicing(@ByVal GpuMat src, @ByVal GpuMat dst, int code);

/** \brief Exchanges the color channels of an image in-place.
<p>
@param image Source image. Supports only CV_8UC4 type.
@param dstOrder Integer array describing how channel values are permutated. The n-th entry of the
array contains the number of the channel that is stored in the n-th channel of the output image.
E.g. Given an RGBA image, aDstOrder = [3,2,1,0] converts this to ABGR channel order.
@param stream Stream for the asynchronous version.
<p>
The methods support arbitrary permutations of the original channels, including replication.
 */
@Namespace("cv::cuda") public static native void swapChannels(@ByVal Mat image, @Const IntPointer dstOrder, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void swapChannels(@ByVal Mat image, @Const IntPointer dstOrder);
@Namespace("cv::cuda") public static native void swapChannels(@ByVal Mat image, @Const IntBuffer dstOrder, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void swapChannels(@ByVal Mat image, @Const IntBuffer dstOrder);
@Namespace("cv::cuda") public static native void swapChannels(@ByVal Mat image, @Const int[] dstOrder, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void swapChannels(@ByVal Mat image, @Const int[] dstOrder);
@Namespace("cv::cuda") public static native void swapChannels(@ByVal UMat image, @Const IntPointer dstOrder, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void swapChannels(@ByVal UMat image, @Const IntPointer dstOrder);
@Namespace("cv::cuda") public static native void swapChannels(@ByVal UMat image, @Const IntBuffer dstOrder, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void swapChannels(@ByVal UMat image, @Const IntBuffer dstOrder);
@Namespace("cv::cuda") public static native void swapChannels(@ByVal UMat image, @Const int[] dstOrder, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void swapChannels(@ByVal UMat image, @Const int[] dstOrder);
@Namespace("cv::cuda") public static native void swapChannels(@ByVal GpuMat image, @Const IntPointer dstOrder, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void swapChannels(@ByVal GpuMat image, @Const IntPointer dstOrder);
@Namespace("cv::cuda") public static native void swapChannels(@ByVal GpuMat image, @Const IntBuffer dstOrder, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void swapChannels(@ByVal GpuMat image, @Const IntBuffer dstOrder);
@Namespace("cv::cuda") public static native void swapChannels(@ByVal GpuMat image, @Const int[] dstOrder, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void swapChannels(@ByVal GpuMat image, @Const int[] dstOrder);

/** \brief Routines for correcting image color gamma.
<p>
@param src Source image (3- or 4-channel 8 bit).
@param dst Destination image.
@param forward true for forward gamma correction or false for inverse gamma correction.
@param stream Stream for the asynchronous version.
 */
@Namespace("cv::cuda") public static native void gammaCorrection(@ByVal Mat src, @ByVal Mat dst, @Cast("bool") boolean forward/*=true*/, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void gammaCorrection(@ByVal Mat src, @ByVal Mat dst);
@Namespace("cv::cuda") public static native void gammaCorrection(@ByVal UMat src, @ByVal UMat dst, @Cast("bool") boolean forward/*=true*/, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void gammaCorrection(@ByVal UMat src, @ByVal UMat dst);
@Namespace("cv::cuda") public static native void gammaCorrection(@ByVal GpuMat src, @ByVal GpuMat dst, @Cast("bool") boolean forward/*=true*/, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void gammaCorrection(@ByVal GpuMat src, @ByVal GpuMat dst);

/** enum cv::cuda::AlphaCompTypes */
public static final int ALPHA_OVER = 0, ALPHA_IN = 1, ALPHA_OUT = 2, ALPHA_ATOP = 3, ALPHA_XOR = 4, ALPHA_PLUS = 5, ALPHA_OVER_PREMUL = 6, ALPHA_IN_PREMUL = 7, ALPHA_OUT_PREMUL = 8,
       ALPHA_ATOP_PREMUL = 9, ALPHA_XOR_PREMUL = 10, ALPHA_PLUS_PREMUL = 11, ALPHA_PREMUL = 12;

/** \brief Composites two images using alpha opacity values contained in each image.
<p>
@param img1 First image. Supports CV_8UC4 , CV_16UC4 , CV_32SC4 and CV_32FC4 types.
@param img2 Second image. Must have the same size and the same type as img1 .
@param dst Destination image.
@param alpha_op Flag specifying the alpha-blending operation:
-   **ALPHA_OVER**
-   **ALPHA_IN**
-   **ALPHA_OUT**
-   **ALPHA_ATOP**
-   **ALPHA_XOR**
-   **ALPHA_PLUS**
-   **ALPHA_OVER_PREMUL**
-   **ALPHA_IN_PREMUL**
-   **ALPHA_OUT_PREMUL**
-   **ALPHA_ATOP_PREMUL**
-   **ALPHA_XOR_PREMUL**
-   **ALPHA_PLUS_PREMUL**
-   **ALPHA_PREMUL**
@param stream Stream for the asynchronous version.
<p>
\note
   -   An example demonstrating the use of alphaComp can be found at
        opencv_source_code/samples/gpu/alpha_comp.cpp
 */
@Namespace("cv::cuda") public static native void alphaComp(@ByVal Mat img1, @ByVal Mat img2, @ByVal Mat dst, int alpha_op, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void alphaComp(@ByVal Mat img1, @ByVal Mat img2, @ByVal Mat dst, int alpha_op);
@Namespace("cv::cuda") public static native void alphaComp(@ByVal UMat img1, @ByVal UMat img2, @ByVal UMat dst, int alpha_op, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void alphaComp(@ByVal UMat img1, @ByVal UMat img2, @ByVal UMat dst, int alpha_op);
@Namespace("cv::cuda") public static native void alphaComp(@ByVal GpuMat img1, @ByVal GpuMat img2, @ByVal GpuMat dst, int alpha_op, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void alphaComp(@ByVal GpuMat img1, @ByVal GpuMat img2, @ByVal GpuMat dst, int alpha_op);

/** \} cudaimgproc_color
<p>
////////////////////////////// Histogram ///////////////////////////////
 <p>
 *  \addtogroup cudaimgproc_hist
 *  \{
<p>
/** \brief Calculates histogram for one channel 8-bit image.
<p>
@param src Source image with CV_8UC1 type.
@param hist Destination histogram with one row, 256 columns, and the CV_32SC1 type.
@param stream Stream for the asynchronous version.
 */
@Namespace("cv::cuda") public static native void calcHist(@ByVal Mat src, @ByVal Mat hist, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void calcHist(@ByVal Mat src, @ByVal Mat hist);
@Namespace("cv::cuda") public static native void calcHist(@ByVal UMat src, @ByVal UMat hist, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void calcHist(@ByVal UMat src, @ByVal UMat hist);
@Namespace("cv::cuda") public static native void calcHist(@ByVal GpuMat src, @ByVal GpuMat hist, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void calcHist(@ByVal GpuMat src, @ByVal GpuMat hist);

/** \brief Calculates histogram for one channel 8-bit image confined in given mask.
<p>
@param src Source image with CV_8UC1 type.
@param hist Destination histogram with one row, 256 columns, and the CV_32SC1 type.
@param mask A mask image same size as src and of type CV_8UC1.
@param stream Stream for the asynchronous version.
 */
@Namespace("cv::cuda") public static native void calcHist(@ByVal Mat src, @ByVal Mat mask, @ByVal Mat hist, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void calcHist(@ByVal Mat src, @ByVal Mat mask, @ByVal Mat hist);
@Namespace("cv::cuda") public static native void calcHist(@ByVal UMat src, @ByVal UMat mask, @ByVal UMat hist, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void calcHist(@ByVal UMat src, @ByVal UMat mask, @ByVal UMat hist);
@Namespace("cv::cuda") public static native void calcHist(@ByVal GpuMat src, @ByVal GpuMat mask, @ByVal GpuMat hist, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void calcHist(@ByVal GpuMat src, @ByVal GpuMat mask, @ByVal GpuMat hist);

/** \brief Equalizes the histogram of a grayscale image.
<p>
@param src Source image with CV_8UC1 type.
@param dst Destination image.
@param stream Stream for the asynchronous version.
<p>
@see equalizeHist
 */
@Namespace("cv::cuda") public static native void equalizeHist(@ByVal Mat src, @ByVal Mat dst, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void equalizeHist(@ByVal Mat src, @ByVal Mat dst);
@Namespace("cv::cuda") public static native void equalizeHist(@ByVal UMat src, @ByVal UMat dst, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void equalizeHist(@ByVal UMat src, @ByVal UMat dst);
@Namespace("cv::cuda") public static native void equalizeHist(@ByVal GpuMat src, @ByVal GpuMat dst, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void equalizeHist(@ByVal GpuMat src, @ByVal GpuMat dst);
// Targeting ../opencv_cudaimgproc/CudaCLAHE.java



/** \brief Creates implementation for cuda::CLAHE .
<p>
@param clipLimit Threshold for contrast limiting.
@param tileGridSize Size of grid for histogram equalization. Input image will be divided into
equally sized rectangular tiles. tileGridSize defines the number of tiles in row and column.
 */
@Namespace("cv::cuda") public static native @Ptr CudaCLAHE createCLAHE(double clipLimit/*=40.0*/, @ByVal(nullValue = "cv::Size(8, 8)") Size tileGridSize);
@Namespace("cv::cuda") public static native @Ptr CudaCLAHE createCLAHE();

/** \brief Computes levels with even distribution.
<p>
@param levels Destination array. levels has 1 row, nLevels columns, and the CV_32SC1 type.
@param nLevels Number of computed levels. nLevels must be at least 2.
@param lowerLevel Lower boundary value of the lowest level.
@param upperLevel Upper boundary value of the greatest level.
@param stream Stream for the asynchronous version.
 */
@Namespace("cv::cuda") public static native void evenLevels(@ByVal Mat levels, int nLevels, int lowerLevel, int upperLevel, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void evenLevels(@ByVal Mat levels, int nLevels, int lowerLevel, int upperLevel);
@Namespace("cv::cuda") public static native void evenLevels(@ByVal UMat levels, int nLevels, int lowerLevel, int upperLevel, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void evenLevels(@ByVal UMat levels, int nLevels, int lowerLevel, int upperLevel);
@Namespace("cv::cuda") public static native void evenLevels(@ByVal GpuMat levels, int nLevels, int lowerLevel, int upperLevel, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void evenLevels(@ByVal GpuMat levels, int nLevels, int lowerLevel, int upperLevel);

/** \brief Calculates a histogram with evenly distributed bins.
<p>
@param src Source image. CV_8U, CV_16U, or CV_16S depth and 1 or 4 channels are supported. For
a four-channel image, all channels are processed separately.
@param hist Destination histogram with one row, histSize columns, and the CV_32S type.
@param histSize Size of the histogram.
@param lowerLevel Lower boundary of lowest-level bin.
@param upperLevel Upper boundary of highest-level bin.
@param stream Stream for the asynchronous version.
 */
@Namespace("cv::cuda") public static native void histEven(@ByVal Mat src, @ByVal Mat hist, int histSize, int lowerLevel, int upperLevel, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void histEven(@ByVal Mat src, @ByVal Mat hist, int histSize, int lowerLevel, int upperLevel);
@Namespace("cv::cuda") public static native void histEven(@ByVal UMat src, @ByVal UMat hist, int histSize, int lowerLevel, int upperLevel, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void histEven(@ByVal UMat src, @ByVal UMat hist, int histSize, int lowerLevel, int upperLevel);
@Namespace("cv::cuda") public static native void histEven(@ByVal GpuMat src, @ByVal GpuMat hist, int histSize, int lowerLevel, int upperLevel, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void histEven(@ByVal GpuMat src, @ByVal GpuMat hist, int histSize, int lowerLevel, int upperLevel);
/** \overload */
@Namespace("cv::cuda") public static native void histEven(@ByVal Mat src, GpuMat hist, IntPointer histSize, IntPointer lowerLevel, IntPointer upperLevel, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void histEven(@ByVal Mat src, GpuMat hist, IntPointer histSize, IntPointer lowerLevel, IntPointer upperLevel);
@Namespace("cv::cuda") public static native void histEven(@ByVal Mat src, GpuMat hist, IntBuffer histSize, IntBuffer lowerLevel, IntBuffer upperLevel, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void histEven(@ByVal Mat src, GpuMat hist, IntBuffer histSize, IntBuffer lowerLevel, IntBuffer upperLevel);
@Namespace("cv::cuda") public static native void histEven(@ByVal Mat src, GpuMat hist, int[] histSize, int[] lowerLevel, int[] upperLevel, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void histEven(@ByVal Mat src, GpuMat hist, int[] histSize, int[] lowerLevel, int[] upperLevel);
@Namespace("cv::cuda") public static native void histEven(@ByVal UMat src, GpuMat hist, IntPointer histSize, IntPointer lowerLevel, IntPointer upperLevel, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void histEven(@ByVal UMat src, GpuMat hist, IntPointer histSize, IntPointer lowerLevel, IntPointer upperLevel);
@Namespace("cv::cuda") public static native void histEven(@ByVal UMat src, GpuMat hist, IntBuffer histSize, IntBuffer lowerLevel, IntBuffer upperLevel, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void histEven(@ByVal UMat src, GpuMat hist, IntBuffer histSize, IntBuffer lowerLevel, IntBuffer upperLevel);
@Namespace("cv::cuda") public static native void histEven(@ByVal UMat src, GpuMat hist, int[] histSize, int[] lowerLevel, int[] upperLevel, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void histEven(@ByVal UMat src, GpuMat hist, int[] histSize, int[] lowerLevel, int[] upperLevel);
@Namespace("cv::cuda") public static native void histEven(@ByVal GpuMat src, GpuMat hist, IntPointer histSize, IntPointer lowerLevel, IntPointer upperLevel, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void histEven(@ByVal GpuMat src, GpuMat hist, IntPointer histSize, IntPointer lowerLevel, IntPointer upperLevel);
@Namespace("cv::cuda") public static native void histEven(@ByVal GpuMat src, GpuMat hist, IntBuffer histSize, IntBuffer lowerLevel, IntBuffer upperLevel, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void histEven(@ByVal GpuMat src, GpuMat hist, IntBuffer histSize, IntBuffer lowerLevel, IntBuffer upperLevel);
@Namespace("cv::cuda") public static native void histEven(@ByVal GpuMat src, GpuMat hist, int[] histSize, int[] lowerLevel, int[] upperLevel, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void histEven(@ByVal GpuMat src, GpuMat hist, int[] histSize, int[] lowerLevel, int[] upperLevel);

/** \brief Calculates a histogram with bins determined by the levels array.
<p>
@param src Source image. CV_8U , CV_16U , or CV_16S depth and 1 or 4 channels are supported.
For a four-channel image, all channels are processed separately.
@param hist Destination histogram with one row, (levels.cols-1) columns, and the CV_32SC1 type.
@param levels Number of levels in the histogram.
@param stream Stream for the asynchronous version.
 */
@Namespace("cv::cuda") public static native void histRange(@ByVal Mat src, @ByVal Mat hist, @ByVal Mat levels, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void histRange(@ByVal Mat src, @ByVal Mat hist, @ByVal Mat levels);
@Namespace("cv::cuda") public static native void histRange(@ByVal UMat src, @ByVal UMat hist, @ByVal UMat levels, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void histRange(@ByVal UMat src, @ByVal UMat hist, @ByVal UMat levels);
@Namespace("cv::cuda") public static native void histRange(@ByVal GpuMat src, @ByVal GpuMat hist, @ByVal GpuMat levels, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void histRange(@ByVal GpuMat src, @ByVal GpuMat hist, @ByVal GpuMat levels);
/** \overload */
@Namespace("cv::cuda") public static native void histRange(@ByVal Mat src, GpuMat hist, @Const GpuMat levels, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void histRange(@ByVal Mat src, GpuMat hist, @Const GpuMat levels);
@Namespace("cv::cuda") public static native void histRange(@ByVal UMat src, GpuMat hist, @Const GpuMat levels, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void histRange(@ByVal UMat src, GpuMat hist, @Const GpuMat levels);
// Targeting ../opencv_cudaimgproc/CannyEdgeDetector.java



/** \brief Creates implementation for cuda::CannyEdgeDetector .
<p>
@param low_thresh First threshold for the hysteresis procedure.
@param high_thresh Second threshold for the hysteresis procedure.
@param apperture_size Aperture size for the Sobel operator.
@param L2gradient Flag indicating whether a more accurate {@code L_2} norm
{@code =\sqrt{(dI/dx)^2 + (dI/dy)^2}} should be used to compute the image gradient magnitude (
L2gradient=true ), or a faster default {@code L_1} norm {@code =|dI/dx|+|dI/dy|} is enough ( L2gradient=false
).
 */
@Namespace("cv::cuda") public static native @Ptr CannyEdgeDetector createCannyEdgeDetector(double low_thresh, double high_thresh, int apperture_size/*=3*/, @Cast("bool") boolean L2gradient/*=false*/);
@Namespace("cv::cuda") public static native @Ptr CannyEdgeDetector createCannyEdgeDetector(double low_thresh, double high_thresh);
// Targeting ../opencv_cudaimgproc/HoughLinesDetector.java



/** \brief Creates implementation for cuda::HoughLinesDetector .
<p>
@param rho Distance resolution of the accumulator in pixels.
@param theta Angle resolution of the accumulator in radians.
@param threshold Accumulator threshold parameter. Only those lines are returned that get enough
votes ( {@code >\texttt{threshold}} ).
@param doSort Performs lines sort by votes.
@param maxLines Maximum number of output lines.
 */
@Namespace("cv::cuda") public static native @Ptr HoughLinesDetector createHoughLinesDetector(float rho, float theta, int threshold, @Cast("bool") boolean doSort/*=false*/, int maxLines/*=4096*/);
@Namespace("cv::cuda") public static native @Ptr HoughLinesDetector createHoughLinesDetector(float rho, float theta, int threshold);
// Targeting ../opencv_cudaimgproc/HoughSegmentDetector.java



/** \brief Creates implementation for cuda::HoughSegmentDetector .
<p>
@param rho Distance resolution of the accumulator in pixels.
@param theta Angle resolution of the accumulator in radians.
@param minLineLength Minimum line length. Line segments shorter than that are rejected.
@param maxLineGap Maximum allowed gap between points on the same line to link them.
@param maxLines Maximum number of output lines.
 */
@Namespace("cv::cuda") public static native @Ptr HoughSegmentDetector createHoughSegmentDetector(float rho, float theta, int minLineLength, int maxLineGap, int maxLines/*=4096*/);
@Namespace("cv::cuda") public static native @Ptr HoughSegmentDetector createHoughSegmentDetector(float rho, float theta, int minLineLength, int maxLineGap);
// Targeting ../opencv_cudaimgproc/HoughCirclesDetector.java



/** \brief Creates implementation for cuda::HoughCirclesDetector .
<p>
@param dp Inverse ratio of the accumulator resolution to the image resolution. For example, if
dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has
half as big width and height.
@param minDist Minimum distance between the centers of the detected circles. If the parameter is
too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is
too large, some circles may be missed.
@param cannyThreshold The higher threshold of the two passed to Canny edge detector (the lower one
is twice smaller).
@param votesThreshold The accumulator threshold for the circle centers at the detection stage. The
smaller it is, the more false circles may be detected.
@param minRadius Minimum circle radius.
@param maxRadius Maximum circle radius.
@param maxCircles Maximum number of output circles.
 */
@Namespace("cv::cuda") public static native @Ptr HoughCirclesDetector createHoughCirclesDetector(float dp, float minDist, int cannyThreshold, int votesThreshold, int minRadius, int maxRadius, int maxCircles/*=4096*/);
@Namespace("cv::cuda") public static native @Ptr HoughCirclesDetector createHoughCirclesDetector(float dp, float minDist, int cannyThreshold, int votesThreshold, int minRadius, int maxRadius);

//////////////////////////////////////
// GeneralizedHough

/** \brief Creates implementation for generalized hough transform from \cite Ballard1981 .
 */
@Namespace("cv::cuda") public static native @Ptr GeneralizedHoughBallard createGeneralizedHoughBallard();

/** \brief Creates implementation for generalized hough transform from \cite Guil1999 .
 */
@Namespace("cv::cuda") public static native @Ptr GeneralizedHoughGuil createGeneralizedHoughGuil();
// Targeting ../opencv_cudaimgproc/CornernessCriteria.java



/** \brief Creates implementation for Harris cornerness criteria.
<p>
@param srcType Input source type. Only CV_8UC1 and CV_32FC1 are supported for now.
@param blockSize Neighborhood size.
@param ksize Aperture parameter for the Sobel operator.
@param k Harris detector free parameter.
@param borderType Pixel extrapolation method. Only BORDER_REFLECT101 and BORDER_REPLICATE are
supported for now.
<p>
@see cornerHarris
 */
@Namespace("cv::cuda") public static native @Ptr CornernessCriteria createHarrisCorner(int srcType, int blockSize, int ksize, double k, int borderType/*=cv::BORDER_REFLECT101*/);
@Namespace("cv::cuda") public static native @Ptr CornernessCriteria createHarrisCorner(int srcType, int blockSize, int ksize, double k);

/** \brief Creates implementation for the minimum eigen value of a 2x2 derivative covariation matrix (the
cornerness criteria).
<p>
@param srcType Input source type. Only CV_8UC1 and CV_32FC1 are supported for now.
@param blockSize Neighborhood size.
@param ksize Aperture parameter for the Sobel operator.
@param borderType Pixel extrapolation method. Only BORDER_REFLECT101 and BORDER_REPLICATE are
supported for now.
<p>
@see cornerMinEigenVal
 */
@Namespace("cv::cuda") public static native @Ptr CornernessCriteria createMinEigenValCorner(int srcType, int blockSize, int ksize, int borderType/*=cv::BORDER_REFLECT101*/);
@Namespace("cv::cuda") public static native @Ptr CornernessCriteria createMinEigenValCorner(int srcType, int blockSize, int ksize);
// Targeting ../opencv_cudaimgproc/CornersDetector.java



/** \brief Creates implementation for cuda::CornersDetector .
<p>
@param srcType Input source type. Only CV_8UC1 and CV_32FC1 are supported for now.
@param maxCorners Maximum number of corners to return. If there are more corners than are found,
the strongest of them is returned.
@param qualityLevel Parameter characterizing the minimal accepted quality of image corners. The
parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue
(see cornerMinEigenVal ) or the Harris function response (see cornerHarris ). The corners with the
quality measure less than the product are rejected. For example, if the best corner has the
quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure
less than 15 are rejected.
@param minDistance Minimum possible Euclidean distance between the returned corners.
@param blockSize Size of an average block for computing a derivative covariation matrix over each
pixel neighborhood. See cornerEigenValsAndVecs .
@param useHarrisDetector Parameter indicating whether to use a Harris detector (see cornerHarris)
or cornerMinEigenVal.
@param harrisK Free parameter of the Harris detector.
 */
@Namespace("cv::cuda") public static native @Ptr CornersDetector createGoodFeaturesToTrackDetector(int srcType, int maxCorners/*=1000*/, double qualityLevel/*=0.01*/, double minDistance/*=0.0*/,
                                                                  int blockSize/*=3*/, @Cast("bool") boolean useHarrisDetector/*=false*/, double harrisK/*=0.04*/);
@Namespace("cv::cuda") public static native @Ptr CornersDetector createGoodFeaturesToTrackDetector(int srcType);

/** \} cudaimgproc_feature
<p>
<p>
///////////////////////////// Mean Shift //////////////////////////////
<p>
/** \brief Performs mean-shift filtering for each point of the source image.
<p>
@param src Source image. Only CV_8UC4 images are supported for now.
@param dst Destination image containing the color of mapped points. It has the same size and type
as src .
@param sp Spatial window radius.
@param sr Color window radius.
@param criteria Termination criteria. See TermCriteria.
@param stream Stream for the asynchronous version.
<p>
It maps each point of the source image into another point. As a result, you have a new color and new
position of each point.
 */
@Namespace("cv::cuda") public static native void meanShiftFiltering(@ByVal Mat src, @ByVal Mat dst, int sp, int sr,
                                   @ByVal(nullValue = "cv::TermCriteria(cv::TermCriteria::MAX_ITER + cv::TermCriteria::EPS, 5, 1)") TermCriteria criteria,
                                   @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void meanShiftFiltering(@ByVal Mat src, @ByVal Mat dst, int sp, int sr);
@Namespace("cv::cuda") public static native void meanShiftFiltering(@ByVal UMat src, @ByVal UMat dst, int sp, int sr,
                                   @ByVal(nullValue = "cv::TermCriteria(cv::TermCriteria::MAX_ITER + cv::TermCriteria::EPS, 5, 1)") TermCriteria criteria,
                                   @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void meanShiftFiltering(@ByVal UMat src, @ByVal UMat dst, int sp, int sr);
@Namespace("cv::cuda") public static native void meanShiftFiltering(@ByVal GpuMat src, @ByVal GpuMat dst, int sp, int sr,
                                   @ByVal(nullValue = "cv::TermCriteria(cv::TermCriteria::MAX_ITER + cv::TermCriteria::EPS, 5, 1)") TermCriteria criteria,
                                   @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void meanShiftFiltering(@ByVal GpuMat src, @ByVal GpuMat dst, int sp, int sr);

/** \brief Performs a mean-shift procedure and stores information about processed points (their colors and
positions) in two images.
<p>
@param src Source image. Only CV_8UC4 images are supported for now.
@param dstr Destination image containing the color of mapped points. The size and type is the same
as src .
@param dstsp Destination image containing the position of mapped points. The size is the same as
src size. The type is CV_16SC2 .
@param sp Spatial window radius.
@param sr Color window radius.
@param criteria Termination criteria. See TermCriteria.
@param stream Stream for the asynchronous version.
<p>
@see cuda::meanShiftFiltering
 */
@Namespace("cv::cuda") public static native void meanShiftProc(@ByVal Mat src, @ByVal Mat dstr, @ByVal Mat dstsp, int sp, int sr,
                              @ByVal(nullValue = "cv::TermCriteria(cv::TermCriteria::MAX_ITER + cv::TermCriteria::EPS, 5, 1)") TermCriteria criteria,
                              @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void meanShiftProc(@ByVal Mat src, @ByVal Mat dstr, @ByVal Mat dstsp, int sp, int sr);
@Namespace("cv::cuda") public static native void meanShiftProc(@ByVal UMat src, @ByVal UMat dstr, @ByVal UMat dstsp, int sp, int sr,
                              @ByVal(nullValue = "cv::TermCriteria(cv::TermCriteria::MAX_ITER + cv::TermCriteria::EPS, 5, 1)") TermCriteria criteria,
                              @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void meanShiftProc(@ByVal UMat src, @ByVal UMat dstr, @ByVal UMat dstsp, int sp, int sr);
@Namespace("cv::cuda") public static native void meanShiftProc(@ByVal GpuMat src, @ByVal GpuMat dstr, @ByVal GpuMat dstsp, int sp, int sr,
                              @ByVal(nullValue = "cv::TermCriteria(cv::TermCriteria::MAX_ITER + cv::TermCriteria::EPS, 5, 1)") TermCriteria criteria,
                              @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void meanShiftProc(@ByVal GpuMat src, @ByVal GpuMat dstr, @ByVal GpuMat dstsp, int sp, int sr);

/** \brief Performs a mean-shift segmentation of the source image and eliminates small segments.
<p>
@param src Source image. Only CV_8UC4 images are supported for now.
@param dst Segmented image with the same size and type as src (host or gpu memory).
@param sp Spatial window radius.
@param sr Color window radius.
@param minsize Minimum segment size. Smaller segments are merged.
@param criteria Termination criteria. See TermCriteria.
@param stream Stream for the asynchronous version.
 */
@Namespace("cv::cuda") public static native void meanShiftSegmentation(@ByVal Mat src, @ByVal Mat dst, int sp, int sr, int minsize,
                                      @ByVal(nullValue = "cv::TermCriteria(cv::TermCriteria::MAX_ITER + cv::TermCriteria::EPS, 5, 1)") TermCriteria criteria,
                                      @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void meanShiftSegmentation(@ByVal Mat src, @ByVal Mat dst, int sp, int sr, int minsize);
@Namespace("cv::cuda") public static native void meanShiftSegmentation(@ByVal UMat src, @ByVal UMat dst, int sp, int sr, int minsize,
                                      @ByVal(nullValue = "cv::TermCriteria(cv::TermCriteria::MAX_ITER + cv::TermCriteria::EPS, 5, 1)") TermCriteria criteria,
                                      @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void meanShiftSegmentation(@ByVal UMat src, @ByVal UMat dst, int sp, int sr, int minsize);
@Namespace("cv::cuda") public static native void meanShiftSegmentation(@ByVal GpuMat src, @ByVal GpuMat dst, int sp, int sr, int minsize,
                                      @ByVal(nullValue = "cv::TermCriteria(cv::TermCriteria::MAX_ITER + cv::TermCriteria::EPS, 5, 1)") TermCriteria criteria,
                                      @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void meanShiftSegmentation(@ByVal GpuMat src, @ByVal GpuMat dst, int sp, int sr, int minsize);
// Targeting ../opencv_cudaimgproc/TemplateMatching.java



/** \brief Creates implementation for cuda::TemplateMatching .
<p>
@param srcType Input source type. CV_32F and CV_8U depth images (1..4 channels) are supported
for now.
@param method Specifies the way to compare the template with the image.
@param user_block_size You can use field user_block_size to set specific block size. If you
leave its default value Size(0,0) then automatic estimation of block size will be used (which is
optimized for speed). By varying user_block_size you can reduce memory requirements at the cost
of speed.
<p>
The following methods are supported for the CV_8U depth images for now:
<p>
-   CV_TM_SQDIFF
-   CV_TM_SQDIFF_NORMED
-   CV_TM_CCORR
-   CV_TM_CCORR_NORMED
-   CV_TM_CCOEFF
-   CV_TM_CCOEFF_NORMED
<p>
The following methods are supported for the CV_32F images for now:
<p>
-   CV_TM_SQDIFF
-   CV_TM_CCORR
<p>
@see matchTemplate
 */
@Namespace("cv::cuda") public static native @Ptr TemplateMatching createTemplateMatching(int srcType, int method, @ByVal(nullValue = "cv::Size()") Size user_block_size);
@Namespace("cv::cuda") public static native @Ptr TemplateMatching createTemplateMatching(int srcType, int method);

////////////////////////// Bilateral Filter ///////////////////////////

/** \brief Performs bilateral filtering of passed image
<p>
@param src Source image. Supports only (channels != 2 && depth() != CV_8S && depth() != CV_32S
&& depth() != CV_64F).
@param dst Destination imagwe.
@param kernel_size Kernel window size.
@param sigma_color Filter sigma in the color space.
@param sigma_spatial Filter sigma in the coordinate space.
@param borderMode Border type. See borderInterpolate for details. BORDER_REFLECT101 ,
BORDER_REPLICATE , BORDER_CONSTANT , BORDER_REFLECT and BORDER_WRAP are supported for now.
@param stream Stream for the asynchronous version.
<p>
@see bilateralFilter
 */
@Namespace("cv::cuda") public static native void bilateralFilter(@ByVal Mat src, @ByVal Mat dst, int kernel_size, float sigma_color, float sigma_spatial,
                                int borderMode/*=cv::BORDER_DEFAULT*/, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void bilateralFilter(@ByVal Mat src, @ByVal Mat dst, int kernel_size, float sigma_color, float sigma_spatial);
@Namespace("cv::cuda") public static native void bilateralFilter(@ByVal UMat src, @ByVal UMat dst, int kernel_size, float sigma_color, float sigma_spatial,
                                int borderMode/*=cv::BORDER_DEFAULT*/, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void bilateralFilter(@ByVal UMat src, @ByVal UMat dst, int kernel_size, float sigma_color, float sigma_spatial);
@Namespace("cv::cuda") public static native void bilateralFilter(@ByVal GpuMat src, @ByVal GpuMat dst, int kernel_size, float sigma_color, float sigma_spatial,
                                int borderMode/*=cv::BORDER_DEFAULT*/, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void bilateralFilter(@ByVal GpuMat src, @ByVal GpuMat dst, int kernel_size, float sigma_color, float sigma_spatial);

///////////////////////////// Blending ////////////////////////////////

/** \brief Performs linear blending of two images.
<p>
@param img1 First image. Supports only CV_8U and CV_32F depth.
@param img2 Second image. Must have the same size and the same type as img1 .
@param weights1 Weights for first image. Must have tha same size as img1 . Supports only CV_32F
type.
@param weights2 Weights for second image. Must have tha same size as img2 . Supports only CV_32F
type.
@param result Destination image.
@param stream Stream for the asynchronous version.
 */
@Namespace("cv::cuda") public static native void blendLinear(@ByVal Mat img1, @ByVal Mat img2, @ByVal Mat weights1, @ByVal Mat weights2,
                            @ByVal Mat result, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void blendLinear(@ByVal Mat img1, @ByVal Mat img2, @ByVal Mat weights1, @ByVal Mat weights2,
                            @ByVal Mat result);
@Namespace("cv::cuda") public static native void blendLinear(@ByVal UMat img1, @ByVal UMat img2, @ByVal UMat weights1, @ByVal UMat weights2,
                            @ByVal UMat result, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void blendLinear(@ByVal UMat img1, @ByVal UMat img2, @ByVal UMat weights1, @ByVal UMat weights2,
                            @ByVal UMat result);
@Namespace("cv::cuda") public static native void blendLinear(@ByVal GpuMat img1, @ByVal GpuMat img2, @ByVal GpuMat weights1, @ByVal GpuMat weights2,
                            @ByVal GpuMat result, @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void blendLinear(@ByVal GpuMat img1, @ByVal GpuMat img2, @ByVal GpuMat weights1, @ByVal GpuMat weights2,
                            @ByVal GpuMat result);

/** \} */

 // namespace cv { namespace cuda {

// #endif /* OPENCV_CUDAIMGPROC_HPP */


}
