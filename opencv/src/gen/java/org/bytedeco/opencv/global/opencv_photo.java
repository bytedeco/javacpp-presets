// Targeted by JavaCPP version 1.5.7: DO NOT EDIT THIS FILE

package org.bytedeco.opencv.global;

import org.bytedeco.opencv.opencv_photo.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;
import org.bytedeco.opencv.opencv_core.*;
import static org.bytedeco.opencv.global.opencv_core.*;
import org.bytedeco.opencv.opencv_imgproc.*;
import static org.bytedeco.opencv.global.opencv_imgproc.*;

public class opencv_photo extends org.bytedeco.opencv.presets.opencv_photo {
    static { Loader.load(); }

// Parsed from <opencv2/photo.hpp>

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                           License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2008-2012, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of the copyright holders may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/

// #ifndef OPENCV_PHOTO_HPP
// #define OPENCV_PHOTO_HPP

// #include "opencv2/core.hpp"
// #include "opencv2/imgproc.hpp"

/**
\defgroup photo Computational Photography
<p>
This module includes photo processing algorithms
\{
    \defgroup photo_inpaint Inpainting
    \defgroup photo_denoise Denoising
    \defgroup photo_hdr HDR imaging
<p>
This section describes high dynamic range imaging algorithms namely tonemapping, exposure alignment,
camera calibration with multiple exposures and exposure fusion.
    <p>
    \defgroup photo_decolor Contrast Preserving Decolorization
<p>
Useful links:
<p>
http://www.cse.cuhk.edu.hk/leojia/projects/color2gray/index.html
    <p>
    \defgroup photo_clone Seamless Cloning
<p>
Useful links:
<p>
https://www.learnopencv.com/seamless-cloning-using-opencv-python-cpp
    <p>
    \defgroup photo_render Non-Photorealistic Rendering
<p>
Useful links:
<p>
http://www.inf.ufrgs.br/~eslgastal/DomainTransform
<p>
https://www.learnopencv.com/non-photorealistic-rendering-using-opencv-python-c/
    <p>
    \defgroup photo_c C API
\}
  */

/** \addtogroup photo
 *  \{
 <p>
 *  \addtogroup photo_inpaint
 *  \{
 *  the inpainting algorithm */
/** enum cv:: */
public static final int
    /** Use Navier-Stokes based method */
    INPAINT_NS    = 0,
    /** Use the algorithm proposed by Alexandru Telea \cite Telea04 */
    INPAINT_TELEA = 1;

/** \brief Restores the selected region in an image using the region neighborhood.
<p>
@param src Input 8-bit, 16-bit unsigned or 32-bit float 1-channel or 8-bit 3-channel image.
@param inpaintMask Inpainting mask, 8-bit 1-channel image. Non-zero pixels indicate the area that
needs to be inpainted.
@param dst Output image with the same size and type as src .
@param inpaintRadius Radius of a circular neighborhood of each point inpainted that is considered
by the algorithm.
@param flags Inpainting method that could be cv::INPAINT_NS or cv::INPAINT_TELEA
<p>
The function reconstructs the selected image area from the pixel near the area boundary. The
function may be used to remove dust and scratches from a scanned photo, or to remove undesirable
objects from still images or video. See <http://en.wikipedia.org/wiki/Inpainting> for more details.
<p>
\note
   -   An example using the inpainting technique can be found at
        opencv_source_code/samples/cpp/inpaint.cpp
   -   (Python) An example using the inpainting technique can be found at
        opencv_source_code/samples/python/inpaint.py
 */
@Namespace("cv") public static native void inpaint( @ByVal Mat src, @ByVal Mat inpaintMask,
        @ByVal Mat dst, double inpaintRadius, int flags );
@Namespace("cv") public static native void inpaint( @ByVal UMat src, @ByVal UMat inpaintMask,
        @ByVal UMat dst, double inpaintRadius, int flags );
@Namespace("cv") public static native void inpaint( @ByVal GpuMat src, @ByVal GpuMat inpaintMask,
        @ByVal GpuMat dst, double inpaintRadius, int flags );

/** \} photo_inpaint
 <p>
 *  \addtogroup photo_denoise
 *  \{
<p>
/** \brief Perform image denoising using Non-local Means Denoising algorithm
<http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/> with several computational
optimizations. Noise expected to be a gaussian white noise
<p>
@param src Input 8-bit 1-channel, 2-channel, 3-channel or 4-channel image.
@param dst Output image with the same size and type as src .
@param templateWindowSize Size in pixels of the template patch that is used to compute weights.
Should be odd. Recommended value 7 pixels
@param searchWindowSize Size in pixels of the window that is used to compute weighted average for
given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
denoising time. Recommended value 21 pixels
@param h Parameter regulating filter strength. Big h value perfectly removes noise but also
removes image details, smaller h value preserves details but also preserves some noise
<p>
This function expected to be applied to grayscale images. For colored images look at
fastNlMeansDenoisingColored. Advanced usage of this functions can be manual denoising of colored
image in different colorspaces. Such approach is used in fastNlMeansDenoisingColored by converting
image to CIELAB colorspace and then separately denoise L and AB components with different h
parameter.
 */
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal Mat src, @ByVal Mat dst, float h/*=3*/,
        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal Mat src, @ByVal Mat dst);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal UMat src, @ByVal UMat dst, float h/*=3*/,
        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal UMat src, @ByVal UMat dst);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal GpuMat src, @ByVal GpuMat dst, float h/*=3*/,
        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal GpuMat src, @ByVal GpuMat dst);

/** \brief Perform image denoising using Non-local Means Denoising algorithm
<http://www.ipol.im/pub/algo/bcm_non_local_means_denoising/> with several computational
optimizations. Noise expected to be a gaussian white noise
<p>
@param src Input 8-bit or 16-bit (only with NORM_L1) 1-channel,
2-channel, 3-channel or 4-channel image.
@param dst Output image with the same size and type as src .
@param templateWindowSize Size in pixels of the template patch that is used to compute weights.
Should be odd. Recommended value 7 pixels
@param searchWindowSize Size in pixels of the window that is used to compute weighted average for
given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
denoising time. Recommended value 21 pixels
@param h Array of parameters regulating filter strength, either one
parameter applied to all channels or one per channel in dst. Big h value
perfectly removes noise but also removes image details, smaller h
value preserves details but also preserves some noise
@param normType Type of norm used for weight calculation. Can be either NORM_L2 or NORM_L1
<p>
This function expected to be applied to grayscale images. For colored images look at
fastNlMeansDenoisingColored. Advanced usage of this functions can be manual denoising of colored
image in different colorspaces. Such approach is used in fastNlMeansDenoisingColored by converting
image to CIELAB colorspace and then separately denoise L and AB components with different h
parameter.
 */
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal Mat src, @ByVal Mat dst,
                                        @StdVector FloatPointer h,
                                        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                        int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal Mat src, @ByVal Mat dst,
                                        @StdVector FloatPointer h);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal Mat src, @ByVal Mat dst,
                                        @StdVector FloatBuffer h,
                                        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                        int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal Mat src, @ByVal Mat dst,
                                        @StdVector FloatBuffer h);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal Mat src, @ByVal Mat dst,
                                        @StdVector float[] h,
                                        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                        int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal Mat src, @ByVal Mat dst,
                                        @StdVector float[] h);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal UMat src, @ByVal UMat dst,
                                        @StdVector FloatPointer h,
                                        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                        int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal UMat src, @ByVal UMat dst,
                                        @StdVector FloatPointer h);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal UMat src, @ByVal UMat dst,
                                        @StdVector FloatBuffer h,
                                        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                        int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal UMat src, @ByVal UMat dst,
                                        @StdVector FloatBuffer h);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal UMat src, @ByVal UMat dst,
                                        @StdVector float[] h,
                                        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                        int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal UMat src, @ByVal UMat dst,
                                        @StdVector float[] h);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal GpuMat src, @ByVal GpuMat dst,
                                        @StdVector FloatPointer h,
                                        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                        int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal GpuMat src, @ByVal GpuMat dst,
                                        @StdVector FloatPointer h);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal GpuMat src, @ByVal GpuMat dst,
                                        @StdVector FloatBuffer h,
                                        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                        int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal GpuMat src, @ByVal GpuMat dst,
                                        @StdVector FloatBuffer h);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal GpuMat src, @ByVal GpuMat dst,
                                        @StdVector float[] h,
                                        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                        int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoising( @ByVal GpuMat src, @ByVal GpuMat dst,
                                        @StdVector float[] h);

/** \brief Modification of fastNlMeansDenoising function for colored images
<p>
@param src Input 8-bit 3-channel image.
@param dst Output image with the same size and type as src .
@param templateWindowSize Size in pixels of the template patch that is used to compute weights.
Should be odd. Recommended value 7 pixels
@param searchWindowSize Size in pixels of the window that is used to compute weighted average for
given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
denoising time. Recommended value 21 pixels
@param h Parameter regulating filter strength for luminance component. Bigger h value perfectly
removes noise but also removes image details, smaller h value preserves details but also preserves
some noise
@param hColor The same as h but for color components. For most images value equals 10
will be enough to remove colored noise and do not distort colors
<p>
The function converts image to CIELAB colorspace and then separately denoise L and AB components
with given h parameters using fastNlMeansDenoising function.
 */
@Namespace("cv") public static native void fastNlMeansDenoisingColored( @ByVal Mat src, @ByVal Mat dst,
        float h/*=3*/, float hColor/*=3*/,
        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingColored( @ByVal Mat src, @ByVal Mat dst);
@Namespace("cv") public static native void fastNlMeansDenoisingColored( @ByVal UMat src, @ByVal UMat dst,
        float h/*=3*/, float hColor/*=3*/,
        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingColored( @ByVal UMat src, @ByVal UMat dst);
@Namespace("cv") public static native void fastNlMeansDenoisingColored( @ByVal GpuMat src, @ByVal GpuMat dst,
        float h/*=3*/, float hColor/*=3*/,
        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingColored( @ByVal GpuMat src, @ByVal GpuMat dst);

/** \brief Modification of fastNlMeansDenoising function for images sequence where consecutive images have been
captured in small period of time. For example video. This version of the function is for grayscale
images or for manual manipulation with colorspaces. For more details see
<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.131.6394>
<p>
@param srcImgs Input 8-bit 1-channel, 2-channel, 3-channel or
4-channel images sequence. All images should have the same type and
size.
@param imgToDenoiseIndex Target image to denoise index in srcImgs sequence
@param temporalWindowSize Number of surrounding images to use for target image denoising. Should
be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to
imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise
srcImgs[imgToDenoiseIndex] image.
@param dst Output image with the same size and type as srcImgs images.
@param templateWindowSize Size in pixels of the template patch that is used to compute weights.
Should be odd. Recommended value 7 pixels
@param searchWindowSize Size in pixels of the window that is used to compute weighted average for
given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
denoising time. Recommended value 21 pixels
@param h Parameter regulating filter strength. Bigger h value
perfectly removes noise but also removes image details, smaller h
value preserves details but also preserves some noise
 */
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal MatVector srcImgs, @ByVal Mat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal MatVector srcImgs, @ByVal Mat dst,
        int imgToDenoiseIndex, int temporalWindowSize);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal UMatVector srcImgs, @ByVal Mat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal UMatVector srcImgs, @ByVal Mat dst,
        int imgToDenoiseIndex, int temporalWindowSize);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal GpuMatVector srcImgs, @ByVal Mat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal GpuMatVector srcImgs, @ByVal Mat dst,
        int imgToDenoiseIndex, int temporalWindowSize);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal MatVector srcImgs, @ByVal UMat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal MatVector srcImgs, @ByVal UMat dst,
        int imgToDenoiseIndex, int temporalWindowSize);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal UMatVector srcImgs, @ByVal UMat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal UMatVector srcImgs, @ByVal UMat dst,
        int imgToDenoiseIndex, int temporalWindowSize);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal GpuMatVector srcImgs, @ByVal UMat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal GpuMatVector srcImgs, @ByVal UMat dst,
        int imgToDenoiseIndex, int temporalWindowSize);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal MatVector srcImgs, @ByVal GpuMat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal MatVector srcImgs, @ByVal GpuMat dst,
        int imgToDenoiseIndex, int temporalWindowSize);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal UMatVector srcImgs, @ByVal GpuMat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal UMatVector srcImgs, @ByVal GpuMat dst,
        int imgToDenoiseIndex, int temporalWindowSize);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal GpuMatVector srcImgs, @ByVal GpuMat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal GpuMatVector srcImgs, @ByVal GpuMat dst,
        int imgToDenoiseIndex, int temporalWindowSize);

/** \brief Modification of fastNlMeansDenoising function for images sequence where consecutive images have been
captured in small period of time. For example video. This version of the function is for grayscale
images or for manual manipulation with colorspaces. For more details see
<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.131.6394>
<p>
@param srcImgs Input 8-bit or 16-bit (only with NORM_L1) 1-channel,
2-channel, 3-channel or 4-channel images sequence. All images should
have the same type and size.
@param imgToDenoiseIndex Target image to denoise index in srcImgs sequence
@param temporalWindowSize Number of surrounding images to use for target image denoising. Should
be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to
imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise
srcImgs[imgToDenoiseIndex] image.
@param dst Output image with the same size and type as srcImgs images.
@param templateWindowSize Size in pixels of the template patch that is used to compute weights.
Should be odd. Recommended value 7 pixels
@param searchWindowSize Size in pixels of the window that is used to compute weighted average for
given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
denoising time. Recommended value 21 pixels
@param h Array of parameters regulating filter strength, either one
parameter applied to all channels or one per channel in dst. Big h value
perfectly removes noise but also removes image details, smaller h
value preserves details but also preserves some noise
@param normType Type of norm used for weight calculation. Can be either NORM_L2 or NORM_L1
 */
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal MatVector srcImgs, @ByVal Mat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector FloatPointer h,
                                             int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                             int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal MatVector srcImgs, @ByVal Mat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector FloatPointer h);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal UMatVector srcImgs, @ByVal Mat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector FloatBuffer h,
                                             int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                             int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal UMatVector srcImgs, @ByVal Mat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector FloatBuffer h);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal GpuMatVector srcImgs, @ByVal Mat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector float[] h,
                                             int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                             int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal GpuMatVector srcImgs, @ByVal Mat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector float[] h);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal MatVector srcImgs, @ByVal UMat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector FloatPointer h,
                                             int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                             int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal MatVector srcImgs, @ByVal UMat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector FloatPointer h);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal UMatVector srcImgs, @ByVal UMat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector FloatBuffer h,
                                             int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                             int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal UMatVector srcImgs, @ByVal UMat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector FloatBuffer h);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal GpuMatVector srcImgs, @ByVal UMat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector float[] h,
                                             int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                             int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal GpuMatVector srcImgs, @ByVal UMat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector float[] h);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal MatVector srcImgs, @ByVal GpuMat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector FloatPointer h,
                                             int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                             int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal MatVector srcImgs, @ByVal GpuMat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector FloatPointer h);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal UMatVector srcImgs, @ByVal GpuMat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector FloatBuffer h,
                                             int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                             int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal UMatVector srcImgs, @ByVal GpuMat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector FloatBuffer h);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal GpuMatVector srcImgs, @ByVal GpuMat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector float[] h,
                                             int templateWindowSize/*=7*/, int searchWindowSize/*=21*/,
                                             int normType/*=cv::NORM_L2*/);
@Namespace("cv") public static native void fastNlMeansDenoisingMulti( @ByVal GpuMatVector srcImgs, @ByVal GpuMat dst,
                                             int imgToDenoiseIndex, int temporalWindowSize,
                                             @StdVector float[] h);

/** \brief Modification of fastNlMeansDenoisingMulti function for colored images sequences
<p>
@param srcImgs Input 8-bit 3-channel images sequence. All images should have the same type and
size.
@param imgToDenoiseIndex Target image to denoise index in srcImgs sequence
@param temporalWindowSize Number of surrounding images to use for target image denoising. Should
be odd. Images from imgToDenoiseIndex - temporalWindowSize / 2 to
imgToDenoiseIndex - temporalWindowSize / 2 from srcImgs will be used to denoise
srcImgs[imgToDenoiseIndex] image.
@param dst Output image with the same size and type as srcImgs images.
@param templateWindowSize Size in pixels of the template patch that is used to compute weights.
Should be odd. Recommended value 7 pixels
@param searchWindowSize Size in pixels of the window that is used to compute weighted average for
given pixel. Should be odd. Affect performance linearly: greater searchWindowsSize - greater
denoising time. Recommended value 21 pixels
@param h Parameter regulating filter strength for luminance component. Bigger h value perfectly
removes noise but also removes image details, smaller h value preserves details but also preserves
some noise.
@param hColor The same as h but for color components.
<p>
The function converts images to CIELAB colorspace and then separately denoise L and AB components
with given h parameters using fastNlMeansDenoisingMulti function.
 */
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal MatVector srcImgs, @ByVal Mat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, float hColor/*=3*/,
        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal MatVector srcImgs, @ByVal Mat dst,
        int imgToDenoiseIndex, int temporalWindowSize);
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal UMatVector srcImgs, @ByVal Mat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, float hColor/*=3*/,
        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal UMatVector srcImgs, @ByVal Mat dst,
        int imgToDenoiseIndex, int temporalWindowSize);
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal GpuMatVector srcImgs, @ByVal Mat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, float hColor/*=3*/,
        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal GpuMatVector srcImgs, @ByVal Mat dst,
        int imgToDenoiseIndex, int temporalWindowSize);
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal MatVector srcImgs, @ByVal UMat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, float hColor/*=3*/,
        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal MatVector srcImgs, @ByVal UMat dst,
        int imgToDenoiseIndex, int temporalWindowSize);
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal UMatVector srcImgs, @ByVal UMat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, float hColor/*=3*/,
        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal UMatVector srcImgs, @ByVal UMat dst,
        int imgToDenoiseIndex, int temporalWindowSize);
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal GpuMatVector srcImgs, @ByVal UMat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, float hColor/*=3*/,
        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal GpuMatVector srcImgs, @ByVal UMat dst,
        int imgToDenoiseIndex, int temporalWindowSize);
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal MatVector srcImgs, @ByVal GpuMat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, float hColor/*=3*/,
        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal MatVector srcImgs, @ByVal GpuMat dst,
        int imgToDenoiseIndex, int temporalWindowSize);
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal UMatVector srcImgs, @ByVal GpuMat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, float hColor/*=3*/,
        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal UMatVector srcImgs, @ByVal GpuMat dst,
        int imgToDenoiseIndex, int temporalWindowSize);
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal GpuMatVector srcImgs, @ByVal GpuMat dst,
        int imgToDenoiseIndex, int temporalWindowSize,
        float h/*=3*/, float hColor/*=3*/,
        int templateWindowSize/*=7*/, int searchWindowSize/*=21*/);
@Namespace("cv") public static native void fastNlMeansDenoisingColoredMulti( @ByVal GpuMatVector srcImgs, @ByVal GpuMat dst,
        int imgToDenoiseIndex, int temporalWindowSize);

/** \brief Primal-dual algorithm is an algorithm for solving special types of variational problems (that is,
finding a function to minimize some functional). As the image denoising, in particular, may be seen
as the variational problem, primal-dual algorithm then can be used to perform denoising and this is
exactly what is implemented.
<p>
It should be noted, that this implementation was taken from the July 2013 blog entry
\cite MA13 , which also contained (slightly more general) ready-to-use source code on Python.
Subsequently, that code was rewritten on C++ with the usage of openCV by Vadim Pisarevsky at the end
of July 2013 and finally it was slightly adapted by later authors.
<p>
Although the thorough discussion and justification of the algorithm involved may be found in
\cite ChambolleEtAl, it might make sense to skim over it here, following \cite MA13 . To begin
with, we consider the 1-byte gray-level images as the functions from the rectangular domain of
pixels (it may be seen as set
{@code \left\{(x,y)\in\mathbb{N}\times\mathbb{N}\mid 1\leq x\leq n,\;1\leq y\leq m\right\}} for some
{@code m,\;n\in\mathbb{N}}) into {@code \{0,1,\dots,255\}}. We shall denote the noised images as {@code f_i} and with
this view, given some image {@code x} of the same size, we may measure how bad it is by the formula
<p>
<pre>{@code \[\left\|\left\|\nabla x\right\|\right\| + \lambda\sum_i\left\|\left\|x-f_i\right\|\right\|\]}</pre>
<p>
{@code \|\|\cdot\|\|} here denotes {@code L_2}-norm and as you see, the first addend states that we want our
image to be smooth (ideally, having zero gradient, thus being constant) and the second states that
we want our result to be close to the observations we've got. If we treat {@code x} as a function, this is
exactly the functional what we seek to minimize and here the Primal-Dual algorithm comes into play.
<p>
@param observations This array should contain one or more noised versions of the image that is to
be restored.
@param result Here the denoised image will be stored. There is no need to do pre-allocation of
storage space, as it will be automatically allocated, if necessary.
@param lambda Corresponds to {@code \lambda} in the formulas above. As it is enlarged, the smooth
(blurred) images are treated more favorably than detailed (but maybe more noised) ones. Roughly
speaking, as it becomes smaller, the result will be more blur but more sever outliers will be
removed.
@param niters Number of iterations that the algorithm will run. Of course, as more iterations as
better, but it is hard to quantitatively refine this statement, so just use the default and
increase it if the results are poor.
 */
@Namespace("cv") public static native void denoise_TVL1(@Const @ByRef MatVector observations,@ByRef Mat result, double lambda/*=1.0*/, int niters/*=30*/);
@Namespace("cv") public static native void denoise_TVL1(@Const @ByRef MatVector observations,@ByRef Mat result);

/** \} photo_denoise
 <p>
 *  \addtogroup photo_hdr
 *  \{ */

/** enum cv:: */
public static final int LDR_SIZE = 256;
// Targeting ../opencv_photo/Tonemap.java



/** \brief Creates simple linear mapper with gamma correction
<p>
@param gamma positive value for gamma correction. Gamma value of 1.0 implies no correction, gamma
equal to 2.2f is suitable for most displays.
Generally gamma \> 1 brightens the image and gamma \< 1 darkens it.
 */
@Namespace("cv") public static native @Ptr Tonemap createTonemap(float gamma/*=1.0f*/);
@Namespace("cv") public static native @Ptr Tonemap createTonemap();
// Targeting ../opencv_photo/TonemapDrago.java



/** \brief Creates TonemapDrago object
<p>
@param gamma gamma value for gamma correction. See createTonemap
@param saturation positive saturation enhancement value. 1.0 preserves saturation, values greater
than 1 increase saturation and values less than 1 decrease it.
@param bias value for bias function in [0, 1] range. Values from 0.7 to 0.9 usually give best
results, default value is 0.85.
 */
@Namespace("cv") public static native @Ptr TonemapDrago createTonemapDrago(float gamma/*=1.0f*/, float saturation/*=1.0f*/, float bias/*=0.85f*/);
@Namespace("cv") public static native @Ptr TonemapDrago createTonemapDrago();
// Targeting ../opencv_photo/TonemapReinhard.java



/** \brief Creates TonemapReinhard object
<p>
@param gamma gamma value for gamma correction. See createTonemap
@param intensity result intensity in [-8, 8] range. Greater intensity produces brighter results.
@param light_adapt light adaptation in [0, 1] range. If 1 adaptation is based only on pixel
value, if 0 it's global, otherwise it's a weighted mean of this two cases.
@param color_adapt chromatic adaptation in [0, 1] range. If 1 channels are treated independently,
if 0 adaptation level is the same for each channel.
 */
@Namespace("cv") public static native @Ptr TonemapReinhard createTonemapReinhard(float gamma/*=1.0f*/, float intensity/*=0.0f*/, float light_adapt/*=1.0f*/, float color_adapt/*=0.0f*/);
@Namespace("cv") public static native @Ptr TonemapReinhard createTonemapReinhard();
// Targeting ../opencv_photo/TonemapMantiuk.java



/** \brief Creates TonemapMantiuk object
<p>
@param gamma gamma value for gamma correction. See createTonemap
@param scale contrast scale factor. HVS response is multiplied by this parameter, thus compressing
dynamic range. Values from 0.6 to 0.9 produce best results.
@param saturation saturation enhancement value. See createTonemapDrago
 */
@Namespace("cv") public static native @Ptr TonemapMantiuk createTonemapMantiuk(float gamma/*=1.0f*/, float scale/*=0.7f*/, float saturation/*=1.0f*/);
@Namespace("cv") public static native @Ptr TonemapMantiuk createTonemapMantiuk();
// Targeting ../opencv_photo/AlignExposures.java


// Targeting ../opencv_photo/AlignMTB.java



/** \brief Creates AlignMTB object
<p>
@param max_bits logarithm to the base 2 of maximal shift in each dimension. Values of 5 and 6 are
usually good enough (31 and 63 pixels shift respectively).
@param exclude_range range for exclusion bitmap that is constructed to suppress noise around the
median value.
@param cut if true cuts images, otherwise fills the new regions with zeros.
 */
@Namespace("cv") public static native @Ptr AlignMTB createAlignMTB(int max_bits/*=6*/, int exclude_range/*=4*/, @Cast("bool") boolean cut/*=true*/);
@Namespace("cv") public static native @Ptr AlignMTB createAlignMTB();
// Targeting ../opencv_photo/CalibrateCRF.java


// Targeting ../opencv_photo/CalibrateDebevec.java



/** \brief Creates CalibrateDebevec object
<p>
@param samples number of pixel locations to use
@param lambda smoothness term weight. Greater values produce smoother results, but can alter the
response.
@param random if true sample pixel locations are chosen at random, otherwise they form a
rectangular grid.
 */
@Namespace("cv") public static native @Ptr CalibrateDebevec createCalibrateDebevec(int samples/*=70*/, float lambda/*=10.0f*/, @Cast("bool") boolean random/*=false*/);
@Namespace("cv") public static native @Ptr CalibrateDebevec createCalibrateDebevec();
// Targeting ../opencv_photo/CalibrateRobertson.java



/** \brief Creates CalibrateRobertson object
<p>
@param max_iter maximal number of Gauss-Seidel solver iterations.
@param threshold target difference between results of two successive steps of the minimization.
 */
@Namespace("cv") public static native @Ptr CalibrateRobertson createCalibrateRobertson(int max_iter/*=30*/, float threshold/*=0.01f*/);
@Namespace("cv") public static native @Ptr CalibrateRobertson createCalibrateRobertson();
// Targeting ../opencv_photo/MergeExposures.java


// Targeting ../opencv_photo/MergeDebevec.java



/** \brief Creates MergeDebevec object
 */
@Namespace("cv") public static native @Ptr MergeDebevec createMergeDebevec();
// Targeting ../opencv_photo/MergeMertens.java



/** \brief Creates MergeMertens object
<p>
@param contrast_weight contrast measure weight. See MergeMertens.
@param saturation_weight saturation measure weight
@param exposure_weight well-exposedness measure weight
 */
@Namespace("cv") public static native @Ptr MergeMertens createMergeMertens(float contrast_weight/*=1.0f*/, float saturation_weight/*=1.0f*/, float exposure_weight/*=0.0f*/);
@Namespace("cv") public static native @Ptr MergeMertens createMergeMertens();
// Targeting ../opencv_photo/MergeRobertson.java



/** \brief Creates MergeRobertson object
 */
@Namespace("cv") public static native @Ptr MergeRobertson createMergeRobertson();

/** \} photo_hdr
 <p>
 *  \addtogroup photo_decolor
 *  \{
<p>
/** \brief Transforms a color image to a grayscale image. It is a basic tool in digital printing, stylized
black-and-white photograph rendering, and in many single channel image processing applications
\cite CL12 .
<p>
@param src Input 8-bit 3-channel image.
@param grayscale Output 8-bit 1-channel image.
@param color_boost Output 8-bit 3-channel image.
<p>
This function is to be applied on color images.
 */
@Namespace("cv") public static native void decolor( @ByVal Mat src, @ByVal Mat grayscale, @ByVal Mat color_boost);
@Namespace("cv") public static native void decolor( @ByVal UMat src, @ByVal UMat grayscale, @ByVal UMat color_boost);
@Namespace("cv") public static native void decolor( @ByVal GpuMat src, @ByVal GpuMat grayscale, @ByVal GpuMat color_boost);

/** \} photo_decolor
 <p>
 *  \addtogroup photo_clone
 *  \{
 <p>
 <p>
 *  seamlessClone algorithm flags */
/** enum cv:: */
public static final int
    /** The power of the method is fully expressed when inserting objects with complex outlines into a new background*/
    NORMAL_CLONE = 1,
    /** The classic method, color-based selection and alpha masking might be time consuming and often leaves an undesirable
    halo. Seamless cloning, even averaged with the original image, is not effective. Mixed seamless cloning based on a loose selection proves effective.*/
    MIXED_CLONE  = 2,
    /** Monochrome transfer allows the user to easily replace certain features of one object by alternative features.*/
    MONOCHROME_TRANSFER = 3;


/** \example samples/cpp/tutorial_code/photo/seamless_cloning/cloning_demo.cpp
An example using seamlessClone function
*/
/** \brief Image editing tasks concern either global changes (color/intensity corrections, filters,
deformations) or local changes concerned to a selection. Here we are interested in achieving local
changes, ones that are restricted to a region manually selected (ROI), in a seamless and effortless
manner. The extent of the changes ranges from slight distortions to complete replacement by novel
content \cite PM03 .
<p>
@param src Input 8-bit 3-channel image.
@param dst Input 8-bit 3-channel image.
@param mask Input 8-bit 1 or 3-channel image.
@param p Point in dst image where object is placed.
@param blend Output image with the same size and type as dst.
@param flags Cloning method that could be cv::NORMAL_CLONE, cv::MIXED_CLONE or cv::MONOCHROME_TRANSFER
 */
@Namespace("cv") public static native void seamlessClone( @ByVal Mat src, @ByVal Mat dst, @ByVal Mat mask, @ByVal Point p,
        @ByVal Mat blend, int flags);
@Namespace("cv") public static native void seamlessClone( @ByVal UMat src, @ByVal UMat dst, @ByVal UMat mask, @ByVal Point p,
        @ByVal UMat blend, int flags);
@Namespace("cv") public static native void seamlessClone( @ByVal GpuMat src, @ByVal GpuMat dst, @ByVal GpuMat mask, @ByVal Point p,
        @ByVal GpuMat blend, int flags);

/** \brief Given an original color image, two differently colored versions of this image can be mixed
seamlessly.
<p>
@param src Input 8-bit 3-channel image.
@param mask Input 8-bit 1 or 3-channel image.
@param dst Output image with the same size and type as src .
@param red_mul R-channel multiply factor.
@param green_mul G-channel multiply factor.
@param blue_mul B-channel multiply factor.
<p>
Multiplication factor is between .5 to 2.5.
 */
@Namespace("cv") public static native void colorChange(@ByVal Mat src, @ByVal Mat mask, @ByVal Mat dst, float red_mul/*=1.0f*/,
        float green_mul/*=1.0f*/, float blue_mul/*=1.0f*/);
@Namespace("cv") public static native void colorChange(@ByVal Mat src, @ByVal Mat mask, @ByVal Mat dst);
@Namespace("cv") public static native void colorChange(@ByVal UMat src, @ByVal UMat mask, @ByVal UMat dst, float red_mul/*=1.0f*/,
        float green_mul/*=1.0f*/, float blue_mul/*=1.0f*/);
@Namespace("cv") public static native void colorChange(@ByVal UMat src, @ByVal UMat mask, @ByVal UMat dst);
@Namespace("cv") public static native void colorChange(@ByVal GpuMat src, @ByVal GpuMat mask, @ByVal GpuMat dst, float red_mul/*=1.0f*/,
        float green_mul/*=1.0f*/, float blue_mul/*=1.0f*/);
@Namespace("cv") public static native void colorChange(@ByVal GpuMat src, @ByVal GpuMat mask, @ByVal GpuMat dst);

/** \brief Applying an appropriate non-linear transformation to the gradient field inside the selection and
then integrating back with a Poisson solver, modifies locally the apparent illumination of an image.
<p>
@param src Input 8-bit 3-channel image.
@param mask Input 8-bit 1 or 3-channel image.
@param dst Output image with the same size and type as src.
@param alpha Value ranges between 0-2.
@param beta Value ranges between 0-2.
<p>
This is useful to highlight under-exposed foreground objects or to reduce specular reflections.
 */
@Namespace("cv") public static native void illuminationChange(@ByVal Mat src, @ByVal Mat mask, @ByVal Mat dst,
        float alpha/*=0.2f*/, float beta/*=0.4f*/);
@Namespace("cv") public static native void illuminationChange(@ByVal Mat src, @ByVal Mat mask, @ByVal Mat dst);
@Namespace("cv") public static native void illuminationChange(@ByVal UMat src, @ByVal UMat mask, @ByVal UMat dst,
        float alpha/*=0.2f*/, float beta/*=0.4f*/);
@Namespace("cv") public static native void illuminationChange(@ByVal UMat src, @ByVal UMat mask, @ByVal UMat dst);
@Namespace("cv") public static native void illuminationChange(@ByVal GpuMat src, @ByVal GpuMat mask, @ByVal GpuMat dst,
        float alpha/*=0.2f*/, float beta/*=0.4f*/);
@Namespace("cv") public static native void illuminationChange(@ByVal GpuMat src, @ByVal GpuMat mask, @ByVal GpuMat dst);

/** \brief By retaining only the gradients at edge locations, before integrating with the Poisson solver, one
washes out the texture of the selected region, giving its contents a flat aspect. Here Canny Edge %Detector is used.
<p>
@param src Input 8-bit 3-channel image.
@param mask Input 8-bit 1 or 3-channel image.
@param dst Output image with the same size and type as src.
@param low_threshold %Range from 0 to 100.
@param high_threshold Value \> 100.
@param kernel_size The size of the Sobel kernel to be used.
<p>
\note
The algorithm assumes that the color of the source image is close to that of the destination. This
assumption means that when the colors don't match, the source image color gets tinted toward the
color of the destination image.
 */
@Namespace("cv") public static native void textureFlattening(@ByVal Mat src, @ByVal Mat mask, @ByVal Mat dst,
        float low_threshold/*=30*/, float high_threshold/*=45*/,
        int kernel_size/*=3*/);
@Namespace("cv") public static native void textureFlattening(@ByVal Mat src, @ByVal Mat mask, @ByVal Mat dst);
@Namespace("cv") public static native void textureFlattening(@ByVal UMat src, @ByVal UMat mask, @ByVal UMat dst,
        float low_threshold/*=30*/, float high_threshold/*=45*/,
        int kernel_size/*=3*/);
@Namespace("cv") public static native void textureFlattening(@ByVal UMat src, @ByVal UMat mask, @ByVal UMat dst);
@Namespace("cv") public static native void textureFlattening(@ByVal GpuMat src, @ByVal GpuMat mask, @ByVal GpuMat dst,
        float low_threshold/*=30*/, float high_threshold/*=45*/,
        int kernel_size/*=3*/);
@Namespace("cv") public static native void textureFlattening(@ByVal GpuMat src, @ByVal GpuMat mask, @ByVal GpuMat dst);

/** \} photo_clone
 <p>
 *  \addtogroup photo_render
 *  \{
 <p>
 *  Edge preserving filters */
/** enum cv:: */
public static final int
    /** Recursive Filtering */
    RECURS_FILTER = 1,
    /** Normalized Convolution Filtering */
    NORMCONV_FILTER = 2;

/** \brief Filtering is the fundamental operation in image and video processing. Edge-preserving smoothing
filters are used in many different applications \cite EM11 .
<p>
@param src Input 8-bit 3-channel image.
@param dst Output 8-bit 3-channel image.
@param flags Edge preserving filters: cv::RECURS_FILTER or cv::NORMCONV_FILTER
@param sigma_s %Range between 0 to 200.
@param sigma_r %Range between 0 to 1.
 */
@Namespace("cv") public static native void edgePreservingFilter(@ByVal Mat src, @ByVal Mat dst, int flags/*=1*/,
        float sigma_s/*=60*/, float sigma_r/*=0.4f*/);
@Namespace("cv") public static native void edgePreservingFilter(@ByVal Mat src, @ByVal Mat dst);
@Namespace("cv") public static native void edgePreservingFilter(@ByVal UMat src, @ByVal UMat dst, int flags/*=1*/,
        float sigma_s/*=60*/, float sigma_r/*=0.4f*/);
@Namespace("cv") public static native void edgePreservingFilter(@ByVal UMat src, @ByVal UMat dst);
@Namespace("cv") public static native void edgePreservingFilter(@ByVal GpuMat src, @ByVal GpuMat dst, int flags/*=1*/,
        float sigma_s/*=60*/, float sigma_r/*=0.4f*/);
@Namespace("cv") public static native void edgePreservingFilter(@ByVal GpuMat src, @ByVal GpuMat dst);

/** \brief This filter enhances the details of a particular image.
<p>
@param src Input 8-bit 3-channel image.
@param dst Output image with the same size and type as src.
@param sigma_s %Range between 0 to 200.
@param sigma_r %Range between 0 to 1.
 */
@Namespace("cv") public static native void detailEnhance(@ByVal Mat src, @ByVal Mat dst, float sigma_s/*=10*/,
        float sigma_r/*=0.15f*/);
@Namespace("cv") public static native void detailEnhance(@ByVal Mat src, @ByVal Mat dst);
@Namespace("cv") public static native void detailEnhance(@ByVal UMat src, @ByVal UMat dst, float sigma_s/*=10*/,
        float sigma_r/*=0.15f*/);
@Namespace("cv") public static native void detailEnhance(@ByVal UMat src, @ByVal UMat dst);
@Namespace("cv") public static native void detailEnhance(@ByVal GpuMat src, @ByVal GpuMat dst, float sigma_s/*=10*/,
        float sigma_r/*=0.15f*/);
@Namespace("cv") public static native void detailEnhance(@ByVal GpuMat src, @ByVal GpuMat dst);

/** \example samples/cpp/tutorial_code/photo/non_photorealistic_rendering/npr_demo.cpp
An example using non-photorealistic line drawing functions
*/
/** \brief Pencil-like non-photorealistic line drawing
<p>
@param src Input 8-bit 3-channel image.
@param dst1 Output 8-bit 1-channel image.
@param dst2 Output image with the same size and type as src.
@param sigma_s %Range between 0 to 200.
@param sigma_r %Range between 0 to 1.
@param shade_factor %Range between 0 to 0.1.
 */
@Namespace("cv") public static native void pencilSketch(@ByVal Mat src, @ByVal Mat dst1, @ByVal Mat dst2,
        float sigma_s/*=60*/, float sigma_r/*=0.07f*/, float shade_factor/*=0.02f*/);
@Namespace("cv") public static native void pencilSketch(@ByVal Mat src, @ByVal Mat dst1, @ByVal Mat dst2);
@Namespace("cv") public static native void pencilSketch(@ByVal UMat src, @ByVal UMat dst1, @ByVal UMat dst2,
        float sigma_s/*=60*/, float sigma_r/*=0.07f*/, float shade_factor/*=0.02f*/);
@Namespace("cv") public static native void pencilSketch(@ByVal UMat src, @ByVal UMat dst1, @ByVal UMat dst2);
@Namespace("cv") public static native void pencilSketch(@ByVal GpuMat src, @ByVal GpuMat dst1, @ByVal GpuMat dst2,
        float sigma_s/*=60*/, float sigma_r/*=0.07f*/, float shade_factor/*=0.02f*/);
@Namespace("cv") public static native void pencilSketch(@ByVal GpuMat src, @ByVal GpuMat dst1, @ByVal GpuMat dst2);

/** \brief Stylization aims to produce digital imagery with a wide variety of effects not focused on
photorealism. Edge-aware filters are ideal for stylization, as they can abstract regions of low
contrast while preserving, or enhancing, high-contrast features.
<p>
@param src Input 8-bit 3-channel image.
@param dst Output image with the same size and type as src.
@param sigma_s %Range between 0 to 200.
@param sigma_r %Range between 0 to 1.
 */
@Namespace("cv") public static native void stylization(@ByVal Mat src, @ByVal Mat dst, float sigma_s/*=60*/,
        float sigma_r/*=0.45f*/);
@Namespace("cv") public static native void stylization(@ByVal Mat src, @ByVal Mat dst);
@Namespace("cv") public static native void stylization(@ByVal UMat src, @ByVal UMat dst, float sigma_s/*=60*/,
        float sigma_r/*=0.45f*/);
@Namespace("cv") public static native void stylization(@ByVal UMat src, @ByVal UMat dst);
@Namespace("cv") public static native void stylization(@ByVal GpuMat src, @ByVal GpuMat dst, float sigma_s/*=60*/,
        float sigma_r/*=0.45f*/);
@Namespace("cv") public static native void stylization(@ByVal GpuMat src, @ByVal GpuMat dst);

/** \} photo_render
 <p>
 *  \} photo */

 // cv

// #endif


// Parsed from <opencv2/photo/cuda.hpp>

/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                           License Agreement
//                For Open Source Computer Vision Library
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2008-2012, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of the copyright holders may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort (including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/

// #ifndef OPENCV_PHOTO_CUDA_HPP
// #define OPENCV_PHOTO_CUDA_HPP

// #include "opencv2/core/cuda.hpp"

/** \addtogroup photo_denoise
 *  \{
<p>
/** \brief Performs pure non local means denoising without any simplification, and thus it is not fast.
<p>
@param src Source image. Supports only CV_8UC1, CV_8UC2 and CV_8UC3.
@param dst Destination image.
@param h Filter sigma regulating filter strength for color.
@param search_window Size of search window.
@param block_size Size of block used for computing weights.
@param borderMode Border type. See borderInterpolate for details. BORDER_REFLECT101 ,
BORDER_REPLICATE , BORDER_CONSTANT , BORDER_REFLECT and BORDER_WRAP are supported for now.
@param stream Stream for the asynchronous version.
<p>
@see
   fastNlMeansDenoising
 */
@Namespace("cv::cuda") public static native void nonLocalMeans(@ByVal Mat src, @ByVal Mat dst,
                              float h,
                              int search_window/*=21*/,
                              int block_size/*=7*/,
                              int borderMode/*=cv::BORDER_DEFAULT*/,
                              @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void nonLocalMeans(@ByVal Mat src, @ByVal Mat dst,
                              float h);
@Namespace("cv::cuda") public static native void nonLocalMeans(@ByVal UMat src, @ByVal UMat dst,
                              float h,
                              int search_window/*=21*/,
                              int block_size/*=7*/,
                              int borderMode/*=cv::BORDER_DEFAULT*/,
                              @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void nonLocalMeans(@ByVal UMat src, @ByVal UMat dst,
                              float h);
@Namespace("cv::cuda") public static native void nonLocalMeans(@ByVal GpuMat src, @ByVal GpuMat dst,
                              float h,
                              int search_window/*=21*/,
                              int block_size/*=7*/,
                              int borderMode/*=cv::BORDER_DEFAULT*/,
                              @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void nonLocalMeans(@ByVal GpuMat src, @ByVal GpuMat dst,
                              float h);

/** \brief Perform image denoising using Non-local Means Denoising algorithm
<http://www.ipol.im/pub/algo/bcm_non_local_means_denoising> with several computational
optimizations. Noise expected to be a gaussian white noise
<p>
@param src Input 8-bit 1-channel, 2-channel or 3-channel image.
@param dst Output image with the same size and type as src .
@param h Parameter regulating filter strength. Big h value perfectly removes noise but also
removes image details, smaller h value preserves details but also preserves some noise
@param search_window Size in pixels of the window that is used to compute weighted average for
given pixel. Should be odd. Affect performance linearly: greater search_window - greater
denoising time. Recommended value 21 pixels
@param block_size Size in pixels of the template patch that is used to compute weights. Should be
odd. Recommended value 7 pixels
@param stream Stream for the asynchronous invocations.
<p>
This function expected to be applied to grayscale images. For colored images look at
FastNonLocalMeansDenoising::labMethod.
<p>
@see
   fastNlMeansDenoising
 */
@Namespace("cv::cuda") public static native void fastNlMeansDenoising(@ByVal Mat src, @ByVal Mat dst,
                                     float h,
                                     int search_window/*=21*/,
                                     int block_size/*=7*/,
                                     @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void fastNlMeansDenoising(@ByVal Mat src, @ByVal Mat dst,
                                     float h);
@Namespace("cv::cuda") public static native void fastNlMeansDenoising(@ByVal UMat src, @ByVal UMat dst,
                                     float h,
                                     int search_window/*=21*/,
                                     int block_size/*=7*/,
                                     @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void fastNlMeansDenoising(@ByVal UMat src, @ByVal UMat dst,
                                     float h);
@Namespace("cv::cuda") public static native void fastNlMeansDenoising(@ByVal GpuMat src, @ByVal GpuMat dst,
                                     float h,
                                     int search_window/*=21*/,
                                     int block_size/*=7*/,
                                     @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void fastNlMeansDenoising(@ByVal GpuMat src, @ByVal GpuMat dst,
                                     float h);

/** \brief Modification of fastNlMeansDenoising function for colored images
<p>
@param src Input 8-bit 3-channel image.
@param dst Output image with the same size and type as src .
@param h_luminance Parameter regulating filter strength. Big h value perfectly removes noise but
also removes image details, smaller h value preserves details but also preserves some noise
@param photo_render float The same as h but for color components. For most images value equals 10 will be
enough to remove colored noise and do not distort colors
@param search_window Size in pixels of the window that is used to compute weighted average for
given pixel. Should be odd. Affect performance linearly: greater search_window - greater
denoising time. Recommended value 21 pixels
@param block_size Size in pixels of the template patch that is used to compute weights. Should be
odd. Recommended value 7 pixels
@param stream Stream for the asynchronous invocations.
<p>
The function converts image to CIELAB colorspace and then separately denoise L and AB components
with given h parameters using FastNonLocalMeansDenoising::simpleMethod function.
<p>
@see
   fastNlMeansDenoisingColored
 */
@Namespace("cv::cuda") public static native void fastNlMeansDenoisingColored(@ByVal Mat src, @ByVal Mat dst,
                                            float h_luminance, float photo_render,
                                            int search_window/*=21*/,
                                            int block_size/*=7*/,
                                            @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void fastNlMeansDenoisingColored(@ByVal Mat src, @ByVal Mat dst,
                                            float h_luminance, float photo_render);
@Namespace("cv::cuda") public static native void fastNlMeansDenoisingColored(@ByVal UMat src, @ByVal UMat dst,
                                            float h_luminance, float photo_render,
                                            int search_window/*=21*/,
                                            int block_size/*=7*/,
                                            @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void fastNlMeansDenoisingColored(@ByVal UMat src, @ByVal UMat dst,
                                            float h_luminance, float photo_render);
@Namespace("cv::cuda") public static native void fastNlMeansDenoisingColored(@ByVal GpuMat src, @ByVal GpuMat dst,
                                            float h_luminance, float photo_render,
                                            int search_window/*=21*/,
                                            int block_size/*=7*/,
                                            @ByRef(nullValue = "cv::cuda::Stream::Null()") Stream stream);
@Namespace("cv::cuda") public static native void fastNlMeansDenoisingColored(@ByVal GpuMat src, @ByVal GpuMat dst,
                                            float h_luminance, float photo_render);

/** \} photo */

 // namespace cv { namespace cuda {

// #endif /* OPENCV_PHOTO_CUDA_HPP */


}
