// Targeted by JavaCPP version 1.4.4: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class ale extends org.bytedeco.javacpp.presets.ale {
    static { Loader.load(); }

// Parsed from emucore/m6502/src/bspf/src/bspf.hxx

//============================================================================
//
//  BBBBB    SSSS   PPPPP   FFFFFF 
//  BB  BB  SS  SS  PP  PP  FF
//  BB  BB  SS      PP  PP  FF
//  BBBBB    SSSS   PPPPP   FFFF    --  "Brad's Simple Portability Framework"
//  BB  BB      SS  PP      FF
//  BB  BB  SS  SS  PP      FF
//  BBBBB    SSSS   PP      FF
//
// Copyright (c) 1997-1998 by Bradford W. Mott
//
// See the file "license" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.
//
// $Id: bspf.hxx,v 1.17 2007/07/31 15:46:21 stephena Exp $
//============================================================================

// #ifndef BSPF_HXX
// #define BSPF_HXX

/**
  This file defines various basic data types and preprocessor variables
  that need to be defined for different operating systems.
  <p>
  @author Bradford W. Mott
  @version $Id: bspf.hxx,v 1.17 2007/07/31 15:46:21 stephena Exp $
*/

// Types for 8-bit signed and unsigned integers

// Types for 16-bit signed and unsigned integers

// Types for 32-bit signed and unsigned integers

// The following code should provide access to the standard C++ objects and
// types: cerr, cerr, string, ostream, istream, etc.
// #ifdef BSPF_OLD_STYLE_CXX_HEADERS
//   #include <iostream.h>
//   #include <iomanip.h>
//   #include <string.h>
// #else
//   #include <iostream>
//   #include <iomanip>
//   #include <string>
// #endif
	
// #ifdef HAVE_INTTYPES
//   #include <inttypes.h>
// #endif

// Defines to help with path handling
//ALE  #if defined BSPF_UNIX
public static final String BSPF_PATH_SEPARATOR =  "/";
//ALE  #elif (defined(BSPF_DOS) || defined(BSPF_WIN32) || defined(BSPF_OS2))
//ALE    #define BSPF_PATH_SEPARATOR  "\\"
//ALE  #elif defined BSPF_MAC_OSX
//ALE    #define BSPF_PATH_SEPARATOR  "/"
//ALE  #elif defined BSPF_GP2X
//ALE      #define BSPF_PATH_SEPARATOR  "/"
//ALE  #endif

// I wish Windows had a complete POSIX layer
// #ifdef BSPF_WIN32
//   #define BSPF_strcasecmp stricmp
//   #define BSPF_strncasecmp strnicmp
//   #define BSPF_isblank(c) ((c == ' ') || (c == '\t'))
//   #define BSPF_snprintf _snprintf
//   #define BSPF_vsnprintf _vsnprintf
// #else
//   #define BSPF_strcasecmp strcasecmp
//   #define BSPF_strncasecmp strncasecmp
//   #define BSPF_isblank(c) isblank(c)
//   #define BSPF_snprintf snprintf
//   #define BSPF_vsnprintf vsnprintf
// #endif

// Some convenience functions

// #ifdef _WIN32_WCE
//   #include "missing.h"
// #endif

// #endif


// Parsed from emucore/m6502/src/Device.hxx

//============================================================================
//
// MM     MM  6666  555555  0000   2222
// MMMM MMMM 66  66 55     00  00 22  22
// MM MMM MM 66     55     00  00     22
// MM  M  MM 66666  55555  00  00  22222  --  "A 6502 Microprocessor Emulator"
// MM     MM 66  66     55 00  00 22
// MM     MM 66  66 55  55 00  00 22
// MM     MM  6666   5555   0000  222222
//
// Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
//
// See the file "license" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.
//
// $Id: Device.hxx,v 1.6 2007/01/14 16:17:57 stephena Exp $
//============================================================================

// #ifndef DEVICE_HXX
// #define DEVICE_HXX

@Opaque public static class System extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public System() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public System(Pointer p) { super(p); }
}
@Opaque public static class Serializer extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Serializer() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Serializer(Pointer p) { super(p); }
}
@Opaque public static class Deserializer extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Deserializer() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Deserializer(Pointer p) { super(p); }
}

// #include "bspf/src/bspf.hxx"

/**
  Abstract base class for devices which can be attached to a 6502
  based system.
  <p>
  @author  Bradford W. Mott
  @version $Id: Device.hxx,v 1.6 2007/01/14 16:17:57 stephena Exp $
*/
@NoOffset public static class Device extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Device(Pointer p) { super(p); }

    /**
      Create a new device
    */

    /**
      Destructor
    */
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")
      <p>
      @return The name of the device
    */
    public native @Cast("const char*") BytePointer name();

    /**
      Reset device to its power-on state
    */
    public native void reset();

    /**
      Notification method invoked by the system right before the
      system resets its cycle counter to zero.  It may be necessary 
      to override this method for devices that remember cycle counts.
    */
    public native void systemCyclesReset();

    /**
      Install device in the specified system.  Invoked by the system
      when the device is attached to it.
      <p>
      @param system The system the device should install itself in
    */
    public native void install(@ByRef System system);

    /**
      Saves the current state of this device to the given Serializer.
      <p>
      @param out The serializer device to save to.
      @return The result of the save.  True on success, false on failure.
    */
    public native @Cast("bool") boolean save(@ByRef Serializer out);

    /**
      Loads the current state of this device from the given Deserializer.
      <p>
      @param in The deserializer device to load from.
      @return The result of the load.  True on success, false on failure.
    */
    public native @Cast("bool") boolean load(@ByRef Deserializer in);
    /**
      Get the byte at the specified address
      <p>
      @return The byte at the specified address
    */
    public native @Cast("uInt8") byte peek(@Cast("uInt16") short address);

    /**
      Change the byte at the specified address to the given value
      <p>
      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    public native void poke(@Cast("uInt16") short address, @Cast("uInt8") byte value);
}

// #endif


// Parsed from emucore/Control.hxx

//============================================================================
//
//   SSSS    tt          lll  lll       
//  SS  SS   tt           ll   ll        
//  SS     tttttt  eeee   ll   ll   aaaa 
//   SSSS    tt   ee  ee  ll   ll      aa
//      SS   tt   eeeeee  ll   ll   aaaaa  --  "An Atari 2600 VCS Emulator"
//  SS  SS   tt   ee      ll   ll  aa  aa
//   SSSS     ttt  eeeee llll llll  aaaaa
//
// Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
//
// See the file "license" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.
//
// $Id: Control.hxx,v 1.9 2007/02/22 02:15:46 stephena Exp $
//============================================================================

// #ifndef CONTROLLER_HXX
// #define CONTROLLER_HXX

// #include "m6502/src/bspf/src/bspf.hxx"

/**
  A controller is a device that plugs into either the left or right 
  controller jack of the Video Computer System (VCS).  The pins of 
  the controller jacks are mapped as follows:
                           <p>
                           -------------
                           \ 1 2 3 4 5 /
                            \ 6 7 8 9 /
                             ---------
            <p>
            Left Controller             Right Controller
    <p>
    pin 1   D4  PIA SWCHA               D0  PIA SWCHA
    pin 2   D5  PIA SWCHA               D1  PIA SWCHA
    pin 3   D6  PIA SWCHA               D2  PIA SWCHA
    pin 4   D7  PIA SWCHA               D3  PIA SWCHA
    pin 5   D7  TIA INPT1 (Dumped)      D7  TIA INPT3 (Dumped)
    pin 6   D7  TIA INPT4 (Latched)     D7  TIA INPT5 (Latched)
    pin 7   +5                          +5
    pin 8   GND                         GND
    pin 9   D7  TIA INPT0 (Dumped)      D7  TIA INPT2 (Dumped)
  <p>
  Each of the pins connected to the PIA can be configured as an
  input or output pin.  The "dumped" TIA pins are used to charge
  a capacitor.  A potentiometer is sometimes connected to these
  pins for analog input.
  <p>
  This is a base class for all controllers.  It provides a view
  of the controller from the perspective of the controller's jack.
  <p>
  @author  Bradford W. Mott
  @version $Id: Control.hxx,v 1.9 2007/02/22 02:15:46 stephena Exp $
*/
@NoOffset public static class Controller extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Controller(Pointer p) { super(p); }

    /**
      Enumeration of the controller jacks
    */
    /** enum Controller::Jack */
    public static final int
      Left = 0, Right = 1;

    /**
      Enumeration of the controller types
    */
    /** enum Controller::Type */
    public static final int
      BoosterGrip = 0, Driving = 1, Keyboard = 2, Paddles = 3, Joystick = 4,
      TrakBall = 5, AtariVox = 6;
    /**
      Create a new controller plugged into the specified jack
      <p>
      @param jack  The jack the controller is plugged into
      @param event The event object to use for events
      @param type  The type for this controller
    */

    /**
      Destructor
    */

    /**
      Returns the type of this controller.
    */
    public native @Cast("Controller::Type") int type();

    /**
      Inform this controller about the current System.
    */
    public native void setSystem(System system);
    /**
      Enumeration of the digital pins of a controller port
    */
    /** enum Controller::DigitalPin */
    public static final int
      One = 0, Two = 1, Three = 2, Four = 3, Six = 4;

    /**
      Enumeration of the analog pins of a controller port
    */
    /** enum Controller::AnalogPin */
    public static final int
      Five = 0, Nine = 1;
    /**
      Read the value of the specified digital pin for this controller.
      <p>
      @param pin The pin of the controller jack to read
      @return The state of the pin
    */
    public native @Cast("bool") boolean read(@Cast("Controller::DigitalPin") int pin);

    /**
      Read the resistance at the specified analog pin for this controller.  
      The returned value is the resistance measured in ohms.
      <p>
      @param pin The pin of the controller jack to read
      @return The resistance at the specified pin
    */

    /**
      Write the given value to the specified digital pin for this 
      controller.  Writing is only allowed to the pins associated 
      with the PIA.  Therefore you cannot write to pin six.
      <p>
      @param pin The pin of the controller jack to write to
      @param value The value to write to the pin
    */
    public native void write(@Cast("Controller::DigitalPin") int pin, @Cast("bool") boolean value);
    /** Constant which represents maximum resistance for analog pins */
    @MemberGetter public static native @Cast("const Int32") int maximumResistance();
    public static final int maximumResistance = maximumResistance();

    /** Constant which represents minimum resistance for analog pins */
    @MemberGetter public static native @Cast("const Int32") int minimumResistance();
    public static final int minimumResistance = minimumResistance();
}

// #endif


// Parsed from emucore/Event.hxx

//============================================================================
//
//   SSSS    tt          lll  lll       
//  SS  SS   tt           ll   ll        
//  SS     tttttt  eeee   ll   ll   aaaa 
//   SSSS    tt   ee  ee  ll   ll      aa
//      SS   tt   eeeeee  ll   ll   aaaaa  --  "An Atari 2600 VCS Emulator"
//  SS  SS   tt   ee      ll   ll  aa  aa
//   SSSS     ttt  eeeee llll llll  aaaaa
//
// Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
//
// See the file "license" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.
//
// $Id: Event.hxx,v 1.28 2007/01/30 17:13:07 stephena Exp $
//============================================================================

// #ifndef EVENT_HXX
// #define EVENT_HXX

// #include "m6502/src/bspf/src/bspf.hxx"

/**
  @author  Bradford W. Mott
  @version $Id: Event.hxx,v 1.28 2007/01/30 17:13:07 stephena Exp $
*/
@NoOffset public static class Event extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Event(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Event(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Event position(long position) {
        return (Event)super.position(position);
    }

    /**
      Enumeration of all possible events in Stella, including both
      console and controller event types as well as events that aren't
      technically part of the emulation core
    */
    /** enum Event::Type */
    public static final int
      NoType = 0,
      ConsoleOn = 1, ConsoleOff = 2, ConsoleColor = 3, ConsoleBlackWhite = 4,
      ConsoleLeftDifficultyA = 5, ConsoleLeftDifficultyB = 6,
      ConsoleRightDifficultyA = 7, ConsoleRightDifficultyB = 8,
      ConsoleSelect = 9, ConsoleReset = 10,

      JoystickZeroUp = 11, JoystickZeroDown = 12, JoystickZeroLeft = 13,
      JoystickZeroRight = 14, JoystickZeroFire = 15,
      JoystickOneUp = 16, JoystickOneDown = 17, JoystickOneLeft = 18,
      JoystickOneRight = 19, JoystickOneFire = 20,

      BoosterGripZeroTrigger = 21, BoosterGripZeroBooster = 22,
      BoosterGripOneTrigger = 23, BoosterGripOneBooster = 24,

      PaddleZeroResistance = 25, PaddleZeroFire = 26,
        PaddleZeroDecrease = 27, PaddleZeroIncrease = 28, PaddleZeroAnalog = 29,
      PaddleOneResistance = 30, PaddleOneFire = 31,
        PaddleOneDecrease = 32, PaddleOneIncrease = 33, PaddleOneAnalog = 34,
      PaddleTwoResistance = 35, PaddleTwoFire = 36,
        PaddleTwoDecrease = 37, PaddleTwoIncrease = 38, PaddleTwoAnalog = 39,
      PaddleThreeResistance = 40, PaddleThreeFire = 41,
        PaddleThreeDecrease = 42, PaddleThreeIncrease = 43, PaddleThreeAnalog = 44,

      KeyboardZero1 = 45, KeyboardZero2 = 46, KeyboardZero3 = 47,
      KeyboardZero4 = 48, KeyboardZero5 = 49, KeyboardZero6 = 50,
      KeyboardZero7 = 51, KeyboardZero8 = 52, KeyboardZero9 = 53,
      KeyboardZeroStar = 54, KeyboardZero0 = 55, KeyboardZeroPound = 56,

      KeyboardOne1 = 57, KeyboardOne2 = 58, KeyboardOne3 = 59,
      KeyboardOne4 = 60, KeyboardOne5 = 61, KeyboardOne6 = 62,
      KeyboardOne7 = 63, KeyboardOne8 = 64, KeyboardOne9 = 65,
      KeyboardOneStar = 66, KeyboardOne0 = 67, KeyboardOnePound = 68,

      DrivingZeroClockwise = 69, DrivingZeroCounterClockwise = 70, DrivingZeroValue = 71, 
      DrivingZeroFire = 72,
      DrivingOneClockwise = 73, DrivingOneCounterClockwise = 74, DrivingOneValue = 75,
      DrivingOneFire = 76,
      
      ChangeState = 77, LoadState = 78, SaveState = 79, TakeSnapshot = 80, Quit = 81,
      PauseMode = 82, MenuMode = 83, CmdMenuMode = 84, DebuggerMode = 85, LauncherMode = 86,
      Fry = 87, VolumeDecrease = 88, VolumeIncrease = 89,

      UIUp = 90, UIDown = 91, UILeft = 92, UIRight = 93, UIHome = 94, UIEnd = 95, UIPgUp = 96, UIPgDown = 97,
      UISelect = 98, UINavPrev = 99, UINavNext = 100, UIOK = 101, UICancel = 102,

      LastType = 103;
    /**
      Create a new event object and use the given eventstreamer
    */
    public Event() { super((Pointer)null); allocate(); }
    private native void allocate();
 
    /**
      Destructor
    */
    /**
      Get the value associated with the event of the specified type
    */
    public native @Cast("Int32") int get(@Cast("Event::Type") int type);

    /**
      Set the value associated with the event of the specified type
    */
    public native void set(@Cast("Event::Type") int type, @Cast("Int32") int value);

    /**
      Clears the event array (resets to initial state)
    */
    public native void clear();
}

// #endif


// Parsed from emucore/Random.hxx

//============================================================================
//
//   SSSS    tt          lll  lll
//  SS  SS   tt           ll   ll
//  SS     tttttt  eeee   ll   ll   aaaa
//   SSSS    tt   ee  ee  ll   ll      aa
//      SS   tt   eeeeee  ll   ll   aaaaa  --  "An Atari 2600 VCS Emulator"
//  SS  SS   tt   ee      ll   ll  aa  aa
//   SSSS     ttt  eeeee llll llll  aaaaa
//
// Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
//
// See the file "license" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.
//
// $Id: Random.hxx,v 1.4 2007/01/01 18:04:49 stephena Exp $
//============================================================================

// #ifndef RANDOM_HXX
// #define RANDOM_HXX

// #include "m6502/src/bspf/src/bspf.hxx"

/**
  This Random class uses a Mersenne Twister to provide pseudorandom numbers.
  The class itself is derived from the original 'Random' class by Bradford W. Mott.
*/
@NoOffset public static class Random extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Random(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Random(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public Random position(long position) {
        return (Random)super.position(position);
    }

    
    /**
      Class method which allows you to set the seed that'll be used
      for created new instances of this class
      <p>
      @param value The value to seed the random number generator with
    */
    public native void seed(@Cast("uInt32") int value);

    /**
      Create a new random number generator
    */
    public Random() { super((Pointer)null); allocate(); }
    private native void allocate();

    /**
      Answer the next random number from the random number generator
      <p>
      @return A random number
    */
    public native @Cast("uInt32") int next();

    /**
      Answer the next random number between 0 and 1 from the random number generator
      <p>
      @return A random number between 0 and 1
    */
    public native double nextDouble();

    // Returns a static Random object. DO NOT USE THIS. This is mostly meant for use by the
    // code for the various cartridges. 
    public static native @ByRef Random getInstance();

    /**
      Serializes the RNG state.
    */
    public native @Cast("bool") boolean saveState(@ByRef Serializer out);

    /** 
      Deserializes the RNG state.
    */
    public native @Cast("bool") boolean loadState(@ByRef Deserializer in);
}
// #endif



// Parsed from common/Constants.h

/* *****************************************************************************
 * A.L.E (Arcade Learning Environment)
 * Copyright (c) 2009-2013 by Yavar Naddaf, Joel Veness, Marc G. Bellemare and 
 *   the Reinforcement Learning and Artificial Intelligence Laboratory
 * Released under the GNU General Public License; see License.txt for details. 
 *
 * Based on: Stella  --  "An Atari 2600 VCS Emulator"
 * Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
 *
 * *****************************************************************************
 *  common_constants.h
 *
 *  Defines a set of constants used by various parts of the player agent code
 *
 **************************************************************************** */

// #ifndef __CONSTANTS_H__
// #define __CONSTANTS_H__

// #include <cassert>
// #include <vector>
// #include <valarray>
// #include <cstdlib>
// #include "../emucore/m6502/src/bspf/src/bspf.hxx"


// Define actions
/** enum Action */
public static final int
    PLAYER_A_NOOP           = 0,
    PLAYER_A_FIRE           = 1,
    PLAYER_A_UP             = 2,
    PLAYER_A_RIGHT          = 3,
    PLAYER_A_LEFT           = 4,
    PLAYER_A_DOWN           = 5,
    PLAYER_A_UPRIGHT        = 6,
    PLAYER_A_UPLEFT         = 7,
    PLAYER_A_DOWNRIGHT      = 8,
    PLAYER_A_DOWNLEFT       = 9,
    PLAYER_A_UPFIRE         = 10,
    PLAYER_A_RIGHTFIRE      = 11,
    PLAYER_A_LEFTFIRE       = 12,
    PLAYER_A_DOWNFIRE       = 13,
    PLAYER_A_UPRIGHTFIRE    = 14,
    PLAYER_A_UPLEFTFIRE     = 15,
    PLAYER_A_DOWNRIGHTFIRE  = 16,
    PLAYER_A_DOWNLEFTFIRE   = 17,
    PLAYER_B_NOOP           = 18,
    PLAYER_B_FIRE           = 19,
    PLAYER_B_UP             = 20,
    PLAYER_B_RIGHT          = 21,
    PLAYER_B_LEFT           = 22,
    PLAYER_B_DOWN           = 23,
    PLAYER_B_UPRIGHT        = 24,
    PLAYER_B_UPLEFT         = 25,
    PLAYER_B_DOWNRIGHT      = 26,
    PLAYER_B_DOWNLEFT       = 27,
    PLAYER_B_UPFIRE         = 28,
    PLAYER_B_RIGHTFIRE      = 29,
    PLAYER_B_LEFTFIRE       = 30,
    PLAYER_B_DOWNFIRE       = 31,
    PLAYER_B_UPRIGHTFIRE    = 32,
    PLAYER_B_UPLEFTFIRE     = 33,
    PLAYER_B_DOWNRIGHTFIRE  = 34,
    PLAYER_B_DOWNLEFTFIRE   = 35,
    RESET                   = 40, // MGB: Use SYSTEM_RESET to reset the environment. 
    UNDEFINED               = 41,
    RANDOM                  = 42,
    SAVE_STATE              = 43,
    LOAD_STATE              = 44,
    SYSTEM_RESET            = 45,
    LAST_ACTION_INDEX       = 50;

public static final int PLAYER_A_MAX = (18);
public static final int PLAYER_B_MAX = (36);

public static native @StdString BytePointer action_to_string(@Cast("Action") int a);

//  Define datatypes

// mode type

// difficulty type

// reward type for RL interface

// Other constant values
public static final int RAM_LENGTH = 128;

// #endif // __CONSTANTS_H__



// Parsed from common/Array.hxx

//============================================================================
//
//   SSSS    tt          lll  lll       
//  SS  SS   tt           ll   ll        
//  SS     tttttt  eeee   ll   ll   aaaa 
//   SSSS    tt   ee  ee  ll   ll      aa
//      SS   tt   eeeeee  ll   ll   aaaaa  --  "An Atari 2600 VCS Emulator"
//  SS  SS   tt   ee      ll   ll  aa  aa
//   SSSS     ttt  eeeee llll llll  aaaaa
//
// Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
//
// See the file "license" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.
//
// $Id: Array.hxx,v 1.4 2007/01/01 18:04:39 stephena Exp $
//
//   Based on code from ScummVM - Scumm Interpreter
//   Copyright (C) 2002-2004 The ScummVM project
//============================================================================

// #ifndef ARRAY_HXX
// #define ARRAY_HXX

// #include <assert.h>

// #include "../emucore/m6502/src/bspf/src/bspf.hxx"

@Name("Common::Array<Resolution>") @NoOffset public static class ResolutionList extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ResolutionList(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ResolutionList(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ResolutionList position(long position) {
        return (ResolutionList)super.position(position);
    }

    public ResolutionList() { super((Pointer)null); allocate(); }
    private native void allocate();
    public ResolutionList(@Const @ByRef ResolutionList array) { super((Pointer)null); allocate(array); }
    private native void allocate(@Const @ByRef ResolutionList array);

    public native void push_back(@Const @ByRef Resolution element);

    public native void push_back(@Const @ByRef ResolutionList array);

    public native void insert_at(int idx, @Const @ByRef Resolution element);

    public native @ByVal Resolution remove_at(int idx);

    // TODO: insert, remove, ...

    public native @ByRef @Name("operator []") Resolution get(int idx);

    public native @ByRef @Name("operator =") ResolutionList put(@Const @ByRef ResolutionList array);

    public native @Cast("unsigned int") int size();

    public native void clear();
    
    public native @Cast("bool") boolean isEmpty();

    public native @Cast("Common::Array<Resolution>::iterator") Resolution begin();

    public native @Cast("Common::Array<Resolution>::iterator") Resolution end();

    
}

  // Namespace GUI

// #endif


// Parsed from common/display_screen.h

/* *****************************************************************************
 * A.L.E (Arcade Learning Environment)
 * Copyright (c) 2009-2013 by Yavar Naddaf, Joel Veness, Marc G. Bellemare, 
 *   Matthew Hausknecht, and the Reinforcement Learning and Artificial Intelligence 
 *   Laboratory
 * Released under the GNU General Public License; see License.txt for details. 
 *
 * Based on: Stella  --  "An Atari 2600 VCS Emulator"
 * Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
 *
 * *****************************************************************************
 *  diplay_screen.cpp 
 *
 *  Supports displaying the screen via SDL. 
 **************************************************************************** */

// #ifndef DISPLAY_SCREEN_H
// #define DISPLAY_SCREEN_H

// #include <stdio.h>
// #include <stdlib.h>

// #include "Constants.h"
// #include "ColourPalette.hpp"
// #include "../emucore/MediaSrc.hxx"

// #ifdef __USE_SDL
// #include "SDL.h"

@NoOffset public static class DisplayScreen extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public DisplayScreen(Pointer p) { super(p); }

    public DisplayScreen(MediaSource mediaSource, Sound sound, @ByRef ColourPalette palette) { super((Pointer)null); allocate(mediaSource, sound, palette); }
    private native void allocate(MediaSource mediaSource, Sound sound, @ByRef ColourPalette palette);

    // Displays the current frame buffer from the mediasource.
    public native void display_screen();

    // Has the user engaged manual control mode?
    public native @Cast("bool") boolean manual_control_engaged();

    // Captures the keypress of a user in manual control mode.
    public native @Cast("Action") int getUserAction();
}
// #else
/** A dummy class that simply ignores display events. */

// Parsed from emucore/M6532.hxx

//============================================================================
//
//   SSSS    tt          lll  lll       
//  SS  SS   tt           ll   ll        
//  SS     tttttt  eeee   ll   ll   aaaa 
//   SSSS    tt   ee  ee  ll   ll      aa
//      SS   tt   eeeeee  ll   ll   aaaaa  --  "An Atari 2600 VCS Emulator"
//  SS  SS   tt   ee      ll   ll  aa  aa
//   SSSS     ttt  eeeee llll llll  aaaaa
//
// Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
//
// See the file "license" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.
//
// $Id: M6532.hxx,v 1.5 2007/01/01 18:04:48 stephena Exp $
//============================================================================

// #ifndef M6532_HXX
// #define M6532_HXX

// #include "m6502/src/bspf/src/bspf.hxx"
// #include "m6502/src/Device.hxx"
// #include "Random.hxx"

/**
  RIOT
  <p>
  @author  Bradford W. Mott
  @version $Id: M6532.hxx,v 1.5 2007/01/01 18:04:48 stephena Exp $
*/
@NoOffset public static class M6532 extends Device {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public M6532(Pointer p) { super(p); }

    /**
      Create a new 6532 for the specified console
      <p>
      @param console The console the 6532 is associated with
    */
    public M6532(@Const @ByRef Console console) { super((Pointer)null); allocate(console); }
    private native void allocate(@Const @ByRef Console console);
    
    /**
      Destructor
    */
    /**
      Get a null terminated string which is the device's name (i.e. "M6532")
      <p>
      @return The name of the device
    */
    public native @Cast("const char*") BytePointer name();

    /**
      Reset cartridge to its power-on state
    */
    public native void reset();

    /**
      Notification method invoked by the system right before the
      system resets its cycle counter to zero.  It may be necessary
      to override this method for devices that remember cycle counts.
    */
    public native void systemCyclesReset();

    /**
      Install 6532 in the specified system.  Invoked by the system
      when the 6532 is attached to it.
      <p>
      @param system The system the device should install itself in
    */
    public native void install(@ByRef System system);

    /**
      Saves the current state of this device to the given Serializer.
      <p>
      @param out The serializer device to save to.
      @return The result of the save.  True on success, false on failure.
    */
    public native @Cast("bool") boolean save(@ByRef Serializer out);

    /**
      Loads the current state of this device from the given Deserializer.
      <p>
      @param in The deserializer device to load from.
      @return The result of the load.  True on success, false on failure.
    */
    public native @Cast("bool") boolean load(@ByRef Deserializer in);
    /**
      Get the byte at the specified address
      <p>
      @return The byte at the specified address
    */
    public native @Cast("uInt8") byte peek(@Cast("uInt16") short address);

    /**
      Change the byte at the specified address to the given value
      <p>
      @param address The address where the value should be stored
      @param value The value to be stored at the address
    */
    public native void poke(@Cast("uInt16") short address, @Cast("uInt8") byte value);
}
// #endif



// Parsed from emucore/Cart.hxx

//============================================================================
//
//   SSSS    tt          lll  lll       
//  SS  SS   tt           ll   ll        
//  SS     tttttt  eeee   ll   ll   aaaa 
//   SSSS    tt   ee  ee  ll   ll      aa
//      SS   tt   eeeeee  ll   ll   aaaaa  --  "An Atari 2600 VCS Emulator"
//  SS  SS   tt   ee      ll   ll  aa  aa
//   SSSS     ttt  eeeee llll llll  aaaaa
//
// Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
//
// See the file "license" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.
//
// $Id: Cart.hxx,v 1.19 2007/06/14 13:47:50 stephena Exp $
//============================================================================

// #ifndef CARTRIDGE_HXX
// #define CARTRIDGE_HXX
@Opaque public static class Properties extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Properties() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Properties(Pointer p) { super(p); }
}

// #include <fstream>
// #include "m6502/src/bspf/src/bspf.hxx"
// #include "m6502/src/Device.hxx"
// #include "../common/Log.hpp"

/**
  A cartridge is a device which contains the machine code for a 
  game and handles any bankswitching performed by the cartridge.
 
  @author  Bradford W. Mott
  @version $Id: Cart.hxx,v 1.19 2007/06/14 13:47:50 stephena Exp $
*/
@NoOffset public static class Cartridge extends Device {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Cartridge(Pointer p) { super(p); }

    /**
      Create a new cartridge object allocated on the heap.  The
      type of cartridge created depends on the properties object.
      <p>
      @param image    A pointer to the ROM image
      @param size     The size of the ROM image 
      @param props    The properties associated with the game
      @param settings The settings associated with the system
      @return   Pointer to the new cartridge object allocated on the heap
    */
    public static native Cartridge create(@Cast("const uInt8*") BytePointer image, @Cast("uInt32") int size, 
            @Const @ByRef Properties props, @Const @ByRef Settings settings);
    public static native Cartridge create(@Cast("const uInt8*") ByteBuffer image, @Cast("uInt32") int size, 
            @Const @ByRef Properties props, @Const @ByRef Settings settings);
    public static native Cartridge create(@Cast("const uInt8*") byte[] image, @Cast("uInt32") int size, 
            @Const @ByRef Properties props, @Const @ByRef Settings settings);

    /**
      Create a new cartridge
    */
 
    /**
      Destructor
    */

    /**
      Query some information about this cartridge.
    */
    public static native @StdString BytePointer about();

    /**
      Save the internal (patched) ROM image.
      <p>
      @param out  The output file stream to save the image
    */
    public native @Cast("bool") boolean save(@Cast("std::ofstream*") @ByRef Pointer out);

    /** MGB: Added to drop warning on overloaded save() method. */  
    public native @Cast("bool") boolean save(@ByRef Serializer out); 

    /**
      Lock/unlock bankswitching capability.
    */
    public native void lockBank();
    public native void unlockBank();
    //////////////////////////////////////////////////////////////////////
    // The following methods are cart-specific and must be implemented
    // in derived classes.
    //////////////////////////////////////////////////////////////////////
    /**
      Set the specified bank.
    */
    public native void bank(@Cast("uInt16") short bank);

    /**
      Get the current bank.
      <p>
      @return  The current bank, or -1 if bankswitching not supported
    */
    public native int bank();

    /**
      Query the number of banks supported by the cartridge.
    */
    public native int bankCount();

    /**
      Patch the cartridge ROM.
      <p>
      @param address  The ROM address to patch
      @param value    The value to place into the address
      @return    Success or failure of the patch operation
    */
    public native @Cast("bool") boolean patch(@Cast("uInt16") short address, @Cast("uInt8") byte value);

    /**
      Access the internal ROM image for this cartridge.
      <p>
      @param size  Set to the size of the internal ROM image data
      @return  A pointer to the internal ROM image data
    */
    public native @Cast("uInt8*") BytePointer getImage(@ByRef IntPointer size);
    public native @Cast("uInt8*") ByteBuffer getImage(@ByRef IntBuffer size);
    public native @Cast("uInt8*") byte[] getImage(@ByRef int[] size);
}

// #endif


// Parsed from emucore/Console.hxx

//============================================================================
//
//   SSSS    tt          lll  lll       
//  SS  SS   tt           ll   ll        
//  SS     tttttt  eeee   ll   ll   aaaa 
//   SSSS    tt   ee  ee  ll   ll      aa
//      SS   tt   eeeeee  ll   ll   aaaaa  --  "An Atari 2600 VCS Emulator"
//  SS  SS   tt   ee      ll   ll  aa  aa
//   SSSS     ttt  eeeee llll llll  aaaaa
//
// Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
//
// See the file "license" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.
//
// $Id: Console.hxx,v 1.61 2007/07/27 13:49:16 stephena Exp $
//============================================================================

// #ifndef CONSOLE_HXX
// #define CONSOLE_HXX
@Opaque public static class MediaSource extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public MediaSource() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public MediaSource(Pointer p) { super(p); }
}
@Opaque public static class Switches extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Switches() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Switches(Pointer p) { super(p); }
}

// #include "m6502/src/bspf/src/bspf.hxx"
// #include "Control.hxx"
// #include "Props.hxx"
// #include "TIA.hxx"
// #include "Cart.hxx"
// #include "M6532.hxx"
// #include "AtariVox.hxx"

/**
  This class represents the entire game console.
  <p>
  @author  Bradford W. Mott
  @version $Id: Console.hxx,v 1.61 2007/07/27 13:49:16 stephena Exp $
*/
@NoOffset public static class Console extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Console(Pointer p) { super(p); }

    /**
      Create a new console for emulating the specified game using the
      given game image and operating system.
      <p>
      @param osystem  The OSystem object to use
      @param cart     The cartridge to use with this console
      @param props    The properties for the cartridge  
    */
    public Console(OSystem osystem, Cartridge cart, @Const @ByRef Properties props) { super((Pointer)null); allocate(osystem, cart, props); }
    private native void allocate(OSystem osystem, Cartridge cart, @Const @ByRef Properties props);

    /**
      Create a new console object by copying another one
      <p>
      @param console The object to copy
    */
    public Console(@Const @ByRef Console console) { super((Pointer)null); allocate(console); }
    private native void allocate(@Const @ByRef Console console);
 
    /**
      Destructor
    */
    /**
      Get the controller plugged into the specified jack
      <p>
      @return The specified controller
    */
    public native @ByRef Controller controller(@Cast("Controller::Jack") int jack);

    /**
      Get the MediaSource for this console
      <p>
      @return The mediasource
    */
    public native @ByRef MediaSource mediaSource();

    /**
      Get the properties being used by the game
      <p>
      @return The properties being used by the game
    */
    public native @Const @ByRef Properties properties();

    /**
      Get the console switches
      <p>
      @return The console switches
    */
    public native @ByRef Switches switches();

    /**
      Get the 6502 based system used by the console to emulate the game
      <p>
      @return The 6502 based system
    */
    public native @ByRef System system();

    /**
      Returns the OSystem for this emulator.
      
      @return The OSystem. 
    */
    public native @ByRef OSystem osystem();

    /**
      Get the cartridge used by the console which contains the ROM code
      <p>
      @return The cartridge for this console
    */
    public native @ByRef Cartridge cartridge();

    /**
      Get the 6532 used by the console
      <p>
      @return The 6532 for this console
    */
    public native @ByRef M6532 riot();

    /**
      Set the properties to those given
      <p>
      @param The properties to use for the current game
    */
    public native void setProperties(@Const @ByRef Properties props);

    /**
      Query some information about this console.
    */
    public native @StdString BytePointer about();
    /**
      Overloaded assignment operator
      <p>
      @param console The console object to set myself equal to
      @return Myself after assignment has taken place
    */
    public native @ByRef @Name("operator =") Console put(@Const @ByRef Console console);
    /**
      Toggle between NTSC/PAL/PAL60 display format.
    */
    public native void toggleFormat();

    /**
      Query the currently selected display format (NTSC/PAL/PAL60).
    */
    public native @StdString BytePointer getFormat();

    /**
      Toggle between the available palettes.
    */
    public native void togglePalette();

    /**
      Toggles phosphor effect.
    */
    public native void togglePhosphor();

    /**
      Initialize the video subsystem wrt this class.
      This is required for changing window size, title, etc.
      <p>
      @param full  Whether we want a full initialization,
                   or only reset certain attributes.
    */
    public native void initializeVideo(@Cast("bool") boolean full/*=true*/);
    public native void initializeVideo();

    /**
      Initialize the audio subsystem wrt this class.
      This is required any time the sound settings change.
    */
    public native void initializeAudio();

    /**
      "Fry" the Atari (mangle memory/TIA contents)
    */
    public native void fry();

    /**
      Change the "Display.YStart" variable.
      <p>
      @param direction +1 indicates increase, -1 indicates decrease.
    */
    public native void changeYStart(int direction);

    /**
      Change the "Display.Height" variable.
      <p>
      @param direction +1 indicates increase, -1 indicates decrease.
    */
    public native void changeHeight(int direction);

    /**
      Toggles the TIA bit specified in the method name.
    */
    public native void toggleP0Bit();
    public native void toggleP1Bit();
    public native void toggleM0Bit();
    public native void toggleM1Bit();
    public native void toggleBLBit();
    public native void togglePFBit();
    public native void enableBits(@Cast("bool") boolean enable);

// #ifdef ATARIVOX_SUPPORT

}

// #endif


// Parsed from emucore/Sound.hxx

//============================================================================
//
//   SSSS    tt          lll  lll       
//  SS  SS   tt           ll   ll        
//  SS     tttttt  eeee   ll   ll   aaaa 
//   SSSS    tt   ee  ee  ll   ll      aa
//      SS   tt   eeeeee  ll   ll   aaaaa  --  "An Atari 2600 VCS Emulator"
//  SS  SS   tt   ee      ll   ll  aa  aa
//   SSSS     ttt  eeeee llll llll  aaaaa
//
// Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
//
// See the file "license" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.
//
// $Id: Sound.hxx,v 1.23 2007/01/01 18:04:50 stephena Exp $
//============================================================================

// #ifndef SOUND_HXX
// #define SOUND_HXX

// #include "m6502/src/bspf/src/bspf.hxx"

/**
  This class is an abstract base class for the various sound objects.
  It has no functionality whatsoever.
  <p>
  @author Stephen Anthony
  @version $Id: Sound.hxx,v 1.23 2007/01/01 18:04:50 stephena Exp $
*/
@NoOffset public static class Sound extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Sound(Pointer p) { super(p); }

    /**
      Create a new sound object.  The init method must be invoked before
      using the object.
    */

    /**
      Destructor
    */ 
    /**
      Enables/disables the sound subsystem.
      <p>
      @param enable  Either true or false, to enable or disable the sound system
    */
    public native void setEnabled(@Cast("bool") boolean enable);

    /**
      The system cycle counter is being adjusting by the specified amount.  Any
      members using the system cycle counter should be adjusted as needed.
      <p>
      @param amount The amount the cycle counter is being adjusted by
    */
    public native void adjustCycleCounter(@Cast("Int32") int amount);

    /**
      Sets the number of channels (mono or stereo sound).
      <p>
      @param channels The number of channels
    */
    public native void setChannels(@Cast("uInt32") int channels);

    /**
      Sets the display framerate.  Sound generation for NTSC and PAL games
      depends on the framerate, so we need to set it here.
      <p>
      @param framerate The base framerate depending on NTSC or PAL ROM
    */
    public native void setFrameRate(@Cast("uInt32") int framerate);

    /**
      Initializes the sound device.  This must be called before any
      calls are made to derived methods.
    */
    public native void initialize();

    /**
      Should be called to close the sound device.  Once called the sound
      device can be started again using the initialize method.
    */
    public native @Name("close") void _close();

    /**
      Return true iff the sound device was successfully initialized.
      <p>
      @return true iff the sound device was successfully initialized.
    */
    public native @Cast("bool") boolean isSuccessfullyInitialized();

    /**
      Set the mute state of the sound object.  While muted no sound is played.
      <p>
      @param state Mutes sound if true, unmute if false
    */
    public native void mute(@Cast("bool") boolean state);

    /**
      Reset the sound device.
    */
    public native void reset();

    /**
      Sets the sound register to a given value.
      <p>
      @param addr  The register address
      @param value The value to save into the register
      @param cycle The system cycle at which the register is being updated
    */
    public native void set(@Cast("uInt16") short addr, @Cast("uInt8") byte value, @Cast("Int32") int cycle);

    /**
      Sets the volume of the sound device to the specified level.  The
      volume is given as a percentage from 0 to 100.  Values outside
      this range indicate that the volume shouldn't be changed at all.
      <p>
      @param percent The new volume percentage level for the sound device
    */
    public native void setVolume(@Cast("Int32") int percent);

    /**
      Adjusts the volume of the sound device based on the given direction.
      <p>
      @param direction  Increase or decrease the current volume by a predefined
                        amount based on the direction (1 = increase, -1 =decrease)
    */
    public native void adjustVolume(@Cast("Int8") byte direction);

    /**
      * Tells the sound engine to record one frame's worth of sound.
      */
    public native void recordNextFrame();
    /**
      Loads the current state of this device from the given Deserializer.
      <p>
      @param in The deserializer device to load from.
      @return The result of the load.  True on success, false on failure.
    */
    public native @Cast("bool") boolean load(@ByRef Deserializer in);

    /**
      Saves the current state of this device to the given Serializer.
      <p>
      @param out The serializer device to save to.
      @return The result of the save.  True on success, false on failure.
    */
    public native @Cast("bool") boolean save(@ByRef Serializer out);
}

// #endif


// Parsed from emucore/Settings.hxx

//============================================================================
//
//   SSSS    tt          lll  lll       
//  SS  SS   tt           ll   ll        
//  SS     tttttt  eeee   ll   ll   aaaa 
//   SSSS    tt   ee  ee  ll   ll      aa
//      SS   tt   eeeeee  ll   ll   aaaaa  --  "An Atari 2600 VCS Emulator"
//  SS  SS   tt   ee      ll   ll  aa  aa
//   SSSS     ttt  eeeee llll llll  aaaaa
//
// Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
//
// See the file "license" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.
//
// $Id: Settings.hxx,v 1.33 2007/07/27 13:49:16 stephena Exp $
//============================================================================

// #ifndef SETTINGS_HXX
// #define SETTINGS_HXX

// #include <map>
// #include <stdexcept>

// #include "../common/Array.hxx"
// #include "m6502/src/bspf/src/bspf.hxx"

/**
  This class provides an interface for accessing frontend specific settings.
  <p>
  @author  Stephen Anthony
  @version $Id: Settings.hxx,v 1.33 2007/07/27 13:49:16 stephena Exp $
*/
@NoOffset public static class Settings extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Settings(Pointer p) { super(p); }

    /**
      Create a new settings abstract class
    */
    public Settings(OSystem osystem) { super((Pointer)null); allocate(osystem); }
    private native void allocate(OSystem osystem);

    /**
      Destructor
    */
    /**
      This method should be called to load the current settings from an rc file.
    */
    public native void loadConfig();
    
    /**
      This method loads the given 
    */
    public native void loadConfig(@Cast("const char*") BytePointer config_file);
    public native void loadConfig(String config_file);

    /**
      This method should be called to save the current settings to an rc file.
    */
    public native void saveConfig();

    /**
      This method should be called to load the arguments from the commandline.
      <p>
      @return Name of the ROM to load, otherwise empty string
    */
    public native @StdString BytePointer loadCommandLine(int argc, @Cast("char**") PointerPointer argv);
    public native @StdString BytePointer loadCommandLine(int argc, @Cast("char**") @ByPtrPtr BytePointer argv);
    public native @StdString String loadCommandLine(int argc, @Cast("char**") @ByPtrPtr ByteBuffer argv);
    public native @StdString BytePointer loadCommandLine(int argc, @Cast("char**") @ByPtrPtr byte[] argv);

    /**
      This method should be called *after* settings have been read,
      to validate (and change, if necessary) any improper settings.
    */
    public native void validate();

    /**
      This method should be called to display usage information.
    */
    public native void usage();

    /**
      Get the value assigned to the specified key.  If the key does
      not exist then -1 is returned.
      <p>
      @param key The key of the setting to lookup
      @return The integer value of the setting
    */
    public native int getInt(@StdString BytePointer key, @Cast("bool") boolean strict/*=false*/);
    public native int getInt(@StdString BytePointer key);
    public native int getInt(@StdString String key, @Cast("bool") boolean strict/*=false*/);
    public native int getInt(@StdString String key);

    /**
      Get the value assigned to the specified key.  If the key does
      not exist then -1.0 is returned.
      <p>
      @param key The key of the setting to lookup
      @return The floating point value of the setting
    */
    public native float getFloat(@StdString BytePointer key, @Cast("bool") boolean strict/*=false*/);
    public native float getFloat(@StdString BytePointer key);
    public native float getFloat(@StdString String key, @Cast("bool") boolean strict/*=false*/);
    public native float getFloat(@StdString String key);

    /**
      Get the value assigned to the specified key.  If the key does
      not exist then false is returned.
      <p>
      @param key The key of the setting to lookup
      @return The boolean value of the setting
    */
    public native @Cast("bool") boolean getBool(@StdString BytePointer key, @Cast("bool") boolean strict/*=false*/);
    public native @Cast("bool") boolean getBool(@StdString BytePointer key);
    public native @Cast("bool") boolean getBool(@StdString String key, @Cast("bool") boolean strict/*=false*/);
    public native @Cast("bool") boolean getBool(@StdString String key);

    /**
      Get the value assigned to the specified key.  If the key does
      not exist then the empty string is returned.
      <p>
      @param key The key of the setting to lookup
      @return The string value of the setting
    */
    public native @StdString BytePointer getString(@StdString BytePointer key, @Cast("bool") boolean strict/*=false*/);
    public native @StdString BytePointer getString(@StdString BytePointer key);
    public native @StdString String getString(@StdString String key, @Cast("bool") boolean strict/*=false*/);
    public native @StdString String getString(@StdString String key);

    /**
      Get the x*y size assigned to the specified key.  If the key does
      not exist (or is invalid) then results are -1 for each item.
      <p>
      @param key The key of the setting to lookup
      @return The x and y values encoded in the key
    */
    public native void getSize(@StdString BytePointer key, @ByRef IntPointer x, @ByRef IntPointer y);
    public native void getSize(@StdString String key, @ByRef IntBuffer x, @ByRef IntBuffer y);
    public native void getSize(@StdString BytePointer key, @ByRef int[] x, @ByRef int[] y);
    public native void getSize(@StdString String key, @ByRef IntPointer x, @ByRef IntPointer y);
    public native void getSize(@StdString BytePointer key, @ByRef IntBuffer x, @ByRef IntBuffer y);
    public native void getSize(@StdString String key, @ByRef int[] x, @ByRef int[] y);

    /**
      Set the value associated with key to the given value.
      <p>
      @param key   The key of the setting
      @param value The value to assign to the setting
    */
    public native void setInt(@StdString BytePointer key, int value);
    public native void setInt(@StdString String key, int value);

    /**
      Set the value associated with key to the given value.
      <p>
      @param key   The key of the setting
      @param value The value to assign to the setting
    */
    public native void setFloat(@StdString BytePointer key, float value);
    public native void setFloat(@StdString String key, float value);

    /**
      Set the value associated with key to the given value.
      <p>
      @param key   The key of the setting
      @param value The value to assign to the setting
    */
    public native void setBool(@StdString BytePointer key, @Cast("const bool") boolean value);
    public native void setBool(@StdString String key, @Cast("const bool") boolean value);

    /**
      Set the value associated with key to the given value.
      <p>
      @param key   The key of the setting
      @param value The value to assign to the setting
    */
    public native void setString(@StdString BytePointer key, @StdString BytePointer value);
    public native void setString(@StdString String key, @StdString String value);

    /**
      Set the value associated with key to the given value.
      <p>
      @param key   The key of the setting
      @param value The value to assign to the setting
    */
    public native void setSize(@StdString BytePointer key, int value1, int value2);
    public native void setSize(@StdString String key, int value1, int value2);
}

// #endif


// Parsed from emucore/OSystem.hxx

//============================================================================
//
//   SSSS    tt          lll  lll       
//  SS  SS   tt           ll   ll        
//  SS     tttttt  eeee   ll   ll   aaaa 
//   SSSS    tt   ee  ee  ll   ll      aa
//      SS   tt   eeeeee  ll   ll   aaaaa  --  "An Atari 2600 VCS Emulator"
//  SS  SS   tt   ee      ll   ll  aa  aa
//   SSSS     ttt  eeeee llll llll  aaaaa
//
// Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
//
// See the file "license" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.
//
// $Id: OSystem.hxx,v 1.55 2007/08/12 23:05:12 stephena Exp $
//============================================================================

// #ifndef OSYSTEM_HXX
// #define OSYSTEM_HXX

@Opaque public static class PropertiesSet extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public PropertiesSet() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PropertiesSet(Pointer p) { super(p); }
}
@Opaque public static class GameController extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public GameController() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public GameController(Pointer p) { super(p); }
}
@Opaque public static class Menu extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Menu() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Menu(Pointer p) { super(p); }
}
@Opaque public static class CommandMenu extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public CommandMenu() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CommandMenu(Pointer p) { super(p); }
}
@Opaque public static class Launcher extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Launcher() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Launcher(Pointer p) { super(p); }
}
@Opaque public static class Debugger extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public Debugger() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Debugger(Pointer p) { super(p); }
}
@Opaque public static class CheatManager extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public CheatManager() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CheatManager(Pointer p) { super(p); }
}
@Opaque public static class VideoDialog extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public VideoDialog() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VideoDialog(Pointer p) { super(p); }
}
// #include "../common/Array.hxx"
//ALE  #include "EventHandler.hxx"
//ALE  #include "FrameBuffer.hxx"
// #include "Sound.hxx"
// #include "../common/SoundNull.hxx"
// #include "Settings.hxx"
// #include "Console.hxx"
// #include "Event.hxx"  //ALE 
//ALE  #include "Font.hxx"
// #include "m6502/src/bspf/src/bspf.hxx"
// #include "../common/display_screen.h" 
// #include "../common/ColourPalette.hpp"
// #include "../common/ScreenExporter.hpp"
// #include "../common/Log.hpp"

public static class Resolution extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public Resolution() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Resolution(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Resolution(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public Resolution position(long position) {
        return (Resolution)super.position(position);
    }

  public native @Cast("uInt32") int width(); public native Resolution width(int width);
  public native @Cast("uInt32") int height(); public native Resolution height(int height);
  public native @StdString BytePointer name(); public native Resolution name(BytePointer name);
}

/**
  This class provides an interface for accessing operating system specific
  functions.  It also comprises an overall parent object, to which all the
  other objects belong.
  <p>
  @author  Stephen Anthony
  @version $Id: OSystem.hxx,v 1.55 2007/08/12 23:05:12 stephena Exp $
*/
@NoOffset public static class OSystem extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public OSystem(Pointer p) { super(p); }

    /**
      Create a new OSystem abstract class
    */

    /**
      Destructor
    */

    /**
      Create all child objects which belong to this OSystem
    */
    public native @Cast("bool") boolean create();
    /**
      Adds the specified settings object to the system.
      <p>
      @param settings The settings object to add 
    */
    public native void attach(Settings settings);

    /**
      Get the event handler of the system
      <p>
      @return The event handler
    */
    //ALE  inline EventHandler& eventHandler() const { return *myEventHandler; }

    /**  //ALE 
      Get the event object of the system  
      <p>
      @return The event object
    */
    public native Event event();

    /**
      Get the frame buffer of the system
      <p>
      @return The frame buffer
    */
    //ALE  inline FrameBuffer& frameBuffer() const { return *myFrameBuffer; }

    /**
      Get the sound object of the system
      <p>
      @return The sound object
    */
    public native @ByRef Sound sound();

    /**
      Get the settings object of the system
      <p>
      @return The settings object
    */
    public native @ByRef Settings settings();

    /**
      Get the set of game properties for the system
      <p>
      @return The properties set object
    */
    public native @ByRef PropertiesSet propSet();

    /**
      Get the console of the system.
      <p>
      @return The console object
    */
    public native @ByRef Console console();

    /**
      Get the settings menu of the system.
      <p>
      @return The settings menu object
    */
    //ALE  inline Menu& menu(void) const { return *myMenu; }

    /**
      Get the command menu of the system.
      <p>
      @return The command menu object
    */
    //ALE  inline CommandMenu& commandMenu(void) const { return *myCommandMenu; }

    /**
      Get the ROM launcher of the system.
      <p>
      @return The launcher object
    */
    //ALE  inline Launcher& launcher(void) const { return *myLauncher; }

// #ifdef DEBUGGER_SUPPORT
// #endif

// #ifdef CHEATCODE_SUPPORT
// #endif

    /**
      Get the font object of the system
      <p>
      @return The font reference
    */
    //ALE  inline const GUI::Font& font() const { return *myFont; }

    /**
      Get the launcher font object of the system
      <p>
      @return The font reference
    */
    //ALE  inline const GUI::Font& launcherFont() const { return *myLauncherFont; }

    /**
      Get the console font object of the system
      <p>
      @return The console font reference
    */
    //ALE  inline const GUI::Font& consoleFont() const { return *myConsoleFont; }

    /**
      Set the framerate for the video system.  It's placed in this class since
      the mainLoop() method is defined here.
      <p>
      @param framerate  The video framerate to use
    */
    public native void setFramerate(@Cast("uInt32") int framerate);

    /**
      Set all config file paths for the OSystem.
    */
    public native void setConfigPaths();

    /**
      Set the user-interface palette which is specified in current settings.
    */
    //ALE  void setUIPalette();

    /**
      Get the current framerate for the video system.
      <p>
      @return  The video framerate currently in use
    */
    public native @Cast("uInt32") int frameRate();

    /**
      Get the maximum dimensions of a window for the video hardware.
    */
    public native @Cast("uInt32") int desktopWidth();
    public native @Cast("uInt32") int desktopHeight();

    /**
      Get the supported fullscreen resolutions for the video hardware.
      <p>
      @return  An array of supported resolutions
    */
    public native @Const @ByRef ResolutionList supportedResolutions();

    /**
      Return the default directory for storing data.
    */
    public native @StdString BytePointer baseDir();

    /**
      This method should be called to get the full path of the gamelist
      cache file (used by the Launcher to show a listing of available games).
      <p>
      @return String representing the full path of the gamelist cache file.
    */
    public native @StdString BytePointer cacheFile();

    /**
      This method should be called to get the full path of the cheat file.
      <p>
      @return String representing the full path of the cheat filename.
    */
    public native @StdString BytePointer cheatFile();

    /**
      This method should be called to get the full path of the config file.
      <p>
      @return String representing the full path of the config filename.
    */
    public native @StdString BytePointer configFile();

    /**
      This method should be called to get the full path of the
      (optional) palette file.
      <p>
      @return String representing the full path of the properties filename.
    */
    public native @StdString BytePointer paletteFile();

    /**
      This method should be called to get the full path of the
      properties file (stella.pro).
      <p>
      @return String representing the full path of the properties filename.
    */
    public native @StdString BytePointer propertiesFile();

    /**
      This method should be called to get the full path of the currently
      loaded ROM.
      <p>
      @return String representing the full path of the ROM file.
    */
    public native @StdString BytePointer romFile();

    /**
      Switches between software and OpenGL framebuffer modes.
    */
    //ALE  void toggleFrameBuffer();

    /**
      Creates a new game console from the specified romfile.
      <p>
      @param romfile  The full pathname of the ROM to use
      @return  True on successful creation, otherwise false
    */
    public native @Cast("bool") boolean createConsole(@StdString BytePointer romfile/*=""*/);
    public native @Cast("bool") boolean createConsole();
    public native @Cast("bool") boolean createConsole(@StdString String romfile/*=""*/);

    /**
      Deletes the currently defined console, if it exists.
      Also prints some statistics (fps, total frames, etc).
    */
    public native void deleteConsole();

    /**
      Creates a new ROM launcher, to select a new ROM to emulate.
    */
    //ALE  void createLauncher();

    /**
      Gets all possible info about the ROM by creating a temporary
      Console object and querying it.
      <p>
      @param romfile  The full pathname of the ROM to use
      @return  Some information about this ROM
    */
    public native @StdString BytePointer getROMInfo(@StdString BytePointer romfile);
    public native @StdString String getROMInfo(@StdString String romfile);

    /**
      The features which are conditionally compiled into Stella.
      <p>
      @return  The supported features
    */
    public native @StdString BytePointer features();

    /**
      Open the given ROM and return an array containing its contents.
      <p>
      @param rom    The absolute pathname of the ROM file
      @param md5    The md5 calculated from the ROM file
      @param image  A pointer to store the ROM data
                    Note, the calling method is responsible for deleting this
      @param size   The amount of data read into the image array
      @return  False on any errors, else true
    */
    public native @Cast("bool") boolean openROM(@StdString BytePointer rom, @StdString @ByRef BytePointer md5, @Cast("uInt8**") PointerPointer image, IntPointer size);
    public native @Cast("bool") boolean openROM(@StdString BytePointer rom, @StdString @ByRef BytePointer md5, @Cast("uInt8**") @ByPtrPtr BytePointer image, IntPointer size);
    public native @Cast("bool") boolean openROM(@StdString String rom, @StdString @ByRef BytePointer md5, @Cast("uInt8**") @ByPtrPtr ByteBuffer image, IntBuffer size);
    public native @Cast("bool") boolean openROM(@StdString BytePointer rom, @StdString @ByRef BytePointer md5, @Cast("uInt8**") @ByPtrPtr byte[] image, int[] size);
    public native @Cast("bool") boolean openROM(@StdString String rom, @StdString @ByRef BytePointer md5, @Cast("uInt8**") @ByPtrPtr BytePointer image, IntPointer size);
    public native @Cast("bool") boolean openROM(@StdString BytePointer rom, @StdString @ByRef BytePointer md5, @Cast("uInt8**") @ByPtrPtr ByteBuffer image, IntBuffer size);
    public native @Cast("bool") boolean openROM(@StdString String rom, @StdString @ByRef BytePointer md5, @Cast("uInt8**") @ByPtrPtr byte[] image, int[] size);

    /**
      Issue a quit event to the OSystem.
    */
    public native void quit();

    public native void skipEmulation();

    /**
      Returns the random number generator for this emulator.
    */
    public native @ByRef Random rng();

    /**
      Resets the seed for our random number generator.
    */
    public native void resetRNGSeed();

    /** 
      Serializes the OSystem state.
    */
    public native @Cast("bool") boolean saveState(@ByRef Serializer out);

    /** 
      Deserializes the OSystem state.
    */
    public native @Cast("bool") boolean loadState(@ByRef Deserializer in);
    //////////////////////////////////////////////////////////////////////
    // The following methods are system-specific and must be implemented
    // in derived classes.
    //////////////////////////////////////////////////////////////////////
    /**
      This method returns number of ticks in microseconds.
      <p>
      @return Current time in microseconds.
    */
    public native @Cast("uInt32") int getTicks(); //ALE 
    // Time per frame for a video update, based on the current framerate
    public native @Cast("uInt32") int myTimePerFrame(); public native OSystem myTimePerFrame(int myTimePerFrame);

    // Indicates whether the main processing loop should proceed
    public static class TimingInfo extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public TimingInfo() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public TimingInfo(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public TimingInfo(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public TimingInfo position(long position) {
            return (TimingInfo)super.position(position);
        }
    
      public native @Cast("uInt32") int start(); public native TimingInfo start(int start);
      public native @Cast("uInt32") int current(); public native TimingInfo current(int current);
      public native @Cast("uInt32") int virt(); public native TimingInfo virt(int virt);
      public native @Cast("uInt32") int totalTime(); public native TimingInfo totalTime(int totalTime);
      public native @Cast("uInt32") int totalFrames(); public native TimingInfo totalFrames(int totalFrames);
    }
    public native @ByRef TimingInfo myTimingInfo(); public native OSystem myTimingInfo(TimingInfo myTimingInfo);

    public native @ByRef ColourPalette colourPalette();
    public native DisplayScreen p_display_screen(); public native OSystem p_display_screen(DisplayScreen p_display_screen);
}

// #endif


// Parsed from common/ColourPalette.hpp

/* *****************************************************************************
 * A.L.E (Arcade Learning Environment)
 * Copyright (c) 2009-2013 by Yavar Naddaf, Joel Veness, Marc G. Bellemare and 
 *   the Reinforcement Learning and Artificial Intelligence Laboratory
 * Released under the GNU General Public License; see License.txt for details. 
 *
 * Based on: Stella  --  "An Atari 2600 VCS Emulator"
 * Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
 *
 * *****************************************************************************
 *  ColourPalette.hpp 
 *
 *  Enables conversion from NTSC/SECAM/PAL to RGB via the OSystem's palette.
 **************************************************************************** */

// #ifndef __COLOUR_PALETTE_HPP__
// #define __COLOUR_PALETTE_HPP__ 

// #include <vector>
// #include <string>
// Include obscure header file for uInt32 definition
// #include "../emucore/m6502/src/bspf/src/bspf.hxx"

@NoOffset public static class ColourPalette extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ColourPalette(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ColourPalette(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ColourPalette position(long position) {
        return (ColourPalette)super.position(position);
    }


        public ColourPalette() { super((Pointer)null); allocate(); }
        private native void allocate();

        /** Converts a given palette value in range [0, 255] into its RGB components. */ 
        public native void getRGB(int val, @ByRef IntPointer r, @ByRef IntPointer g, @ByRef IntPointer b);
        public native void getRGB(int val, @ByRef IntBuffer r, @ByRef IntBuffer g, @ByRef IntBuffer b);
        public native void getRGB(int val, @ByRef int[] r, @ByRef int[] g, @ByRef int[] b); 
        
        /** Converts a given palette value into packed RGB (format 0x00RRGGBB). */
        public native @Cast("uInt32") int getRGB(int val);

        /** Returns the byte-sized grayscale value for this palette index. */ 
        public native @Cast("uInt8") byte getGrayscale(int val); 

        /**
            Applies the current RGB palette to the src_buffer and returns the results in dst_buffer
            For each byte in src_buffer, three bytes are returned in dst_buffer
            8 bits => 24 bits
         */
        public native void applyPaletteRGB(@Cast("uInt8*") BytePointer dst_buffer, @Cast("uInt8*") BytePointer src_buffer, @Cast("size_t") long src_size);
        public native void applyPaletteRGB(@Cast("uInt8*") ByteBuffer dst_buffer, @Cast("uInt8*") ByteBuffer src_buffer, @Cast("size_t") long src_size);
        public native void applyPaletteRGB(@Cast("uInt8*") byte[] dst_buffer, @Cast("uInt8*") byte[] src_buffer, @Cast("size_t") long src_size);

        /**
            Applies the current grayscale palette to the src_buffer and returns the results in dst_buffer
            For each byte in src_buffer, a single byte is returned in dst_buffer
            8 bits => 8 bits
         */
        public native void applyPaletteGrayscale(@Cast("uInt8*") BytePointer dst_buffer, @Cast("uInt8*") BytePointer src_buffer, @Cast("size_t") long src_size);
        public native void applyPaletteGrayscale(@Cast("uInt8*") ByteBuffer dst_buffer, @Cast("uInt8*") ByteBuffer src_buffer, @Cast("size_t") long src_size);
        public native void applyPaletteGrayscale(@Cast("uInt8*") byte[] dst_buffer, @Cast("uInt8*") byte[] src_buffer, @Cast("size_t") long src_size);

        /**
          Loads all defined palettes with PAL color-loss data depending
          on 'state'.
          Sets the palette according to the given palette name.
          <p>
          @param type  The palette type = {standard, z26, user}
          @param displayFormat The display format = { NTSC, PAL, SECAM }
        */
        public native void setPalette(@StdString BytePointer type,
                                @StdString BytePointer displayFormat);
        public native void setPalette(@StdString String type,
                                @StdString String displayFormat);

        /**
            Loads a user-defined palette file (from OSystem::paletteFile), filling the
            appropriate user-defined palette arrays.
        */
        public native void loadUserPalette(@StdString BytePointer paletteFile);
        public native void loadUserPalette(@StdString String paletteFile);
}

// #endif // __COLOUR_PALETTE_HPP__ 




// Parsed from common/ScreenExporter.hpp

/* *****************************************************************************
 * A.L.E (Arcade Learning Environment)
 * Copyright (c) 2009-2013 by Yavar Naddaf, Joel Veness, Marc G. Bellemare and 
 *   the Reinforcement Learning and Artificial Intelligence Laboratory
 * Released under the GNU General Public License; see License.txt for details. 
 *
 * Based on: Stella  --  "An Atari 2600 VCS Emulator"
 * Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
 *
 * *****************************************************************************
 *  ScreenExporter.hpp 
 *
 *  A class for exporting Atari 2600 frames as PNGs.
 *
 **************************************************************************** */

// #ifndef __SCREEN_EXPORTER_HPP__
// #define __SCREEN_EXPORTER_HPP__ 

// #include <string>
// #include "display_screen.h"
// #include "../environment/ale_screen.hpp"

@NoOffset public static class ScreenExporter extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ScreenExporter(Pointer p) { super(p); }


        /** Creates a new ScreenExporter which can be used to save screens using save(filename). */ 
        public ScreenExporter(@ByRef ColourPalette palette) { super((Pointer)null); allocate(palette); }
        private native void allocate(@ByRef ColourPalette palette);

        /** Creates a new ScreenExporter which will save frames successively in the directory provided.
            Frames are sequentially named with 6 digits, starting at 000000. */
        public ScreenExporter(@ByRef ColourPalette palette, @StdString BytePointer path) { super((Pointer)null); allocate(palette, path); }
        private native void allocate(@ByRef ColourPalette palette, @StdString BytePointer path);
        public ScreenExporter(@ByRef ColourPalette palette, @StdString String path) { super((Pointer)null); allocate(palette, path); }
        private native void allocate(@ByRef ColourPalette palette, @StdString String path);

        /** Save the given screen to the given filename. No paths are created. */
        public native void save(@Const @ByRef ALEScreen screen, @StdString BytePointer filename);
        public native void save(@Const @ByRef ALEScreen screen, @StdString String filename);

        /** Save the given screen according to our own internal numbering. */
        public native void saveNext(@Const @ByRef ALEScreen screen);
}

// #endif // __SCREEN_EXPORTER_HPP__ 





// Parsed from environment/ale_ram.hpp

/* *****************************************************************************
 * A.L.E (Arcade Learning Environment)
 * Copyright (c) 2009-2013 by Yavar Naddaf, Joel Veness, Marc G. Bellemare and 
 *   the Reinforcement Learning and Artificial Intelligence Laboratory
 * Released under the GNU General Public License; see License.txt for details. 
 *
 * Based on: Stella  --  "An Atari 2600 VCS Emulator"
 * Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
 *
 * *****************************************************************************
 *  ale_ram.hpp
 *
 *  A class that encapsulates the Atari 2600 RAM. Code is provided inline for
 *   efficiency reasonss.
 *  
 **************************************************************************** */

// #ifndef __ALE_RAM_HPP__
// #define __ALE_RAM_HPP__

// #include <string.h>

public static final int RAM_SIZE = (128);

/** A simple wrapper around the Atari RAM. */ 
@NoOffset public static class ALERAM extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ALERAM(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ALERAM(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ALERAM position(long position) {
        return (ALERAM)super.position(position);
    }

    public ALERAM() { super((Pointer)null); allocate(); }
    private native void allocate();
    public ALERAM(@Const @ByRef ALERAM rhs) { super((Pointer)null); allocate(rhs); }
    private native void allocate(@Const @ByRef ALERAM rhs);

    public native @ByRef @Name("operator =") ALERAM put(@Const @ByRef ALERAM rhs);

    /** Byte accessors */ 
    public native @Cast("byte_t") byte get(@Cast("unsigned int") int x);
    public native @Cast("byte_t*") @Name("byte") BytePointer _byte(@Cast("unsigned int") int x);
   
    /** Returns the whole array (equivalent to byte(0)). */
    public native @Cast("byte_t*") BytePointer array();

    public native @Cast("size_t") long size();
    /** Returns whether two copies of the RAM are equal */
    public native @Cast("bool") boolean equals(@Const @ByRef ALERAM rhs);
}









// Byte accessors 




// #endif // __ALE_RAM_HPP__



// Parsed from environment/ale_screen.hpp

/* *****************************************************************************
 * A.L.E (Arcade Learning Environment)
 * Copyright (c) 2009-2013 by Yavar Naddaf, Joel Veness, Marc G. Bellemare and 
 *   the Reinforcement Learning and Artificial Intelligence Laboratory
 * Released under the GNU General Public License; see License.txt for details. 
 *
 * Based on: Stella  --  "An Atari 2600 VCS Emulator"
 * Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
 *
 * *****************************************************************************
 *  ale_screen.hpp
 *
 *  A class that encapsulates an Atari 2600 screen. Code is provided inline for
 *   efficiency reasons.
 *  
 **************************************************************************** */

// #ifndef __ALE_SCREEN_HPP__
// #define __ALE_SCREEN_HPP__

// #include <cassert>
// #include <cstring>
// #include <memory>
// #include <vector>

/** A simple wrapper around an Atari screen. */ 
@NoOffset public static class ALEScreen extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ALEScreen(Pointer p) { super(p); }

    public ALEScreen(int h, int w) { super((Pointer)null); allocate(h, w); }
    private native void allocate(int h, int w);
    public ALEScreen(@Const @ByRef ALEScreen rhs) { super((Pointer)null); allocate(rhs); }
    private native void allocate(@Const @ByRef ALEScreen rhs);

    public native @ByRef @Name("operator =") ALEScreen put(@Const @ByRef ALEScreen rhs);

    /** pixel accessors, (row, column)-ordered */
    public native @Cast("pixel_t") byte get(int r, int c);
    public native @Cast("pixel_t*") BytePointer pixel(int r, int c);
    
    /** Access a whole row */
    public native @Cast("pixel_t*") BytePointer getRow(int r);
    
    /** Access the whole array */
    public native @Cast("pixel_t*") BytePointer getArray();

    /** Dimensionality information */
    public native @Cast("size_t") long height();
    public native @Cast("size_t") long width();

    /** Returns the size of the underlying array */
    public native @Cast("size_t") long arraySize();

    /** Returns whether two screens are equal */
    public native @Cast("bool") boolean equals(@Const @ByRef ALEScreen rhs); 
}









// pixel accessors, (row, column)-ordered




// Access a whole row



// #endif // __ALE_SCREEN_HPP__



// Parsed from environment/ale_state.hpp

/* *****************************************************************************
 * A.L.E (Arcade Learning Environment)
 * Copyright (c) 2009-2013 by Yavar Naddaf, Joel Veness, Marc G. Bellemare and 
 *   the Reinforcement Learning and Artificial Intelligence Laboratory
 * Released under the GNU General Public License; see License.txt for details. 
 *
 * Based on: Stella  --  "An Atari 2600 VCS Emulator"
 * Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
 *
 * *****************************************************************************
 *  ale_state.hpp
 *
 *  A class that stores a copy of the current ALE state. We use one to keep track
 *   of paddle resistance and in search trees.
 *  
 **************************************************************************** */

// #ifndef __ALE_STATE_HPP__ 
// #define __ALE_STATE_HPP__

// #include "../emucore/OSystem.hxx"
// #include "../emucore/Event.hxx"
// #include <string>
// #include "../common/Log.hpp"

@Opaque public static class RomSettings extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public RomSettings() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public RomSettings(Pointer p) { super(p); }
}

public static final int PADDLE_DELTA = 23000;
// MGB Values taken from Paddles.cxx (Stella 3.3) - 1400000 * [5,235] / 255
public static final int PADDLE_MIN = 27450;
// MGB - was 1290196; updated to 790196... seems to be fine for breakout and pong; 
//  avoids pong paddle going off screen
public static final int PADDLE_MAX = 790196; 
public static final int PADDLE_DEFAULT_VALUE = (((PADDLE_MAX - PADDLE_MIN) / 2) + PADDLE_MIN);

@NoOffset public static class ALEState extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ALEState(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ALEState(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ALEState position(long position) {
        return (ALEState)super.position(position);
    }

    public ALEState() { super((Pointer)null); allocate(); }
    private native void allocate();
    // Makes a copy of this state, also storing emulator information provided as a string
    public ALEState(@Const @ByRef ALEState rhs, @StdString BytePointer serialized) { super((Pointer)null); allocate(rhs, serialized); }
    private native void allocate(@Const @ByRef ALEState rhs, @StdString BytePointer serialized);
    public ALEState(@Const @ByRef ALEState rhs, @StdString String serialized) { super((Pointer)null); allocate(rhs, serialized); }
    private native void allocate(@Const @ByRef ALEState rhs, @StdString String serialized);

    // Restores a serialized ALEState
    public ALEState(@StdString BytePointer serialized) { super((Pointer)null); allocate(serialized); }
    private native void allocate(@StdString BytePointer serialized);
    public ALEState(@StdString String serialized) { super((Pointer)null); allocate(serialized); }
    private native void allocate(@StdString String serialized);

    /** Resets the system to its start state. numResetSteps 'RESET' actions are taken after the
      *  start. */
    

    /** Returns true if the two states contain the same saved information */
    public native @Cast("bool") boolean equals(@ByRef ALEState state);

    public native void resetPaddles(Event arg0);

    //Apply the special select action
    public native void pressSelect(Event event_obj);

    /** Applies paddle actions. This actually modifies the game state by updating the paddle
      *  resistances. */
    public native void applyActionPaddles(Event event_obj, int player_a_action, int player_b_action);
    /** Sets the joystick events. No effect until the emulator is run forward. */
    public native void setActionJoysticks(Event event_obj, int player_a_action, int player_b_action);

    public native void incrementFrame(int steps/*=1*/);
    public native void incrementFrame();

    public native void resetEpisodeFrameNumber();

    //Get the frames executed so far
    public native int getFrameNumber();

    //Get the number of frames executed this episode.
    public native int getEpisodeFrameNumber();

    /** set the difficulty according to the value.
      * If the first bit is 1, then it will put the left difficulty switch to A (otherwise leave it on B)
      * If the second bit is 1, then it will put the right difficulty switch to A (otherwise leave it on B)
      */
    public native void setDifficulty(@Cast("unsigned int") int value);

    // Returns the current difficulty setting.
    public native @Cast("unsigned int") int getDifficulty();

    //Save the current mode we are supposed to be in.
    public native void setCurrentMode(@Cast("game_mode_t") int value);

    //Get the current mode we are in.
    public native @Cast("game_mode_t") int getCurrentMode();

    public native @StdString BytePointer serialize();

}

// #endif // __ALE_STATE_HPP__



// Parsed from environment/stella_environment_wrapper.hpp

/* *****************************************************************************
 * A.L.E (Arcade Learning Environment)
 * Copyright (c) 2009-2013 by Yavar Naddaf, Joel Veness, Marc G. Bellemare and 
 *   the Reinforcement Learning and Artificial Intelligence Laboratory
 * Released under the GNU General Public License; see License.txt for details. 
 *
 * Based on: Stella  --  "An Atari 2600 VCS Emulator"
 * Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
 *
 * *****************************************************************************
 *  stella_environment_wrapper.hpp
 *
 * Method wrapper for StellaEnvironment.
 *  
 **************************************************************************** */

// #ifndef __STELLA_ENVIRONMENT_WRAPPER_HPP__ 
// #define __STELLA_ENVIRONMENT_WRAPPER_HPP__

// #include "../common/Constants.h"

@NoOffset public static class StellaEnvironmentWrapper extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StellaEnvironmentWrapper(Pointer p) { super(p); }

    public StellaEnvironmentWrapper(@ByRef StellaEnvironment environment) { super((Pointer)null); allocate(environment); }
    private native void allocate(@ByRef StellaEnvironment environment);
    public native @Cast("reward_t") int act(@Cast("Action") int player_a_action, @Cast("Action") int player_b_action);
    public native void softReset();
    public native void pressSelect(@Cast("size_t") long num_steps/*=1*/);
    public native void pressSelect();
    
    public native @MemberGetter @ByRef StellaEnvironment m_environment();
}

// #endif // __STELLA_ENVIRONMENT_WRAPPER_HPP__



// Parsed from environment/stella_environment.hpp

/* *****************************************************************************
 * A.L.E (Arcade Learning Environment)
 * Copyright (c) 2009-2013 by Yavar Naddaf, Joel Veness, Marc G. Bellemare and 
 *   the Reinforcement Learning and Artificial Intelligence Laboratory
 * Released under the GNU General Public License; see License.txt for details. 
 *
 * Based on: Stella  --  "An Atari 2600 VCS Emulator"
 * Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
 *
 * *****************************************************************************
 *  stella_environment.hpp
 *
 *  A class that wraps around the Stella core to provide users with a typical
 *  reinforcement learning environment interface.
 *  
 **************************************************************************** */

// #ifndef __STELLA_ENVIRONMENT_HPP__ 
// #define __STELLA_ENVIRONMENT_HPP__

// #include "ale_ram.hpp"
// #include "ale_screen.hpp"
// #include "ale_state.hpp"
// #include "phosphor_blend.hpp"
// #include "stella_environment_wrapper.hpp"
// #include "../emucore/Event.hxx"
// #include "../emucore/OSystem.hxx"
// #include "../games/RomSettings.hpp"
// #include "../common/Constants.h"
// #include "../common/Log.hpp"
// #include "../common/ScreenExporter.hpp"

// #include <stack>
// #include <memory>

@NoOffset public static class StellaEnvironment extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public StellaEnvironment(Pointer p) { super(p); }

    public StellaEnvironment(OSystem system, RomSettings settings) { super((Pointer)null); allocate(system, settings); }
    private native void allocate(OSystem system, RomSettings settings);

    /** Resets the system to its start state. */
    public native void reset();

    /** Save/restore the environment state onto the stack. */
    public native void save();
    public native void load();

    /** Returns a copy of the current emulator state. Note that this doesn't include
        pseudorandomness, so that clone/restoreState are suitable for planning. */
    public native @ByVal ALEState cloneState();
    /** Restores a previously saved copy of the state. */
    public native void restoreState(@Const @ByRef ALEState arg0);

    /** Returns a copy of the current emulator state. This includes RNG state information, and
        more generally should lead to exactly reproducibility. */
    public native @ByVal ALEState cloneSystemState();
    /** Restores a previously saved copy of the state, including RNG state information. */
    public native void restoreSystemState(@Const @ByRef ALEState arg0);

    /** Applies the given actions (e.g. updating paddle positions when the paddle is used)
      *  and performs one simulation step in Stella. Returns the resultant reward. When 
      *  frame skip is set to > 1, up the corresponding number of simulation steps are performed.
      *  Note that the post-act() frame number might not correspond to the pre-act() frame
      *  number plus the frame skip.
      */
    public native @Cast("reward_t") int act(@Cast("Action") int player_a_action, @Cast("Action") int player_b_action);

    /** This functions emulates a push on the reset button of the console */
    public native void softReset();

    /** Keep pressing the console select button for a given amount of time*/
    public native void pressSelect(@Cast("size_t") long num_steps/*=1*/);
    public native void pressSelect();

    /** Set the difficulty according to the value.
      * If the first bit is 1, then it will put the left difficulty switch to A (otherwise leave it on B)
      * If the second bit is 1, then it will put the right difficulty switch to A (otherwise leave it on B)
      *
      * This change takes effect at the immediate next time step.
      */
    public native void setDifficulty(@Cast("difficulty_t") int value);

    /** Set the game mode according to the value. The new mode will not take effect until reset() is
      * called */
    public native void setMode(@Cast("game_mode_t") int value);

    /** Returns true once we reach a terminal state */
    public native @Cast("bool") boolean isTerminal();

    /** Accessor methods for the environment state. */
    public native void setState(@Const @ByRef ALEState state);
    public native @Const @ByRef ALEState getState();

    /** Returns the current screen after processing (e.g. colour averaging) */
    public native @Const @ByRef ALEScreen getScreen();
    public native @Const @ByRef ALERAM getRAM();

    public native int getFrameNumber();
    public native int getEpisodeFrameNumber();

    /** Returns a wrapper providing #include-free access to our methods. */ 
    public native @Name("getWrapper().get") StellaEnvironmentWrapper getWrapper();
}

// #endif // __STELLA_ENVIRONMENT_HPP__


// Parsed from ale_interface.hpp

/* *****************************************************************************
 * The line 99 is based on Xitari's code, from Google Inc.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 * *****************************************************************************
 * A.L.E (Arcade Learning Environment)
 * Copyright (c) 2009-2013 by Yavar Naddaf, Joel Veness, Marc G. Bellemare and 
 *   the Reinforcement Learning and Artificial Intelligence Laboratory
 * Released under the GNU General Public License; see License.txt for details. 
 *
 * Based on: Stella  --  "An Atari 2600 VCS Emulator"
 * Copyright (c) 1995-2007 by Bradford W. Mott and the Stella team
 *
 * *****************************************************************************
 *  ale_interface.hpp
 *
 *  The shared library interface.
 **************************************************************************** */
// #ifndef __ALE_INTERFACE_HPP__
// #define __ALE_INTERFACE_HPP__

// #include "emucore/FSNode.hxx"
// #include "emucore/OSystem.hxx"
// #include "os_dependent/SettingsWin32.hxx"
// #include "os_dependent/OSystemWin32.hxx"
// #include "os_dependent/SettingsUNIX.hxx"
// #include "os_dependent/OSystemUNIX.hxx"
// #include "games/Roms.hpp"
// #include "common/display_screen.h"
// #include "environment/stella_environment.hpp"
// #include "common/ScreenExporter.hpp"
// #include "common/Log.hpp"

// #include <string>
// #include <memory>

@MemberGetter public static native @StdString BytePointer Version();

/**
   This class interfaces ALE with external code for controlling agents.
 */
@NoOffset public static class ALEInterface extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ALEInterface(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ALEInterface(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ALEInterface position(long position) {
        return (ALEInterface)super.position(position);
    }

  public ALEInterface() { super((Pointer)null); allocate(); }
  private native void allocate();
  // Legacy constructor
  public ALEInterface(@Cast("bool") boolean display_screen) { super((Pointer)null); allocate(display_screen); }
  private native void allocate(@Cast("bool") boolean display_screen);

  // Get the value of a setting.
  public native @StdString BytePointer getString(@StdString BytePointer key);
  public native @StdString String getString(@StdString String key);
  public native int getInt(@StdString BytePointer key);
  public native int getInt(@StdString String key);
  public native @Cast("bool") boolean getBool(@StdString BytePointer key);
  public native @Cast("bool") boolean getBool(@StdString String key);
  public native float getFloat(@StdString BytePointer key);
  public native float getFloat(@StdString String key);

  // Set the value of a setting. loadRom() must be called before the
  // setting will take effect.
  public native void setString(@StdString BytePointer key, @StdString BytePointer value);
  public native void setString(@StdString String key, @StdString String value);
  public native void setInt(@StdString BytePointer key, int value);
  public native void setInt(@StdString String key, int value);
  public native void setBool(@StdString BytePointer key, @Cast("const bool") boolean value);
  public native void setBool(@StdString String key, @Cast("const bool") boolean value);
  public native void setFloat(@StdString BytePointer key, float value);
  public native void setFloat(@StdString String key, float value);

  // Resets the Atari and loads a game. After this call the game
  // should be ready to play. This is necessary after changing a
  // setting for the setting to take effect.
  public native void loadROM(@StdString BytePointer rom_file);
  public native void loadROM(@StdString String rom_file);

  // Applies an action to the game and returns the reward. It is the
  // user's responsibility to check if the game has ended and reset
  // when necessary - this method will keep pressing buttons on the
  // game over screen.
  public native @Cast("reward_t") int act(@Cast("Action") int action);

  // Indicates if the game has ended.
  public native @Cast("bool") boolean game_over();

  // Resets the game, but not the full system.
  public native void reset_game();

  // Returns the vector of modes available for the current game.
  // This should be called only after the rom is loaded.
  public native @Cast("game_mode_t*") @StdVector IntPointer getAvailableModes();

  // Sets the mode of the game.
  // The mode must be an available mode (otherwise it throws an exception).
  // This should be called only after the rom is loaded.
  public native void setMode(@Cast("game_mode_t") int m);

  //Returns the vector of difficulties available for the current game.
  //This should be called only after the rom is loaded. Notice
  // that there are 2 levers, the right and left switches. They
  // are not tied to any specific player. In Venture, for example,
  // we have the following interpretation for the difficulties:
  // Skill          Switch
  // Level          Setting
  //   1         left B/right B
  //   2         left B/right A
  //   3         left A/right B
  //   4         left A/right A
  public native @Cast("difficulty_t*") @StdVector IntPointer getAvailableDifficulties();

  // Sets the difficulty of the game.
  // The difficulty must be an available mode (otherwise it throws an exception).
  // This should be called only after the rom is loaded.
  public native void setDifficulty(@Cast("difficulty_t") int m);

  // Returns the vector of legal actions. This should be called only
  // after the rom is loaded.
  public native @Cast("Action*") @StdVector IntPointer getLegalActionSet();

  // Returns the vector of the minimal set of actions needed to play
  // the game.
  public native @Cast("Action*") @StdVector IntPointer getMinimalActionSet();

  // Returns the frame number since the loading of the ROM
  public native int getFrameNumber();

  // The remaining number of lives.
  public native int lives();

  // Returns the frame number since the start of the current episode
  public native int getEpisodeFrameNumber();

  // Returns the current game screen
  public native @Const @ByRef ALEScreen getScreen();

  //This method should receive an empty vector to fill it with
  //the grayscale colours
  public native void getScreenGrayscale(@Cast("unsigned char*") @StdVector BytePointer grayscale_output_buffer);
  public native void getScreenGrayscale(@Cast("unsigned char*") @StdVector ByteBuffer grayscale_output_buffer);
  public native void getScreenGrayscale(@Cast("unsigned char*") @StdVector byte[] grayscale_output_buffer);

  //This method should receive a vector to fill it with
  //the RGB colours. The first positions contain the red colours,
  //followed by the green colours and then the blue colours
  public native void getScreenRGB(@Cast("unsigned char*") @StdVector BytePointer output_rgb_buffer);
  public native void getScreenRGB(@Cast("unsigned char*") @StdVector ByteBuffer output_rgb_buffer);
  public native void getScreenRGB(@Cast("unsigned char*") @StdVector byte[] output_rgb_buffer);

  // Returns the current RAM content
  public native @Const @ByRef ALERAM getRAM();

  // Saves the state of the system
  public native void saveState();

  // Loads the state of the system
  public native void loadState();

  // This makes a copy of the environment state. This copy does *not* include pseudorandomness,
  // making it suitable for planning purposes. By contrast, see cloneSystemState.
  public native @ByVal ALEState cloneState();

  // Reverse operation of cloneState(). This does not restore pseudorandomness, so that repeated
  // calls to restoreState() in the stochastic controls setting will not lead to the same outcomes.
  // By contrast, see restoreSystemState.
  public native void restoreState(@Const @ByRef ALEState state);

  // This makes a copy of the system & environment state, suitable for serialization. This includes
  // pseudorandomness and so is *not* suitable for planning purposes.
  public native @ByVal ALEState cloneSystemState();

  // Reverse operation of cloneSystemState.
  public native void restoreSystemState(@Const @ByRef ALEState state);

  // Save the current screen as a png file
  public native void saveScreenPNG(@StdString BytePointer filename);
  public native void saveScreenPNG(@StdString String filename);

  // Creates a ScreenExporter object which can be used to save a sequence of frames. Ownership 
  // said object is passed to the caller. Frames are saved in the directory 'path', which needs
  // to exists. 
  public native ScreenExporter createScreenExporter(@StdString BytePointer path);
  public native ScreenExporter createScreenExporter(@StdString String path);
  public native @Name("theOSystem.get") OSystem theOSystem();
  public native @Name("theSettings.get") Settings theSettings();
  public native @Name("romSettings.get") RomSettings romSettings();
  public native @Name("environment.get") StellaEnvironment environment();
  public native int max_num_frames(); public native ALEInterface max_num_frames(int max_num_frames);
  // Display ALE welcome message
  public static native @StdString BytePointer welcomeMessage();
  public static native void disableBufferedIO();
  public static native void createOSystem(@UniquePtr OSystem theOSystem,
                              @UniquePtr Settings theSettings);
  public static native void loadSettings(@StdString BytePointer romfile,
                             @UniquePtr OSystem theOSystem);
  public static native void loadSettings(@StdString String romfile,
                             @UniquePtr OSystem theOSystem);
}

// #endif


}
