// Targeted by JavaCPP version 1.5.10: DO NOT EDIT THIS FILE

package org.bytedeco.ffmpeg.global;

import org.bytedeco.ffmpeg.avcodec.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.ffmpeg.avutil.*;
import static org.bytedeco.ffmpeg.global.avutil.*;
import org.bytedeco.ffmpeg.swresample.*;
import static org.bytedeco.ffmpeg.global.swresample.*;

public class avcodec extends org.bytedeco.ffmpeg.presets.avcodec {
    static { Loader.load(); }

// Parsed from <libavcodec/codec_id.h>

/*
 * Codec IDs
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

// #ifndef AVCODEC_CODEC_ID_H
// #define AVCODEC_CODEC_ID_H

// #include "libavutil/avutil.h"
// #include "libavutil/samplefmt.h"

// #include "version_major.h"

/**
 * \addtogroup lavc_core
 * \{
 */

/**
 * Identify the syntax and semantics of the bitstream.
 * The principle is roughly:
 * Two decoders with the same ID can decode the same streams.
 * Two encoders with the same ID can encode compatible streams.
 * There may be slight deviations from the principle due to implementation
 * details.
 *
 * If you add a codec ID to this list, add it so that
 * 1. no value of an existing codec ID changes (that would break ABI),
 * 2. it is as close as possible to similar codecs
 *
 * After adding new codec IDs, do not forget to add an entry to the codec
 * descriptor list and bump libavcodec minor version.
 */
/** enum AVCodecID */
public static final int
    AV_CODEC_ID_NONE = 0,

    /* video codecs */
    AV_CODEC_ID_MPEG1VIDEO = 1,
    /** preferred ID for MPEG-1/2 video decoding */
    AV_CODEC_ID_MPEG2VIDEO = 2,
    AV_CODEC_ID_H261 = 3,
    AV_CODEC_ID_H263 = 4,
    AV_CODEC_ID_RV10 = 5,
    AV_CODEC_ID_RV20 = 6,
    AV_CODEC_ID_MJPEG = 7,
    AV_CODEC_ID_MJPEGB = 8,
    AV_CODEC_ID_LJPEG = 9,
    AV_CODEC_ID_SP5X = 10,
    AV_CODEC_ID_JPEGLS = 11,
    AV_CODEC_ID_MPEG4 = 12,
    AV_CODEC_ID_RAWVIDEO = 13,
    AV_CODEC_ID_MSMPEG4V1 = 14,
    AV_CODEC_ID_MSMPEG4V2 = 15,
    AV_CODEC_ID_MSMPEG4V3 = 16,
    AV_CODEC_ID_WMV1 = 17,
    AV_CODEC_ID_WMV2 = 18,
    AV_CODEC_ID_H263P = 19,
    AV_CODEC_ID_H263I = 20,
    AV_CODEC_ID_FLV1 = 21,
    AV_CODEC_ID_SVQ1 = 22,
    AV_CODEC_ID_SVQ3 = 23,
    AV_CODEC_ID_DVVIDEO = 24,
    AV_CODEC_ID_HUFFYUV = 25,
    AV_CODEC_ID_CYUV = 26,
    AV_CODEC_ID_H264 = 27,
    AV_CODEC_ID_INDEO3 = 28,
    AV_CODEC_ID_VP3 = 29,
    AV_CODEC_ID_THEORA = 30,
    AV_CODEC_ID_ASV1 = 31,
    AV_CODEC_ID_ASV2 = 32,
    AV_CODEC_ID_FFV1 = 33,
    AV_CODEC_ID_4XM = 34,
    AV_CODEC_ID_VCR1 = 35,
    AV_CODEC_ID_CLJR = 36,
    AV_CODEC_ID_MDEC = 37,
    AV_CODEC_ID_ROQ = 38,
    AV_CODEC_ID_INTERPLAY_VIDEO = 39,
    AV_CODEC_ID_XAN_WC3 = 40,
    AV_CODEC_ID_XAN_WC4 = 41,
    AV_CODEC_ID_RPZA = 42,
    AV_CODEC_ID_CINEPAK = 43,
    AV_CODEC_ID_WS_VQA = 44,
    AV_CODEC_ID_MSRLE = 45,
    AV_CODEC_ID_MSVIDEO1 = 46,
    AV_CODEC_ID_IDCIN = 47,
    AV_CODEC_ID_8BPS = 48,
    AV_CODEC_ID_SMC = 49,
    AV_CODEC_ID_FLIC = 50,
    AV_CODEC_ID_TRUEMOTION1 = 51,
    AV_CODEC_ID_VMDVIDEO = 52,
    AV_CODEC_ID_MSZH = 53,
    AV_CODEC_ID_ZLIB = 54,
    AV_CODEC_ID_QTRLE = 55,
    AV_CODEC_ID_TSCC = 56,
    AV_CODEC_ID_ULTI = 57,
    AV_CODEC_ID_QDRAW = 58,
    AV_CODEC_ID_VIXL = 59,
    AV_CODEC_ID_QPEG = 60,
    AV_CODEC_ID_PNG = 61,
    AV_CODEC_ID_PPM = 62,
    AV_CODEC_ID_PBM = 63,
    AV_CODEC_ID_PGM = 64,
    AV_CODEC_ID_PGMYUV = 65,
    AV_CODEC_ID_PAM = 66,
    AV_CODEC_ID_FFVHUFF = 67,
    AV_CODEC_ID_RV30 = 68,
    AV_CODEC_ID_RV40 = 69,
    AV_CODEC_ID_VC1 = 70,
    AV_CODEC_ID_WMV3 = 71,
    AV_CODEC_ID_LOCO = 72,
    AV_CODEC_ID_WNV1 = 73,
    AV_CODEC_ID_AASC = 74,
    AV_CODEC_ID_INDEO2 = 75,
    AV_CODEC_ID_FRAPS = 76,
    AV_CODEC_ID_TRUEMOTION2 = 77,
    AV_CODEC_ID_BMP = 78,
    AV_CODEC_ID_CSCD = 79,
    AV_CODEC_ID_MMVIDEO = 80,
    AV_CODEC_ID_ZMBV = 81,
    AV_CODEC_ID_AVS = 82,
    AV_CODEC_ID_SMACKVIDEO = 83,
    AV_CODEC_ID_NUV = 84,
    AV_CODEC_ID_KMVC = 85,
    AV_CODEC_ID_FLASHSV = 86,
    AV_CODEC_ID_CAVS = 87,
    AV_CODEC_ID_JPEG2000 = 88,
    AV_CODEC_ID_VMNC = 89,
    AV_CODEC_ID_VP5 = 90,
    AV_CODEC_ID_VP6 = 91,
    AV_CODEC_ID_VP6F = 92,
    AV_CODEC_ID_TARGA = 93,
    AV_CODEC_ID_DSICINVIDEO = 94,
    AV_CODEC_ID_TIERTEXSEQVIDEO = 95,
    AV_CODEC_ID_TIFF = 96,
    AV_CODEC_ID_GIF = 97,
    AV_CODEC_ID_DXA = 98,
    AV_CODEC_ID_DNXHD = 99,
    AV_CODEC_ID_THP = 100,
    AV_CODEC_ID_SGI = 101,
    AV_CODEC_ID_C93 = 102,
    AV_CODEC_ID_BETHSOFTVID = 103,
    AV_CODEC_ID_PTX = 104,
    AV_CODEC_ID_TXD = 105,
    AV_CODEC_ID_VP6A = 106,
    AV_CODEC_ID_AMV = 107,
    AV_CODEC_ID_VB = 108,
    AV_CODEC_ID_PCX = 109,
    AV_CODEC_ID_SUNRAST = 110,
    AV_CODEC_ID_INDEO4 = 111,
    AV_CODEC_ID_INDEO5 = 112,
    AV_CODEC_ID_MIMIC = 113,
    AV_CODEC_ID_RL2 = 114,
    AV_CODEC_ID_ESCAPE124 = 115,
    AV_CODEC_ID_DIRAC = 116,
    AV_CODEC_ID_BFI = 117,
    AV_CODEC_ID_CMV = 118,
    AV_CODEC_ID_MOTIONPIXELS = 119,
    AV_CODEC_ID_TGV = 120,
    AV_CODEC_ID_TGQ = 121,
    AV_CODEC_ID_TQI = 122,
    AV_CODEC_ID_AURA = 123,
    AV_CODEC_ID_AURA2 = 124,
    AV_CODEC_ID_V210X = 125,
    AV_CODEC_ID_TMV = 126,
    AV_CODEC_ID_V210 = 127,
    AV_CODEC_ID_DPX = 128,
    AV_CODEC_ID_MAD = 129,
    AV_CODEC_ID_FRWU = 130,
    AV_CODEC_ID_FLASHSV2 = 131,
    AV_CODEC_ID_CDGRAPHICS = 132,
    AV_CODEC_ID_R210 = 133,
    AV_CODEC_ID_ANM = 134,
    AV_CODEC_ID_BINKVIDEO = 135,
    AV_CODEC_ID_IFF_ILBM = 136;
public static final int AV_CODEC_ID_IFF_BYTERUN1 = AV_CODEC_ID_IFF_ILBM;
public static final int
    AV_CODEC_ID_KGV1 = 137,
    AV_CODEC_ID_YOP = 138,
    AV_CODEC_ID_VP8 = 139,
    AV_CODEC_ID_PICTOR = 140,
    AV_CODEC_ID_ANSI = 141,
    AV_CODEC_ID_A64_MULTI = 142,
    AV_CODEC_ID_A64_MULTI5 = 143,
    AV_CODEC_ID_R10K = 144,
    AV_CODEC_ID_MXPEG = 145,
    AV_CODEC_ID_LAGARITH = 146,
    AV_CODEC_ID_PRORES = 147,
    AV_CODEC_ID_JV = 148,
    AV_CODEC_ID_DFA = 149,
    AV_CODEC_ID_WMV3IMAGE = 150,
    AV_CODEC_ID_VC1IMAGE = 151,
    AV_CODEC_ID_UTVIDEO = 152,
    AV_CODEC_ID_BMV_VIDEO = 153,
    AV_CODEC_ID_VBLE = 154,
    AV_CODEC_ID_DXTORY = 155,
    AV_CODEC_ID_V410 = 156,
    AV_CODEC_ID_XWD = 157,
    AV_CODEC_ID_CDXL = 158,
    AV_CODEC_ID_XBM = 159,
    AV_CODEC_ID_ZEROCODEC = 160,
    AV_CODEC_ID_MSS1 = 161,
    AV_CODEC_ID_MSA1 = 162,
    AV_CODEC_ID_TSCC2 = 163,
    AV_CODEC_ID_MTS2 = 164,
    AV_CODEC_ID_CLLC = 165,
    AV_CODEC_ID_MSS2 = 166,
    AV_CODEC_ID_VP9 = 167,
    AV_CODEC_ID_AIC = 168,
    AV_CODEC_ID_ESCAPE130 = 169,
    AV_CODEC_ID_G2M = 170,
    AV_CODEC_ID_WEBP = 171,
    AV_CODEC_ID_HNM4_VIDEO = 172,
    AV_CODEC_ID_HEVC = 173;
public static final int AV_CODEC_ID_H265 = AV_CODEC_ID_HEVC;
public static final int
    AV_CODEC_ID_FIC = 174,
    AV_CODEC_ID_ALIAS_PIX = 175,
    AV_CODEC_ID_BRENDER_PIX = 176,
    AV_CODEC_ID_PAF_VIDEO = 177,
    AV_CODEC_ID_EXR = 178,
    AV_CODEC_ID_VP7 = 179,
    AV_CODEC_ID_SANM = 180,
    AV_CODEC_ID_SGIRLE = 181,
    AV_CODEC_ID_MVC1 = 182,
    AV_CODEC_ID_MVC2 = 183,
    AV_CODEC_ID_HQX = 184,
    AV_CODEC_ID_TDSC = 185,
    AV_CODEC_ID_HQ_HQA = 186,
    AV_CODEC_ID_HAP = 187,
    AV_CODEC_ID_DDS = 188,
    AV_CODEC_ID_DXV = 189,
    AV_CODEC_ID_SCREENPRESSO = 190,
    AV_CODEC_ID_RSCC = 191,
    AV_CODEC_ID_AVS2 = 192,
    AV_CODEC_ID_PGX = 193,
    AV_CODEC_ID_AVS3 = 194,
    AV_CODEC_ID_MSP2 = 195,
    AV_CODEC_ID_VVC = 196;
public static final int AV_CODEC_ID_H266 = AV_CODEC_ID_VVC;
public static final int
    AV_CODEC_ID_Y41P = 197,
    AV_CODEC_ID_AVRP = 198,
    AV_CODEC_ID_012V = 199,
    AV_CODEC_ID_AVUI = 200,
// #if FF_API_AYUV_CODECID
    AV_CODEC_ID_AYUV = 201,
// #endif
    AV_CODEC_ID_TARGA_Y216 = 202,
    AV_CODEC_ID_V308 = 203,
    AV_CODEC_ID_V408 = 204,
    AV_CODEC_ID_YUV4 = 205,
    AV_CODEC_ID_AVRN = 206,
    AV_CODEC_ID_CPIA = 207,
    AV_CODEC_ID_XFACE = 208,
    AV_CODEC_ID_SNOW = 209,
    AV_CODEC_ID_SMVJPEG = 210,
    AV_CODEC_ID_APNG = 211,
    AV_CODEC_ID_DAALA = 212,
    AV_CODEC_ID_CFHD = 213,
    AV_CODEC_ID_TRUEMOTION2RT = 214,
    AV_CODEC_ID_M101 = 215,
    AV_CODEC_ID_MAGICYUV = 216,
    AV_CODEC_ID_SHEERVIDEO = 217,
    AV_CODEC_ID_YLC = 218,
    AV_CODEC_ID_PSD = 219,
    AV_CODEC_ID_PIXLET = 220,
    AV_CODEC_ID_SPEEDHQ = 221,
    AV_CODEC_ID_FMVC = 222,
    AV_CODEC_ID_SCPR = 223,
    AV_CODEC_ID_CLEARVIDEO = 224,
    AV_CODEC_ID_XPM = 225,
    AV_CODEC_ID_AV1 = 226,
    AV_CODEC_ID_BITPACKED = 227,
    AV_CODEC_ID_MSCC = 228,
    AV_CODEC_ID_SRGC = 229,
    AV_CODEC_ID_SVG = 230,
    AV_CODEC_ID_GDV = 231,
    AV_CODEC_ID_FITS = 232,
    AV_CODEC_ID_IMM4 = 233,
    AV_CODEC_ID_PROSUMER = 234,
    AV_CODEC_ID_MWSC = 235,
    AV_CODEC_ID_WCMV = 236,
    AV_CODEC_ID_RASC = 237,
    AV_CODEC_ID_HYMT = 238,
    AV_CODEC_ID_ARBC = 239,
    AV_CODEC_ID_AGM = 240,
    AV_CODEC_ID_LSCR = 241,
    AV_CODEC_ID_VP4 = 242,
    AV_CODEC_ID_IMM5 = 243,
    AV_CODEC_ID_MVDV = 244,
    AV_CODEC_ID_MVHA = 245,
    AV_CODEC_ID_CDTOONS = 246,
    AV_CODEC_ID_MV30 = 247,
    AV_CODEC_ID_NOTCHLC = 248,
    AV_CODEC_ID_PFM = 249,
    AV_CODEC_ID_MOBICLIP = 250,
    AV_CODEC_ID_PHOTOCD = 251,
    AV_CODEC_ID_IPU = 252,
    AV_CODEC_ID_ARGO = 253,
    AV_CODEC_ID_CRI = 254,
    AV_CODEC_ID_SIMBIOSIS_IMX = 255,
    AV_CODEC_ID_SGA_VIDEO = 256,
    AV_CODEC_ID_GEM = 257,
    AV_CODEC_ID_VBN = 258,
    AV_CODEC_ID_JPEGXL = 259,
    AV_CODEC_ID_QOI = 260,
    AV_CODEC_ID_PHM = 261,
    AV_CODEC_ID_RADIANCE_HDR = 262,
    AV_CODEC_ID_WBMP = 263,
    AV_CODEC_ID_MEDIA100 = 264,
    AV_CODEC_ID_VQC = 265,
    AV_CODEC_ID_PDV = 266,
    AV_CODEC_ID_EVC = 267,
    AV_CODEC_ID_RTV1 = 268,
    AV_CODEC_ID_VMIX = 269,

    /* various PCM "codecs" */
    /** A dummy id pointing at the start of audio codecs */
    AV_CODEC_ID_FIRST_AUDIO = 0x10000,
    AV_CODEC_ID_PCM_S16LE = 0x10000,
    AV_CODEC_ID_PCM_S16BE = 0x10000 + 1,
    AV_CODEC_ID_PCM_U16LE = 0x10000 + 2,
    AV_CODEC_ID_PCM_U16BE = 0x10000 + 3,
    AV_CODEC_ID_PCM_S8 = 0x10000 + 4,
    AV_CODEC_ID_PCM_U8 = 0x10000 + 5,
    AV_CODEC_ID_PCM_MULAW = 0x10000 + 6,
    AV_CODEC_ID_PCM_ALAW = 0x10000 + 7,
    AV_CODEC_ID_PCM_S32LE = 0x10000 + 8,
    AV_CODEC_ID_PCM_S32BE = 0x10000 + 9,
    AV_CODEC_ID_PCM_U32LE = 0x10000 + 10,
    AV_CODEC_ID_PCM_U32BE = 0x10000 + 11,
    AV_CODEC_ID_PCM_S24LE = 0x10000 + 12,
    AV_CODEC_ID_PCM_S24BE = 0x10000 + 13,
    AV_CODEC_ID_PCM_U24LE = 0x10000 + 14,
    AV_CODEC_ID_PCM_U24BE = 0x10000 + 15,
    AV_CODEC_ID_PCM_S24DAUD = 0x10000 + 16,
    AV_CODEC_ID_PCM_ZORK = 0x10000 + 17,
    AV_CODEC_ID_PCM_S16LE_PLANAR = 0x10000 + 18,
    AV_CODEC_ID_PCM_DVD = 0x10000 + 19,
    AV_CODEC_ID_PCM_F32BE = 0x10000 + 20,
    AV_CODEC_ID_PCM_F32LE = 0x10000 + 21,
    AV_CODEC_ID_PCM_F64BE = 0x10000 + 22,
    AV_CODEC_ID_PCM_F64LE = 0x10000 + 23,
    AV_CODEC_ID_PCM_BLURAY = 0x10000 + 24,
    AV_CODEC_ID_PCM_LXF = 0x10000 + 25,
    AV_CODEC_ID_S302M = 0x10000 + 26,
    AV_CODEC_ID_PCM_S8_PLANAR = 0x10000 + 27,
    AV_CODEC_ID_PCM_S24LE_PLANAR = 0x10000 + 28,
    AV_CODEC_ID_PCM_S32LE_PLANAR = 0x10000 + 29,
    AV_CODEC_ID_PCM_S16BE_PLANAR = 0x10000 + 30,
    AV_CODEC_ID_PCM_S64LE = 0x10000 + 31,
    AV_CODEC_ID_PCM_S64BE = 0x10000 + 32,
    AV_CODEC_ID_PCM_F16LE = 0x10000 + 33,
    AV_CODEC_ID_PCM_F24LE = 0x10000 + 34,
    AV_CODEC_ID_PCM_VIDC = 0x10000 + 35,
    AV_CODEC_ID_PCM_SGA = 0x10000 + 36,

    /* various ADPCM codecs */
    AV_CODEC_ID_ADPCM_IMA_QT = 0x11000,
    AV_CODEC_ID_ADPCM_IMA_WAV = 0x11000 + 1,
    AV_CODEC_ID_ADPCM_IMA_DK3 = 0x11000 + 2,
    AV_CODEC_ID_ADPCM_IMA_DK4 = 0x11000 + 3,
    AV_CODEC_ID_ADPCM_IMA_WS = 0x11000 + 4,
    AV_CODEC_ID_ADPCM_IMA_SMJPEG = 0x11000 + 5,
    AV_CODEC_ID_ADPCM_MS = 0x11000 + 6,
    AV_CODEC_ID_ADPCM_4XM = 0x11000 + 7,
    AV_CODEC_ID_ADPCM_XA = 0x11000 + 8,
    AV_CODEC_ID_ADPCM_ADX = 0x11000 + 9,
    AV_CODEC_ID_ADPCM_EA = 0x11000 + 10,
    AV_CODEC_ID_ADPCM_G726 = 0x11000 + 11,
    AV_CODEC_ID_ADPCM_CT = 0x11000 + 12,
    AV_CODEC_ID_ADPCM_SWF = 0x11000 + 13,
    AV_CODEC_ID_ADPCM_YAMAHA = 0x11000 + 14,
    AV_CODEC_ID_ADPCM_SBPRO_4 = 0x11000 + 15,
    AV_CODEC_ID_ADPCM_SBPRO_3 = 0x11000 + 16,
    AV_CODEC_ID_ADPCM_SBPRO_2 = 0x11000 + 17,
    AV_CODEC_ID_ADPCM_THP = 0x11000 + 18,
    AV_CODEC_ID_ADPCM_IMA_AMV = 0x11000 + 19,
    AV_CODEC_ID_ADPCM_EA_R1 = 0x11000 + 20,
    AV_CODEC_ID_ADPCM_EA_R3 = 0x11000 + 21,
    AV_CODEC_ID_ADPCM_EA_R2 = 0x11000 + 22,
    AV_CODEC_ID_ADPCM_IMA_EA_SEAD = 0x11000 + 23,
    AV_CODEC_ID_ADPCM_IMA_EA_EACS = 0x11000 + 24,
    AV_CODEC_ID_ADPCM_EA_XAS = 0x11000 + 25,
    AV_CODEC_ID_ADPCM_EA_MAXIS_XA = 0x11000 + 26,
    AV_CODEC_ID_ADPCM_IMA_ISS = 0x11000 + 27,
    AV_CODEC_ID_ADPCM_G722 = 0x11000 + 28,
    AV_CODEC_ID_ADPCM_IMA_APC = 0x11000 + 29,
    AV_CODEC_ID_ADPCM_VIMA = 0x11000 + 30,
    AV_CODEC_ID_ADPCM_AFC = 0x11000 + 31,
    AV_CODEC_ID_ADPCM_IMA_OKI = 0x11000 + 32,
    AV_CODEC_ID_ADPCM_DTK = 0x11000 + 33,
    AV_CODEC_ID_ADPCM_IMA_RAD = 0x11000 + 34,
    AV_CODEC_ID_ADPCM_G726LE = 0x11000 + 35,
    AV_CODEC_ID_ADPCM_THP_LE = 0x11000 + 36,
    AV_CODEC_ID_ADPCM_PSX = 0x11000 + 37,
    AV_CODEC_ID_ADPCM_AICA = 0x11000 + 38,
    AV_CODEC_ID_ADPCM_IMA_DAT4 = 0x11000 + 39,
    AV_CODEC_ID_ADPCM_MTAF = 0x11000 + 40,
    AV_CODEC_ID_ADPCM_AGM = 0x11000 + 41,
    AV_CODEC_ID_ADPCM_ARGO = 0x11000 + 42,
    AV_CODEC_ID_ADPCM_IMA_SSI = 0x11000 + 43,
    AV_CODEC_ID_ADPCM_ZORK = 0x11000 + 44,
    AV_CODEC_ID_ADPCM_IMA_APM = 0x11000 + 45,
    AV_CODEC_ID_ADPCM_IMA_ALP = 0x11000 + 46,
    AV_CODEC_ID_ADPCM_IMA_MTF = 0x11000 + 47,
    AV_CODEC_ID_ADPCM_IMA_CUNNING = 0x11000 + 48,
    AV_CODEC_ID_ADPCM_IMA_MOFLEX = 0x11000 + 49,
    AV_CODEC_ID_ADPCM_IMA_ACORN = 0x11000 + 50,
    AV_CODEC_ID_ADPCM_XMD = 0x11000 + 51,

    /* AMR */
    AV_CODEC_ID_AMR_NB = 0x12000,
    AV_CODEC_ID_AMR_WB = 0x12000 + 1,

    /* RealAudio codecs*/
    AV_CODEC_ID_RA_144 = 0x13000,
    AV_CODEC_ID_RA_288 = 0x13000 + 1,

    /* various DPCM codecs */
    AV_CODEC_ID_ROQ_DPCM = 0x14000,
    AV_CODEC_ID_INTERPLAY_DPCM = 0x14000 + 1,
    AV_CODEC_ID_XAN_DPCM = 0x14000 + 2,
    AV_CODEC_ID_SOL_DPCM = 0x14000 + 3,
    AV_CODEC_ID_SDX2_DPCM = 0x14000 + 4,
    AV_CODEC_ID_GREMLIN_DPCM = 0x14000 + 5,
    AV_CODEC_ID_DERF_DPCM = 0x14000 + 6,
    AV_CODEC_ID_WADY_DPCM = 0x14000 + 7,
    AV_CODEC_ID_CBD2_DPCM = 0x14000 + 8,

    /* audio codecs */
    AV_CODEC_ID_MP2 = 0x15000,
    /** preferred ID for decoding MPEG audio layer 1, 2 or 3 */
    AV_CODEC_ID_MP3 = 0x15000 + 1,
    AV_CODEC_ID_AAC = 0x15000 + 2,
    AV_CODEC_ID_AC3 = 0x15000 + 3,
    AV_CODEC_ID_DTS = 0x15000 + 4,
    AV_CODEC_ID_VORBIS = 0x15000 + 5,
    AV_CODEC_ID_DVAUDIO = 0x15000 + 6,
    AV_CODEC_ID_WMAV1 = 0x15000 + 7,
    AV_CODEC_ID_WMAV2 = 0x15000 + 8,
    AV_CODEC_ID_MACE3 = 0x15000 + 9,
    AV_CODEC_ID_MACE6 = 0x15000 + 10,
    AV_CODEC_ID_VMDAUDIO = 0x15000 + 11,
    AV_CODEC_ID_FLAC = 0x15000 + 12,
    AV_CODEC_ID_MP3ADU = 0x15000 + 13,
    AV_CODEC_ID_MP3ON4 = 0x15000 + 14,
    AV_CODEC_ID_SHORTEN = 0x15000 + 15,
    AV_CODEC_ID_ALAC = 0x15000 + 16,
    AV_CODEC_ID_WESTWOOD_SND1 = 0x15000 + 17,
    /** as in Berlin toast format */
    AV_CODEC_ID_GSM = 0x15000 + 18,
    AV_CODEC_ID_QDM2 = 0x15000 + 19,
    AV_CODEC_ID_COOK = 0x15000 + 20,
    AV_CODEC_ID_TRUESPEECH = 0x15000 + 21,
    AV_CODEC_ID_TTA = 0x15000 + 22,
    AV_CODEC_ID_SMACKAUDIO = 0x15000 + 23,
    AV_CODEC_ID_QCELP = 0x15000 + 24,
    AV_CODEC_ID_WAVPACK = 0x15000 + 25,
    AV_CODEC_ID_DSICINAUDIO = 0x15000 + 26,
    AV_CODEC_ID_IMC = 0x15000 + 27,
    AV_CODEC_ID_MUSEPACK7 = 0x15000 + 28,
    AV_CODEC_ID_MLP = 0x15000 + 29,
    AV_CODEC_ID_GSM_MS = 0x15000 + 30, /* as found in WAV */
    AV_CODEC_ID_ATRAC3 = 0x15000 + 31,
    AV_CODEC_ID_APE = 0x15000 + 32,
    AV_CODEC_ID_NELLYMOSER = 0x15000 + 33,
    AV_CODEC_ID_MUSEPACK8 = 0x15000 + 34,
    AV_CODEC_ID_SPEEX = 0x15000 + 35,
    AV_CODEC_ID_WMAVOICE = 0x15000 + 36,
    AV_CODEC_ID_WMAPRO = 0x15000 + 37,
    AV_CODEC_ID_WMALOSSLESS = 0x15000 + 38,
    AV_CODEC_ID_ATRAC3P = 0x15000 + 39,
    AV_CODEC_ID_EAC3 = 0x15000 + 40,
    AV_CODEC_ID_SIPR = 0x15000 + 41,
    AV_CODEC_ID_MP1 = 0x15000 + 42,
    AV_CODEC_ID_TWINVQ = 0x15000 + 43,
    AV_CODEC_ID_TRUEHD = 0x15000 + 44,
    AV_CODEC_ID_MP4ALS = 0x15000 + 45,
    AV_CODEC_ID_ATRAC1 = 0x15000 + 46,
    AV_CODEC_ID_BINKAUDIO_RDFT = 0x15000 + 47,
    AV_CODEC_ID_BINKAUDIO_DCT = 0x15000 + 48,
    AV_CODEC_ID_AAC_LATM = 0x15000 + 49,
    AV_CODEC_ID_QDMC = 0x15000 + 50,
    AV_CODEC_ID_CELT = 0x15000 + 51,
    AV_CODEC_ID_G723_1 = 0x15000 + 52,
    AV_CODEC_ID_G729 = 0x15000 + 53,
    AV_CODEC_ID_8SVX_EXP = 0x15000 + 54,
    AV_CODEC_ID_8SVX_FIB = 0x15000 + 55,
    AV_CODEC_ID_BMV_AUDIO = 0x15000 + 56,
    AV_CODEC_ID_RALF = 0x15000 + 57,
    AV_CODEC_ID_IAC = 0x15000 + 58,
    AV_CODEC_ID_ILBC = 0x15000 + 59,
    AV_CODEC_ID_OPUS = 0x15000 + 60,
    AV_CODEC_ID_COMFORT_NOISE = 0x15000 + 61,
    AV_CODEC_ID_TAK = 0x15000 + 62,
    AV_CODEC_ID_METASOUND = 0x15000 + 63,
    AV_CODEC_ID_PAF_AUDIO = 0x15000 + 64,
    AV_CODEC_ID_ON2AVC = 0x15000 + 65,
    AV_CODEC_ID_DSS_SP = 0x15000 + 66,
    AV_CODEC_ID_CODEC2 = 0x15000 + 67,
    AV_CODEC_ID_FFWAVESYNTH = 0x15000 + 68,
    AV_CODEC_ID_SONIC = 0x15000 + 69,
    AV_CODEC_ID_SONIC_LS = 0x15000 + 70,
    AV_CODEC_ID_EVRC = 0x15000 + 71,
    AV_CODEC_ID_SMV = 0x15000 + 72,
    AV_CODEC_ID_DSD_LSBF = 0x15000 + 73,
    AV_CODEC_ID_DSD_MSBF = 0x15000 + 74,
    AV_CODEC_ID_DSD_LSBF_PLANAR = 0x15000 + 75,
    AV_CODEC_ID_DSD_MSBF_PLANAR = 0x15000 + 76,
    AV_CODEC_ID_4GV = 0x15000 + 77,
    AV_CODEC_ID_INTERPLAY_ACM = 0x15000 + 78,
    AV_CODEC_ID_XMA1 = 0x15000 + 79,
    AV_CODEC_ID_XMA2 = 0x15000 + 80,
    AV_CODEC_ID_DST = 0x15000 + 81,
    AV_CODEC_ID_ATRAC3AL = 0x15000 + 82,
    AV_CODEC_ID_ATRAC3PAL = 0x15000 + 83,
    AV_CODEC_ID_DOLBY_E = 0x15000 + 84,
    AV_CODEC_ID_APTX = 0x15000 + 85,
    AV_CODEC_ID_APTX_HD = 0x15000 + 86,
    AV_CODEC_ID_SBC = 0x15000 + 87,
    AV_CODEC_ID_ATRAC9 = 0x15000 + 88,
    AV_CODEC_ID_HCOM = 0x15000 + 89,
    AV_CODEC_ID_ACELP_KELVIN = 0x15000 + 90,
    AV_CODEC_ID_MPEGH_3D_AUDIO = 0x15000 + 91,
    AV_CODEC_ID_SIREN = 0x15000 + 92,
    AV_CODEC_ID_HCA = 0x15000 + 93,
    AV_CODEC_ID_FASTAUDIO = 0x15000 + 94,
    AV_CODEC_ID_MSNSIREN = 0x15000 + 95,
    AV_CODEC_ID_DFPWM = 0x15000 + 96,
    AV_CODEC_ID_BONK = 0x15000 + 97,
    AV_CODEC_ID_MISC4 = 0x15000 + 98,
    AV_CODEC_ID_APAC = 0x15000 + 99,
    AV_CODEC_ID_FTR = 0x15000 + 100,
    AV_CODEC_ID_WAVARC = 0x15000 + 101,
    AV_CODEC_ID_RKA = 0x15000 + 102,
    AV_CODEC_ID_AC4 = 0x15000 + 103,
    AV_CODEC_ID_OSQ = 0x15000 + 104,

    /* subtitle codecs */
    /** A dummy ID pointing at the start of subtitle codecs. */
    AV_CODEC_ID_FIRST_SUBTITLE = 0x17000,
    AV_CODEC_ID_DVD_SUBTITLE = 0x17000,
    AV_CODEC_ID_DVB_SUBTITLE = 0x17000 + 1,
    /** raw UTF-8 text */
    AV_CODEC_ID_TEXT = 0x17000 + 2,
    AV_CODEC_ID_XSUB = 0x17000 + 3,
    AV_CODEC_ID_SSA = 0x17000 + 4,
    AV_CODEC_ID_MOV_TEXT = 0x17000 + 5,
    AV_CODEC_ID_HDMV_PGS_SUBTITLE = 0x17000 + 6,
    AV_CODEC_ID_DVB_TELETEXT = 0x17000 + 7,
    AV_CODEC_ID_SRT = 0x17000 + 8,
    AV_CODEC_ID_MICRODVD = 0x17000 + 9,
    AV_CODEC_ID_EIA_608 = 0x17000 + 10,
    AV_CODEC_ID_JACOSUB = 0x17000 + 11,
    AV_CODEC_ID_SAMI = 0x17000 + 12,
    AV_CODEC_ID_REALTEXT = 0x17000 + 13,
    AV_CODEC_ID_STL = 0x17000 + 14,
    AV_CODEC_ID_SUBVIEWER1 = 0x17000 + 15,
    AV_CODEC_ID_SUBVIEWER = 0x17000 + 16,
    AV_CODEC_ID_SUBRIP = 0x17000 + 17,
    AV_CODEC_ID_WEBVTT = 0x17000 + 18,
    AV_CODEC_ID_MPL2 = 0x17000 + 19,
    AV_CODEC_ID_VPLAYER = 0x17000 + 20,
    AV_CODEC_ID_PJS = 0x17000 + 21,
    AV_CODEC_ID_ASS = 0x17000 + 22,
    AV_CODEC_ID_HDMV_TEXT_SUBTITLE = 0x17000 + 23,
    AV_CODEC_ID_TTML = 0x17000 + 24,
    AV_CODEC_ID_ARIB_CAPTION = 0x17000 + 25,

    /* other specific kind of codecs (generally used for attachments) */
    /** A dummy ID pointing at the start of various fake codecs. */
    AV_CODEC_ID_FIRST_UNKNOWN = 0x18000,
    AV_CODEC_ID_TTF = 0x18000,

    /** Contain timestamp estimated through PCR of program stream. */
    AV_CODEC_ID_SCTE_35 = 0x18000 + 1,
    AV_CODEC_ID_EPG = 0x18000 + 2,
    AV_CODEC_ID_BINTEXT = 0x18000 + 3,
    AV_CODEC_ID_XBIN = 0x18000 + 4,
    AV_CODEC_ID_IDF = 0x18000 + 5,
    AV_CODEC_ID_OTF = 0x18000 + 6,
    AV_CODEC_ID_SMPTE_KLV = 0x18000 + 7,
    AV_CODEC_ID_DVD_NAV = 0x18000 + 8,
    AV_CODEC_ID_TIMED_ID3 = 0x18000 + 9,
    AV_CODEC_ID_BIN_DATA = 0x18000 + 10,
    AV_CODEC_ID_SMPTE_2038 = 0x18000 + 11,


    /** codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it */
    AV_CODEC_ID_PROBE = 0x19000,

    /** _FAKE_ codec to indicate a raw MPEG-2 TS
                                * stream (only used by libavformat) */
    AV_CODEC_ID_MPEG2TS = 0x20000,
    /** _FAKE_ codec to indicate a MPEG-4 Systems
                                * stream (only used by libavformat) */
    AV_CODEC_ID_MPEG4SYSTEMS = 0x20001,
    /** Dummy codec for streams containing only metadata information. */
    AV_CODEC_ID_FFMETADATA = 0x21000,
    /** Passthrough codec, AVFrames wrapped in AVPacket */
    AV_CODEC_ID_WRAPPED_AVFRAME = 0x21001,
    /**
     * Dummy null video codec, useful mainly for development and debugging.
     * Null encoder/decoder discard all input and never return any output.
     */
    AV_CODEC_ID_VNULL = 0x21001 + 1,
    /**
     * Dummy null audio codec, useful mainly for development and debugging.
     * Null encoder/decoder discard all input and never return any output.
     */
    AV_CODEC_ID_ANULL = 0x21001 + 2;

/**
 * Get the type of the given codec.
 */
@NoException public static native @Cast("AVMediaType") int avcodec_get_type(@Cast("AVCodecID") int codec_id);

/**
 * Get the name of a codec.
 * @return  a static string identifying the codec; never NULL
 */
@NoException public static native @Cast("const char*") BytePointer avcodec_get_name(@Cast("AVCodecID") int id);

/**
 * Return codec bits per sample.
 *
 * @param codec_id [in] the codec
 * @return Number of bits per sample or zero if unknown for the given codec.
 */
@NoException public static native int av_get_bits_per_sample(@Cast("AVCodecID") int codec_id);

/**
 * Return codec bits per sample.
 * Only return non-zero if the bits per sample is exactly correct, not an
 * approximation.
 *
 * @param codec_id [in] the codec
 * @return Number of bits per sample or zero if unknown for the given codec.
 */
@NoException public static native int av_get_exact_bits_per_sample(@Cast("AVCodecID") int codec_id);

/**
 * Return a name for the specified profile, if available.
 *
 * @param codec_id the ID of the codec to which the requested profile belongs
 * @param profile the profile value for which a name is requested
 * @return A name for the profile if found, NULL otherwise.
 *
 * \note unlike av_get_profile_name(), which searches a list of profiles
 *       supported by a specific decoder or encoder implementation, this
 *       function searches the list of profiles from the AVCodecDescriptor
 */
@NoException public static native @Cast("const char*") BytePointer avcodec_profile_name(@Cast("AVCodecID") int codec_id, int profile);

/**
 * Return the PCM codec associated with a sample format.
 * @param be  endianness, 0 for little, 1 for big,
 *            -1 (or anything else) for native
 * @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE
 */
@NoException public static native @Cast("AVCodecID") int av_get_pcm_codec(@Cast("AVSampleFormat") int fmt, int be);

/**
 * \}
 */

// #endif // AVCODEC_CODEC_ID_H


// Parsed from <libavcodec/codec_desc.h>

/*
 * Codec descriptors public API
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

// #ifndef AVCODEC_CODEC_DESC_H
// #define AVCODEC_CODEC_DESC_H

// #include "libavutil/avutil.h"

// #include "codec_id.h"
// Targeting ../avcodec/AVCodecDescriptor.java



/**
 * Codec uses only intra compression.
 * Video and audio codecs only.
 */
public static final int AV_CODEC_PROP_INTRA_ONLY =    (1 << 0);
/**
 * Codec supports lossy compression. Audio and video codecs only.
 * \note a codec may support both lossy and lossless
 * compression modes
 */
public static final int AV_CODEC_PROP_LOSSY =         (1 << 1);
/**
 * Codec supports lossless compression. Audio and video codecs only.
 */
public static final int AV_CODEC_PROP_LOSSLESS =      (1 << 2);
/**
 * Codec supports frame reordering. That is, the coded order (the order in which
 * the encoded packets are output by the encoders / stored / input to the
 * decoders) may be different from the presentation order of the corresponding
 * frames.
 *
 * For codecs that do not have this property set, PTS and DTS should always be
 * equal.
 */
public static final int AV_CODEC_PROP_REORDER =       (1 << 3);

/**
 * Video codec supports separate coding of fields in interlaced frames.
 */
public static final int AV_CODEC_PROP_FIELDS =        (1 << 4);

/**
 * Subtitle codec is bitmap based
 * Decoded AVSubtitle data can be read from the AVSubtitleRect->pict field.
 */
public static final int AV_CODEC_PROP_BITMAP_SUB =    (1 << 16);
/**
 * Subtitle codec is text based.
 * Decoded AVSubtitle data can be read from the AVSubtitleRect->ass field.
 */
public static final int AV_CODEC_PROP_TEXT_SUB =      (1 << 17);

/**
 * @return descriptor for given codec ID or NULL if no descriptor exists.
 */
@NoException public static native @Const AVCodecDescriptor avcodec_descriptor_get(@Cast("AVCodecID") int id);

/**
 * Iterate over all codec descriptors known to libavcodec.
 *
 * @param prev previous descriptor. NULL to get the first descriptor.
 *
 * @return next descriptor or NULL after the last descriptor
 */
@NoException public static native @Const AVCodecDescriptor avcodec_descriptor_next(@Const AVCodecDescriptor prev);

/**
 * @return codec descriptor with the given name or NULL if no such descriptor
 *         exists.
 */
@NoException public static native @Const AVCodecDescriptor avcodec_descriptor_get_by_name(@Cast("const char*") BytePointer name);
@NoException public static native @Const AVCodecDescriptor avcodec_descriptor_get_by_name(String name);

/**
 * \}
 */

// #endif // AVCODEC_CODEC_DESC_H


// Parsed from <libavcodec/defs.h>

/*
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

// #ifndef AVCODEC_DEFS_H
// #define AVCODEC_DEFS_H

/**
 * \file
 * \ingroup libavc
 * Misc types and constants that do not belong anywhere else.
 */

// #include <stdint.h>
// #include <stdlib.h>

/**
 * \ingroup lavc_decoding
 * Required number of additionally allocated bytes at the end of the input bitstream for decoding.
 * This is mainly needed because some optimized bitstream readers read
 * 32 or 64 bit at once and could read over the end.<br>
 * Note: If the first 23 bits of the additional bytes are not 0, then damaged
 * MPEG bitstreams could cause overread and segfault.
 */
public static final int AV_INPUT_BUFFER_PADDING_SIZE = 64;

/**
 * Verify checksums embedded in the bitstream (could be of either encoded or
 * decoded data, depending on the format) and print an error message on mismatch.
 * If AV_EF_EXPLODE is also set, a mismatching checksum will result in the
 * decoder/demuxer returning an error.
 */
public static final int AV_EF_CRCCHECK =       (1<<0);
/** detect bitstream specification deviations */
public static final int AV_EF_BITSTREAM =      (1<<1);
/** detect improper bitstream length */
public static final int AV_EF_BUFFER =         (1<<2);
/** abort decoding on minor error detection */
public static final int AV_EF_EXPLODE =        (1<<3);

/** ignore errors and continue */
public static final int AV_EF_IGNORE_ERR =     (1<<15);
/** consider things that violate the spec, are fast to calculate and have not been seen in the wild as errors */
public static final int AV_EF_CAREFUL =        (1<<16);
/** consider all spec non compliances as errors */
public static final int AV_EF_COMPLIANT =      (1<<17);
/** consider things that a sane encoder/muxer should not do as an error */
public static final int AV_EF_AGGRESSIVE =     (1<<18);

/** Strictly conform to an older more strict version of the spec or reference software. */
public static final int FF_COMPLIANCE_VERY_STRICT =   2;
/** Strictly conform to all the things in the spec no matter what consequences. */
public static final int FF_COMPLIANCE_STRICT =        1;
public static final int FF_COMPLIANCE_NORMAL =        0;
/** Allow unofficial extensions */
public static final int FF_COMPLIANCE_UNOFFICIAL =   -1;
/** Allow nonstandardized experimental things. */
public static final int FF_COMPLIANCE_EXPERIMENTAL = -2;


public static final int AV_PROFILE_UNKNOWN =        -99;
public static final int AV_PROFILE_RESERVED =      -100;

public static final int AV_PROFILE_AAC_MAIN =         0;
public static final int AV_PROFILE_AAC_LOW =          1;
public static final int AV_PROFILE_AAC_SSR =          2;
public static final int AV_PROFILE_AAC_LTP =          3;
public static final int AV_PROFILE_AAC_HE =           4;
public static final int AV_PROFILE_AAC_HE_V2 =       28;
public static final int AV_PROFILE_AAC_LD =          22;
public static final int AV_PROFILE_AAC_ELD =         38;
public static final int AV_PROFILE_MPEG2_AAC_LOW =  128;
public static final int AV_PROFILE_MPEG2_AAC_HE =   131;

public static final int AV_PROFILE_DNXHD =         0;
public static final int AV_PROFILE_DNXHR_LB =      1;
public static final int AV_PROFILE_DNXHR_SQ =      2;
public static final int AV_PROFILE_DNXHR_HQ =      3;
public static final int AV_PROFILE_DNXHR_HQX =     4;
public static final int AV_PROFILE_DNXHR_444 =     5;

public static final int AV_PROFILE_DTS =                20;
public static final int AV_PROFILE_DTS_ES =             30;
public static final int AV_PROFILE_DTS_96_24 =          40;
public static final int AV_PROFILE_DTS_HD_HRA =         50;
public static final int AV_PROFILE_DTS_HD_MA =          60;
public static final int AV_PROFILE_DTS_EXPRESS =        70;
public static final int AV_PROFILE_DTS_HD_MA_X =        61;
public static final int AV_PROFILE_DTS_HD_MA_X_IMAX =   62;

public static final int AV_PROFILE_EAC3_DDP_ATMOS =         30;

public static final int AV_PROFILE_TRUEHD_ATMOS =           30;

public static final int AV_PROFILE_MPEG2_422 =           0;
public static final int AV_PROFILE_MPEG2_HIGH =          1;
public static final int AV_PROFILE_MPEG2_SS =            2;
public static final int AV_PROFILE_MPEG2_SNR_SCALABLE =  3;
public static final int AV_PROFILE_MPEG2_MAIN =          4;
public static final int AV_PROFILE_MPEG2_SIMPLE =        5;

public static final int AV_PROFILE_H264_CONSTRAINED =  (1<<9);  // 8+1; constraint_set1_flag
public static final int AV_PROFILE_H264_INTRA =        (1<<11); // 8+3; constraint_set3_flag

public static final int AV_PROFILE_H264_BASELINE =             66;
public static final int AV_PROFILE_H264_CONSTRAINED_BASELINE = (66|AV_PROFILE_H264_CONSTRAINED);
public static final int AV_PROFILE_H264_MAIN =                 77;
public static final int AV_PROFILE_H264_EXTENDED =             88;
public static final int AV_PROFILE_H264_HIGH =                 100;
public static final int AV_PROFILE_H264_HIGH_10 =              110;
public static final int AV_PROFILE_H264_HIGH_10_INTRA =        (110|AV_PROFILE_H264_INTRA);
public static final int AV_PROFILE_H264_MULTIVIEW_HIGH =       118;
public static final int AV_PROFILE_H264_HIGH_422 =             122;
public static final int AV_PROFILE_H264_HIGH_422_INTRA =       (122|AV_PROFILE_H264_INTRA);
public static final int AV_PROFILE_H264_STEREO_HIGH =          128;
public static final int AV_PROFILE_H264_HIGH_444 =             144;
public static final int AV_PROFILE_H264_HIGH_444_PREDICTIVE =  244;
public static final int AV_PROFILE_H264_HIGH_444_INTRA =       (244|AV_PROFILE_H264_INTRA);
public static final int AV_PROFILE_H264_CAVLC_444 =            44;

public static final int AV_PROFILE_VC1_SIMPLE =   0;
public static final int AV_PROFILE_VC1_MAIN =     1;
public static final int AV_PROFILE_VC1_COMPLEX =  2;
public static final int AV_PROFILE_VC1_ADVANCED = 3;

public static final int AV_PROFILE_MPEG4_SIMPLE =                     0;
public static final int AV_PROFILE_MPEG4_SIMPLE_SCALABLE =            1;
public static final int AV_PROFILE_MPEG4_CORE =                       2;
public static final int AV_PROFILE_MPEG4_MAIN =                       3;
public static final int AV_PROFILE_MPEG4_N_BIT =                      4;
public static final int AV_PROFILE_MPEG4_SCALABLE_TEXTURE =           5;
public static final int AV_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION =      6;
public static final int AV_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE =     7;
public static final int AV_PROFILE_MPEG4_HYBRID =                     8;
public static final int AV_PROFILE_MPEG4_ADVANCED_REAL_TIME =         9;
public static final int AV_PROFILE_MPEG4_CORE_SCALABLE =             10;
public static final int AV_PROFILE_MPEG4_ADVANCED_CODING =           11;
public static final int AV_PROFILE_MPEG4_ADVANCED_CORE =             12;
public static final int AV_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE = 13;
public static final int AV_PROFILE_MPEG4_SIMPLE_STUDIO =             14;
public static final int AV_PROFILE_MPEG4_ADVANCED_SIMPLE =           15;

public static final int AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 =   1;
public static final int AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 =   2;
public static final int AV_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION =  32768;
public static final int AV_PROFILE_JPEG2000_DCINEMA_2K =              3;
public static final int AV_PROFILE_JPEG2000_DCINEMA_4K =              4;

public static final int AV_PROFILE_VP9_0 =                            0;
public static final int AV_PROFILE_VP9_1 =                            1;
public static final int AV_PROFILE_VP9_2 =                            2;
public static final int AV_PROFILE_VP9_3 =                            3;

public static final int AV_PROFILE_HEVC_MAIN =                        1;
public static final int AV_PROFILE_HEVC_MAIN_10 =                     2;
public static final int AV_PROFILE_HEVC_MAIN_STILL_PICTURE =          3;
public static final int AV_PROFILE_HEVC_REXT =                        4;
public static final int AV_PROFILE_HEVC_SCC =                         9;

public static final int AV_PROFILE_VVC_MAIN_10 =                      1;
public static final int AV_PROFILE_VVC_MAIN_10_444 =                 33;

public static final int AV_PROFILE_AV1_MAIN =                         0;
public static final int AV_PROFILE_AV1_HIGH =                         1;
public static final int AV_PROFILE_AV1_PROFESSIONAL =                 2;

public static final int AV_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT =            0xc0;
public static final int AV_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT = 0xc1;
public static final int AV_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT =         0xc2;
public static final int AV_PROFILE_MJPEG_HUFFMAN_LOSSLESS =                0xc3;
public static final int AV_PROFILE_MJPEG_JPEG_LS =                         0xf7;

public static final int AV_PROFILE_SBC_MSBC =                         1;

public static final int AV_PROFILE_PRORES_PROXY =     0;
public static final int AV_PROFILE_PRORES_LT =        1;
public static final int AV_PROFILE_PRORES_STANDARD =  2;
public static final int AV_PROFILE_PRORES_HQ =        3;
public static final int AV_PROFILE_PRORES_4444 =      4;
public static final int AV_PROFILE_PRORES_XQ =        5;

public static final int AV_PROFILE_ARIB_PROFILE_A = 0;
public static final int AV_PROFILE_ARIB_PROFILE_C = 1;

public static final int AV_PROFILE_KLVA_SYNC =  0;
public static final int AV_PROFILE_KLVA_ASYNC = 1;

public static final int AV_PROFILE_EVC_BASELINE =             0;
public static final int AV_PROFILE_EVC_MAIN =                 1;


public static final int AV_LEVEL_UNKNOWN =                  -99;

/** enum AVFieldOrder */
public static final int
    AV_FIELD_UNKNOWN = 0,
    AV_FIELD_PROGRESSIVE = 1,
    /** Top coded_first, top displayed first */
    AV_FIELD_TT = 2,
    /** Bottom coded first, bottom displayed first */
    AV_FIELD_BB = 3,
    /** Top coded first, bottom displayed first */
    AV_FIELD_TB = 4,
    /** Bottom coded first, top displayed first */
    AV_FIELD_BT = 5;

/**
 * \ingroup lavc_decoding
 */
/** enum AVDiscard */
public static final int
    /* We leave some space between them for extensions (drop some
     * keyframes for intra-only or drop just some bidir frames). */
    /** discard nothing */
    AVDISCARD_NONE    = -16,
    /** discard useless packets like 0 size packets in avi */
    AVDISCARD_DEFAULT = 0,
    /** discard all non reference */
    AVDISCARD_NONREF  = 8,
    /** discard all bidirectional frames */
    AVDISCARD_BIDIR   = 16,
    /** discard all non intra frames */
    AVDISCARD_NONINTRA = 24,
    /** discard all frames except keyframes */
    AVDISCARD_NONKEY  = 32,
    /** discard all */
    AVDISCARD_ALL     = 48;

/** enum AVAudioServiceType */
public static final int
    AV_AUDIO_SERVICE_TYPE_MAIN              = 0,
    AV_AUDIO_SERVICE_TYPE_EFFECTS           = 1,
    AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2,
    AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED  = 3,
    AV_AUDIO_SERVICE_TYPE_DIALOGUE          = 4,
    AV_AUDIO_SERVICE_TYPE_COMMENTARY        = 5,
    AV_AUDIO_SERVICE_TYPE_EMERGENCY         = 6,
    AV_AUDIO_SERVICE_TYPE_VOICE_OVER        = 7,
    AV_AUDIO_SERVICE_TYPE_KARAOKE           = 8,
    /** Not part of ABI */
    AV_AUDIO_SERVICE_TYPE_NB = 9;
// Targeting ../avcodec/AVPanScan.java


// Targeting ../avcodec/AVCPBProperties.java



/**
 * Allocate a CPB properties structure and initialize its fields to default
 * values.
 *
 * @param size if non-NULL, the size of the allocated struct will be written
 *             here. This is useful for embedding it in side data.
 *
 * @return the newly allocated struct or NULL on failure
 */
@NoException public static native AVCPBProperties av_cpb_properties_alloc(@Cast("size_t*") SizeTPointer size);
// Targeting ../avcodec/AVProducerReferenceTime.java



/**
 * Encode extradata length to a buffer. Used by xiph codecs.
 *
 * @param s buffer to write to; must be at least (v/255+1) bytes long
 * @param v size of extradata in bytes
 * @return number of bytes written to the buffer.
 */
@NoException public static native @Cast("unsigned int") int av_xiphlacing(@Cast("unsigned char*") BytePointer s, @Cast("unsigned int") int v);
@NoException public static native @Cast("unsigned int") int av_xiphlacing(@Cast("unsigned char*") ByteBuffer s, @Cast("unsigned int") int v);
@NoException public static native @Cast("unsigned int") int av_xiphlacing(@Cast("unsigned char*") byte[] s, @Cast("unsigned int") int v);

// #endif // AVCODEC_DEFS_H


// Parsed from <libavcodec/codec_par.h>

/*
 * Codec parameters public API
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

// #ifndef AVCODEC_CODEC_PAR_H
// #define AVCODEC_CODEC_PAR_H

// #include <stdint.h>

// #include "libavutil/avutil.h"
// #include "libavutil/channel_layout.h"
// #include "libavutil/rational.h"
// #include "libavutil/pixfmt.h"

// #include "codec_id.h"
// #include "defs.h"
// #include "packet.h"
// Targeting ../avcodec/AVCodecParameters.java



/**
 * Allocate a new AVCodecParameters and set its fields to default values
 * (unknown/invalid/0). The returned struct must be freed with
 * avcodec_parameters_free().
 */
@NoException public static native AVCodecParameters avcodec_parameters_alloc();

/**
 * Free an AVCodecParameters instance and everything associated with it and
 * write NULL to the supplied pointer.
 */
@NoException public static native void avcodec_parameters_free(@Cast("AVCodecParameters**") PointerPointer par);
@NoException public static native void avcodec_parameters_free(@ByPtrPtr AVCodecParameters par);

/**
 * Copy the contents of src to dst. Any allocated fields in dst are freed and
 * replaced with newly allocated duplicates of the corresponding fields in src.
 *
 * @return >= 0 on success, a negative AVERROR code on failure.
 */
@NoException public static native int avcodec_parameters_copy(AVCodecParameters dst, @Const AVCodecParameters src);

/**
 * This function is the same as av_get_audio_frame_duration(), except it works
 * with AVCodecParameters instead of an AVCodecContext.
 */
@NoException public static native int av_get_audio_frame_duration2(AVCodecParameters par, int frame_bytes);

/**
 * \}
 */

// #endif // AVCODEC_CODEC_PAR_H


// Parsed from <libavcodec/packet.h>

/*
 * AVPacket public API
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

// #ifndef AVCODEC_PACKET_H
// #define AVCODEC_PACKET_H

// #include <stddef.h>
// #include <stdint.h>

// #include "libavutil/attributes.h"
// #include "libavutil/buffer.h"
// #include "libavutil/dict.h"
// #include "libavutil/rational.h"
// #include "libavutil/version.h"

// #include "libavcodec/version_major.h"

/**
 * \defgroup lavc_packet_side_data AVPacketSideData
 *
 * Types and functions for working with AVPacketSideData.
 * \{
 */
/** enum AVPacketSideDataType */
public static final int
    /**
     * An AV_PKT_DATA_PALETTE side data packet contains exactly AVPALETTE_SIZE
     * bytes worth of palette. This side data signals that a new palette is
     * present.
     */
    AV_PKT_DATA_PALETTE = 0,

    /**
     * The AV_PKT_DATA_NEW_EXTRADATA is used to notify the codec or the format
     * that the extradata buffer was changed and the receiving side should
     * act upon it appropriately. The new extradata is embedded in the side
     * data buffer and should be immediately used for processing the current
     * frame or packet.
     */
    AV_PKT_DATA_NEW_EXTRADATA = 1,

    /**
     * An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:
     * <pre>{@code
     * u32le param_flags
     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT)
     *     s32le channel_count
     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT)
     *     u64le channel_layout
     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE)
     *     s32le sample_rate
     * if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS)
     *     s32le width
     *     s32le height
     * }</pre>
     */
    AV_PKT_DATA_PARAM_CHANGE = 2,

    /**
     * An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of
     * structures with info about macroblocks relevant to splitting the
     * packet into smaller packets on macroblock edges (e.g. as for RFC 2190).
     * That is, it does not necessarily contain info about all macroblocks,
     * as long as the distance between macroblocks in the info is smaller
     * than the target payload size.
     * Each MB info structure is 12 bytes, and is laid out as follows:
     * <pre>{@code
     * u32le bit offset from the start of the packet
     * u8    current quantizer at the start of the macroblock
     * u8    GOB number
     * u16le macroblock address within the GOB
     * u8    horizontal MV predictor
     * u8    vertical MV predictor
     * u8    horizontal MV predictor for block number 3
     * u8    vertical MV predictor for block number 3
     * }</pre>
     */
    AV_PKT_DATA_H263_MB_INFO = 3,

    /**
     * This side data should be associated with an audio stream and contains
     * ReplayGain information in form of the AVReplayGain struct.
     */
    AV_PKT_DATA_REPLAYGAIN = 4,

    /**
     * This side data contains a 3x3 transformation matrix describing an affine
     * transformation that needs to be applied to the decoded video frames for
     * correct presentation.
     *
     * See libavutil/display.h for a detailed description of the data.
     */
    AV_PKT_DATA_DISPLAYMATRIX = 5,

    /**
     * This side data should be associated with a video stream and contains
     * Stereoscopic 3D information in form of the AVStereo3D struct.
     */
    AV_PKT_DATA_STEREO3D = 6,

    /**
     * This side data should be associated with an audio stream and corresponds
     * to enum AVAudioServiceType.
     */
    AV_PKT_DATA_AUDIO_SERVICE_TYPE = 7,

    /**
     * This side data contains quality related information from the encoder.
     * <pre>{@code
     * u32le quality factor of the compressed frame. Allowed range is between 1 (good) and FF_LAMBDA_MAX (bad).
     * u8    picture type
     * u8    error count
     * u16   reserved
     * u64le[error count] sum of squared differences between encoder in and output
     * }</pre>
     */
    AV_PKT_DATA_QUALITY_STATS = 8,

    /**
     * This side data contains an integer value representing the stream index
     * of a "fallback" track.  A fallback track indicates an alternate
     * track to use when the current track can not be decoded for some reason.
     * e.g. no decoder available for codec.
     */
    AV_PKT_DATA_FALLBACK_TRACK = 9,

    /**
     * This side data corresponds to the AVCPBProperties struct.
     */
    AV_PKT_DATA_CPB_PROPERTIES = 10,

    /**
     * Recommmends skipping the specified number of samples
     * <pre>{@code
     * u32le number of samples to skip from start of this packet
     * u32le number of samples to skip from end of this packet
     * u8    reason for start skip
     * u8    reason for end   skip (0=padding silence, 1=convergence)
     * }</pre>
     */
    AV_PKT_DATA_SKIP_SAMPLES = 11,

    /**
     * An AV_PKT_DATA_JP_DUALMONO side data packet indicates that
     * the packet may contain "dual mono" audio specific to Japanese DTV
     * and if it is true, recommends only the selected channel to be used.
     * <pre>{@code
     * u8    selected channels (0=main/left, 1=sub/right, 2=both)
     * }</pre>
     */
    AV_PKT_DATA_JP_DUALMONO = 12,

    /**
     * A list of zero terminated key/value strings. There is no end marker for
     * the list, so it is required to rely on the side data size to stop.
     */
    AV_PKT_DATA_STRINGS_METADATA = 13,

    /**
     * Subtitle event position
     * <pre>{@code
     * u32le x1
     * u32le y1
     * u32le x2
     * u32le y2
     * }</pre>
     */
    AV_PKT_DATA_SUBTITLE_POSITION = 14,

    /**
     * Data found in BlockAdditional element of matroska container. There is
     * no end marker for the data, so it is required to rely on the side data
     * size to recognize the end. 8 byte id (as found in BlockAddId) followed
     * by data.
     */
    AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL = 15,

    /**
     * The optional first identifier line of a WebVTT cue.
     */
    AV_PKT_DATA_WEBVTT_IDENTIFIER = 16,

    /**
     * The optional settings (rendering instructions) that immediately
     * follow the timestamp specifier of a WebVTT cue.
     */
    AV_PKT_DATA_WEBVTT_SETTINGS = 17,

    /**
     * A list of zero terminated key/value strings. There is no end marker for
     * the list, so it is required to rely on the side data size to stop. This
     * side data includes updated metadata which appeared in the stream.
     */
    AV_PKT_DATA_METADATA_UPDATE = 18,

    /**
     * MPEGTS stream ID as uint8_t, this is required to pass the stream ID
     * information from the demuxer to the corresponding muxer.
     */
    AV_PKT_DATA_MPEGTS_STREAM_ID = 19,

    /**
     * Mastering display metadata (based on SMPTE-2086:2014). This metadata
     * should be associated with a video stream and contains data in the form
     * of the AVMasteringDisplayMetadata struct.
     */
    AV_PKT_DATA_MASTERING_DISPLAY_METADATA = 20,

    /**
     * This side data should be associated with a video stream and corresponds
     * to the AVSphericalMapping structure.
     */
    AV_PKT_DATA_SPHERICAL = 21,

    /**
     * Content light level (based on CTA-861.3). This metadata should be
     * associated with a video stream and contains data in the form of the
     * AVContentLightMetadata struct.
     */
    AV_PKT_DATA_CONTENT_LIGHT_LEVEL = 22,

    /**
     * ATSC A53 Part 4 Closed Captions. This metadata should be associated with
     * a video stream. A53 CC bitstream is stored as uint8_t in AVPacketSideData.data.
     * The number of bytes of CC data is AVPacketSideData.size.
     */
    AV_PKT_DATA_A53_CC = 23,

    /**
     * This side data is encryption initialization data.
     * The format is not part of ABI, use av_encryption_init_info_* methods to
     * access.
     */
    AV_PKT_DATA_ENCRYPTION_INIT_INFO = 24,

    /**
     * This side data contains encryption info for how to decrypt the packet.
     * The format is not part of ABI, use av_encryption_info_* methods to access.
     */
    AV_PKT_DATA_ENCRYPTION_INFO = 25,

    /**
     * Active Format Description data consisting of a single byte as specified
     * in ETSI TS 101 154 using AVActiveFormatDescription enum.
     */
    AV_PKT_DATA_AFD = 26,

    /**
     * Producer Reference Time data corresponding to the AVProducerReferenceTime struct,
     * usually exported by some encoders (on demand through the prft flag set in the
     * AVCodecContext export_side_data field).
     */
    AV_PKT_DATA_PRFT = 27,

    /**
     * ICC profile data consisting of an opaque octet buffer following the
     * format described by ISO 15076-1.
     */
    AV_PKT_DATA_ICC_PROFILE = 28,

    /**
     * DOVI configuration
     * ref:
     * dolby-vision-bitstreams-within-the-iso-base-media-file-format-v2.1.2, section 2.2
     * dolby-vision-bitstreams-in-mpeg-2-transport-stream-multiplex-v1.2, section 3.3
     * Tags are stored in struct AVDOVIDecoderConfigurationRecord.
     */
    AV_PKT_DATA_DOVI_CONF = 29,

    /**
     * Timecode which conforms to SMPTE ST 12-1:2014. The data is an array of 4 uint32_t
     * where the first uint32_t describes how many (1-3) of the other timecodes are used.
     * The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()
     * function in libavutil/timecode.h.
     */
    AV_PKT_DATA_S12M_TIMECODE = 30,

    /**
     * HDR10+ dynamic metadata associated with a video frame. The metadata is in
     * the form of the AVDynamicHDRPlus struct and contains
     * information for color volume transform - application 4 of
     * SMPTE 2094-40:2016 standard.
     */
    AV_PKT_DATA_DYNAMIC_HDR10_PLUS = 31,

    /**
     * The number of side data types.
     * This is not part of the public API/ABI in the sense that it may
     * change when new side data types are added.
     * This must stay the last enum value.
     * If its value becomes huge, some code using it
     * needs to be updated as it assumes it to be smaller than other limits.
     */
    AV_PKT_DATA_NB = 32;

public static final int AV_PKT_DATA_QUALITY_FACTOR = AV_PKT_DATA_QUALITY_STATS;
// Targeting ../avcodec/AVPacketSideData.java



/**
 * Allocate a new packet side data.
 *
 * @param sd    pointer to an array of side data to which the side data should
 *              be added. *sd may be NULL, in which case the array will be
 *              initialized.
 * @param nb_sd pointer to an integer containing the number of entries in
 *              the array. The integer value will be increased by 1 on success.
 * @param type  side data type
 * @param size  desired side data size
 * @param flags currently unused. Must be zero
 *
 * @return pointer to freshly allocated side data on success, or NULL otherwise.
 */
@NoException public static native AVPacketSideData av_packet_side_data_new(@Cast("AVPacketSideData**") PointerPointer psd, IntPointer pnb_sd,
                                          @Cast("AVPacketSideDataType") int type,
                                          @Cast("size_t") long size, int flags);
@NoException public static native AVPacketSideData av_packet_side_data_new(@ByPtrPtr AVPacketSideData psd, IntPointer pnb_sd,
                                          @Cast("AVPacketSideDataType") int type,
                                          @Cast("size_t") long size, int flags);
@NoException public static native AVPacketSideData av_packet_side_data_new(@ByPtrPtr AVPacketSideData psd, IntBuffer pnb_sd,
                                          @Cast("AVPacketSideDataType") int type,
                                          @Cast("size_t") long size, int flags);
@NoException public static native AVPacketSideData av_packet_side_data_new(@ByPtrPtr AVPacketSideData psd, int[] pnb_sd,
                                          @Cast("AVPacketSideDataType") int type,
                                          @Cast("size_t") long size, int flags);

/**
 * Wrap existing data as packet side data.
 *
 * @param sd    pointer to an array of side data to which the side data should
 *              be added. *sd may be NULL, in which case the array will be
 *              initialized
 * @param nb_sd pointer to an integer containing the number of entries in
 *              the array. The integer value will be increased by 1 on success.
 * @param type  side data type
 * @param data  a data array. It must be allocated with the av_malloc() family
 *              of functions. The ownership of the data is transferred to the
 *              side data array on success
 * @param size  size of the data array
 * @param flags currently unused. Must be zero
 *
 * @return pointer to freshly allocated side data on success, or NULL otherwise
 *         On failure, the side data array is unchanged and the data remains
 *         owned by the caller.
 */
@NoException public static native AVPacketSideData av_packet_side_data_add(@Cast("AVPacketSideData**") PointerPointer sd, IntPointer nb_sd,
                                          @Cast("AVPacketSideDataType") int type,
                                          Pointer data, @Cast("size_t") long size, int flags);
@NoException public static native AVPacketSideData av_packet_side_data_add(@ByPtrPtr AVPacketSideData sd, IntPointer nb_sd,
                                          @Cast("AVPacketSideDataType") int type,
                                          Pointer data, @Cast("size_t") long size, int flags);
@NoException public static native AVPacketSideData av_packet_side_data_add(@ByPtrPtr AVPacketSideData sd, IntBuffer nb_sd,
                                          @Cast("AVPacketSideDataType") int type,
                                          Pointer data, @Cast("size_t") long size, int flags);
@NoException public static native AVPacketSideData av_packet_side_data_add(@ByPtrPtr AVPacketSideData sd, int[] nb_sd,
                                          @Cast("AVPacketSideDataType") int type,
                                          Pointer data, @Cast("size_t") long size, int flags);

/**
 * Get side information from a side data array.
 *
 * @param sd    the array from which the side data should be fetched
 * @param nb_sd value containing the number of entries in the array.
 * @param type  desired side information type
 *
 * @return pointer to side data if present or NULL otherwise
 */
@NoException public static native @Const AVPacketSideData av_packet_side_data_get(@Const AVPacketSideData sd,
                                                int nb_sd,
                                                @Cast("AVPacketSideDataType") int type);

/**
 * Remove side data of the given type from a side data array.
 *
 * @param sd    the array from which the side data should be removed
 * @param nb_sd pointer to an integer containing the number of entries in
 *              the array. Will be reduced by the amount of entries removed
 *              upon return
 * @param type  side information type
 */
@NoException public static native void av_packet_side_data_remove(AVPacketSideData sd, IntPointer nb_sd,
                                @Cast("AVPacketSideDataType") int type);
@NoException public static native void av_packet_side_data_remove(AVPacketSideData sd, IntBuffer nb_sd,
                                @Cast("AVPacketSideDataType") int type);
@NoException public static native void av_packet_side_data_remove(AVPacketSideData sd, int[] nb_sd,
                                @Cast("AVPacketSideDataType") int type);

/**
 * Convenience function to free all the side data stored in an array, and
 * the array itself.
 *
 * @param sd    pointer to array of side data to free. Will be set to NULL
 *              upon return.
 * @param nb_sd pointer to an integer containing the number of entries in
 *              the array. Will be set to 0 upon return.
 */
@NoException public static native void av_packet_side_data_free(@Cast("AVPacketSideData**") PointerPointer sd, IntPointer nb_sd);
@NoException public static native void av_packet_side_data_free(@ByPtrPtr AVPacketSideData sd, IntPointer nb_sd);
@NoException public static native void av_packet_side_data_free(@ByPtrPtr AVPacketSideData sd, IntBuffer nb_sd);
@NoException public static native void av_packet_side_data_free(@ByPtrPtr AVPacketSideData sd, int[] nb_sd);

@NoException public static native @Cast("const char*") BytePointer av_packet_side_data_name(@Cast("AVPacketSideDataType") int type);
// Targeting ../avcodec/AVPacket.java


// Targeting ../avcodec/AVPacketList.java


// #endif

/** The packet contains a keyframe */
public static final int AV_PKT_FLAG_KEY =     0x0001;
/** The packet content is corrupted */
public static final int AV_PKT_FLAG_CORRUPT = 0x0002;
/**
 * Flag is used to discard packets which are required to maintain valid
 * decoder state but are not required for output and should be dropped
 * after decoding.
 **/
public static final int AV_PKT_FLAG_DISCARD =   0x0004;
/**
 * The packet comes from a trusted source.
 *
 * Otherwise-unsafe constructs such as arbitrary pointers to data
 * outside the packet may be followed.
 */
public static final int AV_PKT_FLAG_TRUSTED =   0x0008;
/**
 * Flag is used to indicate packets that contain frames that can
 * be discarded by the decoder.  I.e. Non-reference frames.
 */
public static final int AV_PKT_FLAG_DISPOSABLE = 0x0010;

/** enum AVSideDataParamChangeFlags */
public static final int
// #if FF_API_OLD_CHANNEL_LAYOUT
    /**
     * @deprecated those are not used by any decoder
     */
    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT  = 0x0001,
    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 0x0002,
// #endif
    AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE    = 0x0004,
    AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS     = 0x0008;

/**
 * Allocate an AVPacket and set its fields to default values.  The resulting
 * struct must be freed using av_packet_free().
 *
 * @return An AVPacket filled with default values or NULL on failure.
 *
 * \note this only allocates the AVPacket itself, not the data buffers. Those
 * must be allocated through other means such as av_new_packet.
 *
 * @see av_new_packet
 */
@NoException public static native AVPacket av_packet_alloc();

/**
 * Create a new packet that references the same data as src.
 *
 * This is a shortcut for av_packet_alloc()+av_packet_ref().
 *
 * @return newly created AVPacket on success, NULL on error.
 *
 * @see av_packet_alloc
 * @see av_packet_ref
 */
@NoException public static native AVPacket av_packet_clone(@Const AVPacket src);

/**
 * Free the packet, if the packet is reference counted, it will be
 * unreferenced first.
 *
 * @param pkt packet to be freed. The pointer will be set to NULL.
 * \note passing NULL is a no-op.
 */
@NoException public static native void av_packet_free(@Cast("AVPacket**") PointerPointer pkt);
@NoException public static native void av_packet_free(@ByPtrPtr AVPacket pkt);

// #if FF_API_INIT_PACKET
/**
 * Initialize optional fields of a packet with default values.
 *
 * Note, this does not touch the data and size members, which have to be
 * initialized separately.
 *
 * @param pkt packet
 *
 * @see av_packet_alloc
 * @see av_packet_unref
 *
 * @deprecated This function is deprecated. Once it's removed,
               sizeof(AVPacket) will not be a part of the ABI anymore.
 */
@NoException public static native @Deprecated void av_init_packet(AVPacket pkt);
// #endif

/**
 * Allocate the payload of a packet and initialize its fields with
 * default values.
 *
 * @param pkt packet
 * @param size wanted payload size
 * @return 0 if OK, AVERROR_xxx otherwise
 */
@NoException public static native int av_new_packet(AVPacket pkt, int size);

/**
 * Reduce packet size, correctly zeroing padding
 *
 * @param pkt packet
 * @param size new size
 */
@NoException public static native void av_shrink_packet(AVPacket pkt, int size);

/**
 * Increase packet size, correctly zeroing padding
 *
 * @param pkt packet
 * @param grow_by number of bytes by which to increase the size of the packet
 */
@NoException public static native int av_grow_packet(AVPacket pkt, int grow_by);

/**
 * Initialize a reference-counted packet from av_malloc()ed data.
 *
 * @param pkt packet to be initialized. This function will set the data, size,
 *        and buf fields, all others are left untouched.
 * @param data Data allocated by av_malloc() to be used as packet data. If this
 *        function returns successfully, the data is owned by the underlying AVBuffer.
 *        The caller may not access the data through other means.
 * @param size size of data in bytes, without the padding. I.e. the full buffer
 *        size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.
 *
 * @return 0 on success, a negative AVERROR on error
 */
@NoException public static native int av_packet_from_data(AVPacket pkt, @Cast("uint8_t*") BytePointer data, int size);
@NoException public static native int av_packet_from_data(AVPacket pkt, @Cast("uint8_t*") ByteBuffer data, int size);
@NoException public static native int av_packet_from_data(AVPacket pkt, @Cast("uint8_t*") byte[] data, int size);

/**
 * Allocate new information of a packet.
 *
 * @param pkt packet
 * @param type side information type
 * @param size side information size
 * @return pointer to fresh allocated data or NULL otherwise
 */
@NoException public static native @Cast("uint8_t*") BytePointer av_packet_new_side_data(AVPacket pkt, @Cast("AVPacketSideDataType") int type,
                                 @Cast("size_t") long size);

/**
 * Wrap an existing array as a packet side data.
 *
 * @param pkt packet
 * @param type side information type
 * @param data the side data array. It must be allocated with the av_malloc()
 *             family of functions. The ownership of the data is transferred to
 *             pkt.
 * @param size side information size
 * @return a non-negative number on success, a negative AVERROR code on
 *         failure. On failure, the packet is unchanged and the data remains
 *         owned by the caller.
 */
@NoException public static native int av_packet_add_side_data(AVPacket pkt, @Cast("AVPacketSideDataType") int type,
                            @Cast("uint8_t*") BytePointer data, @Cast("size_t") long size);
@NoException public static native int av_packet_add_side_data(AVPacket pkt, @Cast("AVPacketSideDataType") int type,
                            @Cast("uint8_t*") ByteBuffer data, @Cast("size_t") long size);
@NoException public static native int av_packet_add_side_data(AVPacket pkt, @Cast("AVPacketSideDataType") int type,
                            @Cast("uint8_t*") byte[] data, @Cast("size_t") long size);

/**
 * Shrink the already allocated side data buffer
 *
 * @param pkt packet
 * @param type side information type
 * @param size new side information size
 * @return 0 on success, < 0 on failure
 */
@NoException public static native int av_packet_shrink_side_data(AVPacket pkt, @Cast("AVPacketSideDataType") int type,
                               @Cast("size_t") long size);

/**
 * Get side information from packet.
 *
 * @param pkt packet
 * @param type desired side information type
 * @param size If supplied, *size will be set to the size of the side data
 *             or to zero if the desired side data is not present.
 * @return pointer to data if present or NULL otherwise
 */
@NoException public static native @Cast("uint8_t*") BytePointer av_packet_get_side_data(@Const AVPacket pkt, @Cast("AVPacketSideDataType") int type,
                                 @Cast("size_t*") SizeTPointer size);

/**
 * Pack a dictionary for use in side_data.
 *
 * @param dict The dictionary to pack.
 * @param size pointer to store the size of the returned data
 * @return pointer to data if successful, NULL otherwise
 */
@NoException public static native @Cast("uint8_t*") BytePointer av_packet_pack_dictionary(AVDictionary dict, @Cast("size_t*") SizeTPointer size);
/**
 * Unpack a dictionary from side_data.
 *
 * @param data data from side_data
 * @param size size of the data
 * @param dict the metadata storage dictionary
 * @return 0 on success, < 0 on failure
 */
@NoException public static native int av_packet_unpack_dictionary(@Cast("const uint8_t*") BytePointer data, @Cast("size_t") long size,
                                @Cast("AVDictionary**") PointerPointer dict);
@NoException public static native int av_packet_unpack_dictionary(@Cast("const uint8_t*") BytePointer data, @Cast("size_t") long size,
                                @ByPtrPtr AVDictionary dict);
@NoException public static native int av_packet_unpack_dictionary(@Cast("const uint8_t*") ByteBuffer data, @Cast("size_t") long size,
                                @ByPtrPtr AVDictionary dict);
@NoException public static native int av_packet_unpack_dictionary(@Cast("const uint8_t*") byte[] data, @Cast("size_t") long size,
                                @ByPtrPtr AVDictionary dict);

/**
 * Convenience function to free all the side data stored.
 * All the other fields stay untouched.
 *
 * @param pkt packet
 */
@NoException public static native void av_packet_free_side_data(AVPacket pkt);

/**
 * Setup a new reference to the data described by a given packet
 *
 * If src is reference-counted, setup dst as a new reference to the
 * buffer in src. Otherwise allocate a new buffer in dst and copy the
 * data from src into it.
 *
 * All the other fields are copied from src.
 *
 * @see av_packet_unref
 *
 * @param dst Destination packet. Will be completely overwritten.
 * @param src Source packet
 *
 * @return 0 on success, a negative AVERROR on error. On error, dst
 *         will be blank (as if returned by av_packet_alloc()).
 */
@NoException public static native int av_packet_ref(AVPacket dst, @Const AVPacket src);

/**
 * Wipe the packet.
 *
 * Unreference the buffer referenced by the packet and reset the
 * remaining packet fields to their default values.
 *
 * @param pkt The packet to be unreferenced.
 */
@NoException public static native void av_packet_unref(AVPacket pkt);

/**
 * Move every field in src to dst and reset src.
 *
 * @see av_packet_unref
 *
 * @param src Source packet, will be reset
 * @param dst Destination packet
 */
@NoException public static native void av_packet_move_ref(AVPacket dst, AVPacket src);

/**
 * Copy only "properties" fields from src to dst.
 *
 * Properties for the purpose of this function are all the fields
 * beside those related to the packet data (buf, data, size)
 *
 * @param dst Destination packet
 * @param src Source packet
 *
 * @return 0 on success AVERROR on failure.
 */
@NoException public static native int av_packet_copy_props(AVPacket dst, @Const AVPacket src);

/**
 * Ensure the data described by a given packet is reference counted.
 *
 * \note This function does not ensure that the reference will be writable.
 *       Use av_packet_make_writable instead for that purpose.
 *
 * @see av_packet_ref
 * @see av_packet_make_writable
 *
 * @param pkt packet whose data should be made reference counted.
 *
 * @return 0 on success, a negative AVERROR on error. On failure, the
 *         packet is unchanged.
 */
@NoException public static native int av_packet_make_refcounted(AVPacket pkt);

/**
 * Create a writable reference for the data described by a given packet,
 * avoiding data copy if possible.
 *
 * @param pkt Packet whose data should be made writable.
 *
 * @return 0 on success, a negative AVERROR on failure. On failure, the
 *         packet is unchanged.
 */
@NoException public static native int av_packet_make_writable(AVPacket pkt);

/**
 * Convert valid timing fields (timestamps / durations) in a packet from one
 * timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be
 * ignored.
 *
 * @param pkt packet on which the conversion will be performed
 * @param tb_src source timebase, in which the timing fields in pkt are
 *               expressed
 * @param tb_dst destination timebase, to which the timing fields will be
 *               converted
 */
@NoException public static native void av_packet_rescale_ts(AVPacket pkt, @ByVal AVRational tb_src, @ByVal AVRational tb_dst);

/**
 * \}
 */

// #endif // AVCODEC_PACKET_H


// Parsed from <libavcodec/bsf.h>

/*
 * Bitstream filters public API
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

// #ifndef AVCODEC_BSF_H
// #define AVCODEC_BSF_H

// #include "libavutil/dict.h"
// #include "libavutil/log.h"
// #include "libavutil/rational.h"

// #include "codec_id.h"
// #include "codec_par.h"
// #include "packet.h"
// Targeting ../avcodec/AVBSFContext.java


// Targeting ../avcodec/AVBitStreamFilter.java



/**
 * @return a bitstream filter with the specified name or NULL if no such
 *         bitstream filter exists.
 */
@NoException public static native @Const AVBitStreamFilter av_bsf_get_by_name(@Cast("const char*") BytePointer name);
@NoException public static native @Const AVBitStreamFilter av_bsf_get_by_name(String name);

/**
 * Iterate over all registered bitstream filters.
 *
 * @param opaque a pointer where libavcodec will store the iteration state. Must
 *               point to NULL to start the iteration.
 *
 * @return the next registered bitstream filter or NULL when the iteration is
 *         finished
 */
@NoException public static native @Const AVBitStreamFilter av_bsf_iterate(@Cast("void**") PointerPointer opaque);
@NoException public static native @Const AVBitStreamFilter av_bsf_iterate(@Cast("void**") @ByPtrPtr Pointer opaque);

/**
 * Allocate a context for a given bitstream filter. The caller must fill in the
 * context parameters as described in the documentation and then call
 * av_bsf_init() before sending any data to the filter.
 *
 * @param filter the filter for which to allocate an instance.
 * @param ctx [out] a pointer into which the pointer to the newly-allocated context
 *                 will be written. It must be freed with av_bsf_free() after the
 *                 filtering is done.
 *
 * @return 0 on success, a negative AVERROR code on failure
 */
@NoException public static native int av_bsf_alloc(@Const AVBitStreamFilter filter, @Cast("AVBSFContext**") PointerPointer ctx);
@NoException public static native int av_bsf_alloc(@Const AVBitStreamFilter filter, @ByPtrPtr AVBSFContext ctx);

/**
 * Prepare the filter for use, after all the parameters and options have been
 * set.
 *
 * @param ctx a AVBSFContext previously allocated with av_bsf_alloc()
 */
@NoException public static native int av_bsf_init(AVBSFContext ctx);

/**
 * Submit a packet for filtering.
 *
 * After sending each packet, the filter must be completely drained by calling
 * av_bsf_receive_packet() repeatedly until it returns AVERROR(EAGAIN) or
 * AVERROR_EOF.
 *
 * @param ctx an initialized AVBSFContext
 * @param pkt the packet to filter. The bitstream filter will take ownership of
 * the packet and reset the contents of pkt. pkt is not touched if an error occurs.
 * If pkt is empty (i.e. NULL, or pkt->data is NULL and pkt->side_data_elems zero),
 * it signals the end of the stream (i.e. no more non-empty packets will be sent;
 * sending more empty packets does nothing) and will cause the filter to output
 * any packets it may have buffered internally.
 *
 * @return
 *  - 0 on success.
 *  - AVERROR(EAGAIN) if packets need to be retrieved from the filter (using
 *    av_bsf_receive_packet()) before new input can be consumed.
 *  - Another negative AVERROR value if an error occurs.
 */
@NoException public static native int av_bsf_send_packet(AVBSFContext ctx, AVPacket pkt);

/**
 * Retrieve a filtered packet.
 *
 * @param ctx an initialized AVBSFContext
 * @param pkt [out] this struct will be filled with the contents of the filtered
 *                 packet. It is owned by the caller and must be freed using
 *                 av_packet_unref() when it is no longer needed.
 *                 This parameter should be "clean" (i.e. freshly allocated
 *                 with av_packet_alloc() or unreffed with av_packet_unref())
 *                 when this function is called. If this function returns
 *                 successfully, the contents of pkt will be completely
 *                 overwritten by the returned data. On failure, pkt is not
 *                 touched.
 *
 * @return
 *  - 0 on success.
 *  - AVERROR(EAGAIN) if more packets need to be sent to the filter (using
 *    av_bsf_send_packet()) to get more output.
 *  - AVERROR_EOF if there will be no further output from the filter.
 *  - Another negative AVERROR value if an error occurs.
 *
 * \note one input packet may result in several output packets, so after sending
 * a packet with av_bsf_send_packet(), this function needs to be called
 * repeatedly until it stops returning 0. It is also possible for a filter to
 * output fewer packets than were sent to it, so this function may return
 * AVERROR(EAGAIN) immediately after a successful av_bsf_send_packet() call.
 */
@NoException public static native int av_bsf_receive_packet(AVBSFContext ctx, AVPacket pkt);

/**
 * Reset the internal bitstream filter state. Should be called e.g. when seeking.
 */
@NoException public static native void av_bsf_flush(AVBSFContext ctx);

/**
 * Free a bitstream filter context and everything associated with it; write NULL
 * into the supplied pointer.
 */
@NoException public static native void av_bsf_free(@Cast("AVBSFContext**") PointerPointer ctx);
@NoException public static native void av_bsf_free(@ByPtrPtr AVBSFContext ctx);

/**
 * Get the AVClass for AVBSFContext. It can be used in combination with
 * AV_OPT_SEARCH_FAKE_OBJ for examining options.
 *
 * @see av_opt_find().
 */
@NoException public static native @Const AVClass av_bsf_get_class();
// Targeting ../avcodec/AVBSFList.java



/**
 * Allocate empty list of bitstream filters.
 * The list must be later freed by av_bsf_list_free()
 * or finalized by av_bsf_list_finalize().
 *
 * @return Pointer to \ref AVBSFList on success, NULL in case of failure
 */
@NoException public static native AVBSFList av_bsf_list_alloc();

/**
 * Free list of bitstream filters.
 *
 * @param lst Pointer to pointer returned by av_bsf_list_alloc()
 */
@NoException public static native void av_bsf_list_free(@Cast("AVBSFList**") PointerPointer lst);
@NoException public static native void av_bsf_list_free(@ByPtrPtr AVBSFList lst);

/**
 * Append bitstream filter to the list of bitstream filters.
 *
 * @param lst List to append to
 * @param bsf Filter context to be appended
 *
 * @return >=0 on success, negative AVERROR in case of failure
 */
@NoException public static native int av_bsf_list_append(AVBSFList lst, AVBSFContext bsf);

/**
 * Construct new bitstream filter context given it's name and options
 * and append it to the list of bitstream filters.
 *
 * @param lst      List to append to
 * @param bsf_name Name of the bitstream filter
 * @param options  Options for the bitstream filter, can be set to NULL
 *
 * @return >=0 on success, negative AVERROR in case of failure
 */
@NoException public static native int av_bsf_list_append2(AVBSFList lst, @Cast("const char*") BytePointer bsf_name, @Cast("AVDictionary**") PointerPointer options);
@NoException public static native int av_bsf_list_append2(AVBSFList lst, @Cast("const char*") BytePointer bsf_name, @ByPtrPtr AVDictionary options);
@NoException public static native int av_bsf_list_append2(AVBSFList lst, String bsf_name, @ByPtrPtr AVDictionary options);
/**
 * Finalize list of bitstream filters.
 *
 * This function will transform \ref AVBSFList to single \ref AVBSFContext,
 * so the whole chain of bitstream filters can be treated as single filter
 * freshly allocated by av_bsf_alloc().
 * If the call is successful, \ref AVBSFList structure is freed and lst
 * will be set to NULL. In case of failure, caller is responsible for
 * freeing the structure by av_bsf_list_free()
 *
 * @param      lst Filter list structure to be transformed
 * @param bsf [out] Pointer to be set to newly created \ref AVBSFContext structure
 *                 representing the chain of bitstream filters
 *
 * @return >=0 on success, negative AVERROR in case of failure
 */
@NoException public static native int av_bsf_list_finalize(@Cast("AVBSFList**") PointerPointer lst, @Cast("AVBSFContext**") PointerPointer bsf);
@NoException public static native int av_bsf_list_finalize(@ByPtrPtr AVBSFList lst, @ByPtrPtr AVBSFContext bsf);

/**
 * Parse string describing list of bitstream filters and create single
 * \ref AVBSFContext describing the whole chain of bitstream filters.
 * Resulting \ref AVBSFContext can be treated as any other \ref AVBSFContext freshly
 * allocated by av_bsf_alloc().
 *
 * @param      str String describing chain of bitstream filters in format
 *                 {@code bsf1[=opt1=val1:opt2=val2][,bsf2]}
 * @param bsf [out] Pointer to be set to newly created \ref AVBSFContext structure
 *                 representing the chain of bitstream filters
 *
 * @return >=0 on success, negative AVERROR in case of failure
 */
@NoException public static native int av_bsf_list_parse_str(@Cast("const char*") BytePointer str, @Cast("AVBSFContext**") PointerPointer bsf);
@NoException public static native int av_bsf_list_parse_str(@Cast("const char*") BytePointer str, @ByPtrPtr AVBSFContext bsf);
@NoException public static native int av_bsf_list_parse_str(String str, @ByPtrPtr AVBSFContext bsf);

/**
 * Get null/pass-through bitstream filter.
 *
 * @param bsf [out] Pointer to be set to new instance of pass-through bitstream filter
 *
 * @return
 */
@NoException public static native int av_bsf_get_null_filter(@Cast("AVBSFContext**") PointerPointer bsf);
@NoException public static native int av_bsf_get_null_filter(@ByPtrPtr AVBSFContext bsf);

/**
 * \}
 */

// #endif // AVCODEC_BSF_H


// Parsed from <libavcodec/codec.h>

/*
 * AVCodec public API
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

// #ifndef AVCODEC_CODEC_H
// #define AVCODEC_CODEC_H

// #include <stdint.h>

// #include "libavutil/avutil.h"
// #include "libavutil/hwcontext.h"
// #include "libavutil/log.h"
// #include "libavutil/pixfmt.h"
// #include "libavutil/rational.h"
// #include "libavutil/samplefmt.h"

// #include "libavcodec/codec_id.h"
// #include "libavcodec/version_major.h"

/**
 * \addtogroup lavc_core
 * \{
 */

/**
 * Decoder can use draw_horiz_band callback.
 */
public static final int AV_CODEC_CAP_DRAW_HORIZ_BAND =     (1 <<  0);
/**
 * Codec uses get_buffer() or get_encode_buffer() for allocating buffers and
 * supports custom allocators.
 * If not set, it might not use get_buffer() or get_encode_buffer() at all, or
 * use operations that assume the buffer was allocated by
 * avcodec_default_get_buffer2 or avcodec_default_get_encode_buffer.
 */
public static final int AV_CODEC_CAP_DR1 =                 (1 <<  1);
/**
 * Encoder or decoder requires flushing with NULL input at the end in order to
 * give the complete and correct output.
 *
 * NOTE: If this flag is not set, the codec is guaranteed to never be fed with
 *       with NULL data. The user can still send NULL data to the public encode
 *       or decode function, but libavcodec will not pass it along to the codec
 *       unless this flag is set.
 *
 * Decoders:
 * The decoder has a non-zero delay and needs to be fed with avpkt->data=NULL,
 * avpkt->size=0 at the end to get the delayed data until the decoder no longer
 * returns frames.
 *
 * Encoders:
 * The encoder needs to be fed with NULL data at the end of encoding until the
 * encoder no longer returns data.
 *
 * NOTE: For encoders implementing the AVCodec.encode2() function, setting this
 *       flag also means that the encoder must set the pts and duration for
 *       each output packet. If this flag is not set, the pts and duration will
 *       be determined by libavcodec from the input frame.
 */
public static final int AV_CODEC_CAP_DELAY =               (1 <<  5);
/**
 * Codec can be fed a final frame with a smaller size.
 * This can be used to prevent truncation of the last audio samples.
 */
public static final int AV_CODEC_CAP_SMALL_LAST_FRAME =    (1 <<  6);

// #if FF_API_SUBFRAMES
/**
 * Codec can output multiple frames per AVPacket
 * Normally demuxers return one frame at a time, demuxers which do not do
 * are connected to a parser to split what they return into proper frames.
 * This flag is reserved to the very rare category of codecs which have a
 * bitstream that cannot be split into frames without timeconsuming
 * operations like full decoding. Demuxers carrying such bitstreams thus
 * may return multiple frames in a packet. This has many disadvantages like
 * prohibiting stream copy in many cases thus it should only be considered
 * as a last resort.
 */
public static final int AV_CODEC_CAP_SUBFRAMES =           (1 <<  8);
// #endif

/**
 * Codec is experimental and is thus avoided in favor of non experimental
 * encoders
 */
public static final int AV_CODEC_CAP_EXPERIMENTAL =        (1 <<  9);
/**
 * Codec should fill in channel configuration and samplerate instead of container
 */
public static final int AV_CODEC_CAP_CHANNEL_CONF =        (1 << 10);
/**
 * Codec supports frame-level multithreading.
 */
public static final int AV_CODEC_CAP_FRAME_THREADS =       (1 << 12);
/**
 * Codec supports slice-based (or partition-based) multithreading.
 */
public static final int AV_CODEC_CAP_SLICE_THREADS =       (1 << 13);
/**
 * Codec supports changed parameters at any point.
 */
public static final int AV_CODEC_CAP_PARAM_CHANGE =        (1 << 14);
/**
 * Codec supports multithreading through a method other than slice- or
 * frame-level multithreading. Typically this marks wrappers around
 * multithreading-capable external libraries.
 */
public static final int AV_CODEC_CAP_OTHER_THREADS =       (1 << 15);
/**
 * Audio encoder supports receiving a different number of samples in each call.
 */
public static final int AV_CODEC_CAP_VARIABLE_FRAME_SIZE = (1 << 16);
/**
 * Decoder is not a preferred choice for probing.
 * This indicates that the decoder is not a good choice for probing.
 * It could for example be an expensive to spin up hardware decoder,
 * or it could simply not provide a lot of useful information about
 * the stream.
 * A decoder marked with this flag should only be used as last resort
 * choice for probing.
 */
public static final int AV_CODEC_CAP_AVOID_PROBING =       (1 << 17);

/**
 * Codec is backed by a hardware implementation. Typically used to
 * identify a non-hwaccel hardware decoder. For information about hwaccels, use
 * avcodec_get_hw_config() instead.
 */
public static final int AV_CODEC_CAP_HARDWARE =            (1 << 18);

/**
 * Codec is potentially backed by a hardware implementation, but not
 * necessarily. This is used instead of AV_CODEC_CAP_HARDWARE, if the
 * implementation provides some sort of internal fallback.
 */
public static final int AV_CODEC_CAP_HYBRID =              (1 << 19);

/**
 * This encoder can reorder user opaque values from input AVFrames and return
 * them with corresponding output packets.
 * @see AV_CODEC_FLAG_COPY_OPAQUE
 */
public static final int AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE = (1 << 20);

/**
 * This encoder can be flushed using avcodec_flush_buffers(). If this flag is
 * not set, the encoder must be closed and reopened to ensure that no frames
 * remain pending.
 */
public static final int AV_CODEC_CAP_ENCODER_FLUSH =   (1 << 21);

/**
 * The encoder is able to output reconstructed frame data, i.e. raw frames that
 * would be produced by decoding the encoded bitstream.
 *
 * Reconstructed frame output is enabled by the AV_CODEC_FLAG_RECON_FRAME flag.
 */
public static final int AV_CODEC_CAP_ENCODER_RECON_FRAME = (1 << 22);
// Targeting ../avcodec/AVProfile.java


// Targeting ../avcodec/AVCodec.java



/**
 * Iterate over all registered codecs.
 *
 * @param opaque a pointer where libavcodec will store the iteration state. Must
 *               point to NULL to start the iteration.
 *
 * @return the next registered codec or NULL when the iteration is
 *         finished
 */
@NoException public static native @Const AVCodec av_codec_iterate(@Cast("void**") PointerPointer opaque);
@NoException public static native @Const AVCodec av_codec_iterate(@Cast("void**") @ByPtrPtr Pointer opaque);

/**
 * Find a registered decoder with a matching codec ID.
 *
 * @param id AVCodecID of the requested decoder
 * @return A decoder if one was found, NULL otherwise.
 */
@NoException public static native @Const AVCodec avcodec_find_decoder(@Cast("AVCodecID") int id);

/**
 * Find a registered decoder with the specified name.
 *
 * @param name name of the requested decoder
 * @return A decoder if one was found, NULL otherwise.
 */
@NoException public static native @Const AVCodec avcodec_find_decoder_by_name(@Cast("const char*") BytePointer name);
@NoException public static native @Const AVCodec avcodec_find_decoder_by_name(String name);

/**
 * Find a registered encoder with a matching codec ID.
 *
 * @param id AVCodecID of the requested encoder
 * @return An encoder if one was found, NULL otherwise.
 */
@NoException public static native @Const AVCodec avcodec_find_encoder(@Cast("AVCodecID") int id);

/**
 * Find a registered encoder with the specified name.
 *
 * @param name name of the requested encoder
 * @return An encoder if one was found, NULL otherwise.
 */
@NoException public static native @Const AVCodec avcodec_find_encoder_by_name(@Cast("const char*") BytePointer name);
@NoException public static native @Const AVCodec avcodec_find_encoder_by_name(String name);
/**
 * @return a non-zero number if codec is an encoder, zero otherwise
 */
@NoException public static native int av_codec_is_encoder(@Const AVCodec codec);

/**
 * @return a non-zero number if codec is a decoder, zero otherwise
 */
@NoException public static native int av_codec_is_decoder(@Const AVCodec codec);

/**
 * Return a name for the specified profile, if available.
 *
 * @param codec the codec that is searched for the given profile
 * @param profile the profile value for which a name is requested
 * @return A name for the profile if found, NULL otherwise.
 */
@NoException public static native @Cast("const char*") BytePointer av_get_profile_name(@Const AVCodec codec, int profile);

/** enum  */
public static final int
    /**
     * The codec supports this format via the hw_device_ctx interface.
     *
     * When selecting this format, AVCodecContext.hw_device_ctx should
     * have been set to a device of the specified type before calling
     * avcodec_open2().
     */
    AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX = 0x01,
    /**
     * The codec supports this format via the hw_frames_ctx interface.
     *
     * When selecting this format for a decoder,
     * AVCodecContext.hw_frames_ctx should be set to a suitable frames
     * context inside the get_format() callback.  The frames context
     * must have been created on a device of the specified type.
     *
     * When selecting this format for an encoder,
     * AVCodecContext.hw_frames_ctx should be set to the context which
     * will be used for the input frames before calling avcodec_open2().
     */
    AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX = 0x02,
    /**
     * The codec supports this format by some internal method.
     *
     * This format can be selected without any additional configuration -
     * no device or frames context is required.
     */
    AV_CODEC_HW_CONFIG_METHOD_INTERNAL      = 0x04,
    /**
     * The codec supports this format by some ad-hoc method.
     *
     * Additional settings and/or function calls are required.  See the
     * codec-specific documentation for details.  (Methods requiring
     * this sort of configuration are deprecated and others should be
     * used in preference.)
     */
    AV_CODEC_HW_CONFIG_METHOD_AD_HOC        = 0x08;
// Targeting ../avcodec/AVCodecHWConfig.java



/**
 * Retrieve supported hardware configurations for a codec.
 *
 * Values of index from zero to some maximum return the indexed configuration
 * descriptor; all other values return NULL.  If the codec does not support
 * any hardware configurations then it will always return NULL.
 */
@NoException public static native @Const AVCodecHWConfig avcodec_get_hw_config(@Const AVCodec codec, int index);

/**
 * \}
 */

// #endif /* AVCODEC_CODEC_H */


// Parsed from <libavcodec/avcodec.h>

/*
 * copyright (c) 2001 Fabrice Bellard
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

// #ifndef AVCODEC_AVCODEC_H
// #define AVCODEC_AVCODEC_H

/**
 * \file
 * \ingroup libavc
 * Libavcodec external API header
 */

// #include "libavutil/samplefmt.h"
// #include "libavutil/attributes.h"
// #include "libavutil/avutil.h"
// #include "libavutil/buffer.h"
// #include "libavutil/channel_layout.h"
// #include "libavutil/dict.h"
// #include "libavutil/frame.h"
// #include "libavutil/log.h"
// #include "libavutil/pixfmt.h"
// #include "libavutil/rational.h"

// #include "codec.h"
// #include "codec_id.h"
// #include "defs.h"
// #include "packet.h"
// #include "version_major.h"
// #ifndef HAVE_AV_CONFIG_H
/* When included as part of the ffmpeg build, only include the major version
 * to avoid unnecessary rebuilds. When included externally, keep including
 * the full version information. */
// #include "version.h"

// #include "codec_desc.h"
// #include "codec_par.h"
// #endif

/**
 * \defgroup libavc libavcodec
 * Encoding/Decoding Library
 *
 * \{
 *
 * \defgroup lavc_decoding Decoding
 * \{
 * \}
 *
 * \defgroup lavc_encoding Encoding
 * \{
 * \}
 *
 * \defgroup lavc_codec Codecs
 * \{
 * \defgroup lavc_codec_native Native Codecs
 * \{
 * \}
 * \defgroup lavc_codec_wrappers External library wrappers
 * \{
 * \}
 * \defgroup lavc_codec_hwaccel Hardware Accelerators bridge
 * \{
 * \}
 * \}
 * \defgroup lavc_internal Internal
 * \{
 * \}
 * \}
 */

/**
 * \ingroup libavc
 * \defgroup lavc_encdec send/receive encoding and decoding API overview
 * \{
 *
 * The avcodec_send_packet()/avcodec_receive_frame()/avcodec_send_frame()/
 * avcodec_receive_packet() functions provide an encode/decode API, which
 * decouples input and output.
 *
 * The API is very similar for encoding/decoding and audio/video, and works as
 * follows:
 * - Set up and open the AVCodecContext as usual.
 * - Send valid input:
 *   - For decoding, call avcodec_send_packet() to give the decoder raw
 *     compressed data in an AVPacket.
 *   - For encoding, call avcodec_send_frame() to give the encoder an AVFrame
 *     containing uncompressed audio or video.
 *
 *   In both cases, it is recommended that AVPackets and AVFrames are
 *   refcounted, or libavcodec might have to copy the input data. (libavformat
 *   always returns refcounted AVPackets, and av_frame_get_buffer() allocates
 *   refcounted AVFrames.)
 * - Receive output in a loop. Periodically call one of the avcodec_receive_*()
 *   functions and process their output:
 *   - For decoding, call avcodec_receive_frame(). On success, it will return
 *     an AVFrame containing uncompressed audio or video data.
 *   - For encoding, call avcodec_receive_packet(). On success, it will return
 *     an AVPacket with a compressed frame.
 *
 *   Repeat this call until it returns AVERROR(EAGAIN) or an error. The
 *   AVERROR(EAGAIN) return value means that new input data is required to
 *   return new output. In this case, continue with sending input. For each
 *   input frame/packet, the codec will typically return 1 output frame/packet,
 *   but it can also be 0 or more than 1.
 *
 * At the beginning of decoding or encoding, the codec might accept multiple
 * input frames/packets without returning a frame, until its internal buffers
 * are filled. This situation is handled transparently if you follow the steps
 * outlined above.
 *
 * In theory, sending input can result in EAGAIN - this should happen only if
 * not all output was received. You can use this to structure alternative decode
 * or encode loops other than the one suggested above. For example, you could
 * try sending new input on each iteration, and try to receive output if that
 * returns EAGAIN.
 *
 * End of stream situations. These require "flushing" (aka draining) the codec,
 * as the codec might buffer multiple frames or packets internally for
 * performance or out of necessity (consider B-frames).
 * This is handled as follows:
 * - Instead of valid input, send NULL to the avcodec_send_packet() (decoding)
 *   or avcodec_send_frame() (encoding) functions. This will enter draining
 *   mode.
 * - Call avcodec_receive_frame() (decoding) or avcodec_receive_packet()
 *   (encoding) in a loop until AVERROR_EOF is returned. The functions will
 *   not return AVERROR(EAGAIN), unless you forgot to enter draining mode.
 * - Before decoding can be resumed again, the codec has to be reset with
 *   avcodec_flush_buffers().
 *
 * Using the API as outlined above is highly recommended. But it is also
 * possible to call functions outside of this rigid schema. For example, you can
 * call avcodec_send_packet() repeatedly without calling
 * avcodec_receive_frame(). In this case, avcodec_send_packet() will succeed
 * until the codec's internal buffer has been filled up (which is typically of
 * size 1 per output frame, after initial input), and then reject input with
 * AVERROR(EAGAIN). Once it starts rejecting input, you have no choice but to
 * read at least some output.
 *
 * Not all codecs will follow a rigid and predictable dataflow; the only
 * guarantee is that an AVERROR(EAGAIN) return value on a send/receive call on
 * one end implies that a receive/send call on the other end will succeed, or
 * at least will not fail with AVERROR(EAGAIN). In general, no codec will
 * permit unlimited buffering of input or output.
 *
 * A codec is not allowed to return AVERROR(EAGAIN) for both sending and receiving. This
 * would be an invalid state, which could put the codec user into an endless
 * loop. The API has no concept of time either: it cannot happen that trying to
 * do avcodec_send_packet() results in AVERROR(EAGAIN), but a repeated call 1 second
 * later accepts the packet (with no other receive/flush API calls involved).
 * The API is a strict state machine, and the passage of time is not supposed
 * to influence it. Some timing-dependent behavior might still be deemed
 * acceptable in certain cases. But it must never result in both send/receive
 * returning EAGAIN at the same time at any point. It must also absolutely be
 * avoided that the current state is "unstable" and can "flip-flop" between
 * the send/receive APIs allowing progress. For example, it's not allowed that
 * the codec randomly decides that it actually wants to consume a packet now
 * instead of returning a frame, after it just returned AVERROR(EAGAIN) on an
 * avcodec_send_packet() call.
 * \}
 */

/**
 * \defgroup lavc_core Core functions/structures.
 * \ingroup libavc
 *
 * Basic definitions, functions for querying libavcodec capabilities,
 * allocating core structures, etc.
 * \{
 */

/**
 * \ingroup lavc_encoding
 * minimum encoding buffer size
 * Used to avoid some checks during header writing.
 */
public static final int AV_INPUT_BUFFER_MIN_SIZE = 16384;
// Targeting ../avcodec/RcOverride.java



/* encoding support
   These flags can be passed in AVCodecContext.flags before initialization.
   Note: Not everything is supported yet.
*/

/**
 * Allow decoders to produce frames with data planes that are not aligned
 * to CPU requirements (e.g. due to cropping).
 */
public static final int AV_CODEC_FLAG_UNALIGNED =       (1 <<  0);
/**
 * Use fixed qscale.
 */
public static final int AV_CODEC_FLAG_QSCALE =          (1 <<  1);
/**
 * 4 MV per MB allowed / advanced prediction for H.263.
 */
public static final int AV_CODEC_FLAG_4MV =             (1 <<  2);
/**
 * Output even those frames that might be corrupted.
 */
public static final int AV_CODEC_FLAG_OUTPUT_CORRUPT =  (1 <<  3);
/**
 * Use qpel MC.
 */
public static final int AV_CODEC_FLAG_QPEL =            (1 <<  4);
// #if FF_API_DROPCHANGED
/**
 * Don't output frames whose parameters differ from first
 * decoded frame in stream.
 *
 * @deprecated callers should implement this functionality in their own code
 */
public static final int AV_CODEC_FLAG_DROPCHANGED =     (1 <<  5);
// #endif
/**
 * Request the encoder to output reconstructed frames, i.e.\ frames that would
 * be produced by decoding the encoded bistream. These frames may be retrieved
 * by calling avcodec_receive_frame() immediately after a successful call to
 * avcodec_receive_packet().
 *
 * Should only be used with encoders flagged with the
 * \ref AV_CODEC_CAP_ENCODER_RECON_FRAME capability.
 *
 * \note
 * Each reconstructed frame returned by the encoder corresponds to the last
 * encoded packet, i.e. the frames are returned in coded order rather than
 * presentation order.
 *
 * \note
 * Frame parameters (like pixel format or dimensions) do not have to match the
 * AVCodecContext values. Make sure to use the values from the returned frame.
 */
public static final int AV_CODEC_FLAG_RECON_FRAME =     (1 <<  6);
/**
 * \par decoding
 * Request the decoder to propagate each packet's AVPacket.opaque and
 * AVPacket.opaque_ref to its corresponding output AVFrame.
 *
 * \par encoding:
 * Request the encoder to propagate each frame's AVFrame.opaque and
 * AVFrame.opaque_ref values to its corresponding output AVPacket.
 *
 * \par
 * May only be set on encoders that have the
 * \ref AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE capability flag.
 *
 * \note
 * While in typical cases one input frame produces exactly one output packet
 * (perhaps after a delay), in general the mapping of frames to packets is
 * M-to-N, so
 * - Any number of input frames may be associated with any given output packet.
 *   This includes zero - e.g. some encoders may output packets that carry only
 *   metadata about the whole stream.
 * - A given input frame may be associated with any number of output packets.
 *   Again this includes zero - e.g. some encoders may drop frames under certain
 *   conditions.
 * .
 * This implies that when using this flag, the caller must NOT assume that
 * - a given input frame's opaques will necessarily appear on some output packet;
 * - every output packet will have some non-NULL opaque value.
 * .
 * When an output packet contains multiple frames, the opaque values will be
 * taken from the first of those.
 *
 * \note
 * The converse holds for decoders, with frames and packets switched.
 */
public static final int AV_CODEC_FLAG_COPY_OPAQUE =     (1 <<  7);
/**
 * Signal to the encoder that the values of AVFrame.duration are valid and
 * should be used (typically for transferring them to output packets).
 *
 * If this flag is not set, frame durations are ignored.
 */
public static final int AV_CODEC_FLAG_FRAME_DURATION =  (1 <<  8);
/**
 * Use internal 2pass ratecontrol in first pass mode.
 */
public static final int AV_CODEC_FLAG_PASS1 =           (1 <<  9);
/**
 * Use internal 2pass ratecontrol in second pass mode.
 */
public static final int AV_CODEC_FLAG_PASS2 =           (1 << 10);
/**
 * loop filter.
 */
public static final int AV_CODEC_FLAG_LOOP_FILTER =     (1 << 11);
/**
 * Only decode/encode grayscale.
 */
public static final int AV_CODEC_FLAG_GRAY =            (1 << 13);
/**
 * error[?] variables will be set during encoding.
 */
public static final int AV_CODEC_FLAG_PSNR =            (1 << 15);
/**
 * Use interlaced DCT.
 */
public static final int AV_CODEC_FLAG_INTERLACED_DCT =  (1 << 18);
/**
 * Force low delay.
 */
public static final int AV_CODEC_FLAG_LOW_DELAY =       (1 << 19);
/**
 * Place global headers in extradata instead of every keyframe.
 */
public static final int AV_CODEC_FLAG_GLOBAL_HEADER =   (1 << 22);
/**
 * Use only bitexact stuff (except (I)DCT).
 */
public static final int AV_CODEC_FLAG_BITEXACT =        (1 << 23);
/* Fx : Flag for H.263+ extra options */
/**
 * H.263 advanced intra coding / MPEG-4 AC prediction
 */
public static final int AV_CODEC_FLAG_AC_PRED =         (1 << 24);
/**
 * interlaced motion estimation
 */
public static final int AV_CODEC_FLAG_INTERLACED_ME =   (1 << 29);
public static final int AV_CODEC_FLAG_CLOSED_GOP =      (1 << 31);

/**
 * Allow non spec compliant speedup tricks.
 */
public static final int AV_CODEC_FLAG2_FAST =           (1 <<  0);
/**
 * Skip bitstream encoding.
 */
public static final int AV_CODEC_FLAG2_NO_OUTPUT =      (1 <<  2);
/**
 * Place global headers at every keyframe instead of in extradata.
 */
public static final int AV_CODEC_FLAG2_LOCAL_HEADER =   (1 <<  3);

/**
 * Input bitstream might be truncated at a packet boundaries
 * instead of only at frame boundaries.
 */
public static final int AV_CODEC_FLAG2_CHUNKS =         (1 << 15);
/**
 * Discard cropping information from SPS.
 */
public static final int AV_CODEC_FLAG2_IGNORE_CROP =    (1 << 16);

/**
 * Show all frames before the first keyframe
 */
public static final int AV_CODEC_FLAG2_SHOW_ALL =       (1 << 22);
/**
 * Export motion vectors through frame side data
 */
public static final int AV_CODEC_FLAG2_EXPORT_MVS =     (1 << 28);
/**
 * Do not skip samples and export skip information as frame side data
 */
public static final int AV_CODEC_FLAG2_SKIP_MANUAL =    (1 << 29);
/**
 * Do not reset ASS ReadOrder field on flush (subtitles decoding)
 */
public static final int AV_CODEC_FLAG2_RO_FLUSH_NOOP =  (1 << 30);
/**
 * Generate/parse ICC profiles on encode/decode, as appropriate for the type of
 * file. No effect on codecs which cannot contain embedded ICC profiles, or
 * when compiled without support for lcms2.
 */
public static final int AV_CODEC_FLAG2_ICC_PROFILES =   (1 << 31);

/* Exported side data.
   These flags can be passed in AVCodecContext.export_side_data before initialization.
*/
/**
 * Export motion vectors through frame side data
 */
public static final int AV_CODEC_EXPORT_DATA_MVS =         (1 << 0);
/**
 * Export encoder Producer Reference Time through packet side data
 */
public static final int AV_CODEC_EXPORT_DATA_PRFT =        (1 << 1);
/**
 * Decoding only.
 * Export the AVVideoEncParams structure through frame side data.
 */
public static final int AV_CODEC_EXPORT_DATA_VIDEO_ENC_PARAMS = (1 << 2);
/**
 * Decoding only.
 * Do not apply film grain, export it instead.
 */
public static final int AV_CODEC_EXPORT_DATA_FILM_GRAIN = (1 << 3);

/**
 * The decoder will keep a reference to the frame and may reuse it later.
 */
public static final int AV_GET_BUFFER_FLAG_REF = (1 << 0);

/**
 * The encoder will keep a reference to the packet and may reuse it later.
 */
public static final int AV_GET_ENCODE_BUFFER_FLAG_REF = (1 << 0);
// Targeting ../avcodec/AVCodecContext.java


// Targeting ../avcodec/AVHWAccel.java



/**
 * HWAccel is experimental and is thus avoided in favor of non experimental
 * codecs
 */
public static final int AV_HWACCEL_CODEC_CAP_EXPERIMENTAL = 0x0200;

/**
 * Hardware acceleration should be used for decoding even if the codec level
 * used is unknown or higher than the maximum supported level reported by the
 * hardware driver.
 *
 * It's generally a good idea to pass this flag unless you have a specific
 * reason not to, as hardware tends to under-report supported levels.
 */
public static final int AV_HWACCEL_FLAG_IGNORE_LEVEL = (1 << 0);

/**
 * Hardware acceleration can output YUV pixel formats with a different chroma
 * sampling than 4:2:0 and/or other than 8 bits per component.
 */
public static final int AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH = (1 << 1);

/**
 * Hardware acceleration should still be attempted for decoding when the
 * codec profile does not match the reported capabilities of the hardware.
 *
 * For example, this can be used to try to decode baseline profile H.264
 * streams in hardware - it will often succeed, because many streams marked
 * as baseline profile actually conform to constrained baseline profile.
 *
 * \warning If the stream is actually not supported then the behaviour is
 *          undefined, and may include returning entirely incorrect output
 *          while indicating success.
 */
public static final int AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH = (1 << 2);

/**
 * Some hardware decoders (namely nvdec) can either output direct decoder
 * surfaces, or make an on-device copy and return said copy.
 * There is a hard limit on how many decoder surfaces there can be, and it
 * cannot be accurately guessed ahead of time.
 * For some processing chains, this can be okay, but others will run into the
 * limit and in turn produce very confusing errors that require fine tuning of
 * more or less obscure options by the user, or in extreme cases cannot be
 * resolved at all without inserting an avfilter that forces a copy.
 *
 * Thus, the hwaccel will by default make a copy for safety and resilience.
 * If a users really wants to minimize the amount of copies, they can set this
 * flag and ensure their processing chain does not exhaust the surface pool.
 */
public static final int AV_HWACCEL_FLAG_UNSAFE_OUTPUT = (1 << 3);

/**
 * \}
 */

/** enum AVSubtitleType */
public static final int
    SUBTITLE_NONE = 0,

    /** A bitmap, pict will be set */
    SUBTITLE_BITMAP = 1,

    /**
     * Plain text, the text field must be set by the decoder and is
     * authoritative. ass and pict fields may contain approximations.
     */
    SUBTITLE_TEXT = 2,

    /**
     * Formatted text, the ass field must be set by the decoder and is
     * authoritative. pict and text fields may contain approximations.
     */
    SUBTITLE_ASS = 3;

public static final int AV_SUBTITLE_FLAG_FORCED = 0x00000001;
// Targeting ../avcodec/AVSubtitleRect.java


// Targeting ../avcodec/AVSubtitle.java



/**
 * Return the LIBAVCODEC_VERSION_INT constant.
 */
@NoException public static native @Cast("unsigned") int avcodec_version();

/**
 * Return the libavcodec build-time configuration.
 */
@NoException public static native @Cast("const char*") BytePointer avcodec_configuration();

/**
 * Return the libavcodec license.
 */
@NoException public static native @Cast("const char*") BytePointer avcodec_license();

/**
 * Allocate an AVCodecContext and set its fields to default values. The
 * resulting struct should be freed with avcodec_free_context().
 *
 * @param codec if non-NULL, allocate private data and initialize defaults
 *              for the given codec. It is illegal to then call avcodec_open2()
 *              with a different codec.
 *              If NULL, then the codec-specific defaults won't be initialized,
 *              which may result in suboptimal default settings (this is
 *              important mainly for encoders, e.g. libx264).
 *
 * @return An AVCodecContext filled with default values or NULL on failure.
 */
@NoException public static native AVCodecContext avcodec_alloc_context3(@Const AVCodec codec);

/**
 * Free the codec context and everything associated with it and write NULL to
 * the provided pointer.
 */
@NoException public static native void avcodec_free_context(@Cast("AVCodecContext**") PointerPointer avctx);
@NoException public static native void avcodec_free_context(@ByPtrPtr AVCodecContext avctx);

/**
 * Get the AVClass for AVCodecContext. It can be used in combination with
 * AV_OPT_SEARCH_FAKE_OBJ for examining options.
 *
 * @see av_opt_find().
 */
@NoException public static native @Const AVClass avcodec_get_class();

/**
 * Get the AVClass for AVSubtitleRect. It can be used in combination with
 * AV_OPT_SEARCH_FAKE_OBJ for examining options.
 *
 * @see av_opt_find().
 */
@NoException public static native @Const AVClass avcodec_get_subtitle_rect_class();

/**
 * Fill the parameters struct based on the values from the supplied codec
 * context. Any allocated fields in par are freed and replaced with duplicates
 * of the corresponding fields in codec.
 *
 * @return >= 0 on success, a negative AVERROR code on failure
 */
@NoException public static native int avcodec_parameters_from_context(AVCodecParameters par,
                                    @Const AVCodecContext codec);

/**
 * Fill the codec context based on the values from the supplied codec
 * parameters. Any allocated fields in codec that have a corresponding field in
 * par are freed and replaced with duplicates of the corresponding field in par.
 * Fields in codec that do not have a counterpart in par are not touched.
 *
 * @return >= 0 on success, a negative AVERROR code on failure.
 */
@NoException public static native int avcodec_parameters_to_context(AVCodecContext codec,
                                  @Const AVCodecParameters par);

/**
 * Initialize the AVCodecContext to use the given AVCodec. Prior to using this
 * function the context has to be allocated with avcodec_alloc_context3().
 *
 * The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),
 * avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for
 * retrieving a codec.
 *
 * Depending on the codec, you might need to set options in the codec context
 * also for decoding (e.g. width, height, or the pixel or audio sample format in
 * the case the information is not available in the bitstream, as when decoding
 * raw audio or video).
 *
 * Options in the codec context can be set either by setting them in the options
 * AVDictionary, or by setting the values in the context itself, directly or by
 * using the av_opt_set() API before calling this function.
 *
 * Example:
 * <pre>{@code
 * av_dict_set(&opts, "b", "2.5M", 0);
 * codec = avcodec_find_decoder(AV_CODEC_ID_H264);
 * if (!codec)
 *     exit(1);
 *
 * context = avcodec_alloc_context3(codec);
 *
 * if (avcodec_open2(context, codec, opts) < 0)
 *     exit(1);
 * }</pre>
 *
 * In the case AVCodecParameters are available (e.g. when demuxing a stream
 * using libavformat, and accessing the AVStream contained in the demuxer), the
 * codec parameters can be copied to the codec context using
 * avcodec_parameters_to_context(), as in the following example:
 *
 * <pre>{@code
 * AVStream *stream = ...;
 * context = avcodec_alloc_context3(codec);
 * if (avcodec_parameters_to_context(context, stream->codecpar) < 0)
 *     exit(1);
 * if (avcodec_open2(context, codec, NULL) < 0)
 *     exit(1);
 * }</pre>
 *
 * \note Always call this function before using decoding routines (such as
 * \ref avcodec_receive_frame()).
 *
 * @param avctx The context to initialize.
 * @param codec The codec to open this context for. If a non-NULL codec has been
 *              previously passed to avcodec_alloc_context3() or
 *              for this context, then this parameter MUST be either NULL or
 *              equal to the previously passed codec.
 * @param options A dictionary filled with AVCodecContext and codec-private
 *                options, which are set on top of the options already set in
 *                avctx, can be NULL. On return this object will be filled with
 *                options that were not found in the avctx codec context.
 *
 * @return zero on success, a negative value on error
 * @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),
 *      av_dict_set(), av_opt_set(), av_opt_find(), avcodec_parameters_to_context()
 */
@NoException public static native int avcodec_open2(AVCodecContext avctx, @Const AVCodec codec, @Cast("AVDictionary**") PointerPointer options);
@NoException public static native int avcodec_open2(AVCodecContext avctx, @Const AVCodec codec, @ByPtrPtr AVDictionary options);

/**
 * Close a given AVCodecContext and free all the data associated with it
 * (but not the AVCodecContext itself).
 *
 * Calling this function on an AVCodecContext that hasn't been opened will free
 * the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL
 * codec. Subsequent calls will do nothing.
 *
 * \note Do not use this function. Use avcodec_free_context() to destroy a
 * codec context (either open or closed). Opening and closing a codec context
 * multiple times is not supported anymore -- use multiple codec contexts
 * instead.
 */
@NoException public static native int avcodec_close(AVCodecContext avctx);

/**
 * Free all allocated data in the given subtitle struct.
 *
 * @param sub AVSubtitle to free.
 */
@NoException public static native void avsubtitle_free(AVSubtitle sub);

/**
 * \}
 */

/**
 * \addtogroup lavc_decoding
 * \{
 */

/**
 * The default callback for AVCodecContext.get_buffer2(). It is made public so
 * it can be called by custom get_buffer2() implementations for decoders without
 * AV_CODEC_CAP_DR1 set.
 */
@NoException public static native int avcodec_default_get_buffer2(AVCodecContext s, AVFrame frame, int flags);

/**
 * The default callback for AVCodecContext.get_encode_buffer(). It is made public so
 * it can be called by custom get_encode_buffer() implementations for encoders without
 * AV_CODEC_CAP_DR1 set.
 */
@NoException public static native int avcodec_default_get_encode_buffer(AVCodecContext s, AVPacket pkt, int flags);

/**
 * Modify width and height values so that they will result in a memory
 * buffer that is acceptable for the codec if you do not use any horizontal
 * padding.
 *
 * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
 */
@NoException public static native void avcodec_align_dimensions(AVCodecContext s, IntPointer width, IntPointer height);
@NoException public static native void avcodec_align_dimensions(AVCodecContext s, IntBuffer width, IntBuffer height);
@NoException public static native void avcodec_align_dimensions(AVCodecContext s, int[] width, int[] height);

/**
 * Modify width and height values so that they will result in a memory
 * buffer that is acceptable for the codec if you also ensure that all
 * line sizes are a multiple of the respective linesize_align[i].
 *
 * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
 */
@NoException public static native void avcodec_align_dimensions2(AVCodecContext s, IntPointer width, IntPointer height,
                               IntPointer linesize_align);
@NoException public static native void avcodec_align_dimensions2(AVCodecContext s, IntBuffer width, IntBuffer height,
                               IntBuffer linesize_align);
@NoException public static native void avcodec_align_dimensions2(AVCodecContext s, int[] width, int[] height,
                               int[] linesize_align);

// #ifdef FF_API_AVCODEC_CHROMA_POS
/**
 * Converts AVChromaLocation to swscale x/y chroma position.
 *
 * The positions represent the chroma (0,0) position in a coordinates system
 * with luma (0,0) representing the origin and luma(1,1) representing 256,256
 *
 * @param xpos  horizontal chroma sample position
 * @param ypos  vertical   chroma sample position
 * @deprecated Use av_chroma_location_enum_to_pos() instead.
 */
 @NoException public static native @Deprecated int avcodec_enum_to_chroma_pos(IntPointer xpos, IntPointer ypos, @Cast("AVChromaLocation") int pos);
 @NoException public static native @Deprecated int avcodec_enum_to_chroma_pos(IntBuffer xpos, IntBuffer ypos, @Cast("AVChromaLocation") int pos);
 @NoException public static native @Deprecated int avcodec_enum_to_chroma_pos(int[] xpos, int[] ypos, @Cast("AVChromaLocation") int pos);

/**
 * Converts swscale x/y chroma position to AVChromaLocation.
 *
 * The positions represent the chroma (0,0) position in a coordinates system
 * with luma (0,0) representing the origin and luma(1,1) representing 256,256
 *
 * @param xpos  horizontal chroma sample position
 * @param ypos  vertical   chroma sample position
 * @deprecated Use av_chroma_location_pos_to_enum() instead.
 */
 @NoException public static native @Cast("AVChromaLocation") @Deprecated int avcodec_chroma_pos_to_enum(int xpos, int ypos);
// #endif

/**
 * Decode a subtitle message.
 * Return a negative value on error, otherwise return the number of bytes used.
 * If no subtitle could be decompressed, got_sub_ptr is zero.
 * Otherwise, the subtitle is stored in *sub.
 * Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for
 * simplicity, because the performance difference is expected to be negligible
 * and reusing a get_buffer written for video codecs would probably perform badly
 * due to a potentially very different allocation pattern.
 *
 * Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input
 * and output. This means that for some packets they will not immediately
 * produce decoded output and need to be flushed at the end of decoding to get
 * all the decoded data. Flushing is done by calling this function with packets
 * with avpkt->data set to NULL and avpkt->size set to 0 until it stops
 * returning subtitles. It is safe to flush even those decoders that are not
 * marked with AV_CODEC_CAP_DELAY, then no subtitles will be returned.
 *
 * \note The AVCodecContext MUST have been opened with \ref avcodec_open2()
 * before packets may be fed to the decoder.
 *
 * @param avctx the codec context
 * @param sub [out] The preallocated AVSubtitle in which the decoded subtitle will be stored,
 *                 must be freed with avsubtitle_free if *got_sub_ptr is set.
 * @param got_sub_ptr [in,out] Zero if no subtitle could be decompressed, otherwise, it is nonzero.
 * @param avpkt [in] The input AVPacket containing the input buffer.
 */
@NoException public static native int avcodec_decode_subtitle2(AVCodecContext avctx, AVSubtitle sub,
                             IntPointer got_sub_ptr, @Const AVPacket avpkt);
@NoException public static native int avcodec_decode_subtitle2(AVCodecContext avctx, AVSubtitle sub,
                             IntBuffer got_sub_ptr, @Const AVPacket avpkt);
@NoException public static native int avcodec_decode_subtitle2(AVCodecContext avctx, AVSubtitle sub,
                             int[] got_sub_ptr, @Const AVPacket avpkt);

/**
 * Supply raw packet data as input to a decoder.
 *
 * Internally, this call will copy relevant AVCodecContext fields, which can
 * influence decoding per-packet, and apply them when the packet is actually
 * decoded. (For example AVCodecContext.skip_frame, which might direct the
 * decoder to drop the frame contained by the packet sent with this function.)
 *
 * \warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE
 *          larger than the actual read bytes because some optimized bitstream
 *          readers read 32 or 64 bits at once and could read over the end.
 *
 * \note The AVCodecContext MUST have been opened with \ref avcodec_open2()
 *       before packets may be fed to the decoder.
 *
 * @param avctx codec context
 * @param avpkt [in] The input AVPacket. Usually, this will be a single video
 *                  frame, or several complete audio frames.
 *                  Ownership of the packet remains with the caller, and the
 *                  decoder will not write to the packet. The decoder may create
 *                  a reference to the packet data (or copy it if the packet is
 *                  not reference-counted).
 *                  Unlike with older APIs, the packet is always fully consumed,
 *                  and if it contains multiple frames (e.g. some audio codecs),
 *                  will require you to call avcodec_receive_frame() multiple
 *                  times afterwards before you can send a new packet.
 *                  It can be NULL (or an AVPacket with data set to NULL and
 *                  size set to 0); in this case, it is considered a flush
 *                  packet, which signals the end of the stream. Sending the
 *                  first flush packet will return success. Subsequent ones are
 *                  unnecessary and will return AVERROR_EOF. If the decoder
 *                  still has frames buffered, it will return them after sending
 *                  a flush packet.
 *
 * \retval 0                 success
 * \retval AVERROR(EAGAIN)   input is not accepted in the current state - user
 *                           must read output with avcodec_receive_frame() (once
 *                           all output is read, the packet should be resent,
 *                           and the call will not fail with EAGAIN).
 * \retval AVERROR_EOF       the decoder has been flushed, and no new packets can be
 *                           sent to it (also returned if more than 1 flush
 *                           packet is sent)
 * \retval AVERROR(EINVAL)   codec not opened, it is an encoder, or requires flush
 * \retval AVERROR(ENOMEM)   failed to add packet to internal queue, or similar
 * \retval "another negative error code" legitimate decoding errors
 */
@NoException public static native int avcodec_send_packet(AVCodecContext avctx, @Const AVPacket avpkt);

/**
 * Return decoded output data from a decoder or encoder (when the
 * \ref AV_CODEC_FLAG_RECON_FRAME flag is used).
 *
 * @param avctx codec context
 * @param frame This will be set to a reference-counted video or audio
 *              frame (depending on the decoder type) allocated by the
 *              codec. Note that the function will always call
 *              av_frame_unref(frame) before doing anything else.
 *
 * \retval 0                success, a frame was returned
 * \retval AVERROR(EAGAIN)  output is not available in this state - user must
 *                          try to send new input
 * \retval AVERROR_EOF      the codec has been fully flushed, and there will be
 *                          no more output frames
 * \retval AVERROR(EINVAL)  codec not opened, or it is an encoder without the
 *                          \ref AV_CODEC_FLAG_RECON_FRAME flag enabled
 * \retval "other negative error code" legitimate decoding errors
 */
@NoException public static native int avcodec_receive_frame(AVCodecContext avctx, AVFrame frame);

/**
 * Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet()
 * to retrieve buffered output packets.
 *
 * @param avctx     codec context
 * @param frame [in] AVFrame containing the raw audio or video frame to be encoded.
 *                  Ownership of the frame remains with the caller, and the
 *                  encoder will not write to the frame. The encoder may create
 *                  a reference to the frame data (or copy it if the frame is
 *                  not reference-counted).
 *                  It can be NULL, in which case it is considered a flush
 *                  packet.  This signals the end of the stream. If the encoder
 *                  still has packets buffered, it will return them after this
 *                  call. Once flushing mode has been entered, additional flush
 *                  packets are ignored, and sending frames will return
 *                  AVERROR_EOF.
 *
 *                  For audio:
 *                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
 *                  can have any number of samples.
 *                  If it is not set, frame->nb_samples must be equal to
 *                  avctx->frame_size for all frames except the last.
 *                  The final frame may be smaller than avctx->frame_size.
 * \retval 0                 success
 * \retval AVERROR(EAGAIN)   input is not accepted in the current state - user must
 *                           read output with avcodec_receive_packet() (once all
 *                           output is read, the packet should be resent, and the
 *                           call will not fail with EAGAIN).
 * \retval AVERROR_EOF       the encoder has been flushed, and no new frames can
 *                           be sent to it
 * \retval AVERROR(EINVAL)   codec not opened, it is a decoder, or requires flush
 * \retval AVERROR(ENOMEM)   failed to add packet to internal queue, or similar
 * \retval "another negative error code" legitimate encoding errors
 */
@NoException public static native int avcodec_send_frame(AVCodecContext avctx, @Const AVFrame frame);

/**
 * Read encoded data from the encoder.
 *
 * @param avctx codec context
 * @param avpkt This will be set to a reference-counted packet allocated by the
 *              encoder. Note that the function will always call
 *              av_packet_unref(avpkt) before doing anything else.
 * \retval 0               success
 * \retval AVERROR(EAGAIN) output is not available in the current state - user must
 *                         try to send input
 * \retval AVERROR_EOF     the encoder has been fully flushed, and there will be no
 *                         more output packets
 * \retval AVERROR(EINVAL) codec not opened, or it is a decoder
 * \retval "another negative error code" legitimate encoding errors
 */
@NoException public static native int avcodec_receive_packet(AVCodecContext avctx, AVPacket avpkt);

/**
 * Create and return a AVHWFramesContext with values adequate for hardware
 * decoding. This is meant to get called from the get_format callback, and is
 * a helper for preparing a AVHWFramesContext for AVCodecContext.hw_frames_ctx.
 * This API is for decoding with certain hardware acceleration modes/APIs only.
 *
 * The returned AVHWFramesContext is not initialized. The caller must do this
 * with av_hwframe_ctx_init().
 *
 * Calling this function is not a requirement, but makes it simpler to avoid
 * codec or hardware API specific details when manually allocating frames.
 *
 * Alternatively to this, an API user can set AVCodecContext.hw_device_ctx,
 * which sets up AVCodecContext.hw_frames_ctx fully automatically, and makes
 * it unnecessary to call this function or having to care about
 * AVHWFramesContext initialization at all.
 *
 * There are a number of requirements for calling this function:
 *
 * - It must be called from get_format with the same avctx parameter that was
 *   passed to get_format. Calling it outside of get_format is not allowed, and
 *   can trigger undefined behavior.
 * - The function is not always supported (see description of return values).
 *   Even if this function returns successfully, hwaccel initialization could
 *   fail later. (The degree to which implementations check whether the stream
 *   is actually supported varies. Some do this check only after the user's
 *   get_format callback returns.)
 * - The hw_pix_fmt must be one of the choices suggested by get_format. If the
 *   user decides to use a AVHWFramesContext prepared with this API function,
 *   the user must return the same hw_pix_fmt from get_format.
 * - The device_ref passed to this function must support the given hw_pix_fmt.
 * - After calling this API function, it is the user's responsibility to
 *   initialize the AVHWFramesContext (returned by the out_frames_ref parameter),
 *   and to set AVCodecContext.hw_frames_ctx to it. If done, this must be done
 *   before returning from get_format (this is implied by the normal
 *   AVCodecContext.hw_frames_ctx API rules).
 * - The AVHWFramesContext parameters may change every time time get_format is
 *   called. Also, AVCodecContext.hw_frames_ctx is reset before get_format. So
 *   you are inherently required to go through this process again on every
 *   get_format call.
 * - It is perfectly possible to call this function without actually using
 *   the resulting AVHWFramesContext. One use-case might be trying to reuse a
 *   previously initialized AVHWFramesContext, and calling this API function
 *   only to test whether the required frame parameters have changed.
 * - Fields that use dynamically allocated values of any kind must not be set
 *   by the user unless setting them is explicitly allowed by the documentation.
 *   If the user sets AVHWFramesContext.free and AVHWFramesContext.user_opaque,
 *   the new free callback must call the potentially set previous free callback.
 *   This API call may set any dynamically allocated fields, including the free
 *   callback.
 *
 * The function will set at least the following fields on AVHWFramesContext
 * (potentially more, depending on hwaccel API):
 *
 * - All fields set by av_hwframe_ctx_alloc().
 * - Set the format field to hw_pix_fmt.
 * - Set the sw_format field to the most suited and most versatile format. (An
 *   implication is that this will prefer generic formats over opaque formats
 *   with arbitrary restrictions, if possible.)
 * - Set the width/height fields to the coded frame size, rounded up to the
 *   API-specific minimum alignment.
 * - Only _if_ the hwaccel requires a pre-allocated pool: set the initial_pool_size
 *   field to the number of maximum reference surfaces possible with the codec,
 *   plus 1 surface for the user to work (meaning the user can safely reference
 *   at most 1 decoded surface at a time), plus additional buffering introduced
 *   by frame threading. If the hwaccel does not require pre-allocation, the
 *   field is left to 0, and the decoder will allocate new surfaces on demand
 *   during decoding.
 * - Possibly AVHWFramesContext.hwctx fields, depending on the underlying
 *   hardware API.
 *
 * Essentially, out_frames_ref returns the same as av_hwframe_ctx_alloc(), but
 * with basic frame parameters set.
 *
 * The function is stateless, and does not change the AVCodecContext or the
 * device_ref AVHWDeviceContext.
 *
 * @param avctx The context which is currently calling get_format, and which
 *              implicitly contains all state needed for filling the returned
 *              AVHWFramesContext properly.
 * @param device_ref A reference to the AVHWDeviceContext describing the device
 *                   which will be used by the hardware decoder.
 * @param hw_pix_fmt The hwaccel format you are going to return from get_format.
 * @param out_frames_ref On success, set to a reference to an _uninitialized_
 *                       AVHWFramesContext, created from the given device_ref.
 *                       Fields will be set to values required for decoding.
 *                       Not changed if an error is returned.
 * @return zero on success, a negative value on error. The following error codes
 *         have special semantics:
 *      AVERROR(ENOENT): the decoder does not support this functionality. Setup
 *                       is always manual, or it is a decoder which does not
 *                       support setting AVCodecContext.hw_frames_ctx at all,
 *                       or it is a software format.
 *      AVERROR(EINVAL): it is known that hardware decoding is not supported for
 *                       this configuration, or the device_ref is not supported
 *                       for the hwaccel referenced by hw_pix_fmt.
 */
@NoException public static native int avcodec_get_hw_frames_parameters(AVCodecContext avctx,
                                     AVBufferRef device_ref,
                                     @Cast("AVPixelFormat") int hw_pix_fmt,
                                     @Cast("AVBufferRef**") PointerPointer out_frames_ref);
@NoException public static native int avcodec_get_hw_frames_parameters(AVCodecContext avctx,
                                     AVBufferRef device_ref,
                                     @Cast("AVPixelFormat") int hw_pix_fmt,
                                     @ByPtrPtr AVBufferRef out_frames_ref);



/**
 * \defgroup lavc_parsing Frame parsing
 * \{
 */

/** enum AVPictureStructure */
public static final int
    /** unknown */
    AV_PICTURE_STRUCTURE_UNKNOWN = 0,
    /** coded as top field */
    AV_PICTURE_STRUCTURE_TOP_FIELD = 1,
    /** coded as bottom field */
    AV_PICTURE_STRUCTURE_BOTTOM_FIELD = 2,
    /** coded as frame */
    AV_PICTURE_STRUCTURE_FRAME = 3;
// Targeting ../avcodec/AVCodecParserContext.java


// Targeting ../avcodec/AVCodecParser.java



/**
 * Iterate over all registered codec parsers.
 *
 * @param opaque a pointer where libavcodec will store the iteration state. Must
 *               point to NULL to start the iteration.
 *
 * @return the next registered codec parser or NULL when the iteration is
 *         finished
 */
@NoException public static native @Const AVCodecParser av_parser_iterate(@Cast("void**") PointerPointer opaque);
@NoException public static native @Const AVCodecParser av_parser_iterate(@Cast("void**") @ByPtrPtr Pointer opaque);

@NoException public static native AVCodecParserContext av_parser_init(int codec_id);

/**
 * Parse a packet.
 *
 * @param s             parser context.
 * @param avctx         codec context.
 * @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.
 * @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.
 * @param buf           input buffer.
 * @param buf_size      buffer size in bytes without the padding. I.e. the full buffer
                        size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE.
                        To signal EOF, this should be 0 (so that the last frame
                        can be output).
 * @param pts           input presentation timestamp.
 * @param dts           input decoding timestamp.
 * @param pos           input byte position in stream.
 * @return the number of bytes of the input bitstream used.
 *
 * Example:
 * <pre>{@code
 *   while(in_len){
 *       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,
 *                                        in_data, in_len,
 *                                        pts, dts, pos);
 *       in_data += len;
 *       in_len  -= len;
 *
 *       if(size)
 *          decode_frame(data, size);
 *   }
 * }</pre>
 */
@NoException public static native int av_parser_parse2(AVCodecParserContext s,
                     AVCodecContext avctx,
                     @Cast("uint8_t**") PointerPointer poutbuf, IntPointer poutbuf_size,
                     @Cast("const uint8_t*") BytePointer buf, int buf_size,
                     @Cast("int64_t") long pts, @Cast("int64_t") long dts,
                     @Cast("int64_t") long pos);
@NoException public static native int av_parser_parse2(AVCodecParserContext s,
                     AVCodecContext avctx,
                     @Cast("uint8_t**") @ByPtrPtr BytePointer poutbuf, IntPointer poutbuf_size,
                     @Cast("const uint8_t*") BytePointer buf, int buf_size,
                     @Cast("int64_t") long pts, @Cast("int64_t") long dts,
                     @Cast("int64_t") long pos);
@NoException public static native int av_parser_parse2(AVCodecParserContext s,
                     AVCodecContext avctx,
                     @Cast("uint8_t**") @ByPtrPtr ByteBuffer poutbuf, IntBuffer poutbuf_size,
                     @Cast("const uint8_t*") ByteBuffer buf, int buf_size,
                     @Cast("int64_t") long pts, @Cast("int64_t") long dts,
                     @Cast("int64_t") long pos);
@NoException public static native int av_parser_parse2(AVCodecParserContext s,
                     AVCodecContext avctx,
                     @Cast("uint8_t**") @ByPtrPtr byte[] poutbuf, int[] poutbuf_size,
                     @Cast("const uint8_t*") byte[] buf, int buf_size,
                     @Cast("int64_t") long pts, @Cast("int64_t") long dts,
                     @Cast("int64_t") long pos);

@NoException public static native void av_parser_close(AVCodecParserContext s);

/**
 * \}
 * \}
 */

/**
 * \addtogroup lavc_encoding
 * \{
 */

@NoException public static native int avcodec_encode_subtitle(AVCodecContext avctx, @Cast("uint8_t*") BytePointer buf, int buf_size,
                            @Const AVSubtitle sub);
@NoException public static native int avcodec_encode_subtitle(AVCodecContext avctx, @Cast("uint8_t*") ByteBuffer buf, int buf_size,
                            @Const AVSubtitle sub);
@NoException public static native int avcodec_encode_subtitle(AVCodecContext avctx, @Cast("uint8_t*") byte[] buf, int buf_size,
                            @Const AVSubtitle sub);


/**
 * \}
 */

/**
 * \defgroup lavc_misc Utility functions
 * \ingroup libavc
 *
 * Miscellaneous utility functions related to both encoding and decoding
 * (or neither).
 * \{
 */

/**
 * \defgroup lavc_misc_pixfmt Pixel formats
 *
 * Functions for working with pixel formats.
 * \{
 */

/**
 * Return a value representing the fourCC code associated to the
 * pixel format pix_fmt, or 0 if no associated fourCC code can be
 * found.
 */
@NoException public static native @Cast("unsigned int") int avcodec_pix_fmt_to_codec_tag(@Cast("AVPixelFormat") int pix_fmt);

/**
 * Find the best pixel format to convert to given a certain source pixel
 * format.  When converting from one pixel format to another, information loss
 * may occur.  For example, when converting from RGB24 to GRAY, the color
 * information will be lost. Similarly, other losses occur when converting from
 * some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of
 * the given pixel formats should be used to suffer the least amount of loss.
 * The pixel formats from which it chooses one, are determined by the
 * pix_fmt_list parameter.
 *
 *
 * @param pix_fmt_list [in] AV_PIX_FMT_NONE terminated array of pixel formats to choose from
 * @param src_pix_fmt [in] source pixel format
 * @param has_alpha [in] Whether the source pixel format alpha channel is used.
 * @param loss_ptr [out] Combination of flags informing you what kind of losses will occur.
 * @return The best pixel format to convert to or -1 if none was found.
 */
@NoException public static native @Cast("AVPixelFormat") int avcodec_find_best_pix_fmt_of_list(@Cast("const AVPixelFormat*") IntPointer pix_fmt_list,
                                            @Cast("AVPixelFormat") int src_pix_fmt,
                                            int has_alpha, IntPointer loss_ptr);
@NoException public static native @Cast("AVPixelFormat") int avcodec_find_best_pix_fmt_of_list(@Cast("const AVPixelFormat*") IntBuffer pix_fmt_list,
                                            @Cast("AVPixelFormat") int src_pix_fmt,
                                            int has_alpha, IntBuffer loss_ptr);
@NoException public static native @Cast("AVPixelFormat") int avcodec_find_best_pix_fmt_of_list(@Cast("const AVPixelFormat*") int[] pix_fmt_list,
                                            @Cast("AVPixelFormat") int src_pix_fmt,
                                            int has_alpha, int[] loss_ptr);

@NoException public static native @Cast("AVPixelFormat") int avcodec_default_get_format(AVCodecContext s, @Cast("const AVPixelFormat*") IntPointer fmt);
@NoException public static native @Cast("AVPixelFormat") int avcodec_default_get_format(AVCodecContext s, @Cast("const AVPixelFormat*") IntBuffer fmt);
@NoException public static native @Cast("AVPixelFormat") int avcodec_default_get_format(AVCodecContext s, @Cast("const AVPixelFormat*") int[] fmt);

/**
 * \}
 */

@NoException public static native void avcodec_string(@Cast("char*") BytePointer buf, int buf_size, AVCodecContext enc, int encode);
@NoException public static native void avcodec_string(@Cast("char*") ByteBuffer buf, int buf_size, AVCodecContext enc, int encode);
@NoException public static native void avcodec_string(@Cast("char*") byte[] buf, int buf_size, AVCodecContext enc, int encode);
// Targeting ../avcodec/Func_AVCodecContext_Pointer.java


@NoException public static native int avcodec_default_execute(AVCodecContext c, Func_AVCodecContext_Pointer func,Pointer arg, IntPointer ret, int count, int size);
@NoException public static native int avcodec_default_execute(AVCodecContext c, Func_AVCodecContext_Pointer func,Pointer arg, IntBuffer ret, int count, int size);
@NoException public static native int avcodec_default_execute(AVCodecContext c, Func_AVCodecContext_Pointer func,Pointer arg, int[] ret, int count, int size);
// Targeting ../avcodec/Func_AVCodecContext_Pointer_int_int.java


@NoException public static native int avcodec_default_execute2(AVCodecContext c, Func_AVCodecContext_Pointer_int_int func,Pointer arg, IntPointer ret, int count);
@NoException public static native int avcodec_default_execute2(AVCodecContext c, Func_AVCodecContext_Pointer_int_int func,Pointer arg, IntBuffer ret, int count);
@NoException public static native int avcodec_default_execute2(AVCodecContext c, Func_AVCodecContext_Pointer_int_int func,Pointer arg, int[] ret, int count);
//FIXME func typedef

/**
 * Fill AVFrame audio data and linesize pointers.
 *
 * The buffer buf must be a preallocated buffer with a size big enough
 * to contain the specified samples amount. The filled AVFrame data
 * pointers will point to this buffer.
 *
 * AVFrame extended_data channel pointers are allocated if necessary for
 * planar audio.
 *
 * @param frame       the AVFrame
 *                    frame->nb_samples must be set prior to calling the
 *                    function. This function fills in frame->data,
 *                    frame->extended_data, frame->linesize[0].
 * @param nb_channels channel count
 * @param sample_fmt  sample format
 * @param buf         buffer to use for frame data
 * @param buf_size    size of buffer
 * @param align       plane size sample alignment (0 = default)
 * @return            >=0 on success, negative error code on failure
 * \todo return the size in bytes required to store the samples in
 * case of success, at the next libavutil bump
 */
@NoException public static native int avcodec_fill_audio_frame(AVFrame frame, int nb_channels,
                             @Cast("AVSampleFormat") int sample_fmt, @Cast("const uint8_t*") BytePointer buf,
                             int buf_size, int align);
@NoException public static native int avcodec_fill_audio_frame(AVFrame frame, int nb_channels,
                             @Cast("AVSampleFormat") int sample_fmt, @Cast("const uint8_t*") ByteBuffer buf,
                             int buf_size, int align);
@NoException public static native int avcodec_fill_audio_frame(AVFrame frame, int nb_channels,
                             @Cast("AVSampleFormat") int sample_fmt, @Cast("const uint8_t*") byte[] buf,
                             int buf_size, int align);

/**
 * Reset the internal codec state / flush internal buffers. Should be called
 * e.g. when seeking or when switching to a different stream.
 *
 * \note for decoders, this function just releases any references the decoder
 * might keep internally, but the caller's references remain valid.
 *
 * \note for encoders, this function will only do something if the encoder
 * declares support for AV_CODEC_CAP_ENCODER_FLUSH. When called, the encoder
 * will drain any remaining packets, and can then be re-used for a different
 * stream (as opposed to sending a null frame which will leave the encoder
 * in a permanent EOF state after draining). This can be desirable if the
 * cost of tearing down and replacing the encoder instance is high.
 */
@NoException public static native void avcodec_flush_buffers(AVCodecContext avctx);

/**
 * Return audio frame duration.
 *
 * @param avctx        codec context
 * @param frame_bytes  size of the frame, or 0 if unknown
 * @return             frame duration, in samples, if known. 0 if not able to
 *                     determine.
 */
@NoException public static native int av_get_audio_frame_duration(AVCodecContext avctx, int frame_bytes);

/* memory */

/**
 * Same behaviour av_fast_malloc but the buffer has additional
 * AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.
 *
 * In addition the whole buffer will initially and after resizes
 * be 0-initialized so that no uninitialized data will ever appear.
 */
@NoException public static native void av_fast_padded_malloc(Pointer ptr, @Cast("unsigned int*") IntPointer size, @Cast("size_t") long min_size);
@NoException public static native void av_fast_padded_malloc(Pointer ptr, @Cast("unsigned int*") IntBuffer size, @Cast("size_t") long min_size);
@NoException public static native void av_fast_padded_malloc(Pointer ptr, @Cast("unsigned int*") int[] size, @Cast("size_t") long min_size);

/**
 * Same behaviour av_fast_padded_malloc except that buffer will always
 * be 0-initialized after call.
 */
@NoException public static native void av_fast_padded_mallocz(Pointer ptr, @Cast("unsigned int*") IntPointer size, @Cast("size_t") long min_size);
@NoException public static native void av_fast_padded_mallocz(Pointer ptr, @Cast("unsigned int*") IntBuffer size, @Cast("size_t") long min_size);
@NoException public static native void av_fast_padded_mallocz(Pointer ptr, @Cast("unsigned int*") int[] size, @Cast("size_t") long min_size);

/**
 * @return a positive value if s is open (i.e. avcodec_open2() was called on it
 * with no corresponding avcodec_close()), 0 otherwise.
 */
@NoException public static native int avcodec_is_open(AVCodecContext s);

/**
 * \}
 */

// #endif /* AVCODEC_AVCODEC_H */


// Parsed from <libavcodec/jni.h>

/*
 * JNI public API functions
 *
 * Copyright (c) 2015-2016 Matthieu Bouron <matthieu.bouron stupeflix.com>
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

// #ifndef AVCODEC_JNI_H
// #define AVCODEC_JNI_H

/*
 * Manually set a Java virtual machine which will be used to retrieve the JNI
 * environment. Once a Java VM is set it cannot be changed afterwards, meaning
 * you can call multiple times av_jni_set_java_vm with the same Java VM pointer
 * however it will error out if you try to set a different Java VM.
 *
 * @param vm Java virtual machine
 * @param log_ctx context used for logging, can be NULL
 * @return 0 on success, < 0 otherwise
 */
@NoException public static native int av_jni_set_java_vm(Pointer vm, Pointer log_ctx);

/*
 * Get the Java virtual machine which has been set with av_jni_set_java_vm.
 *
 * @param vm Java virtual machine
 * @return a pointer to the Java virtual machine
 */
@NoException public static native Pointer av_jni_get_java_vm(Pointer log_ctx);

// #endif /* AVCODEC_JNI_H */


// Parsed from <libavcodec/avfft.h>

/*
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

// #ifndef AVCODEC_AVFFT_H
// #define AVCODEC_AVFFT_H

// #include "libavutil/attributes.h"
// #include "version_major.h"
// #if FF_API_AVFFT

/**
 * \file
 * \ingroup lavc_fft
 * FFT functions
 */

/**
 * \defgroup lavc_fft FFT functions
 * \ingroup lavc_misc
 *
 * \{
 */
// Targeting ../avcodec/FFTComplex.java


// Targeting ../avcodec/FFTContext.java



/**
 * Set up a complex FFT.
 * @param nbits           log2 of the length of the input array
 * @param inverse         if 0 perform the forward transform, if 1 perform the inverse
 * @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_FFT
 */
@NoException public static native @Deprecated FFTContext av_fft_init(int nbits, int inverse);

/**
 * Do the permutation needed BEFORE calling ff_fft_calc().
 * @deprecated without replacement
 */
@NoException public static native @Deprecated void av_fft_permute(FFTContext s, FFTComplex z);

/**
 * Do a complex FFT with the parameters defined in av_fft_init(). The
 * input data must be permuted before. No 1.0/sqrt(n) normalization is done.
 * @deprecated use the av_tx_fn value returned by av_tx_init, which also does permutation
 */
@NoException public static native @Deprecated void av_fft_calc(FFTContext s, FFTComplex z);

@NoException public static native @Deprecated void av_fft_end(FFTContext s);

/**
 * @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_MDCT,
 * with a flag of AV_TX_FULL_IMDCT for a replacement to av_imdct_calc.
 */






/* Real Discrete Fourier Transform */

/** enum RDFTransformType */
public static final int
    DFT_R2C = 0,
    IDFT_C2R = 1,
    IDFT_R2C = 2,
    DFT_C2R = 3;
// Targeting ../avcodec/RDFTContext.java



/**
 * Set up a real FFT.
 * @param nbits           log2 of the length of the input array
 * @param trans           the type of transform
 *
 * @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_RDFT
 */
@NoException public static native @Deprecated RDFTContext av_rdft_init(int nbits, @Cast("RDFTransformType") int trans);
@NoException public static native @Deprecated void av_rdft_calc(RDFTContext s, @Cast("FFTSample*") FloatPointer data);
@NoException public static native @Deprecated void av_rdft_calc(RDFTContext s, @Cast("FFTSample*") FloatBuffer data);
@NoException public static native @Deprecated void av_rdft_calc(RDFTContext s, @Cast("FFTSample*") float[] data);
@NoException public static native @Deprecated void av_rdft_end(RDFTContext s);
// Targeting ../avcodec/DCTContext.java



/** enum DCTTransformType */
public static final int
    DCT_II = 0,
    DCT_III = 1,
    DCT_I = 2,
    DST_I = 3;

/**
 * Set up DCT.
 *
 * @param nbits           size of the input array:
 *                        (1 << nbits)     for DCT-II, DCT-III and DST-I
 *                        (1 << nbits) + 1 for DCT-I
 * @param type            the type of transform
 *
 * \note the first element of the input of DST-I is ignored
 *
 * @deprecated use av_tx_init from libavutil/tx.h with an appropriate type of AV_TX_FLOAT_DCT
 */
@NoException public static native @Deprecated DCTContext av_dct_init(int nbits, @Cast("DCTTransformType") int type);
@NoException public static native @Deprecated void av_dct_calc(DCTContext s, @Cast("FFTSample*") FloatPointer data);
@NoException public static native @Deprecated void av_dct_calc(DCTContext s, @Cast("FFTSample*") FloatBuffer data);
@NoException public static native @Deprecated void av_dct_calc(DCTContext s, @Cast("FFTSample*") float[] data);
@NoException public static native @Deprecated void av_dct_end(DCTContext s);

/**
 * \}
 */

// #endif /* FF_API_AVFFT */
// #endif /* AVCODEC_AVFFT_H */


// Parsed from <libavcodec/version_major.h>

/*
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

// #ifndef AVCODEC_VERSION_MAJOR_H
// #define AVCODEC_VERSION_MAJOR_H

/**
 * \file
 * \ingroup libavc
 * Libavcodec version macros.
 */

public static final int LIBAVCODEC_VERSION_MAJOR =  60;

/**
 * FF_API_* defines may be placed below to indicate public API that will be
 * dropped at a future version bump. The defines themselves are not part of
 * the public API and may change, break or disappear at any time.
 *
 * \note, when bumping the major version it is recommended to manually
 * disable each FF_API_* in its own commit instead of disabling them all
 * at once through the bump. This improves the git bisect-ability of the change.
 */

public static final boolean FF_API_INIT_PACKET =         (LIBAVCODEC_VERSION_MAJOR < 61);
public static final boolean FF_API_IDCT_NONE =           (LIBAVCODEC_VERSION_MAJOR < 61);
public static final boolean FF_API_SVTAV1_OPTS =         (LIBAVCODEC_VERSION_MAJOR < 61);
public static final boolean FF_API_AYUV_CODECID =        (LIBAVCODEC_VERSION_MAJOR < 61);
public static final boolean FF_API_VT_OUTPUT_CALLBACK =  (LIBAVCODEC_VERSION_MAJOR < 61);
public static final boolean FF_API_AVCODEC_CHROMA_POS =  (LIBAVCODEC_VERSION_MAJOR < 61);
public static final boolean FF_API_VT_HWACCEL_CONTEXT =  (LIBAVCODEC_VERSION_MAJOR < 61);
public static final boolean FF_API_AVCTX_FRAME_NUMBER =  (LIBAVCODEC_VERSION_MAJOR < 61);
public static final boolean FF_API_SLICE_OFFSET =        (LIBAVCODEC_VERSION_MAJOR < 61);
public static final boolean FF_API_SUBFRAMES =           (LIBAVCODEC_VERSION_MAJOR < 61);
public static final boolean FF_API_TICKS_PER_FRAME =     (LIBAVCODEC_VERSION_MAJOR < 61);
public static final boolean FF_API_DROPCHANGED =         (LIBAVCODEC_VERSION_MAJOR < 61);

public static final boolean FF_API_AVFFT =               (LIBAVCODEC_VERSION_MAJOR < 62);
public static final boolean FF_API_FF_PROFILE_LEVEL =    (LIBAVCODEC_VERSION_MAJOR < 62);

// reminder to remove CrystalHD decoders on next major bump
public static final boolean FF_CODEC_CRYSTAL_HD =        (LIBAVCODEC_VERSION_MAJOR < 61);

// #endif /* AVCODEC_VERSION_MAJOR_H */


// Parsed from <libavcodec/version.h>

/*
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

// #ifndef AVCODEC_VERSION_H
// #define AVCODEC_VERSION_H

/**
 * \file
 * \ingroup libavc
 * Libavcodec version macros.
 */

// #include "libavutil/version.h"

// #include "version_major.h"

public static final int LIBAVCODEC_VERSION_MINOR =  31;
public static final int LIBAVCODEC_VERSION_MICRO = 102;

public static native @MemberGetter int LIBAVCODEC_VERSION_INT();
public static final int LIBAVCODEC_VERSION_INT = LIBAVCODEC_VERSION_INT();
// #define LIBAVCODEC_VERSION      AV_VERSION(LIBAVCODEC_VERSION_MAJOR,
//                                            LIBAVCODEC_VERSION_MINOR,
//                                            LIBAVCODEC_VERSION_MICRO)
public static final int LIBAVCODEC_BUILD =        LIBAVCODEC_VERSION_INT;

public static native @MemberGetter String LIBAVCODEC_IDENT();
public static final String LIBAVCODEC_IDENT = LIBAVCODEC_IDENT();

// #endif /* AVCODEC_VERSION_H */


}
