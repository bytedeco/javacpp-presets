// Targeted by JavaCPP version 1.5.7: DO NOT EDIT THIS FILE

package org.bytedeco.caffe.global;

import org.bytedeco.caffe.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;
import org.bytedeco.opencv.opencv_core.*;
import static org.bytedeco.opencv.global.opencv_core.*;
import org.bytedeco.opencv.opencv_imgproc.*;
import static org.bytedeco.opencv.global.opencv_imgproc.*;
import static org.bytedeco.opencv.global.opencv_imgcodecs.*;
import org.bytedeco.opencv.opencv_videoio.*;
import static org.bytedeco.opencv.global.opencv_videoio.*;
import org.bytedeco.opencv.opencv_highgui.*;
import static org.bytedeco.opencv.global.opencv_highgui.*;
import org.bytedeco.hdf5.*;
import static org.bytedeco.hdf5.global.hdf5.*;

public class caffe extends org.bytedeco.caffe.presets.caffe {
    static { Loader.load(); }

// Targeting ../FloatRegistry.java


// Targeting ../DoubleRegistry.java


// Targeting ../StringIntMap.java


// Targeting ../StringVector.java


// Targeting ../FieldDescriptorVector.java


// Targeting ../DatumVector.java


// Targeting ../FloatBlobSharedVector.java


// Targeting ../DoubleBlobSharedVector.java


// Targeting ../FloatLayerSharedVector.java


// Targeting ../DoubleLayerSharedVector.java


// Targeting ../FloatNetSharedVector.java


// Targeting ../DoubleNetSharedVector.java


// Targeting ../FloatBlobVector.java


// Targeting ../DoubleBlobVector.java


// Targeting ../FloatBlobVectorVector.java


// Targeting ../DoubleBlobVectorVector.java


// Targeting ../BoolVector.java


// Targeting ../BoolVectorVector.java


// Targeting ../FloatCallbackVector.java


// Targeting ../DoubleCallbackVector.java


// Targeting ../LongLongPair.java


// Parsed from caffe/caffe.hpp

// caffe.hpp is the header file that you need to include in your code. It wraps
// all the internal caffe header files into one for simpler inclusion.

// #ifndef CAFFE_CAFFE_HPP_
// #define CAFFE_CAFFE_HPP_

// #include "caffe/blob.hpp"
// #include "caffe/common.hpp"
// #include "caffe/filler.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/layer_factory.hpp"
// #include "caffe/net.hpp"
// #include "caffe/parallel.hpp"
// #include "caffe/proto/caffe.pb.h"
// #include "caffe/solver.hpp"
// #include "caffe/solver_factory.hpp"
// #include "caffe/util/benchmark.hpp"
// #include "caffe/util/io.hpp"
// #include "caffe/util/upgrade_proto.hpp"

// #endif  // CAFFE_CAFFE_HPP_


// Parsed from caffe/util/device_alternate.hpp

// #ifndef CAFFE_UTIL_DEVICE_ALTERNATE_H_
// #define CAFFE_UTIL_DEVICE_ALTERNATE_H_

// #ifdef CPU_ONLY  // CPU-only Caffe.

// #include <vector>

// Stub out GPU calls as unavailable.

// #define NO_GPU LOG(FATAL) << "Cannot use GPU in CPU-only Caffe: check mode."

// #define STUB_GPU(classname)
// template <typename Dtype>
// void classname<Dtype>::Forward_gpu(const vector<Blob<Dtype>*>& bottom,
//     const vector<Blob<Dtype>*>& top) { NO_GPU; }
// template <typename Dtype>
// void classname<Dtype>::Backward_gpu(const vector<Blob<Dtype>*>& top,
//     const vector<bool>& propagate_down,
//     const vector<Blob<Dtype>*>& bottom) { NO_GPU; } 

// #define STUB_GPU_FORWARD(classname, funcname)
// template <typename Dtype>
// void classname<Dtype>::funcname##_##gpu(const vector<Blob<Dtype>*>& bottom,
//     const vector<Blob<Dtype>*>& top) { NO_GPU; } 

// #define STUB_GPU_BACKWARD(classname, funcname)
// template <typename Dtype>
// void classname<Dtype>::funcname##_##gpu(const vector<Blob<Dtype>*>& top,
//     const vector<bool>& propagate_down,
//     const vector<Blob<Dtype>*>& bottom) { NO_GPU; } 

// #else  // Normal GPU + CPU Caffe.

// #endif  // CPU_ONLY

// #endif  // CAFFE_UTIL_DEVICE_ALTERNATE_H_


// Parsed from google/protobuf/stubs/common.h

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: kenton@google.com (Kenton Varda) and others
//
// Contains basic types and utilities used by the rest of the library.

// #ifndef GOOGLE_PROTOBUF_COMMON_H__
// #define GOOGLE_PROTOBUF_COMMON_H__

// #include <algorithm>
// #include <iostream>
// #include <map>
// #include <memory>
// #include <set>
// #include <string>
// #include <vector>

// #include <google/protobuf/stubs/port.h>
// #include <google/protobuf/stubs/macros.h>
// #include <google/protobuf/stubs/platform_macros.h>

// #ifndef PROTOBUF_USE_EXCEPTIONS
// #if defined(_MSC_VER) && defined(_CPPUNWIND)
  public static final int PROTOBUF_USE_EXCEPTIONS = 1;
// #elif defined(__EXCEPTIONS)
// #else
// #endif
// #endif

// #if PROTOBUF_USE_EXCEPTIONS
// #include <exception>
// #endif
// #if defined(__APPLE__)
// #include <TargetConditionals.h>  // for TARGET_OS_IPHONE
// #endif

// #if defined(__ANDROID__) || defined(GOOGLE_PROTOBUF_OS_ANDROID) || (defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE) || defined(GOOGLE_PROTOBUF_OS_IPHONE)
// #include <pthread.h>
// #endif

// #include <google/protobuf/port_def.inc>



// Some of these constants are macros rather than const ints so that they can
// be used in #if directives.

// The current version, represented as a single integer to make comparison
// easier:  major * 10^6 + minor * 10^3 + micro
public static final int GOOGLE_PROTOBUF_VERSION = 3007001;

// A suffix string for alpha, beta or rc releases. Empty for stable releases.
public static final String GOOGLE_PROTOBUF_VERSION_SUFFIX = "";

// The minimum header version which works with the current version of
// the library.  This constant should only be used by protoc's C++ code
// generator.
@Namespace("google::protobuf::internal") @MemberGetter public static native int kMinHeaderVersionForLibrary();
public static final int kMinHeaderVersionForLibrary = kMinHeaderVersionForLibrary();

// The minimum protoc version which works with the current version of the
// headers.
public static final int GOOGLE_PROTOBUF_MIN_PROTOC_VERSION = 3007000;

// The minimum header version which works with the current version of
// protoc.  This constant should only be used in VerifyVersion().
@Namespace("google::protobuf::internal") @MemberGetter public static native int kMinHeaderVersionForProtoc();
public static final int kMinHeaderVersionForProtoc = kMinHeaderVersionForProtoc();

// Verifies that the headers and libraries are compatible.  Use the macro
// below to call this.
@Namespace("google::protobuf::internal") public static native void VerifyVersion(int headerVersion, int minLibraryVersion,
                                   @Cast("const char*") BytePointer filename);
@Namespace("google::protobuf::internal") public static native void VerifyVersion(int headerVersion, int minLibraryVersion,
                                   String filename);

// Converts a numeric version number to a string.
@Namespace("google::protobuf::internal") public static native @StdString BytePointer VersionString(int version);

  // namespace internal

// Place this macro in your main() function (or somewhere before you attempt
// to use the protobuf library) to verify that the version you link against
// matches the headers you compiled against.  If a version mismatch is
// detected, the process will abort.
// #define GOOGLE_PROTOBUF_VERIFY_VERSION
//   ::google::protobuf::internal::VerifyVersion(
//     GOOGLE_PROTOBUF_VERSION, GOOGLE_PROTOBUF_MIN_LIBRARY_VERSION,
//     __FILE__)
// Targeting ../StringPiece.java



// Checks if the buffer contains structurally-valid UTF-8.  Implemented in
// structurally_valid.cc.
@Namespace("google::protobuf::internal") public static native @Cast("bool") boolean IsStructurallyValidUTF8(@Cast("const char*") BytePointer buf, int len);
@Namespace("google::protobuf::internal") public static native @Cast("bool") boolean IsStructurallyValidUTF8(String buf, int len);

@Namespace("google::protobuf::internal") public static native @Cast("bool") boolean IsStructurallyValidUTF8(@StdString BytePointer str);
@Namespace("google::protobuf::internal") public static native @Cast("bool") boolean IsStructurallyValidUTF8(@StdString String str);

// Returns initial number of bytes of structually valid UTF-8.
@Namespace("google::protobuf::internal") public static native int UTF8SpnStructurallyValid(@Const @ByRef StringPiece str);

// Coerce UTF-8 byte string in src_str to be
// a structurally-valid equal-length string by selectively
// overwriting illegal bytes with replace_char (typically ' ' or '?').
// replace_char must be legal printable 7-bit Ascii 0x20..0x7e.
// src_str is read-only.
//
// Returns pointer to output buffer, src_str.data() if no changes were made,
//  or idst if some bytes were changed. idst is allocated by the caller
//  and must be at least as big as src_str
//
// Optimized for: all structurally valid and no byte copying is done.
//
@Namespace("google::protobuf::internal") public static native @Cast("char*") BytePointer UTF8CoerceToStructurallyValid(@Const @ByRef StringPiece str,
                                                    @Cast("char*") BytePointer dst,
                                                    @Cast("char") byte replace_char);
@Namespace("google::protobuf::internal") public static native @Cast("char*") ByteBuffer UTF8CoerceToStructurallyValid(@Const @ByRef StringPiece str,
                                                    @Cast("char*") ByteBuffer dst,
                                                    @Cast("char") byte replace_char);
@Namespace("google::protobuf::internal") public static native @Cast("char*") byte[] UTF8CoerceToStructurallyValid(@Const @ByRef StringPiece str,
                                                    @Cast("char*") byte[] dst,
                                                    @Cast("char") byte replace_char);

  // namespace internal


// ===================================================================
// Shutdown support.

// Shut down the entire protocol buffers library, deleting all static-duration
// objects allocated by the library or by generated .pb.cc files.
//
// There are two reasons you might want to call this:
// * You use a draconian definition of "memory leak" in which you expect
//   every single malloc() to have a corresponding free(), even for objects
//   which live until program exit.
// * You are writing a dynamically-loaded library which needs to clean up
//   after itself when the library is unloaded.
//
// It is safe to call this multiple times.  However, it is not safe to use
// any other part of the protocol buffers library after
// ShutdownProtobufLibrary() has been called. Furthermore this call is not
// thread safe, user needs to synchronize multiple calls.
@Namespace("google::protobuf") public static native void ShutdownProtobufLibrary();
// Targeting ../Func.java


@Namespace("google::protobuf::internal") public static native void OnShutdown(Func func);
// Targeting ../F_Pointer.java


@Namespace("google::protobuf::internal") public static native void OnShutdownRun(F_Pointer f, @Const Pointer arg);


// Targeting ../FatalException.java


// #endif

// This is at the end of the file instead of the beginning to work around a bug
// in some versions of MSVC.

  // namespace protobuf
  // namespace google

// #include <google/protobuf/port_undef.inc>

// #endif  // GOOGLE_PROTOBUF_COMMON_H__


// Parsed from google/protobuf/arena.h

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// This file defines an Arena allocator for better allocation performance.

// #ifndef GOOGLE_PROTOBUF_ARENA_H__
// #define GOOGLE_PROTOBUF_ARENA_H__

// #include <limits>
// #ifdef max
// #undef max  // Visual Studio defines this macro
// #endif
// #if defined(_MSC_VER) && !defined(_LIBCPP_STD_VER) && !_HAS_EXCEPTIONS
// Work around bugs in MSVC <typeinfo> header when _HAS_EXCEPTIONS=0.
// #include <exception>
// #include <typeinfo>

// #else
// #include <typeinfo>
// #endif

// #include <google/protobuf/arena_impl.h>
// #include <google/protobuf/port.h>
// #include <type_traits>

// #include <google/protobuf/port_def.inc>

// #ifdef SWIG
// #error "You cannot SWIG proto headers"
// #endif  // defined below

  // namespace protobuf
  // namespace google          // defined below        // defined in message.h

@Namespace("google::protobuf::arena_metrics") public static native void EnableArenaMetrics(ArenaOptions options);


// Targeting ../ArenaStringPtr.java


// Targeting ../LazyField.java

           // defined in lazy_field.h  // defined in repeated_field.h

// Templated cleanup methods.
@Namespace("google::protobuf::internal") public static native void arena_free(Pointer object, @Cast("size_t") long size);


// Targeting ../ArenaOptions.java



// Support for non-RTTI environments. (The metrics hooks API uses type
// information.)
// #if PROTOBUF_RTTI
// #define RTTI_TYPE_ID(type) (&typeid(type))
// #else
// #define RTTI_TYPE_ID(type) (NULL)
// Targeting ../Arena.java



// Defined above for supporting environments without RTTI.
// #undef RTTI_TYPE_ID

  // namespace protobuf
  // namespace google

// #include <google/protobuf/port_undef.inc>

// #endif  // GOOGLE_PROTOBUF_ARENA_H__


// Parsed from google/protobuf/descriptor.h

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// This file contains classes which describe a type of protocol message.
// You can use a message's descriptor to learn at runtime what fields
// it contains and what the types of those fields are.  The Message
// interface also allows you to dynamically access and modify individual
// fields by passing the FieldDescriptor of the field you are interested
// in.
//
// Most users will not care about descriptors, because they will write
// code specific to certain protocol types and will simply use the classes
// generated by the protocol compiler directly.  Advanced users who want
// to operate on arbitrary types (not known at compile time) may want to
// read descriptors in order to learn about the contents of a message.
// A very small number of users will want to construct their own
// Descriptors, either because they are implementing Message manually or
// because they are writing something like the protocol compiler.
//
// For an example of how you might use descriptors, see the code example
// at the top of message.h.

// #ifndef GOOGLE_PROTOBUF_DESCRIPTOR_H__
// #define GOOGLE_PROTOBUF_DESCRIPTOR_H__

// #include <memory>
// #include <set>
// #include <string>
// #include <vector>
// #include <google/protobuf/stubs/common.h>
// #include <google/protobuf/stubs/mutex.h>
// #include <google/protobuf/stubs/once.h>

// #include <google/protobuf/port_def.inc>

// TYPE_BOOL is defined in the MacOS's ConditionalMacros.h.
// #ifdef TYPE_BOOL
// #undef TYPE_BOOL
// #endif  // TYPE_BOOL

// #ifdef SWIG
// #define PROTOBUF_EXPORT
// #endif
// Targeting ../DescriptorDatabase.java


// Targeting ../DescriptorProto.java


// Targeting ../DescriptorProto_ExtensionRange.java


// Targeting ../FieldDescriptorProto.java


// Targeting ../OneofDescriptorProto.java


// Targeting ../EnumDescriptorProto.java


// Targeting ../EnumValueDescriptorProto.java


// Targeting ../ServiceDescriptorProto.java


// Targeting ../MethodDescriptorProto.java


// Targeting ../FileDescriptorProto.java


// Targeting ../MessageOptions.java


// Targeting ../FieldOptions.java


// Targeting ../OneofOptions.java


// Targeting ../EnumOptions.java


// Targeting ../EnumValueOptions.java


// Targeting ../ExtensionRangeOptions.java


// Targeting ../ServiceOptions.java


// Targeting ../MethodOptions.java


// Targeting ../FileOptions.java


// Targeting ../UninterpretedOption.java


// Targeting ../SourceCodeInfo.java



// Defined in message.h
// Targeting ../DescriptorBuilder.java


// Targeting ../FileDescriptorTables.java


// Targeting ../Symbol.java


// Targeting ../UnknownField.java


// Targeting ../GeneratedMessageReflection.java



// Targeting ../CommandLineInterface.java


// Defined in helpers.h
  // namespace cpp

// Targeting ../DescriptorTest.java



// Targeting ../Printer.java



// Targeting ../SourceLocation.java


// Targeting ../DebugStringOptions.java


// Targeting ../LazyDescriptor.java



// Targeting ../Descriptor.java


// Targeting ../FieldDescriptor.java


// Targeting ../OneofDescriptor.java


// Targeting ../EnumDescriptor.java


// Targeting ../EnumValueDescriptor.java


// Targeting ../ServiceDescriptor.java


// Targeting ../MethodDescriptor.java


// Targeting ../FileDescriptor.java


// Targeting ../DescriptorPool.java




// inline methods ====================================================

// These macros makes this repetitive code more readable.
// #define PROTOBUF_DEFINE_ACCESSOR(CLASS, FIELD, TYPE)
//   inline TYPE CLASS::FIELD() const { return FIELD##_; }

// Strings fields are stored as pointers but returned as const references.
// #define PROTOBUF_DEFINE_STRING_ACCESSOR(CLASS, FIELD)
//   inline const std::string& CLASS::FIELD() const { return *FIELD##_; }

// Arrays take an index parameter, obviously.
// #define PROTOBUF_DEFINE_ARRAY_ACCESSOR(CLASS, FIELD, TYPE)
//   inline TYPE CLASS::FIELD(int index) const { return FIELD##s_ + index; }

// #define PROTOBUF_DEFINE_OPTIONS_ACCESSOR(CLASS, TYPE)
//   inline const TYPE& CLASS::options() const { return *options_; }













































































































// #undef PROTOBUF_DEFINE_ACCESSOR
// #undef PROTOBUF_DEFINE_STRING_ACCESSOR
// #undef PROTOBUF_DEFINE_ARRAY_ACCESSOR

// A few accessors differ from the macros...







// Can't use PROTOBUF_DEFINE_ARRAY_ACCESSOR because reserved_names_ is actually
// an array of pointers rather than the usual array of objects.






// Can't use PROTOBUF_DEFINE_ARRAY_ACCESSOR because reserved_names_ is actually
// an array of pointers rather than the usual array of objects.














// To save space, index() is computed by looking at the descriptor's position
// in the parent's array of children.








































// Can't use PROTOBUF_DEFINE_ARRAY_ACCESSOR because fields_ is actually an array
// of pointers rather than the usual array of objects.


  // namespace protobuf
  // namespace google

// #include <google/protobuf/port_undef.inc>

// #endif  // GOOGLE_PROTOBUF_DESCRIPTOR_H__


// Parsed from google/protobuf/message_lite.h

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Authors: wink@google.com (Wink Saville),
//          kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// Defines MessageLite, the abstract interface implemented by all (lite
// and non-lite) protocol message objects.

// #ifndef GOOGLE_PROTOBUF_MESSAGE_LITE_H__
// #define GOOGLE_PROTOBUF_MESSAGE_LITE_H__

// #include <climits>
// #include <string>
// #include <google/protobuf/stubs/common.h>
// #include <google/protobuf/stubs/logging.h>
// #include <google/protobuf/arena.h>
// #include <google/protobuf/stubs/once.h>
// #include <google/protobuf/port.h>
// #include <google/protobuf/stubs/strutil.h>


// #include <google/protobuf/port_def.inc>

// #ifdef SWIG
// #error "You cannot SWIG proto headers"
// #endif
// Targeting ../CodedInputStream.java


// Targeting ../CodedOutputStream.java


// Targeting ../ZeroCopyInputStream.java


// Targeting ../ZeroCopyOutputStream.java



  // namespace io
// Targeting ../RepeatedPtrFieldBase.java


// Targeting ../WireFormatLite.java


// Targeting ../WeakFieldMap.java



// We compute sizes as size_t but cache them as int.  This function converts a
// computed size to a cached size.  Since we don't proceed with serialization
// if the total size was > INT_MAX, it is not important what this function
// returns for inputs > INT_MAX.  However this case should not error or
// GOOGLE_CHECK-fail, because the full size_t resolution is still returned from
// ByteSizeLong() and checked against INT_MAX; we can catch the overflow
// there.
@Namespace("google::protobuf::internal") public static native int ToCachedSize(@Cast("size_t") long size);

// We mainly calculate sizes in terms of size_t, but some functions that
// compute sizes return "int".  These int sizes are expected to always be
// positive. This function is more efficient than casting an int to size_t
// directly on 64-bit platforms because it avoids making the compiler emit a
// sign extending instruction, which we don't want and don't want to pay for.
@Namespace("google::protobuf::internal") public static native @Cast("size_t") long FromIntSize(int size);

// For cases where a legacy function returns an integer size.  We GOOGLE_DCHECK()
// that the conversion will fit within an integer; if this is false then we
// are losing information.
@Namespace("google::protobuf::internal") public static native int ToIntSize(@Cast("size_t") long size);

// This type wraps a variable whose constructor and destructor are explicitly
// called. It is particularly useful for a global variable, without its
// constructor and destructor run on start and end of the program lifetime.
// This circumvents the initial construction order fiasco, while keeping
// the address of the empty string a compile time constant.
//
// Pay special attention to the initialization state of the object.
// 1. The object is "uninitialized" to begin with.
// 2. Call DefaultConstruct() only if the object is uninitialized.
//    After the call, the object becomes "initialized".
// 3. Call get() and get_mutable() only if the object is initialized.
// 4. Call Destruct() only if the object is initialized.
//    After the call, the object becomes uninitialized.

// Default empty string object. Don't use this directly. Instead, call
// GetEmptyString() to get the reference.


@Namespace("google::protobuf::internal") public static native @StdString BytePointer GetEmptyStringAlreadyInited();

@Namespace("google::protobuf::internal") public static native @Cast("size_t") long StringSpaceUsedExcludingSelfLong(@StdString BytePointer str);
@Namespace("google::protobuf::internal") public static native @Cast("size_t") long StringSpaceUsedExcludingSelfLong(@StdString String str);


// Targeting ../MessageLite.java










// Targeting ../BoundedZCIS.java









  // namespace internal



  // namespace protobuf
  // namespace google

// #include <google/protobuf/port_undef.inc>

// #endif  // GOOGLE_PROTOBUF_MESSAGE_LITE_H__


// Parsed from google/protobuf/message.h

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// Defines Message, the abstract interface implemented by non-lite
// protocol message objects.  Although it's possible to implement this
// interface manually, most users will use the protocol compiler to
// generate implementations.
//
// Example usage:
//
// Say you have a message defined as:
//
//   message Foo {
//     optional string text = 1;
//     repeated int32 numbers = 2;
//   }
//
// Then, if you used the protocol compiler to generate a class from the above
// definition, you could use it like so:
//
//   string data;  // Will store a serialized version of the message.
//
//   {
//     // Create a message and serialize it.
//     Foo foo;
//     foo.set_text("Hello World!");
//     foo.add_numbers(1);
//     foo.add_numbers(5);
//     foo.add_numbers(42);
//
//     foo.SerializeToString(&data);
//   }
//
//   {
//     // Parse the serialized message and check that it contains the
//     // correct data.
//     Foo foo;
//     foo.ParseFromString(data);
//
//     assert(foo.text() == "Hello World!");
//     assert(foo.numbers_size() == 3);
//     assert(foo.numbers(0) == 1);
//     assert(foo.numbers(1) == 5);
//     assert(foo.numbers(2) == 42);
//   }
//
//   {
//     // Same as the last block, but do it dynamically via the Message
//     // reflection interface.
//     Message* foo = new Foo;
//     const Descriptor* descriptor = foo->GetDescriptor();
//
//     // Get the descriptors for the fields we're interested in and verify
//     // their types.
//     const FieldDescriptor* text_field = descriptor->FindFieldByName("text");
//     assert(text_field != NULL);
//     assert(text_field->type() == FieldDescriptor::TYPE_STRING);
//     assert(text_field->label() == FieldDescriptor::LABEL_OPTIONAL);
//     const FieldDescriptor* numbers_field = descriptor->
//                                            FindFieldByName("numbers");
//     assert(numbers_field != NULL);
//     assert(numbers_field->type() == FieldDescriptor::TYPE_INT32);
//     assert(numbers_field->label() == FieldDescriptor::LABEL_REPEATED);
//
//     // Parse the message.
//     foo->ParseFromString(data);
//
//     // Use the reflection interface to examine the contents.
//     const Reflection* reflection = foo->GetReflection();
//     assert(reflection->GetString(*foo, text_field) == "Hello World!");
//     assert(reflection->FieldSize(*foo, numbers_field) == 3);
//     assert(reflection->GetRepeatedInt32(*foo, numbers_field, 0) == 1);
//     assert(reflection->GetRepeatedInt32(*foo, numbers_field, 1) == 5);
//     assert(reflection->GetRepeatedInt32(*foo, numbers_field, 2) == 42);
//
//     delete foo;
//   }

// #ifndef GOOGLE_PROTOBUF_MESSAGE_H__
// #define GOOGLE_PROTOBUF_MESSAGE_H__

// #include <iosfwd>
// #include <string>
// #include <type_traits>
// #include <vector>

// #include <google/protobuf/stubs/casts.h>
// #include <google/protobuf/stubs/common.h>
// #include <google/protobuf/arena.h>
// #include <google/protobuf/descriptor.h>
// #include <google/protobuf/message_lite.h>
// #include <google/protobuf/port.h>


// #define GOOGLE_PROTOBUF_HAS_ONEOF
// #define GOOGLE_PROTOBUF_HAS_ARENAS

// #include <google/protobuf/port_def.inc>

// #ifdef SWIG
// #error "You cannot SWIG proto headers"
// #endif

// Defined in this file.
// Targeting ../MapKey.java


// Targeting ../MapValueRef.java


// Targeting ../MapIterator.java


// Targeting ../MapReflectionTester.java


// Targeting ../MapFieldBase.java



// Targeting ../UnknownFieldSet.java

         // unknown_field_set.h     // zero_copy_stream.h    // zero_copy_stream.h        // coded_stream.h       // coded_stream.h

// Targeting ../MapReflectionFriend.java

     // scalar_map_container.h

// Targeting ../CelMapReflectionFriend.java

  // field_backed_map_impl.cc

// Targeting ../MapFieldPrinterHelper.java

   // text_format.cc

// Targeting ../ReflectionAccessor.java


// Targeting ../ReflectionOps.java


// Targeting ../MapKeySorter.java


// Targeting ../WireFormat.java


// Targeting ../MapFieldReflectionTest.java

  // map_test.cc
     // repeated_field.h
// Targeting ../Metadata.java


// Targeting ../Message.java


// Targeting ../RepeatedFieldAccessor.java


  // namespace internal

// Forward-declare RepeatedFieldRef templates. The second type parameter is
// used for SFINAE tricks. Users should ignore it.
// Targeting ../Reflection.java


// Targeting ../MessageFactory.java



// #define DECLARE_GET_REPEATED_FIELD(TYPE)
//   template <>
//   PROTOBUF_EXPORT const RepeatedField<TYPE>&
//   Reflection::GetRepeatedField<TYPE>(const Message& message,
//                                      const FieldDescriptor* field) const;
// 
//   template <>
//   PROTOBUF_EXPORT RepeatedField<TYPE>* Reflection::MutableRepeatedField<TYPE>(
//       Message * message, const FieldDescriptor* field) const;



  


  


  


  


  


  


  

// #undef DECLARE_GET_REPEATED_FIELD

// Tries to downcast this message to a generated message type.  Returns NULL if
// this class is not an instance of T.  This works even if RTTI is disabled.
//
// This also has the effect of creating a strong reference to T that will
// prevent the linker from stripping it out at link time.  This can be important
// if you are using a DynamicMessageFactory that delegates to the generated
// factory.

// Legacy functions, to preserve compatibility with existing callers.
// These had a slightly different signature, so we have to adjust "T".

  // namespace internal

// =============================================================================
// Implementation details for {Get,Mutable}RawRepeatedPtrField.  We provide
// specializations for <string>, <StringPieceField> and <Message> and handle
// everything else with the default template which will match any type having
// a method with signature "static const google::protobuf::Descriptor* descriptor()".
// Such a type presumably is a descendant of google::protobuf::Message.






// -----








  // namespace protobuf
  // namespace google

// #include <google/protobuf/port_undef.inc>

// #endif  // GOOGLE_PROTOBUF_MESSAGE_H__


// Parsed from caffe/common.hpp

// #ifndef CAFFE_COMMON_HPP_
// #define CAFFE_COMMON_HPP_

// #include <boost/shared_ptr.hpp>
// #include <gflags/gflags.h>
// #include <glog/logging.h>

// #include <climits>
// #include <cmath>
// #include <fstream>  // NOLINT(readability/streams)
// #include <iostream>  // NOLINT(readability/streams)
// #include <map>
// #include <set>
// #include <sstream>
// #include <string>
// #include <utility>  // pair
// #include <vector>

// #include "caffe/util/device_alternate.hpp"

// Convert macro to string
// #define STRINGIFY(m) #m
// #define AS_STRING(m) STRINGIFY(m)

// gflags 2.1 issue: namespace google was changed to gflags without warning.
// Luckily we will be able to use GFLAGS_GFLAGS_H_ to detect if it is version
// 2.1. If yes, we will add a temporary solution to redirect the namespace.
// TODO(Yangqing): Once gflags solves the problem in a more elegant way, let's
// remove the following hack.
// #ifndef GFLAGS_GFLAGS_H_
// #endif  // GFLAGS_GFLAGS_H_

// Disable the copy and assignment operator for a class.
// #define DISABLE_COPY_AND_ASSIGN(classname)
// private:
//   classname(const classname&);
//   classname& operator=(const classname&)

// Instantiate a class with float and double specifications.
// #define INSTANTIATE_CLASS(classname)
//   char gInstantiationGuard##classname;
//   template class classname<float>;
//   template class classname<double>

// #define INSTANTIATE_LAYER_GPU_FORWARD(classname)
//   template void classname<float>::Forward_gpu(
//       const std::vector<Blob<float>*>& bottom,
//       const std::vector<Blob<float>*>& top);
//   template void classname<double>::Forward_gpu(
//       const std::vector<Blob<double>*>& bottom,
//       const std::vector<Blob<double>*>& top);

// #define INSTANTIATE_LAYER_GPU_BACKWARD(classname)
//   template void classname<float>::Backward_gpu(
//       const std::vector<Blob<float>*>& top,
//       const std::vector<bool>& propagate_down,
//       const std::vector<Blob<float>*>& bottom);
//   template void classname<double>::Backward_gpu(
//       const std::vector<Blob<double>*>& top,
//       const std::vector<bool>& propagate_down,
//       const std::vector<Blob<double>*>& bottom)

// #define INSTANTIATE_LAYER_GPU_FUNCS(classname)
//   INSTANTIATE_LAYER_GPU_FORWARD(classname);
//   INSTANTIATE_LAYER_GPU_BACKWARD(classname)

// A simple macro to mark codes that are not implemented, so that when the code
// is executed we will see a fatal log.
// #define NOT_IMPLEMENTED LOG(FATAL) << "Not Implemented Yet"

// See PR #1236 

// We will use the boost shared_ptr instead of the new C++11 one mainly
// because cuda does not work (at least now) well with C++11 features.

// Common functions and classes from std that caffe often uses.

// A global initialization function that you should call in your main function.
// Currently it initializes google flags and google logging.
@Namespace("caffe") public static native void GlobalInit(IntPointer pargc, @Cast("char***") @ByPtrPtr PointerPointer pargv);
@Namespace("caffe") public static native void GlobalInit(IntBuffer pargc, @Cast("char***") @ByPtrPtr PointerPointer pargv);
@Namespace("caffe") public static native void GlobalInit(int[] pargc, @Cast("char***") @ByPtrPtr PointerPointer pargv);
// Targeting ../Caffe.java



  // namespace caffe

// #endif  // CAFFE_COMMON_HPP_


// Parsed from google/protobuf/generated_message_table_driven.h

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// #ifndef GOOGLE_PROTOBUF_GENERATED_MESSAGE_TABLE_DRIVEN_H__
// #define GOOGLE_PROTOBUF_GENERATED_MESSAGE_TABLE_DRIVEN_H__

// #include <google/protobuf/map.h>
// #include <google/protobuf/map_entry_lite.h>
// #include <google/protobuf/map_field_lite.h>
// #include <google/protobuf/message_lite.h>
// #include <google/protobuf/wire_format_lite.h>
// #include <google/protobuf/wire_format_lite_inl.h>

// We require C++11 and Clang to use constexpr for variables, as GCC 4.8
// requires constexpr to be consistent between declarations of variables
// unnecessarily (see https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58541).
// VS 2017 Update 3 also supports this usage of constexpr.
// #if defined(__clang__) || (defined(_MSC_VER) && _MSC_VER >= 1911)
// #define PROTOBUF_CONSTEXPR_VAR constexpr
// #else  // !__clang__
// #define PROTOBUF_CONSTEXPR_VAR
// #endif  // !_clang

// #ifdef SWIG
// #error "You cannot SWIG proto headers"
// #endif

// #include <google/protobuf/port_def.inc>

// Processing-type masks.
@Namespace("google::protobuf::internal") @MemberGetter public static native @Cast("const unsigned char") byte kOneofMask();
public static final byte kOneofMask = kOneofMask();
@Namespace("google::protobuf::internal") @MemberGetter public static native @Cast("const unsigned char") byte kRepeatedMask();
public static final byte kRepeatedMask = kRepeatedMask();
// Mask for the raw type: either a WireFormatLite::FieldType or one of the
// ProcessingTypes below, without the oneof or repeated flag.
@Namespace("google::protobuf::internal") @MemberGetter public static native @Cast("const unsigned char") byte kTypeMask();
public static final byte kTypeMask = kTypeMask();

// Wire type masks.
@Namespace("google::protobuf::internal") @MemberGetter public static native @Cast("const unsigned char") byte kNotPackedMask();
public static final byte kNotPackedMask = kNotPackedMask();
@Namespace("google::protobuf::internal") @MemberGetter public static native @Cast("const unsigned char") byte kInvalidMask();
public static final byte kInvalidMask = kInvalidMask();

/** enum google::protobuf::internal::ProcessingTypes */
public static final int
  TYPE_STRING_CORD = 19,
  TYPE_STRING_STRING_PIECE = 20,
  TYPE_BYTES_CORD = 21,
  TYPE_BYTES_STRING_PIECE = 22,
  TYPE_STRING_INLINED = 23,
  TYPE_BYTES_INLINED = 24,
  TYPE_MAP = 25;
// Targeting ../ParseTableField.java


// Targeting ../AuxillaryParseTableField.java


// Targeting ../ParseTable.java


// The tables must be composed of POD components to ensure link-time
// initialization.

// #ifndef __NVCC__  // This assertion currently fails under NVCC.
// #endif

// TODO(ckennelly): Consolidate these implementations into a single one, using
// dynamic dispatch to the appropriate unknown field handler.
@Namespace("google::protobuf::internal") public static native @Cast("bool") boolean MergePartialFromCodedStream(MessageLite msg, @Const @ByRef ParseTable table,
                                 CodedInputStream input);
@Namespace("google::protobuf::internal") public static native @Cast("bool") boolean MergePartialFromCodedStreamLite(MessageLite msg, @Const @ByRef ParseTable table,
                                 CodedInputStream input);
// Targeting ../CompareHelper.java


// Targeting ../CompareMapKey.java



  // namespace internal
  // namespace protobuf
  // namespace google

// #include <google/protobuf/port_undef.inc>

// #endif  // GOOGLE_PROTOBUF_GENERATED_MESSAGE_TABLE_DRIVEN_H__


// Parsed from caffe/proto/caffe.pb.h

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: caffe.proto

// #ifndef PROTOBUF_INCLUDED_caffe_2eproto
// #define PROTOBUF_INCLUDED_caffe_2eproto

// #include <limits>
// #include <string>

// #include <google/protobuf/port_def.inc>
// #if PROTOBUF_VERSION < 3007000
// #error This file was generated by a newer version of protoc which is
// #error incompatible with your Protocol Buffer headers. Please update
// #error your headers.
// #endif
// #if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
// #error This file was generated by an older version of protoc which is
// #error incompatible with your Protocol Buffer headers. Please
// #error regenerate this file with a newer version of protoc.
// #endif

// #include <google/protobuf/port_undef.inc>
// #include <google/protobuf/io/coded_stream.h>
// #include <google/protobuf/arena.h>
// #include <google/protobuf/arenastring.h>
// #include <google/protobuf/generated_message_table_driven.h>
// #include <google/protobuf/generated_message_util.h>
// #include <google/protobuf/inlined_string_field.h>
// #include <google/protobuf/metadata.h>
// #include <google/protobuf/message.h>
// #include <google/protobuf/repeated_field.h>  // IWYU pragma: export
// #include <google/protobuf/extension_set.h>  // IWYU pragma: export
// #include <google/protobuf/generated_enum_reflection.h>
// #include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
// #include <google/protobuf/port_def.inc>
// #define PROTOBUF_INTERNAL_EXPORT_caffe_2eproto

// Internal implementation detail -- do not use these members.
public static native void AddDescriptors_caffe_2eproto();
  // namespace caffe





























































  // namespace protobuf
  // namespace google

/** enum caffe::FillerParameter_VarianceNorm */
public static final int
  FillerParameter_VarianceNorm_FAN_IN = 0,
  FillerParameter_VarianceNorm_FAN_OUT = 1,
  FillerParameter_VarianceNorm_AVERAGE = 2;
@Namespace("caffe") public static native @Cast("bool") boolean FillerParameter_VarianceNorm_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::FillerParameter_VarianceNorm") int FillerParameter_VarianceNorm_VarianceNorm_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::FillerParameter_VarianceNorm") int FillerParameter_VarianceNorm_VarianceNorm_MAX();
@Namespace("caffe") @MemberGetter public static native int FillerParameter_VarianceNorm_VarianceNorm_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor FillerParameter_VarianceNorm_descriptor();
@Namespace("caffe") public static native @StdString BytePointer FillerParameter_VarianceNorm_Name(@Cast("caffe::FillerParameter_VarianceNorm") int value);
@Namespace("caffe") public static native @Cast("bool") boolean FillerParameter_VarianceNorm_Parse(
    @StdString BytePointer name, @Cast("caffe::FillerParameter_VarianceNorm*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean FillerParameter_VarianceNorm_Parse(
    @StdString String name, @Cast("caffe::FillerParameter_VarianceNorm*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean FillerParameter_VarianceNorm_Parse(
    @StdString BytePointer name, @Cast("caffe::FillerParameter_VarianceNorm*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean FillerParameter_VarianceNorm_Parse(
    @StdString String name, @Cast("caffe::FillerParameter_VarianceNorm*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean FillerParameter_VarianceNorm_Parse(
    @StdString BytePointer name, @Cast("caffe::FillerParameter_VarianceNorm*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean FillerParameter_VarianceNorm_Parse(
    @StdString String name, @Cast("caffe::FillerParameter_VarianceNorm*") int[] value);
/** enum caffe::SolverParameter_SnapshotFormat */
public static final int
  SolverParameter_SnapshotFormat_HDF5 = 0,
  SolverParameter_SnapshotFormat_BINARYPROTO = 1;
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SnapshotFormat_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::SolverParameter_SnapshotFormat") int SolverParameter_SnapshotFormat_SnapshotFormat_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::SolverParameter_SnapshotFormat") int SolverParameter_SnapshotFormat_SnapshotFormat_MAX();
@Namespace("caffe") @MemberGetter public static native int SolverParameter_SnapshotFormat_SnapshotFormat_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor SolverParameter_SnapshotFormat_descriptor();
@Namespace("caffe") public static native @StdString BytePointer SolverParameter_SnapshotFormat_Name(@Cast("caffe::SolverParameter_SnapshotFormat") int value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SnapshotFormat_Parse(
    @StdString BytePointer name, @Cast("caffe::SolverParameter_SnapshotFormat*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SnapshotFormat_Parse(
    @StdString String name, @Cast("caffe::SolverParameter_SnapshotFormat*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SnapshotFormat_Parse(
    @StdString BytePointer name, @Cast("caffe::SolverParameter_SnapshotFormat*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SnapshotFormat_Parse(
    @StdString String name, @Cast("caffe::SolverParameter_SnapshotFormat*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SnapshotFormat_Parse(
    @StdString BytePointer name, @Cast("caffe::SolverParameter_SnapshotFormat*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SnapshotFormat_Parse(
    @StdString String name, @Cast("caffe::SolverParameter_SnapshotFormat*") int[] value);
/** enum caffe::SolverParameter_SolverMode */
public static final int
  SolverParameter_SolverMode_CPU = 0,
  SolverParameter_SolverMode_GPU = 1;
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SolverMode_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::SolverParameter_SolverMode") int SolverParameter_SolverMode_SolverMode_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::SolverParameter_SolverMode") int SolverParameter_SolverMode_SolverMode_MAX();
@Namespace("caffe") @MemberGetter public static native int SolverParameter_SolverMode_SolverMode_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor SolverParameter_SolverMode_descriptor();
@Namespace("caffe") public static native @StdString BytePointer SolverParameter_SolverMode_Name(@Cast("caffe::SolverParameter_SolverMode") int value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SolverMode_Parse(
    @StdString BytePointer name, @Cast("caffe::SolverParameter_SolverMode*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SolverMode_Parse(
    @StdString String name, @Cast("caffe::SolverParameter_SolverMode*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SolverMode_Parse(
    @StdString BytePointer name, @Cast("caffe::SolverParameter_SolverMode*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SolverMode_Parse(
    @StdString String name, @Cast("caffe::SolverParameter_SolverMode*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SolverMode_Parse(
    @StdString BytePointer name, @Cast("caffe::SolverParameter_SolverMode*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SolverMode_Parse(
    @StdString String name, @Cast("caffe::SolverParameter_SolverMode*") int[] value);
/** enum caffe::SolverParameter_SolverType */
public static final int
  SolverParameter_SolverType_SGD = 0,
  SolverParameter_SolverType_NESTEROV = 1,
  SolverParameter_SolverType_ADAGRAD = 2,
  SolverParameter_SolverType_RMSPROP = 3,
  SolverParameter_SolverType_ADADELTA = 4,
  SolverParameter_SolverType_ADAM = 5;
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SolverType_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::SolverParameter_SolverType") int SolverParameter_SolverType_SolverType_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::SolverParameter_SolverType") int SolverParameter_SolverType_SolverType_MAX();
@Namespace("caffe") @MemberGetter public static native int SolverParameter_SolverType_SolverType_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor SolverParameter_SolverType_descriptor();
@Namespace("caffe") public static native @StdString BytePointer SolverParameter_SolverType_Name(@Cast("caffe::SolverParameter_SolverType") int value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SolverType_Parse(
    @StdString BytePointer name, @Cast("caffe::SolverParameter_SolverType*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SolverType_Parse(
    @StdString String name, @Cast("caffe::SolverParameter_SolverType*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SolverType_Parse(
    @StdString BytePointer name, @Cast("caffe::SolverParameter_SolverType*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SolverType_Parse(
    @StdString String name, @Cast("caffe::SolverParameter_SolverType*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SolverType_Parse(
    @StdString BytePointer name, @Cast("caffe::SolverParameter_SolverType*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean SolverParameter_SolverType_Parse(
    @StdString String name, @Cast("caffe::SolverParameter_SolverType*") int[] value);
/** enum caffe::ParamSpec_DimCheckMode */
public static final int
  ParamSpec_DimCheckMode_STRICT = 0,
  ParamSpec_DimCheckMode_PERMISSIVE = 1;
@Namespace("caffe") public static native @Cast("bool") boolean ParamSpec_DimCheckMode_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::ParamSpec_DimCheckMode") int ParamSpec_DimCheckMode_DimCheckMode_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::ParamSpec_DimCheckMode") int ParamSpec_DimCheckMode_DimCheckMode_MAX();
@Namespace("caffe") @MemberGetter public static native int ParamSpec_DimCheckMode_DimCheckMode_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor ParamSpec_DimCheckMode_descriptor();
@Namespace("caffe") public static native @StdString BytePointer ParamSpec_DimCheckMode_Name(@Cast("caffe::ParamSpec_DimCheckMode") int value);
@Namespace("caffe") public static native @Cast("bool") boolean ParamSpec_DimCheckMode_Parse(
    @StdString BytePointer name, @Cast("caffe::ParamSpec_DimCheckMode*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean ParamSpec_DimCheckMode_Parse(
    @StdString String name, @Cast("caffe::ParamSpec_DimCheckMode*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean ParamSpec_DimCheckMode_Parse(
    @StdString BytePointer name, @Cast("caffe::ParamSpec_DimCheckMode*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean ParamSpec_DimCheckMode_Parse(
    @StdString String name, @Cast("caffe::ParamSpec_DimCheckMode*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean ParamSpec_DimCheckMode_Parse(
    @StdString BytePointer name, @Cast("caffe::ParamSpec_DimCheckMode*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean ParamSpec_DimCheckMode_Parse(
    @StdString String name, @Cast("caffe::ParamSpec_DimCheckMode*") int[] value);
/** enum caffe::LossParameter_NormalizationMode */
public static final int
  LossParameter_NormalizationMode_FULL = 0,
  LossParameter_NormalizationMode_VALID = 1,
  LossParameter_NormalizationMode_BATCH_SIZE = 2,
  LossParameter_NormalizationMode_NONE = 3;
@Namespace("caffe") public static native @Cast("bool") boolean LossParameter_NormalizationMode_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::LossParameter_NormalizationMode") int LossParameter_NormalizationMode_NormalizationMode_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::LossParameter_NormalizationMode") int LossParameter_NormalizationMode_NormalizationMode_MAX();
@Namespace("caffe") @MemberGetter public static native int LossParameter_NormalizationMode_NormalizationMode_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor LossParameter_NormalizationMode_descriptor();
@Namespace("caffe") public static native @StdString BytePointer LossParameter_NormalizationMode_Name(@Cast("caffe::LossParameter_NormalizationMode") int value);
@Namespace("caffe") public static native @Cast("bool") boolean LossParameter_NormalizationMode_Parse(
    @StdString BytePointer name, @Cast("caffe::LossParameter_NormalizationMode*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean LossParameter_NormalizationMode_Parse(
    @StdString String name, @Cast("caffe::LossParameter_NormalizationMode*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean LossParameter_NormalizationMode_Parse(
    @StdString BytePointer name, @Cast("caffe::LossParameter_NormalizationMode*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean LossParameter_NormalizationMode_Parse(
    @StdString String name, @Cast("caffe::LossParameter_NormalizationMode*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean LossParameter_NormalizationMode_Parse(
    @StdString BytePointer name, @Cast("caffe::LossParameter_NormalizationMode*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean LossParameter_NormalizationMode_Parse(
    @StdString String name, @Cast("caffe::LossParameter_NormalizationMode*") int[] value);
/** enum caffe::ConvolutionParameter_Engine */
public static final int
  ConvolutionParameter_Engine_DEFAULT = 0,
  ConvolutionParameter_Engine_CAFFE = 1,
  ConvolutionParameter_Engine_CUDNN = 2;
@Namespace("caffe") public static native @Cast("bool") boolean ConvolutionParameter_Engine_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::ConvolutionParameter_Engine") int ConvolutionParameter_Engine_Engine_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::ConvolutionParameter_Engine") int ConvolutionParameter_Engine_Engine_MAX();
@Namespace("caffe") @MemberGetter public static native int ConvolutionParameter_Engine_Engine_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor ConvolutionParameter_Engine_descriptor();
@Namespace("caffe") public static native @StdString BytePointer ConvolutionParameter_Engine_Name(@Cast("caffe::ConvolutionParameter_Engine") int value);
@Namespace("caffe") public static native @Cast("bool") boolean ConvolutionParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::ConvolutionParameter_Engine*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean ConvolutionParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::ConvolutionParameter_Engine*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean ConvolutionParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::ConvolutionParameter_Engine*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean ConvolutionParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::ConvolutionParameter_Engine*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean ConvolutionParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::ConvolutionParameter_Engine*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean ConvolutionParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::ConvolutionParameter_Engine*") int[] value);
/** enum caffe::DataParameter_DB */
public static final int
  DataParameter_DB_LEVELDB = 0,
  DataParameter_DB_LMDB = 1;
@Namespace("caffe") public static native @Cast("bool") boolean DataParameter_DB_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::DataParameter_DB") int DataParameter_DB_DB_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::DataParameter_DB") int DataParameter_DB_DB_MAX();
@Namespace("caffe") @MemberGetter public static native int DataParameter_DB_DB_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor DataParameter_DB_descriptor();
@Namespace("caffe") public static native @StdString BytePointer DataParameter_DB_Name(@Cast("caffe::DataParameter_DB") int value);
@Namespace("caffe") public static native @Cast("bool") boolean DataParameter_DB_Parse(
    @StdString BytePointer name, @Cast("caffe::DataParameter_DB*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean DataParameter_DB_Parse(
    @StdString String name, @Cast("caffe::DataParameter_DB*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean DataParameter_DB_Parse(
    @StdString BytePointer name, @Cast("caffe::DataParameter_DB*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean DataParameter_DB_Parse(
    @StdString String name, @Cast("caffe::DataParameter_DB*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean DataParameter_DB_Parse(
    @StdString BytePointer name, @Cast("caffe::DataParameter_DB*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean DataParameter_DB_Parse(
    @StdString String name, @Cast("caffe::DataParameter_DB*") int[] value);
/** enum caffe::EltwiseParameter_EltwiseOp */
public static final int
  EltwiseParameter_EltwiseOp_PROD = 0,
  EltwiseParameter_EltwiseOp_SUM = 1,
  EltwiseParameter_EltwiseOp_MAX = 2;
@Namespace("caffe") public static native @Cast("bool") boolean EltwiseParameter_EltwiseOp_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::EltwiseParameter_EltwiseOp") int EltwiseParameter_EltwiseOp_EltwiseOp_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::EltwiseParameter_EltwiseOp") int EltwiseParameter_EltwiseOp_EltwiseOp_MAX();
@Namespace("caffe") @MemberGetter public static native int EltwiseParameter_EltwiseOp_EltwiseOp_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor EltwiseParameter_EltwiseOp_descriptor();
@Namespace("caffe") public static native @StdString BytePointer EltwiseParameter_EltwiseOp_Name(@Cast("caffe::EltwiseParameter_EltwiseOp") int value);
@Namespace("caffe") public static native @Cast("bool") boolean EltwiseParameter_EltwiseOp_Parse(
    @StdString BytePointer name, @Cast("caffe::EltwiseParameter_EltwiseOp*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean EltwiseParameter_EltwiseOp_Parse(
    @StdString String name, @Cast("caffe::EltwiseParameter_EltwiseOp*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean EltwiseParameter_EltwiseOp_Parse(
    @StdString BytePointer name, @Cast("caffe::EltwiseParameter_EltwiseOp*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean EltwiseParameter_EltwiseOp_Parse(
    @StdString String name, @Cast("caffe::EltwiseParameter_EltwiseOp*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean EltwiseParameter_EltwiseOp_Parse(
    @StdString BytePointer name, @Cast("caffe::EltwiseParameter_EltwiseOp*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean EltwiseParameter_EltwiseOp_Parse(
    @StdString String name, @Cast("caffe::EltwiseParameter_EltwiseOp*") int[] value);
/** enum caffe::HingeLossParameter_Norm */
public static final int
  HingeLossParameter_Norm_L1 = 1,
  HingeLossParameter_Norm_L2 = 2;
@Namespace("caffe") public static native @Cast("bool") boolean HingeLossParameter_Norm_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::HingeLossParameter_Norm") int HingeLossParameter_Norm_Norm_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::HingeLossParameter_Norm") int HingeLossParameter_Norm_Norm_MAX();
@Namespace("caffe") @MemberGetter public static native int HingeLossParameter_Norm_Norm_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor HingeLossParameter_Norm_descriptor();
@Namespace("caffe") public static native @StdString BytePointer HingeLossParameter_Norm_Name(@Cast("caffe::HingeLossParameter_Norm") int value);
@Namespace("caffe") public static native @Cast("bool") boolean HingeLossParameter_Norm_Parse(
    @StdString BytePointer name, @Cast("caffe::HingeLossParameter_Norm*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean HingeLossParameter_Norm_Parse(
    @StdString String name, @Cast("caffe::HingeLossParameter_Norm*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean HingeLossParameter_Norm_Parse(
    @StdString BytePointer name, @Cast("caffe::HingeLossParameter_Norm*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean HingeLossParameter_Norm_Parse(
    @StdString String name, @Cast("caffe::HingeLossParameter_Norm*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean HingeLossParameter_Norm_Parse(
    @StdString BytePointer name, @Cast("caffe::HingeLossParameter_Norm*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean HingeLossParameter_Norm_Parse(
    @StdString String name, @Cast("caffe::HingeLossParameter_Norm*") int[] value);
/** enum caffe::LRNParameter_NormRegion */
public static final int
  LRNParameter_NormRegion_ACROSS_CHANNELS = 0,
  LRNParameter_NormRegion_WITHIN_CHANNEL = 1;
@Namespace("caffe") public static native @Cast("bool") boolean LRNParameter_NormRegion_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::LRNParameter_NormRegion") int LRNParameter_NormRegion_NormRegion_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::LRNParameter_NormRegion") int LRNParameter_NormRegion_NormRegion_MAX();
@Namespace("caffe") @MemberGetter public static native int LRNParameter_NormRegion_NormRegion_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor LRNParameter_NormRegion_descriptor();
@Namespace("caffe") public static native @StdString BytePointer LRNParameter_NormRegion_Name(@Cast("caffe::LRNParameter_NormRegion") int value);
@Namespace("caffe") public static native @Cast("bool") boolean LRNParameter_NormRegion_Parse(
    @StdString BytePointer name, @Cast("caffe::LRNParameter_NormRegion*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean LRNParameter_NormRegion_Parse(
    @StdString String name, @Cast("caffe::LRNParameter_NormRegion*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean LRNParameter_NormRegion_Parse(
    @StdString BytePointer name, @Cast("caffe::LRNParameter_NormRegion*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean LRNParameter_NormRegion_Parse(
    @StdString String name, @Cast("caffe::LRNParameter_NormRegion*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean LRNParameter_NormRegion_Parse(
    @StdString BytePointer name, @Cast("caffe::LRNParameter_NormRegion*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean LRNParameter_NormRegion_Parse(
    @StdString String name, @Cast("caffe::LRNParameter_NormRegion*") int[] value);
/** enum caffe::LRNParameter_Engine */
public static final int
  LRNParameter_Engine_DEFAULT = 0,
  LRNParameter_Engine_CAFFE = 1,
  LRNParameter_Engine_CUDNN = 2;
@Namespace("caffe") public static native @Cast("bool") boolean LRNParameter_Engine_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::LRNParameter_Engine") int LRNParameter_Engine_Engine_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::LRNParameter_Engine") int LRNParameter_Engine_Engine_MAX();
@Namespace("caffe") @MemberGetter public static native int LRNParameter_Engine_Engine_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor LRNParameter_Engine_descriptor();
@Namespace("caffe") public static native @StdString BytePointer LRNParameter_Engine_Name(@Cast("caffe::LRNParameter_Engine") int value);
@Namespace("caffe") public static native @Cast("bool") boolean LRNParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::LRNParameter_Engine*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean LRNParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::LRNParameter_Engine*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean LRNParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::LRNParameter_Engine*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean LRNParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::LRNParameter_Engine*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean LRNParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::LRNParameter_Engine*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean LRNParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::LRNParameter_Engine*") int[] value);
/** enum caffe::PoolingParameter_PoolMethod */
public static final int
  PoolingParameter_PoolMethod_MAX = 0,
  PoolingParameter_PoolMethod_AVE = 1,
  PoolingParameter_PoolMethod_STOCHASTIC = 2;
@Namespace("caffe") public static native @Cast("bool") boolean PoolingParameter_PoolMethod_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::PoolingParameter_PoolMethod") int PoolingParameter_PoolMethod_PoolMethod_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::PoolingParameter_PoolMethod") int PoolingParameter_PoolMethod_PoolMethod_MAX();
@Namespace("caffe") @MemberGetter public static native int PoolingParameter_PoolMethod_PoolMethod_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor PoolingParameter_PoolMethod_descriptor();
@Namespace("caffe") public static native @StdString BytePointer PoolingParameter_PoolMethod_Name(@Cast("caffe::PoolingParameter_PoolMethod") int value);
@Namespace("caffe") public static native @Cast("bool") boolean PoolingParameter_PoolMethod_Parse(
    @StdString BytePointer name, @Cast("caffe::PoolingParameter_PoolMethod*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean PoolingParameter_PoolMethod_Parse(
    @StdString String name, @Cast("caffe::PoolingParameter_PoolMethod*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean PoolingParameter_PoolMethod_Parse(
    @StdString BytePointer name, @Cast("caffe::PoolingParameter_PoolMethod*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean PoolingParameter_PoolMethod_Parse(
    @StdString String name, @Cast("caffe::PoolingParameter_PoolMethod*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean PoolingParameter_PoolMethod_Parse(
    @StdString BytePointer name, @Cast("caffe::PoolingParameter_PoolMethod*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean PoolingParameter_PoolMethod_Parse(
    @StdString String name, @Cast("caffe::PoolingParameter_PoolMethod*") int[] value);
/** enum caffe::PoolingParameter_Engine */
public static final int
  PoolingParameter_Engine_DEFAULT = 0,
  PoolingParameter_Engine_CAFFE = 1,
  PoolingParameter_Engine_CUDNN = 2;
@Namespace("caffe") public static native @Cast("bool") boolean PoolingParameter_Engine_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::PoolingParameter_Engine") int PoolingParameter_Engine_Engine_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::PoolingParameter_Engine") int PoolingParameter_Engine_Engine_MAX();
@Namespace("caffe") @MemberGetter public static native int PoolingParameter_Engine_Engine_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor PoolingParameter_Engine_descriptor();
@Namespace("caffe") public static native @StdString BytePointer PoolingParameter_Engine_Name(@Cast("caffe::PoolingParameter_Engine") int value);
@Namespace("caffe") public static native @Cast("bool") boolean PoolingParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::PoolingParameter_Engine*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean PoolingParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::PoolingParameter_Engine*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean PoolingParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::PoolingParameter_Engine*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean PoolingParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::PoolingParameter_Engine*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean PoolingParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::PoolingParameter_Engine*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean PoolingParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::PoolingParameter_Engine*") int[] value);
/** enum caffe::ReductionParameter_ReductionOp */
public static final int
  ReductionParameter_ReductionOp_SUM = 1,
  ReductionParameter_ReductionOp_ASUM = 2,
  ReductionParameter_ReductionOp_SUMSQ = 3,
  ReductionParameter_ReductionOp_MEAN = 4;
@Namespace("caffe") public static native @Cast("bool") boolean ReductionParameter_ReductionOp_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::ReductionParameter_ReductionOp") int ReductionParameter_ReductionOp_ReductionOp_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::ReductionParameter_ReductionOp") int ReductionParameter_ReductionOp_ReductionOp_MAX();
@Namespace("caffe") @MemberGetter public static native int ReductionParameter_ReductionOp_ReductionOp_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor ReductionParameter_ReductionOp_descriptor();
@Namespace("caffe") public static native @StdString BytePointer ReductionParameter_ReductionOp_Name(@Cast("caffe::ReductionParameter_ReductionOp") int value);
@Namespace("caffe") public static native @Cast("bool") boolean ReductionParameter_ReductionOp_Parse(
    @StdString BytePointer name, @Cast("caffe::ReductionParameter_ReductionOp*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean ReductionParameter_ReductionOp_Parse(
    @StdString String name, @Cast("caffe::ReductionParameter_ReductionOp*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean ReductionParameter_ReductionOp_Parse(
    @StdString BytePointer name, @Cast("caffe::ReductionParameter_ReductionOp*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean ReductionParameter_ReductionOp_Parse(
    @StdString String name, @Cast("caffe::ReductionParameter_ReductionOp*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean ReductionParameter_ReductionOp_Parse(
    @StdString BytePointer name, @Cast("caffe::ReductionParameter_ReductionOp*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean ReductionParameter_ReductionOp_Parse(
    @StdString String name, @Cast("caffe::ReductionParameter_ReductionOp*") int[] value);
/** enum caffe::ReLUParameter_Engine */
public static final int
  ReLUParameter_Engine_DEFAULT = 0,
  ReLUParameter_Engine_CAFFE = 1,
  ReLUParameter_Engine_CUDNN = 2;
@Namespace("caffe") public static native @Cast("bool") boolean ReLUParameter_Engine_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::ReLUParameter_Engine") int ReLUParameter_Engine_Engine_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::ReLUParameter_Engine") int ReLUParameter_Engine_Engine_MAX();
@Namespace("caffe") @MemberGetter public static native int ReLUParameter_Engine_Engine_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor ReLUParameter_Engine_descriptor();
@Namespace("caffe") public static native @StdString BytePointer ReLUParameter_Engine_Name(@Cast("caffe::ReLUParameter_Engine") int value);
@Namespace("caffe") public static native @Cast("bool") boolean ReLUParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::ReLUParameter_Engine*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean ReLUParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::ReLUParameter_Engine*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean ReLUParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::ReLUParameter_Engine*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean ReLUParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::ReLUParameter_Engine*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean ReLUParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::ReLUParameter_Engine*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean ReLUParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::ReLUParameter_Engine*") int[] value);
/** enum caffe::SigmoidParameter_Engine */
public static final int
  SigmoidParameter_Engine_DEFAULT = 0,
  SigmoidParameter_Engine_CAFFE = 1,
  SigmoidParameter_Engine_CUDNN = 2;
@Namespace("caffe") public static native @Cast("bool") boolean SigmoidParameter_Engine_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::SigmoidParameter_Engine") int SigmoidParameter_Engine_Engine_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::SigmoidParameter_Engine") int SigmoidParameter_Engine_Engine_MAX();
@Namespace("caffe") @MemberGetter public static native int SigmoidParameter_Engine_Engine_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor SigmoidParameter_Engine_descriptor();
@Namespace("caffe") public static native @StdString BytePointer SigmoidParameter_Engine_Name(@Cast("caffe::SigmoidParameter_Engine") int value);
@Namespace("caffe") public static native @Cast("bool") boolean SigmoidParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::SigmoidParameter_Engine*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean SigmoidParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::SigmoidParameter_Engine*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean SigmoidParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::SigmoidParameter_Engine*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean SigmoidParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::SigmoidParameter_Engine*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean SigmoidParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::SigmoidParameter_Engine*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean SigmoidParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::SigmoidParameter_Engine*") int[] value);
/** enum caffe::SoftmaxParameter_Engine */
public static final int
  SoftmaxParameter_Engine_DEFAULT = 0,
  SoftmaxParameter_Engine_CAFFE = 1,
  SoftmaxParameter_Engine_CUDNN = 2;
@Namespace("caffe") public static native @Cast("bool") boolean SoftmaxParameter_Engine_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::SoftmaxParameter_Engine") int SoftmaxParameter_Engine_Engine_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::SoftmaxParameter_Engine") int SoftmaxParameter_Engine_Engine_MAX();
@Namespace("caffe") @MemberGetter public static native int SoftmaxParameter_Engine_Engine_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor SoftmaxParameter_Engine_descriptor();
@Namespace("caffe") public static native @StdString BytePointer SoftmaxParameter_Engine_Name(@Cast("caffe::SoftmaxParameter_Engine") int value);
@Namespace("caffe") public static native @Cast("bool") boolean SoftmaxParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::SoftmaxParameter_Engine*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean SoftmaxParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::SoftmaxParameter_Engine*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean SoftmaxParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::SoftmaxParameter_Engine*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean SoftmaxParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::SoftmaxParameter_Engine*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean SoftmaxParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::SoftmaxParameter_Engine*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean SoftmaxParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::SoftmaxParameter_Engine*") int[] value);
/** enum caffe::TanHParameter_Engine */
public static final int
  TanHParameter_Engine_DEFAULT = 0,
  TanHParameter_Engine_CAFFE = 1,
  TanHParameter_Engine_CUDNN = 2;
@Namespace("caffe") public static native @Cast("bool") boolean TanHParameter_Engine_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::TanHParameter_Engine") int TanHParameter_Engine_Engine_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::TanHParameter_Engine") int TanHParameter_Engine_Engine_MAX();
@Namespace("caffe") @MemberGetter public static native int TanHParameter_Engine_Engine_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor TanHParameter_Engine_descriptor();
@Namespace("caffe") public static native @StdString BytePointer TanHParameter_Engine_Name(@Cast("caffe::TanHParameter_Engine") int value);
@Namespace("caffe") public static native @Cast("bool") boolean TanHParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::TanHParameter_Engine*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean TanHParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::TanHParameter_Engine*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean TanHParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::TanHParameter_Engine*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean TanHParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::TanHParameter_Engine*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean TanHParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::TanHParameter_Engine*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean TanHParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::TanHParameter_Engine*") int[] value);
/** enum caffe::SPPParameter_PoolMethod */
public static final int
  SPPParameter_PoolMethod_MAX = 0,
  SPPParameter_PoolMethod_AVE = 1,
  SPPParameter_PoolMethod_STOCHASTIC = 2;
@Namespace("caffe") public static native @Cast("bool") boolean SPPParameter_PoolMethod_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::SPPParameter_PoolMethod") int SPPParameter_PoolMethod_PoolMethod_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::SPPParameter_PoolMethod") int SPPParameter_PoolMethod_PoolMethod_MAX();
@Namespace("caffe") @MemberGetter public static native int SPPParameter_PoolMethod_PoolMethod_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor SPPParameter_PoolMethod_descriptor();
@Namespace("caffe") public static native @StdString BytePointer SPPParameter_PoolMethod_Name(@Cast("caffe::SPPParameter_PoolMethod") int value);
@Namespace("caffe") public static native @Cast("bool") boolean SPPParameter_PoolMethod_Parse(
    @StdString BytePointer name, @Cast("caffe::SPPParameter_PoolMethod*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean SPPParameter_PoolMethod_Parse(
    @StdString String name, @Cast("caffe::SPPParameter_PoolMethod*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean SPPParameter_PoolMethod_Parse(
    @StdString BytePointer name, @Cast("caffe::SPPParameter_PoolMethod*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean SPPParameter_PoolMethod_Parse(
    @StdString String name, @Cast("caffe::SPPParameter_PoolMethod*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean SPPParameter_PoolMethod_Parse(
    @StdString BytePointer name, @Cast("caffe::SPPParameter_PoolMethod*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean SPPParameter_PoolMethod_Parse(
    @StdString String name, @Cast("caffe::SPPParameter_PoolMethod*") int[] value);
/** enum caffe::SPPParameter_Engine */
public static final int
  SPPParameter_Engine_DEFAULT = 0,
  SPPParameter_Engine_CAFFE = 1,
  SPPParameter_Engine_CUDNN = 2;
@Namespace("caffe") public static native @Cast("bool") boolean SPPParameter_Engine_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::SPPParameter_Engine") int SPPParameter_Engine_Engine_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::SPPParameter_Engine") int SPPParameter_Engine_Engine_MAX();
@Namespace("caffe") @MemberGetter public static native int SPPParameter_Engine_Engine_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor SPPParameter_Engine_descriptor();
@Namespace("caffe") public static native @StdString BytePointer SPPParameter_Engine_Name(@Cast("caffe::SPPParameter_Engine") int value);
@Namespace("caffe") public static native @Cast("bool") boolean SPPParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::SPPParameter_Engine*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean SPPParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::SPPParameter_Engine*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean SPPParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::SPPParameter_Engine*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean SPPParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::SPPParameter_Engine*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean SPPParameter_Engine_Parse(
    @StdString BytePointer name, @Cast("caffe::SPPParameter_Engine*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean SPPParameter_Engine_Parse(
    @StdString String name, @Cast("caffe::SPPParameter_Engine*") int[] value);
/** enum caffe::V1LayerParameter_LayerType */
public static final int
  V1LayerParameter_LayerType_NONE = 0,
  V1LayerParameter_LayerType_ABSVAL = 35,
  V1LayerParameter_LayerType_ACCURACY = 1,
  V1LayerParameter_LayerType_ARGMAX = 30,
  V1LayerParameter_LayerType_BNLL = 2,
  V1LayerParameter_LayerType_CONCAT = 3,
  V1LayerParameter_LayerType_CONTRASTIVE_LOSS = 37,
  V1LayerParameter_LayerType_CONVOLUTION = 4,
  V1LayerParameter_LayerType_DATA = 5,
  V1LayerParameter_LayerType_DECONVOLUTION = 39,
  V1LayerParameter_LayerType_DROPOUT = 6,
  V1LayerParameter_LayerType_DUMMY_DATA = 32,
  V1LayerParameter_LayerType_EUCLIDEAN_LOSS = 7,
  V1LayerParameter_LayerType_ELTWISE = 25,
  V1LayerParameter_LayerType_EXP = 38,
  V1LayerParameter_LayerType_FLATTEN = 8,
  V1LayerParameter_LayerType_HDF5_DATA = 9,
  V1LayerParameter_LayerType_HDF5_OUTPUT = 10,
  V1LayerParameter_LayerType_HINGE_LOSS = 28,
  V1LayerParameter_LayerType_IM2COL = 11,
  V1LayerParameter_LayerType_IMAGE_DATA = 12,
  V1LayerParameter_LayerType_INFOGAIN_LOSS = 13,
  V1LayerParameter_LayerType_INNER_PRODUCT = 14,
  V1LayerParameter_LayerType_LRN = 15,
  V1LayerParameter_LayerType_MEMORY_DATA = 29,
  V1LayerParameter_LayerType_MULTINOMIAL_LOGISTIC_LOSS = 16,
  V1LayerParameter_LayerType_MVN = 34,
  V1LayerParameter_LayerType_POOLING = 17,
  V1LayerParameter_LayerType_POWER = 26,
  V1LayerParameter_LayerType_RELU = 18,
  V1LayerParameter_LayerType_SIGMOID = 19,
  V1LayerParameter_LayerType_SIGMOID_CROSS_ENTROPY_LOSS = 27,
  V1LayerParameter_LayerType_SILENCE = 36,
  V1LayerParameter_LayerType_SOFTMAX = 20,
  V1LayerParameter_LayerType_SOFTMAX_LOSS = 21,
  V1LayerParameter_LayerType_SPLIT = 22,
  V1LayerParameter_LayerType_SLICE = 33,
  V1LayerParameter_LayerType_TANH = 23,
  V1LayerParameter_LayerType_WINDOW_DATA = 24,
  V1LayerParameter_LayerType_THRESHOLD = 31;
@Namespace("caffe") public static native @Cast("bool") boolean V1LayerParameter_LayerType_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::V1LayerParameter_LayerType") int V1LayerParameter_LayerType_LayerType_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::V1LayerParameter_LayerType") int V1LayerParameter_LayerType_LayerType_MAX();
@Namespace("caffe") @MemberGetter public static native int V1LayerParameter_LayerType_LayerType_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor V1LayerParameter_LayerType_descriptor();
@Namespace("caffe") public static native @StdString BytePointer V1LayerParameter_LayerType_Name(@Cast("caffe::V1LayerParameter_LayerType") int value);
@Namespace("caffe") public static native @Cast("bool") boolean V1LayerParameter_LayerType_Parse(
    @StdString BytePointer name, @Cast("caffe::V1LayerParameter_LayerType*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean V1LayerParameter_LayerType_Parse(
    @StdString String name, @Cast("caffe::V1LayerParameter_LayerType*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean V1LayerParameter_LayerType_Parse(
    @StdString BytePointer name, @Cast("caffe::V1LayerParameter_LayerType*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean V1LayerParameter_LayerType_Parse(
    @StdString String name, @Cast("caffe::V1LayerParameter_LayerType*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean V1LayerParameter_LayerType_Parse(
    @StdString BytePointer name, @Cast("caffe::V1LayerParameter_LayerType*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean V1LayerParameter_LayerType_Parse(
    @StdString String name, @Cast("caffe::V1LayerParameter_LayerType*") int[] value);
/** enum caffe::V1LayerParameter_DimCheckMode */
public static final int
  V1LayerParameter_DimCheckMode_STRICT = 0,
  V1LayerParameter_DimCheckMode_PERMISSIVE = 1;
@Namespace("caffe") public static native @Cast("bool") boolean V1LayerParameter_DimCheckMode_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::V1LayerParameter_DimCheckMode") int V1LayerParameter_DimCheckMode_DimCheckMode_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::V1LayerParameter_DimCheckMode") int V1LayerParameter_DimCheckMode_DimCheckMode_MAX();
@Namespace("caffe") @MemberGetter public static native int V1LayerParameter_DimCheckMode_DimCheckMode_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor V1LayerParameter_DimCheckMode_descriptor();
@Namespace("caffe") public static native @StdString BytePointer V1LayerParameter_DimCheckMode_Name(@Cast("caffe::V1LayerParameter_DimCheckMode") int value);
@Namespace("caffe") public static native @Cast("bool") boolean V1LayerParameter_DimCheckMode_Parse(
    @StdString BytePointer name, @Cast("caffe::V1LayerParameter_DimCheckMode*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean V1LayerParameter_DimCheckMode_Parse(
    @StdString String name, @Cast("caffe::V1LayerParameter_DimCheckMode*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean V1LayerParameter_DimCheckMode_Parse(
    @StdString BytePointer name, @Cast("caffe::V1LayerParameter_DimCheckMode*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean V1LayerParameter_DimCheckMode_Parse(
    @StdString String name, @Cast("caffe::V1LayerParameter_DimCheckMode*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean V1LayerParameter_DimCheckMode_Parse(
    @StdString BytePointer name, @Cast("caffe::V1LayerParameter_DimCheckMode*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean V1LayerParameter_DimCheckMode_Parse(
    @StdString String name, @Cast("caffe::V1LayerParameter_DimCheckMode*") int[] value);
/** enum caffe::V0LayerParameter_PoolMethod */
public static final int
  V0LayerParameter_PoolMethod_MAX = 0,
  V0LayerParameter_PoolMethod_AVE = 1,
  V0LayerParameter_PoolMethod_STOCHASTIC = 2;
@Namespace("caffe") public static native @Cast("bool") boolean V0LayerParameter_PoolMethod_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::V0LayerParameter_PoolMethod") int V0LayerParameter_PoolMethod_PoolMethod_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::V0LayerParameter_PoolMethod") int V0LayerParameter_PoolMethod_PoolMethod_MAX();
@Namespace("caffe") @MemberGetter public static native int V0LayerParameter_PoolMethod_PoolMethod_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor V0LayerParameter_PoolMethod_descriptor();
@Namespace("caffe") public static native @StdString BytePointer V0LayerParameter_PoolMethod_Name(@Cast("caffe::V0LayerParameter_PoolMethod") int value);
@Namespace("caffe") public static native @Cast("bool") boolean V0LayerParameter_PoolMethod_Parse(
    @StdString BytePointer name, @Cast("caffe::V0LayerParameter_PoolMethod*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean V0LayerParameter_PoolMethod_Parse(
    @StdString String name, @Cast("caffe::V0LayerParameter_PoolMethod*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean V0LayerParameter_PoolMethod_Parse(
    @StdString BytePointer name, @Cast("caffe::V0LayerParameter_PoolMethod*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean V0LayerParameter_PoolMethod_Parse(
    @StdString String name, @Cast("caffe::V0LayerParameter_PoolMethod*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean V0LayerParameter_PoolMethod_Parse(
    @StdString BytePointer name, @Cast("caffe::V0LayerParameter_PoolMethod*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean V0LayerParameter_PoolMethod_Parse(
    @StdString String name, @Cast("caffe::V0LayerParameter_PoolMethod*") int[] value);
/** enum caffe::Phase */
public static final int
  TRAIN = 0,
  TEST = 1;
@Namespace("caffe") public static native @Cast("bool") boolean Phase_IsValid(int value);
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::Phase") int Phase_MIN();
@Namespace("caffe") @MemberGetter public static native @Cast("const caffe::Phase") int Phase_MAX();
@Namespace("caffe") @MemberGetter public static native int Phase_ARRAYSIZE();

@Namespace("caffe") public static native @Const EnumDescriptor Phase_descriptor();
@Namespace("caffe") public static native @StdString BytePointer Phase_Name(@Cast("caffe::Phase") int value);
@Namespace("caffe") public static native @Cast("bool") boolean Phase_Parse(
    @StdString BytePointer name, @Cast("caffe::Phase*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean Phase_Parse(
    @StdString String name, @Cast("caffe::Phase*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean Phase_Parse(
    @StdString BytePointer name, @Cast("caffe::Phase*") int[] value);
@Namespace("caffe") public static native @Cast("bool") boolean Phase_Parse(
    @StdString String name, @Cast("caffe::Phase*") IntPointer value);
@Namespace("caffe") public static native @Cast("bool") boolean Phase_Parse(
    @StdString BytePointer name, @Cast("caffe::Phase*") IntBuffer value);
@Namespace("caffe") public static native @Cast("bool") boolean Phase_Parse(
    @StdString String name, @Cast("caffe::Phase*") int[] value);
// Targeting ../BlobShape.java


// Targeting ../BlobProto.java


// Targeting ../BlobProtoVector.java


// Targeting ../Datum.java


// Targeting ../FillerParameter.java


// Targeting ../NetParameter.java


// Targeting ../SolverParameter.java


// Targeting ../SolverState.java


// Targeting ../NetState.java


// Targeting ../NetStateRule.java


// Targeting ../ParamSpec.java


// Targeting ../LayerParameter.java


// Targeting ../TransformationParameter.java


// Targeting ../LossParameter.java


// Targeting ../AccuracyParameter.java


// Targeting ../ArgMaxParameter.java


// Targeting ../ConcatParameter.java


// Targeting ../BatchNormParameter.java


// Targeting ../BiasParameter.java


// Targeting ../ContrastiveLossParameter.java


// Targeting ../ConvolutionParameter.java


// Targeting ../CropParameter.java


// Targeting ../DataParameter.java


// Targeting ../DropoutParameter.java


// Targeting ../DummyDataParameter.java


// Targeting ../EltwiseParameter.java


// Targeting ../ELUParameter.java


// Targeting ../EmbedParameter.java


// Targeting ../ExpParameter.java


// Targeting ../FlattenParameter.java


// Targeting ../HDF5DataParameter.java


// Targeting ../HDF5OutputParameter.java


// Targeting ../HingeLossParameter.java


// Targeting ../ImageDataParameter.java


// Targeting ../InfogainLossParameter.java


// Targeting ../InnerProductParameter.java


// Targeting ../InputParameter.java


// Targeting ../LogParameter.java


// Targeting ../LRNParameter.java


// Targeting ../MemoryDataParameter.java


// Targeting ../MVNParameter.java


// Targeting ../ParameterParameter.java


// Targeting ../PoolingParameter.java


// Targeting ../PowerParameter.java


// Targeting ../PythonParameter.java


// Targeting ../RecurrentParameter.java


// Targeting ../ReductionParameter.java


// Targeting ../ReLUParameter.java


// Targeting ../ReshapeParameter.java


// Targeting ../ScaleParameter.java


// Targeting ../SigmoidParameter.java


// Targeting ../SliceParameter.java


// Targeting ../SoftmaxParameter.java


// Targeting ../TanHParameter.java


// Targeting ../TileParameter.java


// Targeting ../ThresholdParameter.java


// Targeting ../WindowDataParameter.java


// Targeting ../SPPParameter.java


// Targeting ../V1LayerParameter.java


// Targeting ../V0LayerParameter.java


// Targeting ../PReLUParameter.java


// ===================================================================


// ===================================================================

// #ifdef __GNUC__
//   #pragma GCC diagnostic push
//   #pragma GCC diagnostic ignored "-Wstrict-aliasing"
// #endif  // __GNUC__
// BlobShape

// repeated int64 dim = 1 [packed = true];








// -------------------------------------------------------------------

// BlobProto

// optional .caffe.BlobShape shape = 7;







// repeated float data = 5 [packed = true];








// repeated float diff = 6 [packed = true];








// repeated double double_data = 8 [packed = true];








// repeated double double_diff = 9 [packed = true];








// optional int32 num = 1 [default = 0];





// optional int32 channels = 2 [default = 0];





// optional int32 height = 3 [default = 0];





// optional int32 width = 4 [default = 0];





// -------------------------------------------------------------------

// BlobProtoVector

// repeated .caffe.BlobProto blobs = 1;








// -------------------------------------------------------------------

// Datum

// optional int32 channels = 1;





// optional int32 height = 2;





// optional int32 width = 3;





// optional bytes data = 4;




// #if LANG_CXX11
// #endif






// optional int32 label = 5;





// repeated float float_data = 6;








// optional bool encoded = 7 [default = false];





// -------------------------------------------------------------------

// FillerParameter

// optional string type = 1 [default = "constant"];




// #if LANG_CXX11
// #endif






// optional float value = 2 [default = 0];





// optional float min = 3 [default = 0];





// optional float max = 4 [default = 1];





// optional float mean = 5 [default = 0];





// optional float std = 6 [default = 1];





// optional int32 sparse = 7 [default = -1];





// optional .caffe.FillerParameter.VarianceNorm variance_norm = 8 [default = FAN_IN];





// -------------------------------------------------------------------

// NetParameter

// optional string name = 1;




// #if LANG_CXX11
// #endif






// repeated string input = 3;





// #if LANG_CXX11
// #endif




// #if LANG_CXX11
// #endif





// repeated .caffe.BlobShape input_shape = 8;








// repeated int32 input_dim = 4;








// optional bool force_backward = 5 [default = false];





// optional .caffe.NetState state = 6;







// optional bool debug_info = 7 [default = false];





// repeated .caffe.LayerParameter layer = 100;








// repeated .caffe.V1LayerParameter layers = 2;








// -------------------------------------------------------------------

// SolverParameter

// optional string net = 24;




// #if LANG_CXX11
// #endif






// optional .caffe.NetParameter net_param = 25;







// optional string train_net = 1;




// #if LANG_CXX11
// #endif






// repeated string test_net = 2;





// #if LANG_CXX11
// #endif




// #if LANG_CXX11
// #endif





// optional .caffe.NetParameter train_net_param = 21;







// repeated .caffe.NetParameter test_net_param = 22;








// optional .caffe.NetState train_state = 26;







// repeated .caffe.NetState test_state = 27;








// repeated int32 test_iter = 3;








// optional int32 test_interval = 4 [default = 0];





// optional bool test_compute_loss = 19 [default = false];





// optional bool test_initialization = 32 [default = true];





// optional float base_lr = 5;





// optional int32 display = 6;





// optional int32 average_loss = 33 [default = 1];





// optional int32 max_iter = 7;





// optional int32 iter_size = 36 [default = 1];





// optional string lr_policy = 8;




// #if LANG_CXX11
// #endif






// optional float gamma = 9;





// optional float power = 10;





// optional float momentum = 11;





// optional float weight_decay = 12;





// optional string regularization_type = 29 [default = "L2"];




// #if LANG_CXX11
// #endif






// optional int32 stepsize = 13;





// repeated int32 stepvalue = 34;








// optional float clip_gradients = 35 [default = -1];





// optional int32 snapshot = 14 [default = 0];





// optional string snapshot_prefix = 15;




// #if LANG_CXX11
// #endif






// optional bool snapshot_diff = 16 [default = false];





// optional .caffe.SolverParameter.SnapshotFormat snapshot_format = 37 [default = BINARYPROTO];





// optional .caffe.SolverParameter.SolverMode solver_mode = 17 [default = GPU];





// optional int32 device_id = 18 [default = 0];





// optional int64 random_seed = 20 [default = -1];





// optional string type = 40 [default = "SGD"];




// #if LANG_CXX11
// #endif






// optional float delta = 31 [default = 1e-08];





// optional float momentum2 = 39 [default = 0.999];





// optional float rms_decay = 38 [default = 0.99];





// optional bool debug_info = 23 [default = false];





// optional bool snapshot_after_train = 28 [default = true];





// optional .caffe.SolverParameter.SolverType solver_type = 30 [default = SGD];





// optional bool layer_wise_reduce = 41 [default = true];





// -------------------------------------------------------------------

// SolverState

// optional int32 iter = 1;





// optional string learned_net = 2;




// #if LANG_CXX11
// #endif






// repeated .caffe.BlobProto history = 3;








// optional int32 current_step = 4 [default = 0];





// -------------------------------------------------------------------

// NetState

// optional .caffe.Phase phase = 1 [default = TEST];





// optional int32 level = 2 [default = 0];





// repeated string stage = 3;





// #if LANG_CXX11
// #endif




// #if LANG_CXX11
// #endif





// -------------------------------------------------------------------

// NetStateRule

// optional .caffe.Phase phase = 1;





// optional int32 min_level = 2;





// optional int32 max_level = 3;





// repeated string stage = 4;





// #if LANG_CXX11
// #endif




// #if LANG_CXX11
// #endif





// repeated string not_stage = 5;





// #if LANG_CXX11
// #endif




// #if LANG_CXX11
// #endif





// -------------------------------------------------------------------

// ParamSpec

// optional string name = 1;




// #if LANG_CXX11
// #endif






// optional .caffe.ParamSpec.DimCheckMode share_mode = 2;





// optional float lr_mult = 3 [default = 1];





// optional float decay_mult = 4 [default = 1];





// -------------------------------------------------------------------

// LayerParameter

// optional string name = 1;




// #if LANG_CXX11
// #endif






// optional string type = 2;




// #if LANG_CXX11
// #endif






// repeated string bottom = 3;





// #if LANG_CXX11
// #endif




// #if LANG_CXX11
// #endif





// repeated string top = 4;





// #if LANG_CXX11
// #endif




// #if LANG_CXX11
// #endif





// optional .caffe.Phase phase = 10;





// repeated float loss_weight = 5;








// repeated .caffe.ParamSpec param = 6;








// repeated .caffe.BlobProto blobs = 7;








// repeated bool propagate_down = 11;








// repeated .caffe.NetStateRule include = 8;








// repeated .caffe.NetStateRule exclude = 9;








// optional .caffe.TransformationParameter transform_param = 100;







// optional .caffe.LossParameter loss_param = 101;







// optional .caffe.AccuracyParameter accuracy_param = 102;







// optional .caffe.ArgMaxParameter argmax_param = 103;







// optional .caffe.BatchNormParameter batch_norm_param = 139;







// optional .caffe.BiasParameter bias_param = 141;







// optional .caffe.ConcatParameter concat_param = 104;







// optional .caffe.ContrastiveLossParameter contrastive_loss_param = 105;







// optional .caffe.ConvolutionParameter convolution_param = 106;







// optional .caffe.CropParameter crop_param = 144;







// optional .caffe.DataParameter data_param = 107;







// optional .caffe.DropoutParameter dropout_param = 108;







// optional .caffe.DummyDataParameter dummy_data_param = 109;







// optional .caffe.EltwiseParameter eltwise_param = 110;







// optional .caffe.ELUParameter elu_param = 140;







// optional .caffe.EmbedParameter embed_param = 137;







// optional .caffe.ExpParameter exp_param = 111;







// optional .caffe.FlattenParameter flatten_param = 135;







// optional .caffe.HDF5DataParameter hdf5_data_param = 112;







// optional .caffe.HDF5OutputParameter hdf5_output_param = 113;







// optional .caffe.HingeLossParameter hinge_loss_param = 114;







// optional .caffe.ImageDataParameter image_data_param = 115;







// optional .caffe.InfogainLossParameter infogain_loss_param = 116;







// optional .caffe.InnerProductParameter inner_product_param = 117;







// optional .caffe.InputParameter input_param = 143;







// optional .caffe.LogParameter log_param = 134;







// optional .caffe.LRNParameter lrn_param = 118;







// optional .caffe.MemoryDataParameter memory_data_param = 119;







// optional .caffe.MVNParameter mvn_param = 120;







// optional .caffe.ParameterParameter parameter_param = 145;







// optional .caffe.PoolingParameter pooling_param = 121;







// optional .caffe.PowerParameter power_param = 122;







// optional .caffe.PReLUParameter prelu_param = 131;







// optional .caffe.PythonParameter python_param = 130;







// optional .caffe.RecurrentParameter recurrent_param = 146;







// optional .caffe.ReductionParameter reduction_param = 136;







// optional .caffe.ReLUParameter relu_param = 123;







// optional .caffe.ReshapeParameter reshape_param = 133;







// optional .caffe.ScaleParameter scale_param = 142;







// optional .caffe.SigmoidParameter sigmoid_param = 124;







// optional .caffe.SoftmaxParameter softmax_param = 125;







// optional .caffe.SPPParameter spp_param = 132;







// optional .caffe.SliceParameter slice_param = 126;







// optional .caffe.TanHParameter tanh_param = 127;







// optional .caffe.ThresholdParameter threshold_param = 128;







// optional .caffe.TileParameter tile_param = 138;







// optional .caffe.WindowDataParameter window_data_param = 129;







// -------------------------------------------------------------------

// TransformationParameter

// optional float scale = 1 [default = 1];





// optional bool mirror = 2 [default = false];





// optional uint32 crop_size = 3 [default = 0];





// optional string mean_file = 4;




// #if LANG_CXX11
// #endif






// repeated float mean_value = 5;








// optional bool force_color = 6 [default = false];





// optional bool force_gray = 7 [default = false];





// -------------------------------------------------------------------

// LossParameter

// optional int32 ignore_label = 1;





// optional .caffe.LossParameter.NormalizationMode normalization = 3 [default = VALID];





// optional bool normalize = 2;





// -------------------------------------------------------------------

// AccuracyParameter

// optional uint32 top_k = 1 [default = 1];





// optional int32 axis = 2 [default = 1];





// optional int32 ignore_label = 3;





// -------------------------------------------------------------------

// ArgMaxParameter

// optional bool out_max_val = 1 [default = false];





// optional uint32 top_k = 2 [default = 1];





// optional int32 axis = 3;





// -------------------------------------------------------------------

// ConcatParameter

// optional int32 axis = 2 [default = 1];





// optional uint32 concat_dim = 1 [default = 1];





// -------------------------------------------------------------------

// BatchNormParameter

// optional bool use_global_stats = 1;





// optional float moving_average_fraction = 2 [default = 0.999];





// optional float eps = 3 [default = 1e-05];





// -------------------------------------------------------------------

// BiasParameter

// optional int32 axis = 1 [default = 1];





// optional int32 num_axes = 2 [default = 1];





// optional .caffe.FillerParameter filler = 3;







// -------------------------------------------------------------------

// ContrastiveLossParameter

// optional float margin = 1 [default = 1];





// optional bool legacy_version = 2 [default = false];





// -------------------------------------------------------------------

// ConvolutionParameter

// optional uint32 num_output = 1;





// optional bool bias_term = 2 [default = true];





// repeated uint32 pad = 3;








// repeated uint32 kernel_size = 4;








// repeated uint32 stride = 6;








// repeated uint32 dilation = 18;








// optional uint32 pad_h = 9 [default = 0];





// optional uint32 pad_w = 10 [default = 0];





// optional uint32 kernel_h = 11;





// optional uint32 kernel_w = 12;





// optional uint32 stride_h = 13;





// optional uint32 stride_w = 14;





// optional uint32 group = 5 [default = 1];





// optional .caffe.FillerParameter weight_filler = 7;







// optional .caffe.FillerParameter bias_filler = 8;







// optional .caffe.ConvolutionParameter.Engine engine = 15 [default = DEFAULT];





// optional int32 axis = 16 [default = 1];





// optional bool force_nd_im2col = 17 [default = false];





// -------------------------------------------------------------------

// CropParameter

// optional int32 axis = 1 [default = 2];





// repeated uint32 offset = 2;








// -------------------------------------------------------------------

// DataParameter

// optional string source = 1;




// #if LANG_CXX11
// #endif






// optional uint32 batch_size = 4;





// optional uint32 rand_skip = 7 [default = 0];





// optional .caffe.DataParameter.DB backend = 8 [default = LEVELDB];





// optional float scale = 2 [default = 1];





// optional string mean_file = 3;




// #if LANG_CXX11
// #endif






// optional uint32 crop_size = 5 [default = 0];





// optional bool mirror = 6 [default = false];





// optional bool force_encoded_color = 9 [default = false];





// optional uint32 prefetch = 10 [default = 4];





// -------------------------------------------------------------------

// DropoutParameter

// optional float dropout_ratio = 1 [default = 0.5];





// -------------------------------------------------------------------

// DummyDataParameter

// repeated .caffe.FillerParameter data_filler = 1;








// repeated .caffe.BlobShape shape = 6;








// repeated uint32 num = 2;








// repeated uint32 channels = 3;








// repeated uint32 height = 4;








// repeated uint32 width = 5;








// -------------------------------------------------------------------

// EltwiseParameter

// optional .caffe.EltwiseParameter.EltwiseOp operation = 1 [default = SUM];





// repeated float coeff = 2;








// optional bool stable_prod_grad = 3 [default = true];





// -------------------------------------------------------------------

// ELUParameter

// optional float alpha = 1 [default = 1];





// -------------------------------------------------------------------

// EmbedParameter

// optional uint32 num_output = 1;





// optional uint32 input_dim = 2;





// optional bool bias_term = 3 [default = true];





// optional .caffe.FillerParameter weight_filler = 4;







// optional .caffe.FillerParameter bias_filler = 5;







// -------------------------------------------------------------------

// ExpParameter

// optional float base = 1 [default = -1];





// optional float scale = 2 [default = 1];





// optional float shift = 3 [default = 0];





// -------------------------------------------------------------------

// FlattenParameter

// optional int32 axis = 1 [default = 1];





// optional int32 end_axis = 2 [default = -1];





// -------------------------------------------------------------------

// HDF5DataParameter

// optional string source = 1;




// #if LANG_CXX11
// #endif






// optional uint32 batch_size = 2;





// optional bool shuffle = 3 [default = false];





// -------------------------------------------------------------------

// HDF5OutputParameter

// optional string file_name = 1;




// #if LANG_CXX11
// #endif






// -------------------------------------------------------------------

// HingeLossParameter

// optional .caffe.HingeLossParameter.Norm norm = 1 [default = L1];





// -------------------------------------------------------------------

// ImageDataParameter

// optional string source = 1;




// #if LANG_CXX11
// #endif






// optional uint32 batch_size = 4 [default = 1];





// optional uint32 rand_skip = 7 [default = 0];





// optional bool shuffle = 8 [default = false];





// optional uint32 new_height = 9 [default = 0];





// optional uint32 new_width = 10 [default = 0];





// optional bool is_color = 11 [default = true];





// optional float scale = 2 [default = 1];





// optional string mean_file = 3;




// #if LANG_CXX11
// #endif






// optional uint32 crop_size = 5 [default = 0];





// optional bool mirror = 6 [default = false];





// optional string root_folder = 12 [default = ""];




// #if LANG_CXX11
// #endif






// -------------------------------------------------------------------

// InfogainLossParameter

// optional string source = 1;




// #if LANG_CXX11
// #endif






// optional int32 axis = 2 [default = 1];





// -------------------------------------------------------------------

// InnerProductParameter

// optional uint32 num_output = 1;





// optional bool bias_term = 2 [default = true];





// optional .caffe.FillerParameter weight_filler = 3;







// optional .caffe.FillerParameter bias_filler = 4;







// optional int32 axis = 5 [default = 1];





// optional bool transpose = 6 [default = false];





// -------------------------------------------------------------------

// InputParameter

// repeated .caffe.BlobShape shape = 1;








// -------------------------------------------------------------------

// LogParameter

// optional float base = 1 [default = -1];





// optional float scale = 2 [default = 1];





// optional float shift = 3 [default = 0];





// -------------------------------------------------------------------

// LRNParameter

// optional uint32 local_size = 1 [default = 5];





// optional float alpha = 2 [default = 1];





// optional float beta = 3 [default = 0.75];





// optional .caffe.LRNParameter.NormRegion norm_region = 4 [default = ACROSS_CHANNELS];





// optional float k = 5 [default = 1];





// optional .caffe.LRNParameter.Engine engine = 6 [default = DEFAULT];





// -------------------------------------------------------------------

// MemoryDataParameter

// optional uint32 batch_size = 1;





// optional uint32 channels = 2;





// optional uint32 height = 3;





// optional uint32 width = 4;





// -------------------------------------------------------------------

// MVNParameter

// optional bool normalize_variance = 1 [default = true];





// optional bool across_channels = 2 [default = false];





// optional float eps = 3 [default = 1e-09];





// -------------------------------------------------------------------

// ParameterParameter

// optional .caffe.BlobShape shape = 1;







// -------------------------------------------------------------------

// PoolingParameter

// optional .caffe.PoolingParameter.PoolMethod pool = 1 [default = MAX];





// optional uint32 pad = 4 [default = 0];





// optional uint32 pad_h = 9 [default = 0];





// optional uint32 pad_w = 10 [default = 0];





// optional uint32 kernel_size = 2;





// optional uint32 kernel_h = 5;





// optional uint32 kernel_w = 6;





// optional uint32 stride = 3 [default = 1];





// optional uint32 stride_h = 7;





// optional uint32 stride_w = 8;





// optional .caffe.PoolingParameter.Engine engine = 11 [default = DEFAULT];





// optional bool global_pooling = 12 [default = false];





// -------------------------------------------------------------------

// PowerParameter

// optional float power = 1 [default = 1];





// optional float scale = 2 [default = 1];





// optional float shift = 3 [default = 0];





// -------------------------------------------------------------------

// PythonParameter

// optional string module = 1;




// #if LANG_CXX11
// #endif






// optional string layer = 2;




// #if LANG_CXX11
// #endif






// optional string param_str = 3 [default = ""];




// #if LANG_CXX11
// #endif






// optional bool share_in_parallel = 4 [default = false];





// -------------------------------------------------------------------

// RecurrentParameter

// optional uint32 num_output = 1 [default = 0];





// optional .caffe.FillerParameter weight_filler = 2;







// optional .caffe.FillerParameter bias_filler = 3;







// optional bool debug_info = 4 [default = false];





// optional bool expose_hidden = 5 [default = false];





// -------------------------------------------------------------------

// ReductionParameter

// optional .caffe.ReductionParameter.ReductionOp operation = 1 [default = SUM];





// optional int32 axis = 2 [default = 0];





// optional float coeff = 3 [default = 1];





// -------------------------------------------------------------------

// ReLUParameter

// optional float negative_slope = 1 [default = 0];





// optional .caffe.ReLUParameter.Engine engine = 2 [default = DEFAULT];





// -------------------------------------------------------------------

// ReshapeParameter

// optional .caffe.BlobShape shape = 1;







// optional int32 axis = 2 [default = 0];





// optional int32 num_axes = 3 [default = -1];





// -------------------------------------------------------------------

// ScaleParameter

// optional int32 axis = 1 [default = 1];





// optional int32 num_axes = 2 [default = 1];





// optional .caffe.FillerParameter filler = 3;







// optional bool bias_term = 4 [default = false];





// optional .caffe.FillerParameter bias_filler = 5;







// -------------------------------------------------------------------

// SigmoidParameter

// optional .caffe.SigmoidParameter.Engine engine = 1 [default = DEFAULT];





// -------------------------------------------------------------------

// SliceParameter

// optional int32 axis = 3 [default = 1];





// repeated uint32 slice_point = 2;








// optional uint32 slice_dim = 1 [default = 1];





// -------------------------------------------------------------------

// SoftmaxParameter

// optional .caffe.SoftmaxParameter.Engine engine = 1 [default = DEFAULT];





// optional int32 axis = 2 [default = 1];





// -------------------------------------------------------------------

// TanHParameter

// optional .caffe.TanHParameter.Engine engine = 1 [default = DEFAULT];





// -------------------------------------------------------------------

// TileParameter

// optional int32 axis = 1 [default = 1];





// optional int32 tiles = 2;





// -------------------------------------------------------------------

// ThresholdParameter

// optional float threshold = 1 [default = 0];





// -------------------------------------------------------------------

// WindowDataParameter

// optional string source = 1;




// #if LANG_CXX11
// #endif






// optional float scale = 2 [default = 1];





// optional string mean_file = 3;




// #if LANG_CXX11
// #endif






// optional uint32 batch_size = 4;





// optional uint32 crop_size = 5 [default = 0];





// optional bool mirror = 6 [default = false];





// optional float fg_threshold = 7 [default = 0.5];





// optional float bg_threshold = 8 [default = 0.5];





// optional float fg_fraction = 9 [default = 0.25];





// optional uint32 context_pad = 10 [default = 0];





// optional string crop_mode = 11 [default = "warp"];




// #if LANG_CXX11
// #endif






// optional bool cache_images = 12 [default = false];





// optional string root_folder = 13 [default = ""];




// #if LANG_CXX11
// #endif






// -------------------------------------------------------------------

// SPPParameter

// optional uint32 pyramid_height = 1;





// optional .caffe.SPPParameter.PoolMethod pool = 2 [default = MAX];





// optional .caffe.SPPParameter.Engine engine = 6 [default = DEFAULT];





// -------------------------------------------------------------------

// V1LayerParameter

// repeated string bottom = 2;





// #if LANG_CXX11
// #endif




// #if LANG_CXX11
// #endif





// repeated string top = 3;





// #if LANG_CXX11
// #endif




// #if LANG_CXX11
// #endif





// optional string name = 4;




// #if LANG_CXX11
// #endif






// repeated .caffe.NetStateRule include = 32;








// repeated .caffe.NetStateRule exclude = 33;








// optional .caffe.V1LayerParameter.LayerType type = 5;





// repeated .caffe.BlobProto blobs = 6;








// repeated string param = 1001;





// #if LANG_CXX11
// #endif




// #if LANG_CXX11
// #endif





// repeated .caffe.V1LayerParameter.DimCheckMode blob_share_mode = 1002;








// repeated float blobs_lr = 7;








// repeated float weight_decay = 8;








// repeated float loss_weight = 35;








// optional .caffe.AccuracyParameter accuracy_param = 27;







// optional .caffe.ArgMaxParameter argmax_param = 23;







// optional .caffe.ConcatParameter concat_param = 9;







// optional .caffe.ContrastiveLossParameter contrastive_loss_param = 40;







// optional .caffe.ConvolutionParameter convolution_param = 10;







// optional .caffe.DataParameter data_param = 11;







// optional .caffe.DropoutParameter dropout_param = 12;







// optional .caffe.DummyDataParameter dummy_data_param = 26;







// optional .caffe.EltwiseParameter eltwise_param = 24;







// optional .caffe.ExpParameter exp_param = 41;







// optional .caffe.HDF5DataParameter hdf5_data_param = 13;







// optional .caffe.HDF5OutputParameter hdf5_output_param = 14;







// optional .caffe.HingeLossParameter hinge_loss_param = 29;







// optional .caffe.ImageDataParameter image_data_param = 15;







// optional .caffe.InfogainLossParameter infogain_loss_param = 16;







// optional .caffe.InnerProductParameter inner_product_param = 17;







// optional .caffe.LRNParameter lrn_param = 18;







// optional .caffe.MemoryDataParameter memory_data_param = 22;







// optional .caffe.MVNParameter mvn_param = 34;







// optional .caffe.PoolingParameter pooling_param = 19;







// optional .caffe.PowerParameter power_param = 21;







// optional .caffe.ReLUParameter relu_param = 30;







// optional .caffe.SigmoidParameter sigmoid_param = 38;







// optional .caffe.SoftmaxParameter softmax_param = 39;







// optional .caffe.SliceParameter slice_param = 31;







// optional .caffe.TanHParameter tanh_param = 37;







// optional .caffe.ThresholdParameter threshold_param = 25;







// optional .caffe.WindowDataParameter window_data_param = 20;







// optional .caffe.TransformationParameter transform_param = 36;







// optional .caffe.LossParameter loss_param = 42;







// optional .caffe.V0LayerParameter layer = 1;







// -------------------------------------------------------------------

// V0LayerParameter

// optional string name = 1;




// #if LANG_CXX11
// #endif






// optional string type = 2;




// #if LANG_CXX11
// #endif






// optional uint32 num_output = 3;





// optional bool biasterm = 4 [default = true];





// optional .caffe.FillerParameter weight_filler = 5;







// optional .caffe.FillerParameter bias_filler = 6;







// optional uint32 pad = 7 [default = 0];





// optional uint32 kernelsize = 8;





// optional uint32 group = 9 [default = 1];





// optional uint32 stride = 10 [default = 1];





// optional .caffe.V0LayerParameter.PoolMethod pool = 11 [default = MAX];





// optional float dropout_ratio = 12 [default = 0.5];





// optional uint32 local_size = 13 [default = 5];





// optional float alpha = 14 [default = 1];





// optional float beta = 15 [default = 0.75];





// optional float k = 22 [default = 1];





// optional string source = 16;




// #if LANG_CXX11
// #endif






// optional float scale = 17 [default = 1];





// optional string meanfile = 18;




// #if LANG_CXX11
// #endif






// optional uint32 batchsize = 19;





// optional uint32 cropsize = 20 [default = 0];





// optional bool mirror = 21 [default = false];





// repeated .caffe.BlobProto blobs = 50;








// repeated float blobs_lr = 51;








// repeated float weight_decay = 52;








// optional uint32 rand_skip = 53 [default = 0];





// optional float det_fg_threshold = 54 [default = 0.5];





// optional float det_bg_threshold = 55 [default = 0.5];





// optional float det_fg_fraction = 56 [default = 0.25];





// optional uint32 det_context_pad = 58 [default = 0];





// optional string det_crop_mode = 59 [default = "warp"];




// #if LANG_CXX11
// #endif






// optional int32 new_num = 60 [default = 0];





// optional int32 new_channels = 61 [default = 0];





// optional int32 new_height = 62 [default = 0];





// optional int32 new_width = 63 [default = 0];





// optional bool shuffle_images = 64 [default = false];





// optional uint32 concat_dim = 65 [default = 1];





// optional .caffe.HDF5OutputParameter hdf5_output_param = 1001;







// -------------------------------------------------------------------

// PReLUParameter

// optional .caffe.FillerParameter filler = 1;







// optional bool channel_shared = 2 [default = false];





// #ifdef __GNUC__
//   #pragma GCC diagnostic pop
// #endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

  // namespace caffe


























  // namespace protobuf
  // namespace google

// @@protoc_insertion_point(global_scope)

// #include <google/protobuf/port_undef.inc>
// #endif  // PROTOBUF_INCLUDED_caffe_2eproto


// Parsed from caffe/util/blocking_queue.hpp

// #ifndef CAFFE_UTIL_BLOCKING_QUEUE_HPP_
// #define CAFFE_UTIL_BLOCKING_QUEUE_HPP_

// #include <queue>
// #include <string>
// Targeting ../DatumBlockingQueue.java



  // namespace caffe

// #endif


// Parsed from caffe/util/math_functions.hpp

// #ifndef CAFFE_UTIL_MATH_FUNCTIONS_H_
// #define CAFFE_UTIL_MATH_FUNCTIONS_H_

// #include <stdint.h>
// #include <cmath>  // for std::fabs and std::signbit

// #include "glog/logging.h"

// #include "caffe/common.hpp"
// #include "caffe/util/device_alternate.hpp"
// #include "caffe/util/mkl_alternate.hpp"

// Caffe gemm provides a simpler interface to the gemm functions, with the
// limitation that the data has to be contiguous in memory.
@Namespace("caffe") public static native @Name("caffe_cpu_gemm<float>") void caffe_cpu_gemm_float(@Cast("const CBLAS_TRANSPOSE") int TransA,
    @Cast("const CBLAS_TRANSPOSE") int TransB, int M, int N, int K,
    float alpha, @Const FloatPointer A, @Const FloatPointer B, float beta,
    FloatPointer C);
@Namespace("caffe") public static native @Name("caffe_cpu_gemm<float>") void caffe_cpu_gemm_float(@Cast("const CBLAS_TRANSPOSE") int TransA,
    @Cast("const CBLAS_TRANSPOSE") int TransB, int M, int N, int K,
    float alpha, @Const FloatBuffer A, @Const FloatBuffer B, float beta,
    FloatBuffer C);
@Namespace("caffe") public static native @Name("caffe_cpu_gemm<float>") void caffe_cpu_gemm_float(@Cast("const CBLAS_TRANSPOSE") int TransA,
    @Cast("const CBLAS_TRANSPOSE") int TransB, int M, int N, int K,
    float alpha, @Const float[] A, @Const float[] B, float beta,
    float[] C);
@Namespace("caffe") public static native @Name("caffe_cpu_gemm<double>") void caffe_cpu_gemm_double(@Cast("const CBLAS_TRANSPOSE") int TransA,
    @Cast("const CBLAS_TRANSPOSE") int TransB, int M, int N, int K,
    double alpha, @Const DoublePointer A, @Const DoublePointer B, double beta,
    DoublePointer C);
@Namespace("caffe") public static native @Name("caffe_cpu_gemm<double>") void caffe_cpu_gemm_double(@Cast("const CBLAS_TRANSPOSE") int TransA,
    @Cast("const CBLAS_TRANSPOSE") int TransB, int M, int N, int K,
    double alpha, @Const DoubleBuffer A, @Const DoubleBuffer B, double beta,
    DoubleBuffer C);
@Namespace("caffe") public static native @Name("caffe_cpu_gemm<double>") void caffe_cpu_gemm_double(@Cast("const CBLAS_TRANSPOSE") int TransA,
    @Cast("const CBLAS_TRANSPOSE") int TransB, int M, int N, int K,
    double alpha, @Const double[] A, @Const double[] B, double beta,
    double[] C);

@Namespace("caffe") public static native @Name("caffe_cpu_gemv<float>") void caffe_cpu_gemv_float(@Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
    float alpha, @Const FloatPointer A, @Const FloatPointer x, float beta,
    FloatPointer y);
@Namespace("caffe") public static native @Name("caffe_cpu_gemv<float>") void caffe_cpu_gemv_float(@Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
    float alpha, @Const FloatBuffer A, @Const FloatBuffer x, float beta,
    FloatBuffer y);
@Namespace("caffe") public static native @Name("caffe_cpu_gemv<float>") void caffe_cpu_gemv_float(@Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
    float alpha, @Const float[] A, @Const float[] x, float beta,
    float[] y);

@Namespace("caffe") public static native @Name("caffe_cpu_gemv<double>") void caffe_cpu_gemv_double(@Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
    double alpha, @Const DoublePointer A, @Const DoublePointer x, double beta,
    DoublePointer y);
@Namespace("caffe") public static native @Name("caffe_cpu_gemv<double>") void caffe_cpu_gemv_double(@Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
    double alpha, @Const DoubleBuffer A, @Const DoubleBuffer x, double beta,
    DoubleBuffer y);
@Namespace("caffe") public static native @Name("caffe_cpu_gemv<double>") void caffe_cpu_gemv_double(@Cast("const CBLAS_TRANSPOSE") int TransA, int M, int N,
    double alpha, @Const double[] A, @Const double[] x, double beta,
    double[] y);

@Namespace("caffe") public static native @Name("caffe_axpy<float>") void caffe_axpy_float(int N, float alpha, @Const FloatPointer X,
    FloatPointer Y);
@Namespace("caffe") public static native @Name("caffe_axpy<float>") void caffe_axpy_float(int N, float alpha, @Const FloatBuffer X,
    FloatBuffer Y);
@Namespace("caffe") public static native @Name("caffe_axpy<float>") void caffe_axpy_float(int N, float alpha, @Const float[] X,
    float[] Y);

@Namespace("caffe") public static native @Name("caffe_axpy<double>") void caffe_axpy_double(int N, double alpha, @Const DoublePointer X,
    DoublePointer Y);
@Namespace("caffe") public static native @Name("caffe_axpy<double>") void caffe_axpy_double(int N, double alpha, @Const DoubleBuffer X,
    DoubleBuffer Y);
@Namespace("caffe") public static native @Name("caffe_axpy<double>") void caffe_axpy_double(int N, double alpha, @Const double[] X,
    double[] Y);

@Namespace("caffe") public static native @Name("caffe_cpu_axpby<float>") void caffe_cpu_axpby_float(int N, float alpha, @Const FloatPointer X,
    float beta, FloatPointer Y);
@Namespace("caffe") public static native @Name("caffe_cpu_axpby<float>") void caffe_cpu_axpby_float(int N, float alpha, @Const FloatBuffer X,
    float beta, FloatBuffer Y);
@Namespace("caffe") public static native @Name("caffe_cpu_axpby<float>") void caffe_cpu_axpby_float(int N, float alpha, @Const float[] X,
    float beta, float[] Y);

@Namespace("caffe") public static native @Name("caffe_cpu_axpby<double>") void caffe_cpu_axpby_double(int N, double alpha, @Const DoublePointer X,
    double beta, DoublePointer Y);
@Namespace("caffe") public static native @Name("caffe_cpu_axpby<double>") void caffe_cpu_axpby_double(int N, double alpha, @Const DoubleBuffer X,
    double beta, DoubleBuffer Y);
@Namespace("caffe") public static native @Name("caffe_cpu_axpby<double>") void caffe_cpu_axpby_double(int N, double alpha, @Const double[] X,
    double beta, double[] Y);

@Namespace("caffe") public static native @Name("caffe_copy<float>") void caffe_copy_float(int N, @Const FloatPointer X, FloatPointer Y);
@Namespace("caffe") public static native @Name("caffe_copy<float>") void caffe_copy_float(int N, @Const FloatBuffer X, FloatBuffer Y);
@Namespace("caffe") public static native @Name("caffe_copy<float>") void caffe_copy_float(int N, @Const float[] X, float[] Y);

@Namespace("caffe") public static native @Name("caffe_copy<double>") void caffe_copy_double(int N, @Const DoublePointer X, DoublePointer Y);
@Namespace("caffe") public static native @Name("caffe_copy<double>") void caffe_copy_double(int N, @Const DoubleBuffer X, DoubleBuffer Y);
@Namespace("caffe") public static native @Name("caffe_copy<double>") void caffe_copy_double(int N, @Const double[] X, double[] Y);

@Namespace("caffe") public static native @Name("caffe_set<float>") void caffe_set_float(int N, float alpha, FloatPointer X);
@Namespace("caffe") public static native @Name("caffe_set<float>") void caffe_set_float(int N, float alpha, FloatBuffer X);
@Namespace("caffe") public static native @Name("caffe_set<float>") void caffe_set_float(int N, float alpha, float[] X);

@Namespace("caffe") public static native @Name("caffe_set<double>") void caffe_set_double(int N, double alpha, DoublePointer X);
@Namespace("caffe") public static native @Name("caffe_set<double>") void caffe_set_double(int N, double alpha, DoubleBuffer X);
@Namespace("caffe") public static native @Name("caffe_set<double>") void caffe_set_double(int N, double alpha, double[] X);

@Namespace("caffe") public static native void caffe_memset(@Cast("const size_t") long N, int alpha, Pointer X);

@Namespace("caffe") public static native @Name("caffe_add_scalar<float>") void caffe_add_scalar_float(int N, float alpha, FloatPointer X);
@Namespace("caffe") public static native @Name("caffe_add_scalar<float>") void caffe_add_scalar_float(int N, float alpha, FloatBuffer X);
@Namespace("caffe") public static native @Name("caffe_add_scalar<float>") void caffe_add_scalar_float(int N, float alpha, float[] X);

@Namespace("caffe") public static native @Name("caffe_add_scalar<double>") void caffe_add_scalar_double(int N, double alpha, DoublePointer X);
@Namespace("caffe") public static native @Name("caffe_add_scalar<double>") void caffe_add_scalar_double(int N, double alpha, DoubleBuffer X);
@Namespace("caffe") public static native @Name("caffe_add_scalar<double>") void caffe_add_scalar_double(int N, double alpha, double[] X);

@Namespace("caffe") public static native @Name("caffe_scal<float>") void caffe_scal_float(int N, float alpha, FloatPointer X);
@Namespace("caffe") public static native @Name("caffe_scal<float>") void caffe_scal_float(int N, float alpha, FloatBuffer X);
@Namespace("caffe") public static native @Name("caffe_scal<float>") void caffe_scal_float(int N, float alpha, float[] X);

@Namespace("caffe") public static native @Name("caffe_scal<double>") void caffe_scal_double(int N, double alpha, DoublePointer X);
@Namespace("caffe") public static native @Name("caffe_scal<double>") void caffe_scal_double(int N, double alpha, DoubleBuffer X);
@Namespace("caffe") public static native @Name("caffe_scal<double>") void caffe_scal_double(int N, double alpha, double[] X);

@Namespace("caffe") public static native @Name("caffe_sqr<float>") void caffe_sqr_float(int N, @Const FloatPointer a, FloatPointer y);
@Namespace("caffe") public static native @Name("caffe_sqr<float>") void caffe_sqr_float(int N, @Const FloatBuffer a, FloatBuffer y);
@Namespace("caffe") public static native @Name("caffe_sqr<float>") void caffe_sqr_float(int N, @Const float[] a, float[] y);

@Namespace("caffe") public static native @Name("caffe_sqr<double>") void caffe_sqr_double(int N, @Const DoublePointer a, DoublePointer y);
@Namespace("caffe") public static native @Name("caffe_sqr<double>") void caffe_sqr_double(int N, @Const DoubleBuffer a, DoubleBuffer y);
@Namespace("caffe") public static native @Name("caffe_sqr<double>") void caffe_sqr_double(int N, @Const double[] a, double[] y);

@Namespace("caffe") public static native @Name("caffe_add<float>") void caffe_add_float(int N, @Const FloatPointer a, @Const FloatPointer b, FloatPointer y);
@Namespace("caffe") public static native @Name("caffe_add<float>") void caffe_add_float(int N, @Const FloatBuffer a, @Const FloatBuffer b, FloatBuffer y);
@Namespace("caffe") public static native @Name("caffe_add<float>") void caffe_add_float(int N, @Const float[] a, @Const float[] b, float[] y);

@Namespace("caffe") public static native @Name("caffe_add<double>") void caffe_add_double(int N, @Const DoublePointer a, @Const DoublePointer b, DoublePointer y);
@Namespace("caffe") public static native @Name("caffe_add<double>") void caffe_add_double(int N, @Const DoubleBuffer a, @Const DoubleBuffer b, DoubleBuffer y);
@Namespace("caffe") public static native @Name("caffe_add<double>") void caffe_add_double(int N, @Const double[] a, @Const double[] b, double[] y);

@Namespace("caffe") public static native @Name("caffe_sub<float>") void caffe_sub_float(int N, @Const FloatPointer a, @Const FloatPointer b, FloatPointer y);
@Namespace("caffe") public static native @Name("caffe_sub<float>") void caffe_sub_float(int N, @Const FloatBuffer a, @Const FloatBuffer b, FloatBuffer y);
@Namespace("caffe") public static native @Name("caffe_sub<float>") void caffe_sub_float(int N, @Const float[] a, @Const float[] b, float[] y);

@Namespace("caffe") public static native @Name("caffe_sub<double>") void caffe_sub_double(int N, @Const DoublePointer a, @Const DoublePointer b, DoublePointer y);
@Namespace("caffe") public static native @Name("caffe_sub<double>") void caffe_sub_double(int N, @Const DoubleBuffer a, @Const DoubleBuffer b, DoubleBuffer y);
@Namespace("caffe") public static native @Name("caffe_sub<double>") void caffe_sub_double(int N, @Const double[] a, @Const double[] b, double[] y);

@Namespace("caffe") public static native @Name("caffe_mul<float>") void caffe_mul_float(int N, @Const FloatPointer a, @Const FloatPointer b, FloatPointer y);
@Namespace("caffe") public static native @Name("caffe_mul<float>") void caffe_mul_float(int N, @Const FloatBuffer a, @Const FloatBuffer b, FloatBuffer y);
@Namespace("caffe") public static native @Name("caffe_mul<float>") void caffe_mul_float(int N, @Const float[] a, @Const float[] b, float[] y);

@Namespace("caffe") public static native @Name("caffe_mul<double>") void caffe_mul_double(int N, @Const DoublePointer a, @Const DoublePointer b, DoublePointer y);
@Namespace("caffe") public static native @Name("caffe_mul<double>") void caffe_mul_double(int N, @Const DoubleBuffer a, @Const DoubleBuffer b, DoubleBuffer y);
@Namespace("caffe") public static native @Name("caffe_mul<double>") void caffe_mul_double(int N, @Const double[] a, @Const double[] b, double[] y);

@Namespace("caffe") public static native @Name("caffe_div<float>") void caffe_div_float(int N, @Const FloatPointer a, @Const FloatPointer b, FloatPointer y);
@Namespace("caffe") public static native @Name("caffe_div<float>") void caffe_div_float(int N, @Const FloatBuffer a, @Const FloatBuffer b, FloatBuffer y);
@Namespace("caffe") public static native @Name("caffe_div<float>") void caffe_div_float(int N, @Const float[] a, @Const float[] b, float[] y);

@Namespace("caffe") public static native @Name("caffe_div<double>") void caffe_div_double(int N, @Const DoublePointer a, @Const DoublePointer b, DoublePointer y);
@Namespace("caffe") public static native @Name("caffe_div<double>") void caffe_div_double(int N, @Const DoubleBuffer a, @Const DoubleBuffer b, DoubleBuffer y);
@Namespace("caffe") public static native @Name("caffe_div<double>") void caffe_div_double(int N, @Const double[] a, @Const double[] b, double[] y);

@Namespace("caffe") public static native @Name("caffe_powx<float>") void caffe_powx_float(int n, @Const FloatPointer a, float b, FloatPointer y);
@Namespace("caffe") public static native @Name("caffe_powx<float>") void caffe_powx_float(int n, @Const FloatBuffer a, float b, FloatBuffer y);
@Namespace("caffe") public static native @Name("caffe_powx<float>") void caffe_powx_float(int n, @Const float[] a, float b, float[] y);

@Namespace("caffe") public static native @Name("caffe_powx<double>") void caffe_powx_double(int n, @Const DoublePointer a, double b, DoublePointer y);
@Namespace("caffe") public static native @Name("caffe_powx<double>") void caffe_powx_double(int n, @Const DoubleBuffer a, double b, DoubleBuffer y);
@Namespace("caffe") public static native @Name("caffe_powx<double>") void caffe_powx_double(int n, @Const double[] a, double b, double[] y);

@Namespace("caffe") public static native @Cast("unsigned int") int caffe_rng_rand();

@Namespace("caffe") public static native @Name("caffe_nextafter<float>") float caffe_nextafter_float(float b);

@Namespace("caffe") public static native @Name("caffe_nextafter<double>") double caffe_nextafter_double(double b);

@Namespace("caffe") public static native @Name("caffe_rng_uniform<float>") void caffe_rng_uniform_float(int n, float a, float b, FloatPointer r);
@Namespace("caffe") public static native @Name("caffe_rng_uniform<float>") void caffe_rng_uniform_float(int n, float a, float b, FloatBuffer r);
@Namespace("caffe") public static native @Name("caffe_rng_uniform<float>") void caffe_rng_uniform_float(int n, float a, float b, float[] r);

@Namespace("caffe") public static native @Name("caffe_rng_uniform<double>") void caffe_rng_uniform_double(int n, double a, double b, DoublePointer r);
@Namespace("caffe") public static native @Name("caffe_rng_uniform<double>") void caffe_rng_uniform_double(int n, double a, double b, DoubleBuffer r);
@Namespace("caffe") public static native @Name("caffe_rng_uniform<double>") void caffe_rng_uniform_double(int n, double a, double b, double[] r);

@Namespace("caffe") public static native @Name("caffe_rng_gaussian<float>") void caffe_rng_gaussian_float(int n, float mu, float sigma,
                        FloatPointer r);
@Namespace("caffe") public static native @Name("caffe_rng_gaussian<float>") void caffe_rng_gaussian_float(int n, float mu, float sigma,
                        FloatBuffer r);
@Namespace("caffe") public static native @Name("caffe_rng_gaussian<float>") void caffe_rng_gaussian_float(int n, float mu, float sigma,
                        float[] r);

@Namespace("caffe") public static native @Name("caffe_rng_gaussian<double>") void caffe_rng_gaussian_double(int n, double mu, double sigma,
                        DoublePointer r);
@Namespace("caffe") public static native @Name("caffe_rng_gaussian<double>") void caffe_rng_gaussian_double(int n, double mu, double sigma,
                        DoubleBuffer r);
@Namespace("caffe") public static native @Name("caffe_rng_gaussian<double>") void caffe_rng_gaussian_double(int n, double mu, double sigma,
                        double[] r);

@Namespace("caffe") public static native @Name("caffe_rng_bernoulli<float>") void caffe_rng_bernoulli_float(int n, float p, IntPointer r);
@Namespace("caffe") public static native @Name("caffe_rng_bernoulli<float>") void caffe_rng_bernoulli_float(int n, float p, IntBuffer r);
@Namespace("caffe") public static native @Name("caffe_rng_bernoulli<float>") void caffe_rng_bernoulli_float(int n, float p, int[] r);

@Namespace("caffe") public static native @Name("caffe_rng_bernoulli<double>") void caffe_rng_bernoulli_double(int n, double p, IntPointer r);
@Namespace("caffe") public static native @Name("caffe_rng_bernoulli<double>") void caffe_rng_bernoulli_double(int n, double p, IntBuffer r);
@Namespace("caffe") public static native @Name("caffe_rng_bernoulli<double>") void caffe_rng_bernoulli_double(int n, double p, int[] r);

@Namespace("caffe") public static native @Name("caffe_exp<float>") void caffe_exp_float(int n, @Const FloatPointer a, FloatPointer y);
@Namespace("caffe") public static native @Name("caffe_exp<float>") void caffe_exp_float(int n, @Const FloatBuffer a, FloatBuffer y);
@Namespace("caffe") public static native @Name("caffe_exp<float>") void caffe_exp_float(int n, @Const float[] a, float[] y);

@Namespace("caffe") public static native @Name("caffe_exp<double>") void caffe_exp_double(int n, @Const DoublePointer a, DoublePointer y);
@Namespace("caffe") public static native @Name("caffe_exp<double>") void caffe_exp_double(int n, @Const DoubleBuffer a, DoubleBuffer y);
@Namespace("caffe") public static native @Name("caffe_exp<double>") void caffe_exp_double(int n, @Const double[] a, double[] y);

@Namespace("caffe") public static native @Name("caffe_log<float>") void caffe_log_float(int n, @Const FloatPointer a, FloatPointer y);
@Namespace("caffe") public static native @Name("caffe_log<float>") void caffe_log_float(int n, @Const FloatBuffer a, FloatBuffer y);
@Namespace("caffe") public static native @Name("caffe_log<float>") void caffe_log_float(int n, @Const float[] a, float[] y);

@Namespace("caffe") public static native @Name("caffe_log<double>") void caffe_log_double(int n, @Const DoublePointer a, DoublePointer y);
@Namespace("caffe") public static native @Name("caffe_log<double>") void caffe_log_double(int n, @Const DoubleBuffer a, DoubleBuffer y);
@Namespace("caffe") public static native @Name("caffe_log<double>") void caffe_log_double(int n, @Const double[] a, double[] y);

@Namespace("caffe") public static native @Name("caffe_abs<float>") void caffe_abs_float(int n, @Const FloatPointer a, FloatPointer y);
@Namespace("caffe") public static native @Name("caffe_abs<float>") void caffe_abs_float(int n, @Const FloatBuffer a, FloatBuffer y);
@Namespace("caffe") public static native @Name("caffe_abs<float>") void caffe_abs_float(int n, @Const float[] a, float[] y);

@Namespace("caffe") public static native @Name("caffe_abs<double>") void caffe_abs_double(int n, @Const DoublePointer a, DoublePointer y);
@Namespace("caffe") public static native @Name("caffe_abs<double>") void caffe_abs_double(int n, @Const DoubleBuffer a, DoubleBuffer y);
@Namespace("caffe") public static native @Name("caffe_abs<double>") void caffe_abs_double(int n, @Const double[] a, double[] y);

@Namespace("caffe") public static native @Name("caffe_cpu_dot<float>") float caffe_cpu_dot_float(int n, @Const FloatPointer x, @Const FloatPointer y);
@Namespace("caffe") public static native @Name("caffe_cpu_dot<float>") float caffe_cpu_dot_float(int n, @Const FloatBuffer x, @Const FloatBuffer y);
@Namespace("caffe") public static native @Name("caffe_cpu_dot<float>") float caffe_cpu_dot_float(int n, @Const float[] x, @Const float[] y);

@Namespace("caffe") public static native @Name("caffe_cpu_dot<double>") double caffe_cpu_dot_double(int n, @Const DoublePointer x, @Const DoublePointer y);
@Namespace("caffe") public static native @Name("caffe_cpu_dot<double>") double caffe_cpu_dot_double(int n, @Const DoubleBuffer x, @Const DoubleBuffer y);
@Namespace("caffe") public static native @Name("caffe_cpu_dot<double>") double caffe_cpu_dot_double(int n, @Const double[] x, @Const double[] y);

@Namespace("caffe") public static native @Name("caffe_cpu_strided_dot<float>") float caffe_cpu_strided_dot_float(int n, @Const FloatPointer x, int incx,
    @Const FloatPointer y, int incy);
@Namespace("caffe") public static native @Name("caffe_cpu_strided_dot<float>") float caffe_cpu_strided_dot_float(int n, @Const FloatBuffer x, int incx,
    @Const FloatBuffer y, int incy);
@Namespace("caffe") public static native @Name("caffe_cpu_strided_dot<float>") float caffe_cpu_strided_dot_float(int n, @Const float[] x, int incx,
    @Const float[] y, int incy);

@Namespace("caffe") public static native @Name("caffe_cpu_strided_dot<double>") double caffe_cpu_strided_dot_double(int n, @Const DoublePointer x, int incx,
    @Const DoublePointer y, int incy);
@Namespace("caffe") public static native @Name("caffe_cpu_strided_dot<double>") double caffe_cpu_strided_dot_double(int n, @Const DoubleBuffer x, int incx,
    @Const DoubleBuffer y, int incy);
@Namespace("caffe") public static native @Name("caffe_cpu_strided_dot<double>") double caffe_cpu_strided_dot_double(int n, @Const double[] x, int incx,
    @Const double[] y, int incy);

// Returns the sum of the absolute values of the elements of vector x
@Namespace("caffe") public static native @Name("caffe_cpu_asum<float>") float caffe_cpu_asum_float(int n, @Const FloatPointer x);
@Namespace("caffe") public static native @Name("caffe_cpu_asum<float>") float caffe_cpu_asum_float(int n, @Const FloatBuffer x);
@Namespace("caffe") public static native @Name("caffe_cpu_asum<float>") float caffe_cpu_asum_float(int n, @Const float[] x);
@Namespace("caffe") public static native @Name("caffe_cpu_asum<double>") double caffe_cpu_asum_double(int n, @Const DoublePointer x);
@Namespace("caffe") public static native @Name("caffe_cpu_asum<double>") double caffe_cpu_asum_double(int n, @Const DoubleBuffer x);
@Namespace("caffe") public static native @Name("caffe_cpu_asum<double>") double caffe_cpu_asum_double(int n, @Const double[] x);

// the branchless, type-safe version from
// http://stackoverflow.com/questions/1903954/is-there-a-standard-sign-function-signum-sgn-in-c-c
@Namespace("caffe") public static native @Name("caffe_sign<float>") byte caffe_sign_float(float val);
@Namespace("caffe") public static native @Name("caffe_sign<double>") byte caffe_sign_double(double val);

// The following two macros are modifications of DEFINE_VSL_UNARY_FUNC
//   in include/caffe/util/mkl_alternate.hpp authored by @Rowland Depp.
// Please refer to commit 7e8ef25c7 of the boost-eigen branch.
// Git cherry picking that commit caused a conflict hard to resolve and
//   copying that file in convenient for code reviewing.
// So they have to be pasted here temporarily.
// #define DEFINE_CAFFE_CPU_UNARY_FUNC(name, operation)
//   template<typename Dtype>
//   void caffe_cpu_##name(const int n, const Dtype* x, Dtype* y) {
//     CHECK_GT(n, 0); CHECK(x); CHECK(y);
//     for (int i = 0; i < n; ++i) {
//       operation;
//     }
//   }

// output is 1 for the positives, 0 for zero, and -1 for the negatives

// This returns a nonzero value if the input has its sign bit set.
// The name sngbit is meant to avoid conflicts with std::signbit in the macro.
// The extra parens are needed because CUDA < 6.5 defines signbit as a macro,
// and we don't want that to expand here when CUDA headers are also included.

@Namespace("caffe") public static native @Name("caffe_cpu_scale<float>") void caffe_cpu_scale_float(int n, float alpha, @Const FloatPointer x, FloatPointer y);
@Namespace("caffe") public static native @Name("caffe_cpu_scale<float>") void caffe_cpu_scale_float(int n, float alpha, @Const FloatBuffer x, FloatBuffer y);
@Namespace("caffe") public static native @Name("caffe_cpu_scale<float>") void caffe_cpu_scale_float(int n, float alpha, @Const float[] x, float[] y);

@Namespace("caffe") public static native @Name("caffe_cpu_scale<double>") void caffe_cpu_scale_double(int n, double alpha, @Const DoublePointer x, DoublePointer y);
@Namespace("caffe") public static native @Name("caffe_cpu_scale<double>") void caffe_cpu_scale_double(int n, double alpha, @Const DoubleBuffer x, DoubleBuffer y);
@Namespace("caffe") public static native @Name("caffe_cpu_scale<double>") void caffe_cpu_scale_double(int n, double alpha, @Const double[] x, double[] y);

// #ifndef CPU_ONLY  // GPU

// #endif  // !CPU_ONLY

  // namespace caffe

// #endif  // CAFFE_UTIL_MATH_FUNCTIONS_H_


// Parsed from caffe/syncedmem.hpp

// #ifndef CAFFE_SYNCEDMEM_HPP_
// #define CAFFE_SYNCEDMEM_HPP_

// #include <cstdlib>

// #ifdef USE_MKL
//   #include "mkl.h"
// #endif

// #include "caffe/common.hpp"

// If CUDA is available and in GPU mode, host memory will be allocated pinned,
// using cudaMallocHost. It avoids dynamic pinning for transfers (DMA).
// The improvement in performance seems negligible in the single GPU case,
// but might be more significant for parallel training. Most importantly,
// it improved stability for large models on many GPUs.
@Namespace("caffe") public static native void CaffeMallocHost(@Cast("void**") PointerPointer ptr, @Cast("size_t") long size, @Cast("bool*") BoolPointer use_cuda);
@Namespace("caffe") public static native void CaffeMallocHost(@Cast("void**") @ByPtrPtr Pointer ptr, @Cast("size_t") long size, @Cast("bool*") BoolPointer use_cuda);
@Namespace("caffe") public static native void CaffeMallocHost(@Cast("void**") @ByPtrPtr Pointer ptr, @Cast("size_t") long size, @Cast("bool*") boolean[] use_cuda);

@Namespace("caffe") public static native void CaffeFreeHost(Pointer ptr, @Cast("bool") boolean use_cuda);
// Targeting ../SyncedMemory.java

  // class SyncedMemory

  // namespace caffe

// #endif  // CAFFE_SYNCEDMEM_HPP_


// Parsed from caffe/blob.hpp

// #ifndef CAFFE_BLOB_HPP_
// #define CAFFE_BLOB_HPP_

// #include <algorithm>
// #include <string>
// #include <vector>

// #include "caffe/common.hpp"
// #include "caffe/proto/caffe.pb.h"
// #include "caffe/syncedmem.hpp"

@MemberGetter public static native int kMaxBlobAxes();
// Targeting ../FloatBlob.java


// Targeting ../DoubleBlob.java

  // class Blob

  // namespace caffe

// #endif  // CAFFE_BLOB_HPP_


// Parsed from caffe/data_transformer.hpp

// #ifndef CAFFE_DATA_TRANSFORMER_HPP
// #define CAFFE_DATA_TRANSFORMER_HPP

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/common.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatDataTransformer.java


// Targeting ../DoubleDataTransformer.java



  // namespace caffe

// #endif  // CAFFE_DATA_TRANSFORMER_HPP_


// Parsed from caffe/filler.hpp

// Fillers are random number generators that fills a blob using the specified
// algorithm. The expectation is that they are only going to be used during
// initialization time and will not involve any GPUs.

// #ifndef CAFFE_FILLER_HPP
// #define CAFFE_FILLER_HPP

// #include <string>

// #include "caffe/blob.hpp"
// #include "caffe/proto/caffe.pb.h"
// #include "caffe/syncedmem.hpp"
// #include "caffe/util/math_functions.hpp"
// Targeting ../FloatFiller.java


// Targeting ../DoubleFiller.java


// Targeting ../FloatConstantFiller.java


// Targeting ../DoubleConstantFiller.java


// Targeting ../FloatUniformFiller.java


// Targeting ../DoubleUniformFiller.java


// Targeting ../FloatGaussianFiller.java


// Targeting ../DoubleGaussianFiller.java


// Targeting ../FloatPositiveUnitballFiller.java


// Targeting ../DoublePositiveUnitballFiller.java


// Targeting ../FloatXavierFiller.java


// Targeting ../DoubleXavierFiller.java


// Targeting ../FloatMSRAFiller.java


// Targeting ../DoubleMSRAFiller.java


// Targeting ../FloatBilinearFiller.java


// Targeting ../DoubleBilinearFiller.java



/**
 * \brief Get a specific filler from the specification given in FillerParameter.
 *
 * Ideally this would be replaced by a factory pattern, but we will leave it
 * this way for now.
 */
@Namespace("caffe") public static native @Name("GetFiller<float>") FloatFiller GetFloatFiller(@Const @ByRef FillerParameter param);
@Namespace("caffe") public static native @Name("GetFiller<double>") DoubleFiller GetDoubleFiller(@Const @ByRef FillerParameter param);

  // namespace caffe

// #endif  // CAFFE_FILLER_HPP_


// Parsed from caffe/internal_thread.hpp

// #ifndef CAFFE_INTERNAL_THREAD_HPP_
// #define CAFFE_INTERNAL_THREAD_HPP_

// #include "caffe/common.hpp"
// Targeting ../thread.java

 
// Targeting ../InternalThread.java



  // namespace caffe

// #endif  // CAFFE_INTERNAL_THREAD_HPP_


// Parsed from caffe/util/hdf5.hpp

// #ifndef CAFFE_UTIL_HDF5_H_
// #define CAFFE_UTIL_HDF5_H_

// #include <string>

// #include "hdf5.h"
// #include "hdf5_hl.h"

// #include "caffe/blob.hpp"

@Namespace("caffe") public static native @Name("hdf5_load_nd_dataset_helper<float>") void hdf5_load_nd_dataset_helper_float(
    @Cast("hid_t") int file_id, @Cast("const char*") BytePointer dataset_name_, int min_dim, int max_dim,
    FloatBlob blob, @Cast("bool") boolean reshape);
@Namespace("caffe") public static native @Name("hdf5_load_nd_dataset_helper<float>") void hdf5_load_nd_dataset_helper_float(
    @Cast("hid_t") int file_id, String dataset_name_, int min_dim, int max_dim,
    FloatBlob blob, @Cast("bool") boolean reshape);

@Namespace("caffe") public static native @Name("hdf5_load_nd_dataset_helper<double>") void hdf5_load_nd_dataset_helper_double(
    @Cast("hid_t") int file_id, @Cast("const char*") BytePointer dataset_name_, int min_dim, int max_dim,
    DoubleBlob blob, @Cast("bool") boolean reshape);
@Namespace("caffe") public static native @Name("hdf5_load_nd_dataset_helper<double>") void hdf5_load_nd_dataset_helper_double(
    @Cast("hid_t") int file_id, String dataset_name_, int min_dim, int max_dim,
    DoubleBlob blob, @Cast("bool") boolean reshape);

@Namespace("caffe") public static native @Name("hdf5_load_nd_dataset<float>") void hdf5_load_nd_dataset_float(
    @Cast("hid_t") int file_id, @Cast("const char*") BytePointer dataset_name_, int min_dim, int max_dim,
    FloatBlob blob, @Cast("bool") boolean reshape/*=false*/);
@Namespace("caffe") public static native @Name("hdf5_load_nd_dataset<float>") void hdf5_load_nd_dataset_float(
    @Cast("hid_t") int file_id, @Cast("const char*") BytePointer dataset_name_, int min_dim, int max_dim,
    FloatBlob blob);
@Namespace("caffe") public static native @Name("hdf5_load_nd_dataset<float>") void hdf5_load_nd_dataset_float(
    @Cast("hid_t") int file_id, String dataset_name_, int min_dim, int max_dim,
    FloatBlob blob, @Cast("bool") boolean reshape/*=false*/);
@Namespace("caffe") public static native @Name("hdf5_load_nd_dataset<float>") void hdf5_load_nd_dataset_float(
    @Cast("hid_t") int file_id, String dataset_name_, int min_dim, int max_dim,
    FloatBlob blob);

@Namespace("caffe") public static native @Name("hdf5_load_nd_dataset<double>") void hdf5_load_nd_dataset_double(
    @Cast("hid_t") int file_id, @Cast("const char*") BytePointer dataset_name_, int min_dim, int max_dim,
    DoubleBlob blob, @Cast("bool") boolean reshape/*=false*/);
@Namespace("caffe") public static native @Name("hdf5_load_nd_dataset<double>") void hdf5_load_nd_dataset_double(
    @Cast("hid_t") int file_id, @Cast("const char*") BytePointer dataset_name_, int min_dim, int max_dim,
    DoubleBlob blob);
@Namespace("caffe") public static native @Name("hdf5_load_nd_dataset<double>") void hdf5_load_nd_dataset_double(
    @Cast("hid_t") int file_id, String dataset_name_, int min_dim, int max_dim,
    DoubleBlob blob, @Cast("bool") boolean reshape/*=false*/);
@Namespace("caffe") public static native @Name("hdf5_load_nd_dataset<double>") void hdf5_load_nd_dataset_double(
    @Cast("hid_t") int file_id, String dataset_name_, int min_dim, int max_dim,
    DoubleBlob blob);

@Namespace("caffe") public static native @Name("hdf5_save_nd_dataset<float>") void hdf5_save_nd_dataset_float(
    @Cast("const hid_t") int file_id, @StdString BytePointer dataset_name, @Const @ByRef FloatBlob blob,
    @Cast("bool") boolean write_diff/*=false*/);
@Namespace("caffe") public static native @Name("hdf5_save_nd_dataset<float>") void hdf5_save_nd_dataset_float(
    @Cast("const hid_t") int file_id, @StdString BytePointer dataset_name, @Const @ByRef FloatBlob blob);
@Namespace("caffe") public static native @Name("hdf5_save_nd_dataset<float>") void hdf5_save_nd_dataset_float(
    @Cast("const hid_t") int file_id, @StdString String dataset_name, @Const @ByRef FloatBlob blob,
    @Cast("bool") boolean write_diff/*=false*/);
@Namespace("caffe") public static native @Name("hdf5_save_nd_dataset<float>") void hdf5_save_nd_dataset_float(
    @Cast("const hid_t") int file_id, @StdString String dataset_name, @Const @ByRef FloatBlob blob);

@Namespace("caffe") public static native @Name("hdf5_save_nd_dataset<double>") void hdf5_save_nd_dataset_double(
    @Cast("const hid_t") int file_id, @StdString BytePointer dataset_name, @Const @ByRef DoubleBlob blob,
    @Cast("bool") boolean write_diff/*=false*/);
@Namespace("caffe") public static native @Name("hdf5_save_nd_dataset<double>") void hdf5_save_nd_dataset_double(
    @Cast("const hid_t") int file_id, @StdString BytePointer dataset_name, @Const @ByRef DoubleBlob blob);
@Namespace("caffe") public static native @Name("hdf5_save_nd_dataset<double>") void hdf5_save_nd_dataset_double(
    @Cast("const hid_t") int file_id, @StdString String dataset_name, @Const @ByRef DoubleBlob blob,
    @Cast("bool") boolean write_diff/*=false*/);
@Namespace("caffe") public static native @Name("hdf5_save_nd_dataset<double>") void hdf5_save_nd_dataset_double(
    @Cast("const hid_t") int file_id, @StdString String dataset_name, @Const @ByRef DoubleBlob blob);

@Namespace("caffe") public static native int hdf5_load_int(@Cast("hid_t") int loc_id, @StdString BytePointer dataset_name);
@Namespace("caffe") public static native int hdf5_load_int(@Cast("hid_t") int loc_id, @StdString String dataset_name);
@Namespace("caffe") public static native void hdf5_save_int(@Cast("hid_t") int loc_id, @StdString BytePointer dataset_name, int i);
@Namespace("caffe") public static native void hdf5_save_int(@Cast("hid_t") int loc_id, @StdString String dataset_name, int i);
@Namespace("caffe") public static native @StdString BytePointer hdf5_load_string(@Cast("hid_t") int loc_id, @StdString BytePointer dataset_name);
@Namespace("caffe") public static native @StdString String hdf5_load_string(@Cast("hid_t") int loc_id, @StdString String dataset_name);
@Namespace("caffe") public static native void hdf5_save_string(@Cast("hid_t") int loc_id, @StdString BytePointer dataset_name,
                      @StdString BytePointer s);
@Namespace("caffe") public static native void hdf5_save_string(@Cast("hid_t") int loc_id, @StdString String dataset_name,
                      @StdString String s);

@Namespace("caffe") public static native int hdf5_get_num_links(@Cast("hid_t") int loc_id);
@Namespace("caffe") public static native @StdString BytePointer hdf5_get_name_by_idx(@Cast("hid_t") int loc_id, int idx);

  // namespace caffe

// #endif   // CAFFE_UTIL_HDF5_H_


// Parsed from caffe/layers/base_data_layer.hpp

// #ifndef CAFFE_DATA_LAYERS_HPP_
// #define CAFFE_DATA_LAYERS_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/data_transformer.hpp"
// #include "caffe/internal_thread.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// #include "caffe/util/blocking_queue.hpp"
// Targeting ../FloatBaseDataLayer.java


// Targeting ../DoubleBaseDataLayer.java


// Targeting ../FloatBatch.java


// Targeting ../DoubleBatch.java


// Targeting ../FloatBasePrefetchingDataLayer.java


// Targeting ../DoubleBasePrefetchingDataLayer.java



  // namespace caffe

// #endif  // CAFFE_DATA_LAYERS_HPP_


// Parsed from caffe/layers/data_layer.hpp

// #ifndef CAFFE_DATA_LAYER_HPP_
// #define CAFFE_DATA_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/data_transformer.hpp"
// #include "caffe/internal_thread.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/layers/base_data_layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// #include "caffe/util/db.hpp"
// Targeting ../FloatDataLayer.java


// Targeting ../DoubleDataLayer.java



  // namespace caffe

// #endif  // CAFFE_DATA_LAYER_HPP_


// Parsed from caffe/layers/dummy_data_layer.hpp

// #ifndef CAFFE_DUMMY_DATA_LAYER_HPP_
// #define CAFFE_DUMMY_DATA_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/filler.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatDummyDataLayer.java


// Targeting ../DoubleDummyDataLayer.java



  // namespace caffe

// #endif  // CAFFE_DUMMY_DATA_LAYER_HPP_


// Parsed from caffe/layers/hdf5_data_layer.hpp

// #ifndef CAFFE_HDF5_DATA_LAYER_HPP_
// #define CAFFE_HDF5_DATA_LAYER_HPP_

// #include "hdf5.h"

// #include <string>
// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/base_data_layer.hpp"
// Targeting ../FloatHDF5DataLayer.java


// Targeting ../DoubleHDF5DataLayer.java



  // namespace caffe

// #endif  // CAFFE_HDF5_DATA_LAYER_HPP_


// Parsed from caffe/layers/hdf5_output_layer.hpp

// #ifndef CAFFE_HDF5_OUTPUT_LAYER_HPP_
// #define CAFFE_HDF5_OUTPUT_LAYER_HPP_

// #include "hdf5.h"

// #include <string>
// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

public static final String HDF5_DATA_DATASET_NAME = "data";
public static final String HDF5_DATA_LABEL_NAME = "label";
// Targeting ../FloatHDF5OutputLayer.java


// Targeting ../DoubleHDF5OutputLayer.java



  // namespace caffe

// #endif  // CAFFE_HDF5_OUTPUT_LAYER_HPP_


// Parsed from caffe/layers/image_data_layer.hpp

// #ifndef CAFFE_IMAGE_DATA_LAYER_HPP_
// #define CAFFE_IMAGE_DATA_LAYER_HPP_

// #include <string>
// #include <utility>
// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/data_transformer.hpp"
// #include "caffe/internal_thread.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/layers/base_data_layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatImageDataLayer.java


// Targeting ../DoubleImageDataLayer.java




  // namespace caffe

// #endif  // CAFFE_IMAGE_DATA_LAYER_HPP_


// Parsed from caffe/layers/memory_data_layer.hpp

// #ifndef CAFFE_MEMORY_DATA_LAYER_HPP_
// #define CAFFE_MEMORY_DATA_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/base_data_layer.hpp"
// Targeting ../FloatMemoryDataLayer.java


// Targeting ../DoubleMemoryDataLayer.java



  // namespace caffe

// #endif  // CAFFE_MEMORY_DATA_LAYER_HPP_


// Parsed from caffe/layers/window_data_layer.hpp

// #ifndef CAFFE_WINDOW_DATA_LAYER_HPP_
// #define CAFFE_WINDOW_DATA_LAYER_HPP_

// #include <string>
// #include <utility>
// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/data_transformer.hpp"
// #include "caffe/internal_thread.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/layers/base_data_layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatWindowDataLayer.java


// Targeting ../DoubleWindowDataLayer.java



  // namespace caffe

// #endif  // CAFFE_WINDOW_DATA_LAYER_HPP_


// Parsed from caffe/layer_factory.hpp

/**
 * \brief A layer factory that allows one to register layers.
 * During runtime, registered layers can be called by passing a LayerParameter
 * protobuffer to the CreateLayer function:
 *
 *     LayerRegistry<Dtype>::CreateLayer(param);
 *
 * There are two ways to register a layer. Assuming that we have a layer like:
 *
 *   template <typename Dtype>
 *   class MyAwesomeLayer : public Layer<Dtype> {
 *     // your implementations
 *   };
 *
 * and its type is its C++ class name, but without the "Layer" at the end
 * ("MyAwesomeLayer" -> "MyAwesome").
 *
 * If the layer is going to be created simply by its constructor, in your c++
 * file, add the following line:
 *
 *    REGISTER_LAYER_CLASS(MyAwesome);
 *
 * Or, if the layer is going to be created by another creator function, in the
 * format of:
 *
 *    template <typename Dtype>
 *    Layer<Dtype*> GetMyAwesomeLayer(const LayerParameter& param) {
 *      // your implementation
 *    }
 *
 * (for example, when your layer has multiple backends, see GetConvolutionLayer
 * for a use case), then you can register the creator function instead, like
 *
 * REGISTER_LAYER_CREATOR(MyAwesome, GetMyAwesomeLayer)
 *
 * Note that each layer type should only be registered once.
 */

// #ifndef CAFFE_LAYER_FACTORY_H_
// #define CAFFE_LAYER_FACTORY_H_

// #include <map>
// #include <string>
// #include <vector>

// #include "caffe/common.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatLayerRegistry.java


// Targeting ../DoubleLayerRegistry.java


// Targeting ../FloatLayerRegisterer.java


// Targeting ../DoubleLayerRegisterer.java




// #define REGISTER_LAYER_CREATOR(type, creator)
//   static LayerRegisterer<float> g_creator_f_##type(#type, creator<float>);
//   static LayerRegisterer<double> g_creator_d_##type(#type, creator<double>)    

// #define REGISTER_LAYER_CLASS(type)
//   template <typename Dtype>
//   shared_ptr<Layer<Dtype> > Creator_##type##Layer(const LayerParameter& param)
//   {
//     return shared_ptr<Layer<Dtype> >(new type##Layer<Dtype>(param));
//   }
//   REGISTER_LAYER_CREATOR(type, Creator_##type##Layer)

  // namespace caffe

// #endif  // CAFFE_LAYER_FACTORY_H_


// Parsed from caffe/layer.hpp

// #ifndef CAFFE_LAYER_H_
// #define CAFFE_LAYER_H_

// #include <algorithm>
// #include <string>
// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/common.hpp"
// #include "caffe/layer_factory.hpp"
// #include "caffe/proto/caffe.pb.h"
// #include "caffe/util/math_functions.hpp"

/**
 Forward declare boost::thread instead of including boost/thread.hpp
 to avoid a boost/NVCC issues (#1009, #1010) on OSX.
 */ 
// Targeting ../FloatLayer.java


// Targeting ../DoubleLayer.java

  // class Layer

// Forward and backward wrappers. You should implement the cpu and
// gpu specific implementations instead, and should not change these
// functions.




// Serialize LayerParameter to protocol buffer


  // namespace caffe

// #endif  // CAFFE_LAYER_H_


// Parsed from caffe/layers/accuracy_layer.hpp

// #ifndef CAFFE_ACCURACY_LAYER_HPP_
// #define CAFFE_ACCURACY_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/loss_layer.hpp"
// Targeting ../FloatAccuracyLayer.java


// Targeting ../DoubleAccuracyLayer.java



  // namespace caffe

// #endif  // CAFFE_ACCURACY_LAYER_HPP_


// Parsed from caffe/layers/loss_layer.hpp

// #ifndef CAFFE_LOSS_LAYER_HPP_
// #define CAFFE_LOSS_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

@Namespace("caffe") @MemberGetter public static native float kLOG_THRESHOLD();
// Targeting ../FloatLossLayer.java


// Targeting ../DoubleLossLayer.java



  // namespace caffe

// #endif  // CAFFE_LOSS_LAYER_HPP_


// Parsed from caffe/layers/contrastive_loss_layer.hpp

// #ifndef CAFFE_CONTRASTIVE_LOSS_LAYER_HPP_
// #define CAFFE_CONTRASTIVE_LOSS_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/loss_layer.hpp"
// Targeting ../FloatContrastiveLossLayer.java


// Targeting ../DoubleContrastiveLossLayer.java



  // namespace caffe

// #endif  // CAFFE_CONTRASTIVE_LOSS_LAYER_HPP_


// Parsed from caffe/layers/euclidean_loss_layer.hpp

// #ifndef CAFFE_EUCLIDEAN_LOSS_LAYER_HPP_
// #define CAFFE_EUCLIDEAN_LOSS_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/loss_layer.hpp"
// Targeting ../FloatEuclideanLossLayer.java


// Targeting ../DoubleEuclideanLossLayer.java



  // namespace caffe

// #endif  // CAFFE_EUCLIDEAN_LOSS_LAYER_HPP_


// Parsed from caffe/layers/hinge_loss_layer.hpp

// #ifndef CAFFE_HINGE_LOSS_LAYER_HPP_
// #define CAFFE_HINGE_LOSS_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/loss_layer.hpp"
// Targeting ../FloatHingeLossLayer.java


// Targeting ../DoubleHingeLossLayer.java




  // namespace caffe

// #endif  // CAFFE_HINGE_LOSS_LAYER_HPP_


// Parsed from caffe/layers/infogain_loss_layer.hpp

// #ifndef CAFFE_INFOGAIN_LOSS_LAYER_HPP_
// #define CAFFE_INFOGAIN_LOSS_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/loss_layer.hpp"
// #include "caffe/layers/softmax_layer.hpp"
// Targeting ../FloatInfogainLossLayer.java


// Targeting ../DoubleInfogainLossLayer.java



  // namespace caffe

// #endif  // CAFFE_INFOGAIN_LOSS_LAYER_HPP_


// Parsed from caffe/layers/multinomial_logistic_loss_layer.hpp

// #ifndef CAFFE_MULTINOMIAL_LOGISTIC_LOSS_LAYER_HPP_
// #define CAFFE_MULTINOMIAL_LOGISTIC_LOSS_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/loss_layer.hpp"
// Targeting ../FloatMultinomialLogisticLossLayer.java


// Targeting ../DoubleMultinomialLogisticLossLayer.java



  // namespace caffe

// #endif  // CAFFE_MULTINOMIAL_LOGISTIC_LOSS_LAYER_HPP_


// Parsed from caffe/layers/sigmoid_cross_entropy_loss_layer.hpp

// #ifndef CAFFE_SIGMOID_CROSS_ENTROPY_LOSS_LAYER_HPP_
// #define CAFFE_SIGMOID_CROSS_ENTROPY_LOSS_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/loss_layer.hpp"
// #include "caffe/layers/sigmoid_layer.hpp"
// Targeting ../FloatSigmoidCrossEntropyLossLayer.java


// Targeting ../DoubleSigmoidCrossEntropyLossLayer.java



  // namespace caffe

// #endif  // CAFFE_SIGMOID_CROSS_ENTROPY_LOSS_LAYER_HPP_


// Parsed from caffe/layers/softmax_loss_layer.hpp

// #ifndef CAFFE_SOFTMAX_WITH_LOSS_LAYER_HPP_
// #define CAFFE_SOFTMAX_WITH_LOSS_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/loss_layer.hpp"
// #include "caffe/layers/softmax_layer.hpp"
// Targeting ../FloatSoftmaxWithLossLayer.java


// Targeting ../DoubleSoftmaxWithLossLayer.java



  // namespace caffe

// #endif  // CAFFE_SOFTMAX_WITH_LOSS_LAYER_HPP_


// Parsed from caffe/layers/neuron_layer.hpp

// #ifndef CAFFE_NEURON_LAYER_HPP_
// #define CAFFE_NEURON_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatNeuronLayer.java


// Targeting ../DoubleNeuronLayer.java



  // namespace caffe

// #endif  // CAFFE_NEURON_LAYER_HPP_


// Parsed from caffe/layers/absval_layer.hpp

// #ifndef CAFFE_ABSVAL_LAYER_HPP_
// #define CAFFE_ABSVAL_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/neuron_layer.hpp"
// Targeting ../FloatAbsValLayer.java


// Targeting ../DoubleAbsValLayer.java



  // namespace caffe

// #endif  // CAFFE_ABSVAL_LAYER_HPP_


// Parsed from caffe/layers/bnll_layer.hpp

// #ifndef CAFFE_BNLL_LAYER_HPP_
// #define CAFFE_BNLL_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/neuron_layer.hpp"
// Targeting ../FloatBNLLLayer.java


// Targeting ../DoubleBNLLLayer.java



  // namespace caffe

// #endif  // CAFFE_BNLL_LAYER_HPP_


// Parsed from caffe/layers/dropout_layer.hpp

// #ifndef CAFFE_DROPOUT_LAYER_HPP_
// #define CAFFE_DROPOUT_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/neuron_layer.hpp"
// Targeting ../FloatDropoutLayer.java


// Targeting ../DoubleDropoutLayer.java



  // namespace caffe

// #endif  // CAFFE_DROPOUT_LAYER_HPP_


// Parsed from caffe/layers/exp_layer.hpp

// #ifndef CAFFE_EXP_LAYER_HPP_
// #define CAFFE_EXP_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/neuron_layer.hpp"
// Targeting ../FloatExpLayer.java


// Targeting ../DoubleExpLayer.java



  // namespace caffe

// #endif  // CAFFE_EXP_LAYER_HPP_


// Parsed from caffe/layers/log_layer.hpp

// #ifndef CAFFE_LOG_LAYER_HPP_
// #define CAFFE_LOG_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/neuron_layer.hpp"

/**
 * \brief Computes {@code  y = log_{\gamma}(\alpha x + \beta) },
 *        as specified by the scale {@code  \alpha }, shift {@code  \beta },
 *        and base {@code  \gamma }.
 */

  // namespace caffe

// #endif  // CAFFE_LOG_LAYER_HPP_


// Parsed from caffe/layers/power_layer.hpp

// #ifndef CAFFE_POWER_LAYER_HPP_
// #define CAFFE_POWER_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/neuron_layer.hpp"
// Targeting ../FloatPowerLayer.java


// Targeting ../DoublePowerLayer.java



  // namespace caffe

// #endif  // CAFFE_POWER_LAYER_HPP_


// Parsed from caffe/layers/relu_layer.hpp

// #ifndef CAFFE_RELU_LAYER_HPP_
// #define CAFFE_RELU_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/neuron_layer.hpp"
// Targeting ../FloatReLULayer.java


// Targeting ../DoubleReLULayer.java



  // namespace caffe

// #endif  // CAFFE_RELU_LAYER_HPP_


// Parsed from caffe/layers/cudnn_relu_layer.hpp

// #ifndef CAFFE_CUDNN_RELU_LAYER_HPP_
// #define CAFFE_CUDNN_RELU_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/neuron_layer.hpp"
// #include "caffe/layers/relu_layer.hpp"
// Targeting ../FloatCuDNNReLULayer.java


// Targeting ../DoubleCuDNNReLULayer.java


// #endif

  // namespace caffe

// #endif  // CAFFE_CUDNN_RELU_LAYER_HPP_


// Parsed from caffe/layers/sigmoid_layer.hpp

// #ifndef CAFFE_SIGMOID_LAYER_HPP_
// #define CAFFE_SIGMOID_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/neuron_layer.hpp"
// Targeting ../FloatSigmoidLayer.java


// Targeting ../DoubleSigmoidLayer.java



  // namespace caffe

// #endif  // CAFFE_SIGMOID_LAYER_HPP_


// Parsed from caffe/layers/cudnn_sigmoid_layer.hpp

// #ifndef CAFFE_CUDNN_SIGMOID_LAYER_HPP_
// #define CAFFE_CUDNN_SIGMOID_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/neuron_layer.hpp"
// #include "caffe/layers/sigmoid_layer.hpp"
// Targeting ../FloatCuDNNSigmoidLayer.java


// Targeting ../DoubleCuDNNSigmoidLayer.java


// #endif

  // namespace caffe

// #endif  // CAFFE_CUDNN_SIGMOID_LAYER_HPP_


// Parsed from caffe/layers/tanh_layer.hpp

// #ifndef CAFFE_TANH_LAYER_HPP_
// #define CAFFE_TANH_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/neuron_layer.hpp"
// Targeting ../FloatTanHLayer.java


// Targeting ../DoubleTanHLayer.java



  // namespace caffe

// #endif  // CAFFE_TANH_LAYER_HPP_


// Parsed from caffe/layers/cudnn_tanh_layer.hpp

// #ifndef CAFFE_CUDNN_TANH_LAYER_HPP_
// #define CAFFE_CUDNN_TANH_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/neuron_layer.hpp"
// #include "caffe/layers/tanh_layer.hpp"
// Targeting ../FloatCuDNNTanHLayer.java


// Targeting ../DoubleCuDNNTanHLayer.java


// #endif

  // namespace caffe

// #endif  // CAFFE_CUDNN_TANH_LAYER_HPP_


// Parsed from caffe/layers/threshold_layer.hpp

// #ifndef CAFFE_THRESHOLD_LAYER_HPP_
// #define CAFFE_THRESHOLD_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/neuron_layer.hpp"
// Targeting ../FloatThresholdLayer.java


// Targeting ../DoubleThresholdLayer.java



  // namespace caffe

// #endif  // CAFFE_THRESHOLD_LAYER_HPP_


// Parsed from caffe/layers/prelu_layer.hpp

// #ifndef CAFFE_PRELU_LAYER_HPP_
// #define CAFFE_PRELU_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/neuron_layer.hpp"
// Targeting ../FloatPReLULayer.java


// Targeting ../DoublePReLULayer.java



  // namespace caffe

// #endif  // CAFFE_PRELU_LAYER_HPP_


// Parsed from caffe/layers/argmax_layer.hpp

// #ifndef CAFFE_ARGMAX_LAYER_HPP_
// #define CAFFE_ARGMAX_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatArgMaxLayer.java


// Targeting ../DoubleArgMaxLayer.java



  // namespace caffe

// #endif  // CAFFE_ARGMAX_LAYER_HPP_


// Parsed from caffe/layers/batch_norm_layer.hpp

// #ifndef CAFFE_BATCHNORM_LAYER_HPP_
// #define CAFFE_BATCHNORM_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatBatchNormLayer.java


// Targeting ../DoubleBatchNormLayer.java



  // namespace caffe

// #endif  // CAFFE_BATCHNORM_LAYER_HPP_


// Parsed from caffe/layers/batch_reindex_layer.hpp

// #ifndef CAFFE_BATCHREINDEX_LAYER_HPP_
// #define CAFFE_BATCHREINDEX_LAYER_HPP_

// #include <utility>
// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatBatchReindexLayer.java


// Targeting ../DoubleBatchReindexLayer.java



  // namespace caffe

// #endif  // CAFFE_BATCHREINDEX_LAYER_HPP_


// Parsed from caffe/layers/concat_layer.hpp

// #ifndef CAFFE_CONCAT_LAYER_HPP_
// #define CAFFE_CONCAT_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatConcatLayer.java


// Targeting ../DoubleConcatLayer.java



  // namespace caffe

// #endif  // CAFFE_CONCAT_LAYER_HPP_


// Parsed from caffe/layers/eltwise_layer.hpp

// #ifndef CAFFE_ELTWISE_LAYER_HPP_
// #define CAFFE_ELTWISE_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatEltwiseLayer.java


// Targeting ../DoubleEltwiseLayer.java



  // namespace caffe

// #endif  // CAFFE_ELTWISE_LAYER_HPP_


// Parsed from caffe/layers/embed_layer.hpp

// #ifndef CAFFE_EMBED_LAYER_HPP_
// #define CAFFE_EMBED_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatEmbedLayer.java


// Targeting ../DoubleEmbedLayer.java



  // namespace caffe

// #endif  // CAFFE_EMBED_LAYER_HPP_


// Parsed from caffe/layers/filter_layer.hpp

// #ifndef CAFFE_FILTER_LAYER_HPP_
// #define CAFFE_FILTER_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatFilterLayer.java


// Targeting ../DoubleFilterLayer.java



  // namespace caffe

// #endif  // CAFFE_FILTER_LAYER_HPP_


// Parsed from caffe/layers/flatten_layer.hpp

// #ifndef CAFFE_FLATTEN_LAYER_HPP_
// #define CAFFE_FLATTEN_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatFlattenLayer.java


// Targeting ../DoubleFlattenLayer.java



  // namespace caffe

// #endif  // CAFFE_FLATTEN_LAYER_HPP_


// Parsed from caffe/layers/inner_product_layer.hpp

// #ifndef CAFFE_INNER_PRODUCT_LAYER_HPP_
// #define CAFFE_INNER_PRODUCT_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatInnerProductLayer.java


// Targeting ../DoubleInnerProductLayer.java



  // namespace caffe

// #endif  // CAFFE_INNER_PRODUCT_LAYER_HPP_


// Parsed from caffe/layers/mvn_layer.hpp

// #ifndef CAFFE_MVN_LAYER_HPP_
// #define CAFFE_MVN_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatMVNLayer.java


// Targeting ../DoubleMVNLayer.java



  // namespace caffe

// #endif  // CAFFE_MVN_LAYER_HPP_


// Parsed from caffe/layers/reshape_layer.hpp

// #ifndef CAFFE_XXX_LAYER_HPP_
// #define CAFFE_XXX_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatReshapeLayer.java


// Targeting ../DoubleReshapeLayer.java



  // namespace caffe

// #endif  // CAFFE_XXX_LAYER_HPP_


// Parsed from caffe/layers/reduction_layer.hpp

// #ifndef CAFFE_REDUCTION_LAYER_HPP_
// #define CAFFE_REDUCTION_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatReductionLayer.java


// Targeting ../DoubleReductionLayer.java



  // namespace caffe

// #endif  // CAFFE_REDUCTION_LAYER_HPP_


// Parsed from caffe/layers/silence_layer.hpp

// #ifndef CAFFE_SILENCE_LAYER_HPP_
// #define CAFFE_SILENCE_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatSilenceLayer.java


// Targeting ../DoubleSilenceLayer.java



  // namespace caffe

// #endif  // CAFFE_SILENCE_LAYER_HPP_


// Parsed from caffe/layers/softmax_layer.hpp

// #ifndef CAFFE_SOFTMAX_LAYER_HPP_
// #define CAFFE_SOFTMAX_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatSoftmaxLayer.java


// Targeting ../DoubleSoftmaxLayer.java



  // namespace caffe

// #endif  // CAFFE_SOFTMAX_LAYER_HPP_


// Parsed from caffe/layers/cudnn_softmax_layer.hpp

// #ifndef CAFFE_CUDNN_SOFTMAX_LAYER_HPP_
// #define CAFFE_CUDNN_SOFTMAX_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/softmax_layer.hpp"
// Targeting ../FloatCuDNNSoftmaxLayer.java


// Targeting ../DoubleCuDNNSoftmaxLayer.java


// #endif

  // namespace caffe

// #endif  // CAFFE_CUDNN_SOFTMAX_LAYER_HPP_


// Parsed from caffe/layers/split_layer.hpp

// #ifndef CAFFE_SPLIT_LAYER_HPP_
// #define CAFFE_SPLIT_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatSplitLayer.java


// Targeting ../DoubleSplitLayer.java



  // namespace caffe

// #endif  // CAFFE_SPLIT_LAYER_HPP_


// Parsed from caffe/layers/slice_layer.hpp

// #ifndef CAFFE_SLICE_LAYER_HPP_
// #define CAFFE_SLICE_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatSliceLayer.java


// Targeting ../DoubleSliceLayer.java



  // namespace caffe

// #endif  // CAFFE_SLICE_LAYER_HPP_


// Parsed from caffe/layers/tile_layer.hpp

// #ifndef CAFFE_TILE_LAYER_HPP_
// #define CAFFE_TILE_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatTileLayer.java


// Targeting ../DoubleTileLayer.java



  // namespace caffe

// #endif  // CAFFE_TILE_LAYER_HPP_


// Parsed from caffe/net.hpp

// #ifndef CAFFE_NET_HPP_
// #define CAFFE_NET_HPP_

// #include <map>
// #include <set>
// #include <string>
// #include <utility>
// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/common.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatNet.java


// Targeting ../DoubleNet.java




  // namespace caffe

// #endif  // CAFFE_NET_HPP_


// Parsed from caffe/parallel.hpp

// #ifndef CAFFE_PARALLEL_HPP_
// #define CAFFE_PARALLEL_HPP_

// #ifdef USE_NCCL

// #include <boost/thread.hpp>

// #include <string>
// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/common.hpp"
// #include "caffe/internal_thread.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// #include "caffe/solver.hpp"
// #include "caffe/syncedmem.hpp"
// #include "caffe/util/blocking_queue.hpp"
// #include "caffe/util/nccl.hpp"

// Represents a net parameters. Once a net is created, its parameter buffers can
// be replaced by ones from Params, to allow parallelization. Params ensures
// parameters are allocated in one consecutive array.

// Params stored in GPU memory.

  // namespace caffe

// #endif  // USE_NCCL
// #endif  // header


// Parsed from caffe/solver.hpp

// #ifndef CAFFE_SOLVER_HPP_
// #define CAFFE_SOLVER_HPP_
// #include <boost/function.hpp>
// #include <string>
// #include <vector>

// #include "caffe/net.hpp"
// #include "caffe/solver_factory.hpp"
// #include "caffe/util/benchmark.hpp"

/**
  * \brief Enumeration of actions that a client of the Solver may request by
  * implementing the Solver's action request function, which a
  * client may optionally provide in order to request early termination
  * or saving a snapshot without exiting. In the executable caffe, this
  * mechanism is used to allow the snapshot to be saved when stopping
  * execution with a SIGINT (Ctrl-C).
  */
    /** enum caffe::SolverAction::Enum */
    public static final int
      NONE = 0,  // Take no special action.
      STOP = 1,  // Stop training. snapshot_after_train controls whether a
                 // snapshot is created.
      SNAPSHOT = 2;  // Take a snapshot, and keep training.
  

/**
 * \brief Type of a function that returns a Solver Action enumeration.
 */
// Targeting ../FloatSolver.java


// Targeting ../DoubleSolver.java



  // namespace caffe

// #endif  // CAFFE_SOLVER_HPP_


// Parsed from caffe/solver_factory.hpp

/**
 * \brief A solver factory that allows one to register solvers, similar to
 * layer factory. During runtime, registered solvers could be called by passing
 * a SolverParameter protobuffer to the CreateSolver function:
 *
 *     SolverRegistry<Dtype>::CreateSolver(param);
 *
 * There are two ways to register a solver. Assuming that we have a solver like:
 *
 *   template <typename Dtype>
 *   class MyAwesomeSolver : public Solver<Dtype> {
 *     // your implementations
 *   };
 *
 * and its type is its C++ class name, but without the "Solver" at the end
 * ("MyAwesomeSolver" -> "MyAwesome").
 *
 * If the solver is going to be created simply by its constructor, in your C++
 * file, add the following line:
 *
 *    REGISTER_SOLVER_CLASS(MyAwesome);
 *
 * Or, if the solver is going to be created by another creator function, in the
 * format of:
 *
 *    template <typename Dtype>
 *    Solver<Dtype*> GetMyAwesomeSolver(const SolverParameter& param) {
 *      // your implementation
 *    }
 *
 * then you can register the creator function instead, like
 *
 * REGISTER_SOLVER_CREATOR(MyAwesome, GetMyAwesomeSolver)
 *
 * Note that each solver type should only be registered once.
 */

// #ifndef CAFFE_SOLVER_FACTORY_H_
// #define CAFFE_SOLVER_FACTORY_H_

// #include <map>
// #include <string>
// #include <vector>

// #include "caffe/common.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatSolverRegistry.java


// Targeting ../DoubleSolverRegistry.java


// Targeting ../FloatSolverRegisterer.java


// Targeting ../DoubleSolverRegisterer.java




// #define REGISTER_SOLVER_CREATOR(type, creator)
//   static SolverRegisterer<float> g_creator_f_##type(#type, creator<float>);
//   static SolverRegisterer<double> g_creator_d_##type(#type, creator<double>)   

// #define REGISTER_SOLVER_CLASS(type)
//   template <typename Dtype>
//   Solver<Dtype>* Creator_##type##Solver(
//       const SolverParameter& param)
//   {
//     return new type##Solver<Dtype>(param);
//   }
//   REGISTER_SOLVER_CREATOR(type, Creator_##type##Solver)

  // namespace caffe

// #endif  // CAFFE_SOLVER_FACTORY_H_


// Parsed from caffe/sgd_solvers.hpp

// #ifndef CAFFE_SGD_SOLVERS_HPP_
// #define CAFFE_SGD_SOLVERS_HPP_

// #include <string>
// #include <vector>

// #include "caffe/solver.hpp"
// Targeting ../FloatSGDSolver.java


// Targeting ../DoubleSGDSolver.java


// Targeting ../FloatNesterovSolver.java


// Targeting ../DoubleNesterovSolver.java


// Targeting ../FloatAdaGradSolver.java


// Targeting ../DoubleAdaGradSolver.java


// Targeting ../FloatRMSPropSolver.java


// Targeting ../DoubleRMSPropSolver.java


// Targeting ../FloatAdaDeltaSolver.java


// Targeting ../DoubleAdaDeltaSolver.java


// Targeting ../FloatAdamSolver.java


// Targeting ../DoubleAdamSolver.java



  // namespace caffe

// #endif  // CAFFE_SGD_SOLVERS_HPP_


// Parsed from caffe/layers/input_layer.hpp

// #ifndef CAFFE_INPUT_LAYER_HPP_
// #define CAFFE_INPUT_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatInputLayer.java


// Targeting ../DoubleInputLayer.java



  // namespace caffe

// #endif  // CAFFE_INPUT_LAYER_HPP_


// Parsed from caffe/layers/parameter_layer.hpp

// #ifndef CAFFE_PARAMETER_LAYER_HPP_
// #define CAFFE_PARAMETER_LAYER_HPP_

// #include <vector>

// #include "caffe/layer.hpp"
// Targeting ../FloatParameterLayer.java


// Targeting ../DoubleParameterLayer.java



  // namespace caffe

// #endif


// Parsed from caffe/layers/base_conv_layer.hpp

// #ifndef CAFFE_BASE_CONVOLUTION_LAYER_HPP_
// #define CAFFE_BASE_CONVOLUTION_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// #include "caffe/util/im2col.hpp"
// Targeting ../FloatBaseConvolutionLayer.java


// Targeting ../DoubleBaseConvolutionLayer.java



  // namespace caffe

// #endif  // CAFFE_BASE_CONVOLUTION_LAYER_HPP_


// Parsed from caffe/layers/conv_layer.hpp

// #ifndef CAFFE_CONV_LAYER_HPP_
// #define CAFFE_CONV_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/base_conv_layer.hpp"
// Targeting ../FloatConvolutionLayer.java


// Targeting ../DoubleConvolutionLayer.java



  // namespace caffe

// #endif  // CAFFE_CONV_LAYER_HPP_


// Parsed from caffe/layers/crop_layer.hpp

// #ifndef CAFFE_CROP_LAYER_HPP_
// #define CAFFE_CROP_LAYER_HPP_

// #include <utility>
// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatCropLayer.java


// Targeting ../DoubleCropLayer.java


  // namespace caffe

// #endif  // CAFFE_CROP_LAYER_HPP_


// Parsed from caffe/layers/deconv_layer.hpp

// #ifndef CAFFE_DECONV_LAYER_HPP_
// #define CAFFE_DECONV_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/base_conv_layer.hpp"
// Targeting ../FloatDeconvolutionLayer.java


// Targeting ../DoubleDeconvolutionLayer.java



  // namespace caffe

// #endif  // CAFFE_DECONV_LAYER_HPP_


// Parsed from caffe/layers/cudnn_conv_layer.hpp

// #ifndef CAFFE_CUDNN_CONV_LAYER_HPP_
// #define CAFFE_CUDNN_CONV_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/conv_layer.hpp"
// Targeting ../FloatCuDNNConvolutionLayer.java


// Targeting ../DoubleCuDNNConvolutionLayer.java


// #endif

  // namespace caffe

// #endif  // CAFFE_CUDNN_CONV_LAYER_HPP_


// Parsed from caffe/layers/im2col_layer.hpp

// #ifndef CAFFE_IM2COL_LAYER_HPP_
// #define CAFFE_IM2COL_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatIm2colLayer.java


// Targeting ../DoubleIm2colLayer.java



  // namespace caffe

// #endif  // CAFFE_IM2COL_LAYER_HPP_


// Parsed from caffe/layers/lrn_layer.hpp

// #ifndef CAFFE_LRN_LAYER_HPP_
// #define CAFFE_LRN_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/eltwise_layer.hpp"
// #include "caffe/layers/pooling_layer.hpp"
// #include "caffe/layers/power_layer.hpp"
// #include "caffe/layers/split_layer.hpp"
// Targeting ../FloatLRNLayer.java


// Targeting ../DoubleLRNLayer.java



  // namespace caffe

// #endif  // CAFFE_LRN_LAYER_HPP_


// Parsed from caffe/layers/cudnn_lrn_layer.hpp

// #ifndef CAFFE_CUDNN_LRN_LAYER_HPP_
// #define CAFFE_CUDNN_LRN_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/lrn_layer.hpp"
// Targeting ../FloatCuDNNLRNLayer.java


// Targeting ../DoubleCuDNNLRNLayer.java


// #endif

  // namespace caffe

// #endif  // CAFFE_CUDNN_LRN_LAYER_HPP_


// Parsed from caffe/layers/cudnn_lcn_layer.hpp

// #ifndef CAFFE_CUDNN_LCN_LAYER_HPP_
// #define CAFFE_CUDNN_LCN_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/lrn_layer.hpp"
// #include "caffe/layers/power_layer.hpp"
// Targeting ../FloatCuDNNLCNLayer.java


// Targeting ../DoubleCuDNNLCNLayer.java


// #endif

  // namespace caffe

// #endif  // CAFFE_CUDNN_LCN_LAYER_HPP_


// Parsed from caffe/layers/pooling_layer.hpp

// #ifndef CAFFE_POOLING_LAYER_HPP_
// #define CAFFE_POOLING_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatPoolingLayer.java


// Targeting ../DoublePoolingLayer.java



  // namespace caffe

// #endif  // CAFFE_POOLING_LAYER_HPP_


// Parsed from caffe/layers/cudnn_pooling_layer.hpp

// #ifndef CAFFE_CUDNN_POOLING_LAYER_HPP_
// #define CAFFE_CUDNN_POOLING_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"

// #include "caffe/layers/pooling_layer.hpp"
// Targeting ../FloatCuDNNPoolingLayer.java


// Targeting ../DoubleCuDNNPoolingLayer.java


// #endif

  // namespace caffe

// #endif  // CAFFE_CUDNN_POOLING_LAYER_HPP_


// Parsed from caffe/layers/spp_layer.hpp

// #ifndef CAFFE_SPP_LAYER_HPP_
// #define CAFFE_SPP_LAYER_HPP_

// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatSPPLayer.java


// Targeting ../DoubleSPPLayer.java



  // namespace caffe

// #endif  // CAFFE_SPP_LAYER_HPP_


// Parsed from caffe/layers/recurrent_layer.hpp

// #ifndef CAFFE_RECURRENT_LAYER_HPP_
// #define CAFFE_RECURRENT_LAYER_HPP_

// #include <string>
// #include <utility>
// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/common.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/net.hpp"
// #include "caffe/proto/caffe.pb.h"
// #include "caffe/util/format.hpp"
// Targeting ../FloatRecurrentLayer.java


// Targeting ../DoubleRecurrentLayer.java



  // namespace caffe

// #endif  // CAFFE_RECURRENT_LAYER_HPP_


// Parsed from caffe/layers/lstm_layer.hpp

// #ifndef CAFFE_LSTM_LAYER_HPP_
// #define CAFFE_LSTM_LAYER_HPP_

// #include <string>
// #include <utility>
// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/common.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/layers/recurrent_layer.hpp"
// #include "caffe/net.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatLSTMLayer.java


// Targeting ../DoubleLSTMLayer.java



/**
 * \brief A helper for LSTMLayer: computes a single timestep of the
 *        non-linearity of the LSTM, producing the updated cell and hidden
 *        states.
 */

  // namespace caffe

// #endif  // CAFFE_LSTM_LAYER_HPP_


// Parsed from caffe/layers/rnn_layer.hpp

// #ifndef CAFFE_RNN_LAYER_HPP_
// #define CAFFE_RNN_LAYER_HPP_

// #include <string>
// #include <utility>
// #include <vector>

// #include "caffe/blob.hpp"
// #include "caffe/common.hpp"
// #include "caffe/layer.hpp"
// #include "caffe/layers/recurrent_layer.hpp"
// #include "caffe/net.hpp"
// #include "caffe/proto/caffe.pb.h"
// Targeting ../FloatRNNLayer.java


// Targeting ../DoubleRNNLayer.java



  // namespace caffe

// #endif  // CAFFE_RNN_LAYER_HPP_


// Parsed from caffe/util/benchmark.hpp

// #ifndef CAFFE_UTIL_BENCHMARK_H_
// #define CAFFE_UTIL_BENCHMARK_H_

// #include <boost/date_time/posix_time/posix_time.hpp>

// #include "caffe/util/device_alternate.hpp"
// Targeting ../Timer.java


// Targeting ../CPUTimer.java



  // namespace caffe

// #endif   // CAFFE_UTIL_BENCHMARK_H_


// Parsed from caffe/util/db.hpp

// #ifndef CAFFE_UTIL_DB_HPP
// #define CAFFE_UTIL_DB_HPP

// #include <string>

// #include "caffe/common.hpp"
// #include "caffe/proto/caffe.pb.h"

/** enum caffe::db::Mode */
public static final int READ = 0, WRITE = 1, NEW = 2;
// Targeting ../Cursor.java


// Targeting ../Transaction.java


// Targeting ../DB.java



@Namespace("caffe::db") public static native DB GetDB(@Cast("caffe::DataParameter::DB") int backend);
@Namespace("caffe::db") public static native DB GetDB(@StdString BytePointer backend);
@Namespace("caffe::db") public static native DB GetDB(@StdString String backend);

  // namespace db
  // namespace caffe

// #endif  // CAFFE_UTIL_DB_HPP


// Parsed from caffe/util/db_leveldb.hpp

// #ifdef USE_LEVELDB
// #ifndef CAFFE_UTIL_DB_LEVELDB_HPP
// #define CAFFE_UTIL_DB_LEVELDB_HPP

// #include <string>

// #include "leveldb/db.h"
// #include "leveldb/write_batch.h"

// #include "caffe/util/db.hpp"
// Targeting ../LevelDBCursor.java


// Targeting ../LevelDBTransaction.java


// Targeting ../LevelDB.java




  // namespace db
  // namespace caffe

// #endif  // CAFFE_UTIL_DB_LEVELDB_HPP
// #endif  // USE_LEVELDB


// Parsed from caffe/util/db_lmdb.hpp

// #ifdef USE_LMDB
// #ifndef CAFFE_UTIL_DB_LMDB_HPP
// #define CAFFE_UTIL_DB_LMDB_HPP

// #include <string>
// #include <vector>

// #include "lmdb.h"

// #include "caffe/util/db.hpp"

@Namespace("caffe::db") public static native void MDB_CHECK(int mdb_status);
// Targeting ../LMDBCursor.java


// Targeting ../LMDBTransaction.java


// Targeting ../LMDB.java



  // namespace db
  // namespace caffe

// #endif  // CAFFE_UTIL_DB_LMDB_HPP
// #endif  // USE_LMDB


// Parsed from caffe/util/io.hpp

// #ifndef CAFFE_UTIL_IO_H_
// #define CAFFE_UTIL_IO_H_

// #include <boost/filesystem.hpp>
// #include <iomanip>
// #include <iostream>  // NOLINT(readability/streams)
// #include <string>

// #include "google/protobuf/message.h"

// #include "caffe/common.hpp"
// #include "caffe/proto/caffe.pb.h"
// #include "caffe/util/format.hpp"

// #ifndef CAFFE_TMP_DIR_RETRIES
public static final int CAFFE_TMP_DIR_RETRIES = 100;
// #endif

@Namespace("caffe") public static native void MakeTempDir(@StdString @Cast({"char*", "std::string*"}) BytePointer temp_dirname);

@Namespace("caffe") public static native void MakeTempFilename(@StdString @Cast({"char*", "std::string*"}) BytePointer temp_filename);

@Namespace("caffe") public static native @Cast("bool") boolean ReadProtoFromTextFile(@Cast("const char*") BytePointer filename, Message proto);
@Namespace("caffe") public static native @Cast("bool") boolean ReadProtoFromTextFile(String filename, Message proto);

@Namespace("caffe") public static native void ReadProtoFromTextFileOrDie(@Cast("const char*") BytePointer filename, Message proto);
@Namespace("caffe") public static native void ReadProtoFromTextFileOrDie(String filename, Message proto);

@Namespace("caffe") public static native void WriteProtoToTextFile(@Const @ByRef Message proto, @Cast("const char*") BytePointer filename);
@Namespace("caffe") public static native void WriteProtoToTextFile(@Const @ByRef Message proto, String filename);

@Namespace("caffe") public static native @Cast("bool") boolean ReadProtoFromBinaryFile(@Cast("const char*") BytePointer filename, Message proto);
@Namespace("caffe") public static native @Cast("bool") boolean ReadProtoFromBinaryFile(String filename, Message proto);

@Namespace("caffe") public static native void ReadProtoFromBinaryFileOrDie(@Cast("const char*") BytePointer filename, Message proto);
@Namespace("caffe") public static native void ReadProtoFromBinaryFileOrDie(String filename, Message proto);


@Namespace("caffe") public static native void WriteProtoToBinaryFile(@Const @ByRef Message proto, @Cast("const char*") BytePointer filename);
@Namespace("caffe") public static native void WriteProtoToBinaryFile(@Const @ByRef Message proto, String filename);

@Namespace("caffe") public static native @Cast("bool") boolean ReadFileToDatum(@StdString BytePointer filename, int label, Datum datum);
@Namespace("caffe") public static native @Cast("bool") boolean ReadFileToDatum(@StdString String filename, int label, Datum datum);

@Namespace("caffe") public static native @Cast("bool") boolean ReadFileToDatum(@StdString BytePointer filename, Datum datum);
@Namespace("caffe") public static native @Cast("bool") boolean ReadFileToDatum(@StdString String filename, Datum datum);

@Namespace("caffe") public static native @Cast("bool") boolean ReadImageToDatum(@StdString BytePointer filename, int label,
    int height, int width, @Cast("const bool") boolean is_color,
    @StdString BytePointer encoding, Datum datum);
@Namespace("caffe") public static native @Cast("bool") boolean ReadImageToDatum(@StdString String filename, int label,
    int height, int width, @Cast("const bool") boolean is_color,
    @StdString String encoding, Datum datum);

@Namespace("caffe") public static native @Cast("bool") boolean ReadImageToDatum(@StdString BytePointer filename, int label,
    int height, int width, @Cast("const bool") boolean is_color, Datum datum);
@Namespace("caffe") public static native @Cast("bool") boolean ReadImageToDatum(@StdString String filename, int label,
    int height, int width, @Cast("const bool") boolean is_color, Datum datum);

@Namespace("caffe") public static native @Cast("bool") boolean ReadImageToDatum(@StdString BytePointer filename, int label,
    int height, int width, Datum datum);
@Namespace("caffe") public static native @Cast("bool") boolean ReadImageToDatum(@StdString String filename, int label,
    int height, int width, Datum datum);

@Namespace("caffe") public static native @Cast("bool") boolean ReadImageToDatum(@StdString BytePointer filename, int label,
    @Cast("const bool") boolean is_color, Datum datum);
@Namespace("caffe") public static native @Cast("bool") boolean ReadImageToDatum(@StdString String filename, int label,
    @Cast("const bool") boolean is_color, Datum datum);

@Namespace("caffe") public static native @Cast("bool") boolean ReadImageToDatum(@StdString BytePointer filename, int label,
    Datum datum);
@Namespace("caffe") public static native @Cast("bool") boolean ReadImageToDatum(@StdString String filename, int label,
    Datum datum);

@Namespace("caffe") public static native @Cast("bool") boolean ReadImageToDatum(@StdString BytePointer filename, int label,
    @StdString BytePointer encoding, Datum datum);
@Namespace("caffe") public static native @Cast("bool") boolean ReadImageToDatum(@StdString String filename, int label,
    @StdString String encoding, Datum datum);

@Namespace("caffe") public static native @Cast("bool") boolean DecodeDatumNative(Datum datum);
@Namespace("caffe") public static native @Cast("bool") boolean DecodeDatum(Datum datum, @Cast("bool") boolean is_color);

// #ifdef USE_OPENCV
@Namespace("caffe") public static native @ByVal Mat ReadImageToCVMat(@StdString BytePointer filename,
    int height, int width, @Cast("const bool") boolean is_color);
@Namespace("caffe") public static native @ByVal Mat ReadImageToCVMat(@StdString String filename,
    int height, int width, @Cast("const bool") boolean is_color);

@Namespace("caffe") public static native @ByVal Mat ReadImageToCVMat(@StdString BytePointer filename,
    int height, int width);
@Namespace("caffe") public static native @ByVal Mat ReadImageToCVMat(@StdString String filename,
    int height, int width);

@Namespace("caffe") public static native @ByVal Mat ReadImageToCVMat(@StdString BytePointer filename,
    @Cast("const bool") boolean is_color);
@Namespace("caffe") public static native @ByVal Mat ReadImageToCVMat(@StdString String filename,
    @Cast("const bool") boolean is_color);

@Namespace("caffe") public static native @ByVal Mat ReadImageToCVMat(@StdString BytePointer filename);
@Namespace("caffe") public static native @ByVal Mat ReadImageToCVMat(@StdString String filename);

@Namespace("caffe") public static native @ByVal Mat DecodeDatumToCVMatNative(@Const @ByRef Datum datum);
@Namespace("caffe") public static native @ByVal Mat DecodeDatumToCVMat(@Const @ByRef Datum datum, @Cast("bool") boolean is_color);

@Namespace("caffe") public static native void CVMatToDatum(@Const @ByRef Mat cv_img, Datum datum);
// #endif  // USE_OPENCV

  // namespace caffe

// #endif   // CAFFE_UTIL_IO_H_


// Parsed from caffe/util/rng.hpp

// #ifndef CAFFE_RNG_CPP_HPP_
// #define CAFFE_RNG_CPP_HPP_

// #include <algorithm>
// #include <iterator>

// #include "boost/random/mersenne_twister.hpp"
// #include "boost/random/uniform_int.hpp"

// #include "caffe/common.hpp"

@Namespace("caffe") public static native @Cast("caffe::rng_t*") Pointer caffe_rng();

// FisherYates algorithm
  // namespace caffe

// #endif  // CAFFE_RNG_HPP_


// Parsed from caffe/util/im2col.hpp

// #ifndef _CAFFE_UTIL_IM2COL_HPP_
// #define _CAFFE_UTIL_IM2COL_HPP_

@Namespace("caffe") public static native @Name("im2col_nd_cpu<float>") void im2col_nd_cpu_float(@Const FloatPointer data_im, int num_spatial_axes,
    @Const IntPointer im_shape, @Const IntPointer col_shape,
    @Const IntPointer kernel_shape, @Const IntPointer pad, @Const IntPointer stride,
    @Const IntPointer dilation, FloatPointer data_col);
@Namespace("caffe") public static native @Name("im2col_nd_cpu<float>") void im2col_nd_cpu_float(@Const FloatBuffer data_im, int num_spatial_axes,
    @Const IntBuffer im_shape, @Const IntBuffer col_shape,
    @Const IntBuffer kernel_shape, @Const IntBuffer pad, @Const IntBuffer stride,
    @Const IntBuffer dilation, FloatBuffer data_col);
@Namespace("caffe") public static native @Name("im2col_nd_cpu<float>") void im2col_nd_cpu_float(@Const float[] data_im, int num_spatial_axes,
    @Const int[] im_shape, @Const int[] col_shape,
    @Const int[] kernel_shape, @Const int[] pad, @Const int[] stride,
    @Const int[] dilation, float[] data_col);

@Namespace("caffe") public static native @Name("im2col_nd_cpu<double>") void im2col_nd_cpu_double(@Const DoublePointer data_im, int num_spatial_axes,
    @Const IntPointer im_shape, @Const IntPointer col_shape,
    @Const IntPointer kernel_shape, @Const IntPointer pad, @Const IntPointer stride,
    @Const IntPointer dilation, DoublePointer data_col);
@Namespace("caffe") public static native @Name("im2col_nd_cpu<double>") void im2col_nd_cpu_double(@Const DoubleBuffer data_im, int num_spatial_axes,
    @Const IntBuffer im_shape, @Const IntBuffer col_shape,
    @Const IntBuffer kernel_shape, @Const IntBuffer pad, @Const IntBuffer stride,
    @Const IntBuffer dilation, DoubleBuffer data_col);
@Namespace("caffe") public static native @Name("im2col_nd_cpu<double>") void im2col_nd_cpu_double(@Const double[] data_im, int num_spatial_axes,
    @Const int[] im_shape, @Const int[] col_shape,
    @Const int[] kernel_shape, @Const int[] pad, @Const int[] stride,
    @Const int[] dilation, double[] data_col);

@Namespace("caffe") public static native @Name("im2col_cpu<float>") void im2col_cpu_float(@Const FloatPointer data_im, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    FloatPointer data_col);
@Namespace("caffe") public static native @Name("im2col_cpu<float>") void im2col_cpu_float(@Const FloatBuffer data_im, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    FloatBuffer data_col);
@Namespace("caffe") public static native @Name("im2col_cpu<float>") void im2col_cpu_float(@Const float[] data_im, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    float[] data_col);

@Namespace("caffe") public static native @Name("im2col_cpu<double>") void im2col_cpu_double(@Const DoublePointer data_im, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    DoublePointer data_col);
@Namespace("caffe") public static native @Name("im2col_cpu<double>") void im2col_cpu_double(@Const DoubleBuffer data_im, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    DoubleBuffer data_col);
@Namespace("caffe") public static native @Name("im2col_cpu<double>") void im2col_cpu_double(@Const double[] data_im, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    double[] data_col);

@Namespace("caffe") public static native @Name("col2im_nd_cpu<float>") void col2im_nd_cpu_float(@Const FloatPointer data_col, int num_spatial_axes,
    @Const IntPointer im_shape, @Const IntPointer col_shape,
    @Const IntPointer kernel_shape, @Const IntPointer pad, @Const IntPointer stride,
    @Const IntPointer dilation, FloatPointer data_im);
@Namespace("caffe") public static native @Name("col2im_nd_cpu<float>") void col2im_nd_cpu_float(@Const FloatBuffer data_col, int num_spatial_axes,
    @Const IntBuffer im_shape, @Const IntBuffer col_shape,
    @Const IntBuffer kernel_shape, @Const IntBuffer pad, @Const IntBuffer stride,
    @Const IntBuffer dilation, FloatBuffer data_im);
@Namespace("caffe") public static native @Name("col2im_nd_cpu<float>") void col2im_nd_cpu_float(@Const float[] data_col, int num_spatial_axes,
    @Const int[] im_shape, @Const int[] col_shape,
    @Const int[] kernel_shape, @Const int[] pad, @Const int[] stride,
    @Const int[] dilation, float[] data_im);

@Namespace("caffe") public static native @Name("col2im_nd_cpu<double>") void col2im_nd_cpu_double(@Const DoublePointer data_col, int num_spatial_axes,
    @Const IntPointer im_shape, @Const IntPointer col_shape,
    @Const IntPointer kernel_shape, @Const IntPointer pad, @Const IntPointer stride,
    @Const IntPointer dilation, DoublePointer data_im);
@Namespace("caffe") public static native @Name("col2im_nd_cpu<double>") void col2im_nd_cpu_double(@Const DoubleBuffer data_col, int num_spatial_axes,
    @Const IntBuffer im_shape, @Const IntBuffer col_shape,
    @Const IntBuffer kernel_shape, @Const IntBuffer pad, @Const IntBuffer stride,
    @Const IntBuffer dilation, DoubleBuffer data_im);
@Namespace("caffe") public static native @Name("col2im_nd_cpu<double>") void col2im_nd_cpu_double(@Const double[] data_col, int num_spatial_axes,
    @Const int[] im_shape, @Const int[] col_shape,
    @Const int[] kernel_shape, @Const int[] pad, @Const int[] stride,
    @Const int[] dilation, double[] data_im);

@Namespace("caffe") public static native @Name("col2im_cpu<float>") void col2im_cpu_float(@Const FloatPointer data_col, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    FloatPointer data_im);
@Namespace("caffe") public static native @Name("col2im_cpu<float>") void col2im_cpu_float(@Const FloatBuffer data_col, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    FloatBuffer data_im);
@Namespace("caffe") public static native @Name("col2im_cpu<float>") void col2im_cpu_float(@Const float[] data_col, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    float[] data_im);

@Namespace("caffe") public static native @Name("col2im_cpu<double>") void col2im_cpu_double(@Const DoublePointer data_col, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    DoublePointer data_im);
@Namespace("caffe") public static native @Name("col2im_cpu<double>") void col2im_cpu_double(@Const DoubleBuffer data_col, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    DoubleBuffer data_im);
@Namespace("caffe") public static native @Name("col2im_cpu<double>") void col2im_cpu_double(@Const double[] data_col, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    double[] data_im);

@Namespace("caffe") public static native @Name("im2col_nd_gpu<float>") void im2col_nd_gpu_float(@Const FloatPointer data_im, int num_spatial_axes,
    int col_size, @Const IntPointer im_shape, @Const IntPointer col_shape,
    @Const IntPointer kernel_shape, @Const IntPointer pad, @Const IntPointer stride,
    @Const IntPointer dilation, FloatPointer data_col);
@Namespace("caffe") public static native @Name("im2col_nd_gpu<float>") void im2col_nd_gpu_float(@Const FloatBuffer data_im, int num_spatial_axes,
    int col_size, @Const IntBuffer im_shape, @Const IntBuffer col_shape,
    @Const IntBuffer kernel_shape, @Const IntBuffer pad, @Const IntBuffer stride,
    @Const IntBuffer dilation, FloatBuffer data_col);
@Namespace("caffe") public static native @Name("im2col_nd_gpu<float>") void im2col_nd_gpu_float(@Const float[] data_im, int num_spatial_axes,
    int col_size, @Const int[] im_shape, @Const int[] col_shape,
    @Const int[] kernel_shape, @Const int[] pad, @Const int[] stride,
    @Const int[] dilation, float[] data_col);

@Namespace("caffe") public static native @Name("im2col_nd_gpu<double>") void im2col_nd_gpu_double(@Const DoublePointer data_im, int num_spatial_axes,
    int col_size, @Const IntPointer im_shape, @Const IntPointer col_shape,
    @Const IntPointer kernel_shape, @Const IntPointer pad, @Const IntPointer stride,
    @Const IntPointer dilation, DoublePointer data_col);
@Namespace("caffe") public static native @Name("im2col_nd_gpu<double>") void im2col_nd_gpu_double(@Const DoubleBuffer data_im, int num_spatial_axes,
    int col_size, @Const IntBuffer im_shape, @Const IntBuffer col_shape,
    @Const IntBuffer kernel_shape, @Const IntBuffer pad, @Const IntBuffer stride,
    @Const IntBuffer dilation, DoubleBuffer data_col);
@Namespace("caffe") public static native @Name("im2col_nd_gpu<double>") void im2col_nd_gpu_double(@Const double[] data_im, int num_spatial_axes,
    int col_size, @Const int[] im_shape, @Const int[] col_shape,
    @Const int[] kernel_shape, @Const int[] pad, @Const int[] stride,
    @Const int[] dilation, double[] data_col);

@Namespace("caffe") public static native @Name("im2col_gpu<float>") void im2col_gpu_float(@Const FloatPointer data_im, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    FloatPointer data_col);
@Namespace("caffe") public static native @Name("im2col_gpu<float>") void im2col_gpu_float(@Const FloatBuffer data_im, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    FloatBuffer data_col);
@Namespace("caffe") public static native @Name("im2col_gpu<float>") void im2col_gpu_float(@Const float[] data_im, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    float[] data_col);

@Namespace("caffe") public static native @Name("im2col_gpu<double>") void im2col_gpu_double(@Const DoublePointer data_im, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    DoublePointer data_col);
@Namespace("caffe") public static native @Name("im2col_gpu<double>") void im2col_gpu_double(@Const DoubleBuffer data_im, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    DoubleBuffer data_col);
@Namespace("caffe") public static native @Name("im2col_gpu<double>") void im2col_gpu_double(@Const double[] data_im, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    double[] data_col);

@Namespace("caffe") public static native @Name("col2im_nd_gpu<float>") void col2im_nd_gpu_float(@Const FloatPointer data_col, int num_spatial_axes,
    int im_size, @Const IntPointer im_shape, @Const IntPointer col_shape,
    @Const IntPointer kernel_shape, @Const IntPointer pad, @Const IntPointer stride,
    @Const IntPointer dilation, FloatPointer data_im);
@Namespace("caffe") public static native @Name("col2im_nd_gpu<float>") void col2im_nd_gpu_float(@Const FloatBuffer data_col, int num_spatial_axes,
    int im_size, @Const IntBuffer im_shape, @Const IntBuffer col_shape,
    @Const IntBuffer kernel_shape, @Const IntBuffer pad, @Const IntBuffer stride,
    @Const IntBuffer dilation, FloatBuffer data_im);
@Namespace("caffe") public static native @Name("col2im_nd_gpu<float>") void col2im_nd_gpu_float(@Const float[] data_col, int num_spatial_axes,
    int im_size, @Const int[] im_shape, @Const int[] col_shape,
    @Const int[] kernel_shape, @Const int[] pad, @Const int[] stride,
    @Const int[] dilation, float[] data_im);

@Namespace("caffe") public static native @Name("col2im_nd_gpu<double>") void col2im_nd_gpu_double(@Const DoublePointer data_col, int num_spatial_axes,
    int im_size, @Const IntPointer im_shape, @Const IntPointer col_shape,
    @Const IntPointer kernel_shape, @Const IntPointer pad, @Const IntPointer stride,
    @Const IntPointer dilation, DoublePointer data_im);
@Namespace("caffe") public static native @Name("col2im_nd_gpu<double>") void col2im_nd_gpu_double(@Const DoubleBuffer data_col, int num_spatial_axes,
    int im_size, @Const IntBuffer im_shape, @Const IntBuffer col_shape,
    @Const IntBuffer kernel_shape, @Const IntBuffer pad, @Const IntBuffer stride,
    @Const IntBuffer dilation, DoubleBuffer data_im);
@Namespace("caffe") public static native @Name("col2im_nd_gpu<double>") void col2im_nd_gpu_double(@Const double[] data_col, int num_spatial_axes,
    int im_size, @Const int[] im_shape, @Const int[] col_shape,
    @Const int[] kernel_shape, @Const int[] pad, @Const int[] stride,
    @Const int[] dilation, double[] data_im);

@Namespace("caffe") public static native @Name("col2im_gpu<float>") void col2im_gpu_float(@Const FloatPointer data_col, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    FloatPointer data_im);
@Namespace("caffe") public static native @Name("col2im_gpu<float>") void col2im_gpu_float(@Const FloatBuffer data_col, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    FloatBuffer data_im);
@Namespace("caffe") public static native @Name("col2im_gpu<float>") void col2im_gpu_float(@Const float[] data_col, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    float[] data_im);

@Namespace("caffe") public static native @Name("col2im_gpu<double>") void col2im_gpu_double(@Const DoublePointer data_col, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    DoublePointer data_im);
@Namespace("caffe") public static native @Name("col2im_gpu<double>") void col2im_gpu_double(@Const DoubleBuffer data_col, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    DoubleBuffer data_im);
@Namespace("caffe") public static native @Name("col2im_gpu<double>") void col2im_gpu_double(@Const double[] data_col, int channels,
    int height, int width, int kernel_h, int kernel_w,
    int pad_h, int pad_w, int stride_h,
    int stride_w, int dilation_h, int dilation_w,
    double[] data_im);

  // namespace caffe

// #endif  // CAFFE_UTIL_IM2COL_HPP_


// Parsed from caffe/util/insert_splits.hpp

// #ifndef _CAFFE_UTIL_INSERT_SPLITS_HPP_
// #define _CAFFE_UTIL_INSERT_SPLITS_HPP_

// #include <string>

// #include "caffe/proto/caffe.pb.h"

// Copy NetParameters with SplitLayers added to replace any shared bottom
// blobs with unique bottom blobs provided by the SplitLayer.
@Namespace("caffe") public static native void InsertSplits(@Const @ByRef NetParameter param, NetParameter param_split);

@Namespace("caffe") public static native void ConfigureSplitLayer(@StdString BytePointer layer_name, @StdString BytePointer blob_name,
    int blob_idx, int split_count, float loss_weight,
    LayerParameter split_layer_param);
@Namespace("caffe") public static native void ConfigureSplitLayer(@StdString String layer_name, @StdString String blob_name,
    int blob_idx, int split_count, float loss_weight,
    LayerParameter split_layer_param);

@Namespace("caffe") public static native @StdString BytePointer SplitLayerName(@StdString BytePointer layer_name, @StdString BytePointer blob_name,
    int blob_idx);
@Namespace("caffe") public static native @StdString String SplitLayerName(@StdString String layer_name, @StdString String blob_name,
    int blob_idx);

@Namespace("caffe") public static native @StdString BytePointer SplitBlobName(@StdString BytePointer layer_name, @StdString BytePointer blob_name,
    int blob_idx, int split_idx);
@Namespace("caffe") public static native @StdString String SplitBlobName(@StdString String layer_name, @StdString String blob_name,
    int blob_idx, int split_idx);

  // namespace caffe

// #endif  // CAFFE_UTIL_INSERT_SPLITS_HPP_


// Parsed from caffe/util/mkl_alternate.hpp

// #ifndef CAFFE_UTIL_MKL_ALTERNATE_H_
// #define CAFFE_UTIL_MKL_ALTERNATE_H_

// #ifdef USE_MKL

// #include <mkl.h>

// #else  // If use MKL, simply include the MKL header

// #ifdef USE_ACCELERATE
// #include <Accelerate/Accelerate.h>
// #else
// #include <cblas.h>
// #endif  // USE_ACCELERATE

// #include <math.h>

// Functions that caffe uses but are not present if MKL is not linked.

// A simple way to define the vsl unary functions. The operation should
// be in the form e.g. y[i] = sqrt(a[i])
// #define DEFINE_VSL_UNARY_FUNC(name, operation)
//   template<typename Dtype>
//   void v##name(const int n, const Dtype* a, Dtype* y) {
//     CHECK_GT(n, 0); CHECK(a); CHECK(y);
//     for (int i = 0; i < n; ++i) { operation; }
//   }
//   inline void vs##name(
//     const int n, const float* a, float* y) {
//     v##name<float>(n, a, y);
//   }
//   inline void vd##name(
//       const int n, const double* a, double* y) {
//     v##name<double>(n, a, y);
//   }
  public static native void vsSqr(
      int n, @Const FloatPointer a, FloatPointer y);
  public static native void vsSqr(
      int n, @Const FloatBuffer a, FloatBuffer y);
  public static native void vsSqr(
      int n, @Const float[] a, float[] y);
  public static native void vdSqr(
        int n, @Const DoublePointer a, DoublePointer y);
  public static native void vdSqr(
        int n, @Const DoubleBuffer a, DoubleBuffer y);
  public static native void vdSqr(
        int n, @Const double[] a, double[] y);
  public static native void vsSqrt(
      int n, @Const FloatPointer a, FloatPointer y);
  public static native void vsSqrt(
      int n, @Const FloatBuffer a, FloatBuffer y);
  public static native void vsSqrt(
      int n, @Const float[] a, float[] y);
  public static native void vdSqrt(
        int n, @Const DoublePointer a, DoublePointer y);
  public static native void vdSqrt(
        int n, @Const DoubleBuffer a, DoubleBuffer y);
  public static native void vdSqrt(
        int n, @Const double[] a, double[] y);
  public static native void vsExp(
      int n, @Const FloatPointer a, FloatPointer y);
  public static native void vsExp(
      int n, @Const FloatBuffer a, FloatBuffer y);
  public static native void vsExp(
      int n, @Const float[] a, float[] y);
  public static native void vdExp(
        int n, @Const DoublePointer a, DoublePointer y);
  public static native void vdExp(
        int n, @Const DoubleBuffer a, DoubleBuffer y);
  public static native void vdExp(
        int n, @Const double[] a, double[] y);
  public static native void vsLn(
      int n, @Const FloatPointer a, FloatPointer y);
  public static native void vsLn(
      int n, @Const FloatBuffer a, FloatBuffer y);
  public static native void vsLn(
      int n, @Const float[] a, float[] y);
  public static native void vdLn(
        int n, @Const DoublePointer a, DoublePointer y);
  public static native void vdLn(
        int n, @Const DoubleBuffer a, DoubleBuffer y);
  public static native void vdLn(
        int n, @Const double[] a, double[] y);
  public static native void vsAbs(
      int n, @Const FloatPointer a, FloatPointer y);
  public static native void vsAbs(
      int n, @Const FloatBuffer a, FloatBuffer y);
  public static native void vsAbs(
      int n, @Const float[] a, float[] y);
  public static native void vdAbs(
        int n, @Const DoublePointer a, DoublePointer y);
  public static native void vdAbs(
        int n, @Const DoubleBuffer a, DoubleBuffer y);
  public static native void vdAbs(
        int n, @Const double[] a, double[] y);

// A simple way to define the vsl unary functions with singular parameter b.
// The operation should be in the form e.g. y[i] = pow(a[i], b)
// #define DEFINE_VSL_UNARY_FUNC_WITH_PARAM(name, operation)
//   template<typename Dtype>
//   void v##name(const int n, const Dtype* a, const Dtype b, Dtype* y) {
//     CHECK_GT(n, 0); CHECK(a); CHECK(y);
//     for (int i = 0; i < n; ++i) { operation; }
//   }
//   inline void vs##name(
//     const int n, const float* a, const float b, float* y) {
//     v##name<float>(n, a, b, y);
//   }
//   inline void vd##name(
//       const int n, const double* a, const float b, double* y) {
//     v##name<double>(n, a, b, y);
//   }
  public static native void vsPowx(
      int n, @Const FloatPointer a, float b, FloatPointer y);
  public static native void vsPowx(
      int n, @Const FloatBuffer a, float b, FloatBuffer y);
  public static native void vsPowx(
      int n, @Const float[] a, float b, float[] y);
  public static native void vdPowx(
        int n, @Const DoublePointer a, float b, DoublePointer y);
  public static native void vdPowx(
        int n, @Const DoubleBuffer a, float b, DoubleBuffer y);
  public static native void vdPowx(
        int n, @Const double[] a, float b, double[] y);

// A simple way to define the vsl binary functions. The operation should
// be in the form e.g. y[i] = a[i] + b[i]
// #define DEFINE_VSL_BINARY_FUNC(name, operation)
//   template<typename Dtype>
//   void v##name(const int n, const Dtype* a, const Dtype* b, Dtype* y) {
//     CHECK_GT(n, 0); CHECK(a); CHECK(b); CHECK(y);
//     for (int i = 0; i < n; ++i) { operation; }
//   }
//   inline void vs##name(
//     const int n, const float* a, const float* b, float* y) {
//     v##name<float>(n, a, b, y);
//   }
//   inline void vd##name(
//       const int n, const double* a, const double* b, double* y) {
//     v##name<double>(n, a, b, y);
//   }
  public static native void vsAdd(
      int n, @Const FloatPointer a, @Const FloatPointer b, FloatPointer y);
  public static native void vsAdd(
      int n, @Const FloatBuffer a, @Const FloatBuffer b, FloatBuffer y);
  public static native void vsAdd(
      int n, @Const float[] a, @Const float[] b, float[] y);
  public static native void vdAdd(
        int n, @Const DoublePointer a, @Const DoublePointer b, DoublePointer y);
  public static native void vdAdd(
        int n, @Const DoubleBuffer a, @Const DoubleBuffer b, DoubleBuffer y);
  public static native void vdAdd(
        int n, @Const double[] a, @Const double[] b, double[] y);
  public static native void vsSub(
      int n, @Const FloatPointer a, @Const FloatPointer b, FloatPointer y);
  public static native void vsSub(
      int n, @Const FloatBuffer a, @Const FloatBuffer b, FloatBuffer y);
  public static native void vsSub(
      int n, @Const float[] a, @Const float[] b, float[] y);
  public static native void vdSub(
        int n, @Const DoublePointer a, @Const DoublePointer b, DoublePointer y);
  public static native void vdSub(
        int n, @Const DoubleBuffer a, @Const DoubleBuffer b, DoubleBuffer y);
  public static native void vdSub(
        int n, @Const double[] a, @Const double[] b, double[] y);
  public static native void vsMul(
      int n, @Const FloatPointer a, @Const FloatPointer b, FloatPointer y);
  public static native void vsMul(
      int n, @Const FloatBuffer a, @Const FloatBuffer b, FloatBuffer y);
  public static native void vsMul(
      int n, @Const float[] a, @Const float[] b, float[] y);
  public static native void vdMul(
        int n, @Const DoublePointer a, @Const DoublePointer b, DoublePointer y);
  public static native void vdMul(
        int n, @Const DoubleBuffer a, @Const DoubleBuffer b, DoubleBuffer y);
  public static native void vdMul(
        int n, @Const double[] a, @Const double[] b, double[] y);
  public static native void vsDiv(
      int n, @Const FloatPointer a, @Const FloatPointer b, FloatPointer y);
  public static native void vsDiv(
      int n, @Const FloatBuffer a, @Const FloatBuffer b, FloatBuffer y);
  public static native void vsDiv(
      int n, @Const float[] a, @Const float[] b, float[] y);
  public static native void vdDiv(
        int n, @Const DoublePointer a, @Const DoublePointer b, DoublePointer y);
  public static native void vdDiv(
        int n, @Const DoubleBuffer a, @Const DoubleBuffer b, DoubleBuffer y);
  public static native void vdDiv(
        int n, @Const double[] a, @Const double[] b, double[] y);

// In addition, MKL comes with an additional function axpby that is not present
// in standard blas. We will simply use a two-step (inefficient, of course) way
// to mimic that.



// #endif  // USE_MKL
// #endif  // CAFFE_UTIL_MKL_ALTERNATE_H_


// Parsed from caffe/util/upgrade_proto.hpp

// #ifndef CAFFE_UTIL_UPGRADE_PROTO_H_
// #define CAFFE_UTIL_UPGRADE_PROTO_H_

// #include <string>

// #include "caffe/proto/caffe.pb.h"

// Return true iff the net is not the current version.
@Namespace("caffe") public static native @Cast("bool") boolean NetNeedsUpgrade(@Const @ByRef NetParameter net_param);

// Check for deprecations and upgrade the NetParameter as needed.
@Namespace("caffe") public static native @Cast("bool") boolean UpgradeNetAsNeeded(@StdString BytePointer param_file, NetParameter param);
@Namespace("caffe") public static native @Cast("bool") boolean UpgradeNetAsNeeded(@StdString String param_file, NetParameter param);

// Read parameters from a file into a NetParameter proto message.
@Namespace("caffe") public static native void ReadNetParamsFromTextFileOrDie(@StdString BytePointer param_file,
                                    NetParameter param);
@Namespace("caffe") public static native void ReadNetParamsFromTextFileOrDie(@StdString String param_file,
                                    NetParameter param);
@Namespace("caffe") public static native void ReadNetParamsFromBinaryFileOrDie(@StdString BytePointer param_file,
                                      NetParameter param);
@Namespace("caffe") public static native void ReadNetParamsFromBinaryFileOrDie(@StdString String param_file,
                                      NetParameter param);

// Return true iff any layer contains parameters specified using
// deprecated V0LayerParameter.
@Namespace("caffe") public static native @Cast("bool") boolean NetNeedsV0ToV1Upgrade(@Const @ByRef NetParameter net_param);

// Perform all necessary transformations to upgrade a V0NetParameter into a
// NetParameter (including upgrading padding layers and LayerParameters).
@Namespace("caffe") public static native @Cast("bool") boolean UpgradeV0Net(@Const @ByRef NetParameter v0_net_param, NetParameter net_param);

// Upgrade NetParameter with padding layers to pad-aware conv layers.
// For any padding layer, remove it and put its pad parameter in any layers
// taking its top blob as input.
// Error if any of these above layers are not-conv layers.
@Namespace("caffe") public static native void UpgradeV0PaddingLayers(@Const @ByRef NetParameter param,
                            NetParameter param_upgraded_pad);

// Upgrade a single V0LayerConnection to the V1LayerParameter format.
@Namespace("caffe") public static native @Cast("bool") boolean UpgradeV0LayerParameter(@Const @ByRef V1LayerParameter v0_layer_connection,
                             V1LayerParameter layer_param);

@Namespace("caffe") public static native @Cast("caffe::V1LayerParameter_LayerType") int UpgradeV0LayerType(@StdString BytePointer type);
@Namespace("caffe") public static native @Cast("caffe::V1LayerParameter_LayerType") int UpgradeV0LayerType(@StdString String type);

// Return true iff any layer contains deprecated data transformation parameters.
@Namespace("caffe") public static native @Cast("bool") boolean NetNeedsDataUpgrade(@Const @ByRef NetParameter net_param);

// Perform all necessary transformations to upgrade old transformation fields
// into a TransformationParameter.
@Namespace("caffe") public static native void UpgradeNetDataTransformation(NetParameter net_param);

// Return true iff the Net contains any layers specified as V1LayerParameters.
@Namespace("caffe") public static native @Cast("bool") boolean NetNeedsV1ToV2Upgrade(@Const @ByRef NetParameter net_param);

// Perform all necessary transformations to upgrade a NetParameter with
// deprecated V1LayerParameters.
@Namespace("caffe") public static native @Cast("bool") boolean UpgradeV1Net(@Const @ByRef NetParameter v1_net_param, NetParameter net_param);

@Namespace("caffe") public static native @Cast("bool") boolean UpgradeV1LayerParameter(@Const @ByRef V1LayerParameter v1_layer_param,
                             LayerParameter layer_param);

@Namespace("caffe") public static native @Cast("const char*") BytePointer UpgradeV1LayerType(@Cast("const caffe::V1LayerParameter_LayerType") int type);

// Return true iff the Net contains input fields.
@Namespace("caffe") public static native @Cast("bool") boolean NetNeedsInputUpgrade(@Const @ByRef NetParameter net_param);

// Perform all necessary transformations to upgrade input fields into layers.
@Namespace("caffe") public static native void UpgradeNetInput(NetParameter net_param);

// Return true iff the Net contains batch norm layers with manual local LRs.
@Namespace("caffe") public static native @Cast("bool") boolean NetNeedsBatchNormUpgrade(@Const @ByRef NetParameter net_param);

// Perform all necessary transformations to upgrade batch norm layers.
@Namespace("caffe") public static native void UpgradeNetBatchNorm(NetParameter net_param);

// Return true iff the solver contains any old solver_type specified as enums
@Namespace("caffe") public static native @Cast("bool") boolean SolverNeedsTypeUpgrade(@Const @ByRef SolverParameter solver_param);

@Namespace("caffe") public static native @Cast("bool") boolean UpgradeSolverType(SolverParameter solver_param);

// Check for deprecations and upgrade the SolverParameter as needed.
@Namespace("caffe") public static native @Cast("bool") boolean UpgradeSolverAsNeeded(@StdString BytePointer param_file, SolverParameter param);
@Namespace("caffe") public static native @Cast("bool") boolean UpgradeSolverAsNeeded(@StdString String param_file, SolverParameter param);

// Read parameters from a file into a SolverParameter proto message.
@Namespace("caffe") public static native void ReadSolverParamsFromTextFileOrDie(@StdString BytePointer param_file,
                                       SolverParameter param);
@Namespace("caffe") public static native void ReadSolverParamsFromTextFileOrDie(@StdString String param_file,
                                       SolverParameter param);

  // namespace caffe

// #endif   // CAFFE_UTIL_UPGRADE_PROTO_H_


}
