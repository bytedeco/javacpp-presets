// Targeted by JavaCPP version 1.5-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.caffe;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import org.bytedeco.opencv.opencv_core.*;
import static org.bytedeco.opencv.global.opencv_core.*;
import org.bytedeco.opencv.opencv_imgproc.*;
import static org.bytedeco.opencv.global.opencv_imgproc.*;
import static org.bytedeco.opencv.global.opencv_imgcodecs.*;
import org.bytedeco.opencv.opencv_videoio.*;
import static org.bytedeco.opencv.global.opencv_videoio.*;
import org.bytedeco.opencv.opencv_highgui.*;
import static org.bytedeco.opencv.global.opencv_highgui.*;
import org.bytedeco.hdf5.*;
import static org.bytedeco.hdf5.global.hdf5.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;

import static org.bytedeco.caffe.global.caffe.*;


// Abstract interface for protocol messages.
//
// See also MessageLite, which contains most every-day operations.  Message
// adds descriptors and reflection on top of that.
//
// The methods of this class that are virtual but not pure-virtual have
// default implementations based on reflection.  Message classes which are
// optimized for speed will want to override these with faster implementations,
// but classes optimized for code size may be happy with keeping them.  See
// the optimize_for option in descriptor.proto.
@Namespace("google::protobuf") @Properties(inherit = org.bytedeco.caffe.presets.caffe.class)
public class Message extends MessageLite {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Message(Pointer p) { super(p); }


  // Basic Operations ------------------------------------------------

  // Construct a new instance of the same type.  Ownership is passed to the
  // caller.  (This is also defined in MessageLite, but is defined again here
  // for return-type covariance.)
  public native Message New();

  // Construct a new instance on the arena. Ownership is passed to the caller
  // if arena is a NULL. Default implementation allows for API compatibility
  // during the Arena transition.
  public native Message New(Arena arena);

  // Make this message into a copy of the given message.  The given message
  // must have the same descriptor, but need not necessarily be the same class.
  // By default this is just implemented as "Clear(); MergeFrom(from);".
  public native void CopyFrom(@Const @ByRef Message from);

  // Merge the fields from the given message into this message.  Singular
  // fields will be overwritten, if specified in from, except for embedded
  // messages which will be merged.  Repeated fields will be concatenated.
  // The given message must be of the same type as this message (i.e. the
  // exact same class).
  public native void MergeFrom(@Const @ByRef Message from);

  // Verifies that IsInitialized() returns true.  GOOGLE_CHECK-fails otherwise, with
  // a nice error message.
  public native void CheckInitialized();

  // Slowly build a list of all required fields that are not set.
  // This is much, much slower than IsInitialized() as it is implemented
  // purely via reflection.  Generally, you should not call this unless you
  // have already determined that an error exists by calling IsInitialized().
  public native void FindInitializationErrors(StringVector errors);

  // Like FindInitializationErrors, but joins all the strings, delimited by
  // commas, and returns them.
  public native @StdString BytePointer InitializationErrorString();

  // Clears all unknown fields from this message and all embedded messages.
  // Normally, if unknown tag numbers are encountered when parsing a message,
  // the tag and value are stored in the message's UnknownFieldSet and
  // then written back out when the message is serialized.  This allows servers
  // which simply route messages to other servers to pass through messages
  // that have new field definitions which they don't yet know about.  However,
  // this behavior can have security implications.  To avoid it, call this
  // method after parsing.
  //
  // See Reflection::GetUnknownFields() for more on unknown fields.
  public native void DiscardUnknownFields();

  // Computes (an estimate of) the total number of bytes currently used for
  // storing the message in memory.  The default implementation calls the
  // Reflection object's SpaceUsed() method.
  //
  // SpaceUsed() is noticeably slower than ByteSize(), as it is implemented
  // using reflection (rather than the generated code implementation for
  // ByteSize()). Like ByteSize(), its CPU time is linear in the number of
  // fields defined for the proto.
  public native @Cast("size_t") long SpaceUsedLong();

  public native int SpaceUsed();

  // Debugging & Testing----------------------------------------------

  // Generates a human readable form of this message, useful for debugging
  // and other purposes.
  public native @StdString BytePointer DebugString();
  // Like DebugString(), but with less whitespace.
  public native @StdString BytePointer ShortDebugString();
  // Like DebugString(), but do not escape UTF-8 byte sequences.
  public native @StdString BytePointer Utf8DebugString();
  // Convenience function useful in GDB.  Prints DebugString() to stdout.
  public native void PrintDebugString();

  // Heavy I/O -------------------------------------------------------
  // Additional parsing and serialization methods not implemented by
  // MessageLite because they are not supported by the lite library.

  // Parse a protocol buffer from a file descriptor.  If successful, the entire
  // input will be consumed.
  public native @Cast("bool") boolean ParseFromFileDescriptor(int file_descriptor);
  // Like ParseFromFileDescriptor(), but accepts messages that are missing
  // required fields.
  public native @Cast("bool") boolean ParsePartialFromFileDescriptor(int file_descriptor);
  // Parse a protocol buffer from a C++ istream.  If successful, the entire
  // input will be consumed.
  public native @Cast("bool") boolean ParseFromIstream(@Cast("std::istream*") Pointer input);
  // Like ParseFromIstream(), but accepts messages that are missing
  // required fields.
  public native @Cast("bool") boolean ParsePartialFromIstream(@Cast("std::istream*") Pointer input);

  // Serialize the message and write it to the given file descriptor.  All
  // required fields must be set.
  public native @Cast("bool") boolean SerializeToFileDescriptor(int file_descriptor);
  // Like SerializeToFileDescriptor(), but allows missing required fields.
  public native @Cast("bool") boolean SerializePartialToFileDescriptor(int file_descriptor);
  // Serialize the message and write it to the given C++ ostream.  All
  // required fields must be set.
  public native @Cast("bool") boolean SerializeToOstream(@Cast("std::ostream*") Pointer output);
  // Like SerializeToOstream(), but allows missing required fields.
  public native @Cast("bool") boolean SerializePartialToOstream(@Cast("std::ostream*") Pointer output);


  // Reflection-based methods ----------------------------------------
  // These methods are pure-virtual in MessageLite, but Message provides
  // reflection-based default implementations.

  public native @StdString BytePointer GetTypeName();
  public native void Clear();
  public native @Cast("bool") boolean IsInitialized();
  public native void CheckTypeAndMergeFrom(@Const @ByRef MessageLite other);
  public native @Cast("bool") boolean MergePartialFromCodedStream(CodedInputStream input);
  public native @Cast("size_t") long ByteSizeLong();
  public native void SerializeWithCachedSizes(CodedOutputStream output);

  // Introspection ---------------------------------------------------

  // Typedef for backwards-compatibility.

  // Get a non-owning pointer to a Descriptor for this message's type.  This
  // describes what fields the message contains, the types of those fields, etc.
  // This object remains property of the Message.
  public native @Const Descriptor GetDescriptor();

  // Get a non-owning pointer to the Reflection interface for this Message,
  // which can be used to read and modify the fields of the Message dynamically
  // (in other words, without knowing the message type at compile time).  This
  // object remains property of the Message.
  //
  // This method remains virtual in case a subclass does not implement
  // reflection and wants to override the default behavior.
  public native @Const final Reflection GetReflection();
}
