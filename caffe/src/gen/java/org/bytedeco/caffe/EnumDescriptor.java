// Targeted by JavaCPP version 1.5-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.caffe;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import org.bytedeco.opencv.opencv_core.*;
import static org.bytedeco.opencv.global.opencv_core.*;
import org.bytedeco.opencv.opencv_imgproc.*;
import static org.bytedeco.opencv.global.opencv_imgproc.*;
import static org.bytedeco.opencv.global.opencv_imgcodecs.*;
import org.bytedeco.opencv.opencv_videoio.*;
import static org.bytedeco.opencv.global.opencv_videoio.*;
import org.bytedeco.opencv.opencv_highgui.*;
import static org.bytedeco.opencv.global.opencv_highgui.*;
import org.bytedeco.hdf5.*;
import static org.bytedeco.hdf5.global.hdf5.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;

import static org.bytedeco.caffe.global.caffe.*;


// Describes an enum type defined in a .proto file.  To get the EnumDescriptor
// for a generated enum type, call TypeName_descriptor().  Use DescriptorPool
// to construct your own descriptors.
@Namespace("google::protobuf") @NoOffset @Properties(inherit = org.bytedeco.caffe.presets.caffe.class)
public class EnumDescriptor extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public EnumDescriptor(Pointer p) { super(p); }

  // The name of this enum type in the containing scope.
  public native @StdString BytePointer name();

  // The fully-qualified name of the enum type, scope delimited by periods.
  public native @StdString BytePointer full_name();

  // Index of this enum within the file or containing message's enum array.
  public native int index();

  // The .proto file in which this enum type was defined.  Never NULL.
  public native @Const FileDescriptor file();

  // The number of values for this EnumDescriptor.  Guaranteed to be greater
  // than zero.
  public native int value_count();
  // Gets a value by index, where 0 <= index < value_count().
  // These are returned in the order they were defined in the .proto file.
  public native @Const EnumValueDescriptor value(int index);

  // Looks up a value by name.  Returns NULL if no such value exists.
  public native @Const EnumValueDescriptor FindValueByName(@StdString BytePointer name);
  public native @Const EnumValueDescriptor FindValueByName(@StdString String name);
  // Looks up a value by number.  Returns NULL if no such value exists.  If
  // multiple values have this number, the first one defined is returned.
  public native @Const EnumValueDescriptor FindValueByNumber(int number);

  // If this enum type is nested in a message type, this is that message type.
  // Otherwise, NULL.
  public native @Const Descriptor containing_type();

  // Get options for this enum type.  These are specified in the .proto file by
  // placing lines like "option foo = 1234;" in the enum definition.  Allowed
  // options are defined by EnumOptions in google/protobuf/descriptor.proto,
  // and any available extensions of that message.
  public native @Const @ByRef EnumOptions options();

  // See Descriptor::CopyTo().
  public native void CopyTo(EnumDescriptorProto proto);

  // See Descriptor::DebugString().
  public native @StdString BytePointer DebugString();

  // See Descriptor::DebugStringWithOptions().
  public native @StdString BytePointer DebugStringWithOptions(@Const @ByRef DebugStringOptions options);

  // Returns true if this is a placeholder for an unknown enum. This will
  // only be the case if this descriptor comes from a DescriptorPool
  // with AllowUnknownDependencies() set.
  public native @Cast("bool") boolean is_placeholder();

  // Reserved fields -------------------------------------------------

  // A range of reserved field numbers.
  public static class ReservedRange extends Pointer {
      static { Loader.load(); }
      /** Default native constructor. */
      public ReservedRange() { super((Pointer)null); allocate(); }
      /** Native array allocator. Access with {@link Pointer#position(long)}. */
      public ReservedRange(long size) { super((Pointer)null); allocateArray(size); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public ReservedRange(Pointer p) { super(p); }
      private native void allocate();
      private native void allocateArray(long size);
      @Override public ReservedRange position(long position) {
          return (ReservedRange)super.position(position);
      }
  
    public native int start(); public native ReservedRange start(int start);  // inclusive
    public native int end(); public native ReservedRange end(int end);    // inclusive
  }

  // The number of reserved ranges in this message type.
  public native int reserved_range_count();
  // Gets an reserved range by index, where 0 <= index <
  // reserved_range_count(). These are returned in the order they were defined
  // in the .proto file.
  public native @Const ReservedRange reserved_range(int index);

  // Returns true if the number is in one of the reserved ranges.
  public native @Cast("bool") boolean IsReservedNumber(int number);

  // Returns NULL if no reserved range contains the given number.
  public native @Const ReservedRange FindReservedRangeContainingNumber(int number);

  // The number of reserved field names in this message type.
  public native int reserved_name_count();

  // Gets a reserved name by index, where 0 <= index < reserved_name_count().
  public native @StdString BytePointer reserved_name(int index);

  // Returns true if the field name is reserved.
  public native @Cast("bool") boolean IsReservedName(@StdString BytePointer name);
  public native @Cast("bool") boolean IsReservedName(@StdString String name);

  // Source Location ---------------------------------------------------

  // Updates |*out_location| to the source location of the complete
  // extent of this enum declaration.  Returns false and leaves
  // |*out_location| unchanged iff location information was not available.
  public native @Cast("bool") boolean GetSourceLocation(SourceLocation out_location);
}
