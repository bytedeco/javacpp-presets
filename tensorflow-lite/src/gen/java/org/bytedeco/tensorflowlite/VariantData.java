// Targeted by JavaCPP version 1.5.12-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.tensorflowlite;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.tensorflowlite.global.tensorflowlite.*;


// --- TFLITE VARIANT TENSORS ----
// Programming languges usually define "variant" as a type that can hold an
// unbounded set of types. See std::any
// (https://en.cppreference.com/w/cpp/utility/any) for a related standard
// library construct. In tensorflow, variant tensors have a data member which is
// an Object that is destructible and copy constructible.
//   Variant tensors are commonly used to represent non trivial data
// semantics that don't fit into simple primitives, such as lists of tensors and
// datasets. Additionally, they can facilitate containers for optimizing
// memory movement of tensor data.
//
// The following set of classes define the variant tensor member for tflite.
// They implement a type-erased container intended to be used behind the
// `data.data : void*` member of `TfLiteTensor`s. Runtime functions interact
// the variant member at the level of a `VariantData`, whereas kernels
// operate with the full knowledge of the un-erased type. The `VariantData`
// class provides abstract methods for destroying and copying `VariantData`.
// Invoking these methods will dispatch to the erased type opaquely.
//    The contents of any object of type derived from `AbstractVariant` can be
// written to `TfLiteTensor::data::data : void*` from kernels. If the runtime
// were to copy such a tensor through `TfLiteTensorCopy`, the destination data
// member will contain the result of invoking the erased type's copy
// constructor. Similar for the runtime releasing tensors from memory, the
// erased type's destructor will be invoked. There are a few caveats to consider
// to use these safely, which we discuss below.
//
// EXAMPLE: READING VARIANT TENSORS
//   ```
//   // retrieve input with `type == kTfLiteVariant`
//   TfLiteTensor* input = ...
//   // must first static cast to `VariantData`, more on this below.
//   VariantData* vd_input = static_cast<VariantData*>(t->data.data);
//   CustomType* typed_input =
//   static_cast<CustomType*>(vd_input);
//   // do custom work on `typed_input`...
//   ```
//
// EXAMPLE: WRITING VARIANT TENSORS
//   ```
//   TfLiteTensor* output = ...
//   // construct a new variant object behind the target tensor
//   TfLiteVariantRealloc<DerivedType, DerivedArgs...>(output, args...);
//   // again must static cast to `VariantData*` before writing to `void*`.
//   output->data.data = static_cast<VariantData*>(typed_output);
//   ```
//
// WHY STATIC CAST TO `VariantData*`
//    The Standard defines a `reinterpret_cast` from a derived type to its
// parents as undefined behavior when the parent is a non-standard layout.
// https://en.cppreference.com/w/cpp/language/reinterpret_cast (see bullet 5).
// Due to the `VariantData` having virtual members it is indeed non-standard
// layout, and any type derived from `VariantData` fails to be
// "transparently-replaceable". I.e. implicit cast from derived to base in this
// case may adjust the pointer and by definition `reinterpret_cast` will not
// the adjust the pointer.
//    Thus, dereferencing a pointer of type `VariantData` which addresses
// the first byte of an object of said derived type is UB unless it was first
// implicitly or statically casted to a `VariantData`. Writing the object of
// derived type directly to `void*` which is dereferenced as a `VariantData` is
// then UB, and so the intermediate cast through `VariantData` must be enforced.
//    A good example of this issue is ellucidate in the bottom code snippet
// here: https://en.cppreference.com/w/cpp/utility/launder.
@Properties(inherit = org.bytedeco.tensorflowlite.presets.tensorflowlite.class)
public class VariantData extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public VariantData(Pointer p) { super(p); }

  // All variant objects must be able to be destroyed and copied.
  // A "virtual copy-constructor". Often the destination tensor of a variant
  // copy may have been previously allocated in a prior call to inference. We
  // allow the copy to target the destinations buffer (`maybe_alloc`),
  // for potential reuse and optimizations. `maybe_alloc` must be of the same
  // underlying derived type. References to whatever object is at
  // `maybe_alloc` may be invalidated.
  public native VariantData CloneTo(VariantData maybe_alloc);
}
