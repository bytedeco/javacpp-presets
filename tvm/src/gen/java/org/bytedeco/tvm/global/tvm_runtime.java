// Targeted by JavaCPP version 1.5.5: DO NOT EDIT THIS FILE

package org.bytedeco.tvm.global;

import org.bytedeco.tvm.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.opencl.*;
import static org.bytedeco.opencl.global.OpenCL.*;
import org.bytedeco.dnnl.*;
import static org.bytedeco.dnnl.global.dnnl.*;
import org.bytedeco.llvm.LLVM.*;
import static org.bytedeco.llvm.global.LLVM.*;
import static org.bytedeco.mkl.global.mkl_rt.*;

public class tvm_runtime extends org.bytedeco.tvm.presets.tvm_runtime {
    static { Loader.load(); }

// Targeting ../StringVector.java


// Parsed from dlpack/dlpack.h

/**
 *  Copyright (c) 2017 by Contributors
 * \file dlpack.h
 * \brief The common header of DLPack.
 */
// #ifndef DLPACK_DLPACK_H_
// #define DLPACK_DLPACK_H_

// #ifdef __cplusplus
// #define DLPACK_EXTERN_C extern "C"
// #else
// #define DLPACK_EXTERN_C
// #endif

/** \brief The current version of dlpack */
public static final int DLPACK_VERSION = 020;

/** \brief DLPACK_DLL prefix for windows */
// #ifdef _WIN32
// #ifdef DLPACK_EXPORTS
// #define DLPACK_DLL __declspec(dllexport)
// #else
// #define DLPACK_DLL __declspec(dllimport)
// #endif
// #else
// #define DLPACK_DLL
// #endif

// #include <stdint.h>
// #include <stddef.h>

// #ifdef __cplusplus
// #endif
/**
 * \brief The device type in DLContext.
 */
/** enum DLDeviceType */
public static final int
  /** \brief CPU device */
  kDLCPU = 1,
  /** \brief CUDA GPU device */
  kDLGPU = 2,
  /**
   * \brief Pinned CUDA GPU device by cudaMallocHost
   * \note kDLCPUPinned = kDLCPU | kDLGPU
   */
  kDLCPUPinned = 3,
  /** \brief OpenCL devices. */
  kDLOpenCL = 4,
  /** \brief Vulkan buffer for next generation graphics. */
  kDLVulkan = 7,
  /** \brief Metal for Apple GPU. */
  kDLMetal = 8,
  /** \brief Verilog simulator buffer */
  kDLVPI = 9,
  /** \brief ROCm GPUs for AMD GPUs */
  kDLROCM = 10,
  /**
   * \brief Reserved extension device type,
   * used for quickly test extension device
   * The semantics can differ depending on the implementation.
   */
  kDLExtDev = 12;
// Targeting ../DLContext.java



/**
 * \brief The type code options DLDataType.
 */
/** enum DLDataTypeCode */
public static final int
  kDLInt = 0,
  kDLUInt = 1,
  kDLFloat = 2,
  kDLBfloat = 4;
// Targeting ../DLDataType.java


// Targeting ../DLTensor.java


// Targeting ../DLManagedTensor.java


// #ifdef __cplusplus  // DLPACK_EXTERN_C
// #endif
// #endif  // DLPACK_DLPACK_H_


// Parsed from dmlc/base.h

/**
 *  Copyright (c) 2015 by Contributors
 * \file base.h
 * \brief defines configuration macros
 */
// #ifndef DMLC_BASE_H_
// #define DMLC_BASE_H_

/** \brief whether use glog for logging */
// #ifndef DMLC_USE_GLOG
public static final int DMLC_USE_GLOG = 0;
// #endif

/**
 * \brief whether throw dmlc::Error instead of
 *  directly calling abort when FATAL error occured
 *  NOTE: this may still not be perfect.
 *  do not use FATAL and CHECK in destructors
 */
// #ifndef DMLC_LOG_FATAL_THROW
public static final int DMLC_LOG_FATAL_THROW = 1;
// #endif

/**
 * \brief whether always log a message before throw
 * This can help identify the error that cannot be catched.
 */
// #ifndef DMLC_LOG_BEFORE_THROW
public static final int DMLC_LOG_BEFORE_THROW = 0;
// #endif

/**
 * \brief Whether to use customized logger,
 * whose output can be decided by other libraries.
 */
// #ifndef DMLC_LOG_CUSTOMIZE
public static final int DMLC_LOG_CUSTOMIZE = 0;
// #endif

/**
 * \brief Whether to enable debug logging feature.
 */
// #ifndef DMLC_LOG_DEBUG
// #ifdef NDEBUG
public static final int DMLC_LOG_DEBUG = 0;
// #else
// #endif
// #endif

/**
 * \brief Whether to disable date message on the log.
 */
// #ifndef DMLC_LOG_NODATE
public static final int DMLC_LOG_NODATE = 0;
// #endif

/** \brief whether compile with hdfs support */
// #ifndef DMLC_USE_HDFS
public static final int DMLC_USE_HDFS = 0;
// #endif

/** \brief whether compile with s3 support */
// #ifndef DMLC_USE_S3
public static final int DMLC_USE_S3 = 0;
// #endif

/** \brief whether or not use parameter server */
// #ifndef DMLC_USE_PS
public static final int DMLC_USE_PS = 0;
// #endif

/** \brief whether or not use c++11 support */
// #ifndef DMLC_USE_CXX11
// #if defined(__GXX_EXPERIMENTAL_CXX0X__) || defined(_MSC_VER)
public static final int DMLC_USE_CXX11 = 1;
// #else
// #endif
// #endif

/** \brief strict CXX11 support */
// #ifndef DMLC_STRICT_CXX11
// #if defined(_MSC_VER)
// #else
// #define DMLC_STRICT_CXX11 (__cplusplus >= 201103L)
// #endif
// #endif

/** \brief Whether cxx11 thread local is supported */
// #ifndef DMLC_CXX11_THREAD_LOCAL
// #if defined(_MSC_VER)
// #elif defined(__clang__)
// #define DMLC_CXX11_THREAD_LOCAL (__has_feature(cxx_thread_local))
// #else
// #define DMLC_CXX11_THREAD_LOCAL (__cplusplus >= 201103L)
// #endif
// #endif

/** \brief Whether to use modern thread local construct */
// #ifndef DMLC_MODERN_THREAD_LOCAL
public static final int DMLC_MODERN_THREAD_LOCAL = 1;
// #endif



/** \brief whether RTTI is enabled */
// #ifndef DMLC_ENABLE_RTTI
public static final int DMLC_ENABLE_RTTI = 1;
// #endif

/** \brief whether use fopen64 */
// #ifndef DMLC_USE_FOPEN64
public static final int DMLC_USE_FOPEN64 = 1;
// #endif

/** check if g++ is before 4.6 */
// #if DMLC_USE_CXX11 && defined(__GNUC__) && !defined(__clang_version__)
// #if __GNUC__ == 4 && __GNUC_MINOR__ < 6
// #pragma message("Will need g++-4.6 or higher to compile all"
//                 "the features in dmlc-core, "
//                 "compile without c++0x, some features may be disabled")
// #undef DMLC_USE_CXX11
// #endif
// #endif

/**
 * \brief Use little endian for binary serialization
 *  if this is set to 0, use big endian.
 */
// #ifndef DMLC_IO_USE_LITTLE_ENDIAN
public static final int DMLC_IO_USE_LITTLE_ENDIAN = 1;
// #endif

/**
 * \brief Enable std::thread related modules,
 *  Used to disable some module in mingw compile.
 */
// #ifndef DMLC_ENABLE_STD_THREAD
public static final int DMLC_ENABLE_STD_THREAD = DMLC_USE_CXX11;
// #endif

/** \brief whether enable regex support, actually need g++-4.9 or higher*/
// #ifndef DMLC_USE_REGEX
public static native @MemberGetter int DMLC_USE_REGEX();
public static final int DMLC_USE_REGEX = DMLC_USE_REGEX();
// #endif

/** \brief helper macro to supress unused warning */
// #if defined(__GNUC__)
// #define DMLC_ATTRIBUTE_UNUSED __attribute__((unused))
// #else
// #define DMLC_ATTRIBUTE_UNUSED
// #endif

/** \brief helper macro to supress Undefined Behavior Sanitizer for a specific function */
// #if defined(__clang__)
// #define DMLC_SUPPRESS_UBSAN __attribute__((no_sanitize("undefined")))
// #elif defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 409)
// #define DMLC_SUPPRESS_UBSAN __attribute__((no_sanitize_undefined))
// #else
// #define DMLC_SUPPRESS_UBSAN
// #endif

/** \brief helper macro to generate string concat */
// #define DMLC_STR_CONCAT_(__x, __y) __x##__y
// #define DMLC_STR_CONCAT(__x, __y) DMLC_STR_CONCAT_(__x, __y)

/**
 * \brief Disable copy constructor and assignment operator.
 *
 * If C++11 is supported, both copy and move constructors and
 * assignment operators are deleted explicitly. Otherwise, they are
 * only declared but not implemented. Place this macro in private
 * section if C++11 is not available.
 */
// #ifndef DISALLOW_COPY_AND_ASSIGN
// #  if DMLC_USE_CXX11
// #    define DISALLOW_COPY_AND_ASSIGN(T)
//        T(T const&) = delete;
//        T(T&&) = delete;
//        T& operator=(T const&) = delete;
//        T& operator=(T&&) = delete
// #  else
// #  endif
// #endif

// #ifdef __APPLE__
// #endif

// #ifdef _MSC_VER
// #else
// #ifdef _FILE_OFFSET_BITS
// #if _FILE_OFFSET_BITS == 32
// #pragma message("Warning: FILE OFFSET BITS defined to be 32 bit")
// #endif
// #endif
// #include <sys/types.h>
// #endif

// #ifdef _MSC_VER
// #else
// #include <inttypes.h>
// #endif
// #include <string>
// #include <vector>

// #if defined(_MSC_VER) && _MSC_VER < 1900
// #endif

// #if defined(_MSC_VER)
// #else
// #define DMLC_NO_INLINE __attribute__((noinline))
// #endif

// #if DMLC_USE_CXX11
public static native @MemberGetter int DMLC_THROW_EXCEPTION();
public static final int DMLC_THROW_EXCEPTION = DMLC_THROW_EXCEPTION();
public static native @MemberGetter int DMLC_NO_EXCEPTION();
public static final int DMLC_NO_EXCEPTION = DMLC_NO_EXCEPTION();
// #else
// #endif

/** \brief namespace for dmlc */
/**
 * \brief safely get the beginning address of a vector
 * @param vec input vector
 * @return beginning address of a vector
 */
/**
 * \brief get the beginning address of a const vector
 * @param vec input vector
 * @return beginning address of a vector
 */
/**
 * \brief get the beginning address of a string
 * @param str input string
 * @return beginning address of a string
 */
@Namespace("dmlc") public static native @Cast("char*") BytePointer BeginPtr(@StdString @ByRef BytePointer str);
/**
 * \brief get the beginning address of a const string
 * @param str input string
 * @return beginning address of a string
 */
@Namespace("dmlc") public static native String BeginPtr(@StdString String str);
  // namespace dmlc

// #if defined(_MSC_VER) && _MSC_VER < 1900
// #endif

/* If fopen64 is not defined by current machine,
   replace fopen64 with std::fopen. Also determine ability to print stack trace
   for fatal error and define DMLC_LOG_STACK_TRACE if stack trace can be
   produced. Always keep this include directive at the bottom of dmlc/base.h */
// #ifdef DMLC_CORE_USE_CMAKE
// #include <dmlc/build_config.h>
// #else
// #include <dmlc/build_config_default.h>
// #endif

// #endif  // DMLC_BASE_H_


// Parsed from dmlc/logging.h

/**
 *  Copyright (c) 2015 by Contributors
 * \file logging.h
 * \brief defines logging macros of dmlc
 *  allows use of GLOG, fall back to internal
 *  implementation when disabled
 */
// #ifndef DMLC_LOGGING_H_
// #define DMLC_LOGGING_H_
// #include <cstdio>
// #include <cstdlib>
// #include <string>
// #include <vector>
// #include <stdexcept>
// #include <memory>
// #include "./base.h"

// #if DMLC_LOG_STACK_TRACE
// #include <cxxabi.h>
// #include <sstream>
// #include DMLC_EXECINFO_H
// #endif
// Targeting ../Error.java



// #if DMLC_LOG_STACK_TRACE
// get stack trace logging depth from env variable.
@Namespace("dmlc") public static native @Cast("size_t") long LogStackTraceLevel();



// By default skip the first frame because
// that belongs to ~LogMessageFatal
@Namespace("dmlc") public static native @StdString BytePointer StackTrace(
    @Cast("size_t") long start_frame/*=1*/,
    @Cast("const size_t") long stack_size/*=DMLC_LOG_STACK_TRACE_SIZE*/);
@Namespace("dmlc") public static native @StdString BytePointer StackTrace();

// #else  // DMLC_LOG_STACK_TRACE is off

// #endif  // DMLC_LOG_STACK_TRACE
  // namespace dmlc

// #if DMLC_USE_GLOG
// #include <glog/logging.h>
/**
 * \brief optionally redirect to google's init log
 * @param argv0 The arguments.
 */
@Namespace("dmlc") public static native void InitLogging(@Cast("const char*") BytePointer argv0);
@Namespace("dmlc") public static native void InitLogging(String argv0);
  // namespace dmlc

// #else

// #endif
// #endif  // DMLC_LOGGING_H_


// Parsed from dmlc/io.h

/**
 *  Copyright (c) 2015 by Contributors
 * \file io.h
 * \brief defines serializable interface of dmlc
 */
// #ifndef DMLC_IO_H_
// #define DMLC_IO_H_
// #include <cstdio>
// #include <string>
// #include <cstring>
// #include <vector>
// #include <istream>
// #include <ostream>
// #include <streambuf>
// #include "./logging.h"

// include uint64_t only to make io standalone
// #ifdef _MSC_VER
// #else
// #include <inttypes.h>
// #endif

/** \brief namespace for dmlc */
// Targeting ../Stream.java


// Targeting ../SeekStream.java


// Targeting ../Serializable.java


// Targeting ../InputSplit.java


// Targeting ../ostream.java


// Targeting ../istream.java


// #endif
  // namespace dmlc

// #include "./serializer.h"
// implementations of inline functions







// #ifndef _LIBCPP_SGX_NO_IOSTREAMS
// implementations for ostream




// implementations for istream


// #endif
// Targeting ../URI.java



/** \brief type of file */
@Namespace("dmlc::io") public enum FileType {
  /** \brief the file is file */
  kFile(0),
  /** \brief the file is directory */
  kDirectory(1);

    public final int value;
    private FileType(int v) { this.value = v; }
    private FileType(FileType e) { this.value = e.value; }
    public FileType intern() { for (FileType e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}
// Targeting ../FileInfo.java


// Targeting ../FileSystem.java



  // namespace io
  // namespace dmlc
// #endif  // DMLC_IO_H_


// Parsed from dmlc/type_traits.h

/**
 *  Copyright (c) 2015 by Contributors
 * \file type_traits.h
 * \brief type traits information header
 */
// #ifndef DMLC_TYPE_TRAITS_H_
// #define DMLC_TYPE_TRAITS_H_

// #include "./base.h"
// #if DMLC_USE_CXX11
// #include <type_traits>
// #endif
// #include <string>
/**
 * \brief whether a type is pod type
 * \tparam T the type to query
 */


/**
 * \brief whether a type is integer type
 * \tparam T the type to query
 */

/**
 * \brief whether a type is floating point type
 * \tparam T the type to query
 */

/**
 * \brief whether a type is arithemetic type
 * \tparam T the type to query
 */

/**
 * \brief helper class to construct a string that represents type name
 *
 * Specialized this class to defined type name of custom types
 *
 * \tparam T the type to query
 */

/**
 * \brief the string representation of type name
 * \tparam T the type to query
 * @return a const string of typename.
 */

/**
 * \brief whether a type have save/load function
 * \tparam T the type to query
 */

/**
 * \brief template to select type based on condition
 * For example, IfThenElseType<true, int, float>::Type will give int
 * \tparam cond the condition
 * \tparam Then the typename to be returned if cond is true
 * \tparam Else typename to be returned if cond is false
*/

/** \brief macro to quickly declare traits information */
// #define DMLC_DECLARE_TRAITS(Trait, Type, Value)
//   template<>
//   struct Trait<Type> {
//     static const bool value = Value;
//   }

/** \brief macro to quickly declare traits information */
// #define DMLC_DECLARE_TYPE_NAME(Type, Name)
//   template<>
//   struct type_name_helper<Type> {
//     static inline std::string value() {
//       return Name;
//     }
//   }
// Targeting ../is_pod.java


// Targeting ../is_integral.java


// Targeting ../is_floating_point.java


// Targeting ../type_name_helper.java


/** \endcond */
  // namespace dmlc
// #endif  // DMLC_TYPE_TRAITS_H_


// Parsed from dmlc/endian.h

/**
 *  Copyright (c) 2017 by Contributors
 * \file endian.h
 * \brief Endian testing, need c++11
 */
// #ifndef DMLC_ENDIAN_H_
// #define DMLC_ENDIAN_H_

// #include "./base.h"

// #ifdef DMLC_CMAKE_LITTLE_ENDIAN
  // If compiled with CMake, use CMake's endian detection logic
  public static native @MemberGetter int DMLC_LITTLE_ENDIAN();
  public static final int DMLC_LITTLE_ENDIAN = DMLC_LITTLE_ENDIAN();
// #else
// #endif

/** \brief whether serialize using little endian */
public static native @MemberGetter int DMLC_IO_NO_ENDIAN_SWAP();
public static final int DMLC_IO_NO_ENDIAN_SWAP = DMLC_IO_NO_ENDIAN_SWAP();

/**
 * \brief A generic inplace byte swapping function.
 * @param data The data pointer.
 * @param elem_bytes The number of bytes of the data elements
 * @param num_elems Number of elements in the data.
 * \note Always try pass in constant elem_bytes to enable
 *       compiler optimization
 */
@Namespace("dmlc") public static native void ByteSwap(Pointer data, @Cast("size_t") long elem_bytes, @Cast("size_t") long num_elems);

  // namespace dmlc
// #endif  // DMLC_ENDIAN_H_


// Parsed from dmlc/serializer.h

/**
 *  Copyright (c) 2015 by Contributors
 * \file serializer.h
 * \brief serializer template class that helps serialization.
 *  This file do not need to be directly used by most user.
 */
// #ifndef DMLC_SERIALIZER_H_
// #define DMLC_SERIALIZER_H_

// #include <vector>
// #include <string>
// #include <map>
// #include <set>
// #include <list>
// #include <deque>
// #include <utility>

// #include "./base.h"
// #include "./io.h"
// #include "./logging.h"
// #include "./type_traits.h"
// #include "./endian.h"

// #if DMLC_USE_CXX11
// #include <unordered_map>
// #include <unordered_set>
// #endif
/** \brief internal namespace for serializers */
/**
 * \brief generic serialization handler
 * \tparam T the type to be serialized
 * \tparam need_endian_swap Whether use little endian
 */

/** \cond Doxygen_Suppress
/**
 * \brief Serializer that redirect calls by condition
 * \tparam cond the condition
 * \tparam Then the serializer used for then condition
 * \tparam Else the serializer used for else condition
 * \tparam Return the type of data the serializer handles
 */

/** \brief Serializer for POD(plain-old-data) data */

/** \brief Serializer for arithmetic data, handle endianness */

// serializer for class that have save/load function

/**
 * \brief dummy class for undefined serialization.
 *   This is used to generate error message when user tries to
 *   serialize something that is not supported.
 * \tparam T the type to be serialized
 */

/**
 * \brief Serializer handler for std::vector<T> where T is POD type.
 * \tparam T element type
 */

/**
 * \brief Serializer handler for std::vector<T> where T can be composed type
 * \tparam T element type
 */

/**
 * \brief Serializer handler for std::basic_string<T> where T is POD type.
 * \tparam T element type
 */

/** \brief Serializer for std::pair */

// set type handler that can handle most collection type case


// handler that can handle most list type case
// this type insert function takes additional iterator

/** \endcond
<p>
/**
 * \brief generic serialization handler for type T
 *
 *  User can define specialization of this class to support
 *  composite serialization of their own class.
 *
 * \tparam T the type to be serialized
 */

/** \cond Doxygen_Suppress */

// #if DMLC_USE_CXX11
// #endif
/** \endcond */
  // namespace serializer
  // namespace dmlc
// #endif  // DMLC_SERIALIZER_H_


// Parsed from tvm/runtime/c_runtime_api.h

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/*
 * \file tvm/runtime/c_runtime_api.h
 * \brief TVM runtime library.
 *
 *  The philosophy of TVM project is to customize the compilation
 *  stage to generate code that can used by other projects transparently.
 *  So this is a minimum runtime code gluing, and some limited
 *  memory management code to enable quick testing.
 *
 *  The runtime API is independent from TVM compilation stack and can
 *  be linked via libtvm_runtime.
 *
 *  The common flow is:
 *   - Use TVMFuncListGlobalNames to get global function name
 *   - Use TVMFuncCall to call these functions.
 */
// #ifndef TVM_RUNTIME_C_RUNTIME_API_H_
// #define TVM_RUNTIME_C_RUNTIME_API_H_

// Macros to do weak linking
// #ifdef _MSC_VER
// #else
// #define TVM_WEAK __attribute__((weak))
// #endif

// #ifdef __EMSCRIPTEN__
// #include <emscripten/emscripten.h>
// #define TVM_DLL EMSCRIPTEN_KEEPALIVE
// #endif

// #ifndef TVM_DLL
// #ifdef _WIN32
// #ifdef TVM_EXPORTS
// #define TVM_DLL __declspec(dllexport)
// #else
// #define TVM_DLL __declspec(dllimport)
// #endif
// #else
// #define TVM_DLL __attribute__((visibility("default")))
// #endif
// #endif

// TVM version
public static final String TVM_VERSION = "0.7.0";

// TVM Runtime is DLPack compatible.
// #include <dlpack/dlpack.h>

// #ifdef __cplusplus
// #endif
// #include <stddef.h>
// #include <stdint.h>

/** \brief type of array index. */

/** \brief Extension device types in TVM */
/** enum TVMDeviceExtType */
public static final int
  kDLAOCL = 5,
  kDLSDAccel = 6,
  kOpenGL = 11,
  kDLMicroDev = 13,
  kDLHexagon = 14,
  kDLWebGPU = 15;
  // AddExtraTVMType which is not in DLPack here

/**
 * \brief The type code in used and only used in TVM FFI for argument passing.
 *
 * DLPack consistency:
 * 1) kTVMArgInt is compatible with kDLInt
 * 2) kTVMArgFloat is compatible with kDLFloat
 * 3) kDLUInt is not in ArgTypeCode, but has a spared slot
 *
 * Downstream consistency:
 * The kDLInt, kDLUInt, kDLFloat are kept consistent with the original ArgType code
 *
 * It is only used in argument passing, and should not be confused with
 * DataType::TypeCode, which is DLPack-compatible.
 *
 * @see tvm::runtime::DataType::TypeCode
 */
/** enum TVMArgTypeCode */
public static final int
  kTVMArgInt = kDLInt,
  kTVMArgFloat = kDLFloat,
  kTVMOpaqueHandle = 3,
  kTVMNullptr = 4,
  kTVMDataType = 5,
  kTVMContext = 6,
  kTVMDLTensorHandle = 7,
  kTVMObjectHandle = 8,
  kTVMModuleHandle = 9,
  kTVMPackedFuncHandle = 10,
  kTVMStr = 11,
  kTVMBytes = 12,
  kTVMNDArrayHandle = 13,
  kTVMObjectRValueRefArg = 14,
  // Extension codes for other frameworks to integrate TVM PackedFunc.
  // To make sure each framework's id do not conflict, use first and
  // last sections to mark ranges.
  // Open an issue at the repo if you need a section of code.
  kTVMExtBegin = 15,
  kTVMNNVMFirst = 16,
  kTVMNNVMLast = 20,
  // The following section of code is used for non-reserved types.
  kTVMExtReserveEnd = 64,
  kTVMExtEnd = 128;

/**
 * \brief The Device information, abstract away common device types.
 */

/** \brief the array handle */
// Targeting ../TVMValue.java


// Targeting ../TVMByteArray.java


// Targeting ../TVMModuleHandle.java


// Targeting ../TVMFunctionHandle.java


// Targeting ../TVMRetValueHandle.java


// Targeting ../TVMStreamHandle.java


// Targeting ../TVMObjectHandle.java



/**
 * \brief Used for implementing C API function.
 *  Set last error message before return.
 * @param msg The error message to be set.
 */
public static native void TVMAPISetLastError(@Cast("const char*") BytePointer msg);
public static native void TVMAPISetLastError(String msg);

/**
 * \brief return str message of the last error
 *  all function in this file will return 0 when success
 *  and -1 when an error occurred,
 *  TVMGetLastError can be called to retrieve the error
 *
 *  this function is threadsafe and can be called by different thread
 *  @return error info
 */
public static native @Cast("const char*") BytePointer TVMGetLastError();
/**
 * \brief Load module from file.
 * @param file_name The file name to load the module from.
 * @param format The format of the module.
 * @param out The result module
 *
 * @return 0 when success, -1 when failure happens
 * \note The resulting module do not contain import relation.
 *  It can be reconstructed by TVMModImport.
 */
public static native int TVMModLoadFromFile(@Cast("const char*") BytePointer file_name, @Cast("const char*") BytePointer format, @ByPtrPtr TVMModuleHandle out);
public static native int TVMModLoadFromFile(String file_name, String format, @ByPtrPtr TVMModuleHandle out);

/**
 * \brief Add dep to mod's dependency.
 *  This allows functions in this module to use modules.
 *
 * @param mod The module handle.
 * @param dep The dependent module to be imported.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMModImport(TVMModuleHandle mod, TVMModuleHandle dep);

/**
 * \brief Get function from the module.
 * @param mod The module handle.
 * @param func_name The name of the function.
 * @param query_imports Whether to query imported modules
 * @param out The result function, can be NULL if it is not available.
 * @return 0 when no error is thrown, -1 when failure happens
 */
public static native int TVMModGetFunction(TVMModuleHandle mod, @Cast("const char*") BytePointer func_name, int query_imports,
                              @ByPtrPtr TVMFunctionHandle out);
public static native int TVMModGetFunction(TVMModuleHandle mod, String func_name, int query_imports,
                              @ByPtrPtr TVMFunctionHandle out);

/**
 * \brief Free the Module
 * @param mod The module to be freed.
 *
 * \note This may not free up the module's resources.
 *  If there is active TVMFunctionHandle uses the module
 *  Or if this module is imported by another active module.
 *
 *  The all functions remains valid until TVMFuncFree is called.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMModFree(TVMModuleHandle mod);

/**
 * \brief Free the function when it is no longer needed.
 * @param func The function handle
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMFuncFree(TVMFunctionHandle func);

/**
 * \brief Call a Packed TVM Function.
 *
 * @param func node handle of the function.
 * @param arg_values The arguments
 * @param type_codes The type codes of the arguments
 * @param num_args Number of arguments.
 *
 * @param ret_val The return value.
 * @param ret_type_code the type code of return value.
 *
 * @return 0 when success, -1 when failure happens
 * \note TVM calls always exchanges with type bits=64, lanes=1
 *
 * \note API calls always exchanges with type bits=64, lanes=1
 *   If API call returns container handles (e.g. FunctionHandle)
 *   these handles should be managed by the front-end.
 *   The front-end need to call free function (e.g. TVMFuncFree)
 *   to free these handles.
 */
public static native int TVMFuncCall(TVMFunctionHandle func, TVMValue arg_values, IntPointer type_codes, int num_args,
                        TVMValue ret_val, IntPointer ret_type_code);
public static native int TVMFuncCall(TVMFunctionHandle func, TVMValue arg_values, IntBuffer type_codes, int num_args,
                        TVMValue ret_val, IntBuffer ret_type_code);
public static native int TVMFuncCall(TVMFunctionHandle func, TVMValue arg_values, int[] type_codes, int num_args,
                        TVMValue ret_val, int[] ret_type_code);

/**
 * \brief Set the return value of TVMPackedCFunc.
 *
 *  This function is called by TVMPackedCFunc to set the return value.
 *  When this function is not called, the function returns null by default.
 *
 * @param ret The return value handle, pass by ret in TVMPackedCFunc
 * @param value The value to be returned.
 * @param type_code The type of the value to be returned.
 * @param num_ret Number of return values, for now only 1 is supported.
 */
public static native int TVMCFuncSetReturn(TVMRetValueHandle ret, TVMValue value, IntPointer type_code, int num_ret);
public static native int TVMCFuncSetReturn(TVMRetValueHandle ret, TVMValue value, IntBuffer type_code, int num_ret);
public static native int TVMCFuncSetReturn(TVMRetValueHandle ret, TVMValue value, int[] type_code, int num_ret);

/**
 * \brief Inplace translate callback argument value to return value.
 *  This is only needed for non-POD arguments.
 *
 * @param value The value to be translated.
 * @param code The type code to be translated.
 * \note This function will do a shallow copy when necessary.
 *
 * @return 0 when success, -1 when failure happens.
 */
public static native int TVMCbArgToReturn(TVMValue value, IntPointer code);
public static native int TVMCbArgToReturn(TVMValue value, IntBuffer code);
public static native int TVMCbArgToReturn(TVMValue value, int[] code);
// Targeting ../TVMPackedCFunc.java


// Targeting ../TVMPackedCFuncFinalizer.java


// Targeting ../TVMExtensionFuncDeclarer.java



/**
 * \brief Wrap a TVMPackedCFunc to become a FunctionHandle.
 *
 * The resource_handle will be managed by TVM API, until the function is no longer used.
 *
 * @param func The packed C function.
 * @param resource_handle The resource handle from front-end, can be NULL.
 * @param fin The finalizer on resource handle when the FunctionHandle get freed, can be NULL
 * @param out the result function handle.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMFuncCreateFromCFunc(TVMPackedCFunc func, Pointer resource_handle,
                                   TVMPackedCFuncFinalizer fin, @ByPtrPtr TVMFunctionHandle out);

/**
 * \brief Register the function to runtime's global table.
 *
 * The registered function then can be pulled by the backend by the name.
 *
 * @param name The name of the function.
 * @param f The function to be registered.
 * @param override Whether allow override already registered function.
 */
public static native int TVMFuncRegisterGlobal(@Cast("const char*") BytePointer name, TVMFunctionHandle f, int override);
public static native int TVMFuncRegisterGlobal(String name, TVMFunctionHandle f, int override);

/**
 * \brief Get a global function.
 *
 * @param name The name of the function.
 * @param out the result function pointer, NULL if it does not exist.
 *
 * \note The function handle of global function is managed by TVM runtime,
 *  So TVMFuncFree is should not be called when it get deleted.
 */
public static native int TVMFuncGetGlobal(@Cast("const char*") BytePointer name, @ByPtrPtr TVMFunctionHandle out);
public static native int TVMFuncGetGlobal(String name, @ByPtrPtr TVMFunctionHandle out);

/**
 * \brief List all the globally registered function name
 * @param out_size The number of functions
 * @param out_array The array of function names.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMFuncListGlobalNames(IntPointer out_size, @Cast("const char***") @ByPtrPtr PointerPointer out_array);
public static native int TVMFuncListGlobalNames(IntBuffer out_size, @Cast("const char***") @ByPtrPtr PointerPointer out_array);
public static native int TVMFuncListGlobalNames(int[] out_size, @Cast("const char***") @ByPtrPtr PointerPointer out_array);

// Array related apis for quick proptyping
/**
 * \brief Allocate a nd-array's memory,
 *  including space of shape, of given spec.
 *
 * @param shape The shape of the array, the data content will be copied to out
 * @param ndim The number of dimension of the array.
 * @param dtype_code The type code of the dtype
 * @param dtype_bits The number of bits of dtype
 * @param dtype_lanes The number of lanes in the dtype.
 * @param device_type The device type of context
 * @param device_id The device id of context.
 * @param out The output handle.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMArrayAlloc(@Cast("const tvm_index_t*") LongPointer shape, int ndim, int dtype_code, int dtype_bits,
                          int dtype_lanes, int device_type, int device_id, @Cast("TVMArrayHandle*") PointerPointer out);
public static native int TVMArrayAlloc(@Cast("const tvm_index_t*") LongBuffer shape, int ndim, int dtype_code, int dtype_bits,
                          int dtype_lanes, int device_type, int device_id, @ByPtrPtr @Cast("TVMArrayHandle*") DLTensor out);
public static native int TVMArrayAlloc(@Cast("const tvm_index_t*") long[] shape, int ndim, int dtype_code, int dtype_bits,
                          int dtype_lanes, int device_type, int device_id, @Cast("TVMArrayHandle*") PointerPointer out);
public static native int TVMArrayAlloc(@Cast("const tvm_index_t*") LongPointer shape, int ndim, int dtype_code, int dtype_bits,
                          int dtype_lanes, int device_type, int device_id, @ByPtrPtr @Cast("TVMArrayHandle*") DLTensor out);
public static native int TVMArrayAlloc(@Cast("const tvm_index_t*") LongBuffer shape, int ndim, int dtype_code, int dtype_bits,
                          int dtype_lanes, int device_type, int device_id, @Cast("TVMArrayHandle*") PointerPointer out);
public static native int TVMArrayAlloc(@Cast("const tvm_index_t*") long[] shape, int ndim, int dtype_code, int dtype_bits,
                          int dtype_lanes, int device_type, int device_id, @ByPtrPtr @Cast("TVMArrayHandle*") DLTensor out);

/**
 * \brief Free the TVM Array.
 * @param handle The array handle to be freed.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMArrayFree(@Cast("TVMArrayHandle") DLTensor handle);

/**
 * \brief Copy array data from CPU byte array.
 * @param handle The array handle.
 * @param data the data pointer
 * @param nbytes The number of bytes to copy.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMArrayCopyFromBytes(@Cast("TVMArrayHandle") DLTensor handle, Pointer data, @Cast("size_t") long nbytes);

/**
 * \brief Copy array data to CPU byte array.
 * @param handle The array handle.
 * @param data the data pointer
 * @param nbytes The number of bytes to copy.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMArrayCopyToBytes(@Cast("TVMArrayHandle") DLTensor handle, Pointer data, @Cast("size_t") long nbytes);

/**
 * \brief Copy the array, both from and to must be valid during the copy.
 * @param from The array to be copied from.
 * @param to The target space.
 * @param stream The stream where the copy happens, can be NULL.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMArrayCopyFromTo(@Cast("TVMArrayHandle") DLTensor from, @Cast("TVMArrayHandle") DLTensor to, TVMStreamHandle stream);

/**
 * \brief Produce an array from the DLManagedTensor that shares data memory
 * with the DLManagedTensor.
 * @param from The source DLManagedTensor.
 * @param out The output array handle.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMArrayFromDLPack(DLManagedTensor from, @Cast("TVMArrayHandle*") PointerPointer out);
public static native int TVMArrayFromDLPack(DLManagedTensor from, @ByPtrPtr @Cast("TVMArrayHandle*") DLTensor out);

/**
 * \brief Produce a DLMangedTensor from the array that shares data memory with
 * the array.
 * @param from The source array.
 * @param out The DLManagedTensor handle.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMArrayToDLPack(@Cast("TVMArrayHandle") DLTensor from, @Cast("DLManagedTensor**") PointerPointer out);
public static native int TVMArrayToDLPack(@Cast("TVMArrayHandle") DLTensor from, @ByPtrPtr DLManagedTensor out);

/**
 * \brief Delete (free) a DLManagedTensor's data.
 * @param dltensor Pointer to the DLManagedTensor.
 */
public static native void TVMDLManagedTensorCallDeleter(DLManagedTensor dltensor);

/**
 * \brief Create a new runtime stream.
 *
 * @param device_type The device type of context
 * @param device_id The device id of context
 * @param out The new stream handle
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMStreamCreate(int device_type, int device_id, @ByPtrPtr TVMStreamHandle out);

/**
 * \brief Free a created stream handle.
 *
 * @param device_type The device type of context
 * @param device_id The device id of context
 * @param stream The stream to be freed
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMStreamFree(int device_type, int device_id, TVMStreamHandle stream);

/**
 * \brief Set the runtime stream of current thread to be stream.
 *  The subsequent calls to the same device_type
 *  will use the setted stream handle.
 *  The specific type of stream is runtime device dependent.
 *
 * @param device_type The device type of context
 * @param device_id The device id of context.
 * @param handle The stream handle.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMSetStream(int device_type, int device_id, TVMStreamHandle handle);

/**
 * \brief Wait until all computations on stream completes.
 *
 * @param device_type The device type of context
 * @param device_id The device id of context.
 * @param stream The stream to be synchronized.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMSynchronize(int device_type, int device_id, TVMStreamHandle stream);

/**
 * \brief Synchronize two streams of execution.
 *
 * @param device_type The device type of context
 * @param device_id The device id of context
 * @param src The source stream to synchronize.
 * @param dst The destination stream to synchronize.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMStreamStreamSynchronize(int device_type, int device_id, TVMStreamHandle src,
                                       TVMStreamHandle dst);

/**
 * \brief Get the type_index from an object.
 *
 * @param obj The object handle.
 * @param out_tindex the output type index.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMObjectGetTypeIndex(TVMObjectHandle obj, @Cast("unsigned*") IntPointer out_tindex);
public static native int TVMObjectGetTypeIndex(TVMObjectHandle obj, @Cast("unsigned*") IntBuffer out_tindex);
public static native int TVMObjectGetTypeIndex(TVMObjectHandle obj, @Cast("unsigned*") int[] out_tindex);

/**
 * \brief Convert type key to type index.
 * @param type_key The key of the type.
 * @param out_tindex the corresponding type index.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMObjectTypeKey2Index(@Cast("const char*") BytePointer type_key, @Cast("unsigned*") IntPointer out_tindex);
public static native int TVMObjectTypeKey2Index(String type_key, @Cast("unsigned*") IntBuffer out_tindex);
public static native int TVMObjectTypeKey2Index(@Cast("const char*") BytePointer type_key, @Cast("unsigned*") int[] out_tindex);
public static native int TVMObjectTypeKey2Index(String type_key, @Cast("unsigned*") IntPointer out_tindex);
public static native int TVMObjectTypeKey2Index(@Cast("const char*") BytePointer type_key, @Cast("unsigned*") IntBuffer out_tindex);
public static native int TVMObjectTypeKey2Index(String type_key, @Cast("unsigned*") int[] out_tindex);

/**
 * \brief Increase the reference count of an object.
 *
 * @param obj The object handle.
 * \note Internally we increase the reference counter of the object.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMObjectRetain(TVMObjectHandle obj);

/**
 * \brief Free the object.
 *
 * @param obj The object handle.
 * \note Internally we decrease the reference counter of the object.
 *       The object will be freed when every reference to the object are removed.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMObjectFree(TVMObjectHandle obj);

/**
 * \brief Allocate a data space on device.
 * @param ctx The device context to perform operation.
 * @param nbytes The number of bytes in memory.
 * @param alignment The alignment of the memory.
 * @param type_hint The type of elements. Only needed by certain backends such
 *                   as nbytes & alignment are sufficient for most backends.
 * @param out_data The allocated device pointer.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMDeviceAllocDataSpace(@ByVal DLContext ctx, @Cast("size_t") long nbytes, @Cast("size_t") long alignment,
                                    @ByVal DLDataType type_hint, @Cast("void**") PointerPointer out_data);
public static native int TVMDeviceAllocDataSpace(@ByVal DLContext ctx, @Cast("size_t") long nbytes, @Cast("size_t") long alignment,
                                    @ByVal DLDataType type_hint, @Cast("void**") @ByPtrPtr Pointer out_data);

/**
 * \brief Free a data space on device.
 * @param ctx The device context to perform operation.
 * @param ptr The data space.
 * @return 0 when success, -1 when failure happens
 */
public static native int TVMDeviceFreeDataSpace(@ByVal @Cast("TVMContext*") DLContext ctx, Pointer ptr);

/**
 * \brief Copy data from one place to another.
 * @param from The source array.
 * @param from_offset The byte offeset in the from.
 * @param to The target array.
 * @param to_offset The byte offset in the to.
 * @param num_bytes The size of the memory in bytes
 * @param ctx_from The source context
 * @param ctx_to The target context
 * @param type_hint The type of elements, only neded by certain backends.
 *                  can be useful for cross device endian converison.
 * @param stream Optional stream object.
 * @return 0 when success, -1 when failure happens.
 */
public static native int TVMDeviceCopyDataFromTo(@Const Pointer from, @Cast("size_t") long from_offset, Pointer to,
                                    @Cast("size_t") long to_offset, @Cast("size_t") long num_bytes, @ByVal @Cast("TVMContext*") DLContext ctx_from,
                                    @ByVal @Cast("TVMContext*") DLContext ctx_to, @ByVal DLDataType type_hint,
                                    TVMStreamHandle stream);

/**
 * \brief Check that an object is derived from another.
 * @param child_type_index The type index of the derived type.
 * @param parent_type_index The type index of the parent type.
 * @param is_derived A boolean representing whether this predicate holds.
 * @return 0 when success, -1 when failure happens.
 */
public static native int TVMObjectDerivedFrom(@Cast("uint32_t") int child_type_index, @Cast("uint32_t") int parent_type_index,
                                 IntPointer is_derived);
public static native int TVMObjectDerivedFrom(@Cast("uint32_t") int child_type_index, @Cast("uint32_t") int parent_type_index,
                                 IntBuffer is_derived);
public static native int TVMObjectDerivedFrom(@Cast("uint32_t") int child_type_index, @Cast("uint32_t") int parent_type_index,
                                 int[] is_derived);

// #ifdef __cplusplus  // TVM_EXTERN_C
// #endif
// #endif  // TVM_RUNTIME_C_RUNTIME_API_H_


// Parsed from tvm/runtime/data_type.h

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/*
 * \file tvm/runtime/data_type.h
 * \brief Primitive runtime data type.
 */
// Acknowledgement: DataType structure design originates from Halide.
// #ifndef TVM_RUNTIME_DATA_TYPE_H_
// #define TVM_RUNTIME_DATA_TYPE_H_

// #include <dmlc/logging.h>
// #include <tvm/runtime/c_runtime_api.h>

// #include <string>
// #include <type_traits>
// Targeting ../DataType.java



/**
 * \brief Get the number of bytes needed in a vector.
 * @param dtype The data type.
 * @return Number of bytes needed.
 */
@Namespace("tvm::runtime") public static native int GetVectorBytes(@ByVal DataType dtype);

/**
 * \brief Check whether type matches the given spec.
 * @param t The type
 * @param code The type code.
 * @param bits The number of bits to be matched.
 * @param lanes The number of lanes in the type.
 */
@Namespace("tvm::runtime") public static native @Cast("bool") boolean TypeMatch(@ByVal DLDataType t, int code, int bits, int lanes/*=1*/);
@Namespace("tvm::runtime") public static native @Cast("bool") boolean TypeMatch(@ByVal DLDataType t, int code, int bits);
/**
 * \brief Check whether two types are equal .
 * @param lhs The left operand.
 * @param rhs The right operand.
 */
@Namespace("tvm::runtime") public static native @Cast("bool") boolean TypeEqual(@ByVal DLDataType lhs, @ByVal DLDataType rhs);

/**
 * \brief Runtime utility for getting custom type name from code
 * @param type_code Custom type code
 * @return Custom type name
 */
@Namespace("tvm::runtime") public static native @StdString BytePointer GetCustomTypeName(@Cast("uint8_t") byte type_code);

/**
 * \brief Runtime utility for checking whether custom type is registered
 * @param type_code Custom type code
 * @return Bool representing whether type is registered
 */
@Namespace("tvm::runtime") public static native @Cast("bool") boolean GetCustomTypeRegistered(@Cast("uint8_t") byte type_code);

/**
 * \brief Runtime utility for parsing string of the form "custom[<typename>]"
 * @param s String to parse
 * @param scan pointer to parsing pointer, which is scanning across s
 * @return type code of custom type parsed
 */
@Namespace("tvm::runtime") public static native @Cast("uint8_t") byte ParseCustomDatatype(@StdString BytePointer s, @Cast("const char**") PointerPointer scan);
@Namespace("tvm::runtime") public static native @Cast("uint8_t") byte ParseCustomDatatype(@StdString BytePointer s, @Cast("const char**") @ByPtrPtr BytePointer scan);
@Namespace("tvm::runtime") public static native @Cast("uint8_t") byte ParseCustomDatatype(@StdString String s, @Cast("const char**") @ByPtrPtr ByteBuffer scan);
@Namespace("tvm::runtime") public static native @Cast("uint8_t") byte ParseCustomDatatype(@StdString BytePointer s, @Cast("const char**") @ByPtrPtr byte[] scan);
@Namespace("tvm::runtime") public static native @Cast("uint8_t") byte ParseCustomDatatype(@StdString String s, @Cast("const char**") @ByPtrPtr BytePointer scan);
@Namespace("tvm::runtime") public static native @Cast("uint8_t") byte ParseCustomDatatype(@StdString BytePointer s, @Cast("const char**") @ByPtrPtr ByteBuffer scan);
@Namespace("tvm::runtime") public static native @Cast("uint8_t") byte ParseCustomDatatype(@StdString String s, @Cast("const char**") @ByPtrPtr byte[] scan);

/**
 * \brief Convert type code to its name
 * @param type_code The type code .
 * @return The name of type code.
 */
@Namespace("tvm::runtime") public static native @Cast("const char*") BytePointer DLDataTypeCode2Str(@Cast("DLDataTypeCode") int type_code);

/**
 * \brief convert a string to TVM type.
 * @param s The string to be converted.
 * @return The corresponding tvm type.
 */
@Namespace("tvm::runtime") public static native @ByVal DLDataType String2DLDataType(@StdString BytePointer s);
@Namespace("tvm::runtime") public static native @ByVal DLDataType String2DLDataType(@StdString String s);

/**
 * \brief convert a TVM type to string.
 * @param t The type to be converted.
 * @return The corresponding tvm type in string.
 */
@Namespace("tvm::runtime") public static native @StdString BytePointer DLDataType2String(@ByVal DLDataType t);

// implementation details

@Namespace("tvm::runtime") public static native @Cast("std::ostream*") @ByRef @Name("operator <<") Pointer shiftLeft(@Cast("std::ostream*") @ByRef Pointer os, @ByVal DLDataType t);

@Namespace("tvm::runtime") public static native @Cast("std::ostream*") @ByRef @Name("operator <<") Pointer shiftLeft(@Cast("std::ostream*") @ByRef Pointer os, @Const @ByRef DataType dtype);

  // namespace runtime

  // namespace tvm
// #endif  //  TVM_RUNTIME_DATA_TYPE_H_


// Parsed from tvm/runtime/object.h

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 * \file tvm/runtime/object.h
 * \brief A managed object in the TVM runtime.
 */
// #ifndef TVM_RUNTIME_OBJECT_H_
// #define TVM_RUNTIME_OBJECT_H_

// #include <dmlc/logging.h>
// #include <tvm/runtime/c_runtime_api.h>

// #include <string>
// #include <type_traits>
// #include <utility>

/**
 * \brief Whether or not use atomic reference counter.
 *  If the reference counter is not atomic,
 *  an object cannot be owned by multiple threads.
 *  We can, however, move an object across threads
 */
// #ifndef TVM_OBJECT_ATOMIC_REF_COUNTER
public static final int TVM_OBJECT_ATOMIC_REF_COUNTER = 1;
// #endif

// #if TVM_OBJECT_ATOMIC_REF_COUNTER
// #include <atomic>
// #endif  // TVM_OBJECT_ATOMIC_REF_COUNTER
// Targeting ../TypeIndex.java


// Targeting ../TVMObject.java



/**
 * \brief Get a reference type from a raw object ptr type
 *
 *  It is always important to get a reference type
 *  if we want to return a value as reference or keep
 *  the object alive beyond the scope of the function.
 *
 * @param ptr The object pointer
 * \tparam RefType The reference type
 * \tparam ObjectType The object type
 * @return The corresponding RefType
 */

/**
 * \brief Downcast a base reference type to a more specific type.
 *
 * @param ref The inptut reference
 * @return The corresponding SubRef.
 * \tparam SubRef The target specific reference type.
 * \tparam BaseRef the current reference type.
 */
// Targeting ../ObjectPtr.java


// Targeting ../ArrayNodePtr.java


// Targeting ../ObjectRef.java



/**
 * \brief Get an object ptr type from a raw object ptr.
 *
 * @param ptr The object pointer
 * \tparam BaseType The reference type
 * \tparam ObjectType The object type
 * @return The corresponding RefType
 */
// Targeting ../ObjectPtrHash.java


// Targeting ../ObjectPtrEqual.java



/**
 * \brief helper macro to declare a base object type that can be inheritated.
 * @param TypeName The name of the current type.
 * @param ParentType The name of the ParentType
 */
// #define TVM_DECLARE_BASE_OBJECT_INFO(TypeName, ParentType)
//   static_assert(!ParentType::_type_final, "ParentObj maked as final");
//   static uint32_t RuntimeTypeIndex() {
//     static_assert(TypeName::_type_child_slots == 0 || ParentType::_type_child_slots == 0 ||
//                       TypeName::_type_child_slots < ParentType::_type_child_slots,
//                   "Need to set _type_child_slots when parent specifies it.");
//     if (TypeName::_type_index != ::tvm::runtime::TypeIndex::kDynamic) {
//       return TypeName::_type_index;
//     }
//     return _GetOrAllocRuntimeTypeIndex();
//   }
//   static uint32_t _GetOrAllocRuntimeTypeIndex() {
//     static uint32_t tidx = Object::GetOrAllocRuntimeTypeIndex(
//         TypeName::_type_key, TypeName::_type_index, ParentType::_GetOrAllocRuntimeTypeIndex(),
//         TypeName::_type_child_slots, TypeName::_type_child_slots_can_overflow);
//     return tidx;
//   }

/**
 * \brief helper macro to declare type information in a final class.
 * @param TypeName The name of the current type.
 * @param ParentType The name of the ParentType
 */
// #define TVM_DECLARE_FINAL_OBJECT_INFO(TypeName, ParentType)
//   static const constexpr bool _type_final = true;
//   static const constexpr int _type_child_slots = 0;
//   TVM_DECLARE_BASE_OBJECT_INFO(TypeName, ParentType)

/** \brief helper macro to supress unused warning */
// #if defined(__GNUC__)
// #define TVM_ATTRIBUTE_UNUSED __attribute__((unused))
// #else
// #define TVM_ATTRIBUTE_UNUSED
// #endif

// #define TVM_STR_CONCAT_(__x, __y) __x##__y
// #define TVM_STR_CONCAT(__x, __y) TVM_STR_CONCAT_(__x, __y)

// #define TVM_OBJECT_REG_VAR_DEF static TVM_ATTRIBUTE_UNUSED uint32_t __make_Object_tid

/**
 * \brief Helper macro to register the object type to runtime.
 *  Makes sure that the runtime type table is correctly populated.
 *
 *  Use this macro in the cc file for each terminal class.
 */
// #define TVM_REGISTER_OBJECT_TYPE(TypeName)
//   TVM_STR_CONCAT(TVM_OBJECT_REG_VAR_DEF, __COUNTER__) = TypeName::_GetOrAllocRuntimeTypeIndex()

/*
 * \brief Define the default copy/move constructor and assign opeator
 * \param TypeName The class typename.
 */
// #define TVM_DEFINE_DEFAULT_COPY_MOVE_AND_ASSIGN(TypeName)
//   TypeName(const TypeName& other) = default;
//   TypeName(TypeName&& other) = default;
//   TypeName& operator=(const TypeName& other) = default;
//   TypeName& operator=(TypeName&& other) = default;

/*
 * \brief Define object reference methods.
 * \param TypeName The object type name
 * \param ParentType The parent type of the objectref
 * \param ObjectName The type name of the object.
 */
// #define TVM_DEFINE_OBJECT_REF_METHODS(TypeName, ParentType, ObjectName)
//   TypeName() = default;
//   explicit TypeName(::tvm::runtime::ObjectPtr<::tvm::runtime::Object> n) : ParentType(n) {}
//   TVM_DEFINE_DEFAULT_COPY_MOVE_AND_ASSIGN(TypeName);
//   const ObjectName* operator->() const { return static_cast<const ObjectName*>(data_.get()); }
//   const ObjectName* get() const { return operator->(); }
//   using ContainerType = ObjectName;

/*
 * \brief Define object reference methods that is not nullable.
 *
 * \param TypeName The object type name
 * \param ParentType The parent type of the objectref
 * \param ObjectName The type name of the object.
 */
// #define TVM_DEFINE_NOTNULLABLE_OBJECT_REF_METHODS(TypeName, ParentType, ObjectName)
//   explicit TypeName(::tvm::runtime::ObjectPtr<::tvm::runtime::Object> n) : ParentType(n) {}
//   TVM_DEFINE_DEFAULT_COPY_MOVE_AND_ASSIGN(TypeName);
//   const ObjectName* operator->() const { return static_cast<const ObjectName*>(data_.get()); }
//   const ObjectName* get() const { return operator->(); }
//   static constexpr bool _type_is_nullable = false;
//   using ContainerType = ObjectName;

/*
 * \brief Define object reference methods of whose content is mutable.
 * \param TypeName The object type name
 * \param ParentType The parent type of the objectref
 * \param ObjectName The type name of the object.
 * \note We recommend making objects immutable when possible.
 *       This macro is only reserved for objects that stores runtime states.
 */
// #define TVM_DEFINE_MUTABLE_OBJECT_REF_METHODS(TypeName, ParentType, ObjectName)
//   TypeName() = default;
//   TVM_DEFINE_DEFAULT_COPY_MOVE_AND_ASSIGN(TypeName);
//   explicit TypeName(::tvm::runtime::ObjectPtr<::tvm::runtime::Object> n) : ParentType(n) {}
//   ObjectName* operator->() const { return static_cast<ObjectName*>(data_.get()); }
//   using ContainerType = ObjectName;

/**
 * \brief Define CopyOnWrite function in an ObjectRef.
 * @param ObjectName The Type of the Node.
 *
 *  CopyOnWrite will generate a unique copy of the internal node.
 *  The node will be copied if it is referenced by multiple places.
 *  The function returns the raw pointer to the node to allow modification
 *  of the content.
 *
 * <pre>{@code
 *
 *  MyCOWObjectRef ref, ref2;
 *  ref2 = ref;
 *  ref.CopyOnWrite()->value = new_value;
 *  assert(ref2->value == old_value);
 *  assert(ref->value == new_value);
 *
 * }</pre>
 */
// #define TVM_DEFINE_OBJECT_REF_COW_METHOD(ObjectName)
//   ObjectName* CopyOnWrite() {
//     CHECK(data_ != nullptr);
//     if (!data_.nique()) {
//       auto n = make_object<ObjectName>(*(operator->()));
//       ObjectPtr<Object>(std::move(n)).swap(data_);
//     }
//     return static_cast<ObjectName*>(data_.get());
//   }

// Implementations details below
// Object reference counting.
// #if TVM_OBJECT_ATOMIC_REF_COUNTER







// #else

// #endif  // TVM_OBJECT_ATOMIC_REF_COUNTER





  // namespace runtime
  // namespace tvm

// #endif  // TVM_RUNTIME_OBJECT_H_


// Parsed from tvm/runtime/memory.h

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
/**
 * \file tvm/runtime/memory.h
 * \brief Runtime memory management.
 */
// #ifndef TVM_RUNTIME_MEMORY_H_
// #define TVM_RUNTIME_MEMORY_H_

// #include <tvm/runtime/object.h>

// #include <cstdlib>
// #include <type_traits>
// #include <utility>
/**
 * \brief Allocate an object using default allocator.
 * @param args arguments to the constructor.
 * \tparam T the node type.
 * @return The ObjectPtr to the allocated object.
 */
@Namespace("tvm::runtime") public static native @ByVal @Name("make_object<tvm::runtime::ArrayNode>") ArrayNodePtr makeArrayNode();
// Targeting ../SimpleObjAllocatorBase.java


// Targeting ../SimpleObjAllocator.java



  // namespace runtime
  // namespace tvm
// #endif  // TVM_RUNTIME_MEMORY_H_


// Parsed from tvm/runtime/container.h

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * \file tvm/runtime/container.h
 * \brief Common POD(plain old data) container types.
 */
// #ifndef TVM_RUNTIME_CONTAINER_H_
// #define TVM_RUNTIME_CONTAINER_H_

// #include <dmlc/logging.h>
// #include <tvm/runtime/memory.h>
// #include <tvm/runtime/object.h>

// #include <algorithm>
// #include <cstring>
// #include <initializer_list>
// #include <memory>
// #include <string>
// #include <unordered_map>
// We use c++14 std::experimental::string_view for optimizing hash computation
// only right now, its usage is limited in this file. Any broader usage of
// std::experiment in our core codebase is discouraged and needs community
// discussion for each use case. Reference for feature test macros of
// string_view:
// https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations
// https://en.cppreference.com/w/User:D41D8CD98F/feature_testing_macros
// #if defined(__cpp_lib_experimental_string_view) && __cpp_lib_experimental_string_view >= 201411
public static final int TVM_USE_CXX14_STRING_VIEW_HASH = 1;
// #else
// #endif

// Tested with clang version 9.0.1 and c++17. It will detect string_view support
// correctly.
// #if defined(__cpp_lib_string_view) && __cpp_lib_string_view >= 201606
public static final int TVM_USE_CXX17_STRING_VIEW_HASH = 1;
// #else
// #endif

// #if TVM_USE_CXX17_STRING_VIEW_HASH
// #include <string_view>
// #elif TVM_USE_CXX14_STRING_VIEW_HASH
// #include <experimental/string_view>
// #endif

// #include <type_traits>
// #include <utility>
// #include <vector>
// String to llvm object compatibility.
  // namespace llvm

// Forward declare TVMArgValue
// Targeting ../ObjectHash.java


// Targeting ../ObjectEqual.java


// Targeting ../ADTObjBase.java


// Targeting ../ArrayNodeBase.java



/**
 * \brief iterator adapter that adapts TIter to return another type.
 * \tparam Converter a struct that contains converting function
 * \tparam TIter the content iterator type.
 */

/**
 * \brief iterator adapter that adapts TIter to return another type.
 * \tparam Converter a struct that contains converting function
 * \tparam TIter the content iterator type.
 */
// Targeting ../ArrayNode.java



/**
 * \brief Array, container representing a contigious sequence of ObjectRefs.
 *
 *  Array implements in-place copy-on-write semantics.
 *
 * As in typical copy-on-write, a method which would typically mutate the array
 * instead opaquely copies the underlying container, and then acts on its copy.
 *
 * If the array has reference count equal to one, we directly update the
 * container in place without copying. This is optimization is sound because
 * when the reference count is equal to one this reference is guranteed to be
 * the sole pointer to the container.
 *
 *
 * operator[] only provides const access, use Set to mutate the content.
 * \tparam T The content ObjectRef type.
 */

/**
 * \brief Concat two Arrays.
 * @param lhs first Array to be concatenated.
 * @param rhs second Array to be concatenated.
 * @return The concatenated Array. Original Arrays are kept unchanged.
 */

// Specialize make_object<ArrayNode> to make sure it is correct.
// Targeting ../ADTObj.java


// Targeting ../ADT.java


// Targeting ../StringObj.java


// Targeting ../TVMString.java



/** \brief An object representing string moved from std::string. */







@Namespace("tvm::runtime") public static native @ByVal @Name("operator +") TVMString add(@Const @ByRef TVMString lhs, @Const @ByRef TVMString rhs);

@Namespace("tvm::runtime") public static native @ByVal @Name("operator +") TVMString add(@Const @ByRef TVMString lhs, @StdString BytePointer rhs);
@Namespace("tvm::runtime") public static native @ByVal @Name("operator +") TVMString add(@Const @ByRef TVMString lhs, @StdString String rhs);

@Namespace("tvm::runtime") public static native @ByVal @Name("operator +") TVMString add(@StdString BytePointer lhs, @Const @ByRef TVMString rhs);
@Namespace("tvm::runtime") public static native @ByVal @Name("operator +") TVMString add(@StdString String lhs, @Const @ByRef TVMString rhs);

// Overload < operator
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator <") boolean lessThan(@Const @ByRef TVMString lhs, @StdString BytePointer rhs);
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator <") boolean lessThan(@Const @ByRef TVMString lhs, @StdString String rhs);

@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator <") boolean lessThan(@StdString BytePointer lhs, @Const @ByRef TVMString rhs);
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator <") boolean lessThan(@StdString String lhs, @Const @ByRef TVMString rhs);

@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator <") boolean lessThan(@Const @ByRef TVMString lhs, @Const @ByRef TVMString rhs);

// Overload > operator
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator >") boolean greaterThan(@Const @ByRef TVMString lhs, @StdString BytePointer rhs);
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator >") boolean greaterThan(@Const @ByRef TVMString lhs, @StdString String rhs);

@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator >") boolean greaterThan(@StdString BytePointer lhs, @Const @ByRef TVMString rhs);
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator >") boolean greaterThan(@StdString String lhs, @Const @ByRef TVMString rhs);

@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator >") boolean greaterThan(@Const @ByRef TVMString lhs, @Const @ByRef TVMString rhs);

// Overload <= operator
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator <=") boolean lessThanEquals(@Const @ByRef TVMString lhs, @StdString BytePointer rhs);
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator <=") boolean lessThanEquals(@Const @ByRef TVMString lhs, @StdString String rhs);

@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator <=") boolean lessThanEquals(@StdString BytePointer lhs, @Const @ByRef TVMString rhs);
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator <=") boolean lessThanEquals(@StdString String lhs, @Const @ByRef TVMString rhs);

@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator <=") boolean lessThanEquals(@Const @ByRef TVMString lhs, @Const @ByRef TVMString rhs);

// Overload >= operator
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator >=") boolean greaterThanEquals(@Const @ByRef TVMString lhs, @StdString BytePointer rhs);
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator >=") boolean greaterThanEquals(@Const @ByRef TVMString lhs, @StdString String rhs);

@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator >=") boolean greaterThanEquals(@StdString BytePointer lhs, @Const @ByRef TVMString rhs);
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator >=") boolean greaterThanEquals(@StdString String lhs, @Const @ByRef TVMString rhs);

@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator >=") boolean greaterThanEquals(@Const @ByRef TVMString lhs, @Const @ByRef TVMString rhs);

// Overload == operator
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef TVMString lhs, @StdString BytePointer rhs);
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef TVMString lhs, @StdString String rhs);

@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator ==") boolean equals(@StdString BytePointer lhs, @Const @ByRef TVMString rhs);
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator ==") boolean equals(@StdString String lhs, @Const @ByRef TVMString rhs);

@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef TVMString lhs, @Const @ByRef TVMString rhs);

// Overload != operator
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef TVMString lhs, @StdString BytePointer rhs);
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef TVMString lhs, @StdString String rhs);

@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator !=") boolean notEquals(@StdString BytePointer lhs, @Const @ByRef TVMString rhs);
@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator !=") boolean notEquals(@StdString String lhs, @Const @ByRef TVMString rhs);

@Namespace("tvm::runtime") public static native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef TVMString lhs, @Const @ByRef TVMString rhs);

@Namespace("tvm::runtime") public static native @Cast("std::ostream*") @ByRef @Name("operator <<") Pointer shiftLeft(@Cast("std::ostream*") @ByRef Pointer out, @Const @ByRef TVMString input);






// Targeting ../NullOptType.java



/**
 * \brief Optional container that to represent to a Nullable variant of T.
 * \tparam T The original ObjectRef.
 *
 * <pre>{@code
 *
 *  Optional<String> opt0 = nullptr;
 *  Optional<String> opt1 = String("xyz");
 *  CHECK(opt0 == nullptr);
 *  CHECK(opt1 == "xyz");
 *
 * }</pre>
 */
// Targeting ../ClosureObj.java


// Targeting ../Closure.java



  // namespace runtime

// expose the functions to the root namespace.
@Namespace("tvm") @MemberGetter public static native @Const @ByRef NullOptType NullOpt();
  // namespace tvm
  // namespace std

// #endif  // TVM_RUNTIME_CONTAINER_H_


// Parsed from tvm/runtime/ndarray.h

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * \file tvm/runtime/ndarray.h
 * \brief A device-independent managed NDArray abstraction.
 */
// #ifndef TVM_RUNTIME_NDARRAY_H_
// #define TVM_RUNTIME_NDARRAY_H_

// #include <tvm/runtime/c_runtime_api.h>
// #include <tvm/runtime/data_type.h>
// #include <tvm/runtime/object.h>
// #include <tvm/runtime/serializer.h>

// #include <atomic>
// #include <utility>
// #include <vector>
// Targeting ../NDArray.java



/**
 * \brief Save a DLTensor to stream
 * @param strm The output stream
 * @param tensor The tensor to be saved.
 */
@Namespace("tvm::runtime") public static native @Cast("bool") boolean SaveDLTensor(Stream strm, @Const DLTensor tensor);
// Targeting ../ContainerBase.java


// Targeting ../Container.java



// implementations of inline functions
/**
 * \brief return the size of data the DLTensor hold, in term of number of bytes
 *
 *  @param arr the input DLTensor
 *  @return number of  bytes of data in the DLTensor.
 */
@Namespace("tvm::runtime") public static native @Cast("size_t") long GetDataSize(@Const @ByRef DLTensor arr);

/**
 * \brief check if a DLTensor is contiguous.
 * @param arr The input DLTensor.
 * @return The check result.
 */
@Namespace("tvm::runtime") public static native @Cast("bool") boolean IsContiguous(@Const @ByRef DLTensor arr);

























@Namespace("tvm::runtime") public static native TVMObject TVMArrayHandleToObjectHandle(@Cast("TVMArrayHandle") DLTensor handle);

/** \brief Magic number for NDArray file */
@Namespace("tvm::runtime") @MemberGetter public static native @Cast("const uint64_t") long kTVMNDArrayMagic();





  // namespace runtime
  // namespace tvm
// #endif  // TVM_RUNTIME_NDARRAY_H_


// Parsed from tvm/runtime/serializer.h

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * \file tvm/runtime/serializer.h
 * \brief Serializer extension to support TVM data types
 *  Include this file to enable serialization of DLDataType, DLContext
 */
// #ifndef TVM_RUNTIME_SERIALIZER_H_
// #define TVM_RUNTIME_SERIALIZER_H_

// #include <dmlc/io.h>
// #include <dmlc/serializer.h>
// #include <tvm/runtime/c_runtime_api.h>
// #include <tvm/runtime/ndarray.h>
// Targeting ../Handler.java



  // namespace serializer
  // namespace dmlc
// #endif  // TVM_RUNTIME_SERIALIZER_H_


// Parsed from tvm/runtime/module.h

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * \file tvm/runtime/module.h
 * \brief Runtime container of the functions generated by TVM,
 *  This is used to support dynamically link, load and save
 *  functions from different convention under unified API.
 */
// #ifndef TVM_RUNTIME_MODULE_H_
// #define TVM_RUNTIME_MODULE_H_

// #include <dmlc/io.h>
// #include <tvm/runtime/c_runtime_api.h>
// #include <tvm/runtime/memory.h>
// #include <tvm/runtime/object.h>

// #include <memory>
// #include <string>
// #include <unordered_map>
// #include <vector>
// Targeting ../Module.java


// Targeting ../ModuleNode.java



/**
 * \brief Check if runtime module is enabled for target.
 * @param target The target module name.
 * @return Whether runtime is enabled.
 */
@Namespace("tvm::runtime") public static native @Cast("bool") boolean RuntimeEnabled(@StdString BytePointer target);
@Namespace("tvm::runtime") public static native @Cast("bool") boolean RuntimeEnabled(@StdString String target);

/** \brief namespace for constant symbols */
/** \brief Global variable to store module context. */
@Namespace("tvm::runtime::symbol") @MemberGetter public static native @Cast("const char*") BytePointer tvm_module_ctx();
/** \brief Global variable to store device module blob */
@Namespace("tvm::runtime::symbol") @MemberGetter public static native @Cast("const char*") BytePointer tvm_dev_mblob();
/** \brief Number of bytes of device module blob. */
@Namespace("tvm::runtime::symbol") @MemberGetter public static native @Cast("const char*") BytePointer tvm_dev_mblob_nbytes();
/** \brief global function to set device */
@Namespace("tvm::runtime::symbol") @MemberGetter public static native @Cast("const char*") BytePointer tvm_set_device();
/** \brief Auxiliary counter to global barrier. */
@Namespace("tvm::runtime::symbol") @MemberGetter public static native @Cast("const char*") BytePointer tvm_global_barrier_state();
/** \brief Prepare the global barrier before kernels that uses global barrier. */
@Namespace("tvm::runtime::symbol") @MemberGetter public static native @Cast("const char*") BytePointer tvm_prepare_global_barrier();
/** \brief Placeholder for the module's entry function. */
@Namespace("tvm::runtime::symbol") @MemberGetter public static native @Cast("const char*") BytePointer tvm_module_main();
  // namespace symbol

// implementations of inline functions.







  // namespace runtime
  // namespace tvm

// #include <tvm/runtime/packed_func.h>  // NOLINT(*)
// #endif                                // TVM_RUNTIME_MODULE_H_


// Parsed from tvm/runtime/packed_func.h

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * \file tvm/runtime/packed_func.h
 * \brief Type-erased function used across TVM API.
 */
// #ifndef TVM_RUNTIME_PACKED_FUNC_H_
// #define TVM_RUNTIME_PACKED_FUNC_H_

// #include <dmlc/logging.h>
// #include <tvm/runtime/c_runtime_api.h>
// #include <tvm/runtime/container.h>
// #include <tvm/runtime/data_type.h>
// #include <tvm/runtime/module.h>
// #include <tvm/runtime/ndarray.h>
// #include <tvm/runtime/object.h>

// #include <functional>
// #include <limits>
// #include <memory>
// #include <string>
// #include <tuple>
// #include <type_traits>
// #include <utility>
// #include <vector>

// Whether use TVM runtime in header only mode.
// #ifndef TVM_RUNTIME_HEADER_ONLY
public static final int TVM_RUNTIME_HEADER_ONLY = 0;
// #endif

// Always inline macro only use in template
// expansion cases where we know inline is important.
// #ifdef _MSC_VER
// #else
// #define TVM_ALWAYS_INLINE inline __attribute__((always_inline))
// #endif

// forward declarations
// Targeting ../PackedFunc.java



/**
 * \brief Please refer to \ref TypedPackedFuncAnchor "TypedPackedFunc<R(Args..)>"
 */

/**
 * \anchor TypedPackedFuncAnchor
 * \brief A PackedFunc wrapper to provide typed function signature.
 * It is backed by a PackedFunc internally.
 *
 * TypedPackedFunc enables compile time type checking.
 * TypedPackedFunc works with the runtime system:
 * - It can be passed as an argument of PackedFunc.
 * - It can be assigned to TVMRetValue.
 * - It can be directly converted to a type-erased PackedFunc.
 *
 * Developers should prefer TypedPackedFunc over PackedFunc in C++ code
 * as it enables compile time checking.
 * We can construct a TypedPackedFunc from a lambda function
 * with the same signature.
 *
 * <pre>{@code
 *  // user defined lambda function.
 *  auto addone = [](int x)->int {
 *    return x + 1;
 *  };
 *  // We can directly convert
 *  // lambda function to TypedPackedFunc
 *  TypedPackedFunc<int(int)> ftyped(addone);
 *  // invoke the function.
 *  int y = ftyped(1);
 *  // Can be directly converted to PackedFunc
 *  PackedFunc packed = ftype;
 * }</pre>
 * \tparam R The return value of the function.
 * \tparam Args The argument signature of the function.
 */
// Targeting ../TVMArgs.java



/**
 * \brief Convert argument type code to string.
 * @param type_code The input type code.
 * @return The corresponding string repr.
 */
@Namespace("tvm::runtime") public static native @Cast("const char*") BytePointer ArgTypeCode2Str(int type_code);

// macro to check type code.
// #define TVM_CHECK_TYPE_CODE(CODE, T)
//   CHECK_EQ(CODE, T) << " expected " << ArgTypeCode2Str(T) << " but get " << ArgTypeCode2Str(CODE)

/**
 * \brief Type traits for runtime type check during FFI conversion.
 * \tparam T the type to be checked.
 */
// Targeting ../TVMPODValue_.java


// Targeting ../TVMArgValue.java


// Targeting ../TVMMovableArgValue_.java


// Targeting ../TVMRetValue.java



/**
 * \brief Type trait to specify special value conversion rules from
 *        TVMArgValue and TVMRetValue.
 *
 *  The trait can be specialized to add type specific conversion logic
 *  from the TVMArgvalue and TVMRetValue.
 *
 * \tparam TObjectRef the specific ObjectRefType.
 */

/**
 * \brief Export a function with the PackedFunc signature
 *        as a PackedFunc that can be loaded by LibraryModule.
 *
 * @param ExportName The symbol name to be exported.
 * @param Function The function with PackedFunc signature.
 * @see PackedFunc
 *
 * <pre>{@code
 *
 * void AddOne_(TVMArgs args, TVMRetValue* rv) {
 *   int value = args[0];
 *   *rv = value + 1;
 * }
 * // Expose the function as "AddOne"
 * TVM_DLL_EXPORT_PACKED_FUNC(AddOne, AddOne_);
 *
 * }</pre>
 */
// #define TVM_DLL_EXPORT_PACKED_FUNC(ExportName, Function)
//   extern "C" {
//   TVM_DLL int ExportName(TVMValue* args, int* type_code, int num_args, TVMValue* out_value,
//                          int* out_type_code);
//   int ExportName(TVMValue* args, int* type_code, int num_args, TVMValue* out_value,
//                  int* out_type_code) {
//     try {
//       ::tvm::runtime::TVMRetValue rv;
//       Function(::tvm::runtime::TVMArgs(args, type_code, num_args), &rv);
//       rv.MoveToCHost(out_value, out_type_code);
//       return 0;
//     } catch (const ::std::runtime_error& _except_) {
//       TVMAPISetLastError(_except_.what());
//       return -1;
//     }
//   }
//   }

/**
 * \brief Export typed function as a PackedFunc
 *        that can be loaded by LibraryModule.
 *
 * @param ExportName The symbol name to be exported.
 * @param Function The typed function.
 * \note ExportName and Function must be different,
 *       see code examples below.
 *
 * @see TypedPackedFunc
 *
 * <pre>{@code
 *
 * int AddOne_(int x) {
 *   return x + 1;
 * }
 *
 * // Expose the function as "AddOne"
 * TVM_DLL_EXPORT_TYPED_FUNC(AddOne, AddOne_);
 *
 * // Expose the function as "SubOne"
 * TVM_DLL_EXPORT_TYPED_FUNC(SubOne, [](int x) {
 *   return x - 1;
 * });
 *
 * // The following code will cause compilation error.
 * // Because the same Function and ExortName
 * // TVM_DLL_EXPORT_TYPED_FUNC(AddOne_, AddOne_);
 *
 * // The following code is OK, assuming the macro
 * // is in a different namespace from xyz
 * // TVM_DLL_EXPORT_TYPED_FUNC(AddOne_, xyz::AddOne_);
 *
 * }</pre>
 */
// #define TVM_DLL_EXPORT_TYPED_FUNC(ExportName, Function)
//   extern "C" {
//   TVM_DLL int ExportName(TVMValue* args, int* type_code, int num_args, TVMValue* out_value,
//                          int* out_type_code) {
//     try {
//       auto f = Function;
//       using FType = ::tvm::runtime::detail::function_signature<decltype(f)>::FType;
//       ::tvm::runtime::TVMRetValue rv;
//       ::tvm::runtime::detail::unpack_call_by_signature<FType>::run(
//           f, ::tvm::runtime::TVMArgs(args, type_code, num_args), &rv);
//       rv.MoveToCHost(out_value, out_type_code);
//       return 0;
//     } catch (const ::std::runtime_error& _except_) {
//       TVMAPISetLastError(_except_.what());
//       return -1;
//     }
//   }
//   }









// internal namespace

/**
 * \brief template class to get function signature of a function or functor.
 * \tparam T The funtion/functor type.
 */

// handle case of function.

// handle case of function ptr.

// Targeting ../TVMArgsSetter.java




// Targeting ../typed_packed_call_dispatcher.java


  // namespace detail













// ObjectRef related conversion handling
// Object can have three possible type codes:
//      kTVMNDArrayHandle, kTVMModuleHandle, kTVMObjectHandle
//
// We use type traits to eliminate un-necessary checks.















// Targeting ../PackedFuncValueConverter.java









  // namespace runtime
  // namespace tvm
// #endif  // TVM_RUNTIME_PACKED_FUNC_H_


// Parsed from tvm/runtime/registry.h

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * \file tvm/runtime/registry.h
 * \brief This file defines the TVM global function registry.
 *
 *  The registered functions will be made available to front-end
 *  as well as backend users.
 *
 *  The registry stores type-erased functions.
 *  Each registered function is automatically exposed
 *  to front-end language(e.g. python).
 *
 *  Front-end can also pass callbacks as PackedFunc, or register
 *  then into the same global registry in C++.
 *  The goal is to mix the front-end language and the TVM back-end.
 *
 * <pre>{@code
 *   // register the function as MyAPIFuncName
 *   TVM_REGISTER_GLOBAL(MyAPIFuncName)
 *   .set_body([](TVMArgs args, TVMRetValue* rv) {
 *     // my code.
 *   });
 * }</pre>
 */
// #ifndef TVM_RUNTIME_REGISTRY_H_
// #define TVM_RUNTIME_REGISTRY_H_

// #include <tvm/runtime/packed_func.h>

// #include <string>
// #include <utility>
// #include <vector>
// Targeting ../Registry.java



// #define TVM_FUNC_REG_VAR_DEF static TVM_ATTRIBUTE_UNUSED ::tvm::runtime::Registry& __mk_##TVM

/**
 * \brief Register a function globally.
 * <pre>{@code
 *   TVM_REGISTER_GLOBAL("MyPrint")
 *   .set_body([](TVMArgs args, TVMRetValue* rv) {
 *   });
 * }</pre>
 */
// #define TVM_REGISTER_GLOBAL(OpName)
//   TVM_STR_CONCAT(TVM_FUNC_REG_VAR_DEF, __COUNTER__) = ::tvm::runtime::Registry::Register(OpName)

// #define TVM_STRINGIZE_DETAIL(x) #x
// #define TVM_STRINGIZE(x) TVM_STRINGIZE_DETAIL(x)
// #define TVM_DESCRIBE(...) describe(__VA_ARGS__ "\n\nFrom:" __FILE__ ":" TVM_STRINGIZE(__LINE__))
/**
 * \brief Macro to include current line as string
 */
// #define TVM_ADD_FILELINE "\n\nDefined in " __FILE__ ":L" TVM_STRINGIZE(__LINE__)

  // namespace runtime
  // namespace tvm
// #endif  // TVM_RUNTIME_REGISTRY_H_


}
