// Targeted by JavaCPP version 1.4.4: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class liquidfun extends org.bytedeco.javacpp.presets.liquidfun {
    static { Loader.load(); }

// Parsed from <Box2D/Common/b2Settings.h>

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
* Copyright (c) 2013 Google, Inc.
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_SETTINGS_H
// #define B2_SETTINGS_H

// #include <stddef.h>
// #include <assert.h>
// #include <float.h>

// #define B2_NOT_USED(x) ((void)(x))
// #if DEBUG && !defined(NDEBUG)
// #define b2Assert(A) assert(A)
public static final int B2_ASSERT_ENABLED = 1;
// #else
// #define b2Assert(A)
// #endif

// Statement which is compiled out when DEBUG isn't defined.
// #if DEBUG
// #define B2_DEBUG_STATEMENT(A) A
// #else
// #define B2_DEBUG_STATEMENT(A)
// #endif  // DEBUG

// Calculate the size of a static array.
// #define B2_ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

// #ifdef WIN32
// #else // !WIN32
// #endif

// #define	b2_maxFloat		FLT_MAX
// #define	b2_epsilon		FLT_EPSILON
public static final double b2_pi =			3.14159265359f;

// #if !defined(b2Inline)
// #if defined(__GNUC__)
// #define b2Inline __attribute__((always_inline))
// #else
// #define b2Inline inline
// #endif // defined(__GNUC__)
// #endif // !defined(b2Inline)

// We expand the API so that other languages (e.g. Java) can call into
// our C++ more easily. Only set if when the flag is not externally defined.
// #if !defined(LIQUIDFUN_EXTERNAL_LANGUAGE_API)
// #if SWIG || LIQUIDFUN_UNIT_TESTS
public static final int LIQUIDFUN_EXTERNAL_LANGUAGE_API = 1;
// #else
// #endif
// #endif

/** \file
 *  Global tuning constants based on meters-kilograms-seconds (MKS) units.
 *  */

// Collision

/** The maximum number of contact points between two convex shapes. Do
/** not change this value. */
public static final int b2_maxManifoldPoints =	2;

/** The maximum number of vertices on a convex polygon. You cannot increase
 *  this too much because b2BlockAllocator has a maximum object size. */
public static final int b2_maxPolygonVertices =	8;

/** This is used to fatten AABBs in the dynamic tree. This allows proxies
 *  to move by a small amount without triggering a tree adjustment.
 *  This is in meters. */
public static final double b2_aabbExtension =		0.1f;

/** This is used to fatten AABBs in the dynamic tree. This is used to predict
 *  the future position based on the current displacement.
 *  This is a dimensionless multiplier. */
public static final double b2_aabbMultiplier =		2.0f;

/** A small length used as a collision and constraint tolerance. Usually it is
 *  chosen to be numerically significant, but visually insignificant. */
public static final double b2_linearSlop =			0.005f;

/** A small angle used as a collision and constraint tolerance. Usually it is
 *  chosen to be numerically significant, but visually insignificant. */
public static final double b2_angularSlop =			(2.0f / 180.0f * b2_pi);

/** The radius of the polygon/edge shape skin. This should not be modified. Making
 *  this smaller means polygons will have an insufficient buffer for continuous collision.
 *  Making it larger may create artifacts for vertex collision. */
public static final double b2_polygonRadius =		(2.0f * b2_linearSlop);

/** Maximum number of sub-steps per contact in continuous physics simulation. */
public static final int b2_maxSubSteps =			8;


// Dynamics

/** Maximum number of contacts to be handled to solve a TOI impact. */
public static final int b2_maxTOIContacts =			32;

/** A velocity threshold for elastic collisions. Any collision with a relative linear
 *  velocity below this threshold will be treated as inelastic. */
public static final double b2_velocityThreshold =		1.0f;

/** The maximum linear position correction used when solving constraints. This helps to
 *  prevent overshoot. */
public static final double b2_maxLinearCorrection =		0.2f;

/** The maximum angular position correction used when solving constraints. This helps to
 *  prevent overshoot. */
public static final double b2_maxAngularCorrection =		(8.0f / 180.0f * b2_pi);

/** The maximum linear velocity of a body. This limit is very large and is used
 *  to prevent numerical problems. You shouldn't need to adjust this. */
public static final double b2_maxTranslation =			2.0f;
// #define b2_maxTranslationSquared	(b2_maxTranslation * b2_maxTranslation)

/** The maximum angular velocity of a body. This limit is very large and is used
 *  to prevent numerical problems. You shouldn't need to adjust this. */
public static final double b2_maxRotation =				(0.5f * b2_pi);
// #define b2_maxRotationSquared		(b2_maxRotation * b2_maxRotation)

/** This scale factor controls how fast overlap is resolved. Ideally this would be 1 so
 *  that overlap is removed in one time step. However using values close to 1 often lead
 *  to overshoot. */
public static final double b2_baumgarte =				0.2f;
public static final double b2_toiBaugarte =				0.75f;


// Particle

/** NEON SIMD requires 16-bit particle indices */
// #if !defined(B2_USE_16_BIT_PARTICLE_INDICES) && defined(LIQUIDFUN_SIMD_NEON)
// #define B2_USE_16_BIT_PARTICLE_INDICES
// #endif

/** A symbolic constant that stands for particle allocation error. */
public static final int b2_invalidParticleIndex =		(-1);

// #ifdef B2_USE_16_BIT_PARTICLE_INDICES
// #else
public static final int b2_maxParticleIndex =			0x7FFFFFFF;
// #endif

/** The default distance between particles, multiplied by the particle diameter. */
public static final double b2_particleStride =			0.75f;

/** The minimum particle weight that produces pressure. */
public static final double b2_minParticleWeight =			1.0f;

/** The upper limit for particle pressure. */
public static final double b2_maxParticlePressure =		0.25f;

/** The upper limit for force between particles. */
public static final double b2_maxParticleForce =		0.5f;

/** The maximum distance between particles in a triad, multiplied by the
 *  particle diameter. */
public static final int b2_maxTriadDistance =			2;
public static final int b2_maxTriadDistanceSquared =		(b2_maxTriadDistance * b2_maxTriadDistance);

/** The initial size of particle data buffers. */
public static final int b2_minParticleSystemBufferCapacity =	256;

/** The time into the future that collisions against barrier particles will be detected. */
public static final double b2_barrierCollisionTime = 2.5f;

// Sleep

/** The time that a body must be still before it will go to sleep. */
public static final double b2_timeToSleep =				0.5f;

/** A body cannot sleep if its linear velocity is above this tolerance. */
public static final double b2_linearSleepTolerance =		0.01f;

/** A body cannot sleep if its angular velocity is above this tolerance. */
public static final double b2_angularSleepTolerance =	(2.0f / 180.0f * b2_pi);

// Memory Allocation

/** Implement this function to use your own memory allocator. */
public static native Pointer b2Alloc(@Cast("int32") int size);

/** If you implement b2Alloc, you should also implement this function. */
public static native void b2Free(Pointer mem);

/** Use this function to override b2Alloc() without recompiling this library. */
public static class b2AllocFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    b2AllocFunction(Pointer p) { super(p); }
    protected b2AllocFunction() { allocate(); }
    private native void allocate();
    public native Pointer call(@Cast("int32") int size, Pointer callbackData);
}
/** Use this function to override b2Free() without recompiling this library. */
public static class b2FreeFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    b2FreeFunction(Pointer p) { super(p); }
    protected b2FreeFunction() { allocate(); }
    private native void allocate();
    public native void call(Pointer mem, Pointer callbackData);
}

/** Set alloc and free callbacks to override the default behavior of using
 *  malloc() and free() for dynamic memory allocation.
 *  Set allocCallback and freeCallback to NULL to restore the default
 *  allocator (malloc / free). */
public static native void b2SetAllocFreeCallbacks(b2AllocFunction allocCallback,
							 b2FreeFunction freeCallback,
							 Pointer callbackData);

/** Set the number of calls to b2Alloc minus the number of calls to b2Free.
 *  This can be used to disable the empty heap check in
 *  b2SetAllocFreeCallbacks() which can be useful for testing. */
public static native void b2SetNumAllocs(@Cast("const int32") int numAllocs);

/** Get number of calls to b2Alloc minus number of calls to b2Free. */
public static native @Cast("int32") int b2GetNumAllocs();

/** Logging function. */
public static native void b2Log(@Cast("const char*") BytePointer string);
public static native void b2Log(String string);

/** Version numbering scheme.
 *  See http://en.wikipedia.org/wiki/Software_versioning */
public static class b2Version extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2Version() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Version(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Version(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2Version position(long position) {
        return (b2Version)super.position(position);
    }

	/** significant changes */
	public native @Cast("int32") int major(); public native b2Version major(int major);
	/** incremental changes */
	public native @Cast("int32") int minor(); public native b2Version minor(int minor);
	/** bug fixes */
	public native @Cast("int32") int revision(); public native b2Version revision(int revision);
}

/** Current version.
 *  Version of Box2D, LiquidFun is based upon. */
public static native @ByRef b2Version b2_version(); public static native void b2_version(b2Version b2_version);

/** Global variable is used to identify the version of LiquidFun. */
@MemberGetter public static native @Const @ByRef b2Version b2_liquidFunVersion();
/** String which identifies the current version of LiquidFun.
 *  b2_liquidFunVersionString is used by Google developers to identify which
 *  applications uploaded to Google Play are using this library.  This allows
 *  the development team at Google to determine the popularity of the library.
 *  How it works: Applications that are uploaded to the Google Play Store are
 *  scanned for this version string.  We track which applications are using it
 *  to measure popularity.  You are free to remove it (of course) but we would
 *  appreciate if you left it in. */
@MemberGetter public static native @Cast("const char*") BytePointer b2_liquidFunVersionString();

// #endif


// Parsed from <Box2D/Common/b2Math.h>

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_MATH_H
// #define B2_MATH_H

// #include <Box2D/Common/b2Settings.h>
// #include <math.h>

/** This function is used to ensure that a floating point number is not a NaN or infinity. */
public static native @Cast("bool") boolean b2IsValid(@Cast("float32") float x);

/** This is a approximate yet fast inverse square-root. */
public static native @Cast("float32") float b2InvSqrt(@Cast("float32") float x);

// #define	b2Sqrt(x)	sqrtf(x)
// #define	b2Atan2(y, x)	atan2f(y, x)

/** A 2D column vector. */
@NoOffset public static class b2Vec2 extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Vec2(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Vec2(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2Vec2 position(long position) {
        return (b2Vec2)super.position(position);
    }

	/** Default constructor does nothing (for performance). */
	public b2Vec2() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Construct using coordinates. */
	public b2Vec2(@Cast("float32") float x, @Cast("float32") float y) { super((Pointer)null); allocate(x, y); }
	private native void allocate(@Cast("float32") float x, @Cast("float32") float y);

	/** Set this vector to all zeros. */
	public native void SetZero();

	/** Set this vector to some specified coordinates. */
	public native void Set(@Cast("float32") float x_, @Cast("float32") float y_);

	/** Negate this vector. */
	public native @ByVal @Name("operator -") b2Vec2 subtract();

	/** Read from and indexed element. */

	/** Write to an indexed element. */
	public native @Cast("float32*") @ByRef @Name("operator ()") FloatPointer apply(@Cast("int32") int i);

	/** Add a vector to this vector. */
	public native @Name("operator +=") void addPut(@Const @ByRef b2Vec2 v);

	/** Subtract a vector from this vector. */
	public native @Name("operator -=") void subtractPut(@Const @ByRef b2Vec2 v);

	/** Multiply this vector by a scalar. */
	public native @Name("operator *=") void multiplyPut(@Cast("float32") float a);

	/** Get the length of this vector (the norm). */
	public native @Cast("float32") float Length();

	/** Get the length squared. For performance, use this instead of
	 *  b2Vec2::Length (if possible). */
	public native @Cast("float32") float LengthSquared();

	/** Convert this vector into a unit vector. Returns the length. */
	public native @Cast("float32") float Normalize();

	/** Does this vector contain finite coordinates? */
	public native @Cast("bool") boolean IsValid();

	/** Get the skew vector such that dot(skew_vec, other) == cross(vec, other) */
	public native @ByVal b2Vec2 Skew();

	public native @Cast("float32") float x(); public native b2Vec2 x(float x);
	public native @Cast("float32") float y(); public native b2Vec2 y(float y);
}

/** Add a float to a vector. */
public static native @ByVal @Name("operator +") b2Vec2 add(@Const @ByRef b2Vec2 v, float f);

/** Substract a float from a vector. */
public static native @ByVal @Name("operator -") b2Vec2 subtract(@Const @ByRef b2Vec2 v, float f);

/** Multiply a float with a vector. */
public static native @ByVal @Name("operator *") b2Vec2 multiply(@Const @ByRef b2Vec2 v, float f);

/** Divide a vector by a float. */
public static native @ByVal @Name("operator /") b2Vec2 divide(@Const @ByRef b2Vec2 v, float f);

/** A 3D column vector with 3 elements. */
@NoOffset public static class b2Vec3 extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Vec3(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Vec3(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2Vec3 position(long position) {
        return (b2Vec3)super.position(position);
    }

	/** Default constructor does nothing (for performance). */
	public b2Vec3() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Construct using coordinates. */
	public b2Vec3(@Cast("float32") float x, @Cast("float32") float y, @Cast("float32") float z) { super((Pointer)null); allocate(x, y, z); }
	private native void allocate(@Cast("float32") float x, @Cast("float32") float y, @Cast("float32") float z);

	/** Set this vector to all zeros. */
	public native void SetZero();

	/** Set this vector to some specified coordinates. */
	public native void Set(@Cast("float32") float x_, @Cast("float32") float y_, @Cast("float32") float z_);

	/** Negate this vector. */
	public native @ByVal @Name("operator -") b2Vec3 subtract();

	/** Add a vector to this vector. */
	public native @Name("operator +=") void addPut(@Const @ByRef b2Vec3 v);

	/** Subtract a vector from this vector. */
	public native @Name("operator -=") void subtractPut(@Const @ByRef b2Vec3 v);

	/** Multiply this vector by a scalar. */
	public native @Name("operator *=") void multiplyPut(@Cast("float32") float s);

		/** Get the length of this vector (the norm). */
	public native @Cast("float32") float Length();

	/** Convert this vector into a unit vector. Returns the length. */
	public native @Cast("float32") float Normalize();

	public native @Cast("float32") float x(); public native b2Vec3 x(float x);
	public native @Cast("float32") float y(); public native b2Vec3 y(float y);
	public native @Cast("float32") float z(); public native b2Vec3 z(float z);
}

/** A 4D column vector with 4 elements. */
@NoOffset public static class b2Vec4 extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Vec4(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Vec4(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2Vec4 position(long position) {
        return (b2Vec4)super.position(position);
    }

	/** Default constructor does nothing (for performance). */
	public b2Vec4() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Construct using coordinates. */
	public b2Vec4(@Cast("float32") float x, @Cast("float32") float y, @Cast("float32") float z, @Cast("float32") float w) { super((Pointer)null); allocate(x, y, z, w); }
	private native void allocate(@Cast("float32") float x, @Cast("float32") float y, @Cast("float32") float z, @Cast("float32") float w);

	public native @Cast("float32") float x(); public native b2Vec4 x(float x);
	public native @Cast("float32") float y(); public native b2Vec4 y(float y);
	public native @Cast("float32") float z(); public native b2Vec4 z(float z);
	public native @Cast("float32") float w(); public native b2Vec4 w(float w);
}

/** A 2-by-2 matrix. Stored in column-major order. */
@NoOffset public static class b2Mat22 extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Mat22(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Mat22(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2Mat22 position(long position) {
        return (b2Mat22)super.position(position);
    }

	/** The default constructor does nothing (for performance). */
	public b2Mat22() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Construct this matrix using columns. */
	public b2Mat22(@Const @ByRef b2Vec2 c1, @Const @ByRef b2Vec2 c2) { super((Pointer)null); allocate(c1, c2); }
	private native void allocate(@Const @ByRef b2Vec2 c1, @Const @ByRef b2Vec2 c2);

	/** Construct this matrix using scalars. */
	public b2Mat22(@Cast("float32") float a11, @Cast("float32") float a12, @Cast("float32") float a21, @Cast("float32") float a22) { super((Pointer)null); allocate(a11, a12, a21, a22); }
	private native void allocate(@Cast("float32") float a11, @Cast("float32") float a12, @Cast("float32") float a21, @Cast("float32") float a22);

	/** Initialize this matrix using columns. */
	public native void Set(@Const @ByRef b2Vec2 c1, @Const @ByRef b2Vec2 c2);

	/** Set this to the identity matrix. */
	public native void SetIdentity();

	/** Set this matrix to all zeros. */
	public native void SetZero();

	public native @ByVal b2Mat22 GetInverse();

	/** Solve A * x = b, where b is a column vector. This is more efficient
	 *  than computing the inverse in one-shot cases. */
	public native @ByVal b2Vec2 Solve(@Const @ByRef b2Vec2 b);

	public native @ByRef b2Vec2 ex(); public native b2Mat22 ex(b2Vec2 ex);
	public native @ByRef b2Vec2 ey(); public native b2Mat22 ey(b2Vec2 ey);
}

/** A 3-by-3 matrix. Stored in column-major order. */
@NoOffset public static class b2Mat33 extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Mat33(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Mat33(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2Mat33 position(long position) {
        return (b2Mat33)super.position(position);
    }

	/** The default constructor does nothing (for performance). */
	public b2Mat33() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Construct this matrix using columns. */
	public b2Mat33(@Const @ByRef b2Vec3 c1, @Const @ByRef b2Vec3 c2, @Const @ByRef b2Vec3 c3) { super((Pointer)null); allocate(c1, c2, c3); }
	private native void allocate(@Const @ByRef b2Vec3 c1, @Const @ByRef b2Vec3 c2, @Const @ByRef b2Vec3 c3);

	/** Set this matrix to all zeros. */
	public native void SetZero();

	/** Solve A * x = b, where b is a column vector. This is more efficient
	 *  than computing the inverse in one-shot cases. */
	public native @ByVal b2Vec3 Solve33(@Const @ByRef b2Vec3 b);

	/** Solve A * x = b, where b is a column vector. This is more efficient
	 *  than computing the inverse in one-shot cases. Solve only the upper
	 *  2-by-2 matrix equation. */
	public native @ByVal b2Vec2 Solve22(@Const @ByRef b2Vec2 b);

	/** Get the inverse of this matrix as a 2-by-2.
	 *  Returns the zero matrix if singular. */
	public native void GetInverse22(b2Mat33 M);

	/** Get the symmetric inverse of this matrix as a 3-by-3.
	 *  Returns the zero matrix if singular. */
	public native void GetSymInverse33(b2Mat33 M);

	public native @ByRef b2Vec3 ex(); public native b2Mat33 ex(b2Vec3 ex);
	public native @ByRef b2Vec3 ey(); public native b2Mat33 ey(b2Vec3 ey);
	public native @ByRef b2Vec3 ez(); public native b2Mat33 ez(b2Vec3 ez);
}

/** Rotation */
@NoOffset public static class b2Rot extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Rot(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Rot(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2Rot position(long position) {
        return (b2Rot)super.position(position);
    }

	public b2Rot() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Initialize from an angle in radians */
	public b2Rot(@Cast("float32") float angle) { super((Pointer)null); allocate(angle); }
	private native void allocate(@Cast("float32") float angle);

	/** Set using an angle in radians. */
	public native void Set(@Cast("float32") float angle);

	/** Set to the identity rotation */
	public native void SetIdentity();

	/** Get the angle in radians */
	public native @Cast("float32") float GetAngle();

	/** Get the x-axis */
	public native @ByVal b2Vec2 GetXAxis();

	/** Get the u-axis */
	public native @ByVal b2Vec2 GetYAxis();

	/** Sine and cosine */
	public native @Cast("float32") float s(); public native b2Rot s(float s);
	public native @Cast("float32") float c(); public native b2Rot c(float c);
}

/** A transform contains translation and rotation. It is used to represent
 *  the position and orientation of rigid frames. */
@NoOffset public static class b2Transform extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Transform(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Transform(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2Transform position(long position) {
        return (b2Transform)super.position(position);
    }

	/** The default constructor does nothing. */
	public b2Transform() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Initialize using a position vector and a rotation. */
	public b2Transform(@Const @ByRef b2Vec2 position, @Const @ByRef b2Rot rotation) { super((Pointer)null); allocate(position, rotation); }
	private native void allocate(@Const @ByRef b2Vec2 position, @Const @ByRef b2Rot rotation);

	/** Set this to the identity transform. */
	public native void SetIdentity();

	/** Set this based on the position and angle. */
	public native void Set(@Const @ByRef b2Vec2 position, @Cast("float32") float angle);

// #if LIQUIDFUN_EXTERNAL_LANGUAGE_API
	/** Get x-coordinate of p. */
	public native @Cast("float32") float GetPositionX();

	/** Get y-coordinate of p. */
	public native @Cast("float32") float GetPositionY();

	/** Get sine-component of q. */
	public native @Cast("float32") float GetRotationSin();

	/** Get cosine-component of q. */
	public native @Cast("float32") float GetRotationCos();
// #endif // LIQUIDFUN_EXTERNAL_LANGUAGE_API

	public native @ByRef b2Vec2 p(); public native b2Transform p(b2Vec2 p);
	public native @ByRef b2Rot q(); public native b2Transform q(b2Rot q);
}

/** This describes the motion of a body/shape for TOI computation.
 *  Shapes are defined with respect to the body origin, which may
 *  no coincide with the center of mass. However, to support dynamics
 *  we must interpolate the center of mass position. */
public static class b2Sweep extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2Sweep() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Sweep(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Sweep(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2Sweep position(long position) {
        return (b2Sweep)super.position(position);
    }

	/** Get the interpolated transform at a specific time.
	 *  @param beta is a factor in [0,1], where 0 indicates alpha0. */
	public native void GetTransform(b2Transform xfb, @Cast("float32") float beta);

	/** Advance the sweep forward, yielding a new initial state.
	 *  @param alpha the new initial time. */
	public native void Advance(@Cast("float32") float alpha);

	/** Normalize the angles. */
	public native void Normalize();

	/** local center of mass position */
	public native @ByRef b2Vec2 localCenter(); public native b2Sweep localCenter(b2Vec2 localCenter);
	/** center world positions */
	public native @ByRef b2Vec2 c0(); public native b2Sweep c0(b2Vec2 c0);
	public native @ByRef b2Vec2 c(); public native b2Sweep c(b2Vec2 c);
	/** world angles */
	public native @Cast("float32") float a0(); public native b2Sweep a0(float a0);
	public native @Cast("float32") float a(); public native b2Sweep a(float a);

	/** Fraction of the current time step in the range [0,1]
	 *  c0 and a0 are the positions at alpha0. */
	public native @Cast("float32") float alpha0(); public native b2Sweep alpha0(float alpha0);
}

/** Useful constant */
@MemberGetter public static native @Const @ByRef b2Vec2 b2Vec2_zero();

/** Perform the dot product on two vectors. */
public static native @Cast("float32") float b2Dot(@Const @ByRef b2Vec2 a, @Const @ByRef b2Vec2 b);

/** Perform the cross product on two vectors. In 2D this produces a scalar. */
public static native @Cast("float32") float b2Cross(@Const @ByRef b2Vec2 a, @Const @ByRef b2Vec2 b);

/** Perform the cross product on a vector and a scalar. In 2D this produces
 *  a vector. */
public static native @ByVal b2Vec2 b2Cross(@Const @ByRef b2Vec2 a, @Cast("float32") float s);

/** Perform the cross product on a scalar and a vector. In 2D this produces
 *  a vector. */
public static native @ByVal b2Vec2 b2Cross(@Cast("float32") float s, @Const @ByRef b2Vec2 a);

/** Multiply a matrix times a vector. If a rotation matrix is provided,
 *  then this transforms the vector from one frame to another. */
public static native @ByVal b2Vec2 b2Mul(@Const @ByRef b2Mat22 A, @Const @ByRef b2Vec2 v);

/** Multiply a matrix transpose times a vector. If a rotation matrix is provided,
 *  then this transforms the vector from one frame to another (inverse transform). */
public static native @ByVal b2Vec2 b2MulT(@Const @ByRef b2Mat22 A, @Const @ByRef b2Vec2 v);

/** Add two vectors component-wise. */
public static native @ByVal @Name("operator +") b2Vec2 add(@Const @ByRef b2Vec2 a, @Const @ByRef b2Vec2 b);

/** Subtract two vectors component-wise. */
public static native @ByVal @Name("operator -") b2Vec2 subtract(@Const @ByRef b2Vec2 a, @Const @ByRef b2Vec2 b);

public static native @ByVal @Name("operator *") b2Vec2 multiply(@Cast("float32") float s, @Const @ByRef b2Vec2 a);

public static native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef b2Vec2 a, @Const @ByRef b2Vec2 b);

public static native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef b2Vec2 a, @Const @ByRef b2Vec2 b);

public static native @Cast("float32") float b2Distance(@Const @ByRef b2Vec2 a, @Const @ByRef b2Vec2 b);

public static native @Cast("float32") float b2DistanceSquared(@Const @ByRef b2Vec2 a, @Const @ByRef b2Vec2 b);

public static native @ByVal @Name("operator *") b2Vec3 multiply(@Cast("float32") float s, @Const @ByRef b2Vec3 a);

/** Add two vectors component-wise. */
public static native @ByVal @Name("operator +") b2Vec3 add(@Const @ByRef b2Vec3 a, @Const @ByRef b2Vec3 b);

/** Subtract two vectors component-wise. */
public static native @ByVal @Name("operator -") b2Vec3 subtract(@Const @ByRef b2Vec3 a, @Const @ByRef b2Vec3 b);

/** Perform the dot product on two vectors. */
public static native @Cast("float32") float b2Dot(@Const @ByRef b2Vec3 a, @Const @ByRef b2Vec3 b);

/** Perform the cross product on two vectors. */
public static native @ByVal b2Vec3 b2Cross(@Const @ByRef b2Vec3 a, @Const @ByRef b2Vec3 b);

public static native @ByVal @Name("operator +") b2Mat22 add(@Const @ByRef b2Mat22 A, @Const @ByRef b2Mat22 B);

// A * B
public static native @ByVal b2Mat22 b2Mul(@Const @ByRef b2Mat22 A, @Const @ByRef b2Mat22 B);

// A^T * B
public static native @ByVal b2Mat22 b2MulT(@Const @ByRef b2Mat22 A, @Const @ByRef b2Mat22 B);

/** Multiply a matrix times a vector. */
public static native @ByVal b2Vec3 b2Mul(@Const @ByRef b2Mat33 A, @Const @ByRef b2Vec3 v);

/** Multiply a matrix times a vector. */
public static native @ByVal b2Vec2 b2Mul22(@Const @ByRef b2Mat33 A, @Const @ByRef b2Vec2 v);

/** Multiply two rotations: q * r */
public static native @ByVal b2Rot b2Mul(@Const @ByRef b2Rot q, @Const @ByRef b2Rot r);

/** Transpose multiply two rotations: qT * r */
public static native @ByVal b2Rot b2MulT(@Const @ByRef b2Rot q, @Const @ByRef b2Rot r);

/** Rotate a vector */
public static native @ByVal b2Vec2 b2Mul(@Const @ByRef b2Rot q, @Const @ByRef b2Vec2 v);

/** Inverse rotate a vector */
public static native @ByVal b2Vec2 b2MulT(@Const @ByRef b2Rot q, @Const @ByRef b2Vec2 v);

public static native @ByVal b2Vec2 b2Mul(@Const @ByRef b2Transform T, @Const @ByRef b2Vec2 v);

public static native @ByVal b2Vec2 b2MulT(@Const @ByRef b2Transform T, @Const @ByRef b2Vec2 v);

// v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
//    = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
public static native @ByVal b2Transform b2Mul(@Const @ByRef b2Transform A, @Const @ByRef b2Transform B);

// v2 = A.q' * (B.q * v1 + B.p - A.p)
//    = A.q' * B.q * v1 + A.q' * (B.p - A.p)
public static native @ByVal b2Transform b2MulT(@Const @ByRef b2Transform A, @Const @ByRef b2Transform B);

public static native @ByVal b2Vec2 b2Abs(@Const @ByRef b2Vec2 a);

public static native @ByVal b2Mat22 b2Abs(@Const @ByRef b2Mat22 A);

public static native @ByVal b2Vec2 b2Min(@Const @ByRef b2Vec2 a, @Const @ByRef b2Vec2 b);

public static native @ByVal b2Vec2 b2Max(@Const @ByRef b2Vec2 a, @Const @ByRef b2Vec2 b);

public static native @ByVal b2Vec2 b2Clamp(@Const @ByRef b2Vec2 a, @Const @ByRef b2Vec2 low, @Const @ByRef b2Vec2 high);

/** "Next Largest Power of 2
 *  Given a binary integer value x, the next largest power of 2 can be computed by a SWAR algorithm
 *  that recursively "folds" the upper bits into the lower bits. This process yields a bit vector with
 *  the same most significant 1 as x, but all 1's below it. Adding 1 to that value yields the next
 *  largest power of 2. For a 32-bit value:" */
public static native @Cast("uint32") long b2NextPowerOfTwo(@Cast("uint32") long x);

public static native @Cast("bool") boolean b2IsPowerOfTwo(@Cast("uint32") long x);





/** Normalize an angle in radians to be between -pi and pi */


// #endif


// Parsed from <Box2D/Common/b2Draw.h>

/*
* Copyright (c) 2011 Erin Catto http://box2d.org
* Copyright (c) 2014 Google, Inc.
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_DRAW_H
// #define B2_DRAW_H

// #include <Box2D/Common/b2Math.h>
// #include <Box2D/Particle/b2Particle.h>

/** Color for debug drawing. Each value has the range [0,1]. */
@NoOffset public static class b2Color extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Color(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Color(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2Color position(long position) {
        return (b2Color)super.position(position);
    }

	public b2Color() { super((Pointer)null); allocate(); }
	private native void allocate();
	public b2Color(@Cast("float32") float r, @Cast("float32") float g, @Cast("float32") float b) { super((Pointer)null); allocate(r, g, b); }
	private native void allocate(@Cast("float32") float r, @Cast("float32") float g, @Cast("float32") float b);
	public native void Set(@Cast("float32") float ri, @Cast("float32") float gi, @Cast("float32") float bi);
	public native @Cast("float32") float r(); public native b2Color r(float r);
	public native @Cast("float32") float g(); public native b2Color g(float g);
	public native @Cast("float32") float b(); public native b2Color b(float b);
}

/** Implement and register this class with a b2World to provide debug drawing of physics
 *  entities in your game. */
@NoOffset public static class b2Draw extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Draw(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Draw(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2Draw position(long position) {
        return (b2Draw)super.position(position);
    }


	/** enum b2Draw:: */
	public static final int
		/** draw shapes */
		e_shapeBit				 = 0x0001,
		/** draw joint connections */
		e_jointBit				 = 0x0002,
		/** draw axis aligned bounding boxes */
		e_aabbBit				 = 0x0004,
		/** draw broad-phase pairs */
		e_pairBit				 = 0x0008,
		/** draw center of mass frame */
		e_centerOfMassBit			 = 0x0010,
		/** draw particles */
		e_particleBit				 = 0x0020;

	/** Set the drawing flags. */
	public native void SetFlags(@Cast("uint32") long flags);

	/** Get the drawing flags. */
	public native @Cast("uint32") long GetFlags();

	/** Append flags to the current flags. */
	public native void AppendFlags(@Cast("uint32") long flags);

	/** Clear flags from the current flags. */
	public native void ClearFlags(@Cast("uint32") long flags);

	/** Draw a closed polygon provided in CCW order. */
	@Virtual(true) public native void DrawPolygon(@Const b2Vec2 vertices, @Cast("int32") int vertexCount, @Const @ByRef b2Color color);

	/** Draw a solid closed polygon provided in CCW order. */
	@Virtual(true) public native void DrawSolidPolygon(@Const b2Vec2 vertices, @Cast("int32") int vertexCount, @Const @ByRef b2Color color);

	/** Draw a circle. */
	@Virtual(true) public native void DrawCircle(@Const @ByRef b2Vec2 center, @Cast("float32") float radius, @Const @ByRef b2Color color);

	/** Draw a solid circle. */
	@Virtual(true) public native void DrawSolidCircle(@Const @ByRef b2Vec2 center, @Cast("float32") float radius, @Const @ByRef b2Vec2 axis, @Const @ByRef b2Color color);

	/** Draw a particle array */
	@Virtual(true) public native void DrawParticles(@Const b2Vec2 centers, @Cast("float32") float radius, @Const b2ParticleColor colors, @Cast("int32") int count);

	/** Draw a line segment. */
	@Virtual(true) public native void DrawSegment(@Const @ByRef b2Vec2 p1, @Const @ByRef b2Vec2 p2, @Const @ByRef b2Color color);

	/** Draw a transform. Choose your own length scale.
	 *  @param xf a transform. */
	@Virtual(true) public native void DrawTransform(@Const @ByRef b2Transform xf);
}

// #endif


// Parsed from <Box2D/Common/b2IntrusiveList.h>

/*
* Copyright (c) 2014 Google, Inc.
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/
// #ifndef B2_INTRUSIVE_LIST
// #define B2_INTRUSIVE_LIST

// #include <Box2D/Common/b2Settings.h>

// Whether to enable b2IntrusiveList::ValidateList().
// Be careful when enabling this since this changes the size of
// b2IntrusiveListNode so make sure *all* projects that include Box2D.h
// also define this value in the same way to avoid data corruption.
// #ifndef B2_INTRUSIVE_LIST_VALIDATE

///
///
///
public static final int B2_INTRUSIVE_LIST_VALIDATE = 0;
// #endif  // B2_INTRUSIVE_LIST_VALIDATE

/** b2IntrusiveListNode is used to implement an intrusive doubly-linked
 *  list.
 * 
 *  For example:
 * 
 *  class MyClass {
 *  public:
 *  	MyClass(const char *msg) : m_msg(msg) {}
 *  	const char* GetMessage() const { return m_msg; }
 *  	B2_INTRUSIVE_LIST_GET_NODE(m_node);
 *  	B2_INTRUSIVE_LIST_NODE_GET_CLASS(MyClass, m_node);
 *  private:
 *  	b2IntrusiveListNode m_node;
 *  	const char *m_msg;
 *  };
 * 
 *  int main(int argc, char *argv[]) {
 *  	b2IntrusiveListNode list; // NOTE: type is NOT MyClass
 *  	MyClass a("this");
 *  	MyClass b("is");
 *  	MyClass c("a");
 *  	MyClass d("test");
 *  	list.InsertBefore(a.GetListNode());
 *  	list.InsertBefore(b.GetListNode());
 *  	list.InsertBefore(c.GetListNode());
 *  	list.InsertBefore(d.GetListNode());
 *  	for (b2IntrusiveListNode* node = list.GetNext();
 *  		 node != list.GetTerminator(); node = node->GetNext()) {
 *  		MyClass *cls = MyClass::GetInstanceFromListNode(node);
 *  		printf("%s\n", cls->GetMessage());
 *  	}
 *  	return 0;
 *  } */
@NoOffset public static class b2IntrusiveListNode extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2IntrusiveListNode(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2IntrusiveListNode(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2IntrusiveListNode position(long position) {
        return (b2IntrusiveListNode)super.position(position);
    }

	/** Initialize the node. */
	public b2IntrusiveListNode() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** If the node is in a list, remove it from the list. */

	/** Insert this node after the specified node. */
	public native void InsertAfter(b2IntrusiveListNode node);

	/** Insert this node before the specified node. */
	public native void InsertBefore(b2IntrusiveListNode node);

	/** Get the terminator of the list. */
	public native @Const b2IntrusiveListNode GetTerminator();

	/** Remove this node from the list it's currently in. */
	public native b2IntrusiveListNode Remove();

	/** Determine whether this list is empty or the node isn't in a list. */
	public native @Cast("bool") boolean IsEmpty();

	/** Determine whether this node is in a list or the list contains nodes. */
	public native @Cast("bool") boolean InList();

	/** Calculate the length of the list. */
	public native @Cast("uint32") long GetLength();

	/** Get the next node in the list. */
	public native b2IntrusiveListNode GetNext();

	/** Get the previous node in the list. */
	public native b2IntrusiveListNode GetPrevious();

	/** If B2_INTRUSIVE_LIST_VALIDATE is 1 perform a very rough validation
	 *  of all nodes in the list. */
	public native @Cast("bool") boolean ValidateList();

	/** Determine whether the specified node is present in this list. */
	public native @Cast("bool") boolean FindNodeInList(b2IntrusiveListNode nodeToFind);
}

/** Declares the member function GetListNode() of Class to retrieve a pointer
 *  to NodeMemberName.
 *  See #B2_INTRUSIVE_LIST_NODE_GET_CLASS_ACCESSOR() */
// #define B2_INTRUSIVE_LIST_GET_NODE(NodeMemberName)
// 	b2IntrusiveListNode* GetListNode() { return &NodeMemberName; }
// 	const b2IntrusiveListNode* GetListNode() const { return &NodeMemberName; }

/** Declares the member function FunctionName of Class to retrieve a pointer
 *  to a Class instance from a list node pointer.   NodeMemberName references
 *  the name of the b2IntrusiveListNode member of Class. */
// #define B2_INTRUSIVE_LIST_NODE_GET_CLASS_ACCESSOR(
// 	Class, NodeMemberName, FunctionName)
// 	static Class* FunctionName(b2IntrusiveListNode *node)
// 	{
// 		Class *cls = NULL;
// 		/* This effectively performs offsetof(Class, NodeMemberName) */
// 		/* which ends up in the undefined behavior realm of C++ but in */
// 		/* practice this works with most compilers. */
// 		return reinterpret_cast<Class*>((uint8*)(node) -
// 										(uint8*)(&cls->NodeMemberName));
// 	}
// 
// 	static const Class* FunctionName(const b2IntrusiveListNode *node)
// 	{
// 		return FunctionName(const_cast<b2IntrusiveListNode*>(node));
// 	}

/** Declares the member function GetInstanceFromListNode() of Class to retrieve
 *  a pointer to a Class instance from a list node pointer.  NodeMemberName
 *  reference the name of the b2IntrusiveListNode member of Class. */

///
///
///
// #define B2_INTRUSIVE_LIST_NODE_GET_CLASS(Class, NodeMemberName)
// 	B2_INTRUSIVE_LIST_NODE_GET_CLASS_ACCESSOR(Class, NodeMemberName,
// 											  GetInstanceFromListNode)

/** b2TypedIntrusiveListNode which supports inserting an object into a single
 *  doubly linked list.  For objects that need to be inserted in multiple
 *  doubly linked lists, use b2IntrusiveListNode.
 * 
 *  For example:
 * 
 *  class IntegerItem : public b2TypedIntrusiveListNode<IntegerItem>
 *  {
 *  public:
 *  	IntegerItem(int32 value) : m_value(value) { }
 *  	~IntegerItem() { }
 *  	int32 GetValue() const { return m_value; }
 *  private:
 *  	int32 m_value;
 *  };
 * 
 *  int main(int argc, const char *arvg[]) {
 *  	b2TypedIntrusiveListNode<IntegerItem> list;
 *  	IntegerItem a(1);
 *  	IntegerItem b(2);
 *  	IntegerItem c(3);
 *  	list.InsertBefore(&a);
 *  	list.InsertBefore(&b);
 *  	list.InsertBefore(&c);
 *  	for (IntegerItem* item = list.GetNext();
 *  		 item != list.GetTerminator(); item = item->GetNext())
 *  	{
 *  		printf("%d\n", item->GetValue());
 *  	}
 *  } */
@Name("b2TypedIntrusiveListNode<b2ParticleHandle>") @NoOffset public static class ParticleHandleListNode extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ParticleHandleListNode(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ParticleHandleListNode(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ParticleHandleListNode position(long position) {
        return (ParticleHandleListNode)super.position(position);
    }

	public ParticleHandleListNode() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Insert this object after the specified object. */
	public native void InsertAfter(b2ParticleHandle obj);

	/** Insert this object before the specified object. */
	public native void InsertBefore(b2ParticleHandle obj);

	/** Get the next object in the list.
	 *  Check against GetTerminator() before deferencing the object. */
	public native b2ParticleHandle GetNext();

	/** Get the previous object in the list.
	 *  Check against GetTerminator() before deferencing the object. */
	public native b2ParticleHandle GetPrevious();

	/** Get the terminator of the list.
	 *  This should not be dereferenced as it is a pointer to
	 *  b2TypedIntrusiveListNode<T> *not* T. */
	public native b2ParticleHandle GetTerminator();

	/** Remove this object from the list it's currently in. */
	public native b2ParticleHandle Remove();

	/** Determine whether this object is in a list. */
	public native @Cast("bool") boolean InList();

	// Determine whether this list is empty.
	public native @Cast("bool") boolean IsEmpty();

	/** Calculate the length of the list. */
	public native @Cast("uint32") long GetLength();

	public native b2IntrusiveListNode GetListNode();
	/** Get a pointer to the instance of T that contains "node". */
	public static native b2ParticleHandle GetInstanceFromListNode(b2IntrusiveListNode node);
}

// #endif // B2_INTRUSIVE_LIST



// Parsed from <Box2D/Collision/Shapes/b2Shape.h>

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
* Copyright (c) 2013 Google, Inc.
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_SHAPE_H
// #define B2_SHAPE_H

// #include <Box2D/Common/b2BlockAllocator.h>
// #include <Box2D/Common/b2Math.h>
// #include <Box2D/Collision/b2Collision.h>

/** This holds the mass data computed for a shape. */
public static class b2MassData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2MassData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2MassData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2MassData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2MassData position(long position) {
        return (b2MassData)super.position(position);
    }

	/** The mass of the shape, usually in kilograms. */
	public native @Cast("float32") float mass(); public native b2MassData mass(float mass);

	/** The position of the shape's centroid relative to the shape's origin. */
	public native @ByRef b2Vec2 center(); public native b2MassData center(b2Vec2 center);

	/** The rotational inertia of the shape about the local origin. */
	public native @Cast("float32") float I(); public native b2MassData I(float I);
}

/** A shape is used for collision detection. You can create a shape however you like.
 *  Shapes used for simulation in b2World are created automatically when a b2Fixture
 *  is created. Shapes may encapsulate a one or more child shapes. */
public static class b2Shape extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Shape(Pointer p) { super(p); }

	
	/** enum b2Shape::Type */
	public static final int
		e_circle = 0,
		e_edge = 1,
		e_polygon = 2,
		e_chain = 3,
		e_typeCount = 4;

	/** Clone the concrete shape using the provided allocator. */
	public native b2Shape Clone(b2BlockAllocator allocator);

	/** Get the type of this shape. You can use this to down cast to the concrete shape.
	 *  @return the shape type. */
	public native @Cast("b2Shape::Type") int GetType();

	/** Get the number of child primitives. */
	public native @Cast("int32") int GetChildCount();

	/** Test a point for containment in this shape. This only works for convex shapes.
	 *  @param xf the shape world transform.
	 *  @param p a point in world coordinates. */
	public native @Cast("bool") boolean TestPoint(@Const @ByRef b2Transform xf, @Const @ByRef b2Vec2 p);

	/** Compute the distance from the current shape to the specified point. This only works for convex shapes.
	 *  @param xf the shape world transform.
	 *  @param p a point in world coordinates.
	 *  @param distance returns the distance from the current shape.
	 *  @param normal returns the direction in which the distance increases. */
	public native void ComputeDistance(@Const @ByRef b2Transform xf, @Const @ByRef b2Vec2 p, @Cast("float32*") FloatPointer distance, b2Vec2 normal, @Cast("int32") int childIndex);
	public native void ComputeDistance(@Const @ByRef b2Transform xf, @Const @ByRef b2Vec2 p, @Cast("float32*") FloatBuffer distance, b2Vec2 normal, @Cast("int32") int childIndex);
	public native void ComputeDistance(@Const @ByRef b2Transform xf, @Const @ByRef b2Vec2 p, @Cast("float32*") float[] distance, b2Vec2 normal, @Cast("int32") int childIndex);

	/** Cast a ray against a child shape.
	 *  @param output the ray-cast results.
	 *  @param input the ray-cast input parameters.
	 *  @param transform the transform to be applied to the shape.
	 *  @param childIndex the child shape index */
	public native @Cast("bool") boolean RayCast(b2RayCastOutput output, @Const @ByRef b2RayCastInput input,
							@Const @ByRef b2Transform transform, @Cast("int32") int childIndex);

	/** Given a transform, compute the associated axis aligned bounding box for a child shape.
	 *  @param aabb returns the axis aligned box.
	 *  @param xf the world transform of the shape.
	 *  @param childIndex the child shape */
	public native void ComputeAABB(b2AABB aabb, @Const @ByRef b2Transform xf, @Cast("int32") int childIndex);

	/** Compute the mass properties of this shape using its dimensions and density.
	 *  The inertia tensor is computed about the local origin.
	 *  @param massData returns the mass data for this shape.
	 *  @param density the density in kilograms per meter squared. */
	public native void ComputeMass(b2MassData massData, @Cast("float32") float density);

	public native @Cast("b2Shape::Type") int m_type(); public native b2Shape m_type(int m_type);
	public native @Cast("float32") float m_radius(); public native b2Shape m_radius(float m_radius);
}



// #endif


// Parsed from <Box2D/Collision/Shapes/b2CircleShape.h>

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
* Copyright (c) 2013 Google, Inc.
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_CIRCLE_SHAPE_H
// #define B2_CIRCLE_SHAPE_H

// #include <Box2D/Collision/Shapes/b2Shape.h>

/** A circle shape. */
@NoOffset public static class b2CircleShape extends b2Shape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2CircleShape(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2CircleShape(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2CircleShape position(long position) {
        return (b2CircleShape)super.position(position);
    }

	public b2CircleShape() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Implement b2Shape. */
	public native b2Shape Clone(b2BlockAllocator allocator);

	/** @see b2Shape::GetChildCount */
	public native @Cast("int32") int GetChildCount();

	/** Implement b2Shape. */
	public native @Cast("bool") boolean TestPoint(@Const @ByRef b2Transform transform, @Const @ByRef b2Vec2 p);

	// @see b2Shape::ComputeDistance
	public native void ComputeDistance(@Const @ByRef b2Transform xf, @Const @ByRef b2Vec2 p, @Cast("float32*") FloatPointer distance, b2Vec2 normal, @Cast("int32") int childIndex);
	public native void ComputeDistance(@Const @ByRef b2Transform xf, @Const @ByRef b2Vec2 p, @Cast("float32*") FloatBuffer distance, b2Vec2 normal, @Cast("int32") int childIndex);
	public native void ComputeDistance(@Const @ByRef b2Transform xf, @Const @ByRef b2Vec2 p, @Cast("float32*") float[] distance, b2Vec2 normal, @Cast("int32") int childIndex);

	/** Implement b2Shape. */
	public native @Cast("bool") boolean RayCast(b2RayCastOutput output, @Const @ByRef b2RayCastInput input,
					@Const @ByRef b2Transform transform, @Cast("int32") int childIndex);

	/** @see b2Shape::ComputeAABB */
	public native void ComputeAABB(b2AABB aabb, @Const @ByRef b2Transform transform, @Cast("int32") int childIndex);

	/** @see b2Shape::ComputeMass */
	public native void ComputeMass(b2MassData massData, @Cast("float32") float density);

	/** Get the supporting vertex index in the given direction. */
	public native @Cast("int32") int GetSupport(@Const @ByRef b2Vec2 d);

	/** Get the supporting vertex in the given direction. */
	public native @Const @ByRef b2Vec2 GetSupportVertex(@Const @ByRef b2Vec2 d);

	/** Get the vertex count. */
	public native @Cast("int32") int GetVertexCount();

	/** Get a vertex by index. Used by b2Distance. */
	public native @Const @ByRef b2Vec2 GetVertex(@Cast("int32") int index);
	/** Set position with direct floats. */
	public native void SetPosition(@Cast("float32") float x, @Cast("float32") float y);

	/** Get x-coordinate of position. */
	public native @Cast("float32") float GetPositionX();

	/** Get y-coordinate of position. */
	public native @Cast("float32") float GetPositionY();
// #endif // LIQUIDFUN_EXTERNAL_LANGUAGE_API

	/** Position */
	public native @ByRef b2Vec2 m_p(); public native b2CircleShape m_p(b2Vec2 m_p);
}









// #endif


// Parsed from <Box2D/Collision/Shapes/b2EdgeShape.h>

/*
* Copyright (c) 2006-2010 Erin Catto http://www.box2d.org
* Copyright (c) 2013 Google, Inc.
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_EDGE_SHAPE_H
// #define B2_EDGE_SHAPE_H

// #include <Box2D/Collision/Shapes/b2Shape.h>

/** A line segment (edge) shape. These can be connected in chains or loops
 *  to other edge shapes. The connectivity information is used to ensure
 *  correct contact normals. */
@NoOffset public static class b2EdgeShape extends b2Shape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2EdgeShape(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2EdgeShape(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2EdgeShape position(long position) {
        return (b2EdgeShape)super.position(position);
    }

	public b2EdgeShape() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Set this as an isolated edge. */
	public native void Set(@Const @ByRef b2Vec2 v1, @Const @ByRef b2Vec2 v2);

	/** Implement b2Shape. */
	public native b2Shape Clone(b2BlockAllocator allocator);

	/** @see b2Shape::GetChildCount */
	public native @Cast("int32") int GetChildCount();

	/** @see b2Shape::TestPoint */
	public native @Cast("bool") boolean TestPoint(@Const @ByRef b2Transform transform, @Const @ByRef b2Vec2 p);

	// @see b2Shape::ComputeDistance
	public native void ComputeDistance(@Const @ByRef b2Transform xf, @Const @ByRef b2Vec2 p, @Cast("float32*") FloatPointer distance, b2Vec2 normal, @Cast("int32") int childIndex);
	public native void ComputeDistance(@Const @ByRef b2Transform xf, @Const @ByRef b2Vec2 p, @Cast("float32*") FloatBuffer distance, b2Vec2 normal, @Cast("int32") int childIndex);
	public native void ComputeDistance(@Const @ByRef b2Transform xf, @Const @ByRef b2Vec2 p, @Cast("float32*") float[] distance, b2Vec2 normal, @Cast("int32") int childIndex);

	/** Implement b2Shape. */
	public native @Cast("bool") boolean RayCast(b2RayCastOutput output, @Const @ByRef b2RayCastInput input,
					@Const @ByRef b2Transform transform, @Cast("int32") int childIndex);

	/** @see b2Shape::ComputeAABB */
	public native void ComputeAABB(b2AABB aabb, @Const @ByRef b2Transform transform, @Cast("int32") int childIndex);

	/** @see b2Shape::ComputeMass */
	public native void ComputeMass(b2MassData massData, @Cast("float32") float density);
	/** Set this as an isolated edge, with direct floats. */
	public native void Set(@Cast("float32") float vx1, @Cast("float32") float vy1, @Cast("float32") float vx2, @Cast("float32") float vy2);
// #endif // LIQUIDFUN_EXTERNAL_LANGUAGE_API

	/** These are the edge vertices */
	public native @ByRef b2Vec2 m_vertex1(); public native b2EdgeShape m_vertex1(b2Vec2 m_vertex1);
	public native @ByRef b2Vec2 m_vertex2(); public native b2EdgeShape m_vertex2(b2Vec2 m_vertex2);

	/** Optional adjacent vertices. These are used for smooth collision. */
	public native @ByRef b2Vec2 m_vertex0(); public native b2EdgeShape m_vertex0(b2Vec2 m_vertex0);
	public native @ByRef b2Vec2 m_vertex3(); public native b2EdgeShape m_vertex3(b2Vec2 m_vertex3);
	public native @Cast("bool") boolean m_hasVertex0(); public native b2EdgeShape m_hasVertex0(boolean m_hasVertex0);
	public native @Cast("bool") boolean m_hasVertex3(); public native b2EdgeShape m_hasVertex3(boolean m_hasVertex3);
}



// #if LIQUIDFUN_EXTERNAL_LANGUAGE_API

// #endif // LIQUIDFUN_EXTERNAL_LANGUAGE_API


// #endif


// Parsed from <Box2D/Collision/Shapes/b2ChainShape.h>

/*
* Copyright (c) 2006-2010 Erin Catto http://www.box2d.org
* Copyright (c) 2013 Google, Inc.
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_CHAIN_SHAPE_H
// #define B2_CHAIN_SHAPE_H

// #include <Box2D/Collision/Shapes/b2Shape.h>

/** A chain shape is a free form sequence of line segments.
 *  The chain has two-sided collision, so you can use inside and outside collision.
 *  Therefore, you may use any winding order.
 *  Since there may be many vertices, they are allocated using b2Alloc.
 *  Connectivity information is used to create smooth collisions.
 *  WARNING: The chain will not collide properly if there are self-intersections. */
@NoOffset public static class b2ChainShape extends b2Shape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ChainShape(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ChainShape(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2ChainShape position(long position) {
        return (b2ChainShape)super.position(position);
    }

	public b2ChainShape() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** The destructor frees the vertices using b2Free. */

	/** Create a loop. This automatically adjusts connectivity.
	 *  @param vertices an array of vertices, these are copied
	 *  @param count the vertex count */
	public native void CreateLoop(@Const b2Vec2 vertices, @Cast("int32") int count);

	/** Create a chain with isolated end vertices.
	 *  @param vertices an array of vertices, these are copied
	 *  @param count the vertex count */
	public native void CreateChain(@Const b2Vec2 vertices, @Cast("int32") int count);

	/** Establish connectivity to a vertex that precedes the first vertex.
	 *  Don't call this for loops. */
	public native void SetPrevVertex(@Const @ByRef b2Vec2 prevVertex);

	/** Establish connectivity to a vertex that follows the last vertex.
	 *  Don't call this for loops. */
	public native void SetNextVertex(@Const @ByRef b2Vec2 nextVertex);

	/** Implement b2Shape. Vertices are cloned using b2Alloc. */
	public native b2Shape Clone(b2BlockAllocator allocator);

	/** @see b2Shape::GetChildCount */
	public native @Cast("int32") int GetChildCount();

	/** Get a child edge. */
	public native void GetChildEdge(b2EdgeShape edge, @Cast("int32") int index);

	/** This always return false.
	 *  @see b2Shape::TestPoint */
	public native @Cast("bool") boolean TestPoint(@Const @ByRef b2Transform transform, @Const @ByRef b2Vec2 p);

	// @see b2Shape::ComputeDistance
	public native void ComputeDistance(@Const @ByRef b2Transform xf, @Const @ByRef b2Vec2 p, @Cast("float32*") FloatPointer distance, b2Vec2 normal, @Cast("int32") int childIndex);
	public native void ComputeDistance(@Const @ByRef b2Transform xf, @Const @ByRef b2Vec2 p, @Cast("float32*") FloatBuffer distance, b2Vec2 normal, @Cast("int32") int childIndex);
	public native void ComputeDistance(@Const @ByRef b2Transform xf, @Const @ByRef b2Vec2 p, @Cast("float32*") float[] distance, b2Vec2 normal, @Cast("int32") int childIndex);

	/** Implement b2Shape. */
	public native @Cast("bool") boolean RayCast(b2RayCastOutput output, @Const @ByRef b2RayCastInput input,
						@Const @ByRef b2Transform transform, @Cast("int32") int childIndex);

	/** @see b2Shape::ComputeAABB */
	public native void ComputeAABB(b2AABB aabb, @Const @ByRef b2Transform transform, @Cast("int32") int childIndex);

	/** Chains have zero mass.
	 *  @see b2Shape::ComputeMass */
	public native void ComputeMass(b2MassData massData, @Cast("float32") float density);

	/** The vertices. Owned by this class. */
	public native b2Vec2 m_vertices(); public native b2ChainShape m_vertices(b2Vec2 m_vertices);

	/** The vertex count. */
	public native @Cast("int32") int m_count(); public native b2ChainShape m_count(int m_count);

	public native @ByRef b2Vec2 m_prevVertex(); public native b2ChainShape m_prevVertex(b2Vec2 m_prevVertex);
	public native @ByRef b2Vec2 m_nextVertex(); public native b2ChainShape m_nextVertex(b2Vec2 m_nextVertex);
	public native @Cast("bool") boolean m_hasPrevVertex(); public native b2ChainShape m_hasPrevVertex(boolean m_hasPrevVertex);
	public native @Cast("bool") boolean m_hasNextVertex(); public native b2ChainShape m_hasNextVertex(boolean m_hasNextVertex);
}



// #endif


// Parsed from <Box2D/Collision/Shapes/b2PolygonShape.h>

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
* Copyright (c) 2013 Google, Inc.
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_POLYGON_SHAPE_H
// #define B2_POLYGON_SHAPE_H

// #include <Box2D/Collision/Shapes/b2Shape.h>

/** A convex polygon. It is assumed that the interior of the polygon is to
 *  the left of each edge.
 *  Polygons have a maximum number of vertices equal to b2_maxPolygonVertices.
 *  In most cases you should not need many vertices for a convex polygon. */
@NoOffset public static class b2PolygonShape extends b2Shape {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2PolygonShape(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2PolygonShape(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2PolygonShape position(long position) {
        return (b2PolygonShape)super.position(position);
    }

	public b2PolygonShape() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Implement b2Shape. */
	public native b2Shape Clone(b2BlockAllocator allocator);

	/** @see b2Shape::GetChildCount */
	public native @Cast("int32") int GetChildCount();

	/** Create a convex hull from the given array of local points.
	 *  The count must be in the range [3, b2_maxPolygonVertices].
	 *  \warning the points may be re-ordered, even if they form a convex polygon
	 *  \warning collinear points are handled but not removed. Collinear points
	 *  may lead to poor stacking behavior. */
	public native void Set(@Const b2Vec2 points, @Cast("int32") int count);

	/** Build vertices to represent an axis-aligned box centered on the local origin.
	 *  @param hx the half-width.
	 *  @param hy the half-height. */
	public native void SetAsBox(@Cast("float32") float hx, @Cast("float32") float hy);

	/** Build vertices to represent an oriented box.
	 *  @param hx the half-width.
	 *  @param hy the half-height.
	 *  @param center the center of the box in local coordinates.
	 *  @param angle the rotation of the box in local coordinates. */
	public native void SetAsBox(@Cast("float32") float hx, @Cast("float32") float hy, @Const @ByRef b2Vec2 center, @Cast("float32") float angle);

	/** @see b2Shape::TestPoint */
	public native @Cast("bool") boolean TestPoint(@Const @ByRef b2Transform transform, @Const @ByRef b2Vec2 p);

	// @see b2Shape::ComputeDistance
	public native void ComputeDistance(@Const @ByRef b2Transform xf, @Const @ByRef b2Vec2 p, @Cast("float32*") FloatPointer distance, b2Vec2 normal, @Cast("int32") int childIndex);
	public native void ComputeDistance(@Const @ByRef b2Transform xf, @Const @ByRef b2Vec2 p, @Cast("float32*") FloatBuffer distance, b2Vec2 normal, @Cast("int32") int childIndex);
	public native void ComputeDistance(@Const @ByRef b2Transform xf, @Const @ByRef b2Vec2 p, @Cast("float32*") float[] distance, b2Vec2 normal, @Cast("int32") int childIndex);

	/** Implement b2Shape. */
	public native @Cast("bool") boolean RayCast(b2RayCastOutput output, @Const @ByRef b2RayCastInput input,
						@Const @ByRef b2Transform transform, @Cast("int32") int childIndex);

	/** @see b2Shape::ComputeAABB */
	public native void ComputeAABB(b2AABB aabb, @Const @ByRef b2Transform transform, @Cast("int32") int childIndex);

	/** @see b2Shape::ComputeMass */
	public native void ComputeMass(b2MassData massData, @Cast("float32") float density);

	/** Get the vertex count. */
	public native @Cast("int32") int GetVertexCount();

	/** Get a vertex by index. */
	public native @Const @ByRef b2Vec2 GetVertex(@Cast("int32") int index);

	/** Validate convexity. This is a very time consuming operation.
	 *  @return true if valid */
	public native @Cast("bool") boolean Validate();
	/** Set centroid with direct floats. */
	public native void SetCentroid(@Cast("float32") float x, @Cast("float32") float y);

	/** SetAsBox with direct floats for center.
	 *  @see b2Shape::SetAsBox */
	public native void SetAsBox(@Cast("float32") float hx,
									@Cast("float32") float hy,
									@Cast("float32") float centerX,
									@Cast("float32") float centerY,
									@Cast("float32") float angle);
// #endif // LIQUIDFUN_EXTERNAL_LANGUAGE_API

	public native @ByRef b2Vec2 m_centroid(); public native b2PolygonShape m_centroid(b2Vec2 m_centroid);
	public native @ByRef b2Vec2 m_vertices(int i); public native b2PolygonShape m_vertices(int i, b2Vec2 m_vertices);
	@MemberGetter public native b2Vec2 m_vertices();
	public native @ByRef b2Vec2 m_normals(int i); public native b2PolygonShape m_normals(int i, b2Vec2 m_normals);
	@MemberGetter public native b2Vec2 m_normals();
	public native @Cast("int32") int m_count(); public native b2PolygonShape m_count(int m_count);
}





// #if LIQUIDFUN_EXTERNAL_LANGUAGE_API



// #endif // LIQUIDFUN_EXTERNAL_LANGUAGE_API

// #endif


// Parsed from <Box2D/Collision/b2Collision.h>

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_COLLISION_H
// #define B2_COLLISION_H

// #include <Box2D/Common/b2Math.h>
// #include <limits.h>

/** \file
 *  Structures and functions used for computing contact points, distance
 *  queries, and TOI queries. */

@MemberGetter public static native @Cast("const uint8") short b2_nullFeature();

/** The features that intersect to form the contact point
 *  This must be 4 bytes or less. */
public static class b2ContactFeature extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2ContactFeature() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ContactFeature(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ContactFeature(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2ContactFeature position(long position) {
        return (b2ContactFeature)super.position(position);
    }

	/** enum b2ContactFeature::Type */
	public static final int
		e_vertex = 0,
		e_face = 1;

	/** Feature index on shapeA */
	public native @Cast("uint8") short indexA(); public native b2ContactFeature indexA(short indexA);
	/** Feature index on shapeB */
	public native @Cast("uint8") short indexB(); public native b2ContactFeature indexB(short indexB);
	/** The feature type on shapeA */
	public native @Cast("uint8") short typeA(); public native b2ContactFeature typeA(short typeA);
	/** The feature type on shapeB */
	public native @Cast("uint8") short typeB(); public native b2ContactFeature typeB(short typeB);
}

/** Contact ids to facilitate warm starting. */
public static class b2ContactID extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2ContactID() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ContactID(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ContactID(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2ContactID position(long position) {
        return (b2ContactID)super.position(position);
    }

	public native @ByRef b2ContactFeature cf(); public native b2ContactID cf(b2ContactFeature cf);
	/** Used to quickly compare contact ids. */
	public native @Cast("uint32") long key(); public native b2ContactID key(long key);
}

/** A manifold point is a contact point belonging to a contact
 *  manifold. It holds details related to the geometry and dynamics
 *  of the contact points.
 *  The local point usage depends on the manifold type:
 *  -e_circles: the local center of circleB
 *  -e_faceA: the local center of cirlceB or the clip point of polygonB
 *  -e_faceB: the clip point of polygonA
 *  This structure is stored across time steps, so we keep it small.
 *  Note: the impulses are used for internal caching and may not
 *  provide reliable contact forces, especially for high speed collisions. */
public static class b2ManifoldPoint extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2ManifoldPoint() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ManifoldPoint(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ManifoldPoint(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2ManifoldPoint position(long position) {
        return (b2ManifoldPoint)super.position(position);
    }

	/** usage depends on manifold type */
	public native @ByRef b2Vec2 localPoint(); public native b2ManifoldPoint localPoint(b2Vec2 localPoint);
	/** the non-penetration impulse */
	public native @Cast("float32") float normalImpulse(); public native b2ManifoldPoint normalImpulse(float normalImpulse);
	/** the friction impulse */
	public native @Cast("float32") float tangentImpulse(); public native b2ManifoldPoint tangentImpulse(float tangentImpulse);
	/** uniquely identifies a contact point between two shapes */
	public native @ByRef b2ContactID id(); public native b2ManifoldPoint id(b2ContactID id);
}

/** A manifold for two touching convex shapes.
 *  Box2D supports multiple types of contact:
 *  - clip point versus plane with radius
 *  - point versus point with radius (circles)
 *  The local point usage depends on the manifold type:
 *  -e_circles: the local center of circleA
 *  -e_faceA: the center of faceA
 *  -e_faceB: the center of faceB
 *  Similarly the local normal usage:
 *  -e_circles: not used
 *  -e_faceA: the normal on polygonA
 *  -e_faceB: the normal on polygonB
 *  We store contacts in this way so that position correction can
 *  account for movement, which is critical for continuous physics.
 *  All contact scenarios must be expressed in one of these types.
 *  This structure is stored across time steps, so we keep it small. */
public static class b2Manifold extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2Manifold() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Manifold(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Manifold(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2Manifold position(long position) {
        return (b2Manifold)super.position(position);
    }

	/** enum b2Manifold::Type */
	public static final int
		e_circles = 0,
		e_faceA = 1,
		e_faceB = 2;

	/** the points of contact */
	public native @ByRef b2ManifoldPoint points(int i); public native b2Manifold points(int i, b2ManifoldPoint points);
	@MemberGetter public native b2ManifoldPoint points();
	/** not use for Type::e_points */
	public native @ByRef b2Vec2 localNormal(); public native b2Manifold localNormal(b2Vec2 localNormal);
	/** usage depends on manifold type */
	public native @ByRef b2Vec2 localPoint(); public native b2Manifold localPoint(b2Vec2 localPoint);
	public native @Cast("b2Manifold::Type") int type(); public native b2Manifold type(int type);
	/** the number of manifold points */
	public native @Cast("int32") int pointCount(); public native b2Manifold pointCount(int pointCount);
}

/** This is used to compute the current state of a contact manifold. */
public static class b2WorldManifold extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2WorldManifold() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2WorldManifold(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2WorldManifold(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2WorldManifold position(long position) {
        return (b2WorldManifold)super.position(position);
    }

	/** Evaluate the manifold with supplied transforms. This assumes
	 *  modest motion from the original state. This does not change the
	 *  point count, impulses, etc. The radii must come from the shapes
	 *  that generated the manifold. */
	public native void Initialize(@Const b2Manifold manifold,
						@Const @ByRef b2Transform xfA, @Cast("float32") float radiusA,
						@Const @ByRef b2Transform xfB, @Cast("float32") float radiusB);

	/** world vector pointing from A to B */
	public native @ByRef b2Vec2 normal(); public native b2WorldManifold normal(b2Vec2 normal);
	/** world contact point (point of intersection) */
	public native @ByRef b2Vec2 points(int i); public native b2WorldManifold points(int i, b2Vec2 points);
	@MemberGetter public native b2Vec2 points();
	/** a negative value indicates overlap, in meters */
	public native @Cast("float32") float separations(int i); public native b2WorldManifold separations(int i, float separations);
	@MemberGetter public native @Cast("float32*") FloatPointer separations();
}

/** This is used for determining the state of contact points. */
/** enum b2PointState */
public static final int
	/** point does not exist */
	b2_nullState = 0,
	/** point was added in the update */
	b2_addState = 1,
	/** point persisted across the update */
	b2_persistState = 2,
	/** point was removed in the update */
	b2_removeState = 3;

/** Compute the point states given two manifolds. The states pertain to the transition from manifold1
 *  to manifold2. So state1 is either persist or remove while state2 is either add or persist. */
public static native void b2GetPointStates(@Cast("b2PointState*") IntPointer state1, @Cast("b2PointState*") IntPointer state2,
					  @Const b2Manifold manifold1, @Const b2Manifold manifold2);
public static native void b2GetPointStates(@Cast("b2PointState*") IntBuffer state1, @Cast("b2PointState*") IntBuffer state2,
					  @Const b2Manifold manifold1, @Const b2Manifold manifold2);
public static native void b2GetPointStates(@Cast("b2PointState*") int[] state1, @Cast("b2PointState*") int[] state2,
					  @Const b2Manifold manifold1, @Const b2Manifold manifold2);

/** Used for computing contact manifolds. */
public static class b2ClipVertex extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2ClipVertex() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ClipVertex(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ClipVertex(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2ClipVertex position(long position) {
        return (b2ClipVertex)super.position(position);
    }

	public native @ByRef b2Vec2 v(); public native b2ClipVertex v(b2Vec2 v);
	public native @ByRef b2ContactID id(); public native b2ClipVertex id(b2ContactID id);
}

/** Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1). */
public static class b2RayCastInput extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2RayCastInput() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2RayCastInput(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2RayCastInput(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2RayCastInput position(long position) {
        return (b2RayCastInput)super.position(position);
    }

	public native @ByRef b2Vec2 p1(); public native b2RayCastInput p1(b2Vec2 p1);
	public native @ByRef b2Vec2 p2(); public native b2RayCastInput p2(b2Vec2 p2);
	public native @Cast("float32") float maxFraction(); public native b2RayCastInput maxFraction(float maxFraction);
}

/** Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2
 *  come from b2RayCastInput. */
public static class b2RayCastOutput extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2RayCastOutput() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2RayCastOutput(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2RayCastOutput(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2RayCastOutput position(long position) {
        return (b2RayCastOutput)super.position(position);
    }

	public native @ByRef b2Vec2 normal(); public native b2RayCastOutput normal(b2Vec2 normal);
	public native @Cast("float32") float fraction(); public native b2RayCastOutput fraction(float fraction);
}

/** An axis aligned bounding box. */
public static class b2AABB extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2AABB() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2AABB(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2AABB(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2AABB position(long position) {
        return (b2AABB)super.position(position);
    }

	/** Verify that the bounds are sorted. */
	public native @Cast("bool") boolean IsValid();

	/** Get the center of the AABB. */
	public native @ByVal b2Vec2 GetCenter();

	/** Get the extents of the AABB (half-widths). */
	public native @ByVal b2Vec2 GetExtents();

	/** Get the perimeter length */
	public native @Cast("float32") float GetPerimeter();

	/** Combine an AABB into this one. */
	public native void Combine(@Const @ByRef b2AABB aabb);

	/** Combine two AABBs into this one. */
	public native void Combine(@Const @ByRef b2AABB aabb1, @Const @ByRef b2AABB aabb2);

	/** Does this aabb contain the provided AABB. */
	public native @Cast("bool") boolean Contains(@Const @ByRef b2AABB aabb);

	public native @Cast("bool") boolean RayCast(b2RayCastOutput output, @Const @ByRef b2RayCastInput input);

	/** the lower vertex */
	public native @ByRef b2Vec2 lowerBound(); public native b2AABB lowerBound(b2Vec2 lowerBound);
	/** the upper vertex */
	public native @ByRef b2Vec2 upperBound(); public native b2AABB upperBound(b2Vec2 upperBound);
}

/** Compute the collision manifold between two circles. */
public static native void b2CollideCircles(b2Manifold manifold,
					  @Const b2CircleShape circleA, @Const @ByRef b2Transform xfA,
					  @Const b2CircleShape circleB, @Const @ByRef b2Transform xfB);

/** Compute the collision manifold between a polygon and a circle. */
public static native void b2CollidePolygonAndCircle(b2Manifold manifold,
							   @Const b2PolygonShape polygonA, @Const @ByRef b2Transform xfA,
							   @Const b2CircleShape circleB, @Const @ByRef b2Transform xfB);

/** Compute the collision manifold between two polygons. */
public static native void b2CollidePolygons(b2Manifold manifold,
					   @Const b2PolygonShape polygonA, @Const @ByRef b2Transform xfA,
					   @Const b2PolygonShape polygonB, @Const @ByRef b2Transform xfB);

/** Compute the collision manifold between an edge and a circle. */
public static native void b2CollideEdgeAndCircle(b2Manifold manifold,
							   @Const b2EdgeShape polygonA, @Const @ByRef b2Transform xfA,
							   @Const b2CircleShape circleB, @Const @ByRef b2Transform xfB);

/** Compute the collision manifold between an edge and a circle. */
public static native void b2CollideEdgeAndPolygon(b2Manifold manifold,
							   @Const b2EdgeShape edgeA, @Const @ByRef b2Transform xfA,
							   @Const b2PolygonShape circleB, @Const @ByRef b2Transform xfB);

/** Clipping for contact manifolds. */
public static native @Cast("int32") int b2ClipSegmentToLine(b2ClipVertex vOut, @Const b2ClipVertex vIn,
							@Const @ByRef b2Vec2 normal, @Cast("float32") float offset, @Cast("int32") int vertexIndexA);

/** Determine if two generic shapes overlap. */
public static native @Cast("bool") boolean b2TestOverlap(	@Const b2Shape shapeA, @Cast("int32") int indexA,
					@Const b2Shape shapeB, @Cast("int32") int indexB,
					@Const @ByRef b2Transform xfA, @Const @ByRef b2Transform xfB);

// ---------------- Inline Functions ------------------------------------------



public static native @Cast("bool") boolean b2TestOverlap(@Const @ByRef b2AABB a, @Const @ByRef b2AABB b);

// #endif


// Parsed from <Box2D/Collision/b2BroadPhase.h>

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_BROAD_PHASE_H
// #define B2_BROAD_PHASE_H

// #include <Box2D/Common/b2Settings.h>
// #include <Box2D/Collision/b2Collision.h>
// #include <Box2D/Collision/b2DynamicTree.h>
// #include <algorithm>

public static class b2Pair extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2Pair() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Pair(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Pair(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2Pair position(long position) {
        return (b2Pair)super.position(position);
    }

	public native @Cast("int32") int proxyIdA(); public native b2Pair proxyIdA(int proxyIdA);
	public native @Cast("int32") int proxyIdB(); public native b2Pair proxyIdB(int proxyIdB);
}

/** The broad-phase is used for computing pairs and performing volume queries and ray casts.
 *  This broad-phase does not persist pairs. Instead, this reports potentially new pairs.
 *  It is up to the client to consume the new pairs and to track subsequent overlap. */
@NoOffset public static class b2BroadPhase extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2BroadPhase(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2BroadPhase(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2BroadPhase position(long position) {
        return (b2BroadPhase)super.position(position);
    }


	/** enum b2BroadPhase:: */
	public static final int
		e_nullProxy = -1;

	public b2BroadPhase() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Create a proxy with an initial AABB. Pairs are not reported until
	 *  UpdatePairs is called. */
	public native @Cast("int32") int CreateProxy(@Const @ByRef b2AABB aabb, Pointer userData);

	/** Destroy a proxy. It is up to the client to remove any pairs. */
	public native void DestroyProxy(@Cast("int32") int proxyId);

	/** Call MoveProxy as many times as you like, then when you are done
	 *  call UpdatePairs to finalized the proxy pairs (for your time step). */
	public native void MoveProxy(@Cast("int32") int proxyId, @Const @ByRef b2AABB aabb, @Const @ByRef b2Vec2 displacement);

	/** Call to trigger a re-processing of it's pairs on the next call to UpdatePairs. */
	public native void TouchProxy(@Cast("int32") int proxyId);

	/** Get the fat AABB for a proxy. */
	public native @Const @ByRef b2AABB GetFatAABB(@Cast("int32") int proxyId);

	/** Get user data from a proxy. Returns NULL if the id is invalid. */
	public native Pointer GetUserData(@Cast("int32") int proxyId);

	/** Test overlap of fat AABBs. */
	public native @Cast("bool") boolean TestOverlap(@Cast("int32") int proxyIdA, @Cast("int32") int proxyIdB);

	/** Get the number of proxies. */
	public native @Cast("int32") int GetProxyCount();

	/** Update the pairs. This results in pair callbacks. This can only add pairs. */

	/** Query an AABB for overlapping proxies. The callback class
	 *  is called for each proxy that overlaps the supplied AABB. */

	/** Ray-cast against the proxies in the tree. This relies on the callback
	 *  to perform a exact ray-cast in the case were the proxy contains a shape.
	 *  The callback also performs the any collision filtering. This has performance
	 *  roughly equal to k * log(n), where k is the number of collisions and n is the
	 *  number of proxies in the tree.
	 *  @param input the ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
	 *  @param callback a callback class that is called for each proxy that is hit by the ray. */

	/** Get the height of the embedded tree. */
	public native @Cast("int32") int GetTreeHeight();

	/** Get the balance of the embedded tree. */
	public native @Cast("int32") int GetTreeBalance();

	/** Get the quality metric of the embedded tree. */
	public native @Cast("float32") float GetTreeQuality();

	/** Shift the world origin. Useful for large worlds.
	 *  The shift formula is: position -= newOrigin
	 *  @param newOrigin the new origin with respect to the old origin */
	public native void ShiftOrigin(@Const @ByRef b2Vec2 newOrigin);
}

/** This is used to sort pairs. */
public static native @Cast("bool") boolean b2PairLessThan(@Const @ByRef b2Pair pair1, @Const @ByRef b2Pair pair2);























// #endif


// Parsed from <Box2D/Collision/b2Distance.h>


/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_DISTANCE_H
// #define B2_DISTANCE_H

// #include <Box2D/Common/b2Math.h>

/** A distance proxy is used by the GJK algorithm.
 *  It encapsulates any shape. */
@NoOffset public static class b2DistanceProxy extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2DistanceProxy(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2DistanceProxy(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2DistanceProxy position(long position) {
        return (b2DistanceProxy)super.position(position);
    }

	public b2DistanceProxy() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Initialize the proxy using the given shape. The shape
	 *  must remain in scope while the proxy is in use. */
	public native void Set(@Const b2Shape shape, @Cast("int32") int index);

	/** Get the supporting vertex index in the given direction. */
	public native @Cast("int32") int GetSupport(@Const @ByRef b2Vec2 d);

	/** Get the supporting vertex in the given direction. */
	public native @Const @ByRef b2Vec2 GetSupportVertex(@Const @ByRef b2Vec2 d);

	/** Get the vertex count. */
	public native @Cast("int32") int GetVertexCount();

	/** Get a vertex by index. Used by b2Distance. */
	public native @Const @ByRef b2Vec2 GetVertex(@Cast("int32") int index);

	public native @ByRef b2Vec2 m_buffer(int i); public native b2DistanceProxy m_buffer(int i, b2Vec2 m_buffer);
	@MemberGetter public native b2Vec2 m_buffer();
	@MemberGetter public native @Const b2Vec2 m_vertices();
	public native @Cast("int32") int m_count(); public native b2DistanceProxy m_count(int m_count);
	public native @Cast("float32") float m_radius(); public native b2DistanceProxy m_radius(float m_radius);
}

/** Used to warm start b2Distance.
 *  Set count to zero on first call. */
public static class b2SimplexCache extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2SimplexCache() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2SimplexCache(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2SimplexCache(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2SimplexCache position(long position) {
        return (b2SimplexCache)super.position(position);
    }

	/** length or area */
	public native @Cast("float32") float metric(); public native b2SimplexCache metric(float metric);
	public native @Cast("uint16") int count(); public native b2SimplexCache count(int count);
	/** vertices on shape A */
	public native @Cast("uint8") short indexA(int i); public native b2SimplexCache indexA(int i, short indexA);
	@MemberGetter public native @Cast("uint8*") BytePointer indexA();
	/** vertices on shape B */
	public native @Cast("uint8") short indexB(int i); public native b2SimplexCache indexB(int i, short indexB);
	@MemberGetter public native @Cast("uint8*") BytePointer indexB();
}

/** Input for b2Distance.
 *  You have to option to use the shape radii
 *  in the computation. Even  */
public static class b2DistanceInput extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2DistanceInput() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2DistanceInput(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2DistanceInput(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2DistanceInput position(long position) {
        return (b2DistanceInput)super.position(position);
    }

	public native @ByRef b2DistanceProxy proxyA(); public native b2DistanceInput proxyA(b2DistanceProxy proxyA);
	public native @ByRef b2DistanceProxy proxyB(); public native b2DistanceInput proxyB(b2DistanceProxy proxyB);
	public native @ByRef b2Transform transformA(); public native b2DistanceInput transformA(b2Transform transformA);
	public native @ByRef b2Transform transformB(); public native b2DistanceInput transformB(b2Transform transformB);
	public native @Cast("bool") boolean useRadii(); public native b2DistanceInput useRadii(boolean useRadii);
}

/** Output for b2Distance. */
public static class b2DistanceOutput extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2DistanceOutput() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2DistanceOutput(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2DistanceOutput(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2DistanceOutput position(long position) {
        return (b2DistanceOutput)super.position(position);
    }

	/** closest point on shapeA */
	public native @ByRef b2Vec2 pointA(); public native b2DistanceOutput pointA(b2Vec2 pointA);
	/** closest point on shapeB */
	public native @ByRef b2Vec2 pointB(); public native b2DistanceOutput pointB(b2Vec2 pointB);
	public native @Cast("float32") float distance(); public native b2DistanceOutput distance(float distance);
	/** number of GJK iterations used */
	public native @Cast("int32") int iterations(); public native b2DistanceOutput iterations(int iterations);
}

/** Compute the closest points between two shapes. Supports any combination of:
 *  b2CircleShape, b2PolygonShape, b2EdgeShape. The simplex cache is input/output.
 *  On the first call set b2SimplexCache.count to zero. */
public static native void b2Distance(b2DistanceOutput output,
				b2SimplexCache cache, 
				@Const b2DistanceInput input);


//////////////////////////////////////////////////////////////////////////









// #endif


// Parsed from <Box2D/Collision/b2DynamicTree.h>

/*
* Copyright (c) 2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_DYNAMIC_TREE_H
// #define B2_DYNAMIC_TREE_H

// #include <Box2D/Collision/b2Collision.h>
// #include <Box2D/Common/b2GrowableStack.h>

public static final int b2_nullNode = (-1);

/** A node in the dynamic tree. The client does not interact with this directly. */
public static class b2TreeNode extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2TreeNode() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2TreeNode(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2TreeNode(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2TreeNode position(long position) {
        return (b2TreeNode)super.position(position);
    }

	public native @Cast("bool") boolean IsLeaf();

	/** Enlarged AABB */
	public native @ByRef b2AABB aabb(); public native b2TreeNode aabb(b2AABB aabb);

	public native Pointer userData(); public native b2TreeNode userData(Pointer userData);
		public native @Cast("int32") int parent(); public native b2TreeNode parent(int parent);
		public native @Cast("int32") int next(); public native b2TreeNode next(int next);

	public native @Cast("int32") int child1(); public native b2TreeNode child1(int child1);
	public native @Cast("int32") int child2(); public native b2TreeNode child2(int child2);

	// leaf = 0, free node = -1
	public native @Cast("int32") int height(); public native b2TreeNode height(int height);
}

/** A dynamic AABB tree broad-phase, inspired by Nathanael Presson's btDbvt.
 *  A dynamic tree arranges data in a binary tree to accelerate
 *  queries such as volume queries and ray casts. Leafs are proxies
 *  with an AABB. In the tree we expand the proxy AABB by b2_fatAABBFactor
 *  so that the proxy AABB is bigger than the client object. This allows the client
 *  object to move by small amounts without triggering a tree update.
 * 
 *  Nodes are pooled and relocatable, so we use node indices rather than pointers. */
@NoOffset public static class b2DynamicTree extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2DynamicTree(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2DynamicTree(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2DynamicTree position(long position) {
        return (b2DynamicTree)super.position(position);
    }

	/** Constructing the tree initializes the node pool. */
	public b2DynamicTree() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Destroy the tree, freeing the node pool. */

	/** Create a proxy. Provide a tight fitting AABB and a userData pointer. */
	public native @Cast("int32") int CreateProxy(@Const @ByRef b2AABB aabb, Pointer userData);

	/** Destroy a proxy. This asserts if the id is invalid. */
	public native void DestroyProxy(@Cast("int32") int proxyId);

	/** Move a proxy with a swepted AABB. If the proxy has moved outside of its fattened AABB,
	 *  then the proxy is removed from the tree and re-inserted. Otherwise
	 *  the function returns immediately.
	 *  @return true if the proxy was re-inserted. */
	public native @Cast("bool") boolean MoveProxy(@Cast("int32") int proxyId, @Const @ByRef b2AABB aabb1, @Const @ByRef b2Vec2 displacement);

	/** Get proxy user data.
	 *  @return the proxy user data or 0 if the id is invalid. */
	public native Pointer GetUserData(@Cast("int32") int proxyId);

	/** Get the fat AABB for a proxy. */
	public native @Const @ByRef b2AABB GetFatAABB(@Cast("int32") int proxyId);

	/** Query an AABB for overlapping proxies. The callback class
	 *  is called for each proxy that overlaps the supplied AABB. */
	public native void Query(b2DynamicTreeQueryCallback callback, @Const @ByRef b2AABB aabb);

	/** Ray-cast against the proxies in the tree. This relies on the callback
	 *  to perform a exact ray-cast in the case were the proxy contains a shape.
	 *  The callback also performs the any collision filtering. This has performance
	 *  roughly equal to k * log(n), where k is the number of collisions and n is the
	 *  number of proxies in the tree.
	 *  @param input the ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
	 *  @param callback a callback class that is called for each proxy that is hit by the ray. */
	public native void RayCast(b2DynamicTreeRayCastCallback callback, @Const @ByRef b2RayCastInput input);

	/** Validate this tree. For testing. */
	public native void Validate();

	/** Compute the height of the binary tree in O(N) time. Should not be
	 *  called often. */
	public native @Cast("int32") int GetHeight();

	/** Get the maximum balance of an node in the tree. The balance is the difference
	 *  in height of the two children of a node. */
	public native @Cast("int32") int GetMaxBalance();

	/** Get the ratio of the sum of the node areas to the root area. */
	public native @Cast("float32") float GetAreaRatio();

	/** Build an optimal tree. Very expensive. For testing. */
	public native void RebuildBottomUp();

	/** Shift the world origin. Useful for large worlds.
	 *  The shift formula is: position -= newOrigin
	 *  @param newOrigin the new origin with respect to the old origin */
	public native void ShiftOrigin(@Const @ByRef b2Vec2 newOrigin);
}









// #endif


// Parsed from <Box2D/Collision/b2TimeOfImpact.h>

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_TIME_OF_IMPACT_H
// #define B2_TIME_OF_IMPACT_H

// #include <Box2D/Common/b2Math.h>
// #include <Box2D/Collision/b2Distance.h>

/** Input parameters for b2TimeOfImpact */
public static class b2TOIInput extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2TOIInput() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2TOIInput(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2TOIInput(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2TOIInput position(long position) {
        return (b2TOIInput)super.position(position);
    }

	public native @ByRef b2DistanceProxy proxyA(); public native b2TOIInput proxyA(b2DistanceProxy proxyA);
	public native @ByRef b2DistanceProxy proxyB(); public native b2TOIInput proxyB(b2DistanceProxy proxyB);
	public native @ByRef b2Sweep sweepA(); public native b2TOIInput sweepA(b2Sweep sweepA);
	public native @ByRef b2Sweep sweepB(); public native b2TOIInput sweepB(b2Sweep sweepB);
	public native @Cast("float32") float tMax(); public native b2TOIInput tMax(float tMax);		// defines sweep interval [0, tMax]
}

// Output parameters for b2TimeOfImpact.
public static class b2TOIOutput extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2TOIOutput() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2TOIOutput(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2TOIOutput(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2TOIOutput position(long position) {
        return (b2TOIOutput)super.position(position);
    }

	/** enum b2TOIOutput::State */
	public static final int
		e_unknown = 0,
		e_failed = 1,
		e_overlapped = 2,
		e_touching = 3,
		e_separated = 4;

	public native @Cast("b2TOIOutput::State") int state(); public native b2TOIOutput state(int state);
	public native @Cast("float32") float t(); public native b2TOIOutput t(float t);
}

/** Compute the upper bound on time before two shapes penetrate. Time is represented as
 *  a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,
 *  non-tunneling collision. If you change the time interval, you should call this function
 *  again.
 *  Note: use b2Distance to compute the contact point and normal at the time of impact. */
public static native void b2TimeOfImpact(b2TOIOutput output, @Const b2TOIInput input);

// #endif


// Parsed from <Box2D/Dynamics/b2Body.h>

/*
* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
* Copyright (c) 2013 Google, Inc.
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_BODY_H
// #define B2_BODY_H

// #include <Box2D/Common/b2Math.h>
// #include <Box2D/Collision/Shapes/b2Shape.h>
// #include <memory>
@Opaque public static class b2Controller extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public b2Controller() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Controller(Pointer p) { super(p); }
}

/** The body type.
 *  static: zero mass, zero velocity, may be manually moved
 *  kinematic: zero mass, non-zero velocity set by user, moved by solver
 *  dynamic: positive mass, non-zero velocity determined by forces, moved by solver */
/** enum b2BodyType */
public static final int
	b2_staticBody = 0,
	b2_kinematicBody = 1,
	b2_dynamicBody = 2;

	// TODO_ERIN
	//b2_bulletBody,

/** A body definition holds all the data needed to construct a rigid body.
 *  You can safely re-use body definitions. Shapes are added to a body after construction. */
@NoOffset public static class b2BodyDef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2BodyDef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2BodyDef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2BodyDef position(long position) {
        return (b2BodyDef)super.position(position);
    }

	/** This constructor sets the body definition default values. */
	public b2BodyDef() { super((Pointer)null); allocate(); }
	private native void allocate();

// #if LIQUIDFUN_EXTERNAL_LANGUAGE_API
	/** Set position with direct floats. */
	public native void SetPosition(@Cast("float32") float positionX, @Cast("float32") float positionY);
// #endif // LIQUIDFUN_EXTERNAL_LANGUAGE_API

	/** The body type: static, kinematic, or dynamic.
	 *  Note: if a dynamic body would have zero mass, the mass is set to one. */
	public native @Cast("b2BodyType") int type(); public native b2BodyDef type(int type);

	/** The world position of the body. Avoid creating bodies at the origin
	 *  since this can lead to many overlapping shapes. */
	public native @ByRef @Name("position") b2Vec2 _position(); public native b2BodyDef _position(b2Vec2 _position);

	/** The world angle of the body in radians. */
	public native @Cast("float32") float angle(); public native b2BodyDef angle(float angle);

	/** The linear velocity of the body's origin in world co-ordinates. */
	public native @ByRef b2Vec2 linearVelocity(); public native b2BodyDef linearVelocity(b2Vec2 linearVelocity);

	/** The angular velocity of the body. */
	public native @Cast("float32") float angularVelocity(); public native b2BodyDef angularVelocity(float angularVelocity);

	/** Linear damping is use to reduce the linear velocity. The damping parameter
	 *  can be larger than 1.0f but the damping effect becomes sensitive to the
	 *  time step when the damping parameter is large. */
	public native @Cast("float32") float linearDamping(); public native b2BodyDef linearDamping(float linearDamping);

	/** Angular damping is use to reduce the angular velocity. The damping parameter
	 *  can be larger than 1.0f but the damping effect becomes sensitive to the
	 *  time step when the damping parameter is large. */
	public native @Cast("float32") float angularDamping(); public native b2BodyDef angularDamping(float angularDamping);

	/** Set this flag to false if this body should never fall asleep. Note that
	 *  this increases CPU usage. */
	public native @Cast("bool") boolean allowSleep(); public native b2BodyDef allowSleep(boolean allowSleep);

	/** Is this body initially awake or sleeping? */
	public native @Cast("bool") boolean awake(); public native b2BodyDef awake(boolean awake);

	/** Should this body be prevented from rotating? Useful for characters. */
	public native @Cast("bool") boolean fixedRotation(); public native b2BodyDef fixedRotation(boolean fixedRotation);

	/** Is this a fast moving body that should be prevented from tunneling through
	 *  other moving bodies? Note that all bodies are prevented from tunneling through
	 *  kinematic and static bodies. This setting is only considered on dynamic bodies.
	 *  \warning You should use this flag sparingly since it increases processing time. */
	public native @Cast("bool") boolean bullet(); public native b2BodyDef bullet(boolean bullet);

	/** Does this body start out active? */
	public native @Cast("bool") boolean active(); public native b2BodyDef active(boolean active);

	/** Use this to store application specific body data. */
	public native Pointer userData(); public native b2BodyDef userData(Pointer userData);

	/** Scale the gravity applied to this body. */
	public native @Cast("float32") float gravityScale(); public native b2BodyDef gravityScale(float gravityScale);
}

/** A rigid body. These are created via b2World::CreateBody. */
@NoOffset public static class b2Body extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Body(Pointer p) { super(p); }

	/** Creates a fixture and attach it to this body. Use this function if you need
	 *  to set some fixture parameters, like friction. Otherwise you can create the
	 *  fixture directly from a shape.
	 *  If the density is non-zero, this function automatically updates the mass of the body.
	 *  Contacts are not created until the next time step.
	 *  @param def the fixture definition.
	 *  \warning This function is locked during callbacks. */
	public native b2Fixture CreateFixture(@Const b2FixtureDef def);

	/** Creates a fixture from a shape and attach it to this body.
	 *  This is a convenience function. Use b2FixtureDef if you need to set parameters
	 *  like friction, restitution, user data, or filtering.
	 *  If the density is non-zero, this function automatically updates the mass of the body.
	 *  @param shape the shape to be cloned.
	 *  @param density the shape density (set to zero for static bodies).
	 *  \warning This function is locked during callbacks. */
	public native b2Fixture CreateFixture(@Const b2Shape shape, @Cast("float32") float density);

	/** Destroy a fixture. This removes the fixture from the broad-phase and
	 *  destroys all contacts associated with this fixture. This will
	 *  automatically adjust the mass of the body if the body is dynamic and the
	 *  fixture has positive density.
	 *  All fixtures attached to a body are implicitly destroyed when the body is destroyed.
	 *  @param fixture the fixture to be removed.
	 *  \warning This function is locked during callbacks. */
	public native void DestroyFixture(b2Fixture fixture);

	/** Set the position of the body's origin and rotation.
	 *  Manipulating a body's transform may cause non-physical behavior.
	 *  Note: contacts are updated on the next call to b2World::Step.
	 *  @param position the world position of the body's local origin.
	 *  @param angle the world rotation in radians. */
	public native void SetTransform(@Const @ByRef b2Vec2 position, @Cast("float32") float angle);

	/** Get the body transform for the body's origin.
	 *  @return the world transform of the body's origin. */
	public native @Const @ByRef b2Transform GetTransform();

	/** Get the world body origin position.
	 *  @return the world position of the body's origin. */
	public native @Const @ByRef b2Vec2 GetPosition();

	/** Get the angle in radians.
	 *  @return the current world rotation angle in radians. */
	public native @Cast("float32") float GetAngle();

	/** Get the world position of the center of mass. */
	public native @Const @ByRef b2Vec2 GetWorldCenter();

	/** Get the local position of the center of mass. */
	public native @Const @ByRef b2Vec2 GetLocalCenter();

	/** Set the linear velocity of the center of mass.
	 *  @param v the new linear velocity of the center of mass. */
	public native void SetLinearVelocity(@Const @ByRef b2Vec2 v);

	/** Get the linear velocity of the center of mass.
	 *  @return the linear velocity of the center of mass. */
	public native @Const @ByRef b2Vec2 GetLinearVelocity();

	/** Set the angular velocity.
	 *  @param omega the new angular velocity in radians/second. */
	public native void SetAngularVelocity(@Cast("float32") float omega);

	/** Get the angular velocity.
	 *  @return the angular velocity in radians/second. */
	public native @Cast("float32") float GetAngularVelocity();

	/** Apply a force at a world point. If the force is not
	 *  applied at the center of mass, it will generate a torque and
	 *  affect the angular velocity. This wakes up the body.
	 *  @param force the world force vector, usually in Newtons (N).
	 *  @param point the world position of the point of application.
	 *  @param wake also wake up the body */
	public native void ApplyForce(@Const @ByRef b2Vec2 force, @Const @ByRef b2Vec2 point, @Cast("bool") boolean wake);

	/** Apply a force to the center of mass. This wakes up the body.
	 *  @param force the world force vector, usually in Newtons (N).
	 *  @param wake also wake up the body */
	public native void ApplyForceToCenter(@Const @ByRef b2Vec2 force, @Cast("bool") boolean wake);

	/** Apply a torque. This affects the angular velocity
	 *  without affecting the linear velocity of the center of mass.
	 *  This wakes up the body.
	 *  @param torque about the z-axis (out of the screen), usually in N-m.
	 *  @param wake also wake up the body */
	public native void ApplyTorque(@Cast("float32") float torque, @Cast("bool") boolean wake);

	/** Apply an impulse at a point. This immediately modifies the velocity.
	 *  It also modifies the angular velocity if the point of application
	 *  is not at the center of mass. This wakes up the body.
	 *  @param impulse the world impulse vector, usually in N-seconds or kg-m/s.
	 *  @param point the world position of the point of application.
	 *  @param wake also wake up the body */
	public native void ApplyLinearImpulse(@Const @ByRef b2Vec2 impulse, @Const @ByRef b2Vec2 point, @Cast("bool") boolean wake);

	/** Apply an angular impulse.
	 *  @param impulse the angular impulse in units of kg*m*m/s
	 *  @param wake also wake up the body */
	public native void ApplyAngularImpulse(@Cast("float32") float impulse, @Cast("bool") boolean wake);

	/** Get the total mass of the body.
	 *  @return the mass, usually in kilograms (kg). */
	public native @Cast("float32") float GetMass();

	/** Get the rotational inertia of the body about the local origin.
	 *  @return the rotational inertia, usually in kg-m^2. */
	public native @Cast("float32") float GetInertia();

	/** Get the mass data of the body.
	 *  @return a struct containing the mass, inertia and center of the body. */
	public native void GetMassData(b2MassData data);

	/** Set the mass properties to override the mass properties of the fixtures.
	 *  Note that this changes the center of mass position.
	 *  Note that creating or destroying fixtures can also alter the mass.
	 *  This function has no effect if the body isn't dynamic.
	 *  @param massData the mass properties. */
	public native void SetMassData(@Const b2MassData data);

	/** This resets the mass properties to the sum of the mass properties of the fixtures.
	 *  This normally does not need to be called unless you called SetMassData to override
	 *  the mass and you later want to reset the mass. */
	public native void ResetMassData();

	/** Get the world coordinates of a point given the local coordinates.
	 *  @param localPoint a point on the body measured relative the the body's origin.
	 *  @return the same point expressed in world coordinates. */
	public native @ByVal b2Vec2 GetWorldPoint(@Const @ByRef b2Vec2 localPoint);

	/** Get the world coordinates of a vector given the local coordinates.
	 *  @param localVector a vector fixed in the body.
	 *  @return the same vector expressed in world coordinates. */
	public native @ByVal b2Vec2 GetWorldVector(@Const @ByRef b2Vec2 localVector);

	/** Gets a local point relative to the body's origin given a world point.
	 *  @param a point in world coordinates.
	 *  @return the corresponding local point relative to the body's origin. */
	public native @ByVal b2Vec2 GetLocalPoint(@Const @ByRef b2Vec2 worldPoint);

	/** Gets a local vector given a world vector.
	 *  @param a vector in world coordinates.
	 *  @return the corresponding local vector. */
	public native @ByVal b2Vec2 GetLocalVector(@Const @ByRef b2Vec2 worldVector);

	/** Get the world linear velocity of a world point attached to this body.
	 *  @param a point in world coordinates.
	 *  @return the world velocity of a point. */
	public native @ByVal b2Vec2 GetLinearVelocityFromWorldPoint(@Const @ByRef b2Vec2 worldPoint);

	/** Get the world velocity of a local point.
	 *  @param a point in local coordinates.
	 *  @return the world velocity of a point. */
	public native @ByVal b2Vec2 GetLinearVelocityFromLocalPoint(@Const @ByRef b2Vec2 localPoint);

	/** Get the linear damping of the body. */
	public native @Cast("float32") float GetLinearDamping();

	/** Set the linear damping of the body. */
	public native void SetLinearDamping(@Cast("float32") float linearDamping);

	/** Get the angular damping of the body. */
	public native @Cast("float32") float GetAngularDamping();

	/** Set the angular damping of the body. */
	public native void SetAngularDamping(@Cast("float32") float angularDamping);

	/** Get the gravity scale of the body. */
	public native @Cast("float32") float GetGravityScale();

	/** Set the gravity scale of the body. */
	public native void SetGravityScale(@Cast("float32") float scale);

	/** Set the type of this body. This may alter the mass and velocity. */
	public native void SetType(@Cast("b2BodyType") int type);

	/** Get the type of this body. */
	public native @Cast("b2BodyType") int GetType();

	/** Should this body be treated like a bullet for continuous collision detection? */
	public native void SetBullet(@Cast("bool") boolean flag);

	/** Is this body treated like a bullet for continuous collision detection? */
	public native @Cast("bool") boolean IsBullet();

	/** You can disable sleeping on this body. If you disable sleeping, the
	 *  body will be woken. */
	public native void SetSleepingAllowed(@Cast("bool") boolean flag);

	/** Is this body allowed to sleep */
	public native @Cast("bool") boolean IsSleepingAllowed();

	/** Set the sleep state of the body. A sleeping body has very
	 *  low CPU cost.
	 *  @param flag set to true to wake the body, false to put it to sleep. */
	public native void SetAwake(@Cast("bool") boolean flag);

	/** Get the sleeping state of this body.
	 *  @return true if the body is awake. */
	public native @Cast("bool") boolean IsAwake();

	/** Set the active state of the body. An inactive body is not
	 *  simulated and cannot be collided with or woken up.
	 *  If you pass a flag of true, all fixtures will be added to the
	 *  broad-phase.
	 *  If you pass a flag of false, all fixtures will be removed from
	 *  the broad-phase and all contacts will be destroyed.
	 *  Fixtures and joints are otherwise unaffected. You may continue
	 *  to create/destroy fixtures and joints on inactive bodies.
	 *  Fixtures on an inactive body are implicitly inactive and will
	 *  not participate in collisions, ray-casts, or queries.
	 *  Joints connected to an inactive body are implicitly inactive.
	 *  An inactive body is still owned by a b2World object and remains
	 *  in the body list. */
	public native void SetActive(@Cast("bool") boolean flag);

	/** Get the active state of the body. */
	public native @Cast("bool") boolean IsActive();

	/** Set this body to have fixed rotation. This causes the mass
	 *  to be reset. */
	public native void SetFixedRotation(@Cast("bool") boolean flag);

	/** Does this body have fixed rotation? */
	public native @Cast("bool") boolean IsFixedRotation();

	/** Get the list of all fixtures attached to this body. */
	public native b2Fixture GetFixtureList();

	/** Get the list of all joints attached to this body. */
	public native b2JointEdge GetJointList();

	/** Get the list of all contacts attached to this body.
	 *  \warning this list changes during the time step and you may
	 *  miss some collisions if you don't use b2ContactListener. */
	public native b2ContactEdge GetContactList();

	/** Get the next body in the world's body list. */
	public native b2Body GetNext();

	/** Get the user data pointer that was provided in the body definition. */
	public native Pointer GetUserData();

	/** Set the user data. Use this to store your application specific data. */
	public native void SetUserData(Pointer data);

	/** Get the parent world of this body. */
	public native b2World GetWorld();

	/** Dump this body to a log file */
	public native void Dump();
	/** Get x-coordinate of position. */
	public native @Cast("float32") float GetPositionX();

	/** Get y-coordinate of position. */
	public native @Cast("float32") float GetPositionY();

	/** Set b2Transform using direct floats. */
	public native void SetTransform(@Cast("float32") float positionX, @Cast("float32") float positionY, @Cast("float32") float angle);
}









































































































// #if LIQUIDFUN_EXTERNAL_LANGUAGE_API



// #endif // LIQUIDFUN_EXTERNAL_LANGUAGE_API

// #endif


// Parsed from <Box2D/Dynamics/b2Fixture.h>

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
* Copyright (c) 2013 Google, Inc.
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_FIXTURE_H
// #define B2_FIXTURE_H

// #include <Box2D/Dynamics/b2Body.h>
// #include <Box2D/Collision/b2Collision.h>
// #include <Box2D/Collision/Shapes/b2Shape.h>

@Opaque public static class b2BlockAllocator extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public b2BlockAllocator() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2BlockAllocator(Pointer p) { super(p); }
}

/** This holds contact filtering data. */
@NoOffset public static class b2Filter extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Filter(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Filter(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2Filter position(long position) {
        return (b2Filter)super.position(position);
    }

	public b2Filter() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** The collision category bits. Normally you would just set one bit. */
	public native @Cast("uint16") int categoryBits(); public native b2Filter categoryBits(int categoryBits);

	/** The collision mask bits. This states the categories that this
	 *  shape would accept for collision. */
	public native @Cast("uint16") int maskBits(); public native b2Filter maskBits(int maskBits);

	/** Collision groups allow a certain group of objects to never collide (negative)
	 *  or always collide (positive). Zero means no collision group. Non-zero group
	 *  filtering always wins against the mask bits. */
	public native @Cast("int16") short groupIndex(); public native b2Filter groupIndex(short groupIndex);
}

/** A fixture definition is used to create a fixture. This class defines an
 *  abstract fixture definition. You can reuse fixture definitions safely. */
@NoOffset public static class b2FixtureDef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2FixtureDef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2FixtureDef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2FixtureDef position(long position) {
        return (b2FixtureDef)super.position(position);
    }

	/** The constructor sets the default fixture definition values. */
	public b2FixtureDef() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** The shape, this must be set. The shape will be cloned, so you
	 *  can create the shape on the stack. */
	@MemberGetter public native @Const b2Shape shape();
	@MemberSetter public native b2FixtureDef shape(@Const b2Shape shape);

	/** Use this to store application specific fixture data. */
	public native Pointer userData(); public native b2FixtureDef userData(Pointer userData);

	/** The friction coefficient, usually in the range [0,1]. */
	public native @Cast("float32") float friction(); public native b2FixtureDef friction(float friction);

	/** The restitution (elasticity) usually in the range [0,1]. */
	public native @Cast("float32") float restitution(); public native b2FixtureDef restitution(float restitution);

	/** The density, usually in kg/m^2. */
	public native @Cast("float32") float density(); public native b2FixtureDef density(float density);

	/** A sensor shape collects contact information but never generates a collision
	 *  response. */
	public native @Cast("bool") boolean isSensor(); public native b2FixtureDef isSensor(boolean isSensor);

	/** Contact filtering data. */
	public native @ByRef b2Filter filter(); public native b2FixtureDef filter(b2Filter filter);
}

/** This proxy is used internally to connect fixtures to the broad-phase. */
public static class b2FixtureProxy extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2FixtureProxy() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2FixtureProxy(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2FixtureProxy(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2FixtureProxy position(long position) {
        return (b2FixtureProxy)super.position(position);
    }

	public native @ByRef b2AABB aabb(); public native b2FixtureProxy aabb(b2AABB aabb);
	public native b2Fixture fixture(); public native b2FixtureProxy fixture(b2Fixture fixture);
	public native @Cast("int32") int childIndex(); public native b2FixtureProxy childIndex(int childIndex);
	public native @Cast("int32") int proxyId(); public native b2FixtureProxy proxyId(int proxyId);
}

/** A fixture is used to attach a shape to a body for collision detection. A fixture
 *  inherits its transform from its parent. Fixtures hold additional non-geometric data
 *  such as friction, collision filters, etc.
 *  Fixtures are created via b2Body::CreateFixture.
 *  \warning you cannot reuse fixtures. */
@NoOffset public static class b2Fixture extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Fixture(Pointer p) { super(p); }

	/** Get the type of the child shape. You can use this to down cast to the concrete shape.
	 *  @return the shape type. */
	public native @Cast("b2Shape::Type") int GetType();

	/** Get the child shape. You can modify the child shape, however you should not change the
	 *  number of vertices because this will crash some collision caching mechanisms.
	 *  Manipulating the shape may lead to non-physical behavior. */
	public native b2Shape GetShape();

	/** Set if this fixture is a sensor. */
	public native void SetSensor(@Cast("bool") boolean sensor);

	/** Is this fixture a sensor (non-solid)?
	 *  @return the true if the shape is a sensor. */
	public native @Cast("bool") boolean IsSensor();

	/** Set the contact filtering data. This will not update contacts until the next time
	 *  step when either parent body is active and awake.
	 *  This automatically calls Refilter. */
	public native void SetFilterData(@Const @ByRef b2Filter filter);

	/** Get the contact filtering data. */
	public native @Const @ByRef b2Filter GetFilterData();

	/** Call this if you want to establish collision that was previously disabled by b2ContactFilter::ShouldCollide. */
	public native void Refilter();

	/** Get the parent body of this fixture. This is NULL if the fixture is not attached.
	 *  @return the parent body. */
	public native b2Body GetBody();

	/** Get the next fixture in the parent body's fixture list.
	 *  @return the next shape. */
	public native b2Fixture GetNext();

	/** Get the user data that was assigned in the fixture definition. Use this to
	 *  store your application specific data. */
	public native Pointer GetUserData();

	/** Set the user data. Use this to store your application specific data. */
	public native void SetUserData(Pointer data);

	/** Test a point for containment in this fixture.
	 *  @param p a point in world coordinates. */
	public native @Cast("bool") boolean TestPoint(@Const @ByRef b2Vec2 p);

	/** Compute the distance from this fixture.
	 *  @param p a point in world coordinates. */
	public native void ComputeDistance(@Const @ByRef b2Vec2 p, @Cast("float32*") FloatPointer distance, b2Vec2 normal, @Cast("int32") int childIndex);
	public native void ComputeDistance(@Const @ByRef b2Vec2 p, @Cast("float32*") FloatBuffer distance, b2Vec2 normal, @Cast("int32") int childIndex);
	public native void ComputeDistance(@Const @ByRef b2Vec2 p, @Cast("float32*") float[] distance, b2Vec2 normal, @Cast("int32") int childIndex);

	/** Cast a ray against this shape.
	 *  @param output the ray-cast results.
	 *  @param input the ray-cast input parameters. */
	public native @Cast("bool") boolean RayCast(b2RayCastOutput output, @Const @ByRef b2RayCastInput input, @Cast("int32") int childIndex);

	/** Get the mass data for this fixture. The mass data is based on the density and
	 *  the shape. The rotational inertia is about the shape's origin. This operation
	 *  may be expensive. */
	public native void GetMassData(b2MassData massData);

	/** Set the density of this fixture. This will _not_ automatically adjust the mass
	 *  of the body. You must call b2Body::ResetMassData to update the body's mass. */
	public native void SetDensity(@Cast("float32") float density);

	/** Get the density of this fixture. */
	public native @Cast("float32") float GetDensity();

	/** Get the coefficient of friction. */
	public native @Cast("float32") float GetFriction();

	/** Set the coefficient of friction. This will _not_ change the friction of
	 *  existing contacts. */
	public native void SetFriction(@Cast("float32") float friction);

	/** Get the coefficient of restitution. */
	public native @Cast("float32") float GetRestitution();

	/** Set the coefficient of restitution. This will _not_ change the restitution of
	 *  existing contacts. */
	public native void SetRestitution(@Cast("float32") float restitution);

	/** Get the fixture's AABB. This AABB may be enlarge and/or stale.
	 *  If you need a more accurate AABB, compute it using the shape and
	 *  the body transform. */
	public native @Const @ByRef b2AABB GetAABB(@Cast("int32") int childIndex);

	/** Dump this fixture to the log file. */
	public native void Dump(@Cast("int32") int bodyIndex);
}













































// #endif


// Parsed from <Box2D/Dynamics/b2WorldCallbacks.h>

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
* Copyright (c) 2013 Google, Inc.
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_WORLD_CALLBACKS_H
// #define B2_WORLD_CALLBACKS_H

// #include <Box2D/Common/b2Settings.h>
@Opaque public static class b2ContactResult extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public b2ContactResult() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ContactResult(Pointer p) { super(p); }
}

/** Joints and fixtures are destroyed when their associated
 *  body is destroyed. Implement this listener so that you
 *  may nullify references to these joints and shapes. */
public static class b2DestructionListener extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2DestructionListener() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2DestructionListener(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2DestructionListener(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2DestructionListener position(long position) {
        return (b2DestructionListener)super.position(position);
    }


	/** Called when any joint is about to be destroyed due
	 *  to the destruction of one of its attached bodies. */
	@Virtual(true) public native void SayGoodbye(b2Joint joint);

	/** Called when any fixture is about to be destroyed due
	 *  to the destruction of its parent body. */
	@Virtual(true) public native void SayGoodbye(b2Fixture fixture);

	/** Called when any particle group is about to be destroyed. */
	@Virtual public native void SayGoodbye(b2ParticleGroup group);

	/** Called when a particle is about to be destroyed.
	 *  The index can be used in conjunction with
	 *  b2ParticleSystem::GetUserDataBuffer() or
	 *  b2ParticleSystem::GetParticleHandleFromIndex() to determine which
	 *  particle has been destroyed. */
	@Virtual public native void SayGoodbye(b2ParticleSystem particleSystem, @Cast("int32") int index);
}

/** Implement this class to provide collision filtering. In other words, you can implement
 *  this class if you want finer control over contact creation. */
public static class b2ContactFilter extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2ContactFilter() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ContactFilter(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ContactFilter(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2ContactFilter position(long position) {
        return (b2ContactFilter)super.position(position);
    }


	/** Return true if contact calculations should be performed between these two shapes.
	 *  \warning for performance reasons this is only called when the AABBs begin to overlap. */
	@Virtual public native @Cast("bool") boolean ShouldCollide(b2Fixture fixtureA, b2Fixture fixtureB);

	/** Return true if contact calculations should be performed between a
	 *  fixture and particle.  This is only called if the
	 *  b2_fixtureContactListenerParticle flag is set on the particle. */
	@Virtual public native @Cast("bool") boolean ShouldCollide(b2Fixture fixture,
								   b2ParticleSystem particleSystem,
								   @Cast("int32") int particleIndex);

	/** Return true if contact calculations should be performed between two
	 *  particles.  This is only called if the
	 *  b2_particleContactListenerParticle flag is set on the particle. */
	@Virtual public native @Cast("bool") boolean ShouldCollide(b2ParticleSystem particleSystem,
								   @Cast("int32") int particleIndexA, @Cast("int32") int particleIndexB);
}

/** Contact impulses for reporting. Impulses are used instead of forces because
 *  sub-step forces may approach infinity for rigid body collisions. These
 *  match up one-to-one with the contact points in b2Manifold. */
public static class b2ContactImpulse extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2ContactImpulse() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ContactImpulse(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ContactImpulse(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2ContactImpulse position(long position) {
        return (b2ContactImpulse)super.position(position);
    }

	public native @Cast("float32") float normalImpulses(int i); public native b2ContactImpulse normalImpulses(int i, float normalImpulses);
	@MemberGetter public native @Cast("float32*") FloatPointer normalImpulses();
	public native @Cast("float32") float tangentImpulses(int i); public native b2ContactImpulse tangentImpulses(int i, float tangentImpulses);
	@MemberGetter public native @Cast("float32*") FloatPointer tangentImpulses();
	public native @Cast("int32") int count(); public native b2ContactImpulse count(int count);
}

/** Implement this class to get contact information. You can use these results for
 *  things like sounds and game logic. You can also get contact results by
 *  traversing the contact lists after the time step. However, you might miss
 *  some contacts because continuous physics leads to sub-stepping.
 *  Additionally you may receive multiple callbacks for the same contact in a
 *  single time step.
 *  You should strive to make your callbacks efficient because there may be
 *  many callbacks per time step.
 *  \warning You cannot create/destroy Box2D entities inside these callbacks. */
public static class b2ContactListener extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2ContactListener() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ContactListener(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ContactListener(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2ContactListener position(long position) {
        return (b2ContactListener)super.position(position);
    }


	/** Called when two fixtures begin to touch. */
	@Virtual public native void BeginContact(b2Contact contact);

	/** Called when two fixtures cease to touch. */
	@Virtual public native void EndContact(b2Contact contact);

	/** Called when a fixture and particle start touching if the
	 *  b2_fixtureContactFilterParticle flag is set on the particle. */
	@Virtual public native void BeginContact(b2ParticleSystem particleSystem,
								  b2ParticleBodyContact particleBodyContact);

	/** Called when a fixture and particle stop touching if the
	 *  b2_fixtureContactFilterParticle flag is set on the particle. */
	@Virtual public native void EndContact(b2Fixture fixture,
								b2ParticleSystem particleSystem, @Cast("int32") int index);

	/** Called when two particles start touching if
	 *  b2_particleContactFilterParticle flag is set on either particle. */
	@Virtual public native void BeginContact(b2ParticleSystem particleSystem,
								  b2ParticleContact particleContact);

	/** Called when two particles start touching if
	 *  b2_particleContactFilterParticle flag is set on either particle. */
	@Virtual public native void EndContact(b2ParticleSystem particleSystem,
								@Cast("int32") int indexA, @Cast("int32") int indexB);

	/** This is called after a contact is updated. This allows you to inspect a
	 *  contact before it goes to the solver. If you are careful, you can modify the
	 *  contact manifold (e.g. disable contact).
	 *  A copy of the old manifold is provided so that you can detect changes.
	 *  Note: this is called only for awake bodies.
	 *  Note: this is called even when the number of contact points is zero.
	 *  Note: this is not called for sensors.
	 *  Note: if you set the number of contact points to zero, you will not
	 *  get an EndContact callback. However, you may get a BeginContact callback
	 *  the next step. */
	@Virtual public native void PreSolve(b2Contact contact, @Const b2Manifold oldManifold);

	/** This lets you inspect a contact after the solver is finished. This is useful
	 *  for inspecting impulses.
	 *  Note: the contact manifold does not include time of impact impulses, which can be
	 *  arbitrarily large if the sub-step is small. Hence the impulse is provided explicitly
	 *  in a separate data structure.
	 *  Note: this is only called for contacts that are touching, solid, and awake. */
	@Virtual public native void PostSolve(b2Contact contact, @Const b2ContactImpulse impulse);
}

/** Callback class for AABB queries.
 *  See b2World::Query */
public static class b2QueryCallback extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2QueryCallback() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2QueryCallback(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2QueryCallback(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2QueryCallback position(long position) {
        return (b2QueryCallback)super.position(position);
    }


	/** Called for each fixture found in the query AABB.
	 *  @return false to terminate the query. */
	@Virtual(true) public native @Cast("bool") boolean ReportFixture(b2Fixture fixture);

	/** Called for each particle found in the query AABB.
	 *  @return false to terminate the query. */
	@Virtual public native @Cast("bool") boolean ReportParticle(@Const b2ParticleSystem particleSystem,
									@Cast("int32") int index);

	/** Cull an entire particle system from b2World::QueryAABB. Ignored for
	 *  b2ParticleSystem::QueryAABB.
	 *  @return true if you want to include particleSystem in the AABB query,
	 *  or false to cull particleSystem from the AABB query. */
	@Virtual public native @Cast("bool") boolean ShouldQueryParticleSystem(
			@Const b2ParticleSystem particleSystem);
}

/** Callback class for ray casts.
 *  See b2World::RayCast */
public static class b2RayCastCallback extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2RayCastCallback() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2RayCastCallback(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2RayCastCallback(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2RayCastCallback position(long position) {
        return (b2RayCastCallback)super.position(position);
    }


	/** Called for each fixture found in the query. You control how the ray cast
	 *  proceeds by returning a float:
	 *  return -1: ignore this fixture and continue
	 *  return 0: terminate the ray cast
	 *  return fraction: clip the ray to this point
	 *  return 1: don't clip the ray and continue
	 *  @param fixture the fixture hit by the ray
	 *  @param point the point of initial intersection
	 *  @param normal the normal vector at the point of intersection
	 *  @return -1 to filter, 0 to terminate, fraction to clip the ray for
	 *  closest hit, 1 to continue */
	@Virtual(true) public native @Cast("float32") float ReportFixture(	b2Fixture fixture, @Const @ByRef b2Vec2 point,
										@Const @ByRef b2Vec2 normal, @Cast("float32") float fraction);

	/** Called for each particle found in the query. You control how the ray
	 *  cast proceeds by returning a float:
	 *  return <=0: ignore the remaining particles in this particle system
	 *  return fraction: ignore particles that are 'fraction' percent farther
	 *    along the line from 'point1' to 'point2'. Note that 'point1' and
	 *    'point2' are parameters to b2World::RayCast.
	 *  @param particleSystem the particle system containing the particle
	 *  @param index the index of the particle in particleSystem
	 *  @param point the point of intersection bt the ray and the particle
	 *  @param normal the normal vector at the point of intersection
	 *  @param fraction percent (0.0~1.0) from 'point0' to 'point1' along the
	 *    ray. Note that 'point1' and 'point2' are parameters to
	 *    b2World::RayCast.
	 *  @return <=0 to ignore rest of particle system, fraction to ignore
	 *  particles that are farther away. */
	@Virtual public native @Cast("float32") float ReportParticle(@Const b2ParticleSystem particleSystem,
									   @Cast("int32") int index, @Const @ByRef b2Vec2 point,
									   @Const @ByRef b2Vec2 normal, @Cast("float32") float fraction);

	/** Cull an entire particle system from b2World::RayCast. Ignored in
	 *  b2ParticleSystem::RayCast.
	 *  @return true if you want to include particleSystem in the RayCast, or
	 *  false to cull particleSystem from the RayCast. */
	@Virtual public native @Cast("bool") boolean ShouldQueryParticleSystem(
			@Const b2ParticleSystem particleSystem);
}

// #endif


// Parsed from <Box2D/Dynamics/b2TimeStep.h>

/*
* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
* Copyright (c) 2014 Google, Inc.
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_TIME_STEP_H
// #define B2_TIME_STEP_H

// #include <Box2D/Common/b2Math.h>

/** Profiling data. Times are in milliseconds. */
public static class b2Profile extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2Profile() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Profile(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Profile(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2Profile position(long position) {
        return (b2Profile)super.position(position);
    }

	public native @Cast("float32") float step(); public native b2Profile step(float step);
	public native @Cast("float32") float collide(); public native b2Profile collide(float collide);
	public native @Cast("float32") float solve(); public native b2Profile solve(float solve);
	public native @Cast("float32") float solveInit(); public native b2Profile solveInit(float solveInit);
	public native @Cast("float32") float solveVelocity(); public native b2Profile solveVelocity(float solveVelocity);
	public native @Cast("float32") float solvePosition(); public native b2Profile solvePosition(float solvePosition);
	public native @Cast("float32") float broadphase(); public native b2Profile broadphase(float broadphase);
	public native @Cast("float32") float solveTOI(); public native b2Profile solveTOI(float solveTOI);
}

/** This is an internal structure. */
public static class b2TimeStep extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2TimeStep() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2TimeStep(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2TimeStep(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2TimeStep position(long position) {
        return (b2TimeStep)super.position(position);
    }

	public native @Cast("float32") float dt(); public native b2TimeStep dt(float dt);			// time step
	public native @Cast("float32") float inv_dt(); public native b2TimeStep inv_dt(float inv_dt);		// inverse time step (0 if dt == 0).
	public native @Cast("float32") float dtRatio(); public native b2TimeStep dtRatio(float dtRatio);	// dt * inv_dt0
	public native @Cast("int32") int velocityIterations(); public native b2TimeStep velocityIterations(int velocityIterations);
	public native @Cast("int32") int positionIterations(); public native b2TimeStep positionIterations(int positionIterations);
	public native @Cast("int32") int particleIterations(); public native b2TimeStep particleIterations(int particleIterations);
	public native @Cast("bool") boolean warmStarting(); public native b2TimeStep warmStarting(boolean warmStarting);
}

/** This is an internal structure. */
public static class b2Position extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2Position() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Position(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Position(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2Position position(long position) {
        return (b2Position)super.position(position);
    }

	public native @ByRef b2Vec2 c(); public native b2Position c(b2Vec2 c);
	public native @Cast("float32") float a(); public native b2Position a(float a);
}

/** This is an internal structure. */
public static class b2Velocity extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2Velocity() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Velocity(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Velocity(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2Velocity position(long position) {
        return (b2Velocity)super.position(position);
    }

	public native @ByRef b2Vec2 v(); public native b2Velocity v(b2Vec2 v);
	public native @Cast("float32") float w(); public native b2Velocity w(float w);
}

/** Solver Data */
public static class b2SolverData extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2SolverData() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2SolverData(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2SolverData(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2SolverData position(long position) {
        return (b2SolverData)super.position(position);
    }

	public native @ByRef b2TimeStep step(); public native b2SolverData step(b2TimeStep step);
	public native b2Position positions(); public native b2SolverData positions(b2Position positions);
	public native b2Velocity velocities(); public native b2SolverData velocities(b2Velocity velocities);
}

// #endif


// Parsed from <Box2D/Dynamics/b2World.h>

/*
* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
* Copyright (c) 2013 Google, Inc.
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_WORLD_H
// #define B2_WORLD_H

// #include <Box2D/Common/b2Math.h>
// #include <Box2D/Common/b2BlockAllocator.h>
// #include <Box2D/Common/b2StackAllocator.h>
// #include <Box2D/Dynamics/b2ContactManager.h>
// #include <Box2D/Dynamics/b2WorldCallbacks.h>
// #include <Box2D/Dynamics/b2TimeStep.h>
// #include <Box2D/Particle/b2ParticleSystem.h>

/** The world class manages all physics entities, dynamic simulation,
 *  and asynchronous queries. The world also contains efficient memory
 *  management facilities. */
@NoOffset public static class b2World extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2World(Pointer p) { super(p); }

	/** Construct a world object.
	 *  @param gravity the world gravity vector. */
	public b2World(@Const @ByRef b2Vec2 gravity) { super((Pointer)null); allocate(gravity); }
	private native void allocate(@Const @ByRef b2Vec2 gravity);

	/** Destruct the world. All physics entities are destroyed and all heap memory is released. */

	/** Register a destruction listener. The listener is owned by you and must
	 *  remain in scope. */
	public native void SetDestructionListener(b2DestructionListener listener);

	/** Register a contact filter to provide specific control over collision.
	 *  Otherwise the default filter is used (b2_defaultFilter). The listener is
	 *  owned by you and must remain in scope. */
	public native void SetContactFilter(b2ContactFilter filter);

	/** Register a contact event listener. The listener is owned by you and must
	 *  remain in scope. */
	public native void SetContactListener(b2ContactListener listener);

	/** Register a routine for debug drawing. The debug draw functions are called
	 *  inside with b2World::DrawDebugData method. The debug draw object is owned
	 *  by you and must remain in scope. */
	public native void SetDebugDraw(b2Draw debugDraw);

	/** Create a rigid body given a definition. No reference to the definition
	 *  is retained.
	 *  \warning This function is locked during callbacks. */
	public native b2Body CreateBody(@Const b2BodyDef def);

	/** Destroy a rigid body.
	 *  This function is locked during callbacks.
	 *  \warning This automatically deletes all associated shapes and joints.
	 *  \warning This function is locked during callbacks. */
	public native void DestroyBody(b2Body body);

	/** Create a joint to constrain bodies together. No reference to the definition
	 *  is retained. This may cause the connected bodies to cease colliding.
	 *  \warning This function is locked during callbacks. */
	public native b2Joint CreateJoint(@Const b2JointDef def);

	/** Destroy a joint. This may cause the connected bodies to begin colliding.
	 *  \warning This function is locked during callbacks. */
	public native void DestroyJoint(b2Joint joint);

	/** Create a particle system given a definition. No reference to the
	 *  definition is retained.
	 *  \warning This function is locked during callbacks. */
	public native b2ParticleSystem CreateParticleSystem(@Const b2ParticleSystemDef def);

	/** Destroy a particle system.
	 *  \warning This function is locked during callbacks. */
	public native void DestroyParticleSystem(b2ParticleSystem p);

	/** Take a time step. This performs collision detection, integration,
	 *  and constraint solution.
	 *  For the numerical stability of particles, minimize the following
	 *  dimensionless gravity acceleration:
	 *      gravity / particleRadius * (timeStep / particleIterations)^2
	 *  b2CalculateParticleIterations() or
	 *  CalculateReasonableParticleIterations() help to determine the optimal
	 *  particleIterations.
	 *  @param timeStep the amount of time to simulate, this should not vary.
	 *  @param velocityIterations for the velocity constraint solver.
	 *  @param positionIterations for the position constraint solver.
	 *  @param particleIterations for the particle simulation. */
	public native void Step(	@Cast("float32") float timeStep,
					@Cast("int32") int velocityIterations,
					@Cast("int32") int positionIterations,
					@Cast("int32") int particleIterations);

	/** Take a time step. This performs collision detection, integration,
	 *  and constraint solution.
	 *  @param timeStep the amount of time to simulate, this should not vary.
	 *  @param velocityIterations for the velocity constraint solver.
	 *  @param positionIterations for the position constraint solver. */
	public native void Step(	@Cast("float32") float timeStep,
					@Cast("int32") int velocityIterations,
					@Cast("int32") int positionIterations);

	/** Recommend a value to be used in {@code Step} for {@code particleIterations}.
	 *  This calculation is necessarily a simplification and should only be
	 *  used as a starting point. Please see "Particle Iterations" in the
	 *  Programmer's Guide for details.
	 *  @param timeStep is the value to be passed into {@code Step}. */
	public native int CalculateReasonableParticleIterations(@Cast("float32") float timeStep);

	/** Manually clear the force buffer on all bodies. By default, forces are cleared automatically
	 *  after each call to Step. The default behavior is modified by calling SetAutoClearForces.
	 *  The purpose of this function is to support sub-stepping. Sub-stepping is often used to maintain
	 *  a fixed sized time step under a variable frame-rate.
	 *  When you perform sub-stepping you will disable auto clearing of forces and instead call
	 *  ClearForces after all sub-steps are complete in one pass of your game loop.
	 *  @see SetAutoClearForces */
	public native void ClearForces();

	/** Call this to draw shapes and other debug draw data. This is intentionally non-const. */
	public native void DrawDebugData();

	/** Query the world for all fixtures that potentially overlap the
	 *  provided AABB.
	 *  @param callback a user implemented callback class.
	 *  @param aabb the query box. */
	public native void QueryAABB(b2QueryCallback callback, @Const @ByRef b2AABB aabb);

	/** Query the world for all fixtures that potentially overlap the
	 *  provided shape's AABB. Calls QueryAABB internally.
	 *  @param callback a user implemented callback class.
	 *  @param shape the query shape
	 *  @param xf the transform of the AABB */
	public native void QueryShapeAABB(b2QueryCallback callback, @Const @ByRef b2Shape shape,
		                    @Const @ByRef b2Transform xf);

	/** Ray-cast the world for all fixtures in the path of the ray. Your callback
	 *  controls whether you get the closest point, any point, or n-points.
	 *  The ray-cast ignores shapes that contain the starting point.
	 *  @param callback a user implemented callback class.
	 *  @param point1 the ray starting point
	 *  @param point2 the ray ending point */
	public native void RayCast(b2RayCastCallback callback, @Const @ByRef b2Vec2 point1, @Const @ByRef b2Vec2 point2);

	/** Get the world body list. With the returned body, use b2Body::GetNext to get
	 *  the next body in the world list. A NULL body indicates the end of the list.
	 *  @return the head of the world body list. */
	public native b2Body GetBodyList();

	/** Get the world joint list. With the returned joint, use b2Joint::GetNext to get
	 *  the next joint in the world list. A NULL joint indicates the end of the list.
	 *  @return the head of the world joint list. */
	public native b2Joint GetJointList();

	/** Get the world particle-system list. With the returned body, use
	 *  b2ParticleSystem::GetNext to get the next particle-system in the world
	 *  list. A NULL particle-system indicates the end of the list.
	 *  @return the head of the world particle-system list. */
	public native b2ParticleSystem GetParticleSystemList();

	/** Get the world contact list. With the returned contact, use b2Contact::GetNext to get
	 *  the next contact in the world list. A NULL contact indicates the end of the list.
	 *  @return the head of the world contact list.
	 *  \warning contacts are created and destroyed in the middle of a time step.
	 *  Use b2ContactListener to avoid missing contacts. */
	public native b2Contact GetContactList();

	/** Enable/disable sleep. */
	public native void SetAllowSleeping(@Cast("bool") boolean flag);
	public native @Cast("bool") boolean GetAllowSleeping();

	/** Enable/disable warm starting. For testing. */
	public native void SetWarmStarting(@Cast("bool") boolean flag);
	public native @Cast("bool") boolean GetWarmStarting();

	/** Enable/disable continuous physics. For testing. */
	public native void SetContinuousPhysics(@Cast("bool") boolean flag);
	public native @Cast("bool") boolean GetContinuousPhysics();

	/** Enable/disable single stepped continuous physics. For testing. */
	public native void SetSubStepping(@Cast("bool") boolean flag);
	public native @Cast("bool") boolean GetSubStepping();

	/** Get the number of broad-phase proxies. */
	public native @Cast("int32") int GetProxyCount();

	/** Get the number of bodies. */
	public native @Cast("int32") int GetBodyCount();

	/** Get the number of joints. */
	public native @Cast("int32") int GetJointCount();

	/** Get the number of contacts (each may have 0 or more contact points). */
	public native @Cast("int32") int GetContactCount();

	/** Get the height of the dynamic tree. */
	public native @Cast("int32") int GetTreeHeight();

	/** Get the balance of the dynamic tree. */
	public native @Cast("int32") int GetTreeBalance();

	/** Get the quality metric of the dynamic tree. The smaller the better.
	 *  The minimum is 1. */
	public native @Cast("float32") float GetTreeQuality();

	/** Change the global gravity vector. */
	public native void SetGravity(@Const @ByRef b2Vec2 gravity);

	/** Get the global gravity vector. */
	public native @ByVal b2Vec2 GetGravity();

	/** Is the world locked (in the middle of a time step). */
	public native @Cast("bool") boolean IsLocked();

	/** Set flag to control automatic clearing of forces after each time step. */
	public native void SetAutoClearForces(@Cast("bool") boolean flag);

	/** Get the flag that controls automatic clearing of forces after each time step. */
	public native @Cast("bool") boolean GetAutoClearForces();

	/** Shift the world origin. Useful for large worlds.
	 *  The body shift formula is: position -= newOrigin
	 *  @param newOrigin the new origin with respect to the old origin */
	public native void ShiftOrigin(@Const @ByRef b2Vec2 newOrigin);

	/** Get the contact manager for testing. */
	public native @Const @ByRef b2ContactManager GetContactManager();

	/** Get the current profile. */
	public native @Const @ByRef b2Profile GetProfile();

	/** Dump the world into the log file.
	 *  \warning this should be called outside of a time step. */
	public native void Dump();

	/** Get API version. */
	public native @Const b2Version GetVersion();

	/** Get API version string. */
	public native @Cast("const char*") BytePointer GetVersionString();
	/** Constructor which takes direct floats. */
	public b2World(@Cast("float32") float gravityX, @Cast("float32") float gravityY) { super((Pointer)null); allocate(gravityX, gravityY); }
	private native void allocate(@Cast("float32") float gravityX, @Cast("float32") float gravityY);

	/** Set gravity with direct floats. */
	public native void SetGravity(@Cast("float32") float gravityX, @Cast("float32") float gravityY);
}































/** Get the flag that controls automatic clearing of forces after each time step. */






// #if LIQUIDFUN_EXTERNAL_LANGUAGE_API



// #endif // LIQUIDFUN_EXTERNAL_LANGUAGE_API

// #endif


// Parsed from <Box2D/Dynamics/b2ContactManager.h>

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_CONTACT_MANAGER_H
// #define B2_CONTACT_MANAGER_H

// #include <Box2D/Collision/b2BroadPhase.h>

// Delegate of b2World.
@NoOffset public static class b2ContactManager extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ContactManager(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ContactManager(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2ContactManager position(long position) {
        return (b2ContactManager)super.position(position);
    }


	public b2ContactManager() { super((Pointer)null); allocate(); }
	private native void allocate();

	// Broad-phase callback.
	public native void AddPair(Pointer proxyUserDataA, Pointer proxyUserDataB);

	public native void FindNewContacts();

	public native void Destroy(b2Contact c);

	public native void Collide();
            
	public native @ByRef b2BroadPhase m_broadPhase(); public native b2ContactManager m_broadPhase(b2BroadPhase m_broadPhase);
	public native b2Contact m_contactList(); public native b2ContactManager m_contactList(b2Contact m_contactList);
	public native @Cast("int32") int m_contactCount(); public native b2ContactManager m_contactCount(int m_contactCount);
	public native b2ContactFilter m_contactFilter(); public native b2ContactManager m_contactFilter(b2ContactFilter m_contactFilter);
	public native b2ContactListener m_contactListener(); public native b2ContactManager m_contactListener(b2ContactListener m_contactListener);
	public native b2BlockAllocator m_allocator(); public native b2ContactManager m_allocator(b2BlockAllocator m_allocator);
}

// #endif


// Parsed from <Box2D/Dynamics/Contacts/b2Contact.h>

/*
* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_CONTACT_H
// #define B2_CONTACT_H

// #include <Box2D/Common/b2Math.h>
// #include <Box2D/Collision/b2Collision.h>
// #include <Box2D/Collision/Shapes/b2Shape.h>
// #include <Box2D/Dynamics/b2Fixture.h>
@Opaque public static class b2StackAllocator extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public b2StackAllocator() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2StackAllocator(Pointer p) { super(p); }
}

/** Friction mixing law. The idea is to allow either fixture to drive the restitution to zero.
 *  For example, anything slides on ice. */
public static native @Cast("float32") float b2MixFriction(@Cast("float32") float friction1, @Cast("float32") float friction2);

/** Restitution mixing law. The idea is allow for anything to bounce off an inelastic surface.
 *  For example, a superball bounces on anything. */
public static native @Cast("float32") float b2MixRestitution(@Cast("float32") float restitution1, @Cast("float32") float restitution2);

public static class b2ContactCreateFcn extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    b2ContactCreateFcn(Pointer p) { super(p); }
    protected b2ContactCreateFcn() { allocate(); }
    private native void allocate();
    public native b2Contact call(	b2Fixture fixtureA, @Cast("int32") int indexA,
										b2Fixture fixtureB, @Cast("int32") int indexB,
										b2BlockAllocator allocator);
}
public static class b2ContactDestroyFcn extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    b2ContactDestroyFcn(Pointer p) { super(p); }
    protected b2ContactDestroyFcn() { allocate(); }
    private native void allocate();
    public native void call(b2Contact contact, b2BlockAllocator allocator);
}

public static class b2ContactRegister extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2ContactRegister() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ContactRegister(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ContactRegister(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2ContactRegister position(long position) {
        return (b2ContactRegister)super.position(position);
    }

	public native b2ContactCreateFcn createFcn(); public native b2ContactRegister createFcn(b2ContactCreateFcn createFcn);
	public native b2ContactDestroyFcn destroyFcn(); public native b2ContactRegister destroyFcn(b2ContactDestroyFcn destroyFcn);
	public native @Cast("bool") boolean primary(); public native b2ContactRegister primary(boolean primary);
}

/** A contact edge is used to connect bodies and contacts together
 *  in a contact graph where each body is a node and each contact
 *  is an edge. A contact edge belongs to a doubly linked list
 *  maintained in each attached body. Each contact has two contact
 *  nodes, one for each attached body. */
public static class b2ContactEdge extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2ContactEdge() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ContactEdge(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ContactEdge(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2ContactEdge position(long position) {
        return (b2ContactEdge)super.position(position);
    }

	/** provides quick access to the other body attached. */
	public native b2Body other(); public native b2ContactEdge other(b2Body other);
	/** the contact */
	public native b2Contact contact(); public native b2ContactEdge contact(b2Contact contact);
	/** the previous contact edge in the body's contact list */
	public native b2ContactEdge prev(); public native b2ContactEdge prev(b2ContactEdge prev);
	/** the next contact edge in the body's contact list */
	public native b2ContactEdge next(); public native b2ContactEdge next(b2ContactEdge next);
}

/** The class manages contact between two shapes. A contact exists for each overlapping
 *  AABB in the broad-phase (except if filtered). Therefore a contact object may exist
 *  that has no contact points. */
@NoOffset public static class b2Contact extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Contact(Pointer p) { super(p); }


	/** Get the contact manifold. Do not modify the manifold unless you understand the
	 *  internals of Box2D. */
	public native b2Manifold GetManifold();

	/** Get the world manifold. */
	public native void GetWorldManifold(b2WorldManifold worldManifold);

	/** Is this contact touching? */
	public native @Cast("bool") boolean IsTouching();

	/** Enable/disable this contact. This can be used inside the pre-solve
	 *  contact listener. The contact is only disabled for the current
	 *  time step (or sub-step in continuous collisions). */
	public native void SetEnabled(@Cast("bool") boolean flag);

	/** Has this contact been disabled? */
	public native @Cast("bool") boolean IsEnabled();

	/** Get the next contact in the world's contact list. */
	public native b2Contact GetNext();

	/** Get fixture A in this contact. */
	public native b2Fixture GetFixtureA();

	/** Get the child primitive index for fixture A. */
	public native @Cast("int32") int GetChildIndexA();

	/** Get fixture B in this contact. */
	public native b2Fixture GetFixtureB();

	/** Get the child primitive index for fixture B. */
	public native @Cast("int32") int GetChildIndexB();

	/** Override the default friction mixture. You can call this in b2ContactListener::PreSolve.
	 *  This value persists until set or reset. */
	public native void SetFriction(@Cast("float32") float friction);

	/** Get the friction. */
	public native @Cast("float32") float GetFriction();

	/** Reset the friction mixture to the default value. */
	public native void ResetFriction();

	/** Override the default restitution mixture. You can call this in b2ContactListener::PreSolve.
	 *  The value persists until you set or reset. */
	public native void SetRestitution(@Cast("float32") float restitution);

	/** Get the restitution. */
	public native @Cast("float32") float GetRestitution();

	/** Reset the restitution to the default value. */
	public native void ResetRestitution();

	/** Set the desired tangent speed for a conveyor belt behavior. In meters per second. */
	public native void SetTangentSpeed(@Cast("float32") float speed);

	/** Get the desired tangent speed. In meters per second. */
	public native @Cast("float32") float GetTangentSpeed();

	/** Evaluate this contact with your own manifold and transforms. */
	public native void Evaluate(b2Manifold manifold, @Const @ByRef b2Transform xfA, @Const @ByRef b2Transform xfB);
}















































// #endif


// Parsed from <Box2D/Dynamics/Joints/b2Joint.h>

/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_JOINT_H
// #define B2_JOINT_H

// #include <Box2D/Common/b2Math.h>

/** enum b2JointType */
public static final int
	e_unknownJoint = 0,
	e_revoluteJoint = 1,
	e_prismaticJoint = 2,
	e_distanceJoint = 3,
	e_pulleyJoint = 4,
	e_mouseJoint = 5,
	e_gearJoint = 6,
	e_wheelJoint = 7,
    e_weldJoint = 8,
	e_frictionJoint = 9,
	e_ropeJoint = 10,
	e_motorJoint = 11;

/** enum b2LimitState */
public static final int
	e_inactiveLimit = 0,
	e_atLowerLimit = 1,
	e_atUpperLimit = 2,
	e_equalLimits = 3;

public static class b2Jacobian extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2Jacobian() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2Jacobian(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Jacobian(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2Jacobian position(long position) {
        return (b2Jacobian)super.position(position);
    }

	public native @ByRef b2Vec2 linear(); public native b2Jacobian linear(b2Vec2 linear);
	public native @Cast("float32") float angularA(); public native b2Jacobian angularA(float angularA);
	public native @Cast("float32") float angularB(); public native b2Jacobian angularB(float angularB);
}

/** A joint edge is used to connect bodies and joints together
 *  in a joint graph where each body is a node and each joint
 *  is an edge. A joint edge belongs to a doubly linked list
 *  maintained in each attached body. Each joint has two joint
 *  nodes, one for each attached body. */
public static class b2JointEdge extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2JointEdge() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2JointEdge(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2JointEdge(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2JointEdge position(long position) {
        return (b2JointEdge)super.position(position);
    }

	/** provides quick access to the other body attached. */
	public native b2Body other(); public native b2JointEdge other(b2Body other);
	/** the joint */
	public native b2Joint joint(); public native b2JointEdge joint(b2Joint joint);
	/** the previous joint edge in the body's joint list */
	public native b2JointEdge prev(); public native b2JointEdge prev(b2JointEdge prev);
	/** the next joint edge in the body's joint list */
	public native b2JointEdge next(); public native b2JointEdge next(b2JointEdge next);
}

/** Joint definitions are used to construct joints. */
@NoOffset public static class b2JointDef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2JointDef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2JointDef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2JointDef position(long position) {
        return (b2JointDef)super.position(position);
    }

	public b2JointDef() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** The joint type is set automatically for concrete joint types. */
	public native @Cast("b2JointType") int type(); public native b2JointDef type(int type);

	/** Use this to attach application specific data to your joints. */
	public native Pointer userData(); public native b2JointDef userData(Pointer userData);

	/** The first attached body. */
	public native b2Body bodyA(); public native b2JointDef bodyA(b2Body bodyA);

	/** The second attached body. */
	public native b2Body bodyB(); public native b2JointDef bodyB(b2Body bodyB);

	/** Set this flag to true if the attached bodies should collide. */
	public native @Cast("bool") boolean collideConnected(); public native b2JointDef collideConnected(boolean collideConnected);
}

/** The base joint class. Joints are used to constraint two bodies together in
 *  various fashions. Some joints also feature limits and motors. */
@NoOffset public static class b2Joint extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2Joint(Pointer p) { super(p); }


	/** Get the type of the concrete joint. */
	public native @Cast("b2JointType") int GetType();

	/** Get the first body attached to this joint. */
	public native b2Body GetBodyA();

	/** Get the second body attached to this joint. */
	public native b2Body GetBodyB();

	/** Get the anchor point on bodyA in world coordinates. */
	public native @ByVal b2Vec2 GetAnchorA();

	/** Get the anchor point on bodyB in world coordinates. */
	public native @ByVal b2Vec2 GetAnchorB();

	/** Get the reaction force on bodyB at the joint anchor in Newtons. */
	public native @ByVal b2Vec2 GetReactionForce(@Cast("float32") float inv_dt);

	/** Get the reaction torque on bodyB in N*m. */
	public native @Cast("float32") float GetReactionTorque(@Cast("float32") float inv_dt);

	/** Get the next joint the world joint list. */
	public native b2Joint GetNext();

	/** Get the user data pointer. */
	public native Pointer GetUserData();

	/** Set the user data pointer. */
	public native void SetUserData(Pointer data);

	/** Short-cut function to determine if either body is inactive. */
	public native @Cast("bool") boolean IsActive();

	/** Get collide connected.
	 *  Note: modifying the collide connect flag won't work correctly because
	 *  the flag is only checked when fixture AABBs begin to overlap. */
	public native @Cast("bool") boolean GetCollideConnected();

	/** Dump this joint to the log file. */
	public native void Dump();

	/** Shift the origin for any points stored in world coordinates. */
	public native void ShiftOrigin(@Const @ByRef b2Vec2 newOrigin);
}

















// #endif


// Parsed from <Box2D/Dynamics/Joints/b2DistanceJoint.h>

/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_DISTANCE_JOINT_H
// #define B2_DISTANCE_JOINT_H

// #include <Box2D/Dynamics/Joints/b2Joint.h>

/** Distance joint definition. This requires defining an
 *  anchor point on both bodies and the non-zero length of the
 *  distance joint. The definition uses local anchor points
 *  so that the initial configuration can violate the constraint
 *  slightly. This helps when saving and loading a game.
 *  \warning Do not use a zero or short length. */
@NoOffset public static class b2DistanceJointDef extends b2JointDef {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2DistanceJointDef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2DistanceJointDef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2DistanceJointDef position(long position) {
        return (b2DistanceJointDef)super.position(position);
    }

	public b2DistanceJointDef() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Initialize the bodies, anchors, and length using the world
	 *  anchors. */
	public native void Initialize(b2Body bodyA, b2Body bodyB,
						@Const @ByRef b2Vec2 anchorA, @Const @ByRef b2Vec2 anchorB);

	/** The local anchor point relative to bodyA's origin. */
	public native @ByRef b2Vec2 localAnchorA(); public native b2DistanceJointDef localAnchorA(b2Vec2 localAnchorA);

	/** The local anchor point relative to bodyB's origin. */
	public native @ByRef b2Vec2 localAnchorB(); public native b2DistanceJointDef localAnchorB(b2Vec2 localAnchorB);

	/** The natural length between the anchor points. */
	public native @Cast("float32") float length(); public native b2DistanceJointDef length(float length);

	/** The mass-spring-damper frequency in Hertz. A value of 0
	 *  disables softness. */
	public native @Cast("float32") float frequencyHz(); public native b2DistanceJointDef frequencyHz(float frequencyHz);

	/** The damping ratio. 0 = no damping, 1 = critical damping. */
	public native @Cast("float32") float dampingRatio(); public native b2DistanceJointDef dampingRatio(float dampingRatio);
}

/** A distance joint constrains two points on two bodies
 *  to remain at a fixed distance from each other. You can view
 *  this as a massless, rigid rod. */
@NoOffset public static class b2DistanceJoint extends b2Joint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2DistanceJoint(Pointer p) { super(p); }


	public native @ByVal b2Vec2 GetAnchorA();
	public native @ByVal b2Vec2 GetAnchorB();

	/** Get the reaction force given the inverse time step.
	 *  Unit is N. */
	public native @ByVal b2Vec2 GetReactionForce(@Cast("float32") float inv_dt);

	/** Get the reaction torque given the inverse time step.
	 *  Unit is N*m. This is always zero for a distance joint. */
	public native @Cast("float32") float GetReactionTorque(@Cast("float32") float inv_dt);

	/** The local anchor point relative to bodyA's origin. */
	public native @Const @ByRef b2Vec2 GetLocalAnchorA();

	/** The local anchor point relative to bodyB's origin. */
	public native @Const @ByRef b2Vec2 GetLocalAnchorB();

	/** Set/get the natural length.
	 *  Manipulating the length can lead to non-physical behavior when the frequency is zero. */
	public native void SetLength(@Cast("float32") float length);
	public native @Cast("float32") float GetLength();

	/** Set/get frequency in Hz. */
	public native void SetFrequency(@Cast("float32") float hz);
	public native @Cast("float32") float GetFrequency();

	/** Set/get damping ratio. */
	public native void SetDampingRatio(@Cast("float32") float ratio);
	public native @Cast("float32") float GetDampingRatio();

	/** Dump joint to dmLog */
	public native void Dump();
}













// #endif


// Parsed from <Box2D/Dynamics/Joints/b2FrictionJoint.h>

/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_FRICTION_JOINT_H
// #define B2_FRICTION_JOINT_H

// #include <Box2D/Dynamics/Joints/b2Joint.h>

/** Friction joint definition. */
@NoOffset public static class b2FrictionJointDef extends b2JointDef {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2FrictionJointDef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2FrictionJointDef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2FrictionJointDef position(long position) {
        return (b2FrictionJointDef)super.position(position);
    }

	public b2FrictionJointDef() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Initialize the bodies, anchors, axis, and reference angle using the world
	 *  anchor and world axis. */
	public native void Initialize(b2Body bodyA, b2Body bodyB, @Const @ByRef b2Vec2 anchor);

	/** The local anchor point relative to bodyA's origin. */
	public native @ByRef b2Vec2 localAnchorA(); public native b2FrictionJointDef localAnchorA(b2Vec2 localAnchorA);

	/** The local anchor point relative to bodyB's origin. */
	public native @ByRef b2Vec2 localAnchorB(); public native b2FrictionJointDef localAnchorB(b2Vec2 localAnchorB);

	/** The maximum friction force in N. */
	public native @Cast("float32") float maxForce(); public native b2FrictionJointDef maxForce(float maxForce);

	/** The maximum friction torque in N-m. */
	public native @Cast("float32") float maxTorque(); public native b2FrictionJointDef maxTorque(float maxTorque);
}

/** Friction joint. This is used for top-down friction.
 *  It provides 2D translational friction and angular friction. */
@NoOffset public static class b2FrictionJoint extends b2Joint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2FrictionJoint(Pointer p) { super(p); }

	public native @ByVal b2Vec2 GetAnchorA();
	public native @ByVal b2Vec2 GetAnchorB();

	public native @ByVal b2Vec2 GetReactionForce(@Cast("float32") float inv_dt);
	public native @Cast("float32") float GetReactionTorque(@Cast("float32") float inv_dt);

	/** The local anchor point relative to bodyA's origin. */
	public native @Const @ByRef b2Vec2 GetLocalAnchorA();

	/** The local anchor point relative to bodyB's origin. */
	public native @Const @ByRef b2Vec2 GetLocalAnchorB();

	/** Set the maximum friction force in N. */
	public native void SetMaxForce(@Cast("float32") float force);

	/** Get the maximum friction force in N. */
	public native @Cast("float32") float GetMaxForce();

	/** Set the maximum friction torque in N*m. */
	public native void SetMaxTorque(@Cast("float32") float torque);

	/** Get the maximum friction torque in N*m. */
	public native @Cast("float32") float GetMaxTorque();

	/** Dump joint to dmLog */
	public native void Dump();
}

// #endif


// Parsed from <Box2D/Dynamics/Joints/b2GearJoint.h>

/*
* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_GEAR_JOINT_H
// #define B2_GEAR_JOINT_H

// #include <Box2D/Dynamics/Joints/b2Joint.h>

/** Gear joint definition. This definition requires two existing
 *  revolute or prismatic joints (any combination will work). */
@NoOffset public static class b2GearJointDef extends b2JointDef {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2GearJointDef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2GearJointDef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2GearJointDef position(long position) {
        return (b2GearJointDef)super.position(position);
    }

	public b2GearJointDef() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** The first revolute/prismatic joint attached to the gear joint. */
	public native b2Joint joint1(); public native b2GearJointDef joint1(b2Joint joint1);

	/** The second revolute/prismatic joint attached to the gear joint. */
	public native b2Joint joint2(); public native b2GearJointDef joint2(b2Joint joint2);

	/** The gear ratio.
	 *  @see b2GearJoint for explanation. */
	public native @Cast("float32") float ratio(); public native b2GearJointDef ratio(float ratio);
}

/** A gear joint is used to connect two joints together. Either joint
 *  can be a revolute or prismatic joint. You specify a gear ratio
 *  to bind the motions together:
 *  coordinate1 + ratio * coordinate2 = constant
 *  The ratio can be negative or positive. If one joint is a revolute joint
 *  and the other joint is a prismatic joint, then the ratio will have units
 *  of length or units of 1/length.
 *  \warning You have to manually destroy the gear joint if joint1 or joint2
 *  is destroyed. */
@NoOffset public static class b2GearJoint extends b2Joint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2GearJoint(Pointer p) { super(p); }

	public native @ByVal b2Vec2 GetAnchorA();
	public native @ByVal b2Vec2 GetAnchorB();

	public native @ByVal b2Vec2 GetReactionForce(@Cast("float32") float inv_dt);
	public native @Cast("float32") float GetReactionTorque(@Cast("float32") float inv_dt);

	/** Get the first joint. */
	public native b2Joint GetJoint1();

	/** Get the second joint. */
	public native b2Joint GetJoint2();

	/** Set/Get the gear ratio. */
	public native void SetRatio(@Cast("float32") float ratio);
	public native @Cast("float32") float GetRatio();

	/** Dump joint to dmLog */
	public native void Dump();
}

// #endif


// Parsed from <Box2D/Dynamics/Joints/b2MotorJoint.h>

/*
* Copyright (c) 2006-2012 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_MOTOR_JOINT_H
// #define B2_MOTOR_JOINT_H

// #include <Box2D/Dynamics/Joints/b2Joint.h>

/** Motor joint definition. */
@NoOffset public static class b2MotorJointDef extends b2JointDef {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2MotorJointDef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2MotorJointDef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2MotorJointDef position(long position) {
        return (b2MotorJointDef)super.position(position);
    }

	public b2MotorJointDef() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Initialize the bodies and offsets using the current transforms. */
	public native void Initialize(b2Body bodyA, b2Body bodyB);

	/** Position of bodyB minus the position of bodyA, in bodyA's frame, in meters. */
	public native @ByRef b2Vec2 linearOffset(); public native b2MotorJointDef linearOffset(b2Vec2 linearOffset);

	/** The bodyB angle minus bodyA angle in radians. */
	public native @Cast("float32") float angularOffset(); public native b2MotorJointDef angularOffset(float angularOffset);
	
	/** The maximum motor force in N. */
	public native @Cast("float32") float maxForce(); public native b2MotorJointDef maxForce(float maxForce);

	/** The maximum motor torque in N-m. */
	public native @Cast("float32") float maxTorque(); public native b2MotorJointDef maxTorque(float maxTorque);

	/** Position correction factor in the range [0,1]. */
	public native @Cast("float32") float correctionFactor(); public native b2MotorJointDef correctionFactor(float correctionFactor);
}

/** A motor joint is used to control the relative motion
 *  between two bodies. A typical usage is to control the movement
 *  of a dynamic body with respect to the ground. */
@NoOffset public static class b2MotorJoint extends b2Joint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2MotorJoint(Pointer p) { super(p); }

	public native @ByVal b2Vec2 GetAnchorA();
	public native @ByVal b2Vec2 GetAnchorB();

	public native @ByVal b2Vec2 GetReactionForce(@Cast("float32") float inv_dt);
	public native @Cast("float32") float GetReactionTorque(@Cast("float32") float inv_dt);

	/** Set/get the target linear offset, in frame A, in meters. */
	public native void SetLinearOffset(@Const @ByRef b2Vec2 linearOffset);
	public native @Const @ByRef b2Vec2 GetLinearOffset();

	/** Set/get the target angular offset, in radians. */
	public native void SetAngularOffset(@Cast("float32") float angularOffset);
	public native @Cast("float32") float GetAngularOffset();

	/** Set the maximum friction force in N. */
	public native void SetMaxForce(@Cast("float32") float force);

	/** Get the maximum friction force in N. */
	public native @Cast("float32") float GetMaxForce();

	/** Set the maximum friction torque in N*m. */
	public native void SetMaxTorque(@Cast("float32") float torque);

	/** Get the maximum friction torque in N*m. */
	public native @Cast("float32") float GetMaxTorque();

	/** Set the position correction factor in the range [0,1]. */
	public native void SetCorrectionFactor(@Cast("float32") float factor);

	/** Get the position correction factor in the range [0,1]. */
	public native @Cast("float32") float GetCorrectionFactor();

	/** Dump to b2Log */
	public native void Dump();
}

// #endif


// Parsed from <Box2D/Dynamics/Joints/b2MouseJoint.h>

/*
* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_MOUSE_JOINT_H
// #define B2_MOUSE_JOINT_H

// #include <Box2D/Dynamics/Joints/b2Joint.h>

/** Mouse joint definition. This requires a world target point,
 *  tuning parameters, and the time step. */
@NoOffset public static class b2MouseJointDef extends b2JointDef {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2MouseJointDef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2MouseJointDef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2MouseJointDef position(long position) {
        return (b2MouseJointDef)super.position(position);
    }

	public b2MouseJointDef() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** The initial world target point. This is assumed
	 *  to coincide with the body anchor initially. */
	public native @ByRef b2Vec2 target(); public native b2MouseJointDef target(b2Vec2 target);

	/** The maximum constraint force that can be exerted
	 *  to move the candidate body. Usually you will express
	 *  as some multiple of the weight (multiplier * mass * gravity). */
	public native @Cast("float32") float maxForce(); public native b2MouseJointDef maxForce(float maxForce);

	/** The response speed. */
	public native @Cast("float32") float frequencyHz(); public native b2MouseJointDef frequencyHz(float frequencyHz);

	/** The damping ratio. 0 = no damping, 1 = critical damping. */
	public native @Cast("float32") float dampingRatio(); public native b2MouseJointDef dampingRatio(float dampingRatio);
}

/** A mouse joint is used to make a point on a body track a
 *  specified world point. This a soft constraint with a maximum
 *  force. This allows the constraint to stretch and without
 *  applying huge forces.
 *  NOTE: this joint is not documented in the manual because it was
 *  developed to be used in the testbed. If you want to learn how to
 *  use the mouse joint, look at the testbed. */
@NoOffset public static class b2MouseJoint extends b2Joint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2MouseJoint(Pointer p) { super(p); }


	/** Implements b2Joint. */
	public native @ByVal b2Vec2 GetAnchorA();

	/** Implements b2Joint. */
	public native @ByVal b2Vec2 GetAnchorB();

	/** Implements b2Joint. */
	public native @ByVal b2Vec2 GetReactionForce(@Cast("float32") float inv_dt);

	/** Implements b2Joint. */
	public native @Cast("float32") float GetReactionTorque(@Cast("float32") float inv_dt);

	/** Use this to update the target point. */
	public native void SetTarget(@Const @ByRef b2Vec2 target);
	public native @Const @ByRef b2Vec2 GetTarget();

	/** Set/get the maximum force in Newtons. */
	public native void SetMaxForce(@Cast("float32") float force);
	public native @Cast("float32") float GetMaxForce();

	/** Set/get the frequency in Hertz. */
	public native void SetFrequency(@Cast("float32") float hz);
	public native @Cast("float32") float GetFrequency();

	/** Set/get the damping ratio (dimensionless). */
	public native void SetDampingRatio(@Cast("float32") float ratio);
	public native @Cast("float32") float GetDampingRatio();

	/** The mouse joint does not support dumping. */
	public native void Dump();

	/** Implement b2Joint::ShiftOrigin */
	public native void ShiftOrigin(@Const @ByRef b2Vec2 newOrigin);
}

// #endif


// Parsed from <Box2D/Dynamics/Joints/b2PrismaticJoint.h>

/*
* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_PRISMATIC_JOINT_H
// #define B2_PRISMATIC_JOINT_H

// #include <Box2D/Dynamics/Joints/b2Joint.h>

/** Prismatic joint definition. This requires defining a line of
 *  motion using an axis and an anchor point. The definition uses local
 *  anchor points and a local axis so that the initial configuration
 *  can violate the constraint slightly. The joint translation is zero
 *  when the local anchor points coincide in world space. Using local
 *  anchors and a local axis helps when saving and loading a game. */
@NoOffset public static class b2PrismaticJointDef extends b2JointDef {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2PrismaticJointDef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2PrismaticJointDef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2PrismaticJointDef position(long position) {
        return (b2PrismaticJointDef)super.position(position);
    }

	public b2PrismaticJointDef() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Initialize the bodies, anchors, axis, and reference angle using the world
	 *  anchor and unit world axis. */
	public native void Initialize(b2Body bodyA, b2Body bodyB, @Const @ByRef b2Vec2 anchor, @Const @ByRef b2Vec2 axis);

	/** The local anchor point relative to bodyA's origin. */
	public native @ByRef b2Vec2 localAnchorA(); public native b2PrismaticJointDef localAnchorA(b2Vec2 localAnchorA);

	/** The local anchor point relative to bodyB's origin. */
	public native @ByRef b2Vec2 localAnchorB(); public native b2PrismaticJointDef localAnchorB(b2Vec2 localAnchorB);

	/** The local translation unit axis in bodyA. */
	public native @ByRef b2Vec2 localAxisA(); public native b2PrismaticJointDef localAxisA(b2Vec2 localAxisA);

	/** The constrained angle between the bodies: bodyB_angle - bodyA_angle. */
	public native @Cast("float32") float referenceAngle(); public native b2PrismaticJointDef referenceAngle(float referenceAngle);

	/** Enable/disable the joint limit. */
	public native @Cast("bool") boolean enableLimit(); public native b2PrismaticJointDef enableLimit(boolean enableLimit);

	/** The lower translation limit, usually in meters. */
	public native @Cast("float32") float lowerTranslation(); public native b2PrismaticJointDef lowerTranslation(float lowerTranslation);

	/** The upper translation limit, usually in meters. */
	public native @Cast("float32") float upperTranslation(); public native b2PrismaticJointDef upperTranslation(float upperTranslation);

	/** Enable/disable the joint motor. */
	public native @Cast("bool") boolean enableMotor(); public native b2PrismaticJointDef enableMotor(boolean enableMotor);

	/** The maximum motor torque, usually in N-m. */
	public native @Cast("float32") float maxMotorForce(); public native b2PrismaticJointDef maxMotorForce(float maxMotorForce);

	/** The desired motor speed in radians per second. */
	public native @Cast("float32") float motorSpeed(); public native b2PrismaticJointDef motorSpeed(float motorSpeed);
}

/** A prismatic joint. This joint provides one degree of freedom: translation
 *  along an axis fixed in bodyA. Relative rotation is prevented. You can
 *  use a joint limit to restrict the range of motion and a joint motor to
 *  drive the motion or to model joint friction. */
@NoOffset public static class b2PrismaticJoint extends b2Joint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2PrismaticJoint(Pointer p) { super(p); }

	public native @ByVal b2Vec2 GetAnchorA();
	public native @ByVal b2Vec2 GetAnchorB();

	public native @ByVal b2Vec2 GetReactionForce(@Cast("float32") float inv_dt);
	public native @Cast("float32") float GetReactionTorque(@Cast("float32") float inv_dt);

	/** The local anchor point relative to bodyA's origin. */
	public native @Const @ByRef b2Vec2 GetLocalAnchorA();

	/** The local anchor point relative to bodyB's origin. */
	public native @Const @ByRef b2Vec2 GetLocalAnchorB();

	/** The local joint axis relative to bodyA. */
	public native @Const @ByRef b2Vec2 GetLocalAxisA();

	/** Get the reference angle. */
	public native @Cast("float32") float GetReferenceAngle();

	/** Get the current joint translation, usually in meters. */
	public native @Cast("float32") float GetJointTranslation();

	/** Get the current joint translation speed, usually in meters per second. */
	public native @Cast("float32") float GetJointSpeed();

	/** Is the joint limit enabled? */
	public native @Cast("bool") boolean IsLimitEnabled();

	/** Enable/disable the joint limit. */
	public native void EnableLimit(@Cast("bool") boolean flag);

	/** Get the lower joint limit, usually in meters. */
	public native @Cast("float32") float GetLowerLimit();

	/** Get the upper joint limit, usually in meters. */
	public native @Cast("float32") float GetUpperLimit();

	/** Set the joint limits, usually in meters. */
	public native void SetLimits(@Cast("float32") float lower, @Cast("float32") float upper);

	/** Is the joint motor enabled? */
	public native @Cast("bool") boolean IsMotorEnabled();

	/** Enable/disable the joint motor. */
	public native void EnableMotor(@Cast("bool") boolean flag);

	/** Set the motor speed, usually in meters per second. */
	public native void SetMotorSpeed(@Cast("float32") float speed);

	/** Get the motor speed, usually in meters per second. */
	public native @Cast("float32") float GetMotorSpeed();

	/** Set the maximum motor force, usually in N. */
	public native void SetMaxMotorForce(@Cast("float32") float force);
	public native @Cast("float32") float GetMaxMotorForce();

	/** Get the current motor force given the inverse time step, usually in N. */
	public native @Cast("float32") float GetMotorForce(@Cast("float32") float inv_dt);

	/** Dump to b2Log */
	public native void Dump();
}



// #endif


// Parsed from <Box2D/Dynamics/Joints/b2PulleyJoint.h>

/*
* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_PULLEY_JOINT_H
// #define B2_PULLEY_JOINT_H

// #include <Box2D/Dynamics/Joints/b2Joint.h>

@MemberGetter public static native @Cast("const float32") float b2_minPulleyLength();

/** Pulley joint definition. This requires two ground anchors,
 *  two dynamic body anchor points, and a pulley ratio. */
@NoOffset public static class b2PulleyJointDef extends b2JointDef {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2PulleyJointDef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2PulleyJointDef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2PulleyJointDef position(long position) {
        return (b2PulleyJointDef)super.position(position);
    }

	public b2PulleyJointDef() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Initialize the bodies, anchors, lengths, max lengths, and ratio using the world anchors. */
	public native void Initialize(b2Body bodyA, b2Body bodyB,
						@Const @ByRef b2Vec2 groundAnchorA, @Const @ByRef b2Vec2 groundAnchorB,
						@Const @ByRef b2Vec2 anchorA, @Const @ByRef b2Vec2 anchorB,
						@Cast("float32") float ratio);

	/** The first ground anchor in world coordinates. This point never moves. */
	public native @ByRef b2Vec2 groundAnchorA(); public native b2PulleyJointDef groundAnchorA(b2Vec2 groundAnchorA);

	/** The second ground anchor in world coordinates. This point never moves. */
	public native @ByRef b2Vec2 groundAnchorB(); public native b2PulleyJointDef groundAnchorB(b2Vec2 groundAnchorB);

	/** The local anchor point relative to bodyA's origin. */
	public native @ByRef b2Vec2 localAnchorA(); public native b2PulleyJointDef localAnchorA(b2Vec2 localAnchorA);

	/** The local anchor point relative to bodyB's origin. */
	public native @ByRef b2Vec2 localAnchorB(); public native b2PulleyJointDef localAnchorB(b2Vec2 localAnchorB);

	/** The a reference length for the segment attached to bodyA. */
	public native @Cast("float32") float lengthA(); public native b2PulleyJointDef lengthA(float lengthA);

	/** The a reference length for the segment attached to bodyB. */
	public native @Cast("float32") float lengthB(); public native b2PulleyJointDef lengthB(float lengthB);

	/** The pulley ratio, used to simulate a block-and-tackle. */
	public native @Cast("float32") float ratio(); public native b2PulleyJointDef ratio(float ratio);
}

/** The pulley joint is connected to two bodies and two fixed ground points.
 *  The pulley supports a ratio such that:
 *  length1 + ratio * length2 <= constant
 *  Yes, the force transmitted is scaled by the ratio.
 *  Warning: the pulley joint can get a bit squirrelly by itself. They often
 *  work better when combined with prismatic joints. You should also cover the
 *  the anchor points with static shapes to prevent one side from going to
 *  zero length. */
@NoOffset public static class b2PulleyJoint extends b2Joint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2PulleyJoint(Pointer p) { super(p); }

	public native @ByVal b2Vec2 GetAnchorA();
	public native @ByVal b2Vec2 GetAnchorB();

	public native @ByVal b2Vec2 GetReactionForce(@Cast("float32") float inv_dt);
	public native @Cast("float32") float GetReactionTorque(@Cast("float32") float inv_dt);

	/** Get the first ground anchor. */
	public native @ByVal b2Vec2 GetGroundAnchorA();

	/** Get the second ground anchor. */
	public native @ByVal b2Vec2 GetGroundAnchorB();

	/** Get the current length of the segment attached to bodyA. */
	public native @Cast("float32") float GetLengthA();

	/** Get the current length of the segment attached to bodyB. */
	public native @Cast("float32") float GetLengthB();

	/** Get the pulley ratio. */
	public native @Cast("float32") float GetRatio();

	/** Get the current length of the segment attached to bodyA. */
	public native @Cast("float32") float GetCurrentLengthA();

	/** Get the current length of the segment attached to bodyB. */
	public native @Cast("float32") float GetCurrentLengthB();

	/** Dump joint to dmLog */
	public native void Dump();

	/** Implement b2Joint::ShiftOrigin */
	public native void ShiftOrigin(@Const @ByRef b2Vec2 newOrigin);
}

// #endif


// Parsed from <Box2D/Dynamics/Joints/b2RevoluteJoint.h>

/*
* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_REVOLUTE_JOINT_H
// #define B2_REVOLUTE_JOINT_H

// #include <Box2D/Dynamics/Joints/b2Joint.h>

/** Revolute joint definition. This requires defining an
 *  anchor point where the bodies are joined. The definition
 *  uses local anchor points so that the initial configuration
 *  can violate the constraint slightly. You also need to
 *  specify the initial relative angle for joint limits. This
 *  helps when saving and loading a game.
 *  The local anchor points are measured from the body's origin
 *  rather than the center of mass because:
 *  1. you might not know where the center of mass will be.
 *  2. if you add/remove shapes from a body and recompute the mass,
 *     the joints will be broken. */
@NoOffset public static class b2RevoluteJointDef extends b2JointDef {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2RevoluteJointDef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2RevoluteJointDef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2RevoluteJointDef position(long position) {
        return (b2RevoluteJointDef)super.position(position);
    }

	public b2RevoluteJointDef() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Initialize the bodies, anchors, and reference angle using a world
	 *  anchor point. */
	public native void Initialize(b2Body bodyA, b2Body bodyB, @Const @ByRef b2Vec2 anchor);

	/** The local anchor point relative to bodyA's origin. */
	public native @ByRef b2Vec2 localAnchorA(); public native b2RevoluteJointDef localAnchorA(b2Vec2 localAnchorA);

	/** The local anchor point relative to bodyB's origin. */
	public native @ByRef b2Vec2 localAnchorB(); public native b2RevoluteJointDef localAnchorB(b2Vec2 localAnchorB);

	/** The bodyB angle minus bodyA angle in the reference state (radians). */
	public native @Cast("float32") float referenceAngle(); public native b2RevoluteJointDef referenceAngle(float referenceAngle);

	/** A flag to enable joint limits. */
	public native @Cast("bool") boolean enableLimit(); public native b2RevoluteJointDef enableLimit(boolean enableLimit);

	/** The lower angle for the joint limit (radians). */
	public native @Cast("float32") float lowerAngle(); public native b2RevoluteJointDef lowerAngle(float lowerAngle);

	/** The upper angle for the joint limit (radians). */
	public native @Cast("float32") float upperAngle(); public native b2RevoluteJointDef upperAngle(float upperAngle);

	/** A flag to enable the joint motor. */
	public native @Cast("bool") boolean enableMotor(); public native b2RevoluteJointDef enableMotor(boolean enableMotor);

	/** The desired motor speed. Usually in radians per second. */
	public native @Cast("float32") float motorSpeed(); public native b2RevoluteJointDef motorSpeed(float motorSpeed);

	/** The maximum motor torque used to achieve the desired motor speed.
	 *  Usually in N-m. */
	public native @Cast("float32") float maxMotorTorque(); public native b2RevoluteJointDef maxMotorTorque(float maxMotorTorque);
}

/** A revolute joint constrains two bodies to share a common point while they
 *  are free to rotate about the point. The relative rotation about the shared
 *  point is the joint angle. You can limit the relative rotation with
 *  a joint limit that specifies a lower and upper angle. You can use a motor
 *  to drive the relative rotation about the shared point. A maximum motor torque
 *  is provided so that infinite forces are not generated. */
@NoOffset public static class b2RevoluteJoint extends b2Joint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2RevoluteJoint(Pointer p) { super(p); }

	public native @ByVal b2Vec2 GetAnchorA();
	public native @ByVal b2Vec2 GetAnchorB();

	/** The local anchor point relative to bodyA's origin. */
	public native @Const @ByRef b2Vec2 GetLocalAnchorA();

	/** The local anchor point relative to bodyB's origin. */
	public native @Const @ByRef b2Vec2 GetLocalAnchorB();

	/** Get the reference angle. */
	public native @Cast("float32") float GetReferenceAngle();

	/** Get the current joint angle in radians. */
	public native @Cast("float32") float GetJointAngle();

	/** Get the current joint angle speed in radians per second. */
	public native @Cast("float32") float GetJointSpeed();

	/** Is the joint limit enabled? */
	public native @Cast("bool") boolean IsLimitEnabled();

	/** Enable/disable the joint limit. */
	public native void EnableLimit(@Cast("bool") boolean flag);

	/** Get the lower joint limit in radians. */
	public native @Cast("float32") float GetLowerLimit();

	/** Get the upper joint limit in radians. */
	public native @Cast("float32") float GetUpperLimit();

	/** Set the joint limits in radians. */
	public native void SetLimits(@Cast("float32") float lower, @Cast("float32") float upper);

	/** Is the joint motor enabled? */
	public native @Cast("bool") boolean IsMotorEnabled();

	/** Enable/disable the joint motor. */
	public native void EnableMotor(@Cast("bool") boolean flag);

	/** Set the motor speed in radians per second. */
	public native void SetMotorSpeed(@Cast("float32") float speed);

	/** Get the motor speed in radians per second. */
	public native @Cast("float32") float GetMotorSpeed();

	/** Set the maximum motor torque, usually in N-m. */
	public native void SetMaxMotorTorque(@Cast("float32") float torque);
	public native @Cast("float32") float GetMaxMotorTorque();

	/** Get the reaction force given the inverse time step.
	 *  Unit is N. */
	public native @ByVal b2Vec2 GetReactionForce(@Cast("float32") float inv_dt);

	/** Get the reaction torque due to the joint limit given the inverse time step.
	 *  Unit is N*m. */
	public native @Cast("float32") float GetReactionTorque(@Cast("float32") float inv_dt);

	/** Get the current motor torque given the inverse time step.
	 *  Unit is N*m. */
	public native @Cast("float32") float GetMotorTorque(@Cast("float32") float inv_dt);

	/** Dump to b2Log. */
	public native void Dump();
}



// #endif


// Parsed from <Box2D/Dynamics/Joints/b2RopeJoint.h>

/*
* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_ROPE_JOINT_H
// #define B2_ROPE_JOINT_H

// #include <Box2D/Dynamics/Joints/b2Joint.h>

/** Rope joint definition. This requires two body anchor points and
 *  a maximum lengths.
 *  Note: by default the connected objects will not collide.
 *  see collideConnected in b2JointDef. */
@NoOffset public static class b2RopeJointDef extends b2JointDef {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2RopeJointDef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2RopeJointDef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2RopeJointDef position(long position) {
        return (b2RopeJointDef)super.position(position);
    }

	public b2RopeJointDef() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** The local anchor point relative to bodyA's origin. */
	public native @ByRef b2Vec2 localAnchorA(); public native b2RopeJointDef localAnchorA(b2Vec2 localAnchorA);

	/** The local anchor point relative to bodyB's origin. */
	public native @ByRef b2Vec2 localAnchorB(); public native b2RopeJointDef localAnchorB(b2Vec2 localAnchorB);

	/** The maximum length of the rope.
	 *  Warning: this must be larger than b2_linearSlop or
	 *  the joint will have no effect. */
	public native @Cast("float32") float maxLength(); public native b2RopeJointDef maxLength(float maxLength);
}

/** A rope joint enforces a maximum distance between two points
 *  on two bodies. It has no other effect.
 *  Warning: if you attempt to change the maximum length during
 *  the simulation you will get some non-physical behavior.
 *  A model that would allow you to dynamically modify the length
 *  would have some sponginess, so I chose not to implement it
 *  that way. See b2DistanceJoint if you want to dynamically
 *  control length. */
@NoOffset public static class b2RopeJoint extends b2Joint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2RopeJoint(Pointer p) { super(p); }

	public native @ByVal b2Vec2 GetAnchorA();
	public native @ByVal b2Vec2 GetAnchorB();

	public native @ByVal b2Vec2 GetReactionForce(@Cast("float32") float inv_dt);
	public native @Cast("float32") float GetReactionTorque(@Cast("float32") float inv_dt);

	/** The local anchor point relative to bodyA's origin. */
	public native @Const @ByRef b2Vec2 GetLocalAnchorA();

	/** The local anchor point relative to bodyB's origin. */
	public native @Const @ByRef b2Vec2 GetLocalAnchorB();

	/** Set/Get the maximum length of the rope. */
	public native void SetMaxLength(@Cast("float32") float length);
	public native @Cast("float32") float GetMaxLength();

	public native @Cast("b2LimitState") int GetLimitState();

	/** Dump joint to dmLog */
	public native void Dump();
}

// #endif


// Parsed from <Box2D/Dynamics/Joints/b2WeldJoint.h>

/*
* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_WELD_JOINT_H
// #define B2_WELD_JOINT_H

// #include <Box2D/Dynamics/Joints/b2Joint.h>

/** Weld joint definition. You need to specify local anchor points
 *  where they are attached and the relative body angle. The position
 *  of the anchor points is important for computing the reaction torque. */
@NoOffset public static class b2WeldJointDef extends b2JointDef {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2WeldJointDef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2WeldJointDef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2WeldJointDef position(long position) {
        return (b2WeldJointDef)super.position(position);
    }

	public b2WeldJointDef() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Initialize the bodies, anchors, and reference angle using a world
	 *  anchor point. */
	public native void Initialize(b2Body bodyA, b2Body bodyB, @Const @ByRef b2Vec2 anchor);

	/** The local anchor point relative to bodyA's origin. */
	public native @ByRef b2Vec2 localAnchorA(); public native b2WeldJointDef localAnchorA(b2Vec2 localAnchorA);

	/** The local anchor point relative to bodyB's origin. */
	public native @ByRef b2Vec2 localAnchorB(); public native b2WeldJointDef localAnchorB(b2Vec2 localAnchorB);

	/** The bodyB angle minus bodyA angle in the reference state (radians). */
	public native @Cast("float32") float referenceAngle(); public native b2WeldJointDef referenceAngle(float referenceAngle);
	
	/** The mass-spring-damper frequency in Hertz. Rotation only.
	 *  Disable softness with a value of 0. */
	public native @Cast("float32") float frequencyHz(); public native b2WeldJointDef frequencyHz(float frequencyHz);

	/** The damping ratio. 0 = no damping, 1 = critical damping. */
	public native @Cast("float32") float dampingRatio(); public native b2WeldJointDef dampingRatio(float dampingRatio);
}

/** A weld joint essentially glues two bodies together. A weld joint may
 *  distort somewhat because the island constraint solver is approximate. */
@NoOffset public static class b2WeldJoint extends b2Joint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2WeldJoint(Pointer p) { super(p); }

	public native @ByVal b2Vec2 GetAnchorA();
	public native @ByVal b2Vec2 GetAnchorB();

	public native @ByVal b2Vec2 GetReactionForce(@Cast("float32") float inv_dt);
	public native @Cast("float32") float GetReactionTorque(@Cast("float32") float inv_dt);

	/** The local anchor point relative to bodyA's origin. */
	public native @Const @ByRef b2Vec2 GetLocalAnchorA();

	/** The local anchor point relative to bodyB's origin. */
	public native @Const @ByRef b2Vec2 GetLocalAnchorB();

	/** Get the reference angle. */
	public native @Cast("float32") float GetReferenceAngle();

	/** Set/get frequency in Hz. */
	public native void SetFrequency(@Cast("float32") float hz);
	public native @Cast("float32") float GetFrequency();

	/** Set/get damping ratio. */
	public native void SetDampingRatio(@Cast("float32") float ratio);
	public native @Cast("float32") float GetDampingRatio();

	/** Dump to b2Log */
	public native void Dump();
}

// #endif


// Parsed from <Box2D/Dynamics/Joints/b2WheelJoint.h>

/*
* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/

// #ifndef B2_WHEEL_JOINT_H
// #define B2_WHEEL_JOINT_H

// #include <Box2D/Dynamics/Joints/b2Joint.h>

/** Wheel joint definition. This requires defining a line of
 *  motion using an axis and an anchor point. The definition uses local
 *  anchor points and a local axis so that the initial configuration
 *  can violate the constraint slightly. The joint translation is zero
 *  when the local anchor points coincide in world space. Using local
 *  anchors and a local axis helps when saving and loading a game. */
@NoOffset public static class b2WheelJointDef extends b2JointDef {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2WheelJointDef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2WheelJointDef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2WheelJointDef position(long position) {
        return (b2WheelJointDef)super.position(position);
    }

	public b2WheelJointDef() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Initialize the bodies, anchors, axis, and reference angle using the world
	 *  anchor and world axis. */
	public native void Initialize(b2Body bodyA, b2Body bodyB, @Const @ByRef b2Vec2 anchor, @Const @ByRef b2Vec2 axis);

	/** The local anchor point relative to bodyA's origin. */
	public native @ByRef b2Vec2 localAnchorA(); public native b2WheelJointDef localAnchorA(b2Vec2 localAnchorA);

	/** The local anchor point relative to bodyB's origin. */
	public native @ByRef b2Vec2 localAnchorB(); public native b2WheelJointDef localAnchorB(b2Vec2 localAnchorB);

	/** The local translation axis in bodyA. */
	public native @ByRef b2Vec2 localAxisA(); public native b2WheelJointDef localAxisA(b2Vec2 localAxisA);

	/** Enable/disable the joint motor. */
	public native @Cast("bool") boolean enableMotor(); public native b2WheelJointDef enableMotor(boolean enableMotor);

	/** The maximum motor torque, usually in N-m. */
	public native @Cast("float32") float maxMotorTorque(); public native b2WheelJointDef maxMotorTorque(float maxMotorTorque);

	/** The desired motor speed in radians per second. */
	public native @Cast("float32") float motorSpeed(); public native b2WheelJointDef motorSpeed(float motorSpeed);

	/** Suspension frequency, zero indicates no suspension */
	public native @Cast("float32") float frequencyHz(); public native b2WheelJointDef frequencyHz(float frequencyHz);

	/** Suspension damping ratio, one indicates critical damping */
	public native @Cast("float32") float dampingRatio(); public native b2WheelJointDef dampingRatio(float dampingRatio);
}

/** A wheel joint. This joint provides two degrees of freedom: translation
 *  along an axis fixed in bodyA and rotation in the plane. You can use a
 *  joint limit to restrict the range of motion and a joint motor to drive
 *  the rotation or to model rotational friction.
 *  This joint is designed for vehicle suspensions. */
@NoOffset public static class b2WheelJoint extends b2Joint {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2WheelJoint(Pointer p) { super(p); }

	public native @ByVal b2Vec2 GetAnchorA();
	public native @ByVal b2Vec2 GetAnchorB();

	public native @ByVal b2Vec2 GetReactionForce(@Cast("float32") float inv_dt);
	public native @Cast("float32") float GetReactionTorque(@Cast("float32") float inv_dt);

	/** The local anchor point relative to bodyA's origin. */
	public native @Const @ByRef b2Vec2 GetLocalAnchorA();

	/** The local anchor point relative to bodyB's origin. */
	public native @Const @ByRef b2Vec2 GetLocalAnchorB();

	/** The local joint axis relative to bodyA. */
	public native @Const @ByRef b2Vec2 GetLocalAxisA();

	/** Get the current joint translation, usually in meters. */
	public native @Cast("float32") float GetJointTranslation();

	/** Get the current joint translation speed, usually in meters per second. */
	public native @Cast("float32") float GetJointSpeed();

	/** Is the joint motor enabled? */
	public native @Cast("bool") boolean IsMotorEnabled();

	/** Enable/disable the joint motor. */
	public native void EnableMotor(@Cast("bool") boolean flag);

	/** Set the motor speed, usually in radians per second. */
	public native void SetMotorSpeed(@Cast("float32") float speed);

	/** Get the motor speed, usually in radians per second. */
	public native @Cast("float32") float GetMotorSpeed();

	/** Set/Get the maximum motor force, usually in N-m. */
	public native void SetMaxMotorTorque(@Cast("float32") float torque);
	public native @Cast("float32") float GetMaxMotorTorque();

	/** Get the current motor torque given the inverse time step, usually in N-m. */
	public native @Cast("float32") float GetMotorTorque(@Cast("float32") float inv_dt);

	/** Set/Get the spring frequency in hertz. Setting the frequency to zero disables the spring. */
	public native void SetSpringFrequencyHz(@Cast("float32") float hz);
	public native @Cast("float32") float GetSpringFrequencyHz();

	/** Set/Get the spring damping ratio */
	public native void SetSpringDampingRatio(@Cast("float32") float ratio);
	public native @Cast("float32") float GetSpringDampingRatio();

	/** Dump to b2Log */
	public native void Dump();
}













// #endif


// Parsed from <Box2D/Particle/b2Particle.h>

/*
* Copyright (c) 2013 Google, Inc.
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/
// #ifndef B2_PARTICLE
// #define B2_PARTICLE

// #include <Box2D/Common/b2Math.h>
// #include <Box2D/Common/b2Settings.h>
// #include <Box2D/Common/b2IntrusiveList.h>

/** \file
 <p>
 *  The particle type. Can be combined with the | operator. */
/** enum b2ParticleFlag */
public static final int
	/** Water particle. */
	b2_waterParticle = 0,
	/** Removed after next simulation step. */
	b2_zombieParticle = 1 << 1,
	/** Zero velocity. */
	b2_wallParticle = 1 << 2,
	/** With restitution from stretching. */
	b2_springParticle = 1 << 3,
	/** With restitution from deformation. */
	b2_elasticParticle = 1 << 4,
	/** With viscosity. */
	b2_viscousParticle = 1 << 5,
	/** Without isotropic pressure. */
	b2_powderParticle = 1 << 6,
	/** With surface tension. */
	b2_tensileParticle = 1 << 7,
	/** Mix color between contacting particles. */
	b2_colorMixingParticle = 1 << 8,
	/** Call b2DestructionListener on destruction. */
	b2_destructionListenerParticle = 1 << 9,
	/** Prevents other particles from leaking. */
	b2_barrierParticle = 1 << 10,
	/** Less compressibility. */
	b2_staticPressureParticle = 1 << 11,
	/** Makes pairs or triads with other particles. */
	b2_reactiveParticle = 1 << 12,
	/** With high repulsive force. */
	b2_repulsiveParticle = 1 << 13,
	/** Call b2ContactListener when this particle is about to interact with
	 *  a rigid body or stops interacting with a rigid body.
	 *  This results in an expensive operation compared to using
	 *  b2_fixtureContactFilterParticle to detect collisions between
	 *  particles. */
	b2_fixtureContactListenerParticle = 1 << 14,
	/** Call b2ContactListener when this particle is about to interact with
	 *  another particle or stops interacting with another particle.
	 *  This results in an expensive operation compared to using
	 *  b2_particleContactFilterParticle to detect collisions between
	 *  particles. */
	b2_particleContactListenerParticle = 1 << 15,
	/** Call b2ContactFilter when this particle interacts with rigid bodies. */
	b2_fixtureContactFilterParticle = 1 << 16,
	/** Call b2ContactFilter when this particle interacts with other
	 *  particles. */
	b2_particleContactFilterParticle = 1 << 17;

/** Small color object for each particle */
@NoOffset public static class b2ParticleColor extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ParticleColor(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ParticleColor(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2ParticleColor position(long position) {
        return (b2ParticleColor)super.position(position);
    }

	public b2ParticleColor() { super((Pointer)null); allocate(); }
	private native void allocate();
	/** Constructor with four elements: r (red), g (green), b (blue), and a
	 *  (opacity).
	 *  Each element can be specified 0 to 255. */
	public b2ParticleColor(@Cast("uint8") short r, @Cast("uint8") short g, @Cast("uint8") short b, @Cast("uint8") short a) { super((Pointer)null); allocate(r, g, b, a); }
	private native void allocate(@Cast("uint8") short r, @Cast("uint8") short g, @Cast("uint8") short b, @Cast("uint8") short a);

	/** Constructor that initializes the above four elements with the value of
	 *  the b2Color object. */
	
	///
	public b2ParticleColor(@Const @ByRef b2Color color) { super((Pointer)null); allocate(color); }
	private native void allocate(@Const @ByRef b2Color color);

	/** True when all four color elements equal 0. When true, a particle color
	 *  buffer isn't allocated by CreateParticle().
	 *  */
	
	///
	public native @Cast("bool") boolean IsZero();

	/** Used internally to convert the value of b2Color.
	 *  */
	
	///
	public native @ByVal b2Color GetColor();

	/** Sets color for current object using the four elements described above.
	 *  */
	
	///
	public native void Set(@Cast("uint8") short r_, @Cast("uint8") short g_, @Cast("uint8") short b_, @Cast("uint8") short a_);

	/** Initializes the object with the value of the b2Color.
	 *  */
	public native void Set(@Const @ByRef b2Color color);

	/** Assign a b2ParticleColor to this instance. */
	public native @ByRef @Name("operator =") b2ParticleColor put(@Const @ByRef b2ParticleColor color);

	/** Multiplies r, g, b, a members by s where s is a value between 0.0
	 *  and 1.0. */
	public native @ByRef @Name("operator *=") b2ParticleColor multiplyPut(@Cast("float32") float s);

	/** Scales r, g, b, a members by s where s is a value between 0 and 255. */
	public native @ByRef @Name("operator *=") b2ParticleColor multiplyPut(@Cast("uint8") short s);

	/** Scales r, g, b, a members by s returning the modified b2ParticleColor. */
	public native @ByVal @Name("operator *") b2ParticleColor multiply(@Cast("float32") float s);

	/** Scales r, g, b, a members by s returning the modified b2ParticleColor. */
	public native @ByVal @Name("operator *") b2ParticleColor multiply(@Cast("uint8") short s);

	/** Add two colors.  This is a non-saturating addition so values
	 *  overflows will wrap. */
	public native @ByRef @Name("operator +=") b2ParticleColor addPut(@Const @ByRef b2ParticleColor color);

	/** Add two colors.  This is a non-saturating addition so values
	 *  overflows will wrap. */
	public native @ByVal @Name("operator +") b2ParticleColor add(@Const @ByRef b2ParticleColor color);

	/** Subtract a color from this color.  This is a subtraction without
	 *  saturation so underflows will wrap. */
	public native @ByRef @Name("operator -=") b2ParticleColor subtractPut(@Const @ByRef b2ParticleColor color);

	/** Subtract a color from this color returning the result.  This is a
	 *  subtraction without saturation so underflows will wrap. */
	public native @ByVal @Name("operator -") b2ParticleColor subtract(@Const @ByRef b2ParticleColor color);

	/** Compare this color with the specified color. */
	public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef b2ParticleColor color);

	/** Mix mixColor with this color using strength to control how much of
	 *  mixColor is mixed with this color and vice versa.  The range of
	 *  strength is 0..128 where 0 results in no color mixing and 128 results
	 *  in an equal mix of both colors.  strength 0..128 is analogous to an
	 *  alpha channel value between 0.0f..0.5f. */
	public native void Mix(b2ParticleColor mixColor, @Cast("const int32") int strength);

	/** Mix colorA with colorB using strength to control how much of
	 *  colorA is mixed with colorB and vice versa.  The range of
	 *  strength is 0..128 where 0 results in no color mixing and 128 results
	 *  in an equal mix of both colors.  strength 0..128 is analogous to an
	 *  alpha channel value between 0.0f..0.5f. */
	public static native void MixColors(b2ParticleColor colorA,
								 b2ParticleColor colorB,
								 @Cast("const int32") int strength);
	public native @Cast("uint8") short r(); public native b2ParticleColor r(short r);
	public native @Cast("uint8") short g(); public native b2ParticleColor g(short g);
	public native @Cast("uint8") short b(); public native b2ParticleColor b(short b);
	public native @Cast("uint8") short a(); public native b2ParticleColor a(short a);
}

public static native @ByRef b2ParticleColor b2ParticleColor_zero(); public static native void b2ParticleColor_zero(b2ParticleColor b2ParticleColor_zero);

/** A particle definition holds all the data needed to construct a particle.
 *  You can safely re-use these definitions. */
@NoOffset public static class b2ParticleDef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ParticleDef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ParticleDef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2ParticleDef position(long position) {
        return (b2ParticleDef)super.position(position);
    }

	public b2ParticleDef() { super((Pointer)null); allocate(); }
	private native void allocate();

// #if LIQUIDFUN_EXTERNAL_LANGUAGE_API
	/** Set position with direct floats */
	public native void SetPosition(@Cast("float32") float x, @Cast("float32") float y);

	/** Set color with direct ints. */
	
	///
	public native void SetColor(@Cast("int32") int r, @Cast("int32") int g, @Cast("int32") int b, @Cast("int32") int a);
// #endif // LIQUIDFUN_EXTERNAL_LANGUAGE_API

	/** \brief Specifies the type of particle (see #b2ParticleFlag).
	 * 
	 *  A particle may be more than one type.
	 *  Multiple types are chained by logical sums, for example:
	 *  pd.flags = b2_elasticParticle | b2_viscousParticle */
	public native @Cast("uint32") long flags(); public native b2ParticleDef flags(long flags);

	/** The world position of the particle. */
	public native @ByRef @Name("position") b2Vec2 _position(); public native b2ParticleDef _position(b2Vec2 _position);

	/** The linear velocity of the particle in world co-ordinates. */
	public native @ByRef b2Vec2 velocity(); public native b2ParticleDef velocity(b2Vec2 velocity);

	/** The color of the particle. */
	public native @ByRef b2ParticleColor color(); public native b2ParticleDef color(b2ParticleColor color);

	/** Lifetime of the particle in seconds.  A value <= 0.0f indicates a
	 *  particle with infinite lifetime. */
	public native @Cast("float32") float lifetime(); public native b2ParticleDef lifetime(float lifetime);

	/** Use this to store application-specific body data. */
	public native Pointer userData(); public native b2ParticleDef userData(Pointer userData);

	/** An existing particle group to which the particle will be added. */
	public native b2ParticleGroup group(); public native b2ParticleDef group(b2ParticleGroup group);

}

/** A helper function to calculate the optimal number of iterations. */
public static native @Cast("int32") int b2CalculateParticleIterations(
	@Cast("float32") float gravity, @Cast("float32") float radius, @Cast("float32") float timeStep);

/** Handle to a particle. Particle indices are ephemeral: the same index might
 *  refer to a different particle, from frame-to-frame. If you need to keep a
 *  reference to a particular particle across frames, you should acquire a
 *  b2ParticleHandle. Use #b2ParticleSystem::GetParticleHandleFromIndex() to
 *  retrieve the b2ParticleHandle of a particle from the particle system. */
@NoOffset public static class b2ParticleHandle extends ParticleHandleListNode {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ParticleHandle(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ParticleHandle(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2ParticleHandle position(long position) {
        return (b2ParticleHandle)super.position(position);
    }

	/** Initialize the index associated with the handle to an invalid index. */
	public b2ParticleHandle() { super((Pointer)null); allocate(); }
	private native void allocate();
	/** Empty destructor. */

	/** Get the index of the particle associated with this handle. */
	public native @Cast("int32") int GetIndex();
}

// #if LIQUIDFUN_EXTERNAL_LANGUAGE_API



// #endif // LIQUIDFUN_EXTERNAL_LANGUAGE_API

// #endif


// Parsed from <Box2D/Particle/b2ParticleGroup.h>

/*
* Copyright (c) 2013 Google, Inc.
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/
// #ifndef B2_PARTICLE_GROUP
// #define B2_PARTICLE_GROUP

// #include <Box2D/Particle/b2Particle.h>
// #if LIQUIDFUN_EXTERNAL_LANGUAGE_API
// #endif // LIQUIDFUN_EXTERNAL_LANGUAGE_API

/** \file
 <p>
 *  The particle group type.  Can be combined with the | operator. */
/** enum b2ParticleGroupFlag */
public static final int
	/** Prevents overlapping or leaking. */
	b2_solidParticleGroup = 1 << 0,
	/** Keeps its shape. */
	b2_rigidParticleGroup = 1 << 1,
	/** Won't be destroyed if it gets empty. */
	b2_particleGroupCanBeEmpty = 1 << 2,
	/** Will be destroyed on next simulation step. */
	b2_particleGroupWillBeDestroyed = 1 << 3,
	/** Updates depth data on next simulation step. */
	b2_particleGroupNeedsUpdateDepth = 1 << 4,
	b2_particleGroupInternalMask = 
		b2_particleGroupWillBeDestroyed |
		b2_particleGroupNeedsUpdateDepth;

/** A particle group definition holds all the data needed to construct a
 *  particle group.  You can safely re-use these definitions. */
@NoOffset public static class b2ParticleGroupDef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ParticleGroupDef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ParticleGroupDef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2ParticleGroupDef position(long position) {
        return (b2ParticleGroupDef)super.position(position);
    }


	public b2ParticleGroupDef() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** The particle-behavior flags (See #b2ParticleFlag). */
	public native @Cast("uint32") long flags(); public native b2ParticleGroupDef flags(long flags);

	/** The group-construction flags (See #b2ParticleGroupFlag). */
	public native @Cast("uint32") long groupFlags(); public native b2ParticleGroupDef groupFlags(long groupFlags);

	/** The world position of the group.
	 *  Moves the group's shape a distance equal to the value of position. */
	public native @ByRef @Name("position") b2Vec2 _position(); public native b2ParticleGroupDef _position(b2Vec2 _position);

	/** The world angle of the group in radians.
	 *  Rotates the shape by an angle equal to the value of angle. */
	public native @Cast("float32") float angle(); public native b2ParticleGroupDef angle(float angle);

	/** The linear velocity of the group's origin in world co-ordinates. */
	public native @ByRef b2Vec2 linearVelocity(); public native b2ParticleGroupDef linearVelocity(b2Vec2 linearVelocity);

	/** The angular velocity of the group. */
	public native @Cast("float32") float angularVelocity(); public native b2ParticleGroupDef angularVelocity(float angularVelocity);

	/** The color of all particles in the group. */
	public native @ByRef b2ParticleColor color(); public native b2ParticleGroupDef color(b2ParticleColor color);

	/** The strength of cohesion among the particles in a group with flag
	 *  b2_elasticParticle or b2_springParticle. */
	public native @Cast("float32") float strength(); public native b2ParticleGroupDef strength(float strength);

	/** The shape where particles will be added. */
	@MemberGetter public native @Const b2Shape shape();
	@MemberSetter public native b2ParticleGroupDef shape(@Const b2Shape shape);

	/** A array of shapes where particles will be added. */
	@MemberGetter public native @Cast("const b2Shape*const*") PointerPointer shapes();
	@MemberSetter public native b2ParticleGroupDef shapes(@Cast("const b2Shape*const*") PointerPointer shapes);

	/** The number of shapes. */
	public native @Cast("int32") int shapeCount(); public native b2ParticleGroupDef shapeCount(int shapeCount);

	/** The interval of particles in the shape.
	 *  If it is 0, b2_particleStride * particleDiameter is used instead. */
	public native @Cast("float32") float stride(); public native b2ParticleGroupDef stride(float stride);

	/** The number of particles in addition to ones added in the shape. */
	public native @Cast("int32") int particleCount(); public native b2ParticleGroupDef particleCount(int particleCount);

	/** The initial positions of the particleCount particles. */
	@MemberGetter public native @Const b2Vec2 positionData();
	@MemberSetter public native b2ParticleGroupDef positionData(@Const b2Vec2 positionData);

	/** Lifetime of the particle group in seconds.  A value <= 0.0f indicates a
	 *  particle group with infinite lifetime. */
	public native @Cast("float32") float lifetime(); public native b2ParticleGroupDef lifetime(float lifetime);

	/** Use this to store application-specific group data. */
	public native Pointer userData(); public native b2ParticleGroupDef userData(Pointer userData);

	/** An existing particle group to which the particles will be added. */
	public native b2ParticleGroup group(); public native b2ParticleGroupDef group(b2ParticleGroup group);

// #if LIQUIDFUN_EXTERNAL_LANGUAGE_API
	/** Storage for constructed CircleShapes from an incoming vertex list */
	@MemberGetter public native @Const b2CircleShape circleShapes();

	/** True if we create the shapes array internally. */
	public native @Cast("bool") boolean ownShapesArray(); public native b2ParticleGroupDef ownShapesArray(boolean ownShapesArray);

	/** Clean up all memory associated with SetCircleShapesFromVertexList */
	public native void FreeShapesMemory();

	/** From a vertex list created by an external language API, construct
	 *  a list of circle shapes that can be used to create a b2ParticleGroup
	 *  This eliminates cumbersome array-interfaces between languages. */
	public native void SetCircleShapesFromVertexList(Pointer inBuf,
										   int numShapes,
										   float radius);

	/** Set position with direct floats. */
	public native void SetPosition(@Cast("float32") float x, @Cast("float32") float y);

	/** Set color with direct ints. */
	public native void SetColor(@Cast("int32") int r, @Cast("int32") int g, @Cast("int32") int b, @Cast("int32") int a);
// #endif // LIQUIDFUN_EXTERNAL_LANGUAGE_API
}

/** A group of particles. b2ParticleGroup::CreateParticleGroup creates these. */
@NoOffset public static class b2ParticleGroup extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ParticleGroup(Pointer p) { super(p); }


	/** Get the next particle group from the list in b2_World. */
	public native b2ParticleGroup GetNext();

	/** Get the particle system that holds this particle group. */
	public native b2ParticleSystem GetParticleSystem();

	/** Get the number of particles. */
	public native @Cast("int32") int GetParticleCount();

	/** Get the offset of this group in the global particle buffer */
	public native @Cast("int32") int GetBufferIndex();

	/** Does this group contain the particle. */
	public native @Cast("bool") boolean ContainsParticle(@Cast("int32") int index);

	/** Get the logical sum of particle flags. */
	public native @Cast("uint32") long GetAllParticleFlags();

	/** Get the construction flags for the group. */
	public native @Cast("uint32") long GetGroupFlags();

	/** Set the construction flags for the group. */
	public native void SetGroupFlags(@Cast("uint32") long flags);

	/** Get the total mass of the group: the sum of all particles in it. */
	public native @Cast("float32") float GetMass();

	/** Get the moment of inertia for the group. */
	public native @Cast("float32") float GetInertia();

	/** Get the center of gravity for the group. */
	public native @ByVal b2Vec2 GetCenter();

	/** Get the linear velocity of the group. */
	public native @ByVal b2Vec2 GetLinearVelocity();

	/** Get the angular velocity of the group. */
	public native @Cast("float32") float GetAngularVelocity();

	/** Get the position of the group's origin and rotation.
	 *  Used only with groups of rigid particles. */
	public native @Const @ByRef b2Transform GetTransform();

	/** Get position of the particle group as a whole.
	 *  Used only with groups of rigid particles. */
	public native @Const @ByRef b2Vec2 GetPosition();

	/** Get the rotational angle of the particle group as a whole.
	 *  Used only with groups of rigid particles. */
	public native @Cast("float32") float GetAngle();

	/** Get the world linear velocity of a world point, from the average linear
	 *  and angular velocities of the particle group.
	 *  @param a point in world coordinates.
	 *  @return the world velocity of a point. */
	public native @ByVal b2Vec2 GetLinearVelocityFromWorldPoint(@Const @ByRef b2Vec2 worldPoint);

	/** Get the user data pointer that was provided in the group definition. */
	public native Pointer GetUserData();

	/** Set the user data. Use this to store your application specific data. */
	public native void SetUserData(Pointer data);

	/** Call b2ParticleSystem::ApplyForce for every particle in the group. */
	public native void ApplyForce(@Const @ByRef b2Vec2 force);

	/** Call b2ParticleSystem::ApplyLinearImpulse for every particle in the
	 *  group. */
	public native void ApplyLinearImpulse(@Const @ByRef b2Vec2 impulse);

	/** Destroy all the particles in this group.
	 *  This function is locked during callbacks.
	 *  @param Whether to call the world b2DestructionListener for each
	 *  particle is destroyed.
	 *  \warning This function is locked during callbacks. */
	public native void DestroyParticles(@Cast("bool") boolean callDestructionListener);

	/** Destroy all particles in this group without enabling the destruction
	 *  callback for destroyed particles.
	 *  This function is locked during callbacks.
	 *  \warning This function is locked during callbacks. */
	public native void DestroyParticles();

}











































// #if LIQUIDFUN_EXTERNAL_LANGUAGE_API



// #endif // LIQUIDFUN_EXTERNAL_LANGUAGE_API


// #endif


// Parsed from <Box2D/Particle/b2ParticleSystem.h>

/*
* Copyright (c) 2013 Google, Inc.
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/
// #ifndef B2_PARTICLE_SYSTEM_H
// #define B2_PARTICLE_SYSTEM_H

// #include <Box2D/Common/b2SlabAllocator.h>
// #include <Box2D/Common/b2GrowableBuffer.h>
// #include <Box2D/Particle/b2Particle.h>
// #include <Box2D/Dynamics/b2TimeStep.h>

// #if LIQUIDFUN_UNIT_TESTS
// #include <gtest/gtest.h>
// #endif // LIQUIDFUN_UNIT_TESTS

// #if LIQUIDFUN_EXTERNAL_LANGUAGE_API
// #include <cstring>
// #endif // LIQUIDFUN_EXTERNAL_LANGUAGE_API
@Opaque public static class b2ParticlePairSet extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public b2ParticlePairSet() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ParticlePairSet(Pointer p) { super(p); }
}
@Opaque public static class FixtureParticleSet extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public FixtureParticleSet() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FixtureParticleSet(Pointer p) { super(p); }
}
@Opaque public static class FindContactInput extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public FindContactInput() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FindContactInput(Pointer p) { super(p); }
}
@Opaque public static class FindContactCheck extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public FindContactCheck() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public FindContactCheck(Pointer p) { super(p); }
}

public static class b2ParticleContact extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2ParticleContact() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ParticleContact(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ParticleContact(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2ParticleContact position(long position) {
        return (b2ParticleContact)super.position(position);
    }

	public native void SetIndices(@Cast("int32") int a, @Cast("int32") int b);
	public native void SetWeight(@Cast("float32") float w);
	public native void SetNormal(@Const @ByRef b2Vec2 n);
	public native void SetFlags(@Cast("uint32") long f);

	public native @Cast("int32") int GetIndexA();
	public native @Cast("int32") int GetIndexB();
	public native @Cast("float32") float GetWeight();
	public native @Const @ByRef b2Vec2 GetNormal();
	public native @Cast("uint32") long GetFlags();

	public native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef b2ParticleContact rhs);
	public native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef b2ParticleContact rhs);
	public native @Cast("bool") boolean ApproximatelyEqual(@Const @ByRef b2ParticleContact rhs);
}

public static class b2ParticleBodyContact extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2ParticleBodyContact() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ParticleBodyContact(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ParticleBodyContact(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2ParticleBodyContact position(long position) {
        return (b2ParticleBodyContact)super.position(position);
    }

	/** Index of the particle making contact. */
	public native @Cast("int32") int index(); public native b2ParticleBodyContact index(int index);

	/** The body making contact. */
	public native b2Body body(); public native b2ParticleBodyContact body(b2Body body);

	/** The specific fixture making contact */
	public native b2Fixture fixture(); public native b2ParticleBodyContact fixture(b2Fixture fixture);

	/** Weight of the contact. A value between 0.0f and 1.0f. */
	public native @Cast("float32") float weight(); public native b2ParticleBodyContact weight(float weight);

	/** The normalized direction from the particle to the body. */
	public native @ByRef b2Vec2 normal(); public native b2ParticleBodyContact normal(b2Vec2 normal);

	/** The effective mass used in calculating force. */
	public native @Cast("float32") float mass(); public native b2ParticleBodyContact mass(float mass);
}

/** Connection between two particles */
public static class b2ParticlePair extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2ParticlePair() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ParticlePair(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ParticlePair(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2ParticlePair position(long position) {
        return (b2ParticlePair)super.position(position);
    }

	/** Indices of the respective particles making pair. */
	public native @Cast("int32") int indexA(); public native b2ParticlePair indexA(int indexA);
	public native @Cast("int32") int indexB(); public native b2ParticlePair indexB(int indexB);

	/** The logical sum of the particle flags. See the b2ParticleFlag enum. */
	public native @Cast("uint32") long flags(); public native b2ParticlePair flags(long flags);

	/** The strength of cohesion among the particles. */
	public native @Cast("float32") float strength(); public native b2ParticlePair strength(float strength);

	/** The initial distance of the particles. */
	public native @Cast("float32") float distance(); public native b2ParticlePair distance(float distance);
}

/** Connection between three particles */
public static class b2ParticleTriad extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2ParticleTriad() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ParticleTriad(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ParticleTriad(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2ParticleTriad position(long position) {
        return (b2ParticleTriad)super.position(position);
    }

	/** Indices of the respective particles making triad. */
	public native @Cast("int32") int indexA(); public native b2ParticleTriad indexA(int indexA);
	public native @Cast("int32") int indexB(); public native b2ParticleTriad indexB(int indexB);
	public native @Cast("int32") int indexC(); public native b2ParticleTriad indexC(int indexC);

	/** The logical sum of the particle flags. See the b2ParticleFlag enum. */
	public native @Cast("uint32") long flags(); public native b2ParticleTriad flags(long flags);

	/** The strength of cohesion among the particles. */
	public native @Cast("float32") float strength(); public native b2ParticleTriad strength(float strength);

	/** Values used for calculation. */
	public native @ByRef b2Vec2 pa(); public native b2ParticleTriad pa(b2Vec2 pa);
	public native @ByRef b2Vec2 pb(); public native b2ParticleTriad pb(b2Vec2 pb);
	public native @ByRef b2Vec2 pc(); public native b2ParticleTriad pc(b2Vec2 pc);
	public native @Cast("float32") float ka(); public native b2ParticleTriad ka(float ka);
	public native @Cast("float32") float kb(); public native b2ParticleTriad kb(float kb);
	public native @Cast("float32") float kc(); public native b2ParticleTriad kc(float kc);
	public native @Cast("float32") float s(); public native b2ParticleTriad s(float s);
}

@NoOffset public static class b2ParticleSystemDef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ParticleSystemDef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2ParticleSystemDef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public b2ParticleSystemDef position(long position) {
        return (b2ParticleSystemDef)super.position(position);
    }

	public b2ParticleSystemDef() { super((Pointer)null); allocate(); }
	private native void allocate();

	/** Enable strict Particle/Body contact check.
	 *  See SetStrictContactCheck for details. */
	public native @Cast("bool") boolean strictContactCheck(); public native b2ParticleSystemDef strictContactCheck(boolean strictContactCheck);

	/** Set the particle density.
	 *  See SetDensity for details. */
	public native @Cast("float32") float density(); public native b2ParticleSystemDef density(float density);

	/** Change the particle gravity scale. Adjusts the effect of the global
	 *  gravity vector on particles. Default value is 1.0f. */
	public native @Cast("float32") float gravityScale(); public native b2ParticleSystemDef gravityScale(float gravityScale);

	/** Particles behave as circles with this radius. In Box2D units. */
	public native @Cast("float32") float radius(); public native b2ParticleSystemDef radius(float radius);

	/** Set the maximum number of particles.
	 *  By default, there is no maximum. The particle buffers can continue to
	 *  grow while b2World's block allocator still has memory.
	 *  See SetMaxParticleCount for details. */
	public native @Cast("int32") int maxCount(); public native b2ParticleSystemDef maxCount(int maxCount);

	/** Increases pressure in response to compression
	 *  Smaller values allow more compression */
	public native @Cast("float32") float pressureStrength(); public native b2ParticleSystemDef pressureStrength(float pressureStrength);

	/** Reduces velocity along the collision normal
	 *  Smaller value reduces less */
	public native @Cast("float32") float dampingStrength(); public native b2ParticleSystemDef dampingStrength(float dampingStrength);

	/** Restores shape of elastic particle groups
	 *  Larger values increase elastic particle velocity */
	public native @Cast("float32") float elasticStrength(); public native b2ParticleSystemDef elasticStrength(float elasticStrength);

	/** Restores length of spring particle groups
	 *  Larger values increase spring particle velocity */
	public native @Cast("float32") float springStrength(); public native b2ParticleSystemDef springStrength(float springStrength);

	/** Reduces relative velocity of viscous particles
	 *  Larger values slow down viscous particles more */
	public native @Cast("float32") float viscousStrength(); public native b2ParticleSystemDef viscousStrength(float viscousStrength);

	/** Produces pressure on tensile particles
	 *  0~0.2. Larger values increase the amount of surface tension. */
	public native @Cast("float32") float surfaceTensionPressureStrength(); public native b2ParticleSystemDef surfaceTensionPressureStrength(float surfaceTensionPressureStrength);

	/** Smoothes outline of tensile particles
	 *  0~0.2. Larger values result in rounder, smoother, water-drop-like
	 *  clusters of particles. */
	public native @Cast("float32") float surfaceTensionNormalStrength(); public native b2ParticleSystemDef surfaceTensionNormalStrength(float surfaceTensionNormalStrength);

	/** Produces additional pressure on repulsive particles
	 *  Larger values repulse more
	 *  Negative values mean attraction. The range where particles behave
	 *  stably is about -0.2 to 2.0. */
	public native @Cast("float32") float repulsiveStrength(); public native b2ParticleSystemDef repulsiveStrength(float repulsiveStrength);

	/** Produces repulsion between powder particles
	 *  Larger values repulse more */
	public native @Cast("float32") float powderStrength(); public native b2ParticleSystemDef powderStrength(float powderStrength);

	/** Pushes particles out of solid particle group
	 *  Larger values repulse more */
	public native @Cast("float32") float ejectionStrength(); public native b2ParticleSystemDef ejectionStrength(float ejectionStrength);

	/** Produces static pressure
	 *  Larger values increase the pressure on neighboring partilces
	 *  For a description of static pressure, see
	 *  http://en.wikipedia.org/wiki/Static_pressure#Static_pressure_in_fluid_dynamics */
	public native @Cast("float32") float staticPressureStrength(); public native b2ParticleSystemDef staticPressureStrength(float staticPressureStrength);

	/** Reduces instability in static pressure calculation
	 *  Larger values make stabilize static pressure with fewer iterations */
	public native @Cast("float32") float staticPressureRelaxation(); public native b2ParticleSystemDef staticPressureRelaxation(float staticPressureRelaxation);

	/** Computes static pressure more precisely
	 *  See SetStaticPressureIterations for details */
	public native @Cast("int32") int staticPressureIterations(); public native b2ParticleSystemDef staticPressureIterations(int staticPressureIterations);

	/** Determines how fast colors are mixed
	 *  1.0f ==> mixed immediately
	 *  0.5f ==> mixed half way each simulation step (see b2World::Step()) */
	public native @Cast("float32") float colorMixingStrength(); public native b2ParticleSystemDef colorMixingStrength(float colorMixingStrength);

	/** Whether to destroy particles by age when no more particles can be
	 *  created.  See #b2ParticleSystem::SetDestructionByAge() for
	 *  more information. */
	public native @Cast("bool") boolean destroyByAge(); public native b2ParticleSystemDef destroyByAge(boolean destroyByAge);

	/** Granularity of particle lifetimes in seconds.  By default this is
	 *  set to (1.0f / 60.0f) seconds.  b2ParticleSystem uses a 32-bit signed
	 *  value to track particle lifetimes so the maximum lifetime of a
	 *  particle is (2^32 - 1) / (1.0f / lifetimeGranularity) seconds.
	 *  With the value set to 1/60 the maximum lifetime or age of a particle is
	 *  2.27 years. */
	public native @Cast("float32") float lifetimeGranularity(); public native b2ParticleSystemDef lifetimeGranularity(float lifetimeGranularity);
}


@NoOffset public static class b2ParticleSystem extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2ParticleSystem(Pointer p) { super(p); }

	/** Create a particle whose properties have been defined.
	 *  No reference to the definition is retained.
	 *  A simulation step must occur before it's possible to interact with a
	 *  newly created particle.  For example, DestroyParticleInShape() will
	 *  not destroy a particle until b2World::Step() has been called.
	 *  \warning This function is locked during callbacks.
	 *  @return the index of the particle. */
	public native @Cast("int32") int CreateParticle(@Const @ByRef b2ParticleDef def);

	/** Retrieve a handle to the particle at the specified index.
	 *  Please see #b2ParticleHandle for why you might want a handle. */
	public native @Const b2ParticleHandle GetParticleHandleFromIndex(@Cast("const int32") int index);

	/** Destroy a particle.
	 *  The particle is removed after the next simulation step (see
	 *  b2World::Step()). */
	public native void DestroyParticle(@Cast("int32") int index);

	/** Destroy a particle.
	 *  The particle is removed after the next step.
	 *  @param Index of the particle to destroy.
	 *  @param Whether to call the destruction listener just before the
	 *  particle is destroyed. */
	public native void DestroyParticle(@Cast("int32") int index, @Cast("bool") boolean callDestructionListener);

	/** Destroy the Nth oldest particle in the system.
	 *  The particle is removed after the next b2World::Step().
	 *  @param Index of the Nth oldest particle to destroy, 0 will destroy the
	 *  oldest particle in the system, 1 will destroy the next oldest
	 *  particle etc.
	 *  @param Whether to call the destruction listener just before the
	 *  particle is destroyed. */
	public native void DestroyOldestParticle(@Cast("const int32") int index,
								   @Cast("const bool") boolean callDestructionListener);

	/** Destroy particles inside a shape without enabling the destruction
	 *  callback for destroyed particles.
	 *  This function is locked during callbacks.
	 *  For more information see
	 *  DestroyParticleInShape(const b2Shape&, const b2Transform&,bool).
	 *  @param Shape which encloses particles that should be destroyed.
	 *  @param Transform applied to the shape.
	 *  \warning This function is locked during callbacks.
	 *  @return Number of particles destroyed. */
	public native @Cast("int32") int DestroyParticlesInShape(@Const @ByRef b2Shape shape, @Const @ByRef b2Transform xf);

	/** Destroy particles inside a shape.
	 *  This function is locked during callbacks.
	 *  In addition, this function immediately destroys particles in the shape
	 *  in constrast to DestroyParticle() which defers the destruction until
	 *  the next simulation step.
	 *  @param Shape which encloses particles that should be destroyed.
	 *  @param Transform applied to the shape.
	 *  @param Whether to call the world b2DestructionListener for each
	 *  particle destroyed.
	 *  \warning This function is locked during callbacks.
	 *  @return Number of particles destroyed. */
	public native @Cast("int32") int DestroyParticlesInShape(@Const @ByRef b2Shape shape, @Const @ByRef b2Transform xf,
		                              @Cast("bool") boolean callDestructionListener);

	/** Create a particle group whose properties have been defined. No
	 *  reference to the definition is retained.
	 *  \warning This function is locked during callbacks. */
	public native b2ParticleGroup CreateParticleGroup(@Const @ByRef b2ParticleGroupDef def);

	/** Join two particle groups.
	 *  @param the first group. Expands to encompass the second group.
	 *  @param the second group. It is destroyed.
	 *  \warning This function is locked during callbacks. */
	public native void JoinParticleGroups(b2ParticleGroup groupA, b2ParticleGroup groupB);

	/** Split particle group into multiple disconnected groups.
	 *  @param the group to be split.
	 *  \warning This function is locked during callbacks. */
	public native void SplitParticleGroup(b2ParticleGroup group);

	/** Get the world particle group list. With the returned group, use
	 *  b2ParticleGroup::GetNext to get the next group in the world list.
	 *  A NULL group indicates the end of the list.
	 *  @return the head of the world particle group list. */
	public native b2ParticleGroup GetParticleGroupList();

	/** Get the number of particle groups. */
	public native @Cast("int32") int GetParticleGroupCount();

	/** Get the number of particles. */
	public native @Cast("int32") int GetParticleCount();

	/** Get the maximum number of particles. */
	public native @Cast("int32") int GetMaxParticleCount();

	/** Set the maximum number of particles.
	 *  A value of 0 means there is no maximum. The particle buffers can
	 *  continue to grow while b2World's block allocator still has memory.
	 *  Note: If you try to CreateParticle() with more than this count,
	 *  b2_invalidParticleIndex is returned unless
	 *  SetDestructionByAge() is used to enable the destruction of the
	 *  oldest particles in the system. */
	public native void SetMaxParticleCount(@Cast("int32") int count);

	/** Get all existing particle flags. */
	public native @Cast("uint32") long GetAllParticleFlags();

	/** Get all existing particle group flags. */
	public native @Cast("uint32") long GetAllGroupFlags();

	/** Pause or unpause the particle system. When paused, b2World::Step()
	 *  skips over this particle system. All b2ParticleSystem function calls
	 *  still work.
	 *  @param paused is true to pause, false to un-pause. */
	public native void SetPaused(@Cast("bool") boolean paused);

	/** @return true if the particle system is being updated in
	 *  b2World::Step().
	 *  Initially, true, then, the last value passed into SetPaused(). */
	public native @Cast("bool") boolean GetPaused();

	/** Change the particle density.
	 *  Particle density affects the mass of the particles, which in turn
	 *  affects how the particles interact with b2Bodies. Note that the density
	 *  does not affect how the particles interact with each other. */
	public native void SetDensity(@Cast("float32") float density);

	/** Get the particle density. */
	public native @Cast("float32") float GetDensity();

	/** Change the particle gravity scale. Adjusts the effect of the global
	 *  gravity vector on particles. */
	public native void SetGravityScale(@Cast("float32") float gravityScale);

	/** Get the particle gravity scale. */
	public native @Cast("float32") float GetGravityScale();

	/** Damping is used to reduce the velocity of particles. The damping
	 *  parameter can be larger than 1.0f but the damping effect becomes
	 *  sensitive to the time step when the damping parameter is large. */
	public native void SetDamping(@Cast("float32") float damping);

	/** Get damping for particles */
	public native @Cast("float32") float GetDamping();

	/** Change the number of iterations when calculating the static pressure of
	 *  particles. By default, 8 iterations. You can reduce the number of
	 *  iterations down to 1 in some situations, but this may cause
	 *  instabilities when many particles come together. If you see particles
	 *  popping away from each other like popcorn, you may have to increase the
	 *  number of iterations.
	 *  For a description of static pressure, see
	 *  http://en.wikipedia.org/wiki/Static_pressure#Static_pressure_in_fluid_dynamics */
	public native void SetStaticPressureIterations(@Cast("int32") int iterations);

	/** Get the number of iterations for static pressure of particles. */
	public native @Cast("int32") int GetStaticPressureIterations();

	/** Change the particle radius.
	 *  You should set this only once, on world start.
	 *  If you change the radius during execution, existing particles may
	 *  explode, shrink, or behave unexpectedly. */
	public native void SetRadius(@Cast("float32") float radius);

	/** Get the particle radius. */
	public native @Cast("float32") float GetRadius();

	/** Get the position of each particle
	 *  Array is length GetParticleCount()
	 *  @return the pointer to the head of the particle positions array. */
	public native b2Vec2 GetPositionBuffer();

	/** Get the velocity of each particle
	 *  Array is length GetParticleCount()
	 *  @return the pointer to the head of the particle velocities array. */
	public native b2Vec2 GetVelocityBuffer();

	/** Get the color of each particle
	 *  Array is length GetParticleCount()
	 *  @return the pointer to the head of the particle colors array. */
	public native b2ParticleColor GetColorBuffer();

	/** Get the particle-group of each particle.
	 *  Array is length GetParticleCount()
	 *  @return the pointer to the head of the particle group array. */
	public native @Cast("b2ParticleGroup*const*") PointerPointer GetGroupBuffer();

	/** Get the weight of each particle
	 *  Array is length GetParticleCount()
	 *  @return the pointer to the head of the particle positions array. */
	public native @Cast("float32*") FloatPointer GetWeightBuffer();

	/** Get the user-specified data of each particle.
	 *  Array is length GetParticleCount()
	 *  @return the pointer to the head of the particle user-data array. */
	public native @Cast("void**") PointerPointer GetUserDataBuffer();

	/** Get the flags for each particle. See the b2ParticleFlag enum.
	 *  Array is length GetParticleCount()
	 *  @return the pointer to the head of the particle-flags array. */
	public native @Cast("const uint32*") IntPointer GetFlagsBuffer();

	/** Set flags for a particle. See the b2ParticleFlag enum. */
	public native void SetParticleFlags(@Cast("int32") int index, @Cast("uint32") long flags);
	/** Get flags for a particle. See the b2ParticleFlag enum. */
	
	///
	///
	public native @Cast("uint32") long GetParticleFlags(@Cast("const int32") int index);

	/** Set an external buffer for particle data.
	 *  Normally, the b2World's block allocator is used for particle data.
	 *  However, sometimes you may have an OpenGL or Java buffer for particle
	 *  data. To avoid data duplication, you may supply this external buffer.
	 * 
	 *  Note that, when b2World's block allocator is used, the particle data
	 *  buffers can grow as required. However, when external buffers are used,
	 *  the maximum number of particles is clamped to the size of the smallest
	 *  external buffer.
	 * 
	 *  @param buffer is a pointer to a block of memory.
	 *  @param size is the number of values in the block. */
	public native void SetFlagsBuffer(@Cast("uint32*") IntPointer buffer, @Cast("int32") int capacity);
	public native void SetFlagsBuffer(@Cast("uint32*") IntBuffer buffer, @Cast("int32") int capacity);
	public native void SetFlagsBuffer(@Cast("uint32*") int[] buffer, @Cast("int32") int capacity);
	public native void SetPositionBuffer(b2Vec2 buffer, @Cast("int32") int capacity);
	public native void SetVelocityBuffer(b2Vec2 buffer, @Cast("int32") int capacity);
	public native void SetColorBuffer(b2ParticleColor buffer, @Cast("int32") int capacity);
	public native void SetUserDataBuffer(@Cast("void**") PointerPointer buffer, @Cast("int32") int capacity);
	public native void SetUserDataBuffer(@Cast("void**") @ByPtrPtr Pointer buffer, @Cast("int32") int capacity);

	/** Get contacts between particles
	 *  Contact data can be used for many reasons, for example to trigger
	 *  rendering or audio effects. */
	public native @Const b2ParticleContact GetContacts();
	public native @Cast("int32") int GetContactCount();

	/** Get contacts between particles and bodies
	 *  Contact data can be used for many reasons, for example to trigger
	 *  rendering or audio effects. */
	public native @Const b2ParticleBodyContact GetBodyContacts();
	public native @Cast("int32") int GetBodyContactCount();

	/** Get array of particle pairs. The particles in a pair:
	 *    (1) are contacting,
	 *    (2) are in the same particle group,
	 *    (3) are part of a rigid particle group, or are spring, elastic,
	 *        or wall particles.
	 *    (4) have at least one particle that is a spring or barrier
	 *        particle (i.e. one of the types in k_pairFlags),
	 *    (5) have at least one particle that returns true for
	 *        ConnectionFilter::IsNecessary,
	 *    (6) are not zombie particles.
	 *  Essentially, this is an array of spring or barrier particles that
	 *  are interacting. The array is sorted by b2ParticlePair's indexA,
	 *  and then indexB. There are no duplicate entries. */
	public native @Const b2ParticlePair GetPairs();
	public native @Cast("int32") int GetPairCount();

	/** Get array of particle triads. The particles in a triad:
	 *    (1) are in the same particle group,
	 *    (2) are in a Voronoi triangle together,
	 *    (3) are within b2_maxTriadDistance particle diameters of each
	 *        other,
	 *    (4) return true for ConnectionFilter::ShouldCreateTriad
	 *    (5) have at least one particle of type elastic (i.e. one of the
	 *        types in k_triadFlags),
	 *    (6) are part of a rigid particle group, or are spring, elastic,
	 *        or wall particles.
	 *    (7) are not zombie particles.
	 *  Essentially, this is an array of elastic particles that are
	 *  interacting. The array is sorted by b2ParticleTriad's indexA,
	 *  then indexB, then indexC. There are no duplicate entries. */
	public native @Const b2ParticleTriad GetTriads();
	public native @Cast("int32") int GetTriadCount();

	/** Set an optional threshold for the maximum number of
	 *  consecutive particle iterations that a particle may contact
	 *  multiple bodies before it is considered a candidate for being
	 *  "stuck". Setting to zero or less disables. */
	public native void SetStuckThreshold(@Cast("int32") int iterations);

	/** Get potentially stuck particles from the last step; the user must
	 *  decide if they are stuck or not, and if so, delete or move them */
	public native @Cast("const int32*") IntPointer GetStuckCandidates();

	/** Get the number of stuck particle candidates from the last step. */
	public native @Cast("int32") int GetStuckCandidateCount();

	/** Compute the kinetic energy that can be lost by damping force */
	public native @Cast("float32") float ComputeCollisionEnergy();

	/** Set strict Particle/Body contact check.
	 *  This is an option that will help ensure correct behavior if there are
	 *  corners in the world model where Particle/Body contact is ambiguous.
	 *  This option scales at n*log(n) of the number of Particle/Body contacts,
	 *  so it is best to only enable if it is necessary for your geometry.
	 *  Enable if you see strange particle behavior around b2Body
	 *  intersections. */
	public native void SetStrictContactCheck(@Cast("bool") boolean enabled);
	/** Get the status of the strict contact check. */
	public native @Cast("bool") boolean GetStrictContactCheck();

	/** Set the lifetime (in seconds) of a particle relative to the current
	 *  time.  A lifetime of less than or equal to 0.0f results in the particle
	 *  living forever until it's manually destroyed by the application. */
	public native void SetParticleLifetime(@Cast("const int32") int index, @Cast("const float32") float lifetime);
	/** Get the lifetime (in seconds) of a particle relative to the current
	 *  time.  A value > 0.0f is returned if the particle is scheduled to be
	 *  destroyed in the future, values <= 0.0f indicate the particle has an
	 *  infinite lifetime. */
	public native @Cast("float32") float GetParticleLifetime(@Cast("const int32") int index);

	/** Enable / disable destruction of particles in CreateParticle() when
	 *  no more particles can be created due to a prior call to
	 *  SetMaxParticleCount().  When this is enabled, the oldest particle is
	 *  destroyed in CreateParticle() favoring the destruction of particles
	 *  with a finite lifetime over particles with infinite lifetimes.
	 *  This feature is enabled by default when particle lifetimes are
	 *  tracked.  Explicitly enabling this feature using this function enables
	 *  particle lifetime tracking. */
	public native void SetDestructionByAge(@Cast("const bool") boolean enable);
	/** Get whether the oldest particle will be destroyed in CreateParticle()
	 *  when the maximum number of particles are present in the system. */
	public native @Cast("bool") boolean GetDestructionByAge();

	/** Get the array of particle expiration times indexed by particle index.
	 *  GetParticleCount() items are in the returned array. */
	public native @Cast("const int32*") IntPointer GetExpirationTimeBuffer();
	/** Convert a expiration time value in returned by
	 *  GetExpirationTimeBuffer() to a time in seconds relative to the
	 *  current simulation time. */
	public native @Cast("float32") float ExpirationTimeToLifetime(@Cast("const int32") int expirationTime);
	/** Get the array of particle indices ordered by reverse lifetime.
	 *  The oldest particle indexes are at the end of the array with the
	 *  newest at the start.  Particles with infinite lifetimes
	 *  (i.e expiration times less than or equal to 0) are placed at the start
	 *   of the array.
	 *  ExpirationTimeToLifetime(GetExpirationTimeBuffer()[index])
	 *  is equivalent to GetParticleLifetime(index).
	 *  GetParticleCount() items are in the returned array. */
	public native @Cast("const int32*") IntPointer GetIndexByExpirationTimeBuffer();

	/** Apply an impulse to one particle. This immediately modifies the
	 *  velocity. Similar to b2Body::ApplyLinearImpulse.
	 *  @param index the particle that will be modified.
	 *  @param impulse the world impulse vector, usually in N-seconds or
     *         kg-m/s. */
	public native void ParticleApplyLinearImpulse(@Cast("int32") int index, @Const @ByRef b2Vec2 impulse);

	/** Apply an impulse to all particles between 'firstIndex' and 'lastIndex'.
	 *  This immediately modifies the velocity. Note that the impulse is
	 *  applied to the total mass of all particles. So, calling
	 *  ParticleApplyLinearImpulse(0, impulse) and
	 *  ParticleApplyLinearImpulse(1, impulse) will impart twice as much
	 *  velocity as calling just ApplyLinearImpulse(0, 1, impulse).
	 *  @param firstIndex the first particle to be modified.
	 *  @param lastIndex the last particle to be modified.
	 *  @param impulse the world impulse vector, usually in N-seconds or
     *         kg-m/s. */
	public native void ApplyLinearImpulse(@Cast("int32") int firstIndex, @Cast("int32") int lastIndex,
								@Const @ByRef b2Vec2 impulse);

	/** Apply a force to the center of a particle.
	 *  @param index the particle that will be modified.
	 *  @param force the world force vector, usually in Newtons (N). */
	public native void ParticleApplyForce(@Cast("int32") int index, @Const @ByRef b2Vec2 force);

	/** Distribute a force across several particles. The particles must not be
	 *  wall particles. Note that the force is distributed across all the
	 *  particles, so calling this function for indices 0..N is not the same as
	 *  calling ParticleApplyForce(i, force) for i in 0..N.
	 *  @param firstIndex the first particle to be modified.
	 *  @param lastIndex the last particle to be modified.
	 *  @param force the world force vector, usually in Newtons (N). */
	public native void ApplyForce(@Cast("int32") int firstIndex, @Cast("int32") int lastIndex, @Const @ByRef b2Vec2 force);

	/** Get the next particle-system in the world's particle-system list. */
	public native b2ParticleSystem GetNext();

	/** Query the particle system for all particles that potentially overlap
	 *  the provided AABB. b2QueryCallback::ShouldQueryParticleSystem is
	 *  ignored.
	 *  @param callback a user implemented callback class.
	 *  @param aabb the query box. */
	public native void QueryAABB(b2QueryCallback callback, @Const @ByRef b2AABB aabb);

	/** Query the particle system for all particles that potentially overlap
	 *  the provided shape's AABB. Calls QueryAABB internally.
	 *  b2QueryCallback::ShouldQueryParticleSystem is ignored.
	 *  @param callback a user implemented callback class.
	 *  @param shape the query shape
	 *  @param xf the transform of the AABB */
	public native void QueryShapeAABB(b2QueryCallback callback, @Const @ByRef b2Shape shape,
							@Const @ByRef b2Transform xf);

	/** Ray-cast the particle system for all particles in the path of the ray.
	 *  Your callback controls whether you get the closest point, any point, or
	 *  n-points. The ray-cast ignores particles that contain the starting
	 *  point. b2RayCastCallback::ShouldQueryParticleSystem is ignored.
	 *  @param callback a user implemented callback class.
	 *  @param point1 the ray starting point
	 *  @param point2 the ray ending point */
	public native void RayCast(b2RayCastCallback callback, @Const @ByRef b2Vec2 point1,
					 @Const @ByRef b2Vec2 point2);

	/** Compute the axis-aligned bounding box for all particles contained
	 *  within this particle system.
	 *  @param aabb Returns the axis-aligned bounding box of the system. */
	public native void ComputeAABB(b2AABB aabb);
	/** enum b2ParticleSystem::b2ExceptionType */
	public static final int
		b2_bufferTooSmall = 0,
		b2_particleIndexOutOfBounds = 1,
		b2_numErrors = 2,
		b2_noExceptions = 3;

	/** Set the velocity of particle at index with direct floats. */
	public native void SetParticleVelocity(@Cast("int32") int index, @Cast("float32") float vx, @Cast("float32") float vy);

	/** Get the x-coordinate of particle at index. */
	public native float GetParticlePositionX(@Cast("int32") int index);

	/** Get the y-coordinate of particle at index. */
	public native float GetParticlePositionY(@Cast("int32") int index);

	/** Copy position buffer into a specified buffer, starting from startIndex. */
	public native int CopyPositionBuffer(int startIndex, int numParticles, Pointer outBuf,
							   int size);

	/** Copy color buffer into a specified buffer, starting from startIndex. */
	public native int CopyColorBuffer(int startIndex, int numParticles, Pointer outBuf,
						    int size);

	/** Copy color buffer into a specified buffer, starting from startIndex. */
	public native int CopyWeightBuffer(int startIndex, int numParticles, Pointer outBuf,
							 int size);
}






// The reciprocal sqrt function differs between SIMD and non-SIMD, but they
// should create approximately equal results.

















































































































// Note: These functions must go in the header so the unit tests will compile
// them. b2ParticleSystem.cpp does not compile with this #define.
// #if LIQUIDFUN_EXTERNAL_LANGUAGE_API















// #endif // LIQUIDFUN_EXTERNAL_LANGUAGE_API

// #endif



// Parsed from liquidfun_adapters.h

// #include <Box2D/Common/b2Settings.h>

public static class b2DynamicTreeQueryCallback extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2DynamicTreeQueryCallback() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2DynamicTreeQueryCallback(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2DynamicTreeQueryCallback(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2DynamicTreeQueryCallback position(long position) {
        return (b2DynamicTreeQueryCallback)super.position(position);
    }

  @Virtual(true) public native @Cast("bool") boolean QueryCallback(@Cast("int32") int nodeId);
}

public static class b2DynamicTreeRayCastCallback extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public b2DynamicTreeRayCastCallback() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public b2DynamicTreeRayCastCallback(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public b2DynamicTreeRayCastCallback(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public b2DynamicTreeRayCastCallback position(long position) {
        return (b2DynamicTreeRayCastCallback)super.position(position);
    }

  @Virtual(true) public native @Cast("bool") boolean RayCastCallback(@ByRef b2RayCastInput subInput, @Cast("int32") int nodeId);
}


}
