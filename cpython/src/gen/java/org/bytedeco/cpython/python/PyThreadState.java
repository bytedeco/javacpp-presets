// Targeted by JavaCPP version 1.5-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.cpython.python;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.cpython.global.python.*;

// #else
@Properties(inherit = org.bytedeco.cpython.presets.python.class)
public class PyThreadState extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyThreadState() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyThreadState(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyThreadState(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyThreadState position(long position) {
        return (PyThreadState)super.position(position);
    }

    /* See Python/ceval.c for comments explaining most fields */

    public native _ts prev(); public native PyThreadState prev(_ts prev);
    public native _ts next(); public native PyThreadState next(_ts next);
    public native PyInterpreterState interp(); public native PyThreadState interp(PyInterpreterState interp);

    public native _frame frame(); public native PyThreadState frame(_frame frame);
    public native int recursion_depth(); public native PyThreadState recursion_depth(int recursion_depth);
    public native @Cast("char") byte overflowed(); public native PyThreadState overflowed(byte overflowed); /* The stack has overflowed. Allow 50 more calls
                        to handle the runtime error. */
    public native @Cast("char") byte recursion_critical(); public native PyThreadState recursion_critical(byte recursion_critical); /* The current calls must not cause
                                a stack overflow. */
    /* 'tracing' keeps track of the execution depth when tracing/profiling.
       This is to prevent the actual trace/profile code from being recorded in
       the trace/profile. */
    public native int tracing(); public native PyThreadState tracing(int tracing);
    public native int use_tracing(); public native PyThreadState use_tracing(int use_tracing);

    public native Py_tracefunc c_profilefunc(); public native PyThreadState c_profilefunc(Py_tracefunc c_profilefunc);
    public native Py_tracefunc c_tracefunc(); public native PyThreadState c_tracefunc(Py_tracefunc c_tracefunc);
    public native PyObject c_profileobj(); public native PyThreadState c_profileobj(PyObject c_profileobj);
    public native PyObject c_traceobj(); public native PyThreadState c_traceobj(PyObject c_traceobj);

    public native PyObject curexc_type(); public native PyThreadState curexc_type(PyObject curexc_type);
    public native PyObject curexc_value(); public native PyThreadState curexc_value(PyObject curexc_value);
    public native PyObject curexc_traceback(); public native PyThreadState curexc_traceback(PyObject curexc_traceback);

    public native PyObject exc_type(); public native PyThreadState exc_type(PyObject exc_type);
    public native PyObject exc_value(); public native PyThreadState exc_value(PyObject exc_value);
    public native PyObject exc_traceback(); public native PyThreadState exc_traceback(PyObject exc_traceback);

    public native PyObject dict(); public native PyThreadState dict(PyObject dict);  /* Stores per-thread state */

    public native int gilstate_counter(); public native PyThreadState gilstate_counter(int gilstate_counter);

    public native PyObject async_exc(); public native PyThreadState async_exc(PyObject async_exc); /* Asynchronous exception to raise */
    public native long thread_id(); public native PyThreadState thread_id(long thread_id); /* Thread id where this tstate was created */

    public native int trash_delete_nesting(); public native PyThreadState trash_delete_nesting(int trash_delete_nesting);
    public native PyObject trash_delete_later(); public native PyThreadState trash_delete_later(PyObject trash_delete_later);

    /* Called when a thread state is deleted normally, but not when it
     * is destroyed after fork().
     * Pain:  to prevent rare but fatal shutdown errors (issue 18808),
     * Thread.join() must wait for the join'ed thread's tstate to be unlinked
     * from the tstate chain.  That happens at the end of a thread's life,
     * in pystate.c.
     * The obvious way doesn't quite work:  create a lock which the tstate
     * unlinking code releases, and have Thread.join() wait to acquire that
     * lock.  The problem is that we _are_ at the end of the thread's life:
     * if the thread holds the last reference to the lock, decref'ing the
     * lock will delete the lock, and that may trigger arbitrary Python code
     * if there's a weakref, with a callback, to the lock.  But by this time
     * _PyThreadState_Current is already NULL, so only the simplest of C code
     * can be allowed to run (in particular it must not be possible to
     * release the GIL).
     * So instead of holding the lock directly, the tstate holds a weakref to
     * the lock:  that's the value of on_delete_data below.  Decref'ing a
     * weakref is harmless.
     * on_delete points to _threadmodule.c's static release_sentinel() function.
     * After the tstate is unlinked, release_sentinel is called with the
     * weakref-to-lock (on_delete_data) argument, and release_sentinel releases
     * the indirectly held lock.
     */
    public static class On_delete_Pointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    On_delete_Pointer(Pointer p) { super(p); }
        protected On_delete_Pointer() { allocate(); }
        private native void allocate();
        public native void call(Pointer arg0);
    }
    public native On_delete_Pointer on_delete(); public native PyThreadState on_delete(On_delete_Pointer on_delete);
    public native Pointer on_delete_data(); public native PyThreadState on_delete_data(Pointer on_delete_data);

    public native PyObject coroutine_wrapper(); public native PyThreadState coroutine_wrapper(PyObject coroutine_wrapper);
    public native int in_coroutine_wrapper(); public native PyThreadState in_coroutine_wrapper(int in_coroutine_wrapper);

    /* Now used from PyInterpreterState, kept here for ABI
       compatibility with PyThreadState */
    
    

    public native PyObject async_gen_firstiter(); public native PyThreadState async_gen_firstiter(PyObject async_gen_firstiter);
    public native PyObject async_gen_finalizer(); public native PyThreadState async_gen_finalizer(PyObject async_gen_finalizer);

    /* XXX signal handlers should also be here */

}
