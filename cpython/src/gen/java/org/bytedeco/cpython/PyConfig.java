// Targeted by JavaCPP version 1.5.6-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.cpython;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

import static org.bytedeco.cpython.global.python.*;



/* --- PyConfig ---------------------------------------------- */

@Properties(inherit = org.bytedeco.cpython.presets.python.class)
public class PyConfig extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyConfig() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyConfig(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyConfig(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyConfig position(long position) {
        return (PyConfig)super.position(position);
    }
    @Override public PyConfig getPointer(long i) {
        return new PyConfig((Pointer)this).position(position + i);
    }

    public native int _config_init(); public native PyConfig _config_init(int setter);     /* _PyConfigInitEnum value */

    public native int isolated(); public native PyConfig isolated(int setter);         /* Isolated mode? see PyPreConfig.isolated */
    public native int use_environment(); public native PyConfig use_environment(int setter);  /* Use environment variables? see PyPreConfig.use_environment */
    public native int dev_mode(); public native PyConfig dev_mode(int setter);         /* Python Development Mode? See PyPreConfig.dev_mode */

    /* Install signal handlers? Yes by default. */
    public native int install_signal_handlers(); public native PyConfig install_signal_handlers(int setter);

    public native int use_hash_seed(); public native PyConfig use_hash_seed(int setter);      /* PYTHONHASHSEED=x */
    public native @Cast("unsigned long") long hash_seed(); public native PyConfig hash_seed(long setter);

    /* Enable faulthandler?
       Set to 1 by -X faulthandler and PYTHONFAULTHANDLER. -1 means unset. */
    public native int faulthandler(); public native PyConfig faulthandler(int setter);

    /* Enable PEG parser?
       1 by default, set to 0 by -X oldparser and PYTHONOLDPARSER */
    public native int _use_peg_parser(); public native PyConfig _use_peg_parser(int setter);

    /* Enable tracemalloc?
       Set by -X tracemalloc=N and PYTHONTRACEMALLOC. -1 means unset */
    public native int tracemalloc(); public native PyConfig tracemalloc(int setter);

    public native int import_time(); public native PyConfig import_time(int setter);        /* PYTHONPROFILEIMPORTTIME, -X importtime */
    public native int show_ref_count(); public native PyConfig show_ref_count(int setter);     /* -X showrefcount */
    public native int dump_refs(); public native PyConfig dump_refs(int setter);          /* PYTHONDUMPREFS */
    public native int malloc_stats(); public native PyConfig malloc_stats(int setter);       /* PYTHONMALLOCSTATS */

    /* Python filesystem encoding and error handler:
       sys.getfilesystemencoding() and sys.getfilesystemencodeerrors().

       Default encoding and error handler:

       * if Py_SetStandardStreamEncoding() has been called: they have the
         highest priority;
       * PYTHONIOENCODING environment variable;
       * The UTF-8 Mode uses UTF-8/surrogateescape;
       * If Python forces the usage of the ASCII encoding (ex: C locale
         or POSIX locale on FreeBSD or HP-UX), use ASCII/surrogateescape;
       * locale encoding: ANSI code page on Windows, UTF-8 on Android and
         VxWorks, LC_CTYPE locale encoding on other platforms;
       * On Windows, "surrogateescape" error handler;
       * "surrogateescape" error handler if the LC_CTYPE locale is "C" or "POSIX";
       * "surrogateescape" error handler if the LC_CTYPE locale has been coerced
         (PEP 538);
       * "strict" error handler.

       Supported error handlers: "strict", "surrogateescape" and
       "surrogatepass". The surrogatepass error handler is only supported
       if Py_DecodeLocale() and Py_EncodeLocale() use directly the UTF-8 codec;
       it's only used on Windows.

       initfsencoding() updates the encoding to the Python codec name.
       For example, "ANSI_X3.4-1968" is replaced with "ascii".

       On Windows, sys._enablelegacywindowsfsencoding() sets the
       encoding/errors to mbcs/replace at runtime.


       See Py_FileSystemDefaultEncoding and Py_FileSystemDefaultEncodeErrors.
       */
    public native @Cast("wchar_t*") Pointer filesystem_encoding(); public native PyConfig filesystem_encoding(Pointer setter);
    public native @Cast("wchar_t*") Pointer filesystem_errors(); public native PyConfig filesystem_errors(Pointer setter);

    public native @Cast("wchar_t*") Pointer pycache_prefix(); public native PyConfig pycache_prefix(Pointer setter);  /* PYTHONPYCACHEPREFIX, -X pycache_prefix=PATH */
    public native int parse_argv(); public native PyConfig parse_argv(int setter);           /* Parse argv command line arguments? */

    /* Command line arguments (sys.argv).

       Set parse_argv to 1 to parse argv as Python command line arguments
       and then strip Python arguments from argv.

       If argv is empty, an empty string is added to ensure that sys.argv
       always exists and is never empty. */
    public native @ByRef PyWideStringList argv(); public native PyConfig argv(PyWideStringList setter);

    /* Program name:

       - If Py_SetProgramName() was called, use its value.
       - On macOS, use PYTHONEXECUTABLE environment variable if set.
       - If WITH_NEXT_FRAMEWORK macro is defined, use __PYVENV_LAUNCHER__
         environment variable is set.
       - Use argv[0] if available and non-empty.
       - Use "python" on Windows, or "python3 on other platforms. */
    public native @Cast("wchar_t*") Pointer program_name(); public native PyConfig program_name(Pointer setter);

    public native @ByRef PyWideStringList xoptions(); public native PyConfig xoptions(PyWideStringList setter);     /* Command line -X options */

    /* Warnings options: lowest to highest priority. warnings.filters
       is built in the reverse order (highest to lowest priority). */
    public native @ByRef PyWideStringList warnoptions(); public native PyConfig warnoptions(PyWideStringList setter);

    /* If equal to zero, disable the import of the module site and the
       site-dependent manipulations of sys.path that it entails. Also disable
       these manipulations if site is explicitly imported later (call
       site.main() if you want them to be triggered).

       Set to 0 by the -S command line option. If set to -1 (default), it is
       set to !Py_NoSiteFlag. */
    public native int site_import(); public native PyConfig site_import(int setter);

    /* Bytes warnings:

       * If equal to 1, issue a warning when comparing bytes or bytearray with
         str or bytes with int.
       * If equal or greater to 2, issue an error.

       Incremented by the -b command line option. If set to -1 (default), inherit
       Py_BytesWarningFlag value. */
    public native int bytes_warning(); public native PyConfig bytes_warning(int setter);

    /* If greater than 0, enable inspect: when a script is passed as first
       argument or the -c option is used, enter interactive mode after
       executing the script or the command, even when sys.stdin does not appear
       to be a terminal.

       Incremented by the -i command line option. Set to 1 if the PYTHONINSPECT
       environment variable is non-empty. If set to -1 (default), inherit
       Py_InspectFlag value. */
    public native int inspect(); public native PyConfig inspect(int setter);

    /* If greater than 0: enable the interactive mode (REPL).

       Incremented by the -i command line option. If set to -1 (default),
       inherit Py_InteractiveFlag value. */
    public native int interactive(); public native PyConfig interactive(int setter);

    /* Optimization level.

       Incremented by the -O command line option. Set by the PYTHONOPTIMIZE
       environment variable. If set to -1 (default), inherit Py_OptimizeFlag
       value. */
    public native int optimization_level(); public native PyConfig optimization_level(int setter);

    /* If greater than 0, enable the debug mode: turn on parser debugging
       output (for expert only, depending on compilation options).

       Incremented by the -d command line option. Set by the PYTHONDEBUG
       environment variable. If set to -1 (default), inherit Py_DebugFlag
       value. */
    public native int parser_debug(); public native PyConfig parser_debug(int setter);

    /* If equal to 0, Python won't try to write ``.pyc`` files on the
       import of source modules.

       Set to 0 by the -B command line option and the PYTHONDONTWRITEBYTECODE
       environment variable. If set to -1 (default), it is set to
       !Py_DontWriteBytecodeFlag. */
    public native int write_bytecode(); public native PyConfig write_bytecode(int setter);

    /* If greater than 0, enable the verbose mode: print a message each time a
       module is initialized, showing the place (filename or built-in module)
       from which it is loaded.

       If greater or equal to 2, print a message for each file that is checked
       for when searching for a module. Also provides information on module
       cleanup at exit.

       Incremented by the -v option. Set by the PYTHONVERBOSE environment
       variable. If set to -1 (default), inherit Py_VerboseFlag value. */
    public native int verbose(); public native PyConfig verbose(int setter);

    /* If greater than 0, enable the quiet mode: Don't display the copyright
       and version messages even in interactive mode.

       Incremented by the -q option. If set to -1 (default), inherit
       Py_QuietFlag value. */
    public native int quiet(); public native PyConfig quiet(int setter);

   /* If greater than 0, don't add the user site-packages directory to
      sys.path.

      Set to 0 by the -s and -I command line options , and the PYTHONNOUSERSITE
      environment variable. If set to -1 (default), it is set to
      !Py_NoUserSiteDirectory. */
    public native int user_site_directory(); public native PyConfig user_site_directory(int setter);

    /* If non-zero, configure C standard steams (stdio, stdout,
       stderr):

       - Set O_BINARY mode on Windows.
       - If buffered_stdio is equal to zero, make streams unbuffered.
         Otherwise, enable streams buffering if interactive is non-zero. */
    public native int configure_c_stdio(); public native PyConfig configure_c_stdio(int setter);

    /* If equal to 0, enable unbuffered mode: force the stdout and stderr
       streams to be unbuffered.

       Set to 0 by the -u option. Set by the PYTHONUNBUFFERED environment
       variable.
       If set to -1 (default), it is set to !Py_UnbufferedStdioFlag. */
    public native int buffered_stdio(); public native PyConfig buffered_stdio(int setter);

    /* Encoding of sys.stdin, sys.stdout and sys.stderr.
       Value set from PYTHONIOENCODING environment variable and
       Py_SetStandardStreamEncoding() function.
       See also 'stdio_errors' attribute. */
    public native @Cast("wchar_t*") Pointer stdio_encoding(); public native PyConfig stdio_encoding(Pointer setter);

    /* Error handler of sys.stdin and sys.stdout.
       Value set from PYTHONIOENCODING environment variable and
       Py_SetStandardStreamEncoding() function.
       See also 'stdio_encoding' attribute. */
    public native @Cast("wchar_t*") Pointer stdio_errors(); public native PyConfig stdio_errors(Pointer setter);

// #ifdef MS_WINDOWS
// #endif

    /* Value of the --check-hash-based-pycs command line option:

       - "default" means the 'check_source' flag in hash-based pycs
         determines invalidation
       - "always" causes the interpreter to hash the source file for
         invalidation regardless of value of 'check_source' bit
       - "never" causes the interpreter to always assume hash-based pycs are
         valid

       The default value is "default".

       See PEP 552 "Deterministic pycs" for more details. */
    public native @Cast("wchar_t*") Pointer check_hash_pycs_mode(); public native PyConfig check_hash_pycs_mode(Pointer setter);

    /* --- Path configuration inputs ------------ */

    /* If greater than 0, suppress _PyPathConfig_Calculate() warnings on Unix.
       The parameter has no effect on Windows.

       If set to -1 (default), inherit !Py_FrozenFlag value. */
    public native int pathconfig_warnings(); public native PyConfig pathconfig_warnings(int setter);

    public native @Cast("wchar_t*") Pointer pythonpath_env(); public native PyConfig pythonpath_env(Pointer setter); /* PYTHONPATH environment variable */
    public native @Cast("wchar_t*") Pointer home(); public native PyConfig home(Pointer setter);          /* PYTHONHOME environment variable,
                               see also Py_SetPythonHome(). */

    /* --- Path configuration outputs ----------- */

    public native int module_search_paths_set(); public native PyConfig module_search_paths_set(int setter);  /* If non-zero, use module_search_paths */
    public native @ByRef PyWideStringList module_search_paths(); public native PyConfig module_search_paths(PyWideStringList setter);  /* sys.path paths. Computed if
                                       module_search_paths_set is equal
                                       to zero. */

    public native @Cast("wchar_t*") Pointer executable(); public native PyConfig executable(Pointer setter);        /* sys.executable */
    public native @Cast("wchar_t*") Pointer base_executable(); public native PyConfig base_executable(Pointer setter);   /* sys._base_executable */
    public native @Cast("wchar_t*") Pointer prefix(); public native PyConfig prefix(Pointer setter);            /* sys.prefix */
    public native @Cast("wchar_t*") Pointer base_prefix(); public native PyConfig base_prefix(Pointer setter);       /* sys.base_prefix */
    public native @Cast("wchar_t*") Pointer exec_prefix(); public native PyConfig exec_prefix(Pointer setter);       /* sys.exec_prefix */
    public native @Cast("wchar_t*") Pointer base_exec_prefix(); public native PyConfig base_exec_prefix(Pointer setter);  /* sys.base_exec_prefix */
    public native @Cast("wchar_t*") Pointer platlibdir(); public native PyConfig platlibdir(Pointer setter);        /* sys.platlibdir */

    /* --- Parameter only used by Py_Main() ---------- */

    /* Skip the first line of the source ('run_filename' parameter), allowing use of non-Unix forms of
       "#!cmd".  This is intended for a DOS specific hack only.

       Set by the -x command line option. */
    public native int skip_source_first_line(); public native PyConfig skip_source_first_line(int setter);

    public native @Cast("wchar_t*") Pointer run_command(); public native PyConfig run_command(Pointer setter);   /* -c command line argument */
    public native @Cast("wchar_t*") Pointer run_module(); public native PyConfig run_module(Pointer setter);    /* -m command line argument */
    public native @Cast("wchar_t*") Pointer run_filename(); public native PyConfig run_filename(Pointer setter);  /* Trailing command line argument without -c or -m */

    /* --- Private fields ---------------------------- */

    /* Install importlib? If set to 0, importlib is not initialized at all.
       Needed by freeze_importlib. */
    public native int _install_importlib(); public native PyConfig _install_importlib(int setter);

    /* If equal to 0, stop Python initialization before the "main" phase */
    public native int _init_main(); public native PyConfig _init_main(int setter);

    /* If non-zero, disallow threads, subprocesses, and fork.
       Default: 0. */
    public native int _isolated_interpreter(); public native PyConfig _isolated_interpreter(int setter);

    /* Original command line arguments. If _orig_argv is empty and _argv is
       not equal to [''], PyConfig_Read() copies the configuration 'argv' list
       into '_orig_argv' list before modifying 'argv' list (if parse_argv
       is non-zero).

       _PyConfig_Write() initializes Py_GetArgcArgv() to this list. */
    public native @ByRef PyWideStringList _orig_argv(); public native PyConfig _orig_argv(PyWideStringList setter);
}
