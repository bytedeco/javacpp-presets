// Targeted by JavaCPP version 1.5.13-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.cpython.global;

import org.bytedeco.cpython.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

public class python extends org.bytedeco.cpython.helper.python {
    static { Loader.load(); }

// Parsed from Python.h

// Entry point of the Python C API.
// C extensions should only #include <Python.h>, and not include directly
// the other Python header files included by <Python.h>.

// #ifndef Py_PYTHON_H
// #define Py_PYTHON_H

// Since this is a "meta-include" file, "#ifdef __cplusplus / extern "C" {"
// is not needed.


// Include Python header files
// #include "patchlevel.h"
// #include "pyconfig.h"
// #include "pymacconfig.h"


// Include standard header files
// When changing these files, remember to update Doc/extending/extending.rst.
// #include <assert.h>               // assert()
// #include <inttypes.h>             // uintptr_t
// #include <limits.h>               // INT_MAX
// #include <math.h>                 // HUGE_VAL
// #include <stdarg.h>               // va_list
// #include <wchar.h>                // wchar_t
// #ifdef HAVE_SYS_TYPES_H
// #  include <sys/types.h>          // ssize_t
// #endif

// <errno.h>, <stdio.h>, <stdlib.h> and <string.h> headers are no longer used
// by Python, but kept for the backward compatibility of existing third party C
// extensions. They are not included by limited C API version 3.11 and newer.
//
// The <ctype.h> and <unistd.h> headers are not included by limited C API
// version 3.13 and newer.
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030d0000
// #  include <ctype.h>              // tolower()
// #  ifndef MS_WINDOWS
// #    include <unistd.h>           // close()
// #  endif
// #endif

// gh-111506: The free-threaded build is not compatible with the limited API
// or the stable ABI.
// #if defined(Py_LIMITED_API) && defined(Py_GIL_DISABLED)
// #  error "The limited API is not currently supported in the free-threaded build"
// #endif

// #if defined(Py_GIL_DISABLED) && defined(_MSC_VER)
// #  include <intrin.h>             // __readgsqword()
// #endif

// #if defined(Py_GIL_DISABLED) && defined(__MINGW32__)
// #  include <intrin.h>             // __readgsqword()
// #endif

// Suppress known warnings in Python header files.
// #if defined(_MSC_VER)
// Warning that alignas behaviour has changed. Doesn't affect us, because we
// never relied on the old behaviour.
// #pragma warning(push)
// #pragma warning(disable: 5274)
// #endif

// Include Python header files
// #include "pyport.h"
// #include "pymacro.h"
// #include "pymath.h"
// #include "pymem.h"
// #include "pytypedefs.h"
// #include "pybuffer.h"
// #include "pystats.h"
// #include "pyatomic.h"
// #include "lock.h"
// #include "critical_section.h"
// #include "object.h"
// #include "refcount.h"
// #include "objimpl.h"
// #include "typeslots.h"
// #include "pyhash.h"
// #include "cpython/pydebug.h"
// #include "bytearrayobject.h"
// #include "bytesobject.h"
// #include "unicodeobject.h"
// #include "pyerrors.h"
// #include "longobject.h"
// #include "cpython/longintrepr.h"
// #include "boolobject.h"
// #include "floatobject.h"
// #include "complexobject.h"
// #include "rangeobject.h"
// #include "memoryobject.h"
// #include "tupleobject.h"
// #include "listobject.h"
// #include "dictobject.h"
// #include "cpython/odictobject.h"
// #include "enumobject.h"
// #include "setobject.h"
// #include "methodobject.h"
// #include "moduleobject.h"
// #include "monitoring.h"
// #include "cpython/funcobject.h"
// #include "cpython/classobject.h"
// #include "fileobject.h"
// #include "pycapsule.h"
// #include "cpython/code.h"
// #include "pyframe.h"
// #include "traceback.h"
// #include "sliceobject.h"
// #include "cpython/cellobject.h"
// #include "iterobject.h"
// #include "cpython/initconfig.h"
// #include "pystate.h"
// #include "cpython/genobject.h"
// #include "descrobject.h"
// #include "genericaliasobject.h"
// #include "warnings.h"
// #include "weakrefobject.h"
// #include "structseq.h"
// #include "cpython/picklebufobject.h"
// #include "cpython/pytime.h"
// #include "codecs.h"
// #include "pythread.h"
// #include "cpython/context.h"
// #include "modsupport.h"
// #include "compile.h"
// #include "pythonrun.h"
// #include "pylifecycle.h"
// #include "ceval.h"
// #include "sysmodule.h"
// #include "audit.h"
// #include "osmodule.h"
// #include "intrcheck.h"
// #include "import.h"
// #include "abstract.h"
// #include "bltinmodule.h"
// #include "cpython/pyctype.h"
// #include "pystrtod.h"
// #include "pystrcmp.h"
// #include "fileutils.h"
// #include "cpython/pyfpe.h"
// #include "cpython/tracemalloc.h"

// Restore warning filter
// #ifdef _MSC_VER
// #pragma warning(pop)
// #endif

// #endif /* !Py_PYTHON_H */


// Parsed from patchlevel.h

// #ifndef _Py_PATCHLEVEL_H
// #define _Py_PATCHLEVEL_H
/* Python version identification scheme.

   When the major or minor version changes, the VERSION variable in
   configure.ac must also be changed.

   There is also (independent) API version information in modsupport.h.
*/

/* Values for PY_RELEASE_LEVEL */
public static final int PY_RELEASE_LEVEL_ALPHA =  0xA;
public static final int PY_RELEASE_LEVEL_BETA =   0xB;
public static final int PY_RELEASE_LEVEL_GAMMA =  0xC;     /* For release candidates */
public static final int PY_RELEASE_LEVEL_FINAL =  0xF;     /* Serial should be 0 here */
                                        /* Higher for patch releases */

/* Version parsed out into numeric values */
/*--start constants--*/
public static final int PY_MAJOR_VERSION =        3;
public static final int PY_MINOR_VERSION =        14;
public static final int PY_MICRO_VERSION =        2;
public static final int PY_RELEASE_LEVEL =        PY_RELEASE_LEVEL_FINAL;
public static final int PY_RELEASE_SERIAL =       0;

/* Version as a string */
public static final String PY_VERSION =              "3.14.2";
/*--end constants--*/


// #define _Py_PACK_FULL_VERSION(X, Y, Z, LEVEL, SERIAL) (
//     (((X) & 0xff) << 24) |
//     (((Y) & 0xff) << 16) |
//     (((Z) & 0xff) << 8) |
//     (((LEVEL) & 0xf) << 4) |
//     (((SERIAL) & 0xf) << 0))

/* Version as a single 4-byte hex number, e.g. 0x010502B2 == 1.5.2b2.
   Use this for numeric comparisons, e.g. #if PY_VERSION_HEX >= ... */
public static native @MemberGetter int PY_VERSION_HEX();
public static final int PY_VERSION_HEX = PY_VERSION_HEX();

// Public Py_PACK_VERSION is declared in pymacro.h; it needs <inttypes.h>.

// #endif //_Py_PATCHLEVEL_H


// Parsed from pyconfig.h

/* pyconfig.h.  Generated from pyconfig.h.in by configure.  */
/* pyconfig.h.in.  Generated from configure.ac by autoheader.  */


// #ifndef Py_PYCONFIG_H
// #define Py_PYCONFIG_H


/* Define if building universal (internal helper macro) */
/* #undef AC_APPLE_UNIVERSAL_BUILD */

/* BUILD_GNU_TYPE + AIX_BUILDDATE are used to construct the PEP425 tag of the
   build system. */
/* #undef AIX_BUILDDATE */

/* Define for AIX if your compiler is a genuine IBM xlC/xlC_r and you want
   support for AIX C++ shared extension modules. */
/* #undef AIX_GENUINE_CPLUSPLUS */

/* The normal alignment of 'long', in bytes. */
public static final int ALIGNOF_LONG = 8;

/* The normal alignment of 'max_align_t', in bytes. */
public static final int ALIGNOF_MAX_ALIGN_T = 16;

/* The normal alignment of 'size_t', in bytes. */
public static final int ALIGNOF_SIZE_T = 8;

/* Alternative SOABI used in debug build to load C extensions built in release
   mode */
/* #undef ALT_SOABI */

/* The Android API level. */
/* #undef ANDROID_API_LEVEL */

/* Define if C doubles are 64-bit IEEE 754 binary format, stored in ARM
   mixed-endian order (byte order 45670123) */
/* #undef DOUBLE_IS_ARM_MIXED_ENDIAN_IEEE754 */

/* Define if C doubles are 64-bit IEEE 754 binary format, stored with the most
   significant byte first */
/* #undef DOUBLE_IS_BIG_ENDIAN_IEEE754 */

/* Define if C doubles are 64-bit IEEE 754 binary format, stored with the
   least significant byte first */
public static final int DOUBLE_IS_LITTLE_ENDIAN_IEEE754 = 1;

/* Define if --enable-ipv6 is specified */
public static final int ENABLE_IPV6 = 1;

/* Define if getpgrp() must be called as getpgrp(0). */
/* #undef GETPGRP_HAVE_ARG */

/* Define if you have the 'accept' function. */
public static final int HAVE_ACCEPT = 1;

/* Define to 1 if you have the 'accept4' function. */
public static final int HAVE_ACCEPT4 = 1;

/* Define to 1 if you have the 'acosh' function. */
public static final int HAVE_ACOSH = 1;

/* struct addrinfo (netdb.h) */
public static final int HAVE_ADDRINFO = 1;

/* Define to 1 if you have the 'alarm' function. */
public static final int HAVE_ALARM = 1;

/* Define if aligned memory access is required */
/* #undef HAVE_ALIGNED_REQUIRED */

/* Define to 1 if you have the <alloca.h> header file. */
public static final int HAVE_ALLOCA_H = 1;

/* Define this if your time.h defines altzone. */
/* #undef HAVE_ALTZONE */

/* Define to 1 if you have the 'asinh' function. */
public static final int HAVE_ASINH = 1;

/* Define to 1 if you have the <asm/types.h> header file. */
public static final int HAVE_ASM_TYPES_H = 1;

/* Define to 1 if you have the 'atanh' function. */
public static final int HAVE_ATANH = 1;

/* Define to 1 if you have the 'backtrace' function. */
public static final int HAVE_BACKTRACE = 1;

/* Define if you have the 'bind' function. */
public static final int HAVE_BIND = 1;

/* Define to 1 if you have the 'bind_textdomain_codeset' function. */
public static final int HAVE_BIND_TEXTDOMAIN_CODESET = 1;

/* Define to 1 if you have the <bluetooth/bluetooth.h> header file. */
/* #undef HAVE_BLUETOOTH_BLUETOOTH_H */

/* Define to 1 if you have the <bluetooth.h> header file. */
/* #undef HAVE_BLUETOOTH_H */

/* Define if mbstowcs(NULL, "text", 0) does not return the number of wide
   chars that would be converted. */
/* #undef HAVE_BROKEN_MBSTOWCS */

/* Define if nice() returns success/failure instead of the new priority. */
/* #undef HAVE_BROKEN_NICE */

/* Define if the system reports an invalid PIPE_BUF value. */
/* #undef HAVE_BROKEN_PIPE_BUF */

/* Define if poll() sets errno on invalid file descriptors. */
/* #undef HAVE_BROKEN_POLL */

/* Define if the Posix semaphores do not work on your system */
/* #undef HAVE_BROKEN_POSIX_SEMAPHORES */

/* Define if pthread_sigmask() does not work on your system. */
/* #undef HAVE_BROKEN_PTHREAD_SIGMASK */

/* define to 1 if your sem_getvalue is broken. */
/* #undef HAVE_BROKEN_SEM_GETVALUE */

/* Define if 'unsetenv' does not return an int. */
/* #undef HAVE_BROKEN_UNSETENV */

/* Has builtin __atomic_load_n() and __atomic_store_n() functions */
public static final int HAVE_BUILTIN_ATOMIC = 1;

/* Define to 1 if you have the <bzlib.h> header file. */
/* #undef HAVE_BZLIB_H */

/* Define to 1 if you have the 'chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the 'chmod' function. */
public static final int HAVE_CHMOD = 1;

/* Define to 1 if you have the 'chown' function. */
public static final int HAVE_CHOWN = 1;

/* Define if you have the 'chroot' function. */
public static final int HAVE_CHROOT = 1;

/* Define to 1 if you have the 'clock' function. */
public static final int HAVE_CLOCK = 1;

/* Define to 1 if you have the 'clock_getres' function. */
public static final int HAVE_CLOCK_GETRES = 1;

/* Define to 1 if you have the 'clock_gettime' function. */
public static final int HAVE_CLOCK_GETTIME = 1;

/* Define to 1 if you have the 'clock_nanosleep' function. */
public static final int HAVE_CLOCK_NANOSLEEP = 1;

/* Define to 1 if you have the 'clock_settime' function. */
public static final int HAVE_CLOCK_SETTIME = 1;

/* Define to 1 if the system has the type 'clock_t'. */
public static final int HAVE_CLOCK_T = 1;

/* Define to 1 if you have the 'closefrom' function. */
public static final int HAVE_CLOSEFROM = 1;

/* Define to 1 if you have the 'close_range' function. */
public static final int HAVE_CLOSE_RANGE = 1;

/* Define if the C compiler supports computed gotos. */
public static final int HAVE_COMPUTED_GOTOS = 1;

/* Define to 1 if you have the 'confstr' function. */
public static final int HAVE_CONFSTR = 1;

/* Define to 1 if you have the <conio.h> header file. */
/* #undef HAVE_CONIO_H */

/* Define if you have the 'connect' function. */
public static final int HAVE_CONNECT = 1;

/* Define to 1 if you have the 'copy_file_range' function. */
public static final int HAVE_COPY_FILE_RANGE = 1;

/* Define to 1 if you have the 'ctermid' function. */
public static final int HAVE_CTERMID = 1;

/* Define if you have the 'ctermid_r' function. */
/* #undef HAVE_CTERMID_R */

/* Define if you have the 'filter' function. */
/* #undef HAVE_CURSES_FILTER */

/* Define to 1 if you have the <curses.h> header file. */
/* #undef HAVE_CURSES_H */

/* Define if you have the 'has_key' function. */
/* #undef HAVE_CURSES_HAS_KEY */

/* Define if you have the 'immedok' function. */
/* #undef HAVE_CURSES_IMMEDOK */

/* Define if you have the 'is_pad' function. */
/* #undef HAVE_CURSES_IS_PAD */

/* Define if you have the 'is_term_resized' function. */
/* #undef HAVE_CURSES_IS_TERM_RESIZED */

/* Define if you have the 'resizeterm' function. */
/* #undef HAVE_CURSES_RESIZETERM */

/* Define if you have the 'resize_term' function. */
/* #undef HAVE_CURSES_RESIZE_TERM */

/* Define if you have the 'syncok' function. */
/* #undef HAVE_CURSES_SYNCOK */

/* Define if you have the 'typeahead' function. */
/* #undef HAVE_CURSES_TYPEAHEAD */

/* Define if you have the 'use_env' function. */
/* #undef HAVE_CURSES_USE_ENV */

/* Define if you have the 'wchgat' function. */
/* #undef HAVE_CURSES_WCHGAT */

/* Define to 1 if you have the <db.h> header file. */
public static final int HAVE_DB_H = 1;

/* Define to 1 if you have the declaration of 'RTLD_DEEPBIND', and to 0 if you
   don't. */
public static final int HAVE_DECL_RTLD_DEEPBIND = 1;

/* Define to 1 if you have the declaration of 'RTLD_GLOBAL', and to 0 if you
   don't. */
public static final int HAVE_DECL_RTLD_GLOBAL = 1;

/* Define to 1 if you have the declaration of 'RTLD_LAZY', and to 0 if you
   don't. */
public static final int HAVE_DECL_RTLD_LAZY = 1;

/* Define to 1 if you have the declaration of 'RTLD_LOCAL', and to 0 if you
   don't. */
public static final int HAVE_DECL_RTLD_LOCAL = 1;

/* Define to 1 if you have the declaration of 'RTLD_MEMBER', and to 0 if you
   don't. */
public static final int HAVE_DECL_RTLD_MEMBER = 0;

/* Define to 1 if you have the declaration of 'RTLD_NODELETE', and to 0 if you
   don't. */
public static final int HAVE_DECL_RTLD_NODELETE = 1;

/* Define to 1 if you have the declaration of 'RTLD_NOLOAD', and to 0 if you
   don't. */
public static final int HAVE_DECL_RTLD_NOLOAD = 1;

/* Define to 1 if you have the declaration of 'RTLD_NOW', and to 0 if you
   don't. */
public static final int HAVE_DECL_RTLD_NOW = 1;

/* Define to 1 if you have the declaration of 'tzname', and to 0 if you don't.
   */
/* #undef HAVE_DECL_TZNAME */

/* Define to 1 if you have the declaration of 'UT_NAMESIZE', and to 0 if you
   don't. */
public static final int HAVE_DECL_UT_NAMESIZE = 1;

/* Define to 1 if you have the device macros. */
public static final int HAVE_DEVICE_MACROS = 1;

/* Define to 1 if you have the /dev/ptc device file. */
/* #undef HAVE_DEV_PTC */

/* Define to 1 if you have the /dev/ptmx device file. */
public static final int HAVE_DEV_PTMX = 1;

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if the dirent structure has a d_type field */
public static final int HAVE_DIRENT_D_TYPE = 1;

/* Define to 1 if you have the <dirent.h> header file, and it defines 'DIR'.
   */
public static final int HAVE_DIRENT_H = 1;

/* Define if you have the 'dirfd' function or macro. */
public static final int HAVE_DIRFD = 1;

/* Define to 1 if you have the 'dladdr' function. */
public static final int HAVE_DLADDR = 1;

/* Define to 1 if you have the 'dladdr1' function. */
public static final int HAVE_DLADDR1 = 1;

/* Define to 1 if you have the <dlfcn.h> header file. */
public static final int HAVE_DLFCN_H = 1;

/* Define to 1 if you have the 'dlopen' function. */
// #define HAVE_DLOPEN 1

/* Define to 1 if you have the 'dup' function. */
public static final int HAVE_DUP = 1;

/* Define to 1 if you have the 'dup2' function. */
public static final int HAVE_DUP2 = 1;

/* Define to 1 if you have the 'dup3' function. */
public static final int HAVE_DUP3 = 1;

/* Define if you have the '_dyld_shared_cache_contains_path' function. */
/* #undef HAVE_DYLD_SHARED_CACHE_CONTAINS_PATH */

/* Defined when any dynamic module loading is enabled. */
public static final int HAVE_DYNAMIC_LOADING = 1;

/* Define to 1 if you have the <editline/readline.h> header file. */
/* #undef HAVE_EDITLINE_READLINE_H */

/* Define to 1 if you have the <endian.h> header file. */
public static final int HAVE_ENDIAN_H = 1;

/* Define if you have the 'epoll_create' function. */
public static final int HAVE_EPOLL = 1;

/* Define if you have the 'epoll_create1' function. */
public static final int HAVE_EPOLL_CREATE1 = 1;

/* Define to 1 if you have the 'erf' function. */
public static final int HAVE_ERF = 1;

/* Define to 1 if you have the 'erfc' function. */
public static final int HAVE_ERFC = 1;

/* Define to 1 if you have the <errno.h> header file. */
public static final int HAVE_ERRNO_H = 1;

/* Define if you have the 'eventfd' function. */
public static final int HAVE_EVENTFD = 1;

/* Define to 1 if you have the <execinfo.h> header file. */
public static final int HAVE_EXECINFO_H = 1;

/* Define to 1 if you have the 'execv' function. */
public static final int HAVE_EXECV = 1;

/* Define to 1 if you have the 'explicit_bzero' function. */
public static final int HAVE_EXPLICIT_BZERO = 1;

/* Define to 1 if you have the 'explicit_memset' function. */
/* #undef HAVE_EXPLICIT_MEMSET */

/* Define to 1 if you have the 'expm1' function. */
public static final int HAVE_EXPM1 = 1;

/* Define to 1 if you have the 'faccessat' function. */
public static final int HAVE_FACCESSAT = 1;

/* Define if you have the 'fchdir' function. */
public static final int HAVE_FCHDIR = 1;

/* Define to 1 if you have the 'fchmod' function. */
public static final int HAVE_FCHMOD = 1;

/* Define to 1 if you have the 'fchmodat' function. */
public static final int HAVE_FCHMODAT = 1;

/* Define to 1 if you have the 'fchown' function. */
public static final int HAVE_FCHOWN = 1;

/* Define to 1 if you have the 'fchownat' function. */
public static final int HAVE_FCHOWNAT = 1;

/* Define to 1 if you have the <fcntl.h> header file. */
public static final int HAVE_FCNTL_H = 1;

/* Define if you have the 'fdatasync' function. */
public static final int HAVE_FDATASYNC = 1;

/* Define to 1 if you have the 'fdopendir' function. */
public static final int HAVE_FDOPENDIR = 1;

/* Define to 1 if you have the 'fdwalk' function. */
/* #undef HAVE_FDWALK */

/* Define to 1 if you have the 'fexecve' function. */
public static final int HAVE_FEXECVE = 1;

/* Define if you have the 'ffi_closure_alloc' function. */
public static final int HAVE_FFI_CLOSURE_ALLOC = 1;

/* Define if you have the 'ffi_prep_cif_var' function. */
public static final int HAVE_FFI_PREP_CIF_VAR = 1;

/* Define if you have the 'ffi_prep_closure_loc' function. */
public static final int HAVE_FFI_PREP_CLOSURE_LOC = 1;

/* Define to 1 if you have the 'flock' function. */
public static final int HAVE_FLOCK = 1;

/* Define to 1 if you have the 'fork' function. */
// #define HAVE_FORK 1

/* Define to 1 if you have the 'fork1' function. */
/* #undef HAVE_FORK1 */

/* Define to 1 if you have the 'forkpty' function. */
public static final int HAVE_FORKPTY = 1;

/* Define to 1 if you have the 'fpathconf' function. */
public static final int HAVE_FPATHCONF = 1;

/* Define to 1 if you have the 'fseek64' function. */
/* #undef HAVE_FSEEK64 */

/* Define to 1 if you have the 'fseeko' function. */
public static final int HAVE_FSEEKO = 1;

/* Define to 1 if you have the 'fstatat' function. */
public static final int HAVE_FSTATAT = 1;

/* Define to 1 if you have the 'fstatvfs' function. */
public static final int HAVE_FSTATVFS = 1;

/* Define if you have the 'fsync' function. */
public static final int HAVE_FSYNC = 1;

/* Define to 1 if you have the 'ftell64' function. */
/* #undef HAVE_FTELL64 */

/* Define to 1 if you have the 'ftello' function. */
public static final int HAVE_FTELLO = 1;

/* Define to 1 if you have the 'ftime' function. */
public static final int HAVE_FTIME = 1;

/* Define to 1 if you have the 'ftruncate' function. */
public static final int HAVE_FTRUNCATE = 1;

/* Define to 1 if you have the 'futimens' function. */
public static final int HAVE_FUTIMENS = 1;

/* Define to 1 if you have the 'futimes' function. */
public static final int HAVE_FUTIMES = 1;

/* Define to 1 if you have the 'futimesat' function. */
public static final int HAVE_FUTIMESAT = 1;

/* Define to 1 if you have the 'gai_strerror' function. */
public static final int HAVE_GAI_STRERROR = 1;

/* Define if we can use gcc inline assembler to get and set mc68881 fpcr */
/* #undef HAVE_GCC_ASM_FOR_MC68881 */

/* Define if we can use x64 gcc inline assembler */
public static final int HAVE_GCC_ASM_FOR_X64 = 1;

/* Define if we can use gcc inline assembler to get and set x87 control word
   */
// #define HAVE_GCC_ASM_FOR_X87 1

/* Define if your compiler provides __uint128_t */
public static final int HAVE_GCC_UINT128_T = 1;

/* Define to 1 if you have the <gdbm-ndbm.h> header file. */
/* #undef HAVE_GDBM_DASH_NDBM_H */

/* Define to 1 if you have the <gdbm.h> header file. */
public static final int HAVE_GDBM_H = 1;

/* Define to 1 if you have the <gdbm/ndbm.h> header file. */
public static final int HAVE_GDBM_NDBM_H = 1;

/* Define if you have the getaddrinfo function. */
public static final int HAVE_GETADDRINFO = 1;

/* Define this if you have flockfile(), getc_unlocked(), and funlockfile() */
public static final int HAVE_GETC_UNLOCKED = 1;

/* Define to 1 if you have the 'getegid' function. */
public static final int HAVE_GETEGID = 1;

/* Define to 1 if you have the 'getentropy' function. */
public static final int HAVE_GETENTROPY = 1;

/* Define to 1 if you have the 'geteuid' function. */
public static final int HAVE_GETEUID = 1;

/* Define to 1 if you have the 'getgid' function. */
public static final int HAVE_GETGID = 1;

/* Define to 1 if you have the 'getgrent' function. */
public static final int HAVE_GETGRENT = 1;

/* Define to 1 if you have the 'getgrgid' function. */
public static final int HAVE_GETGRGID = 1;

/* Define to 1 if you have the 'getgrgid_r' function. */
public static final int HAVE_GETGRGID_R = 1;

/* Define to 1 if you have the 'getgrnam_r' function. */
public static final int HAVE_GETGRNAM_R = 1;

/* Define to 1 if you have the 'getgrouplist' function. */
public static final int HAVE_GETGROUPLIST = 1;

/* Define to 1 if you have the 'getgroups' function. */
public static final int HAVE_GETGROUPS = 1;

/* Define if you have the 'gethostbyaddr' function. */
public static final int HAVE_GETHOSTBYADDR = 1;

/* Define to 1 if you have the 'gethostbyname' function. */
public static final int HAVE_GETHOSTBYNAME = 1;

/* Define this if you have some version of gethostbyname_r() */
public static final int HAVE_GETHOSTBYNAME_R = 1;

/* Define this if you have the 3-arg version of gethostbyname_r(). */
/* #undef HAVE_GETHOSTBYNAME_R_3_ARG */

/* Define this if you have the 5-arg version of gethostbyname_r(). */
/* #undef HAVE_GETHOSTBYNAME_R_5_ARG */

/* Define this if you have the 6-arg version of gethostbyname_r(). */
public static final int HAVE_GETHOSTBYNAME_R_6_ARG = 1;

/* Define to 1 if you have the 'gethostname' function. */
public static final int HAVE_GETHOSTNAME = 1;

/* Define to 1 if you have the 'getitimer' function. */
public static final int HAVE_GETITIMER = 1;

/* Define to 1 if you have the 'getloadavg' function. */
public static final int HAVE_GETLOADAVG = 1;

/* Define to 1 if you have the 'getlogin' function. */
public static final int HAVE_GETLOGIN = 1;

/* Define to 1 if you have the 'getlogin_r' function. */
public static final int HAVE_GETLOGIN_R = 1;

/* Define to 1 if you have the 'getnameinfo' function. */
public static final int HAVE_GETNAMEINFO = 1;

/* Define if you have the 'getpagesize' function. */
public static final int HAVE_GETPAGESIZE = 1;

/* Define if you have the 'getpeername' function. */
public static final int HAVE_GETPEERNAME = 1;

/* Define to 1 if you have the 'getpgid' function. */
public static final int HAVE_GETPGID = 1;

/* Define to 1 if you have the 'getpgrp' function. */
public static final int HAVE_GETPGRP = 1;

/* Define to 1 if you have the 'getpid' function. */
public static final int HAVE_GETPID = 1;

/* Define to 1 if you have the 'getppid' function. */
public static final int HAVE_GETPPID = 1;

/* Define to 1 if you have the 'getpriority' function. */
public static final int HAVE_GETPRIORITY = 1;

/* Define if you have the 'getprotobyname' function. */
public static final int HAVE_GETPROTOBYNAME = 1;

/* Define to 1 if you have the 'getpwent' function. */
public static final int HAVE_GETPWENT = 1;

/* Define to 1 if you have the 'getpwnam_r' function. */
public static final int HAVE_GETPWNAM_R = 1;

/* Define to 1 if you have the 'getpwuid' function. */
public static final int HAVE_GETPWUID = 1;

/* Define to 1 if you have the 'getpwuid_r' function. */
public static final int HAVE_GETPWUID_R = 1;

/* Define to 1 if the getrandom() function is available */
public static final int HAVE_GETRANDOM = 1;

/* Define to 1 if the Linux getrandom() syscall is available */
public static final int HAVE_GETRANDOM_SYSCALL = 1;

/* Define to 1 if you have the 'getresgid' function. */
public static final int HAVE_GETRESGID = 1;

/* Define to 1 if you have the 'getresuid' function. */
public static final int HAVE_GETRESUID = 1;

/* Define to 1 if you have the 'getrusage' function. */
public static final int HAVE_GETRUSAGE = 1;

/* Define if you have the 'getservbyname' function. */
public static final int HAVE_GETSERVBYNAME = 1;

/* Define if you have the 'getservbyport' function. */
public static final int HAVE_GETSERVBYPORT = 1;

/* Define to 1 if you have the 'getsid' function. */
public static final int HAVE_GETSID = 1;

/* Define if you have the 'getsockname' function. */
public static final int HAVE_GETSOCKNAME = 1;

/* Define to 1 if you have the 'getspent' function. */
public static final int HAVE_GETSPENT = 1;

/* Define to 1 if you have the 'getspnam' function. */
public static final int HAVE_GETSPNAM = 1;

/* Define to 1 if you have the 'getuid' function. */
public static final int HAVE_GETUID = 1;

/* Define to 1 if you have the 'getwd' function. */
public static final int HAVE_GETWD = 1;

/* Define if glibc has incorrect _FORTIFY_SOURCE wrappers for memmove and
   bcopy. */
/* #undef HAVE_GLIBC_MEMMOVE_BUG */

/* Define to 1 if you have the 'grantpt' function. */
public static final int HAVE_GRANTPT = 1;

/* Define to 1 if you have the <grp.h> header file. */
public static final int HAVE_GRP_H = 1;

/* Define if you have the 'hstrerror' function. */
public static final int HAVE_HSTRERROR = 1;

/* Define this if you have le64toh() */
public static final int HAVE_HTOLE64 = 1;

/* Define to 1 if you have the 'if_nameindex' function. */
public static final int HAVE_IF_NAMEINDEX = 1;

/* Define if you have the 'inet_aton' function. */
public static final int HAVE_INET_ATON = 1;

/* Define if you have the 'inet_ntoa' function. */
public static final int HAVE_INET_NTOA = 1;

/* Define if you have the 'inet_pton' function. */
public static final int HAVE_INET_PTON = 1;

/* Define to 1 if you have the 'initgroups' function. */
public static final int HAVE_INITGROUPS = 1;

/* Define to 1 if you have the <inttypes.h> header file. */
public static final int HAVE_INTTYPES_H = 1;

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define if gcc has the ipa-pure-const bug. */
/* #undef HAVE_IPA_PURE_CONST_BUG */

/* Define to 1 if you have the 'kill' function. */
public static final int HAVE_KILL = 1;

/* Define to 1 if you have the 'killpg' function. */
public static final int HAVE_KILLPG = 1;

/* Define if you have the 'kqueue' function. */
/* #undef HAVE_KQUEUE */

/* Define to 1 if you have the <langinfo.h> header file. */
public static final int HAVE_LANGINFO_H = 1;

/* Defined to enable large file support when an off_t is bigger than a long
   and long long is at least as big as an off_t. You may need to add some
   flags for configuration and compilation to enable this mode. (For Solaris
   and Linux, the necessary defines are already defined.) */
/* #undef HAVE_LARGEFILE_SUPPORT */

/* Define to 1 if you have the 'lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the 'lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the 'lchown' function. */
public static final int HAVE_LCHOWN = 1;

/* Define to 1 if you have the `db' library (-ldb). */
public static final int HAVE_LIBDB = 1;

/* Define to 1 if you have the 'dl' library (-ldl). */
public static final int HAVE_LIBDL = 1;

/* Define to 1 if you have the 'dld' library (-ldld). */
/* #undef HAVE_LIBDLD */

/* Define to 1 if you have the 'ieee' library (-lieee). */
/* #undef HAVE_LIBIEEE */

/* Define to 1 if you have the <libintl.h> header file. */
public static final int HAVE_LIBINTL_H = 1;

/* Define to 1 if you have the 'sendfile' library (-lsendfile). */
/* #undef HAVE_LIBSENDFILE */

/* Define to 1 if you have the 'sqlite3' library (-lsqlite3). */
/* #undef HAVE_LIBSQLITE3 */

/* Define to 1 if you have the <libutil.h> header file. */
/* #undef HAVE_LIBUTIL_H */

/* Define if you have the 'link' function. */
public static final int HAVE_LINK = 1;

/* Define to 1 if you have the 'linkat' function. */
public static final int HAVE_LINKAT = 1;

/* Define to 1 if you have the <link.h> header file. */
public static final int HAVE_LINK_H = 1;

/* Define to 1 if you have the <linux/auxvec.h> header file. */
public static final int HAVE_LINUX_AUXVEC_H = 1;

/* Define to 1 if you have the <linux/can/bcm.h> header file. */
public static final int HAVE_LINUX_CAN_BCM_H = 1;

/* Define to 1 if you have the <linux/can.h> header file. */
public static final int HAVE_LINUX_CAN_H = 1;

/* Define to 1 if you have the <linux/can/j1939.h> header file. */
public static final int HAVE_LINUX_CAN_J1939_H = 1;

/* Define if compiling using Linux 3.6 or later. */
public static final int HAVE_LINUX_CAN_RAW_FD_FRAMES = 1;

/* Define to 1 if you have the <linux/can/raw.h> header file. */
public static final int HAVE_LINUX_CAN_RAW_H = 1;

/* Define if compiling using Linux 4.1 or later. */
public static final int HAVE_LINUX_CAN_RAW_JOIN_FILTERS = 1;

/* Define to 1 if you have the <linux/fs.h> header file. */
public static final int HAVE_LINUX_FS_H = 1;

/* Define to 1 if you have the <linux/limits.h> header file. */
public static final int HAVE_LINUX_LIMITS_H = 1;

/* Define to 1 if you have the <linux/memfd.h> header file. */
public static final int HAVE_LINUX_MEMFD_H = 1;

/* Define to 1 if you have the <linux/netfilter_ipv4.h> header file. */
public static final int HAVE_LINUX_NETFILTER_IPV4_H = 1;

/* Define to 1 if you have the <linux/netlink.h> header file. */
public static final int HAVE_LINUX_NETLINK_H = 1;

/* Define to 1 if you have the <linux/qrtr.h> header file. */
public static final int HAVE_LINUX_QRTR_H = 1;

/* Define to 1 if you have the <linux/random.h> header file. */
public static final int HAVE_LINUX_RANDOM_H = 1;

/* Define to 1 if you have the <linux/sched.h> header file. */
public static final int HAVE_LINUX_SCHED_H = 1;

/* Define to 1 if you have the <linux/soundcard.h> header file. */
public static final int HAVE_LINUX_SOUNDCARD_H = 1;

/* Define to 1 if you have the <linux/tipc.h> header file. */
public static final int HAVE_LINUX_TIPC_H = 1;

/* Define to 1 if you have the <linux/vm_sockets.h> header file. */
public static final int HAVE_LINUX_VM_SOCKETS_H = 1;

/* Define to 1 if you have the <linux/wait.h> header file. */
public static final int HAVE_LINUX_WAIT_H = 1;

/* Define if you have the 'listen' function. */
public static final int HAVE_LISTEN = 1;

/* Define to 1 if you have the 'lockf' function. */
public static final int HAVE_LOCKF = 1;

/* Define to 1 if you have the 'log1p' function. */
public static final int HAVE_LOG1P = 1;

/* Define to 1 if you have the 'log2' function. */
public static final int HAVE_LOG2 = 1;

/* Define to 1 if you have the `login_tty' function. */
public static final int HAVE_LOGIN_TTY = 1;

/* Define to 1 if the system has the type 'long double'. */
public static final int HAVE_LONG_DOUBLE = 1;

/* Define to 1 if you have the 'lstat' function. */
public static final int HAVE_LSTAT = 1;

/* Define to 1 if you have the 'lutimes' function. */
public static final int HAVE_LUTIMES = 1;

/* Define to 1 if you have the <lzma.h> header file. */
/* #undef HAVE_LZMA_H */

/* Define to 1 if you have the 'madvise' function. */
public static final int HAVE_MADVISE = 1;

/* Define this if you have the makedev macro. */
public static final int HAVE_MAKEDEV = 1;

/* Define if you have the 'MAXLOGNAME' constant. */
/* #undef HAVE_MAXLOGNAME */

/* Define to 1 if you have the 'mbrtowc' function. */
public static final int HAVE_MBRTOWC = 1;

/* Define if you have the 'memfd_create' function. */
public static final int HAVE_MEMFD_CREATE = 1;

/* Define to 1 if you have the 'memrchr' function. */
public static final int HAVE_MEMRCHR = 1;

/* Define to 1 if you have the <minix/config.h> header file. */
/* #undef HAVE_MINIX_CONFIG_H */

/* Define to 1 if you have the 'mkdirat' function. */
public static final int HAVE_MKDIRAT = 1;

/* Define to 1 if you have the 'mkfifo' function. */
public static final int HAVE_MKFIFO = 1;

/* Define to 1 if you have the 'mkfifoat' function. */
public static final int HAVE_MKFIFOAT = 1;

/* Define to 1 if you have the 'mknod' function. */
public static final int HAVE_MKNOD = 1;

/* Define to 1 if you have the 'mknodat' function. */
public static final int HAVE_MKNODAT = 1;

/* Define to 1 if you have the 'mktime' function. */
public static final int HAVE_MKTIME = 1;

/* Define to 1 if you have the 'mmap' function. */
public static final int HAVE_MMAP = 1;

/* Define to 1 if you have the 'mremap' function. */
public static final int HAVE_MREMAP = 1;

/* Define to 1 if you have the 'nanosleep' function. */
public static final int HAVE_NANOSLEEP = 1;

/* Define if you have the 'ncurses' library */
/* #undef HAVE_NCURSES */

/* Define if you have the 'ncursesw' library */
/* #undef HAVE_NCURSESW */

/* Define to 1 if you have the <ncursesw/curses.h> header file. */
/* #undef HAVE_NCURSESW_CURSES_H */

/* Define to 1 if you have the <ncursesw/ncurses.h> header file. */
/* #undef HAVE_NCURSESW_NCURSES_H */

/* Define to 1 if you have the <ncursesw/panel.h> header file. */
/* #undef HAVE_NCURSESW_PANEL_H */

/* Define to 1 if you have the <ncurses/curses.h> header file. */
/* #undef HAVE_NCURSES_CURSES_H */

/* Define to 1 if you have the <ncurses.h> header file. */
/* #undef HAVE_NCURSES_H */

/* Define to 1 if you have the <ncurses/ncurses.h> header file. */
/* #undef HAVE_NCURSES_NCURSES_H */

/* Define to 1 if you have the <ncurses/panel.h> header file. */
/* #undef HAVE_NCURSES_PANEL_H */

/* Define to 1 if you have the <ndbm.h> header file. */
public static final int HAVE_NDBM_H = 1;

/* Define to 1 if you have the <ndir.h> header file, and it defines 'DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <netcan/can.h> header file. */
/* #undef HAVE_NETCAN_CAN_H */

/* Define to 1 if you have the <netdb.h> header file. */
public static final int HAVE_NETDB_H = 1;

/* Define to 1 if you have the <netinet/in.h> header file. */
public static final int HAVE_NETINET_IN_H = 1;

/* Define to 1 if you have the <netlink/netlink.h> header file. */
/* #undef HAVE_NETLINK_NETLINK_H */

/* Define to 1 if you have the <netpacket/packet.h> header file. */
public static final int HAVE_NETPACKET_PACKET_H = 1;

/* Define to 1 if you have the <net/ethernet.h> header file. */
public static final int HAVE_NET_ETHERNET_H = 1;

/* Define to 1 if you have the <net/if.h> header file. */
public static final int HAVE_NET_IF_H = 1;

/* Define to 1 if you have the 'nice' function. */
public static final int HAVE_NICE = 1;

/* Define if the internal form of wchar_t in non-Unicode locales is not
   Unicode. */
/* #undef HAVE_NON_UNICODE_WCHAR_T_REPRESENTATION */

/* Define to 1 if you have the 'openat' function. */
public static final int HAVE_OPENAT = 1;

/* Define to 1 if you have the 'opendir' function. */
public static final int HAVE_OPENDIR = 1;

/* Define to 1 if you have the 'openpty' function. */
public static final int HAVE_OPENPTY = 1;

/* Define if you have the 'panel' library */
/* #undef HAVE_PANEL */

/* Define if you have the 'panelw' library */
/* #undef HAVE_PANELW */

/* Define to 1 if you have the <panel.h> header file. */
/* #undef HAVE_PANEL_H */

/* Define to 1 if you have the 'pathconf' function. */
public static final int HAVE_PATHCONF = 1;

/* Define to 1 if you have the 'pause' function. */
public static final int HAVE_PAUSE = 1;

/* Define to 1 if you have the 'pipe' function. */
public static final int HAVE_PIPE = 1;

/* Define to 1 if you have the 'pipe2' function. */
public static final int HAVE_PIPE2 = 1;

/* Define to 1 if you have the 'plock' function. */
/* #undef HAVE_PLOCK */

/* Define to 1 if you have the 'poll' function. */
public static final int HAVE_POLL = 1;

/* Define to 1 if you have the <poll.h> header file. */
public static final int HAVE_POLL_H = 1;

/* Define to 1 if you have the 'posix_fadvise' function. */
public static final int HAVE_POSIX_FADVISE = 1;

/* Define to 1 if you have the 'posix_fallocate' function. */
public static final int HAVE_POSIX_FALLOCATE = 1;

/* Define to 1 if you have the 'posix_openpt' function. */
public static final int HAVE_POSIX_OPENPT = 1;

/* Define to 1 if you have the 'posix_spawn' function. */
public static final int HAVE_POSIX_SPAWN = 1;

/* Define to 1 if you have the 'posix_spawnp' function. */
public static final int HAVE_POSIX_SPAWNP = 1;

/* Define to 1 if you have the 'posix_spawn_file_actions_addclosefrom_np'
   function. */
public static final int HAVE_POSIX_SPAWN_FILE_ACTIONS_ADDCLOSEFROM_NP = 1;

/* Define to 1 if you have the 'pread' function. */
public static final int HAVE_PREAD = 1;

/* Define to 1 if you have the 'preadv' function. */
public static final int HAVE_PREADV = 1;

/* Define to 1 if you have the 'preadv2' function. */
public static final int HAVE_PREADV2 = 1;

/* Define if you have the 'prlimit' function. */
public static final int HAVE_PRLIMIT = 1;

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define to 1 if you have the 'process_vm_readv' function. */
public static final int HAVE_PROCESS_VM_READV = 1;

/* Define if your compiler supports function prototype */
public static final int HAVE_PROTOTYPES = 1;

/* Define to 1 if you have the 'pthread_condattr_setclock' function. */
public static final int HAVE_PTHREAD_CONDATTR_SETCLOCK = 1;

/* Define to 1 if you have the 'pthread_cond_timedwait_relative_np' function.
   */
/* #undef HAVE_PTHREAD_COND_TIMEDWAIT_RELATIVE_NP */

/* Defined for Solaris 2.6 bug in pthread header. */
/* #undef HAVE_PTHREAD_DESTRUCTOR */

/* Define to 1 if you have the 'pthread_getattr_np' function. */
public static final int HAVE_PTHREAD_GETATTR_NP = 1;

/* Define to 1 if you have the 'pthread_getcpuclockid' function. */
public static final int HAVE_PTHREAD_GETCPUCLOCKID = 1;

/* Define to 1 if you have the 'pthread_getname_np' function. */
public static final int HAVE_PTHREAD_GETNAME_NP = 1;

/* Define to 1 if you have the 'pthread_get_name_np' function. */
/* #undef HAVE_PTHREAD_GET_NAME_NP */

/* Define to 1 if you have the <pthread.h> header file. */
public static final int HAVE_PTHREAD_H = 1;

/* Define to 1 if you have the 'pthread_init' function. */
/* #undef HAVE_PTHREAD_INIT */

/* Define to 1 if you have the 'pthread_kill' function. */
public static final int HAVE_PTHREAD_KILL = 1;

/* Define to 1 if you have the 'pthread_setname_np' function. */
public static final int HAVE_PTHREAD_SETNAME_NP = 1;

/* Define to 1 if you have the 'pthread_set_name_np' function. */
/* #undef HAVE_PTHREAD_SET_NAME_NP */

/* Define to 1 if you have the 'pthread_sigmask' function. */
public static final int HAVE_PTHREAD_SIGMASK = 1;

/* Define if platform requires stubbed pthreads support */
/* #undef HAVE_PTHREAD_STUBS */

/* Define to 1 if you have the 'ptsname' function. */
public static final int HAVE_PTSNAME = 1;

/* Define to 1 if you have the 'ptsname_r' function. */
public static final int HAVE_PTSNAME_R = 1;

/* Define to 1 if you have the <pty.h> header file. */
public static final int HAVE_PTY_H = 1;

/* Define to 1 if you have the 'pwrite' function. */
public static final int HAVE_PWRITE = 1;

/* Define to 1 if you have the 'pwritev' function. */
public static final int HAVE_PWRITEV = 1;

/* Define to 1 if you have the 'pwritev2' function. */
public static final int HAVE_PWRITEV2 = 1;

/* Define to 1 if you have the <readline/readline.h> header file. */
/* #undef HAVE_READLINE_READLINE_H */

/* Define to 1 if you have the 'readlink' function. */
public static final int HAVE_READLINK = 1;

/* Define to 1 if you have the 'readlinkat' function. */
public static final int HAVE_READLINKAT = 1;

/* Define to 1 if you have the 'readv' function. */
public static final int HAVE_READV = 1;

/* Define to 1 if you have the 'realpath' function. */
public static final int HAVE_REALPATH = 1;

/* Define if you have the 'recvfrom' function. */
public static final int HAVE_RECVFROM = 1;

/* Define to 1 if you have the 'renameat' function. */
public static final int HAVE_RENAMEAT = 1;

/* Define if readline supports append_history */
/* #undef HAVE_RL_APPEND_HISTORY */

/* Define if you can turn off readline's signal handling. */
/* #undef HAVE_RL_CATCH_SIGNAL */

/* Define to 1 if the system has the type 'rl_compdisp_func_t'. */
/* #undef HAVE_RL_COMPDISP_FUNC_T */

/* Define if you have readline 2.2 */
/* #undef HAVE_RL_COMPLETION_APPEND_CHARACTER */

/* Define if you have readline 4.0 */
/* #undef HAVE_RL_COMPLETION_DISPLAY_MATCHES_HOOK */

/* Define if you have readline 4.2 */
/* #undef HAVE_RL_COMPLETION_MATCHES */

/* Define if you have rl_completion_suppress_append */
/* #undef HAVE_RL_COMPLETION_SUPPRESS_APPEND */

/* Define if you have readline 4.0 */
/* #undef HAVE_RL_PRE_INPUT_HOOK */

/* Define if you have readline 4.0 */
/* #undef HAVE_RL_RESIZE_TERMINAL */

/* Define to 1 if you have the 'rtpSpawn' function. */
/* #undef HAVE_RTPSPAWN */

/* Define to 1 if you have the 'sched_get_priority_max' function. */
public static final int HAVE_SCHED_GET_PRIORITY_MAX = 1;

/* Define to 1 if you have the <sched.h> header file. */
public static final int HAVE_SCHED_H = 1;

/* Define to 1 if you have the 'sched_rr_get_interval' function. */
public static final int HAVE_SCHED_RR_GET_INTERVAL = 1;

/* Define to 1 if you have the 'sched_setaffinity' function. */
public static final int HAVE_SCHED_SETAFFINITY = 1;

/* Define to 1 if you have the 'sched_setparam' function. */
public static final int HAVE_SCHED_SETPARAM = 1;

/* Define to 1 if you have the 'sched_setscheduler' function. */
public static final int HAVE_SCHED_SETSCHEDULER = 1;

/* Define to 1 if you have the 'sem_clockwait' function. */
public static final int HAVE_SEM_CLOCKWAIT = 1;

/* Define to 1 if you have the 'sem_getvalue' function. */
public static final int HAVE_SEM_GETVALUE = 1;

/* Define to 1 if you have the 'sem_open' function. */
public static final int HAVE_SEM_OPEN = 1;

/* Define to 1 if you have the 'sem_timedwait' function. */
public static final int HAVE_SEM_TIMEDWAIT = 1;

/* Define to 1 if you have the 'sem_unlink' function. */
public static final int HAVE_SEM_UNLINK = 1;

/* Define to 1 if you have the 'sendfile' function. */
public static final int HAVE_SENDFILE = 1;

/* Define if you have the 'sendto' function. */
public static final int HAVE_SENDTO = 1;

/* Define to 1 if you have the 'setegid' function. */
public static final int HAVE_SETEGID = 1;

/* Define to 1 if you have the 'seteuid' function. */
public static final int HAVE_SETEUID = 1;

/* Define to 1 if you have the 'setgid' function. */
public static final int HAVE_SETGID = 1;

/* Define if you have the 'setgroups' function. */
public static final int HAVE_SETGROUPS = 1;

/* Define to 1 if you have the 'sethostname' function. */
public static final int HAVE_SETHOSTNAME = 1;

/* Define to 1 if you have the 'setitimer' function. */
public static final int HAVE_SETITIMER = 1;

/* Define to 1 if you have the <setjmp.h> header file. */
public static final int HAVE_SETJMP_H = 1;

/* Define to 1 if you have the 'setlocale' function. */
public static final int HAVE_SETLOCALE = 1;

/* Define to 1 if you have the 'setns' function. */
public static final int HAVE_SETNS = 1;

/* Define to 1 if you have the 'setpgid' function. */
public static final int HAVE_SETPGID = 1;

/* Define to 1 if you have the 'setpgrp' function. */
public static final int HAVE_SETPGRP = 1;

/* Define to 1 if you have the 'setpriority' function. */
public static final int HAVE_SETPRIORITY = 1;

/* Define to 1 if you have the 'setregid' function. */
public static final int HAVE_SETREGID = 1;

/* Define to 1 if you have the 'setresgid' function. */
public static final int HAVE_SETRESGID = 1;

/* Define to 1 if you have the 'setresuid' function. */
public static final int HAVE_SETRESUID = 1;

/* Define to 1 if you have the 'setreuid' function. */
public static final int HAVE_SETREUID = 1;

/* Define to 1 if you have the 'setsid' function. */
public static final int HAVE_SETSID = 1;

/* Define if you have the 'setsockopt' function. */
public static final int HAVE_SETSOCKOPT = 1;

/* Define to 1 if you have the 'setuid' function. */
public static final int HAVE_SETUID = 1;

/* Define to 1 if you have the 'setvbuf' function. */
public static final int HAVE_SETVBUF = 1;

/* Define to 1 if you have the <shadow.h> header file. */
public static final int HAVE_SHADOW_H = 1;

/* Define to 1 if you have the 'shm_open' function. */
public static final int HAVE_SHM_OPEN = 1;

/* Define to 1 if you have the 'shm_unlink' function. */
public static final int HAVE_SHM_UNLINK = 1;

/* Define to 1 if you have the 'shutdown' function. */
public static final int HAVE_SHUTDOWN = 1;

/* Define to 1 if you have the 'sigaction' function. */
public static final int HAVE_SIGACTION = 1;

/* Define to 1 if you have the 'sigaltstack' function. */
public static final int HAVE_SIGALTSTACK = 1;

/* Define to 1 if you have the 'sigfillset' function. */
public static final int HAVE_SIGFILLSET = 1;

/* Define to 1 if 'si_band' is a member of 'siginfo_t'. */
public static final int HAVE_SIGINFO_T_SI_BAND = 1;

/* Define to 1 if you have the 'siginterrupt' function. */
public static final int HAVE_SIGINTERRUPT = 1;

/* Define to 1 if you have the <signal.h> header file. */
public static final int HAVE_SIGNAL_H = 1;

/* Define to 1 if you have the 'sigpending' function. */
public static final int HAVE_SIGPENDING = 1;

/* Define to 1 if you have the 'sigrelse' function. */
public static final int HAVE_SIGRELSE = 1;

/* Define to 1 if you have the 'sigtimedwait' function. */
public static final int HAVE_SIGTIMEDWAIT = 1;

/* Define to 1 if you have the 'sigwait' function. */
public static final int HAVE_SIGWAIT = 1;

/* Define to 1 if you have the 'sigwaitinfo' function. */
public static final int HAVE_SIGWAITINFO = 1;

/* Define to 1 if you have the 'snprintf' function. */
public static final int HAVE_SNPRINTF = 1;

/* struct sockaddr_alg (linux/if_alg.h) */
public static final int HAVE_SOCKADDR_ALG = 1;

/* Define if sockaddr has sa_len member */
/* #undef HAVE_SOCKADDR_SA_LEN */

/* struct sockaddr_storage (sys/socket.h) */
public static final int HAVE_SOCKADDR_STORAGE = 1;

/* Define if you have the 'socket' function. */
public static final int HAVE_SOCKET = 1;

/* Define if you have the 'socketpair' function. */
public static final int HAVE_SOCKETPAIR = 1;

/* Define to 1 if the system has the type 'socklen_t'. */
public static final int HAVE_SOCKLEN_T = 1;

/* Define to 1 if you have the <spawn.h> header file. */
public static final int HAVE_SPAWN_H = 1;

/* Define to 1 if you have the 'splice' function. */
public static final int HAVE_SPLICE = 1;

/* Define to 1 if the system has the type 'ssize_t'. */
public static final int HAVE_SSIZE_T = 1;

/* Define to 1 if you have the 'statvfs' function. */
public static final int HAVE_STATVFS = 1;

/* Define if you have struct stat.st_mtim.tv_nsec */
public static final int HAVE_STAT_TV_NSEC = 1;

/* Define if you have struct stat.st_mtimensec */
/* #undef HAVE_STAT_TV_NSEC2 */

/* Define to 1 if you have the <stdint.h> header file. */
public static final int HAVE_STDINT_H = 1;

/* Define to 1 if you have the <stdio.h> header file. */
public static final int HAVE_STDIO_H = 1;

/* Define to 1 if you have the <stdlib.h> header file. */
public static final int HAVE_STDLIB_H = 1;

/* Has stdatomic.h with atomic_int and atomic_uintptr_t */
public static final int HAVE_STD_ATOMIC = 1;

/* Define to 1 if you have the 'strftime' function. */
public static final int HAVE_STRFTIME = 1;

/* Define to 1 if you have the <strings.h> header file. */
public static final int HAVE_STRINGS_H = 1;

/* Define to 1 if you have the <string.h> header file. */
public static final int HAVE_STRING_H = 1;

/* Define to 1 if you have the 'strlcpy' function. */
public static final int HAVE_STRLCPY = 1;

/* Define to 1 if you have the <stropts.h> header file. */
/* #undef HAVE_STROPTS_H */

/* Define to 1 if you have the 'strsignal' function. */
public static final int HAVE_STRSIGNAL = 1;

/* Define to 1 if 'pw_gecos' is a member of 'struct passwd'. */
public static final int HAVE_STRUCT_PASSWD_PW_GECOS = 1;

/* Define to 1 if 'pw_passwd' is a member of 'struct passwd'. */
public static final int HAVE_STRUCT_PASSWD_PW_PASSWD = 1;

/* Define to 1 if 'st_birthtime' is a member of 'struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if 'st_blksize' is a member of 'struct stat'. */
public static final int HAVE_STRUCT_STAT_ST_BLKSIZE = 1;

/* Define to 1 if 'st_blocks' is a member of 'struct stat'. */
public static final int HAVE_STRUCT_STAT_ST_BLOCKS = 1;

/* Define to 1 if 'st_flags' is a member of 'struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if 'st_gen' is a member of 'struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_GEN */

/* Define to 1 if 'st_rdev' is a member of 'struct stat'. */
public static final int HAVE_STRUCT_STAT_ST_RDEV = 1;

/* Define to 1 if 'tm_zone' is a member of 'struct tm'. */
public static final int HAVE_STRUCT_TM_TM_ZONE = 1;

/* Define if you have the 'symlink' function. */
public static final int HAVE_SYMLINK = 1;

/* Define to 1 if you have the 'symlinkat' function. */
public static final int HAVE_SYMLINKAT = 1;

/* Define to 1 if you have the 'sync' function. */
public static final int HAVE_SYNC = 1;

/* Define to 1 if you have the 'sysconf' function. */
public static final int HAVE_SYSCONF = 1;

/* Define to 1 if you have the <sysexits.h> header file. */
public static final int HAVE_SYSEXITS_H = 1;

/* Define to 1 if you have the <syslog.h> header file. */
public static final int HAVE_SYSLOG_H = 1;

/* Define to 1 if you have the 'system' function. */
public static final int HAVE_SYSTEM = 1;

/* Define to 1 if you have the <sys/audioio.h> header file. */
/* #undef HAVE_SYS_AUDIOIO_H */

/* Define to 1 if you have the <sys/auxv.h> header file. */
public static final int HAVE_SYS_AUXV_H = 1;

/* Define to 1 if you have the <sys/bsdtty.h> header file. */
/* #undef HAVE_SYS_BSDTTY_H */

/* Define to 1 if you have the <sys/devpoll.h> header file. */
/* #undef HAVE_SYS_DEVPOLL_H */

/* Define to 1 if you have the <sys/dir.h> header file, and it defines 'DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/endian.h> header file. */
/* #undef HAVE_SYS_ENDIAN_H */

/* Define to 1 if you have the <sys/epoll.h> header file. */
public static final int HAVE_SYS_EPOLL_H = 1;

/* Define to 1 if you have the <sys/eventfd.h> header file. */
public static final int HAVE_SYS_EVENTFD_H = 1;

/* Define to 1 if you have the <sys/event.h> header file. */
/* #undef HAVE_SYS_EVENT_H */

/* Define to 1 if you have the <sys/file.h> header file. */
public static final int HAVE_SYS_FILE_H = 1;

/* Define to 1 if you have the <sys/ioctl.h> header file. */
public static final int HAVE_SYS_IOCTL_H = 1;

/* Define to 1 if you have the <sys/kern_control.h> header file. */
/* #undef HAVE_SYS_KERN_CONTROL_H */

/* Define to 1 if you have the <sys/loadavg.h> header file. */
/* #undef HAVE_SYS_LOADAVG_H */

/* Define to 1 if you have the <sys/lock.h> header file. */
/* #undef HAVE_SYS_LOCK_H */

/* Define to 1 if you have the <sys/memfd.h> header file. */
/* #undef HAVE_SYS_MEMFD_H */

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mman.h> header file. */
public static final int HAVE_SYS_MMAN_H = 1;

/* Define to 1 if you have the <sys/modem.h> header file. */
/* #undef HAVE_SYS_MODEM_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines 'DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
public static final int HAVE_SYS_PARAM_H = 1;

/* Define to 1 if you have the <sys/pidfd.h> header file. */
public static final int HAVE_SYS_PIDFD_H = 1;

/* Define to 1 if you have the <sys/poll.h> header file. */
public static final int HAVE_SYS_POLL_H = 1;

/* Define to 1 if you have the <sys/random.h> header file. */
public static final int HAVE_SYS_RANDOM_H = 1;

/* Define to 1 if you have the <sys/resource.h> header file. */
public static final int HAVE_SYS_RESOURCE_H = 1;

/* Define to 1 if you have the <sys/select.h> header file. */
public static final int HAVE_SYS_SELECT_H = 1;

/* Define to 1 if you have the <sys/sendfile.h> header file. */
public static final int HAVE_SYS_SENDFILE_H = 1;

/* Define to 1 if you have the <sys/socket.h> header file. */
public static final int HAVE_SYS_SOCKET_H = 1;

/* Define to 1 if you have the <sys/soundcard.h> header file. */
public static final int HAVE_SYS_SOUNDCARD_H = 1;

/* Define to 1 if you have the <sys/statvfs.h> header file. */
public static final int HAVE_SYS_STATVFS_H = 1;

/* Define to 1 if you have the <sys/stat.h> header file. */
public static final int HAVE_SYS_STAT_H = 1;

/* Define to 1 if you have the <sys/syscall.h> header file. */
public static final int HAVE_SYS_SYSCALL_H = 1;

/* Define to 1 if you have the <sys/sysmacros.h> header file. */
public static final int HAVE_SYS_SYSMACROS_H = 1;

/* Define to 1 if you have the <sys/sys_domain.h> header file. */
/* #undef HAVE_SYS_SYS_DOMAIN_H */

/* Define to 1 if you have the <sys/termio.h> header file. */
/* #undef HAVE_SYS_TERMIO_H */

/* Define to 1 if you have the <sys/timerfd.h> header file. */
public static final int HAVE_SYS_TIMERFD_H = 1;

/* Define to 1 if you have the <sys/times.h> header file. */
public static final int HAVE_SYS_TIMES_H = 1;

/* Define to 1 if you have the <sys/time.h> header file. */
public static final int HAVE_SYS_TIME_H = 1;

/* Define to 1 if you have the <sys/types.h> header file. */
public static final int HAVE_SYS_TYPES_H = 1;

/* Define to 1 if you have the <sys/uio.h> header file. */
public static final int HAVE_SYS_UIO_H = 1;

/* Define to 1 if you have the <sys/un.h> header file. */
public static final int HAVE_SYS_UN_H = 1;

/* Define to 1 if you have the <sys/utsname.h> header file. */
public static final int HAVE_SYS_UTSNAME_H = 1;

/* Define to 1 if you have the <sys/wait.h> header file. */
public static final int HAVE_SYS_WAIT_H = 1;

/* Define to 1 if you have the <sys/xattr.h> header file. */
public static final int HAVE_SYS_XATTR_H = 1;

/* Define to 1 if you have the 'tcgetpgrp' function. */
public static final int HAVE_TCGETPGRP = 1;

/* Define to 1 if you have the 'tcsetpgrp' function. */
public static final int HAVE_TCSETPGRP = 1;

/* Define to 1 if you have the 'tempnam' function. */
public static final int HAVE_TEMPNAM = 1;

/* Define to 1 if you have the <termios.h> header file. */
public static final int HAVE_TERMIOS_H = 1;

/* Define to 1 if you have the <term.h> header file. */
/* #undef HAVE_TERM_H */

/* Define to 1 if you have the 'timegm' function. */
public static final int HAVE_TIMEGM = 1;

/* Define if you have the 'timerfd_create' function. */
public static final int HAVE_TIMERFD_CREATE = 1;

/* Define to 1 if you have the 'times' function. */
public static final int HAVE_TIMES = 1;

/* Define to 1 if you have the 'tmpfile' function. */
public static final int HAVE_TMPFILE = 1;

/* Define to 1 if you have the 'tmpnam' function. */
public static final int HAVE_TMPNAM = 1;

/* Define to 1 if you have the 'tmpnam_r' function. */
public static final int HAVE_TMPNAM_R = 1;

/* Define to 1 if your 'struct tm' has 'tm_zone'. Deprecated, use
   'HAVE_STRUCT_TM_TM_ZONE' instead. */
public static final int HAVE_TM_ZONE = 1;

/* Define to 1 if you have the 'truncate' function. */
public static final int HAVE_TRUNCATE = 1;

/* Define to 1 if you have the 'ttyname_r' function. */
public static final int HAVE_TTYNAME_R = 1;

/* Define to 1 if you don't have 'tm_zone' but do have the external array
   'tzname'. */
/* #undef HAVE_TZNAME */

/* Define to 1 if you have the 'umask' function. */
public static final int HAVE_UMASK = 1;

/* Define to 1 if you have the 'uname' function. */
public static final int HAVE_UNAME = 1;

/* Define to 1 if you have the <unistd.h> header file. */
public static final int HAVE_UNISTD_H = 1;

/* Define to 1 if you have the 'unlinkat' function. */
public static final int HAVE_UNLINKAT = 1;

/* Define to 1 if you have the 'unlockpt' function. */
public static final int HAVE_UNLOCKPT = 1;

/* Define to 1 if you have the 'unshare' function. */
public static final int HAVE_UNSHARE = 1;

/* Define if you have a useable wchar_t type defined in wchar.h; useable means
   wchar_t must be an unsigned type with at least 16 bits. (see
   Include/unicodeobject.h). */
/* #undef HAVE_USABLE_WCHAR_T */

/* Define to 1 if you have the <util.h> header file. */
/* #undef HAVE_UTIL_H */

/* Define to 1 if you have the 'utimensat' function. */
public static final int HAVE_UTIMENSAT = 1;

/* Define to 1 if you have the 'utimes' function. */
public static final int HAVE_UTIMES = 1;

/* Define to 1 if you have the <utime.h> header file. */
public static final int HAVE_UTIME_H = 1;

/* Define to 1 if you have the <utmp.h> header file. */
public static final int HAVE_UTMP_H = 1;

/* Define if you have the 'HAVE_UT_NAMESIZE' constant. */
public static final int HAVE_UT_NAMESIZE = 1;

/* Define to 1 if you have the 'uuid_create' function. */
/* #undef HAVE_UUID_CREATE */

/* Define to 1 if you have the 'uuid_enc_be' function. */
/* #undef HAVE_UUID_ENC_BE */

/* Define if uuid_generate_time_safe() exists. */
public static final int HAVE_UUID_GENERATE_TIME_SAFE = 1;

/* Define if uuid_generate_time_safe() is able to deduce a MAC address. */
/* #undef HAVE_UUID_GENERATE_TIME_SAFE_STABLE_MAC */

/* Define to 1 if you have the <uuid.h> header file. */
public static final int HAVE_UUID_H = 1;

/* Define to 1 if you have the <uuid/uuid.h> header file. */
/* #undef HAVE_UUID_UUID_H */

/* Define to 1 if you have the 'vfork' function. */
public static final int HAVE_VFORK = 1;

/* Define to 1 if you have the 'wait' function. */
public static final int HAVE_WAIT = 1;

/* Define to 1 if you have the 'wait3' function. */
public static final int HAVE_WAIT3 = 1;

/* Define to 1 if you have the 'wait4' function. */
public static final int HAVE_WAIT4 = 1;

/* Define to 1 if you have the 'waitid' function. */
public static final int HAVE_WAITID = 1;

/* Define to 1 if you have the 'waitpid' function. */
public static final int HAVE_WAITPID = 1;

/* Define if the compiler provides a wchar.h header file. */
public static final int HAVE_WCHAR_H = 1;

/* Define to 1 if you have the 'wcscoll' function. */
public static final int HAVE_WCSCOLL = 1;

/* Define to 1 if you have the 'wcsftime' function. */
public static final int HAVE_WCSFTIME = 1;

/* Define to 1 if you have the 'wcsxfrm' function. */
public static final int HAVE_WCSXFRM = 1;

/* Define to 1 if you have the 'wmemcmp' function. */
public static final int HAVE_WMEMCMP = 1;

/* Define if tzset() actually switches the local timezone in a meaningful way.
   */
public static final int HAVE_WORKING_TZSET = 1;

/* Define to 1 if you have the 'writev' function. */
public static final int HAVE_WRITEV = 1;

/* Define to 1 if you have the <zdict.h> header file. */
/* #undef HAVE_ZDICT_H */

/* Define if the zlib library has inflateCopy */
public static final int HAVE_ZLIB_COPY = 1;

/* Define to 1 if you have the <zlib.h> header file. */
/* #undef HAVE_ZLIB_H */

/* Define to 1 if you have the <zstd.h> header file. */
/* #undef HAVE_ZSTD_H */

/* Define to 1 if you have the '_getpty' function. */
/* #undef HAVE__GETPTY */

/* Define to 1 if the system has the type '__uint128_t'. */
public static final int HAVE___UINT128_T = 1;

/* Define to 1 if 'major', 'minor', and 'makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if 'major', 'minor', and 'makedev' are declared in
   <sysmacros.h>. */
public static final int MAJOR_IN_SYSMACROS = 1;

/* Define if mvwdelch in curses.h is an expression. */
/* #undef MVWDELCH_IS_EXPRESSION */

/* Define to the address where bug reports for this package should be sent. */
/* #undef PACKAGE_BUGREPORT */

/* Define to the full name of this package. */
/* #undef PACKAGE_NAME */

/* Define to the full name and version of this package. */
/* #undef PACKAGE_STRING */

/* Define to the one symbol short name of this package. */
/* #undef PACKAGE_TARNAME */

/* Define to the home page for this package. */
/* #undef PACKAGE_URL */

/* Define to the version of this package. */
/* #undef PACKAGE_VERSION */

/* Define if POSIX semaphores aren't enabled on your system */
/* #undef POSIX_SEMAPHORES_NOT_ENABLED */

/* Define if pthread_key_t is compatible with int. */
public static final int PTHREAD_KEY_T_IS_COMPATIBLE_WITH_INT = 1;

/* Defined if PTHREAD_SCOPE_SYSTEM supported. */
public static final int PTHREAD_SYSTEM_SCHED_SUPPORTED = 1;

/* Define as the preferred size in bits of long digits */
/* #undef PYLONG_BITS_IN_DIGIT */

/* enabled builtin hash modules */
public static final String PY_BUILTIN_HASHLIB_HASHES = "md5,sha1,sha2,sha3,blake2";

/* Define if you want to coerce the C locale to a UTF-8 based locale */
public static final int PY_COERCE_C_LOCALE = 1;

/* Define to 1 if you have the perf trampoline. */
public static final int PY_HAVE_PERF_TRAMPOLINE = 1;

/* Define to 1 to build the sqlite module with loadable extensions support. */
/* #undef PY_SQLITE_ENABLE_LOAD_EXTENSION */

/* Define if SQLite was compiled with the serialize API */
/* #undef PY_SQLITE_HAVE_SERIALIZE */

/* Default cipher suites list for ssl module. 1: Python's preferred selection,
   2: leave OpenSSL defaults untouched, 0: custom string */
public static final int PY_SSL_DEFAULT_CIPHERS = 1;

/* Cipher suite string for PY_SSL_DEFAULT_CIPHERS=0 */
/* #undef PY_SSL_DEFAULT_CIPHER_STRING */

/* PEP 11 Support tier (1, 2, 3 or 0 for unsupported) */
public static final int PY_SUPPORT_TIER = 1;

/* Define if you want to build an interpreter with many run-time checks. */
/* #undef Py_DEBUG */

/* Defined if Python is built as a shared library. */
public static final int Py_ENABLE_SHARED = 1;

/* Define if you want to disable the GIL */
/* #undef Py_GIL_DISABLED */

/* Define hash algorithm for str, bytes and memoryview. SipHash24: 1, FNV: 2,
   SipHash13: 3, externally defined: 0 */
/* #undef Py_HASH_ALGORITHM */

/* Define if you want to enable remote debugging support. */
public static final int Py_REMOTE_DEBUG = 1;

/* Define if rl_startup_hook takes arguments */
/* #undef Py_RL_STARTUP_HOOK_TAKES_ARGS */

/* Define if you want to enable internal statistics gathering. */
/* #undef Py_STATS */

/* The version of SunOS/Solaris as reported by `uname -r' without the dot. */
/* #undef Py_SUNOS_VERSION */

/* Define if you want to use tail-calling interpreters in CPython. */
/* #undef Py_TAIL_CALL_INTERP */

/* Define if you want to enable tracing references for debugging purpose */
/* #undef Py_TRACE_REFS */

/* assume C89 semantics that RETSIGTYPE is always void */
// #define RETSIGTYPE void

/* Define if setpgrp() must be called as setpgrp(0, 0). */
/* #undef SETPGRP_HAVE_ARG */

/* Define if i>>j for signed int i does not extend the sign bit when i < 0 */
/* #undef SIGNED_RIGHT_SHIFT_ZERO_FILLS */

/* The size of 'double', as computed by sizeof. */
public static final int SIZEOF_DOUBLE = 8;

/* The size of 'float', as computed by sizeof. */
public static final int SIZEOF_FLOAT = 4;

/* The size of 'fpos_t', as computed by sizeof. */
public static final int SIZEOF_FPOS_T = 16;

/* The size of 'int', as computed by sizeof. */
public static final int SIZEOF_INT = 4;

/* The size of 'long', as computed by sizeof. */
public static final int SIZEOF_LONG = 8;

/* The size of 'long double', as computed by sizeof. */
public static final int SIZEOF_LONG_DOUBLE = 16;

/* The size of 'long long', as computed by sizeof. */
public static final int SIZEOF_LONG_LONG = 8;

/* The size of 'off_t', as computed by sizeof. */
public static final int SIZEOF_OFF_T = 8;

/* The size of 'pid_t', as computed by sizeof. */
public static final int SIZEOF_PID_T = 4;

/* The size of 'pthread_key_t', as computed by sizeof. */
public static final int SIZEOF_PTHREAD_KEY_T = 4;

/* The size of 'pthread_t', as computed by sizeof. */
public static final int SIZEOF_PTHREAD_T = 8;

/* The size of 'short', as computed by sizeof. */
public static final int SIZEOF_SHORT = 2;

/* The size of 'size_t', as computed by sizeof. */
public static final int SIZEOF_SIZE_T = 8;

/* The size of 'time_t', as computed by sizeof. */
public static final int SIZEOF_TIME_T = 8;

/* The size of 'uintptr_t', as computed by sizeof. */
public static final int SIZEOF_UINTPTR_T = 8;

/* The size of 'void *', as computed by sizeof. */
public static final int SIZEOF_VOID_P = 8;

/* The size of 'wchar_t', as computed by sizeof. */
public static final int SIZEOF_WCHAR_T = 4;

/* The size of '_Bool', as computed by sizeof. */
public static final int SIZEOF__BOOL = 1;

/* Define to 1 if you have the ANSI C header files. */
public static final int STDC_HEADERS = 1;

/* Define if you can safely include both <sys/select.h> and <sys/time.h>
   (which you can't on SCO ODT 3.0). */
public static final int SYS_SELECT_WITH_SYS_TIME = 1;

/* Custom thread stack size depending on chosen sanitizer runtimes. */
/* #undef THREAD_STACK_SIZE */

/* Library needed by timemodule.c: librt may be needed for clock_gettime() */
/* #undef TIMEMODULE_LIB */

/* Define to 1 if your <sys/time.h> declares 'struct tm'. */
/* #undef TM_IN_SYS_TIME */

/* Define if you want to use computed gotos in ceval.c. */
/* #undef USE_COMPUTED_GOTOS */

/* Enable extensions on AIX, Interix, z/OS.  */
// #ifndef _ALL_SOURCE
public static final int _ALL_SOURCE = 1;
// #endif
/* Enable general extensions on macOS.  */
// #ifndef _DARWIN_C_SOURCE
public static final int _DARWIN_C_SOURCE = 1;
// #endif
/* Enable general extensions on Solaris.  */
// #ifndef __EXTENSIONS__
public static final int __EXTENSIONS__ = 1;
// #endif
/* Enable GNU extensions on systems that have them.  */
// #ifndef _GNU_SOURCE
public static final int _GNU_SOURCE = 1;
// #endif
/* Enable X/Open compliant socket functions that do not require linking
   with -lxnet on HP-UX 11.11.  */
// #ifndef _HPUX_ALT_XOPEN_SOCKET_API
public static final int _HPUX_ALT_XOPEN_SOCKET_API = 1;
// #endif
/* Identify the host operating system as Minix.
   This macro does not affect the system headers' behavior.
   A future release of Autoconf may stop defining this macro.  */
// #ifndef _MINIX
/* # undef _MINIX */
// #endif
/* Enable general extensions on NetBSD.
   Enable NetBSD compatibility extensions on Minix.  */
// #ifndef _NETBSD_SOURCE
public static final int _NETBSD_SOURCE = 1;
// #endif
/* Enable OpenBSD compatibility extensions on NetBSD.
   Oddly enough, this does nothing on OpenBSD.  */
// #ifndef _OPENBSD_SOURCE
public static final int _OPENBSD_SOURCE = 1;
// #endif
/* Define to 1 if needed for POSIX-compatible behavior.  */
// #ifndef _POSIX_SOURCE
/* # undef _POSIX_SOURCE */
// #endif
/* Define to 2 if needed for POSIX-compatible behavior.  */
// #ifndef _POSIX_1_SOURCE
/* # undef _POSIX_1_SOURCE */
// #endif
/* Enable POSIX-compatible threading on Solaris.  */
// #ifndef _POSIX_PTHREAD_SEMANTICS
public static final int _POSIX_PTHREAD_SEMANTICS = 1;
// #endif
/* Enable extensions specified by ISO/IEC TS 18661-5:2014.  */
// #ifndef __STDC_WANT_IEC_60559_ATTRIBS_EXT__
public static final int __STDC_WANT_IEC_60559_ATTRIBS_EXT__ = 1;
// #endif
/* Enable extensions specified by ISO/IEC TS 18661-1:2014.  */
// #ifndef __STDC_WANT_IEC_60559_BFP_EXT__
public static final int __STDC_WANT_IEC_60559_BFP_EXT__ = 1;
// #endif
/* Enable extensions specified by ISO/IEC TS 18661-2:2015.  */
// #ifndef __STDC_WANT_IEC_60559_DFP_EXT__
public static final int __STDC_WANT_IEC_60559_DFP_EXT__ = 1;
// #endif
/* Enable extensions specified by C23 Annex F.  */
// #ifndef __STDC_WANT_IEC_60559_EXT__
public static final int __STDC_WANT_IEC_60559_EXT__ = 1;
// #endif
/* Enable extensions specified by ISO/IEC TS 18661-4:2015.  */
// #ifndef __STDC_WANT_IEC_60559_FUNCS_EXT__
public static final int __STDC_WANT_IEC_60559_FUNCS_EXT__ = 1;
// #endif
/* Enable extensions specified by C23 Annex H and ISO/IEC TS 18661-3:2015.  */
// #ifndef __STDC_WANT_IEC_60559_TYPES_EXT__
public static final int __STDC_WANT_IEC_60559_TYPES_EXT__ = 1;
// #endif
/* Enable extensions specified by ISO/IEC TR 24731-2:2010.  */
// #ifndef __STDC_WANT_LIB_EXT2__
public static final int __STDC_WANT_LIB_EXT2__ = 1;
// #endif
/* Enable extensions specified by ISO/IEC 24747:2009.  */
// #ifndef __STDC_WANT_MATH_SPEC_FUNCS__
public static final int __STDC_WANT_MATH_SPEC_FUNCS__ = 1;
// #endif
/* Enable extensions on HP NonStop.  */
// #ifndef _TANDEM_SOURCE
public static final int _TANDEM_SOURCE = 1;
// #endif
/* Enable X/Open extensions.  Define to 500 only if necessary
   to make mbstate_t available.  */
// #ifndef _XOPEN_SOURCE
public static final int _XOPEN_SOURCE = 700;
// #endif


/* Define if WINDOW in curses.h offers a field _flags. */
/* #undef WINDOW_HAS_FLAGS */

/* Define if you want build the _decimal module using a coroutine-local rather
   than a thread-local context */
public static final int WITH_DECIMAL_CONTEXTVAR = 1;

/* Define if you want documentation strings in extension modules */
public static final int WITH_DOC_STRINGS = 1;

/* Define if you want to compile in DTrace support */
/* #undef WITH_DTRACE */

/* Define if you want to use the new-style (Openstep, Rhapsody, MacOS) dynamic
   linker (dyld) instead of the old-style (NextStep) dynamic linker (rld).
   Dyld is necessary to support frameworks. */
/* #undef WITH_DYLD */

/* Define to build the readline module against libedit. */
/* #undef WITH_EDITLINE */

/* Define to 1 if libintl is needed for locale functions. */
/* #undef WITH_LIBINTL */

/* Define if you want to compile in mimalloc memory allocator. */
public static final int WITH_MIMALLOC = 1;

/* Define if you want to produce an OpenStep/Rhapsody framework (shared
   library plus accessory files). */
/* #undef WITH_NEXT_FRAMEWORK */

/* Define if you want to compile in Python-specific mallocs */
public static final int WITH_PYMALLOC = 1;

/* Define if you want pymalloc to be disabled when running under valgrind */
/* #undef WITH_VALGRIND */

/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
   significant byte first (like Motorola and SPARC, unlike Intel). */
// #if defined AC_APPLE_UNIVERSAL_BUILD
// # if defined __BIG_ENDIAN__
public static final int WORDS_BIGENDIAN = 1;
// # endif
// #else
// # ifndef WORDS_BIGENDIAN
// # endif
// #endif

/* Define if arithmetic is subject to x87-style double rounding issue */
/* #undef X87_DOUBLE_ROUNDING */

/* Define on OpenBSD to activate all library features */
/* #undef _BSD_SOURCE */

/* Define on Darwin to activate all library features */

/* This must be set to 64 on some systems to enable large file support. */
public static final int _FILE_OFFSET_BITS = 64;

/* Define to include mbstate_t for mbrtowc */
/* #undef _INCLUDE__STDC_A1_SOURCE */

/* This must be defined on some systems to enable large file support. */
public static final int _LARGEFILE_SOURCE = 1;

/* This must be defined on AIX systems to enable large file support. */
/* #undef _LARGE_FILES */

/* Define on NetBSD to activate all library features */

/* Define to activate features from IEEE Stds 1003.1-2008 */
public static final long _POSIX_C_SOURCE = 200809L;

/* Define if you have POSIX threads, and your system does not define that. */
/* #undef _POSIX_THREADS */

/* framework name */
public static final String _PYTHONFRAMEWORK = "";

/* Maximum length in bytes of a thread name */
public static final int _PYTHREAD_NAME_MAXLEN = 15;

/* Defined if _Complex C type can be used with libffi. */
public static final int _Py_FFI_SUPPORT_C_COMPLEX = 1;

/* HACL* library can compile SIMD128 implementations */
public static final int _Py_HACL_CAN_COMPILE_VEC128 = 1;

/* HACL* library can compile SIMD256 implementations */
public static final int _Py_HACL_CAN_COMPILE_VEC256 = 1;

/* Define to 1 if the machine stack grows down (default); 0 if it grows up. */
public static final int _Py_STACK_GROWS_DOWN = 1;

/* Define to force use of thread-safe errno, h_errno, and other functions */
public static final int _REENTRANT = 1;

/* Define to 1 if you want to emulate getpid() on WASI */
/* #undef _WASI_EMULATED_GETPID */

/* Define to 1 if you want to emulate process clocks on WASI */
/* #undef _WASI_EMULATED_PROCESS_CLOCKS */

/* Define to 1 if you want to emulate signals on WASI */
/* #undef _WASI_EMULATED_SIGNAL */

/* Define to the level of X/Open that your system supports */

/* Define to activate Unix95-and-earlier features */
public static final int _XOPEN_SOURCE_EXTENDED = 1;

/* Define on FreeBSD to activate all library features */
public static final int __BSD_VISIBLE = 1;

/* Define to 'long' if <time.h> does not define clock_t. */
/* #undef clock_t */

/* Define to empty if 'const' does not conform to ANSI C. */
/* #undef const */

/* Define as 'int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to 'int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to 'long int' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define as a signed integer type capable of holding a process identifier. */
/* #undef pid_t */

/* Define to empty if the keyword does not work. */
/* #undef signed */

/* Define as 'unsigned int' if <stddef.h> doesn't define. */
/* #undef size_t */

/* Define to 'int' if <sys/socket.h> does not define. */
/* #undef socklen_t */

/* Define as 'int' if <sys/types.h> doesn't define. */
/* #undef uid_t */


/* Define the macros needed if on a UnixWare 7.x system. */
// #if defined(__USLC__) && defined(__SCO_VERSION__)
// #define STRICT_SYSV_CURSES /* Don't use ncurses extensions */
// #endif

// #endif /*Py_PYCONFIG_H*/



// Parsed from pymacconfig.h

// This file moves some of the autoconf magic to compile-time when building on
// macOS. This is needed for building 4-way universal binaries and for 64-bit
// universal binaries because the values redefined below aren't configure-time
// constant but only compile-time constant in these scenarios.

// #ifndef PY_MACCONFIG_H
// #define PY_MACCONFIG_H
// #ifdef __APPLE__

// #endif   // __APPLE__
// #endif   // !PY_MACCONFIG_H


// Parsed from pyport.h

// #ifndef Py_PYPORT_H
// #define Py_PYPORT_H

// #ifndef UCHAR_MAX
// #  error "<limits.h> header must define UCHAR_MAX"
// #endif
// #if UCHAR_MAX != 255
// #  error "Python's source code assumes C's unsigned char is an 8-bit type"
// #endif


// Preprocessor check for a builtin preprocessor function. Always return 0
// if __has_builtin() macro is not defined.
//
// __has_builtin() is available on clang and GCC 10.
// #ifdef __has_builtin
// #  define _Py__has_builtin(x) __has_builtin(x)
// #else
// #  define _Py__has_builtin(x) 0
// #endif

// Preprocessor check for a compiler __attribute__. Always return 0
// if __has_attribute() macro is not defined.
// #ifdef __has_attribute
// #  define _Py__has_attribute(x) __has_attribute(x)
// #else
// #  define _Py__has_attribute(x) 0
// #endif

// Macro to use C++ static_cast<> in the Python C API.
// #ifdef __cplusplus
// #  define _Py_STATIC_CAST(type, expr) static_cast<type>(expr)
// #else
// #  define _Py_STATIC_CAST(type, expr) ((type)(expr))
// #endif
// Macro to use the more powerful/dangerous C-style cast even in C++.
// #define _Py_CAST(type, expr) ((type)(expr))

// Cast a function to another function type T.
//
// The macro first casts the function to the "void func(void)" type
// to prevent compiler warnings.
//
// Note that using this cast only prevents the compiler from emitting
// warnings, but does not prevent an undefined behavior at runtime if
// the original function signature is not respected.
// #define _Py_FUNC_CAST(T, func) _Py_CAST(T, _Py_CAST(void(*)(void), (func)))

// Static inline functions should use _Py_NULL rather than using directly NULL
// to prevent C++ compiler warnings. On C23 and newer and on C++11 and newer,
// _Py_NULL is defined as nullptr.
// #if !defined(_MSC_VER) &&
//     ((defined (__STDC_VERSION__) && __STDC_VERSION__ >= 202311L)
//         || (defined(__cplusplus) && __cplusplus >= 201103))
// #  define _Py_NULL nullptr
// #else
// #  define _Py_NULL NULL
// #endif


/* Defines to build Python and its standard library:
 *
 * - Py_BUILD_CORE: Build Python core. Give access to Python internals, but
 *   should not be used by third-party modules.
 * - Py_BUILD_CORE_BUILTIN: Build a Python stdlib module as a built-in module.
 * - Py_BUILD_CORE_MODULE: Build a Python stdlib module as a dynamic library.
 *
 * Py_BUILD_CORE_BUILTIN and Py_BUILD_CORE_MODULE imply Py_BUILD_CORE.
 *
 * On Windows, Py_BUILD_CORE_MODULE exports "PyInit_xxx" symbol, whereas
 * Py_BUILD_CORE_BUILTIN does not.
 */
// #if defined(Py_BUILD_CORE_BUILTIN) && !defined(Py_BUILD_CORE)
// #  define Py_BUILD_CORE
// #endif
// #if defined(Py_BUILD_CORE_MODULE) && !defined(Py_BUILD_CORE)
// #  define Py_BUILD_CORE
// #endif


/**************************************************************************
Symbols and macros to supply platform-independent interfaces to basic
C language & library operations whose spellings vary across platforms.
<p>
Please try to make documentation here as clear as possible:  by definition,
the stuff here is trying to illuminate C's darkest corners.
<p>
Config #defines referenced here:
<p>
SIGNED_RIGHT_SHIFT_ZERO_FILLS
Meaning:  To be defined iff i>>j does not extend the sign bit when i is a
          signed integral type and i < 0.
Used in:  Py_ARITHMETIC_RIGHT_SHIFT
<p>
Py_DEBUG
Meaning:  Extra checks compiled in for debug mode.
Used in:  Py_SAFE_DOWNCAST
<p>
**************************************************************************/

/* typedefs for some C9X-defined synonyms for integral types.
 *
 * The names in Python are exactly the same as the C9X names, except with a
 * Py_ prefix.  Until C9X is universally implemented, this is the only way
 * to ensure that Python gets reliable names that don't conflict with names
 * in non-Python code that are playing their own tricks to define the C9X
 * names.
 *
 * NOTE: don't go nuts here!  Python has no use for *most* of the C9X
 * integral synonyms.  Only define the ones we actually need.
 */

/* long long is required. Ensure HAVE_LONG_LONG is defined for compatibility. */
// #ifndef HAVE_LONG_LONG
public static final int HAVE_LONG_LONG = 1;
// #endif
// #ifndef PY_LONG_LONG
// #define PY_LONG_LONG long long
/* If LLONG_MAX is defined in limits.h, use that. */
public static native @MemberGetter long PY_LLONG_MIN();
public static final long PY_LLONG_MIN = PY_LLONG_MIN();
public static native @MemberGetter long PY_LLONG_MAX();
public static final long PY_LLONG_MAX = PY_LLONG_MAX();
public static native @MemberGetter long PY_ULLONG_MAX();
public static final long PY_ULLONG_MAX = PY_ULLONG_MAX();
// #endif

// #define PY_UINT32_T uint32_t
// #define PY_UINT64_T uint64_t

/* Signed variants of the above */
// #define PY_INT32_T int32_t
// #define PY_INT64_T int64_t

/* PYLONG_BITS_IN_DIGIT describes the number of bits per "digit" (limb) in the
 * PyLongObject implementation (longintrepr.h). It's currently either 30 or 15,
 * defaulting to 30. The 15-bit digit option may be removed in the future.
 */
// #ifndef PYLONG_BITS_IN_DIGIT
public static final int PYLONG_BITS_IN_DIGIT = 30;
// #endif

/* uintptr_t is the C9X name for an unsigned integral type such that a
 * legitimate void* can be cast to uintptr_t and then back to void* again
 * without loss of information.  Similarly for intptr_t, wrt a signed
 * integral type.
 */

/* Py_ssize_t is a signed integral type such that sizeof(Py_ssize_t) ==
 * sizeof(size_t).  C99 doesn't define such a thing directly (size_t is an
 * unsigned integral type).  See PEP 353 for details.
 * PY_SSIZE_T_MAX is the largest positive value of type Py_ssize_t.
 */
// #ifdef HAVE_PY_SSIZE_T

// #elif HAVE_SSIZE_T
public static native @MemberGetter long PY_SSIZE_T_MAX();
public static final long PY_SSIZE_T_MAX = PY_SSIZE_T_MAX();
// #elif SIZEOF_VOID_P == SIZEOF_SIZE_T
// #else
// #   error "Python needs a typedef for Py_ssize_t in pyport.h."
// #endif

/* Smallest negative value of type Py_ssize_t. */
public static native @MemberGetter long PY_SSIZE_T_MIN();
public static final long PY_SSIZE_T_MIN = PY_SSIZE_T_MIN();

/* Py_hash_t is the same size as a pointer. */
public static native @MemberGetter long SIZEOF_PY_HASH_T();
public static final long SIZEOF_PY_HASH_T = SIZEOF_PY_HASH_T();
/* Py_uhash_t is the unsigned equivalent needed to calculate numeric hash. */
public static native @MemberGetter long SIZEOF_PY_UHASH_T();
public static final long SIZEOF_PY_UHASH_T = SIZEOF_PY_UHASH_T();

/* Now PY_SSIZE_T_CLEAN is mandatory. This is just for backward compatibility. */

/* Largest possible value of size_t. */
// #define PY_SIZE_MAX SIZE_MAX

/* Macro kept for backward compatibility: use directly "z" in new code.
 *
 * PY_FORMAT_SIZE_T is a modifier for use in a printf format to convert an
 * argument with the width of a size_t or Py_ssize_t: "z" (C99).
 */
// #ifndef PY_FORMAT_SIZE_T
// #   define PY_FORMAT_SIZE_T "z"
// #endif

/* Py_LOCAL can be used instead of static to get the fastest possible calling
 * convention for functions that are local to a given module.
 *
 * Py_LOCAL_INLINE does the same thing, and also explicitly requests inlining,
 * for platforms that support that.
 *
 * NOTE: You can only use this for functions that are entirely local to a
 * module; functions that are exported via method tables, callbacks, etc,
 * should keep using static.
 */

// #if defined(_MSC_VER)
   /* ignore warnings if the compiler decides not to inline a function */
// #  pragma warning(disable: 4710)
   /* fastest possible local call under MSVC */
// #  define Py_LOCAL(type) static type __fastcall
// #  define Py_LOCAL_INLINE(type) static __inline type __fastcall
// #else
// #  define Py_LOCAL(type) static type
// #  define Py_LOCAL_INLINE(type) static inline type
// #endif

// Soft deprecated since Python 3.14, use memcpy() instead.
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000
// #endif

// #ifdef __cplusplus
/* Move this down here since some C++ #include's don't like to be included
   inside an extern "C" */
// #endif


/* Py_ARITHMETIC_RIGHT_SHIFT
 * C doesn't define whether a right-shift of a signed integer sign-extends
 * or zero-fills.  Here a macro to force sign extension:
 * Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J)
 *    Return I >> J, forcing sign extension.  Arithmetically, return the
 *    floor of I/2**J.
 * Requirements:
 *    I should have signed integer type.  In the terminology of C99, this can
 *    be either one of the five standard signed integer types (signed char,
 *    short, int, long, long long) or an extended signed integer type.
 *    J is an integer >= 0 and strictly less than the number of bits in the
 *    type of I (because C doesn't define what happens for J outside that
 *    range either).
 *    TYPE used to specify the type of I, but is now ignored.  It's been left
 *    in for backwards compatibility with versions <= 2.6 or 3.0.
 * Caution:
 *    I may be evaluated more than once.
 */
// #ifdef SIGNED_RIGHT_SHIFT_ZERO_FILLS
// #define Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J)
//     ((I) < 0 ? -1-((-1-(I)) >> (J)) : (I) >> (J))
// #else
// #define Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J) ((I) >> (J))
// #endif

/* Py_FORCE_EXPANSION(X)
 * "Simply" returns its argument.  However, macro expansions within the
 * argument are evaluated.  This unfortunate trickery is needed to get
 * token-pasting to work as desired in some cases.
 */
// #define Py_FORCE_EXPANSION(X) X

/* Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW)
 * Cast VALUE to type NARROW from type WIDE.  In Py_DEBUG mode, this
 * assert-fails if any information is lost.
 * Caution:
 *    VALUE may be evaluated more than once.
 */
// #ifdef Py_DEBUG
// #else
// #  define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) _Py_STATIC_CAST(NARROW, (VALUE))
// #endif


/* Py_DEPRECATED(version)
 * Declare a variable, type, or function deprecated.
 * The macro must be placed before the declaration.
 * Usage:
 *    Py_DEPRECATED(3.3) extern int old_var;
 *    Py_DEPRECATED(3.4) typedef int T1;
 *    Py_DEPRECATED(3.8) PyAPI_FUNC(int) Py_OldFunction(void);
 */
// #if defined(__GNUC__)
//     && ((__GNUC__ >= 4) || (__GNUC__ == 3) && (__GNUC_MINOR__ >= 1))
// #define Py_DEPRECATED(VERSION_UNUSED) __attribute__((__deprecated__))
// #elif defined(_MSC_VER)
// #define Py_DEPRECATED(VERSION) __declspec(deprecated(
//                                           "deprecated in " #VERSION))
// #else
// #define Py_DEPRECATED(VERSION_UNUSED)
// #endif

// _Py_DEPRECATED_EXTERNALLY(version)
// Deprecated outside CPython core.
// #ifdef Py_BUILD_CORE
// #else
// #define _Py_DEPRECATED_EXTERNALLY(version) Py_DEPRECATED(version)
// #endif


// #if defined(__clang__)
// #define _Py_COMP_DIAG_PUSH _Pragma("clang diagnostic push")
// #define _Py_COMP_DIAG_IGNORE_DEPR_DECLS
//     _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
// #define _Py_COMP_DIAG_POP _Pragma("clang diagnostic pop")
// #elif defined(__GNUC__)
//     && ((__GNUC__ >= 5) || (__GNUC__ == 4) && (__GNUC_MINOR__ >= 6))
// #define _Py_COMP_DIAG_PUSH _Pragma("GCC diagnostic push")
// #define _Py_COMP_DIAG_IGNORE_DEPR_DECLS
//     _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
// #define _Py_COMP_DIAG_POP _Pragma("GCC diagnostic pop")
// #elif defined(_MSC_VER)
// #define _Py_COMP_DIAG_PUSH __pragma(warning(push))
// #define _Py_COMP_DIAG_IGNORE_DEPR_DECLS __pragma(warning(disable: 4996))
// #define _Py_COMP_DIAG_POP __pragma(warning(pop))
// #else
// #define _Py_COMP_DIAG_PUSH
// #define _Py_COMP_DIAG_IGNORE_DEPR_DECLS
// #define _Py_COMP_DIAG_POP
// #endif

/* _Py_HOT_FUNCTION
 * The hot attribute on a function is used to inform the compiler that the
 * function is a hot spot of the compiled program. The function is optimized
 * more aggressively and on many target it is placed into special subsection of
 * the text section so all hot functions appears close together improving
 * locality.
 *
 * Usage:
 *    int _Py_HOT_FUNCTION x(void) { return 3; }
 *
 * Issue #28618: This attribute must not be abused, otherwise it can have a
 * negative effect on performance. Only the functions were Python spend most of
 * its time must use it. Use a profiler when running performance benchmark
 * suite to find these functions.
 */
// #if defined(__GNUC__)
//     && ((__GNUC__ >= 5) || (__GNUC__ == 4) && (__GNUC_MINOR__ >= 3))
// #define _Py_HOT_FUNCTION __attribute__((hot))
// #else
// #define _Py_HOT_FUNCTION
// #endif

// Ask the compiler to always inline a static inline function. The compiler can
// ignore it and decides to not inline the function.
//
// It can be used to inline performance critical static inline functions when
// building Python in debug mode with function inlining disabled. For example,
// MSC disables function inlining when building in debug mode.
//
// Marking blindly a static inline function with Py_ALWAYS_INLINE can result in
// worse performances (due to increased code size for example). The compiler is
// usually smarter than the developer for the cost/benefit analysis.
//
// If Python is built in debug mode (if the Py_DEBUG macro is defined), the
// Py_ALWAYS_INLINE macro does nothing.
//
// It must be specified before the function return type. Usage:
//
//     static inline Py_ALWAYS_INLINE int random(void) { return 4; }
// #if defined(Py_DEBUG)
   // If Python is built in debug mode, usually compiler optimizations are
   // disabled. In this case, Py_ALWAYS_INLINE can increase a lot the stack
   // memory usage. For example, forcing inlining using gcc -O0 increases the
   // stack usage from 6 KB to 15 KB per Python function call.
// #  define Py_ALWAYS_INLINE
// #elif defined(__GNUC__) || defined(__clang__) || defined(__INTEL_COMPILER)
// #  define Py_ALWAYS_INLINE __attribute__((always_inline))
// #elif defined(_MSC_VER)
// #  define Py_ALWAYS_INLINE __forceinline
// #else
// #  define Py_ALWAYS_INLINE
// #endif

// Py_NO_INLINE
// Disable inlining on a function. For example, it reduces the C stack
// consumption: useful on LTO+PGO builds which heavily inline code (see
// bpo-33720).
//
// Usage:
//
//    Py_NO_INLINE static int random(void) { return 4; }
// #if defined(__GNUC__) || defined(__clang__) || defined(__INTEL_COMPILER)
// #  define Py_NO_INLINE __attribute__ ((noinline))
// #elif defined(_MSC_VER)
// #  define Py_NO_INLINE __declspec(noinline)
// #else
// #  define Py_NO_INLINE
// #endif

// #include "exports.h"

// #ifdef Py_LIMITED_API
   // The internal C API must not be used with the limited C API: make sure
   // that Py_BUILD_CORE macro is not defined in this case. These 3 macros are
   // used by exports.h, so only undefine them afterwards.
// #  undef Py_BUILD_CORE
// #  undef Py_BUILD_CORE_BUILTIN
// #  undef Py_BUILD_CORE_MODULE
// #endif

/* limits.h constants that may be missing */

// #ifndef INT_MAX
public static final int INT_MAX = 2147483647;
// #endif

// #ifndef LONG_MAX
// #if SIZEOF_LONG == 4
public static final long LONG_MAX = 0X7FFFFFFFL;
// #elif SIZEOF_LONG == 8
// #else
// #error "could not set LONG_MAX in pyport.h"
// #endif
// #endif

// #ifndef LONG_MIN
public static final long LONG_MIN = (-LONG_MAX-1);
// #endif

// #ifndef LONG_BIT
public static native @MemberGetter long LONG_BIT();
public static final long LONG_BIT = LONG_BIT();
// #endif

// #if LONG_BIT != 8 * SIZEOF_LONG
/* 04-Oct-2000 LONG_BIT is apparently (mis)defined as 64 on some recent
 * 32-bit platforms using gcc.  We try to catch that here at compile-time
 * rather than waiting for integer multiplication to trigger bogus
 * overflows.
 */
// #error "LONG_BIT definition appears wrong for platform (bad gcc/glibc config?)."
// #endif

// #ifdef __cplusplus
// #endif

/*
 * Hide GCC attributes from compilers that don't support them.
 */
// #if (!defined(__GNUC__) || __GNUC__ < 2 ||
//      (__GNUC__ == 2 && __GNUC_MINOR__ < 7) )
// #define Py_GCC_ATTRIBUTE(x)
// #else
// #define Py_GCC_ATTRIBUTE(x) __attribute__(x)
// #endif

/*
 * Specify alignment on compilers that support it.
 */
// #if defined(__GNUC__) && __GNUC__ >= 3
// #define Py_ALIGNED(x) __attribute__((aligned(x)))
// #else
// #define Py_ALIGNED(x)
// #endif

/* Eliminate end-of-loop code not reached warnings from SunPro C
 * when using do{...}while(0) macros
 */
// #ifdef __SUNPRO_C
// #pragma error_messages (off,E_END_OF_LOOP_CODE_NOT_REACHED)
// #endif

// #ifndef Py_LL
// #define Py_LL(x) x##LL
// #endif

// #ifndef Py_ULL
// #define Py_ULL(x) Py_LL(x##U)
// #endif

// #define Py_VA_COPY va_copy

/*
 * Convenient macros to deal with endianness of the platform. WORDS_BIGENDIAN is
 * detected by configure and defined in pyconfig.h. The code in pyconfig.h
 * also takes care of Apple's universal builds.
 */

// #ifdef WORDS_BIGENDIAN
// #  define PY_BIG_ENDIAN 1
public static final int PY_LITTLE_ENDIAN = 0;
// #else
// #endif

// #ifdef __ANDROID__
   /* The Android langinfo.h header is not used. */
// #  undef HAVE_LANGINFO_H
// #  undef CODESET
// #endif

/* Maximum value of the Windows DWORD type */
public static final long PY_DWORD_MAX = 4294967295L;

/* This macro used to tell whether Python was built with multithreading
 * enabled.  Now multithreading is always enabled, but keep the macro
 * for compatibility.
 */
// #ifndef WITH_THREAD
// #endif

/* Some WebAssembly platforms do not provide a working pthread implementation.
 * Thread support is stubbed and any attempt to create a new thread fails.
 */
// #if (!defined(HAVE_PTHREAD_STUBS) &&
//       (!defined(__EMSCRIPTEN__) || defined(__EMSCRIPTEN_PTHREADS__)))
public static final int Py_CAN_START_THREADS = 1;
// #endif

// #ifdef WITH_THREAD
// #  ifdef Py_BUILD_CORE
// #  endif
// #endif

// #if defined(__ANDROID__) || defined(__VXWORKS__)
   // Use UTF-8 as the locale encoding, ignore the LC_CTYPE locale.
   // See _Py_GetLocaleEncoding(), PyUnicode_DecodeLocale()
   // and PyUnicode_EncodeLocale().
// #  define _Py_FORCE_UTF8_LOCALE
// #endif

// #if defined(_Py_FORCE_UTF8_LOCALE) || defined(__APPLE__)
   // Use UTF-8 as the filesystem encoding.
   // See PyUnicode_DecodeFSDefaultAndSize(), PyUnicode_EncodeFSDefault(),
   // Py_DecodeLocale() and Py_EncodeLocale().
// #  define _Py_FORCE_UTF8_FS_ENCODING
// #endif

/* Mark a function which cannot return. Example:
   PyAPI_FUNC(void) _Py_NO_RETURN PyThread_exit_thread(void);

   XLC support is intentionally omitted due to bpo-40244 */
// #ifndef _Py_NO_RETURN
// #if defined(__clang__) ||
//     (defined(__GNUC__) &&
//      ((__GNUC__ >= 3) ||
//       (__GNUC__ == 2) && (__GNUC_MINOR__ >= 5)))
// #  define _Py_NO_RETURN __attribute__((__noreturn__))
// #elif defined(_MSC_VER)
// #  define _Py_NO_RETURN __declspec(noreturn)
// #else
// #  define _Py_NO_RETURN
// #endif
// #endif


// _Py_TYPEOF(expr) gets the type of an expression.
//
// Example: _Py_TYPEOF(x) x_copy = (x);
//
// The macro is only defined if GCC or clang compiler is used.
// #if defined(__GNUC__) || defined(__clang__)
// #  define _Py_TYPEOF(expr) __typeof__(expr)
// #endif


/* A convenient way for code to know if sanitizers are enabled. */
// #if defined(__has_feature)
// #  if __has_feature(memory_sanitizer)
// #    if !defined(_Py_MEMORY_SANITIZER)
// #      define _Py_MEMORY_SANITIZER
// #      define _Py_NO_SANITIZE_MEMORY __attribute__((no_sanitize_memory))
// #    endif
// #  endif
// #  if __has_feature(address_sanitizer)
// #    if !defined(_Py_ADDRESS_SANITIZER)
// #      define _Py_ADDRESS_SANITIZER
// #      define _Py_NO_SANITIZE_ADDRESS __attribute__((no_sanitize_address))
// #    endif
// #  endif
// #  if __has_feature(thread_sanitizer)
// #    if !defined(_Py_THREAD_SANITIZER)
// #      define _Py_THREAD_SANITIZER
// #      define _Py_NO_SANITIZE_THREAD __attribute__((no_sanitize_thread))
// #    endif
// #  endif
// #elif defined(__GNUC__)
// #  if defined(__SANITIZE_ADDRESS__)
// #    define _Py_ADDRESS_SANITIZER
// #    define _Py_NO_SANITIZE_ADDRESS __attribute__((no_sanitize_address))
// #  endif
// #  if defined(__SANITIZE_THREAD__)
// #    define _Py_THREAD_SANITIZER
// #    define _Py_NO_SANITIZE_THREAD __attribute__((no_sanitize_thread))
// #  elif  __GNUC__ > 5 || (__GNUC__ == 5 && __GNUC_MINOR__ >= 1)
     // TSAN is supported since GCC 5.1, but __SANITIZE_THREAD__ macro
     // is provided only since GCC 7.
// #    define _Py_NO_SANITIZE_THREAD __attribute__((no_sanitize_thread))
// #  endif
// #endif

// #ifndef _Py_NO_SANITIZE_ADDRESS
// #  define _Py_NO_SANITIZE_ADDRESS
// #endif
// #ifndef _Py_NO_SANITIZE_THREAD
// #  define _Py_NO_SANITIZE_THREAD
// #endif
// #ifndef _Py_NO_SANITIZE_MEMORY
// #  define _Py_NO_SANITIZE_MEMORY
// #endif

/* AIX has __bool__ redefined in it's system header file. */
// #if defined(_AIX) && defined(__bool__)
// #undef __bool__
// #endif

// Make sure we have maximum alignment, even if the current compiler
// does not support max_align_t. Note that:
// - Autoconf reports alignment of unknown types to 0.
// - 'long double' has maximum alignment on *most* platforms,
//   looks like the best we can do for pre-C11 compilers.
// - The value is tested, see test_alignof_max_align_t
// #if !defined(ALIGNOF_MAX_ALIGN_T) || ALIGNOF_MAX_ALIGN_T == 0
// #   undef ALIGNOF_MAX_ALIGN_T
// #endif

// #ifndef PY_CXX_CONST
// #  ifdef __cplusplus
// #    define PY_CXX_CONST const
// #  else
// #    define PY_CXX_CONST
// #  endif
// #endif

// #if defined(__sgi) && !defined(_SGI_MP_SOURCE)
// #  define _SGI_MP_SOURCE
// #endif

// Explicit fallthrough in switch case to avoid warnings
// with compiler flag -Wimplicit-fallthrough.
//
// Usage example:
//
//     switch (value) {
//     case 1: _Py_FALLTHROUGH;
//     case 2: code; break;
//     }
//
// __attribute__((fallthrough)) was introduced in GCC 7 and Clang 10 /
// Apple Clang 12.0. Earlier Clang versions support only the C++11
// style fallthrough attribute, not the GCC extension syntax used here,
// and __has_attribute(fallthrough) evaluates to 1.
// #if _Py__has_attribute(fallthrough) && (!defined(__clang__) ||
//     (!defined(__apple_build_version__) && __clang_major__ >= 10) ||
//     (defined(__apple_build_version__) && __clang_major__ >= 12))
// #  define _Py_FALLTHROUGH __attribute__((fallthrough))
// #else
// #  define _Py_FALLTHROUGH do { } while (0)
// #endif


// _Py_NO_SANITIZE_UNDEFINED(): Disable Undefined Behavior sanitizer (UBsan)
// on a function.
//
// Clang and GCC 9.0+ use __attribute__((no_sanitize("undefined"))).
// GCC 4.9+ uses __attribute__((no_sanitize_undefined)).
// #if defined(__has_feature)
// #  if __has_feature(undefined_behavior_sanitizer)
// #    define _Py_NO_SANITIZE_UNDEFINED __attribute__((no_sanitize("undefined")))
// #  endif
// #endif
// #if !defined(_Py_NO_SANITIZE_UNDEFINED) && defined(__GNUC__)
//     && ((__GNUC__ >= 5) || (__GNUC__ == 4) && (__GNUC_MINOR__ >= 9))
// #  define _Py_NO_SANITIZE_UNDEFINED __attribute__((no_sanitize_undefined))
// #endif
// #ifndef _Py_NO_SANITIZE_UNDEFINED
// #  define _Py_NO_SANITIZE_UNDEFINED
// #endif


// _Py_NONSTRING: The nonstring variable attribute specifies that an object or
// member declaration with type array of char, signed char, or unsigned char,
// or pointer to such a type is intended to store character arrays that do not
// necessarily contain a terminating NUL.
//
// Usage:
//
//   char name [8] _Py_NONSTRING;
// #if _Py__has_attribute(nonstring)
// #  define _Py_NONSTRING __attribute__((nonstring))
// #else
// #  define _Py_NONSTRING
// #endif


// Assume the stack grows down unless specified otherwise
// #ifndef _Py_STACK_GROWS_DOWN
// #endif


// #endif /* Py_PYPORT_H */


// Parsed from pymacro.h

// #ifndef Py_PYMACRO_H
// #define Py_PYMACRO_H

// gh-91782: On FreeBSD 12, if the _POSIX_C_SOURCE and _XOPEN_SOURCE macros are
// defined, <sys/cdefs.h> disables C11 support and <assert.h> does not define
// the static_assert() macro.
// https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=255290
//
// macOS <= 10.10 doesn't define static_assert in assert.h at all despite
// having C11 compiler support.
//
// static_assert is defined in glibc from version 2.16. Compiler support for
// the C11 _Static_assert keyword is in gcc >= 4.6.
//
// MSVC makes static_assert a keyword in C11-17, contrary to the standards.
//
// In C++11 and C2x, static_assert is a keyword, redefining is undefined
// behaviour. So only define if building as C, not C++ (if __cplusplus is
// not defined), and only for C11-17.
// #if !defined(static_assert) && (defined(__GNUC__) || defined(__clang__))
//      && !defined(__cplusplus) && defined(__STDC_VERSION__)
//      && __STDC_VERSION__ >= 201112L && __STDC_VERSION__ <= 201710L
// #  define static_assert _Static_assert
// #endif


// _Py_ALIGN_AS: this compiler's spelling of `alignas` keyword,
// We currently use alignas for free-threaded builds only; additional compat
// checking would be great before we add it to the default build.
// Standards/compiler support:
// - `alignas` is a keyword in C23 and C++11.
// - `_Alignas` is a keyword in C11
// - GCC & clang has __attribute__((aligned))
//   (use that for older standards in pedantic mode)
// - MSVC has __declspec(align)
// - `_Alignas` is common C compiler extension
// Older compilers may name it differently; to allow compilation on such
// unsupported platforms, we don't redefine _Py_ALIGN_AS if it's already
// defined. Note that defining it wrong (including defining it to nothing) will
// cause ABI incompatibilities.
// #ifdef Py_GIL_DISABLED
// #endif

/* Minimum value between x and y */
// #define Py_MIN(x, y) (((x) > (y)) ? (y) : (x))

/* Maximum value between x and y */
// #define Py_MAX(x, y) (((x) > (y)) ? (x) : (y))

/* Absolute value of the number x */
// #define Py_ABS(x) ((x) < 0 ? -(x) : (x))

// #define _Py_XSTRINGIFY(x) #x

/* Convert the argument to a string. For example, Py_STRINGIFY(123) is replaced
   with "123" by the preprocessor. Defines are also replaced by their value.
   For example Py_STRINGIFY(__LINE__) is replaced by the line number, not
   by "__LINE__". */
// #define Py_STRINGIFY(x) _Py_XSTRINGIFY(x)

/* Get the size of a structure member in bytes */
// #define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)

/* Argument must be a char or an int in [-128, 127] or [0, 255]. */
// #define Py_CHARMASK(c) ((unsigned char)((c) & 0xff))

// #if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
//      && !defined(__cplusplus) && !defined(_MSC_VER))
// #  define Py_BUILD_ASSERT_EXPR(cond)
//     ((void)sizeof(struct { int dummy; _Static_assert(cond, #cond); }),
//      0)
// #else
   /* Assert a build-time dependency, as an expression.
    *
    * Your compile will fail if the condition isn't true, or can't be evaluated
    * by the compiler. This can be used in an expression: its value is 0.
    *
    * Example:
    *
    * #define foo_to_char(foo)  \
    *     ((char *)(foo)        \
    *      + Py_BUILD_ASSERT_EXPR(offsetof(struct foo, string) == 0))
    *
    * Written by Rusty Russell, public domain, http://ccodearchive.net/
    */
// #  define Py_BUILD_ASSERT_EXPR(cond)
//     (sizeof(char [1 - 2*!(cond)]) - 1)
// #endif

// #if ((defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L)
//      || (defined(__cplusplus) && __cplusplus >= 201103L))
   // Use static_assert() on C11 and newer
// #  define Py_BUILD_ASSERT(cond)
//         do {
//             static_assert((cond), #cond);
//         } while (0)
// #else
// #  define Py_BUILD_ASSERT(cond)
//         do {
//             (void)Py_BUILD_ASSERT_EXPR(cond);
//         } while(0)
// #endif

/* Get the number of elements in a visible array

   This does not work on pointers, or arrays declared as [], or function
   parameters. With correct compiler support, such usage will cause a build
   error (see Py_BUILD_ASSERT_EXPR).

   Written by Rusty Russell, public domain, http://ccodearchive.net/

   Requires at GCC 3.1+ */
// #if (defined(__GNUC__) && !defined(__STRICT_ANSI__) &&
//     (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 1)) || (__GNUC__ >= 4)))
/* Two gcc extensions.
   &a[0] degrades to a pointer: a different type from an array */
// #define Py_ARRAY_LENGTH(array)
//     (sizeof(array) / sizeof((array)[0])
//      + Py_BUILD_ASSERT_EXPR(!__builtin_types_compatible_p(typeof(array),
//                                                           typeof(&(array)[0]))))
// #else
// #define Py_ARRAY_LENGTH(array)
//     (sizeof(array) / sizeof((array)[0]))
// #endif


/* Define macros for inline documentation. */
// #define PyDoc_VAR(name) static const char name[]
// #define PyDoc_STRVAR(name,str) PyDoc_VAR(name) = PyDoc_STR(str)
// #ifdef WITH_DOC_STRINGS
// #define PyDoc_STR(str) str
// #else
// #endif

/* Below "a" is a power of 2. */
/* Round down size "n" to be a multiple of "a". */
// #define _Py_SIZE_ROUND_DOWN(n, a) ((size_t)(n) & ~(size_t)((a) - 1))
/* Round up size "n" to be a multiple of "a". */
// #define _Py_SIZE_ROUND_UP(n, a) (((size_t)(n) +
//         (size_t)((a) - 1)) & ~(size_t)((a) - 1))
/* Round pointer "p" down to the closest "a"-aligned address <= "p". */
// #define _Py_ALIGN_DOWN(p, a) ((void *)((uintptr_t)(p) & ~(uintptr_t)((a) - 1)))
/* Round pointer "p" up to the closest "a"-aligned address >= "p". */
// #define _Py_ALIGN_UP(p, a) ((void *)(((uintptr_t)(p) +
//         (uintptr_t)((a) - 1)) & ~(uintptr_t)((a) - 1)))
/* Check if pointer "p" is aligned to "a"-bytes boundary. */
// #define _Py_IS_ALIGNED(p, a) (!((uintptr_t)(p) & (uintptr_t)((a) - 1)))

/* Use this for unused arguments in a function definition to silence compiler
 * warnings. Example:
 *
 * int func(int a, int Py_UNUSED(b)) { return a; }
 */
// #if defined(__GNUC__) || defined(__clang__)
// #  define Py_UNUSED(name) _unused_ ## name __attribute__((unused))
// #elif defined(_MSC_VER)
   // Disable warning C4100: unreferenced formal parameter,
   // declare the parameter,
   // restore old compiler warnings.
// #  define Py_UNUSED(name)
//         __pragma(warning(push))
//         __pragma(warning(suppress: 4100))
//         _unused_ ## name
//         __pragma(warning(pop))
// #else
// #  define Py_UNUSED(name) _unused_ ## name
// #endif

// #if defined(RANDALL_WAS_HERE)
// #  define Py_UNREACHABLE()
//     Py_FatalError(
//         "If you're seeing this, the code is in what I thought was\n"
//         "an unreachable state.\n\n"
//         "I could give you advice for what to do, but honestly, why\n"
//         "should you trust me?  I clearly screwed this up.  I'm writing\n"
//         "a message that should never appear, yet I know it will\n"
//         "probably appear someday.\n\n"
//         "On a deep level, I know I'm not up to this task.\n"
//         "I'm so sorry.\n"
//         "https://xkcd.com/2200")
// #elif defined(Py_DEBUG)
// #  define Py_UNREACHABLE()
//     Py_FatalError(
//         "We've reached an unreachable state. Anything is possible.\n"
//         "The limits were in our heads all along. Follow your dreams.\n"
//         "https://xkcd.com/2200")
// #elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5))
// #  define Py_UNREACHABLE() __builtin_unreachable()
// #elif defined(__clang__) || defined(__INTEL_COMPILER)
// #  define Py_UNREACHABLE() __builtin_unreachable()
// #elif defined(_MSC_VER)
// #  define Py_UNREACHABLE() __assume(0)
// #else
// #  define Py_UNREACHABLE()
//     Py_FatalError("Unreachable C code path reached")
// #endif

// #define _Py_CONTAINER_OF(ptr, type, member)
//     (type*)((char*)ptr - offsetof(type, member))

// Prevent using an expression as a l-value.
// For example, "int x; _Py_RVALUE(x) = 1;" fails with a compiler error.
// #define _Py_RVALUE(EXPR) ((void)0, (EXPR))

// Return non-zero if the type is signed, return zero if it's unsigned.
// Use "<= 0" rather than "< 0" to prevent the compiler warning:
// "comparison of unsigned expression in '< 0' is always false".
// #define _Py_IS_TYPE_SIGNED(type) ((type)(-1) <= 0)

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030E0000 // 3.14
// Version helpers. These are primarily macros, but have exported equivalents.
@NoException public static native @Cast("uint32_t") int Py_PACK_VERSION(int x, int y);
// #define Py_PACK_FULL_VERSION _Py_PACK_FULL_VERSION
// #define Py_PACK_VERSION(X, Y) Py_PACK_FULL_VERSION(X, Y, 0, 0, 0)
// #endif // Py_LIMITED_API < 3.14


// #endif /* Py_PYMACRO_H */


// Parsed from pymath.h

// Symbols and macros to supply platform-independent interfaces to mathematical
// functions and constants.

// #ifndef Py_PYMATH_H
// #define Py_PYMATH_H

/* High precision definition of pi and e (Euler)
 * The values are taken from libc6's math.h.
 */
// #ifndef Py_MATH_PIl
public static final double Py_MATH_PIl = 3.1415926535897932384626433832795029;
// #endif
// #ifndef Py_MATH_PI
public static final double Py_MATH_PI = 3.14159265358979323846;
// #endif

// #ifndef Py_MATH_El
public static final double Py_MATH_El = 2.7182818284590452353602874713526625;
// #endif

// #ifndef Py_MATH_E
public static final double Py_MATH_E = 2.7182818284590452354;
// #endif

/* Tau (2pi) to 40 digits, taken from tauday.com/tau-digits. */
// #ifndef Py_MATH_TAU
public static final double Py_MATH_TAU = 6.2831853071795864769252867665590057683943;
// #endif

// Py_IS_NAN(X)
// Return 1 if float or double arg is a NaN, else 0.
// Soft deprecated since Python 3.14, use isnan() instead.
// #define Py_IS_NAN(X) isnan(X)

// Py_IS_INFINITY(X)
// Return 1 if float or double arg is an infinity, else 0.
// Soft deprecated since Python 3.14, use isinf() instead.
// #define Py_IS_INFINITY(X) isinf(X)

// Py_IS_FINITE(X)
// Return 1 if float or double arg is neither infinite nor NAN, else 0.
// Soft deprecated since Python 3.14, use isfinite() instead.
// #define Py_IS_FINITE(X) isfinite(X)

// Py_INFINITY: Value that evaluates to a positive double infinity.
// #ifndef Py_INFINITY
public static native @MemberGetter double Py_INFINITY();
public static final double Py_INFINITY = Py_INFINITY();
// #endif

/* Py_HUGE_VAL should always be the same as Py_INFINITY.  But historically
 * this was not reliable and Python did not require IEEE floats and C99
 * conformity.  The macro was soft deprecated in Python 3.14, use Py_INFINITY instead.
 */
// #ifndef Py_HUGE_VAL
// #  define Py_HUGE_VAL HUGE_VAL
// #endif

/* Py_NAN: Value that evaluates to a quiet Not-a-Number (NaN).  The sign is
 * undefined and normally not relevant, but e.g. fixed for float("nan").
 */
// #if !defined(Py_NAN)
// #    define Py_NAN ((double)NAN)
// #endif

// #endif /* Py_PYMATH_H */


// Parsed from cpython/pytime.h

// PyTime_t C API: see Doc/c-api/time.rst for the documentation.

// #ifndef Py_LIMITED_API
// #ifndef Py_PYTIME_H
// #define Py_PYTIME_H
// #ifdef __cplusplus
// #endif
public static native @MemberGetter long PyTime_MIN();
public static final long PyTime_MIN = PyTime_MIN();
public static native @MemberGetter long PyTime_MAX();
public static final long PyTime_MAX = PyTime_MAX();

@NoException public static native double PyTime_AsSecondsDouble(@Cast("PyTime_t") long t);
@NoException public static native int PyTime_Monotonic(@Cast("PyTime_t*") LongPointer result);
@NoException public static native int PyTime_Monotonic(@Cast("PyTime_t*") LongBuffer result);
@NoException public static native int PyTime_Monotonic(@Cast("PyTime_t*") long[] result);
@NoException public static native int PyTime_PerfCounter(@Cast("PyTime_t*") LongPointer result);
@NoException public static native int PyTime_PerfCounter(@Cast("PyTime_t*") LongBuffer result);
@NoException public static native int PyTime_PerfCounter(@Cast("PyTime_t*") long[] result);
@NoException public static native int PyTime_Time(@Cast("PyTime_t*") LongPointer result);
@NoException public static native int PyTime_Time(@Cast("PyTime_t*") LongBuffer result);
@NoException public static native int PyTime_Time(@Cast("PyTime_t*") long[] result);

@NoException public static native int PyTime_MonotonicRaw(@Cast("PyTime_t*") LongPointer result);
@NoException public static native int PyTime_MonotonicRaw(@Cast("PyTime_t*") LongBuffer result);
@NoException public static native int PyTime_MonotonicRaw(@Cast("PyTime_t*") long[] result);
@NoException public static native int PyTime_PerfCounterRaw(@Cast("PyTime_t*") LongPointer result);
@NoException public static native int PyTime_PerfCounterRaw(@Cast("PyTime_t*") LongBuffer result);
@NoException public static native int PyTime_PerfCounterRaw(@Cast("PyTime_t*") long[] result);
@NoException public static native int PyTime_TimeRaw(@Cast("PyTime_t*") LongPointer result);
@NoException public static native int PyTime_TimeRaw(@Cast("PyTime_t*") LongBuffer result);
@NoException public static native int PyTime_TimeRaw(@Cast("PyTime_t*") long[] result);

// #ifdef __cplusplus
// #endif
// #endif /* Py_PYTIME_H */
// #endif /* Py_LIMITED_API */


// Parsed from pymem.h

// The PyMem_ family:  low-level memory allocation interfaces.
// See objimpl.h for the PyObject_ memory family.

// #ifndef Py_PYMEM_H
// #define Py_PYMEM_H
// #ifdef __cplusplus
// #endif

/* BEWARE:

   Each interface exports both functions and macros.  Extension modules should
   use the functions, to ensure binary compatibility across Python versions.
   Because the Python implementation is free to change internal details, and
   the macros may (or may not) expose details for speed, if you do use the
   macros you must recompile your extensions with each Python release.

   Never mix calls to PyMem_ with calls to the platform malloc/realloc/
   calloc/free.  For example, on Windows different DLLs may end up using
   different heaps, and if you use PyMem_Malloc you'll get the memory from the
   heap used by the Python DLL; it could be a disaster if you free()'ed that
   directly in your own extension.  Using PyMem_Free instead ensures Python
   can return the memory to the proper heap.  As another example, in
   a debug build (Py_DEBUG macro), Python wraps all calls to all PyMem_ and
   PyObject_ memory functions in special debugging wrappers that add additional
   debugging info to dynamic memory blocks.  The system routines have no idea
   what to do with that stuff, and the Python wrappers have no idea what to do
   with raw blocks obtained directly by the system routines then.

   The GIL must be held when using these APIs.
*/

/*
 * Raw memory interface
 * ====================
 */

/* Functions

   Functions supplying platform-independent semantics for malloc/realloc/
   free.  These functions make sure that allocating 0 bytes returns a distinct
   non-NULL pointer (whenever possible -- if we're flat out of memory, NULL
   may be returned), even if the platform malloc and realloc don't.
   Returned pointers must be checked for NULL explicitly.  No action is
   performed on failure (no exception is set, no warning is printed, etc).
*/

@NoException public static native Pointer PyMem_Malloc(@Cast("size_t") long size);
@NoException public static native Pointer PyMem_Calloc(@Cast("size_t") long nelem, @Cast("size_t") long elsize);
@NoException public static native Pointer PyMem_Realloc(Pointer ptr, @Cast("size_t") long new_size);
@NoException public static native void PyMem_Free(Pointer ptr);

/*
 * Type-oriented memory interface
 * ==============================
 *
 * Allocate memory for n objects of the given type.  Returns a new pointer
 * or NULL if the request was too large or memory allocation failed.  Use
 * these macros rather than doing the multiplication yourself so that proper
 * overflow checking is always done.
 */

// #define PyMem_New(type, n)
//   ( ((size_t)(n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL :
//         ( (type *) PyMem_Malloc((n) * sizeof(type)) ) )

/*
 * The value of (p) is always clobbered by this macro regardless of success.
 * The caller MUST check if (p) is NULL afterwards and deal with the memory
 * error if so.  This means the original value of (p) MUST be saved for the
 * caller's memory error handler to not lose track of it.
 */
// #define PyMem_Resize(p, type, n)
//   ( (p) = ((size_t)(n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL :
//         (type *) PyMem_Realloc((p), (n) * sizeof(type)) )


// Deprecated aliases only kept for backward compatibility.
// PyMem_Del and PyMem_DEL are defined with no parameter to be able to use
// them as function pointers (ex: dealloc = PyMem_Del).
// #define PyMem_MALLOC(n)           PyMem_Malloc((n))
// #define PyMem_NEW(type, n)        PyMem_New(type, (n))
// #define PyMem_REALLOC(p, n)       PyMem_Realloc((p), (n))
// #define PyMem_RESIZE(p, type, n)  PyMem_Resize((p), type, (n))
// #define PyMem_FREE(p)             PyMem_Free((p))
// #define PyMem_Del(p)              PyMem_Free((p))
// #define PyMem_DEL(p)              PyMem_Free((p))


// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000
// Memory allocator which doesn't require the GIL to be held.
// Usually, it's just a thin wrapper to functions of the standard C library:
// malloc(), calloc(), realloc() and free(). The difference is that
// tracemalloc can track these memory allocations.
@NoException public static native Pointer PyMem_RawMalloc(@Cast("size_t") long size);
@NoException public static native Pointer PyMem_RawCalloc(@Cast("size_t") long nelem, @Cast("size_t") long elsize);
@NoException public static native Pointer PyMem_RawRealloc(Pointer ptr, @Cast("size_t") long new_size);
@NoException public static native void PyMem_RawFree(Pointer ptr);
// #endif

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_PYMEM_H
// #  include "cpython/pymem.h"
// #  undef Py_CPYTHON_PYMEM_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif   // !Py_PYMEM_H


// Parsed from pytypedefs.h

// Forward declarations of types of the Python C API.
// Declare them at the same place since redefining typedef is a C11 feature.
// Only use a forward declaration if there is an interdependency between two
// header files.

// #ifndef Py_PYTYPEDEFS_H
// #define Py_PYTYPEDEFS_H
// #ifdef __cplusplus
// Targeting ../PyObject.java


// Targeting ../PyLongObject.java


// Targeting ../PyFrameObject.java


// Targeting ../PyInterpreterState.java



// #ifdef __cplusplus
// #endif
// #endif   // !Py_PYTYPEDEFS_H


// Parsed from pybuffer.h

/* Public Py_buffer API */

// #ifndef Py_BUFFER_H
// #define Py_BUFFER_H
// #ifdef __cplusplus
// Targeting ../Py_buffer.java


// Targeting ../getbufferproc.java


// Targeting ../releasebufferproc.java



/* Return 1 if the getbuffer function is available, otherwise return 0. */
@NoException public static native int PyObject_CheckBuffer(PyObject obj);

/* This is a C-API version of the getbuffer function call.  It checks
   to make sure object has the required function pointer and issues the
   call.

   Returns -1 and raises an error on failure and returns 0 on success. */
@NoException public static native int PyObject_GetBuffer(PyObject obj, Py_buffer view,
                                   int flags);

/* Get the memory area pointed to by the indices for the buffer given.
   Note that view->ndim is the assumed size of indices. */
@NoException public static native Pointer PyBuffer_GetPointer(@Const Py_buffer view, @Cast("const Py_ssize_t*") SizeTPointer indices);

/* Return the implied itemsize of the data-format area from a
   struct-style description. */


/* Implementation in memoryobject.c */
@NoException public static native int PyBuffer_ToContiguous(Pointer buf, @Const Py_buffer view,
                                      @Cast("Py_ssize_t") long len, @Cast("char") byte order);

@NoException public static native int PyBuffer_FromContiguous(@Const Py_buffer view, @Const Pointer buf,
                                        @Cast("Py_ssize_t") long len, @Cast("char") byte order);

/* Copy len bytes of data from the contiguous chunk of memory
   pointed to by buf into the buffer exported by obj.  Return
   0 on success and return -1 and raise a PyBuffer_Error on
   error (i.e. the object does not have a buffer interface or
   it is not working).

   If fort is 'F', then if the object is multi-dimensional,
   then the data will be copied into the array in
   Fortran-style (first dimension varies the fastest).  If
   fort is 'C', then the data will be copied into the array
   in C-style (last dimension varies the fastest).  If fort
   is 'A', then it does not matter and the copy will be made
   in whatever way is more efficient. */
@NoException public static native int PyObject_CopyData(PyObject dest, PyObject src);

/* Copy the data from the src buffer to the buffer of destination. */
@NoException public static native int PyBuffer_IsContiguous(@Const Py_buffer view, @Cast("char") byte fort);

/*Fill the strides array with byte-strides of a contiguous
  (Fortran-style if fort is 'F' or C-style otherwise)
  array of the given shape with the given number of bytes
  per element. */
@NoException public static native void PyBuffer_FillContiguousStrides(int ndims,
                                               @Cast("Py_ssize_t*") SizeTPointer shape,
                                               @Cast("Py_ssize_t*") SizeTPointer strides,
                                               int itemsize,
                                               @Cast("char") byte fort);

/* Fills in a buffer-info structure correctly for an exporter
   that can only share a contiguous chunk of memory of
   "unsigned bytes" of the given length.

   Returns 0 on success and -1 (with raising an error) on error. */
@NoException public static native int PyBuffer_FillInfo(Py_buffer view, PyObject o, Pointer buf,
                                  @Cast("Py_ssize_t") long len, int readonly,
                                  int flags);

/* Releases a Py_buffer obtained from getbuffer ParseTuple's "s*". */
@NoException public static native void PyBuffer_Release(Py_buffer view);

/* Maximum number of dimensions */
public static final int PyBUF_MAX_NDIM = 64;

/* Flags for getting buffers. Keep these in sync with inspect.BufferFlags. */
public static final int PyBUF_SIMPLE = 0;
public static final int PyBUF_WRITABLE = 0x0001;

// #ifndef Py_LIMITED_API
/*  we used to include an E, backwards compatible alias */
public static final int PyBUF_WRITEABLE = PyBUF_WRITABLE;
// #endif

public static final int PyBUF_FORMAT = 0x0004;
public static final int PyBUF_ND = 0x0008;
public static final int PyBUF_STRIDES = (0x0010 | PyBUF_ND);
public static final int PyBUF_C_CONTIGUOUS = (0x0020 | PyBUF_STRIDES);
public static final int PyBUF_F_CONTIGUOUS = (0x0040 | PyBUF_STRIDES);
public static final int PyBUF_ANY_CONTIGUOUS = (0x0080 | PyBUF_STRIDES);
public static final int PyBUF_INDIRECT = (0x0100 | PyBUF_STRIDES);

public static final int PyBUF_CONTIG = (PyBUF_ND | PyBUF_WRITABLE);
public static final int PyBUF_CONTIG_RO = (PyBUF_ND);

public static final int PyBUF_STRIDED = (PyBUF_STRIDES | PyBUF_WRITABLE);
public static final int PyBUF_STRIDED_RO = (PyBUF_STRIDES);

public static final int PyBUF_RECORDS = (PyBUF_STRIDES | PyBUF_WRITABLE | PyBUF_FORMAT);
public static final int PyBUF_RECORDS_RO = (PyBUF_STRIDES | PyBUF_FORMAT);

public static final int PyBUF_FULL = (PyBUF_INDIRECT | PyBUF_WRITABLE | PyBUF_FORMAT);
public static final int PyBUF_FULL_RO = (PyBUF_INDIRECT | PyBUF_FORMAT);


public static final int PyBUF_READ =  0x100;
public static final int PyBUF_WRITE = 0x200;

// #endif /* !Py_LIMITED_API || Py_LIMITED_API >= 3.11 */

// #ifdef __cplusplus
// #endif
// #endif /* Py_BUFFER_H */


// Parsed from cpython/pymem.h

// #ifndef Py_CPYTHON_PYMEM_H
// #  error "this header file must not be included directly"
// #endif

/** enum PyMemAllocatorDomain */
public static final int
    /* PyMem_RawMalloc(), PyMem_RawRealloc() and PyMem_RawFree() */
    PYMEM_DOMAIN_RAW = 0,

    /* PyMem_Malloc(), PyMem_Realloc() and PyMem_Free() */
    PYMEM_DOMAIN_MEM = 1,

    /* PyObject_Malloc(), PyObject_Realloc() and PyObject_Free() */
    PYMEM_DOMAIN_OBJ = 2;

/** enum PyMemAllocatorName */
public static final int
    PYMEM_ALLOCATOR_NOT_SET = 0,
    PYMEM_ALLOCATOR_DEFAULT = 1,
    PYMEM_ALLOCATOR_DEBUG = 2,
    PYMEM_ALLOCATOR_MALLOC = 3,
    PYMEM_ALLOCATOR_MALLOC_DEBUG = 4,
// #ifdef WITH_PYMALLOC
    PYMEM_ALLOCATOR_PYMALLOC = 5,
    PYMEM_ALLOCATOR_PYMALLOC_DEBUG = 6,
// #endif
// #ifdef WITH_MIMALLOC
    PYMEM_ALLOCATOR_MIMALLOC = 7,
    PYMEM_ALLOCATOR_MIMALLOC_DEBUG = 8;
// #endif
// Targeting ../PyMemAllocatorEx.java



/* Get the memory block allocator of the specified domain. */
@NoException public static native void PyMem_GetAllocator(@Cast("PyMemAllocatorDomain") int domain,
                                    PyMemAllocatorEx allocator);

/* Set the memory block allocator of the specified domain.

   The new allocator must return a distinct non-NULL pointer when requesting
   zero bytes.

   For the PYMEM_DOMAIN_RAW domain, the allocator must be thread-safe: the GIL
   is not held when the allocator is called.

   If the new allocator is not a hook (don't call the previous allocator), the
   PyMem_SetupDebugHooks() function must be called to reinstall the debug hooks
   on top on the new allocator. */
@NoException public static native void PyMem_SetAllocator(@Cast("PyMemAllocatorDomain") int domain,
                                    PyMemAllocatorEx allocator);

/* Setup hooks to detect bugs in the following Python memory allocator
   functions:

   - PyMem_RawMalloc(), PyMem_RawRealloc(), PyMem_RawFree()
   - PyMem_Malloc(), PyMem_Realloc(), PyMem_Free()
   - PyObject_Malloc(), PyObject_Realloc() and PyObject_Free()

   Newly allocated memory is filled with the byte 0xCB, freed memory is filled
   with the byte 0xDB. Additional checks:

   - detect API violations, ex: PyObject_Free() called on a buffer allocated
     by PyMem_Malloc()
   - detect write before the start of the buffer (buffer underflow)
   - detect write after the end of the buffer (buffer overflow)

   The function does nothing if Python is not compiled is debug mode. */
@NoException public static native void PyMem_SetupDebugHooks();


// Parsed from pystats.h

// Statistics on Python performance (public API).
//
// Define _Py_INCREF_STAT_INC() and _Py_DECREF_STAT_INC() used by Py_INCREF()
// and Py_DECREF().
//
// See Include/cpython/pystats.h for the full API.

// #ifndef Py_PYSTATS_H
// #define Py_PYSTATS_H
// #ifdef __cplusplus
// #endif

// #if defined(Py_STATS) && !defined(Py_LIMITED_API)
// #  define Py_CPYTHON_PYSTATS_H
// #  include "cpython/pystats.h"
// #  undef Py_CPYTHON_PYSTATS_H
// #else
// #  define _Py_INCREF_STAT_INC() ((void)0)
// #  define _Py_DECREF_STAT_INC() ((void)0)
// #  define _Py_INCREF_IMMORTAL_STAT_INC() ((void)0)
// #  define _Py_DECREF_IMMORTAL_STAT_INC() ((void)0)
// #endif  // !Py_STATS

// #ifdef __cplusplus
// #endif
// #endif   // !Py_PYSTATS_H


// Parsed from lock.h

// #ifndef Py_LOCK_H
// #define Py_LOCK_H
// #ifdef __cplusplus
// #endif

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_LOCK_H
// #  include "cpython/lock.h"
// #  undef Py_CPYTHON_LOCK_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_LOCK_H */


// Parsed from monitoring.h

// #ifndef Py_MONITORING_H
// #define Py_MONITORING_H
// #ifdef __cplusplus
// #endif

// There is currently no limited API for monitoring

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_MONITORING_H
// #  include "cpython/monitoring.h"
// #  undef Py_CPYTHON_MONITORING_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_MONITORING_H */


// Parsed from critical_section.h

// #ifndef Py_CRITICAL_SECTION_H
// #define Py_CRITICAL_SECTION_H
// #ifdef __cplusplus
// #endif

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_CRITICAL_SECTION_H
// #  include "cpython/critical_section.h"
// #  undef Py_CPYTHON_CRITICAL_SECTION_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_CRITICAL_SECTION_H */


// Parsed from object.h

// #ifndef Py_OBJECT_H
// #define Py_OBJECT_H
// #ifdef __cplusplus
// #endif


/* Object and type object interface */

/*
Objects are structures allocated on the heap.  Special rules apply to
the use of objects to ensure they are properly garbage-collected.
Objects are never allocated statically or on the stack; they must be
accessed through special macros and functions only.  (Type objects are
exceptions to the first rule; the standard types are represented by
statically initialized type objects, although work on type/class unification
for Python 2.2 made it possible to have heap-allocated type objects too).

An object has a 'reference count' that is increased or decreased when a
pointer to the object is copied or deleted; when the reference count
reaches zero there are no references to the object left and it can be
removed from the heap.

An object has a 'type' that determines what it represents and what kind
of data it contains.  An object's type is fixed when it is created.
Types themselves are represented as objects; an object contains a
pointer to the corresponding type object.  The type itself has a type
pointer pointing to the object representing the type 'type', which
contains a pointer to itself!.

Objects do not float around in memory; once allocated an object keeps
the same size and address.  Objects that must hold variable-size data
can contain pointers to variable-size parts of the object.  Not all
objects of the same type have the same size; but the size cannot change
after allocation.  (These restrictions are made so a reference to an
object can be simply a pointer -- moving an object would require
updating all the pointers, and changing an object's size would require
moving it if there was another object right next to it.)

Objects are always accessed through pointers of the type 'PyObject *'.
The type 'PyObject' is a structure that only contains the reference count
and the type pointer.  The actual memory allocated for an object
contains other data that can only be accessed after casting the pointer
to a pointer to a longer structure type.  This longer type must start
with the reference count and type fields; the macro PyObject_HEAD should be
used for this (to accommodate for future changes).  The implementation
of a particular object type can cast the object pointer to the proper
type and back.

A standard interface exists for objects that contain an array of items
whose size is determined when the object is allocated.
*/

/* Py_DEBUG implies Py_REF_DEBUG. */
// #if defined(Py_DEBUG) && !defined(Py_REF_DEBUG)
// #  define Py_REF_DEBUG
// #endif

/* PyObject_HEAD defines the initial segment of every PyObject. */
// #define PyObject_HEAD                   PyObject ob_base;

// Kept for backward compatibility. It was needed by Py_TRACE_REFS build.
// #define _PyObject_EXTRA_INIT

/* Make all uses of PyObject_HEAD_INIT immortal.
 *
 * Statically allocated objects might be shared between
 * interpreters, so must be marked as immortal.
 */
// #if defined(Py_GIL_DISABLED)
// #else
// #define PyObject_HEAD_INIT(type)
//     {
//         { _Py_STATIC_IMMORTAL_INITIAL_REFCNT },
//         (type)
//     },
// #endif

// #define PyVarObject_HEAD_INIT(type, size)
//     {
//         PyObject_HEAD_INIT(type)
//         (size)
//     },

/* PyObject_VAR_HEAD defines the initial segment of all variable-size
 * container objects.  These end with a declaration of an array with 1
 * element, but enough space is malloc'ed so that the array actually
 * has room for ob_size elements.  Note that ob_size is an element count,
 * not necessarily a byte count.
 */
// #define PyObject_VAR_HEAD      PyVarObject ob_base;
public static final long Py_INVALID_SIZE = (long)-1;
// Targeting ../_object.java


// #else
// #endif

/* Cast argument to PyObject* type. */
// #define _PyObject_CAST(op) _Py_CAST(PyObject*, (op))
// Targeting ../PyVarObject.java



/* Cast argument to PyVarObject* type. */
// #define _PyVarObject_CAST(op) _Py_CAST(PyVarObject*, (op))


// Test if the 'x' object is the 'y' object, the same as "x is y" in Python.
@NoException public static native int Py_Is(PyObject x, PyObject y);
// #define Py_Is(x, y) ((x) == (y))

// #if defined(Py_GIL_DISABLED) && !defined(Py_LIMITED_API)
// #endif

// Py_TYPE() implementation for the stable ABI
@NoException public static native PyTypeObject Py_TYPE(PyObject ob);

// #if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030e0000
    // Stable ABI implements Py_TYPE() as a function call
    // on limited C API version 3.14 and newer.
// #else
    @NoException public static native PyTypeObject _Py_TYPE(PyObject ob);
//     #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000
//     #else
//     #   define Py_TYPE(ob) _Py_TYPE(ob)
//     #endif
// #endif

public static native @ByRef PyTypeObject PyLong_Type(); public static native void PyLong_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyBool_Type(); public static native void PyBool_Type(PyTypeObject setter);

// bpo-39573: The Py_SET_SIZE() function must be used to set an object size.
@NoException public static native @Cast("Py_ssize_t") long Py_SIZE(PyObject ob);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000
// #endif

@NoException public static native int Py_IS_TYPE(PyObject ob, PyTypeObject type);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000
// #endif


@NoException public static native void Py_SET_TYPE(PyObject ob, PyTypeObject type);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000
// #endif

@NoException public static native void Py_SET_SIZE(PyVarObject ob, @Cast("Py_ssize_t") long size);
// Targeting ../unaryfunc.java


// Targeting ../binaryfunc.java


// Targeting ../ternaryfunc.java


// Targeting ../inquiry.java


// Targeting ../lenfunc.java


// Targeting ../ssizeargfunc.java


// Targeting ../ssizessizeargfunc.java


// Targeting ../ssizeobjargproc.java


// Targeting ../ssizessizeobjargproc.java


// Targeting ../objobjargproc.java


// Targeting ../objobjproc.java


// Targeting ../visitproc.java


// Targeting ../traverseproc.java


// Targeting ../freefunc.java


// Targeting ../destructor.java


// Targeting ../getattrfunc.java


// Targeting ../getattrofunc.java


// Targeting ../setattrfunc.java


// Targeting ../setattrofunc.java


// Targeting ../reprfunc.java


// Targeting ../hashfunc.java


// Targeting ../richcmpfunc.java


// Targeting ../getiterfunc.java


// Targeting ../iternextfunc.java


// Targeting ../descrgetfunc.java


// Targeting ../descrsetfunc.java


// Targeting ../initproc.java


// Targeting ../newfunc.java


// Targeting ../allocfunc.java


// Targeting ../vectorcallfunc.java


// Targeting ../PyType_Slot.java


// Targeting ../PyType_Spec.java



@NoException public static native PyObject PyType_FromSpec(PyType_Spec arg0);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyType_FromSpecWithBases(PyType_Spec arg0, PyObject arg1);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
@NoException public static native Pointer PyType_GetSlot(PyTypeObject arg0, int arg1);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
@NoException public static native PyObject PyType_FromModuleAndSpec(PyObject arg0, PyType_Spec arg1, PyObject arg2);
@NoException public static native PyObject PyType_GetModule(PyTypeObject arg0);
@NoException public static native Pointer PyType_GetModuleState(PyTypeObject arg0);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030B0000
@NoException public static native PyObject PyType_GetName(PyTypeObject arg0);
@NoException public static native PyObject PyType_GetQualName(PyTypeObject arg0);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030D0000
@NoException public static native PyObject PyType_GetFullyQualifiedName(PyTypeObject type);
@NoException public static native PyObject PyType_GetModuleName(PyTypeObject type);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000
@NoException public static native PyObject PyType_FromMetaclass(PyTypeObject arg0, PyObject arg1, PyType_Spec arg2, PyObject arg3);
@NoException public static native Pointer PyObject_GetTypeData(PyObject obj, PyTypeObject cls);
@NoException public static native @Cast("Py_ssize_t") long PyType_GetTypeDataSize(PyTypeObject cls);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030E0000
@NoException public static native int PyType_GetBaseByToken(PyTypeObject arg0, Pointer arg1, @Cast("PyTypeObject**") PointerPointer arg2);
@NoException public static native int PyType_GetBaseByToken(PyTypeObject arg0, Pointer arg1, @ByPtrPtr PyTypeObject arg2);
public static native @MemberGetter int Py_TP_USE_SPEC();
public static final int Py_TP_USE_SPEC = Py_TP_USE_SPEC();
// #endif

/* Generic type check */
@NoException public static native int PyType_IsSubtype(PyTypeObject arg0, PyTypeObject arg1);

@NoException public static native int PyObject_TypeCheck(PyObject ob, PyTypeObject type);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000
// #endif

public static native @ByRef PyTypeObject PyType_Type(); public static native void PyType_Type(PyTypeObject setter); /* built-in 'type' */
public static native @ByRef PyTypeObject PyBaseObject_Type(); public static native void PyBaseObject_Type(PyTypeObject setter); /* built-in 'object' */
public static native @ByRef PyTypeObject PySuper_Type(); public static native void PySuper_Type(PyTypeObject setter); /* built-in 'super' */

@NoException public static native @Cast("unsigned long") long PyType_GetFlags(PyTypeObject arg0);

@NoException public static native int PyType_Ready(PyTypeObject arg0);
@NoException public static native PyObject PyType_GenericAlloc(PyTypeObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native PyObject PyType_GenericNew(PyTypeObject arg0,
                                               PyObject arg1, PyObject arg2);
@NoException public static native @Cast("unsigned int") int PyType_ClearCache();
@NoException public static native void PyType_Modified(PyTypeObject arg0);

/* Generic operations on objects */
@NoException public static native PyObject PyObject_Repr(PyObject arg0);
@NoException public static native PyObject PyObject_Str(PyObject arg0);
@NoException public static native PyObject PyObject_ASCII(PyObject arg0);
@NoException public static native PyObject PyObject_Bytes(PyObject arg0);
@NoException public static native PyObject PyObject_RichCompare(PyObject arg0, PyObject arg1, int arg2);
@NoException public static native int PyObject_RichCompareBool(PyObject arg0, PyObject arg1, int arg2);
@NoException public static native PyObject PyObject_GetAttrString(PyObject arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native PyObject PyObject_GetAttrString(PyObject arg0, String arg1);
@NoException public static native int PyObject_SetAttrString(PyObject arg0, @Cast("const char*") BytePointer arg1, PyObject arg2);
@NoException public static native int PyObject_SetAttrString(PyObject arg0, String arg1, PyObject arg2);
@NoException public static native int PyObject_DelAttrString(PyObject v, @Cast("const char*") BytePointer name);
@NoException public static native int PyObject_DelAttrString(PyObject v, String name);
@NoException public static native int PyObject_HasAttrString(PyObject arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native int PyObject_HasAttrString(PyObject arg0, String arg1);
@NoException public static native PyObject PyObject_GetAttr(PyObject arg0, PyObject arg1);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000
@NoException public static native int PyObject_GetOptionalAttr(PyObject arg0, PyObject arg1, @Cast("PyObject**") PointerPointer arg2);
@NoException public static native int PyObject_GetOptionalAttr(PyObject arg0, PyObject arg1, @ByPtrPtr PyObject arg2);
@NoException public static native int PyObject_GetOptionalAttrString(PyObject arg0, @Cast("const char*") BytePointer arg1, @Cast("PyObject**") PointerPointer arg2);
@NoException public static native int PyObject_GetOptionalAttrString(PyObject arg0, @Cast("const char*") BytePointer arg1, @ByPtrPtr PyObject arg2);
@NoException public static native int PyObject_GetOptionalAttrString(PyObject arg0, String arg1, @ByPtrPtr PyObject arg2);
// #endif
@NoException public static native int PyObject_SetAttr(PyObject arg0, PyObject arg1, PyObject arg2);
@NoException public static native int PyObject_DelAttr(PyObject v, PyObject name);
@NoException public static native int PyObject_HasAttr(PyObject arg0, PyObject arg1);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000
@NoException public static native int PyObject_HasAttrWithError(PyObject arg0, PyObject arg1);
@NoException public static native int PyObject_HasAttrStringWithError(PyObject arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native int PyObject_HasAttrStringWithError(PyObject arg0, String arg1);
// #endif
@NoException public static native PyObject PyObject_SelfIter(PyObject arg0);
@NoException public static native PyObject PyObject_GenericGetAttr(PyObject arg0, PyObject arg1);
@NoException public static native int PyObject_GenericSetAttr(PyObject arg0, PyObject arg1, PyObject arg2);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native int PyObject_GenericSetDict(PyObject arg0, PyObject arg1, Pointer arg2);
// #endif
@NoException public static native @Cast("Py_hash_t") long PyObject_Hash(PyObject arg0);
@NoException public static native @Cast("Py_hash_t") long PyObject_HashNotImplemented(PyObject arg0);
@NoException public static native int PyObject_IsTrue(PyObject arg0);
@NoException public static native int PyObject_Not(PyObject arg0);
@NoException public static native int PyCallable_Check(PyObject arg0);
@NoException public static native void PyObject_ClearWeakRefs(PyObject arg0);

/* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a
   list of strings.  PyObject_Dir(NULL) is like builtins.dir(),
   returning the names of the current locals.  In this case, if there are
   no current locals, NULL is returned, and PyErr_Occurred() is false.
*/
@NoException public static native PyObject PyObject_Dir(PyObject arg0);

/* Helpers for printing recursive container types */
@NoException public static native int Py_ReprEnter(PyObject arg0);
@NoException public static native void Py_ReprLeave(PyObject arg0);

/* Flag bits for printing: */
public static final int Py_PRINT_RAW =    1;       /* No string quotes etc. */

/*
Type flags (tp_flags)

These flags are used to change expected features and behavior for a
particular type.

Arbitration of the flag bit positions will need to be coordinated among
all extension writers who publicly release their extensions (this will
be fewer than you might expect!).

Most flags were removed as of Python 3.0 to make room for new flags.  (Some
flags are not for backwards compatibility but to indicate the presence of an
optional feature; these flags remain of course.)

Type definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.

Code can use PyType_HasFeature(type_ob, flag_value) to test whether the
given type object has a specified feature.
*/

// #ifndef Py_LIMITED_API

/* Track types initialized using _PyStaticType_InitBuiltin(). */
public static final int _Py_TPFLAGS_STATIC_BUILTIN = (1 << 1);

/* The values array is placed inline directly after the rest of
 * the object. Implies Py_TPFLAGS_HAVE_GC.
 */
public static final int Py_TPFLAGS_INLINE_VALUES = (1 << 2);

/* Placement of weakref pointers are managed by the VM, not by the type.
 * The VM will automatically set tp_weaklistoffset.
 */
public static final int Py_TPFLAGS_MANAGED_WEAKREF = (1 << 3);

/* Placement of dict (and values) pointers are managed by the VM, not by the type.
 * The VM will automatically set tp_dictoffset. Implies Py_TPFLAGS_HAVE_GC.
 */
public static final int Py_TPFLAGS_MANAGED_DICT = (1 << 4);

public static final int Py_TPFLAGS_PREHEADER = (Py_TPFLAGS_MANAGED_WEAKREF | Py_TPFLAGS_MANAGED_DICT);

/* Set if instances of the type object are treated as sequences for pattern matching */
public static final int Py_TPFLAGS_SEQUENCE = (1 << 5);
/* Set if instances of the type object are treated as mappings for pattern matching */
public static final int Py_TPFLAGS_MAPPING = (1 << 6);
// #endif

/* Disallow creating instances of the type: set tp_new to NULL and don't create
 * the "__new__" key in the type dictionary. */
public static final long Py_TPFLAGS_DISALLOW_INSTANTIATION = (1L << 7);

/* Set if the type object is immutable: type attributes cannot be set nor deleted */
public static final long Py_TPFLAGS_IMMUTABLETYPE = (1L << 8);

/* Set if the type object is dynamically allocated */
public static final long Py_TPFLAGS_HEAPTYPE = (1L << 9);

/* Set if the type allows subclassing */
public static final long Py_TPFLAGS_BASETYPE = (1L << 10);

/* Set if the type implements the vectorcall protocol (PEP 590) */
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000
public static final long Py_TPFLAGS_HAVE_VECTORCALL = (1L << 11);
// #ifndef Py_LIMITED_API
// Backwards compatibility alias for API that was provisional in Python 3.8
public static final long _Py_TPFLAGS_HAVE_VECTORCALL = Py_TPFLAGS_HAVE_VECTORCALL;
// #endif
// #endif

/* Set if the type is 'ready' -- fully initialized */
public static final long Py_TPFLAGS_READY = (1L << 12);

/* Set while the type is being 'readied', to prevent recursive ready calls */
public static final long Py_TPFLAGS_READYING = (1L << 13);

/* Objects support garbage collection (see objimpl.h) */
public static final long Py_TPFLAGS_HAVE_GC = (1L << 14);

/* These two bits are preserved for Stackless Python, next after this is 17 */
// #ifdef STACKLESS
public static final long Py_TPFLAGS_HAVE_STACKLESS_EXTENSION = (3L << 15);
// #else
// #endif

/* Objects behave like an unbound method */
public static final long Py_TPFLAGS_METHOD_DESCRIPTOR = (1L << 17);

/* Unused. Legacy flag */
public static final long Py_TPFLAGS_VALID_VERSION_TAG =  (1L << 19);

/* Type is abstract and cannot be instantiated */
public static final long Py_TPFLAGS_IS_ABSTRACT = (1L << 20);

// This undocumented flag gives certain built-ins their unique pattern-matching
// behavior, which allows a single positional subpattern to match against the
// subject itself (rather than a mapped attribute on it):
public static final long _Py_TPFLAGS_MATCH_SELF = (1L << 22);

/* Items (ob_size*tp_itemsize) are found at the end of an instance's memory */
public static final long Py_TPFLAGS_ITEMS_AT_END = (1L << 23);

/* These flags are used to determine if a type is a subclass. */
public static final long Py_TPFLAGS_LONG_SUBCLASS =        (1L << 24);
public static final long Py_TPFLAGS_LIST_SUBCLASS =        (1L << 25);
public static final long Py_TPFLAGS_TUPLE_SUBCLASS =       (1L << 26);
public static final long Py_TPFLAGS_BYTES_SUBCLASS =       (1L << 27);
public static final long Py_TPFLAGS_UNICODE_SUBCLASS =     (1L << 28);
public static final long Py_TPFLAGS_DICT_SUBCLASS =        (1L << 29);
public static final long Py_TPFLAGS_BASE_EXC_SUBCLASS =    (1L << 30);
public static final long Py_TPFLAGS_TYPE_SUBCLASS =        (1L << 31);

public static final long Py_TPFLAGS_DEFAULT =  ( 
                 Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | 
                0);

/* NOTE: Some of the following flags reuse lower bits (removed as part of the
 * Python 3.0 transition). */

/* The following flags are kept for compatibility; in previous
 * versions they indicated presence of newer tp_* fields on the
 * type struct.
 * Starting with 3.8, binary compatibility of C extensions across
 * feature releases of Python is not supported anymore (except when
 * using the stable ABI, in which all classes are created dynamically,
 * using the interpreter's memory layout.)
 * Note that older extensions using the stable ABI set these flags,
 * so the bits must not be repurposed.
 */
public static final long Py_TPFLAGS_HAVE_FINALIZE = (1L << 0);
public static final long Py_TPFLAGS_HAVE_VERSION_TAG =   (1L << 18);


public static final int Py_CONSTANT_NONE = 0;
public static final int Py_CONSTANT_FALSE = 1;
public static final int Py_CONSTANT_TRUE = 2;
public static final int Py_CONSTANT_ELLIPSIS = 3;
public static final int Py_CONSTANT_NOT_IMPLEMENTED = 4;
public static final int Py_CONSTANT_ZERO = 5;
public static final int Py_CONSTANT_ONE = 6;
public static final int Py_CONSTANT_EMPTY_STR = 7;
public static final int Py_CONSTANT_EMPTY_BYTES = 8;
public static final int Py_CONSTANT_EMPTY_TUPLE = 9;

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000
@NoException public static native PyObject Py_GetConstant(@Cast("unsigned int") int constant_id);
@NoException public static native PyObject Py_GetConstantBorrowed(@Cast("unsigned int") int constant_id);
// #endif


/*
_Py_NoneStruct is an object of undefined type which can be used in contexts
where NULL (nil) is not suitable (since NULL often means 'error').
*/
public static native @ByRef PyObject _Py_NoneStruct(); public static native void _Py_NoneStruct(PyObject setter); /* Don't use this directly */

// #if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030D0000
// #  define Py_None Py_GetConstantBorrowed(Py_CONSTANT_NONE)
// #else
// #  define Py_None (&_Py_NoneStruct)
// #endif

// Test if an object is the None singleton, the same as "x is None" in Python.
@NoException public static native int Py_IsNone(PyObject x);
// #define Py_IsNone(x) Py_Is((x), Py_None)

/* Macro for returning Py_None from a function.
 * Only treat Py_None as immortal in the limited C API 3.12 and newer. */
// #if defined(Py_LIMITED_API) && Py_LIMITED_API+0 < 0x030c0000
// #  define Py_RETURN_NONE return Py_NewRef(Py_None)
// #else
// #  define Py_RETURN_NONE return Py_None
// #endif

/*
Py_NotImplemented is a singleton used to signal that an operation is
not implemented for a given type combination.
*/
public static native @ByRef PyObject _Py_NotImplementedStruct(); public static native void _Py_NotImplementedStruct(PyObject setter); /* Don't use this directly */

// #if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030D0000
// #  define Py_NotImplemented Py_GetConstantBorrowed(Py_CONSTANT_NOT_IMPLEMENTED)
// #else
// #  define Py_NotImplemented (&_Py_NotImplementedStruct)
// #endif

/* Macro for returning Py_NotImplemented from a function. Only treat
 * Py_NotImplemented as immortal in the limited C API 3.12 and newer. */
// #if defined(Py_LIMITED_API) && Py_LIMITED_API+0 < 0x030c0000
// #  define Py_RETURN_NOTIMPLEMENTED return Py_NewRef(Py_NotImplemented)
// #else
// #  define Py_RETURN_NOTIMPLEMENTED return Py_NotImplemented
// #endif

/* Rich comparison opcodes */
public static final int Py_LT = 0;
public static final int Py_LE = 1;
public static final int Py_EQ = 2;
public static final int Py_NE = 3;
public static final int Py_GT = 4;
public static final int Py_GE = 5;

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
/* Result of calling PyIter_Send */
/** enum PySendResult */
public static final int
    PYGEN_RETURN = 0,
    PYGEN_ERROR = -1,
    PYGEN_NEXT = 1;
// #endif

/*
 * Macro for implementing rich comparisons
 *
 * Needs to be a macro because any C-comparable type can be used.
 */
// #define Py_RETURN_RICHCOMPARE(val1, val2, op)
//     do {
//         switch (op) {
//         case Py_EQ: if ((val1) == (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;
//         case Py_NE: if ((val1) != (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;
//         case Py_LT: if ((val1) < (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;
//         case Py_GT: if ((val1) > (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;
//         case Py_LE: if ((val1) <= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;
//         case Py_GE: if ((val1) >= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;
//         default:
//             Py_UNREACHABLE();
//         }
//     } while (0)


/*
More conventions
================

Argument Checking
-----------------

Functions that take objects as arguments normally don't check for nil
arguments, but they do check the type of the argument, and return an
error if the function doesn't apply to the type.

Failure Modes
-------------

Functions may fail for a variety of reasons, including running out of
memory.  This is communicated to the caller in two ways: an error string
is set (see errors.h), and the function result differs: functions that
normally return a pointer return NULL for failure, functions returning
an integer return -1 (which could be a legal return value too!), and
other functions return 0 for success and -1 for failure.
Callers should always check for errors before using the result.  If
an error was set, the caller must either explicitly clear it, or pass
the error on to its caller.

Reference Counts
----------------

It takes a while to get used to the proper usage of reference counts.

Functions that create an object set the reference count to 1; such new
objects must be stored somewhere or destroyed again with Py_DECREF().
Some functions that 'store' objects, such as PyTuple_SetItem() and
PyList_SetItem(),
don't increment the reference count of the object, since the most
frequent use is to store a fresh object.  Functions that 'retrieve'
objects, such as PyTuple_GetItem() and PyDict_GetItemString(), also
don't increment
the reference count, since most frequently the object is only looked at
quickly.  Thus, to retrieve an object and store it again, the caller
must call Py_INCREF() explicitly.

NOTE: functions that 'consume' a reference count, like
PyList_SetItem(), consume the reference even if the object wasn't
successfully stored, to simplify error handling.

It seems attractive to make other functions that take an object as
argument consume a reference count; however, this may quickly get
confusing (even the current practice is already confusing).  Consider
it carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at
times.
*/

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_OBJECT_H
// #  include "cpython/object.h"
// #  undef Py_CPYTHON_OBJECT_H
// #endif


@NoException public static native int PyType_HasFeature(PyTypeObject type, @Cast("unsigned long") long feature);

// #define PyType_FastSubclass(type, flag) PyType_HasFeature((type), (flag))

@NoException public static native int PyType_Check(PyObject op);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000
// #endif

// #define _PyType_CAST(op)
//     (assert(PyType_Check(op)), _Py_CAST(PyTypeObject*, (op)))

@NoException public static native int PyType_CheckExact(PyObject op);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 < 0x030b0000
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000
@NoException public static native PyObject PyType_GetModuleByDef(PyTypeObject arg0, PyModuleDef arg1);
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030e0000
@NoException public static native int PyType_Freeze(PyTypeObject type);
// #endif

// #ifdef __cplusplus
// #endif
// #endif   // !Py_OBJECT_H


// Parsed from cpython/object.h

// #ifndef Py_CPYTHON_OBJECT_H
// #  error "this header file must not be included directly"
// #endif

@NoException public static native void _Py_NewReference(PyObject op);
@NoException public static native void _Py_NewReferenceNoTotal(PyObject op);
@NoException public static native void _Py_ResurrectReference(PyObject op);
@NoException public static native void _Py_ForgetReference(PyObject op);
// Targeting ../_Py_Identifier.java



// #ifndef Py_BUILD_CORE
// For now we are keeping _Py_IDENTIFIER for continued use
// in non-builtin extensions (and naughty PyPI modules).

// #define _Py_static_string_init(value) { .string = (value), .index = -1 }
// #define _Py_static_string(varname, value)  static _Py_Identifier varname = _Py_static_string_init(value)
// #define _Py_IDENTIFIER(varname) _Py_static_string(PyId_##varname, #varname)
// Targeting ../PyNumberMethods.java


// Targeting ../PySequenceMethods.java


// Targeting ../PyMappingMethods.java


// Targeting ../sendfunc.java


// Targeting ../PyAsyncMethods.java


// Targeting ../PyBufferProcs.java



/* Allow printfunc in the tp_vectorcall_offset slot for
 * backwards-compatibility */
// Targeting ../PyTypeObject.java



public static final int _Py_ATTR_CACHE_UNUSED = (30000);
// Targeting ../_specialization_cache.java


// Targeting ../PyHeapTypeObject.java



@NoException public static native @Cast("const char*") BytePointer _PyType_Name(PyTypeObject arg0);
@NoException public static native PyObject _PyType_Lookup(PyTypeObject arg0, PyObject arg1);
@NoException public static native PyObject _PyType_LookupRef(PyTypeObject arg0, PyObject arg1);
@NoException public static native PyObject PyType_GetDict(PyTypeObject arg0);

@NoException public static native int PyObject_Print(PyObject arg0, @Cast("FILE*") Pointer arg1, int arg2);
@NoException public static native void _Py_BreakPoint();
@NoException public static native void _PyObject_Dump(PyObject arg0);

@NoException public static native PyObject _PyObject_GetAttrId(PyObject arg0, _Py_Identifier arg1);

@NoException public static native @Cast("PyObject**") PointerPointer _PyObject_GetDictPtr(PyObject arg0);
@NoException public static native void PyObject_CallFinalizer(PyObject arg0);
@NoException public static native int PyObject_CallFinalizerFromDealloc(PyObject arg0);

@NoException public static native void PyUnstable_Object_ClearWeakRefsNoCallbacks(PyObject arg0);

/* Same as PyObject_Generic{Get,Set}Attr, but passing the attributes
   dict as the last parameter. */
@NoException public static native PyObject _PyObject_GenericGetAttrWithDict(PyObject arg0, PyObject arg1, PyObject arg2, int arg3);
@NoException public static native int _PyObject_GenericSetAttrWithDict(PyObject arg0, PyObject arg1,
                                 PyObject arg2, PyObject arg3);

@NoException public static native PyObject _PyObject_FunctionStr(PyObject arg0);

/* Safely decref `dst` and set `dst` to `src`.
 *
 * As in case of Py_CLEAR "the obvious" code can be deadly:
 *
 *     Py_DECREF(dst);
 *     dst = src;
 *
 * The safe way is:
 *
 *      Py_SETREF(dst, src);
 *
 * That arranges to set `dst` to `src` _before_ decref'ing, so that any code
 * triggered as a side-effect of `dst` getting torn down no longer believes
 * `dst` points to a valid object.
 *
 * Temporary variables are used to only evaluate macro arguments once and so
 * avoid the duplication of side effects. _Py_TYPEOF() or memcpy() is used to
 * avoid a miscompilation caused by type punning. See Py_CLEAR() comment for
 * implementation details about type punning.
 *
 * The memcpy() implementation does not emit a compiler warning if 'src' has
 * not the same type than 'src': any pointer type is accepted for 'src'.
 */
// #ifdef _Py_TYPEOF
// #else
// #define Py_SETREF(dst, src)
//     do {
//         PyObject **_tmp_dst_ptr = _Py_CAST(PyObject**, &(dst));
//         PyObject *_tmp_old_dst = (*_tmp_dst_ptr);
//         PyObject *_tmp_src = _PyObject_CAST(src);
//         memcpy(_tmp_dst_ptr, &_tmp_src, sizeof(PyObject*));
//         Py_DECREF(_tmp_old_dst);
//     } while (0)
// #endif

/* Py_XSETREF() is a variant of Py_SETREF() that uses Py_XDECREF() instead of
 * Py_DECREF().
 */
// #ifdef _Py_TYPEOF
// #else
// #define Py_XSETREF(dst, src)
//     do {
//         PyObject **_tmp_dst_ptr = _Py_CAST(PyObject**, &(dst));
//         PyObject *_tmp_old_dst = (*_tmp_dst_ptr);
//         PyObject *_tmp_src = _PyObject_CAST(src);
//         memcpy(_tmp_dst_ptr, &_tmp_src, sizeof(PyObject*));
//         Py_XDECREF(_tmp_old_dst);
//     } while (0)
// #endif


/* Define a pair of assertion macros:
   _PyObject_ASSERT_FROM(), _PyObject_ASSERT_WITH_MSG() and _PyObject_ASSERT().

   These work like the regular C assert(), in that they will abort the
   process with a message on stderr if the given condition fails to hold,
   but compile away to nothing if NDEBUG is defined.

   However, before aborting, Python will also try to call _PyObject_Dump() on
   the given object.  This may be of use when investigating bugs in which a
   particular object is corrupt (e.g. buggy a tp_visit method in an extension
   module breaking the garbage collector), to help locate the broken objects.

   The WITH_MSG variant allows you to supply an additional message that Python
   will attempt to print to stderr, after the object dump. */
// #ifdef NDEBUG
   /* No debugging: compile away the assertions: */
// #  define _PyObject_ASSERT_FROM(obj, expr, msg, filename, lineno, func)
//     ((void)0)
// #else
   /* With debugging: generate checks: */
// #  define _PyObject_ASSERT_FROM(obj, expr, msg, filename, lineno, func)
//     ((expr)
//       ? (void)(0)
//       : _PyObject_AssertFailed((obj), Py_STRINGIFY(expr),
//                                (msg), (filename), (lineno), (func)))
// #endif

// #define _PyObject_ASSERT_WITH_MSG(obj, expr, msg)
//     _PyObject_ASSERT_FROM((obj), expr, (msg), __FILE__, __LINE__, __func__)
// #define _PyObject_ASSERT(obj, expr)
//     _PyObject_ASSERT_WITH_MSG((obj), expr, NULL)

// #define _PyObject_ASSERT_FAILED_MSG(obj, msg)
//     _PyObject_AssertFailed((obj), NULL, (msg), __FILE__, __LINE__, __func__)

/* Declare and define _PyObject_AssertFailed() even when NDEBUG is defined,
   to avoid causing compiler/linker errors when building extensions without
   NDEBUG against a Python built with NDEBUG defined.

   msg, expr and function can be NULL. */
@NoException public static native void _PyObject_AssertFailed(
    PyObject obj,
    @Cast("const char*") BytePointer expr,
    @Cast("const char*") BytePointer msg,
    @Cast("const char*") BytePointer file,
    int line,
    @Cast("const char*") BytePointer function);
@NoException public static native void _PyObject_AssertFailed(
    PyObject obj,
    String expr,
    String msg,
    String file,
    int line,
    String function);


@NoException public static native void _PyTrash_thread_deposit_object(PyThreadState tstate, PyObject op);
@NoException public static native void _PyTrash_thread_destroy_chain(PyThreadState tstate);

@NoException public static native int _Py_ReachedRecursionLimitWithMargin(PyThreadState tstate, int margin_count);

/* For backwards compatibility with the old trashcan mechanism */
// #define Py_TRASHCAN_BEGIN(op, dealloc)
// #define Py_TRASHCAN_END


@NoException public static native Pointer PyObject_GetItemData(PyObject obj);

@NoException public static native int PyObject_VisitManagedDict(PyObject obj, visitproc visit, Pointer arg);
@NoException public static native int _PyObject_SetManagedDict(PyObject obj, PyObject new_dict);
@NoException public static native void PyObject_ClearManagedDict(PyObject obj);
// Targeting ../PyType_WatchCallback.java


@NoException public static native int PyType_AddWatcher(PyType_WatchCallback callback);
@NoException public static native int PyType_ClearWatcher(int watcher_id);
@NoException public static native int PyType_Watch(int watcher_id, PyObject type);
@NoException public static native int PyType_Unwatch(int watcher_id, PyObject type);

/* Attempt to assign a version tag to the given type.
 *
 * Returns 1 if the type already had a valid version tag or a new one was
 * assigned, or 0 if a new tag could not be assigned.
 */
@NoException public static native int PyUnstable_Type_AssignVersionTag(PyTypeObject type);


/** enum PyRefTracerEvent */
public static final int
    PyRefTracer_CREATE = 0,
    PyRefTracer_DESTROY = 1;
// Targeting ../PyRefTracer.java


@NoException public static native int PyRefTracer_SetTracer(PyRefTracer tracer, Pointer data);
@NoException public static native PyRefTracer PyRefTracer_GetTracer(@Cast("void**") PointerPointer arg0);
@NoException public static native PyRefTracer PyRefTracer_GetTracer(@Cast("void**") @ByPtrPtr Pointer arg0);

/* Enable PEP-703 deferred reference counting on the object.
 *
 * Returns 1 if deferred reference counting was successfully enabled, and
 * 0 if the runtime ignored it. This function cannot fail.
 */
@NoException public static native int PyUnstable_Object_EnableDeferredRefcount(PyObject arg0);

/* Determine if the object exists as a unique temporary variable on the
 * topmost frame of the interpreter.
 */
@NoException public static native int PyUnstable_Object_IsUniqueReferencedTemporary(PyObject arg0);

/* Check whether the object is immortal. This cannot fail. */
@NoException public static native int PyUnstable_IsImmortal(PyObject arg0);

// Increments the reference count of the object, if it's not zero.
// PyUnstable_EnableTryIncRef() should be called on the object
// before calling this function in order to avoid spurious failures.
@NoException public static native int PyUnstable_TryIncRef(PyObject arg0);
@NoException public static native void PyUnstable_EnableTryIncRef(PyObject arg0);

@NoException public static native int PyUnstable_Object_IsUniquelyReferenced(PyObject arg0);


// Parsed from objimpl.h

// The PyObject_ memory family:  high-level object memory interfaces.
// See pymem.h for the low-level PyMem_ family.

// #ifndef Py_OBJIMPL_H
// #define Py_OBJIMPL_H
// #ifdef __cplusplus
// #endif

/* BEWARE:

   Each interface exports both functions and macros.  Extension modules should
   use the functions, to ensure binary compatibility across Python versions.
   Because the Python implementation is free to change internal details, and
   the macros may (or may not) expose details for speed, if you do use the
   macros you must recompile your extensions with each Python release.

   Never mix calls to PyObject_ memory functions with calls to the platform
   malloc/realloc/ calloc/free, or with calls to PyMem_.
*/

/*
Functions and macros for modules that implement new object types.

 - PyObject_New(type, typeobj) allocates memory for a new object of the given
   type, and initializes part of it.  'type' must be the C structure type used
   to represent the object, and 'typeobj' the address of the corresponding
   type object.  Reference count and type pointer are filled in; the rest of
   the bytes of the object are *undefined*!  The resulting expression type is
   'type *'.  The size of the object is determined by the tp_basicsize field
   of the type object.

 - PyObject_NewVar(type, typeobj, n) is similar but allocates a variable-size
   object with room for n items.  In addition to the refcount and type pointer
   fields, this also fills in the ob_size field.

 - PyObject_Free(op) releases the memory allocated for an object.  It does not
   run a destructor -- it only frees the memory.

 - PyObject_Init(op, typeobj) and PyObject_InitVar(op, typeobj, n) don't
   allocate memory.  Instead of a 'type' parameter, they take a pointer to a
   new object (allocated by an arbitrary allocator), and initialize its object
   header fields.

Note that objects created with PyObject_{New, NewVar} are allocated using the
specialized Python allocator (implemented in obmalloc.c), if WITH_PYMALLOC is
enabled.  In addition, a special debugging allocator is used if Py_DEBUG
macro is also defined.

In case a specific form of memory management is needed (for example, if you
must use the platform malloc heap(s), or shared memory, or C++ local storage or
operator new), you must first allocate the object with your custom allocator,
then pass its pointer to PyObject_{Init, InitVar} for filling in its Python-
specific fields:  reference count, type pointer, possibly others.  You should
be aware that Python has no control over these objects because they don't
cooperate with the Python memory manager.  Such objects may not be eligible
for automatic garbage collection and you have to make sure that they are
released accordingly whenever their destructor gets called (cf. the specific
form of memory management you're using).

Unless you have specific memory management requirements, use
PyObject_{New, NewVar, Del}.
*/

/*
 * Raw object memory interface
 * ===========================
 */

/* Functions to call the same malloc/realloc/free as used by Python's
   object allocator.  If WITH_PYMALLOC is enabled, these may differ from
   the platform malloc/realloc/free.  The Python object allocator is
   designed for fast, cache-conscious allocation of many "small" objects,
   and with low hidden memory overhead.

   PyObject_Malloc(0) returns a unique non-NULL pointer if possible.

   PyObject_Realloc(NULL, n) acts like PyObject_Malloc(n).
   PyObject_Realloc(p != NULL, 0) does not return  NULL, or free the memory
   at p.

   Returned pointers must be checked for NULL explicitly; no action is
   performed on failure other than to return NULL (no warning it printed, no
   exception is set, etc).

   For allocating objects, use PyObject_{New, NewVar} instead whenever
   possible.  The PyObject_{Malloc, Realloc, Free} family is exposed
   so that you can exploit Python's small-block allocator for non-object
   uses.  If you must use these routines to allocate object memory, make sure
   the object gets initialized via PyObject_{Init, InitVar} after obtaining
   the raw memory.
*/
@NoException public static native Pointer PyObject_Malloc(@Cast("size_t") long size);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
@NoException public static native Pointer PyObject_Calloc(@Cast("size_t") long nelem, @Cast("size_t") long elsize);
// #endif
@NoException public static native Pointer PyObject_Realloc(Pointer ptr, @Cast("size_t") long new_size);
@NoException public static native void PyObject_Free(Pointer ptr);


// Deprecated aliases only kept for backward compatibility.
// PyObject_Del and PyObject_DEL are defined with no parameter to be able to
// use them as function pointers (ex: tp_free = PyObject_Del).
// #define PyObject_MALLOC         PyObject_Malloc
// #define PyObject_REALLOC        PyObject_Realloc
// #define PyObject_FREE           PyObject_Free
// #define PyObject_Del            PyObject_Free
// #define PyObject_DEL            PyObject_Free


/*
 * Generic object allocator interface
 * ==================================
 */

/* Functions */
@NoException public static native PyObject PyObject_Init(PyObject arg0, PyTypeObject arg1);
@NoException public static native PyVarObject PyObject_InitVar(PyVarObject arg0,
                                           PyTypeObject arg1, @Cast("Py_ssize_t") long arg2);

// #define PyObject_INIT(op, typeobj)
//     PyObject_Init(_PyObject_CAST(op), (typeobj))
// #define PyObject_INIT_VAR(op, typeobj, size)
//     PyObject_InitVar(_PyVarObject_CAST(op), (typeobj), (size))


@NoException public static native PyObject _PyObject_New(PyTypeObject arg0);
@NoException public static native PyVarObject _PyObject_NewVar(PyTypeObject arg0, @Cast("Py_ssize_t") long arg1);

// #define PyObject_New(type, typeobj) ((type *)_PyObject_New(typeobj))

// Alias to PyObject_New(). In Python 3.8, PyObject_NEW() called directly
// PyObject_MALLOC() with _PyObject_SIZE().
// #define PyObject_NEW(type, typeobj) PyObject_New(type, (typeobj))

// #define PyObject_NewVar(type, typeobj, n)
//                 ( (type *) _PyObject_NewVar((typeobj), (n)) )

// Alias to PyObject_NewVar(). In Python 3.8, PyObject_NEW_VAR() called
// directly PyObject_MALLOC() with _PyObject_VAR_SIZE().
// #define PyObject_NEW_VAR(type, typeobj, n) PyObject_NewVar(type, (typeobj), (n))


/*
 * Garbage Collection Support
 * ==========================
 */

/* C equivalent of gc.collect(). */
@NoException public static native @Cast("Py_ssize_t") long PyGC_Collect();
/* C API for controlling the state of the garbage collector */
@NoException public static native int PyGC_Enable();
@NoException public static native int PyGC_Disable();
@NoException public static native int PyGC_IsEnabled();

/* Test if a type has a GC head */
// #define PyType_IS_GC(t) PyType_HasFeature((t), Py_TPFLAGS_HAVE_GC)

@NoException public static native PyVarObject _PyObject_GC_Resize(PyVarObject arg0, @Cast("Py_ssize_t") long arg1);
// #define PyObject_GC_Resize(type, op, n)
//                 ( (type *) _PyObject_GC_Resize(_PyVarObject_CAST(op), (n)) )



@NoException public static native PyObject _PyObject_GC_New(PyTypeObject arg0);
@NoException public static native PyVarObject _PyObject_GC_NewVar(PyTypeObject arg0, @Cast("Py_ssize_t") long arg1);

/* Tell the GC to track this object.
 *
 * See also private _PyObject_GC_TRACK() macro. */
@NoException public static native void PyObject_GC_Track(Pointer arg0);

/* Tell the GC to stop tracking this object.
 *
 * See also private _PyObject_GC_UNTRACK() macro. */
@NoException public static native void PyObject_GC_UnTrack(Pointer arg0);

@NoException public static native void PyObject_GC_Del(Pointer arg0);

// #define PyObject_GC_New(type, typeobj)
//     _Py_CAST(type*, _PyObject_GC_New(typeobj))
// #define PyObject_GC_NewVar(type, typeobj, n)
//     _Py_CAST(type*, _PyObject_GC_NewVar((typeobj), (n)))

@NoException public static native int PyObject_GC_IsTracked(PyObject arg0);
@NoException public static native int PyObject_GC_IsFinalized(PyObject arg0);

/* Utility macro to help write tp_traverse functions.
 * To use this macro, the tp_traverse function must name its arguments
 * "visit" and "arg".  This is intended to keep tp_traverse functions
 * looking as much alike as possible.
 */
// #define Py_VISIT(op)
//     do {
//         if (op) {
//             int vret = visit(_PyObject_CAST(op), arg);
//             if (vret)
//                 return vret;
//         }
//     } while (0)

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_OBJIMPL_H
// #  include "cpython/objimpl.h"
// #  undef Py_CPYTHON_OBJIMPL_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif   // !Py_OBJIMPL_H


// Parsed from cpython/objimpl.h

// #ifndef Py_CPYTHON_OBJIMPL_H
// #  error "this header file must not be included directly"
// #endif

@NoException public static native @Cast("size_t") long _PyObject_SIZE(PyTypeObject type);

/* _PyObject_VAR_SIZE returns the number of bytes (as size_t) allocated for a
   vrbl-size object with nitems items, exclusive of gc overhead (if any).  The
   value is rounded up to the closest multiple of sizeof(void *), in order to
   ensure that pointer fields at the end of the object are correctly aligned
   for the platform (this is of special importance for subclasses of, e.g.,
   str or int, so that pointers can be stored after the embedded data).

   Note that there's no memory wastage in doing this, as malloc has to
   return (at worst) pointer-aligned memory anyway.
*/
// #if ((SIZEOF_VOID_P - 1) & SIZEOF_VOID_P) != 0
// #   error "_PyObject_VAR_SIZE requires SIZEOF_VOID_P be a power of 2"
// #endif

@NoException public static native @Cast("size_t") long _PyObject_VAR_SIZE(PyTypeObject type, @Cast("Py_ssize_t") long nitems);
// Targeting ../PyObjectArenaAllocator.java



/* Get the arena allocator. */
@NoException public static native void PyObject_GetArenaAllocator(PyObjectArenaAllocator allocator);

/* Set the arena allocator. */
@NoException public static native void PyObject_SetArenaAllocator(PyObjectArenaAllocator allocator);


/* Test if an object implements the garbage collector protocol */
@NoException public static native int PyObject_IS_GC(PyObject obj);


// Test if a type supports weak references
@NoException public static native int PyType_SUPPORTS_WEAKREFS(PyTypeObject type);

@NoException public static native @Cast("PyObject**") PointerPointer PyObject_GET_WEAKREFS_LISTPTR(PyObject op);

@NoException public static native PyObject PyUnstable_Object_GC_NewWithExtraData(PyTypeObject arg0,
                                                             @Cast("size_t") long arg1);
// Targeting ../gcvisitobjects_t.java


@NoException public static native void PyUnstable_GC_VisitObjects(gcvisitobjects_t callback, Pointer arg);


// Parsed from typeslots.h

/* Do not renumber the file; these numbers are part of the stable ABI. */
public static final int Py_bf_getbuffer = 1;
public static final int Py_bf_releasebuffer = 2;
public static final int Py_mp_ass_subscript = 3;
public static final int Py_mp_length = 4;
public static final int Py_mp_subscript = 5;
public static final int Py_nb_absolute = 6;
public static final int Py_nb_add = 7;
public static final int Py_nb_and = 8;
public static final int Py_nb_bool = 9;
public static final int Py_nb_divmod = 10;
public static final int Py_nb_float = 11;
public static final int Py_nb_floor_divide = 12;
public static final int Py_nb_index = 13;
public static final int Py_nb_inplace_add = 14;
public static final int Py_nb_inplace_and = 15;
public static final int Py_nb_inplace_floor_divide = 16;
public static final int Py_nb_inplace_lshift = 17;
public static final int Py_nb_inplace_multiply = 18;
public static final int Py_nb_inplace_or = 19;
public static final int Py_nb_inplace_power = 20;
public static final int Py_nb_inplace_remainder = 21;
public static final int Py_nb_inplace_rshift = 22;
public static final int Py_nb_inplace_subtract = 23;
public static final int Py_nb_inplace_true_divide = 24;
public static final int Py_nb_inplace_xor = 25;
public static final int Py_nb_int = 26;
public static final int Py_nb_invert = 27;
public static final int Py_nb_lshift = 28;
public static final int Py_nb_multiply = 29;
public static final int Py_nb_negative = 30;
public static final int Py_nb_or = 31;
public static final int Py_nb_positive = 32;
public static final int Py_nb_power = 33;
public static final int Py_nb_remainder = 34;
public static final int Py_nb_rshift = 35;
public static final int Py_nb_subtract = 36;
public static final int Py_nb_true_divide = 37;
public static final int Py_nb_xor = 38;
public static final int Py_sq_ass_item = 39;
public static final int Py_sq_concat = 40;
public static final int Py_sq_contains = 41;
public static final int Py_sq_inplace_concat = 42;
public static final int Py_sq_inplace_repeat = 43;
public static final int Py_sq_item = 44;
public static final int Py_sq_length = 45;
public static final int Py_sq_repeat = 46;
public static final int Py_tp_alloc = 47;
public static final int Py_tp_base = 48;
public static final int Py_tp_bases = 49;
public static final int Py_tp_call = 50;
public static final int Py_tp_clear = 51;
public static final int Py_tp_dealloc = 52;
public static final int Py_tp_del = 53;
public static final int Py_tp_descr_get = 54;
public static final int Py_tp_descr_set = 55;
public static final int Py_tp_doc = 56;
public static final int Py_tp_getattr = 57;
public static final int Py_tp_getattro = 58;
public static final int Py_tp_hash = 59;
public static final int Py_tp_init = 60;
public static final int Py_tp_is_gc = 61;
public static final int Py_tp_iter = 62;
public static final int Py_tp_iternext = 63;
public static final int Py_tp_methods = 64;
public static final int Py_tp_new = 65;
public static final int Py_tp_repr = 66;
public static final int Py_tp_richcompare = 67;
public static final int Py_tp_setattr = 68;
public static final int Py_tp_setattro = 69;
public static final int Py_tp_str = 70;
public static final int Py_tp_traverse = 71;
public static final int Py_tp_members = 72;
public static final int Py_tp_getset = 73;
public static final int Py_tp_free = 74;
public static final int Py_nb_matrix_multiply = 75;
public static final int Py_nb_inplace_matrix_multiply = 76;
public static final int Py_am_await = 77;
public static final int Py_am_aiter = 78;
public static final int Py_am_anext = 79;
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* New in 3.5 */
public static final int Py_tp_finalize = 80;
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
/* New in 3.10 */
public static final int Py_am_send = 81;
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030E0000
/* New in 3.14 */
public static final int Py_tp_vectorcall = 82;
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030E0000
/* New in 3.14 */
public static final int Py_tp_token = 83;
// #endif


// Parsed from pyhash.h

// #ifndef Py_HASH_H
// #define Py_HASH_H
// #ifdef __cplusplus
// #endif

/* Cutoff for small string DJBX33A optimization in range [1, cutoff).
 *
 * About 50% of the strings in a typical Python application are smaller than
 * 6 to 7 chars. However DJBX33A is vulnerable to hash collision attacks.
 * NEVER use DJBX33A for long strings!
 *
 * A Py_HASH_CUTOFF of 0 disables small string optimization. 32 bit platforms
 * should use a smaller cutoff because it is easier to create colliding
 * strings. A cutoff of 7 on 64bit platforms and 5 on 32bit platforms should
 * provide a decent safety margin.
 */
// #ifndef Py_HASH_CUTOFF
public static final int Py_HASH_CUTOFF = 0;
// #elif (Py_HASH_CUTOFF > 7 || Py_HASH_CUTOFF < 0)
// #  error Py_HASH_CUTOFF must in range 0...7.
// #endif /* Py_HASH_CUTOFF */


/* Hash algorithm selection
 *
 * The values for Py_HASH_* are hard-coded in the
 * configure script.
 *
 * - FNV and SIPHASH* are available on all platforms and architectures.
 * - With EXTERNAL embedders can provide an alternative implementation with::
 *
 *     PyHash_FuncDef PyHash_Func = {...};
 *
 * XXX: Figure out __declspec() for extern PyHash_FuncDef.
 */
public static final int Py_HASH_EXTERNAL = 0;
public static final int Py_HASH_SIPHASH24 = 1;
public static final int Py_HASH_FNV = 2;
public static final int Py_HASH_SIPHASH13 = 3;

// #ifndef Py_HASH_ALGORITHM
// #  ifndef HAVE_ALIGNED_REQUIRED
public static final int Py_HASH_ALGORITHM = Py_HASH_SIPHASH13;
// #  else
// #  endif /* uint64_t && uint32_t && aligned */
// #endif /* Py_HASH_ALGORITHM */

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_HASH_H
// #  include "cpython/pyhash.h"
// #  undef Py_CPYTHON_HASH_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif  // !Py_HASH_H


// Parsed from cpython/pydebug.h

// #ifndef Py_LIMITED_API
// #ifndef Py_PYDEBUG_H
// #define Py_PYDEBUG_H
// #ifdef __cplusplus
// #endif

public static native @Deprecated int Py_DebugFlag(); public static native void Py_DebugFlag(int setter);
public static native @Deprecated int Py_VerboseFlag(); public static native void Py_VerboseFlag(int setter);
public static native @Deprecated int Py_QuietFlag(); public static native void Py_QuietFlag(int setter);
public static native @Deprecated int Py_InteractiveFlag(); public static native void Py_InteractiveFlag(int setter);
public static native @Deprecated int Py_InspectFlag(); public static native void Py_InspectFlag(int setter);
public static native @Deprecated int Py_OptimizeFlag(); public static native void Py_OptimizeFlag(int setter);
public static native @Deprecated int Py_NoSiteFlag(); public static native void Py_NoSiteFlag(int setter);
public static native @Deprecated int Py_BytesWarningFlag(); public static native void Py_BytesWarningFlag(int setter);
public static native @Deprecated int Py_FrozenFlag(); public static native void Py_FrozenFlag(int setter);
public static native @Deprecated int Py_IgnoreEnvironmentFlag(); public static native void Py_IgnoreEnvironmentFlag(int setter);
public static native @Deprecated int Py_DontWriteBytecodeFlag(); public static native void Py_DontWriteBytecodeFlag(int setter);
public static native @Deprecated int Py_NoUserSiteDirectory(); public static native void Py_NoUserSiteDirectory(int setter);
public static native @Deprecated int Py_UnbufferedStdioFlag(); public static native void Py_UnbufferedStdioFlag(int setter);
public static native @Deprecated int Py_HashRandomizationFlag(); public static native void Py_HashRandomizationFlag(int setter);
public static native @Deprecated int Py_IsolatedFlag(); public static native void Py_IsolatedFlag(int setter);

// #ifdef MS_WINDOWS
// #endif

/* this is a wrapper around getenv() that pays attention to
   Py_IgnoreEnvironmentFlag.  It should be used for getting variables like
   PYTHONPATH and PYTHONHOME from the environment */
@NoException public static native @Cast("char*") BytePointer Py_GETENV(@Cast("const char*") BytePointer name);
@NoException public static native @Cast("char*") ByteBuffer Py_GETENV(String name);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYDEBUG_H */
// #endif /* Py_LIMITED_API */


// Parsed from descrobject.h

/* Descriptors */
// #ifndef Py_DESCROBJECT_H
// #define Py_DESCROBJECT_H
// #ifdef __cplusplus
// Targeting ../getter.java


// Targeting ../setter.java


// Targeting ../PyGetSetDef.java



public static native @ByRef PyTypeObject PyClassMethodDescr_Type(); public static native void PyClassMethodDescr_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyGetSetDescr_Type(); public static native void PyGetSetDescr_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyMemberDescr_Type(); public static native void PyMemberDescr_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyMethodDescr_Type(); public static native void PyMethodDescr_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyWrapperDescr_Type(); public static native void PyWrapperDescr_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyDictProxy_Type(); public static native void PyDictProxy_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyProperty_Type(); public static native void PyProperty_Type(PyTypeObject setter);

@NoException public static native PyObject PyDescr_NewMethod(PyTypeObject arg0, PyMethodDef arg1);
@NoException public static native PyObject PyDescr_NewClassMethod(PyTypeObject arg0, PyMethodDef arg1);
@NoException public static native PyObject PyDescr_NewMember(PyTypeObject arg0, PyMemberDef arg1);
@NoException public static native PyObject PyDescr_NewGetSet(PyTypeObject arg0, PyGetSetDef arg1);

@NoException public static native PyObject PyDictProxy_New(PyObject arg0);
@NoException public static native PyObject PyWrapper_New(PyObject arg0, PyObject arg1);
// Targeting ../PyMemberDef.java



// These constants used to be in structmember.h, not prefixed by Py_.
// (structmember.h now has aliases to the new names.)

/* Types */
public static final int Py_T_SHORT =     0;
public static final int Py_T_INT =       1;
public static final int Py_T_LONG =      2;
public static final int Py_T_FLOAT =     3;
public static final int Py_T_DOUBLE =    4;
public static final int Py_T_STRING =    5;
public static final int _Py_T_OBJECT =   6;  // Deprecated, use Py_T_OBJECT_EX instead
/* the ordering here is weird for binary compatibility */
public static final int Py_T_CHAR =      7;   /* 1-character string */
public static final int Py_T_BYTE =      8;   /* 8-bit signed int */
/* unsigned variants: */
public static final int Py_T_UBYTE =     9;
public static final int Py_T_USHORT =    10;
public static final int Py_T_UINT =      11;
public static final int Py_T_ULONG =     12;

/* Added by Jack: strings contained in the structure */
public static final int Py_T_STRING_INPLACE =    13;

/* Added by Lillo: bools contained in the structure (assumed char) */
public static final int Py_T_BOOL =      14;

public static final int Py_T_OBJECT_EX = 16;
public static final int Py_T_LONGLONG =  17;
public static final int Py_T_ULONGLONG = 18;

public static final int Py_T_PYSSIZET =  19;      /* Py_ssize_t */
public static final int _Py_T_NONE =     20; // Deprecated. Value is always None.

/* Flags */
public static final int Py_READONLY =            1;
public static final int Py_AUDIT_READ =          2; // Added in 3.10, harmless no-op before that
public static final int _Py_WRITE_RESTRICTED =   4; // Deprecated, no-op. Do not reuse the value.
public static final int Py_RELATIVE_OFFSET =     8;

@NoException public static native PyObject PyMember_GetOne(@Cast("const char*") BytePointer arg0, PyMemberDef arg1);
@NoException public static native PyObject PyMember_GetOne(String arg0, PyMemberDef arg1);
@NoException public static native int PyMember_SetOne(@Cast("char*") BytePointer arg0, PyMemberDef arg1, PyObject arg2);
@NoException public static native int PyMember_SetOne(@Cast("char*") ByteBuffer arg0, PyMemberDef arg1, PyObject arg2);
@NoException public static native int PyMember_SetOne(@Cast("char*") byte[] arg0, PyMemberDef arg1, PyObject arg2);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_DESCROBJECT_H
// #  include "cpython/descrobject.h"
// #  undef Py_CPYTHON_DESCROBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_DESCROBJECT_H */


// Parsed from bytearrayobject.h

/* ByteArray object interface */

// #ifndef Py_BYTEARRAYOBJECT_H
// #define Py_BYTEARRAYOBJECT_H
// #ifdef __cplusplus
// #endif

/* Type PyByteArrayObject represents a mutable array of bytes.
 * The Python API is that of a sequence;
 * the bytes are mapped to ints in [0, 256).
 * Bytes are not characters; they may be used to encode characters.
 * The only way to go between bytes and str/unicode is via encoding
 * and decoding.
 * For the convenience of C programmers, the bytes type is considered
 * to contain a char pointer, not an unsigned char pointer.
 */

/* Type object */
public static native @ByRef PyTypeObject PyByteArray_Type(); public static native void PyByteArray_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyByteArrayIter_Type(); public static native void PyByteArrayIter_Type(PyTypeObject setter);

/* Type check macros */
// #define PyByteArray_Check(self) PyObject_TypeCheck((self), &PyByteArray_Type)
// #define PyByteArray_CheckExact(self) Py_IS_TYPE((self), &PyByteArray_Type)

/* Direct API functions */
@NoException public static native PyObject PyByteArray_FromObject(PyObject arg0);
@NoException public static native PyObject PyByteArray_Concat(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyByteArray_FromStringAndSize(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native PyObject PyByteArray_FromStringAndSize(String arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native @Cast("Py_ssize_t") long PyByteArray_Size(PyObject arg0);
@NoException public static native @Cast("char*") BytePointer PyByteArray_AsString(PyObject arg0);
@NoException public static native int PyByteArray_Resize(PyObject arg0, @Cast("Py_ssize_t") long arg1);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_BYTEARRAYOBJECT_H
// #  include "cpython/bytearrayobject.h"
// #  undef Py_CPYTHON_BYTEARRAYOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_BYTEARRAYOBJECT_H */


// Parsed from cpython/bytearrayobject.h

// #ifndef Py_CPYTHON_BYTEARRAYOBJECT_H
// #  error "this header file must not be included directly"
// Targeting ../PyByteArrayObject.java



public static native @Cast("char") byte _PyByteArray_empty_string(int i); public static native void _PyByteArray_empty_string(int i, byte setter);
@MemberGetter public static native @Cast("char*") BytePointer _PyByteArray_empty_string();

/* Macros and static inline functions, trading safety for speed */
// #define _PyByteArray_CAST(op)
//     (assert(PyByteArray_Check(op)), _Py_CAST(PyByteArrayObject*, op))

@NoException public static native @Cast("char*") BytePointer PyByteArray_AS_STRING(PyObject op);
// #define PyByteArray_AS_STRING(self) PyByteArray_AS_STRING(_PyObject_CAST(self))

@NoException public static native @Cast("Py_ssize_t") long PyByteArray_GET_SIZE(PyObject op);
// #define PyByteArray_GET_SIZE(self) PyByteArray_GET_SIZE(_PyObject_CAST(self))


// Parsed from bytesobject.h

// Bytes object interface

// #ifndef Py_BYTESOBJECT_H
// #define Py_BYTESOBJECT_H
// #ifdef __cplusplus
// #endif

/*
Type PyBytesObject represents a byte string.  An extra zero byte is
reserved at the end to ensure it is zero-terminated, but a size is
present so strings with null bytes in them can be represented.  This
is an immutable object type.

There are functions to create new bytes objects, to test
an object for bytes-ness, and to get the
byte string value.  The latter function returns a null pointer
if the object is not of the proper type.
There is a variant that takes an explicit size as well as a
variant that assumes a zero-terminated string.  Note that none of the
functions should be applied to NULL pointer.
*/

public static native @ByRef PyTypeObject PyBytes_Type(); public static native void PyBytes_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyBytesIter_Type(); public static native void PyBytesIter_Type(PyTypeObject setter);

// #define PyBytes_Check(op)
//                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_BYTES_SUBCLASS)
// #define PyBytes_CheckExact(op) Py_IS_TYPE((op), &PyBytes_Type)

@NoException public static native PyObject PyBytes_FromStringAndSize(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native PyObject PyBytes_FromStringAndSize(String arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native PyObject PyBytes_FromString(@Cast("const char*") BytePointer arg0);
@NoException public static native PyObject PyBytes_FromString(String arg0);
@NoException public static native PyObject PyBytes_FromObject(PyObject arg0);
@NoException public static native PyObject PyBytes_FromFormatV(@Cast("const char*") BytePointer arg0, @ByVal @Cast("va_list*") Pointer arg1);
@NoException public static native PyObject PyBytes_FromFormatV(String arg0, @ByVal @Cast("va_list*") Pointer arg1);
@NoException public static native PyObject PyBytes_FromFormat(@Cast("const char*") BytePointer arg0);
@NoException public static native PyObject PyBytes_FromFormat(String arg0);
@NoException public static native @Cast("Py_ssize_t") long PyBytes_Size(PyObject arg0);
@NoException public static native @Cast("char*") BytePointer PyBytes_AsString(PyObject arg0);
@NoException public static native PyObject PyBytes_Repr(PyObject arg0, int arg1);
@NoException public static native void PyBytes_Concat(@Cast("PyObject**") PointerPointer arg0, PyObject arg1);
@NoException public static native void PyBytes_Concat(@ByPtrPtr PyObject arg0, PyObject arg1);
@NoException public static native void PyBytes_ConcatAndDel(@Cast("PyObject**") PointerPointer arg0, PyObject arg1);
@NoException public static native void PyBytes_ConcatAndDel(@ByPtrPtr PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyBytes_DecodeEscape(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1,
                                            @Cast("const char*") BytePointer arg2, @Cast("Py_ssize_t") long arg3,
                                            @Cast("const char*") BytePointer arg4);
@NoException public static native PyObject PyBytes_DecodeEscape(String arg0, @Cast("Py_ssize_t") long arg1,
                                            String arg2, @Cast("Py_ssize_t") long arg3,
                                            String arg4);

/* Provides access to the internal data buffer and size of a bytes object.
   Passing NULL as len parameter will force the string buffer to be
   0-terminated (passing a string with embedded NUL characters will
   cause an exception).  */
@NoException public static native int PyBytes_AsStringAndSize(
    PyObject obj,
    @Cast("char**") PointerPointer s,
    @Cast("Py_ssize_t*") SizeTPointer len
    );
@NoException public static native int PyBytes_AsStringAndSize(
    PyObject obj,
    @Cast("char**") @ByPtrPtr BytePointer s,
    @Cast("Py_ssize_t*") SizeTPointer len
    );
@NoException public static native int PyBytes_AsStringAndSize(
    PyObject obj,
    @Cast("char**") @ByPtrPtr ByteBuffer s,
    @Cast("Py_ssize_t*") SizeTPointer len
    );
@NoException public static native int PyBytes_AsStringAndSize(
    PyObject obj,
    @Cast("char**") @ByPtrPtr byte[] s,
    @Cast("Py_ssize_t*") SizeTPointer len
    );

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_BYTESOBJECT_H
// #  include "cpython/bytesobject.h"
// #  undef Py_CPYTHON_BYTESOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_BYTESOBJECT_H */


// Parsed from cpython/bytesobject.h

// #ifndef Py_CPYTHON_BYTESOBJECT_H
// #  error "this header file must not be included directly"
// Targeting ../PyBytesObject.java



@NoException public static native int _PyBytes_Resize(@Cast("PyObject**") PointerPointer arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int _PyBytes_Resize(@ByPtrPtr PyObject arg0, @Cast("Py_ssize_t") long arg1);

/* Macros and static inline functions, trading safety for speed */
// #define _PyBytes_CAST(op)
//     (assert(PyBytes_Check(op)), _Py_CAST(PyBytesObject*, op))

@NoException public static native @Cast("char*") BytePointer PyBytes_AS_STRING(PyObject op);
// #define PyBytes_AS_STRING(op) PyBytes_AS_STRING(_PyObject_CAST(op))

@NoException public static native @Cast("Py_ssize_t") long PyBytes_GET_SIZE(PyObject op);
// #define PyBytes_GET_SIZE(self) PyBytes_GET_SIZE(_PyObject_CAST(self))

@NoException public static native PyObject PyBytes_Join(PyObject sep, PyObject iterable);

// Deprecated alias kept for backward compatibility
@NoException public static native @Deprecated PyObject _PyBytes_Join(PyObject sep, PyObject iterable);


// Parsed from unicodeobject.h

// #ifndef Py_UNICODEOBJECT_H
// #define Py_UNICODEOBJECT_H

/*

Unicode implementation based on original code by Fredrik Lundh,
modified by Marc-Andre Lemburg (mal@lemburg.com) according to the
Unicode Integration Proposal. (See
http://www.egenix.com/files/python/unicode-proposal.txt).

Copyright (c) Corporation for National Research Initiatives.


 Original header:
 --------------------------------------------------------------------

 * Yet another Unicode string type for Python.  This type supports the
 * 16-bit Basic Multilingual Plane (BMP) only.
 *
 * Written by Fredrik Lundh, January 1999.
 *
 * Copyright (c) 1999 by Secret Labs AB.
 * Copyright (c) 1999 by Fredrik Lundh.
 *
 * fredrik@pythonware.com
 * http://www.pythonware.com
 *
 * --------------------------------------------------------------------
 * This Unicode String Type is
 *
 * Copyright (c) 1999 by Secret Labs AB
 * Copyright (c) 1999 by Fredrik Lundh
 *
 * By obtaining, using, and/or copying this software and/or its
 * associated documentation, you agree that you have read, understood,
 * and will comply with the following terms and conditions:
 *
 * Permission to use, copy, modify, and distribute this software and its
 * associated documentation for any purpose and without fee is hereby
 * granted, provided that the above copyright notice appears in all
 * copies, and that both that copyright notice and this permission notice
 * appear in supporting documentation, and that the name of Secret Labs
 * AB or the author not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior
 * permission.
 *
 * SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * -------------------------------------------------------------------- */

/* === Internal API ======================================================= */

/* --- Internal Unicode Format -------------------------------------------- */

/* Python 3.x requires unicode */
// #define Py_USING_UNICODE

// #ifndef SIZEOF_WCHAR_T
// #endif

public static native @MemberGetter long Py_UNICODE_SIZE();
public static final long Py_UNICODE_SIZE = Py_UNICODE_SIZE();

/* If wchar_t can be used for UCS-4 storage, set Py_UNICODE_WIDE.
   Otherwise, Unicode strings are stored as UCS-2 (with limited support
   for UTF-16) */

// #if Py_UNICODE_SIZE >= 4
// #define Py_UNICODE_WIDE
// #endif

/* Set these flags if the platform has "wchar.h" and the
   wchar_t type is a 16-bit unsigned type */
/* #define HAVE_WCHAR_H */
/* #define HAVE_USABLE_WCHAR_T */

/* If the compiler provides a wchar_t type we try to support it
   through the interface functions PyUnicode_FromWideChar(),
   PyUnicode_AsWideChar() and PyUnicode_AsWideCharString(). */

// #ifdef HAVE_USABLE_WCHAR_T
// # ifndef HAVE_WCHAR_H
// # endif
// #endif

/* Py_UCS4 and Py_UCS2 are typedefs for the respective
   unicode representations. */

// #ifdef __cplusplus
// #endif


public static native @ByRef PyTypeObject PyUnicode_Type(); public static native void PyUnicode_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyUnicodeIter_Type(); public static native void PyUnicodeIter_Type(PyTypeObject setter);

// #define PyUnicode_Check(op)
//     PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_UNICODE_SUBCLASS)
// #define PyUnicode_CheckExact(op) Py_IS_TYPE((op), &PyUnicode_Type)

/* --- Constants ---------------------------------------------------------- */

/* This Unicode character will be used as replacement character during
   decoding if the errors argument is set to "replace". Note: the
   Unicode character U+FFFD is the official REPLACEMENT CHARACTER in
   Unicode 3.0. */

public static final int Py_UNICODE_REPLACEMENT_CHARACTER = ((int) 0xFFFD);

/* === Public API ========================================================= */

/* Similar to PyUnicode_FromUnicode(), but u points to UTF-8 encoded bytes */
@NoException public static native PyObject PyUnicode_FromStringAndSize(
    @Cast("const char*") BytePointer u,
    @Cast("Py_ssize_t") long size
    );
@NoException public static native PyObject PyUnicode_FromStringAndSize(
    String u,
    @Cast("Py_ssize_t") long size
    );

/* Similar to PyUnicode_FromUnicode(), but u points to null-terminated
   UTF-8 encoded bytes.  The size is determined with strlen(). */
@NoException public static native PyObject PyUnicode_FromString(
    @Cast("const char*") BytePointer u
    );
@NoException public static native PyObject PyUnicode_FromString(
    String u
    );

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyUnicode_Substring(
    PyObject str,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end);
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
/* Copy the string into a UCS4 buffer including the null character if copy_null
   is set. Return NULL and raise an exception on error. Raise a SystemError if
   the buffer is smaller than the string. Return buffer on success.

   buflen is the length of the buffer in (Py_UCS4) characters. */
@NoException public static native @Cast("Py_UCS4*") IntPointer PyUnicode_AsUCS4(
    PyObject unicode,
    @Cast("Py_UCS4*") IntPointer buffer,
    @Cast("Py_ssize_t") long buflen,
    int copy_null);
@NoException public static native @Cast("Py_UCS4*") IntBuffer PyUnicode_AsUCS4(
    PyObject unicode,
    @Cast("Py_UCS4*") IntBuffer buffer,
    @Cast("Py_ssize_t") long buflen,
    int copy_null);
@NoException public static native @Cast("Py_UCS4*") int[] PyUnicode_AsUCS4(
    PyObject unicode,
    @Cast("Py_UCS4*") int[] buffer,
    @Cast("Py_ssize_t") long buflen,
    int copy_null);

/* Copy the string into a UCS4 buffer. A new buffer is allocated using
 * PyMem_Malloc; if this fails, NULL is returned with a memory error
   exception set. */
@NoException public static native @Cast("Py_UCS4*") IntPointer PyUnicode_AsUCS4Copy(PyObject unicode);
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
/* Get the length of the Unicode object. */

@NoException public static native @Cast("Py_ssize_t") long PyUnicode_GetLength(
    PyObject unicode
);
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
/* Read a character from the string. */

@NoException public static native @Cast("Py_UCS4") int PyUnicode_ReadChar(
    PyObject unicode,
    @Cast("Py_ssize_t") long index
    );

/* Write a character to the string. The string must have been created through
   PyUnicode_New, must not be shared, and must not have been hashed yet.

   Return 0 on success, -1 on error. */

@NoException public static native int PyUnicode_WriteChar(
    PyObject unicode,
    @Cast("Py_ssize_t") long index,
    @Cast("Py_UCS4") int character
    );
// #endif

/* Resize a Unicode object. The length is the number of codepoints.

   *unicode is modified to point to the new (resized) object and 0
   returned on success.

   Try to resize the string in place (which is usually faster than allocating
   a new string and copy characters), or create a new string.

   Error handling is implemented as follows: an exception is set, -1
   is returned and *unicode left untouched.

   WARNING: The function doesn't check string content, the result may not be a
            string in canonical representation. */

@NoException public static native int PyUnicode_Resize(
    @Cast("PyObject**") PointerPointer unicode,
    @Cast("Py_ssize_t") long length
    );
@NoException public static native int PyUnicode_Resize(
    @ByPtrPtr PyObject unicode,
    @Cast("Py_ssize_t") long length
    );

/* Decode obj to a Unicode object.

   bytes, bytearray and other bytes-like objects are decoded according to the
   given encoding and error handler. The encoding and error handler can be
   NULL to have the interface use UTF-8 and "strict".

   All other objects (including Unicode objects) raise an exception.

   The API returns NULL in case of an error. The caller is responsible
   for decref'ing the returned objects.

*/

@NoException public static native PyObject PyUnicode_FromEncodedObject(
    PyObject obj,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_FromEncodedObject(
    PyObject obj,
    String encoding,
    String errors
    );

/* Copy an instance of a Unicode subtype to a new true Unicode object if
   necessary. If obj is already a true Unicode object (not a subtype), return
   the reference with *incremented* refcount.

   The API returns NULL in case of an error. The caller is responsible
   for decref'ing the returned objects.

*/

@NoException public static native PyObject PyUnicode_FromObject(
    PyObject obj
    );

@NoException public static native PyObject PyUnicode_FromFormatV(
    @Cast("const char*") BytePointer format,
    @ByVal @Cast("va_list*") Pointer vargs
    );
@NoException public static native PyObject PyUnicode_FromFormatV(
    String format,
    @ByVal @Cast("va_list*") Pointer vargs
    );
@NoException public static native PyObject PyUnicode_FromFormat(
    @Cast("const char*") BytePointer format
    );
@NoException public static native PyObject PyUnicode_FromFormat(
    String format
    );

@NoException public static native void PyUnicode_InternInPlace(@Cast("PyObject**") PointerPointer arg0);
@NoException public static native void PyUnicode_InternInPlace(@ByPtrPtr PyObject arg0);
@NoException public static native PyObject PyUnicode_InternFromString(
    @Cast("const char*") BytePointer u
    );
@NoException public static native PyObject PyUnicode_InternFromString(
    String u
    );

/* --- wchar_t support for platforms which support it --------------------- */

// #ifdef HAVE_WCHAR_H

/* Create a Unicode Object from the wchar_t buffer w of the given
   size.

   The buffer is copied into the new object. */

@NoException public static native PyObject PyUnicode_FromWideChar(
    @Cast("const wchar_t*") Pointer w,
    @Cast("Py_ssize_t") long size
    );

/* Copies the Unicode Object contents into the wchar_t buffer w.  At
   most size wchar_t characters are copied.

   Note that the resulting wchar_t string may or may not be
   0-terminated.  It is the responsibility of the caller to make sure
   that the wchar_t string is 0-terminated in case this is required by
   the application.

   Returns the number of wchar_t characters copied (excluding a
   possibly trailing 0-termination character) or -1 in case of an
   error. */

@NoException public static native @Cast("Py_ssize_t") long PyUnicode_AsWideChar(
    PyObject unicode,
    @Cast("wchar_t*") Pointer w,
    @Cast("Py_ssize_t") long size
    );

/* Convert the Unicode object to a wide character string. The output string
   always ends with a nul character. If size is not NULL, write the number of
   wide characters (excluding the null character) into *size.

   Returns a buffer allocated by PyMem_Malloc() (use PyMem_Free() to free it)
   on success. On error, returns NULL, *size is undefined and raises a
   MemoryError. */

@NoException public static native @Cast("wchar_t*") Pointer PyUnicode_AsWideCharString(
    PyObject unicode,
    @Cast("Py_ssize_t*") SizeTPointer size
    );

// #endif

/* --- Unicode ordinals --------------------------------------------------- */

/* Create a Unicode Object from the given Unicode code point ordinal.

   The ordinal must be in range(0x110000). A ValueError is
   raised in case it is not.

*/

@NoException public static native PyObject PyUnicode_FromOrdinal(int ordinal);

/* === Builtin Codecs =====================================================

   Many of these APIs take two arguments encoding and errors. These
   parameters encoding and errors have the same semantics as the ones
   of the builtin str() API.

   Setting encoding to NULL causes the default encoding (UTF-8) to be used.

   Error handling is set by errors which may also be set to NULL
   meaning to use the default handling defined for the codec. Default
   error handling for all builtin codecs is "strict" (ValueErrors are
   raised).

   The codecs all use a similar interface. Only deviation from the
   generic ones are documented.

*/

/* --- Manage the default encoding ---------------------------------------- */

/* Returns "utf-8".  */
@NoException public static native @Cast("const char*") BytePointer PyUnicode_GetDefaultEncoding();

/* --- Generic Codecs ----------------------------------------------------- */

/* Create a Unicode object by decoding the encoded string s of the
   given size. */

@NoException public static native PyObject PyUnicode_Decode(
    @Cast("const char*") BytePointer s,
    @Cast("Py_ssize_t") long size,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_Decode(
    String s,
    @Cast("Py_ssize_t") long size,
    String encoding,
    String errors
    );

/* Decode a Unicode object unicode and return the result as Python
   object.

   This API is DEPRECATED and will be removed in 3.15.
   The only supported standard encoding is rot13.
   Use PyCodec_Decode() to decode with rot13 and non-standard codecs
   that decode from str. */

@NoException public static native @Deprecated PyObject PyUnicode_AsDecodedObject(
    PyObject unicode,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated PyObject PyUnicode_AsDecodedObject(
    PyObject unicode,
    String encoding,
    String errors
    );

/* Decode a Unicode object unicode and return the result as Unicode
   object.

   This API is DEPRECATED and will be removed in 3.15.
   The only supported standard encoding is rot13.
   Use PyCodec_Decode() to decode with rot13 and non-standard codecs
   that decode from str to str. */

@NoException public static native @Deprecated PyObject PyUnicode_AsDecodedUnicode(
    PyObject unicode,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated PyObject PyUnicode_AsDecodedUnicode(
    PyObject unicode,
    String encoding,
    String errors
    );

/* Encodes a Unicode object and returns the result as Python
   object.

   This API is DEPRECATED and will be removed in 3.15.
   It is superseded by PyUnicode_AsEncodedString()
   since all standard encodings (except rot13) encode str to bytes.
   Use PyCodec_Encode() for encoding with rot13 and non-standard codecs
   that encode form str to non-bytes. */

@NoException public static native @Deprecated PyObject PyUnicode_AsEncodedObject(
    PyObject unicode,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated PyObject PyUnicode_AsEncodedObject(
    PyObject unicode,
    String encoding,
    String errors
    );

/* Encodes a Unicode object and returns the result as Python string
   object. */

@NoException public static native PyObject PyUnicode_AsEncodedString(
    PyObject unicode,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_AsEncodedString(
    PyObject unicode,
    String encoding,
    String errors
    );

/* Encodes a Unicode object and returns the result as Unicode
   object.

   This API is DEPRECATED and will be removed in 3.15.
   The only supported standard encodings is rot13.
   Use PyCodec_Encode() to encode with rot13 and non-standard codecs
   that encode from str to str. */

@NoException public static native @Deprecated PyObject PyUnicode_AsEncodedUnicode(
    PyObject unicode,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated PyObject PyUnicode_AsEncodedUnicode(
    PyObject unicode,
    String encoding,
    String errors
    );

/* Build an encoding map. */

@NoException public static native PyObject PyUnicode_BuildEncodingMap(
    PyObject string
   );

/* --- UTF-7 Codecs ------------------------------------------------------- */

@NoException public static native PyObject PyUnicode_DecodeUTF7(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeUTF7(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

@NoException public static native PyObject PyUnicode_DecodeUTF7Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF7Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );

/* --- UTF-8 Codecs ------------------------------------------------------- */

@NoException public static native PyObject PyUnicode_DecodeUTF8(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeUTF8(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

@NoException public static native PyObject PyUnicode_DecodeUTF8Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF8Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );

@NoException public static native PyObject PyUnicode_AsUTF8String(
    PyObject unicode
    );

/* Returns a pointer to the default encoding (UTF-8) of the
   Unicode object unicode and the size of the encoded representation
   in bytes stored in *size.

   In case of an error, no *size is set.

   This function caches the UTF-8 encoded string in the unicodeobject
   and subsequent calls will return the same string.  The memory is released
   when the unicodeobject is deallocated.
*/

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
@NoException public static native @Cast("const char*") BytePointer PyUnicode_AsUTF8AndSize(
    PyObject unicode,
    @Cast("Py_ssize_t*") SizeTPointer size);
// #endif

/* --- UTF-32 Codecs ------------------------------------------------------ */

/* Decodes length bytes from a UTF-32 encoded buffer string and returns
   the corresponding Unicode object.

   errors (if non-NULL) defines the error handling. It defaults
   to "strict".

   If byteorder is non-NULL, the decoder starts decoding using the
   given byte order:

    *byteorder == -1: little endian
    *byteorder == 0:  native order
    *byteorder == 1:  big endian

   In native mode, the first four bytes of the stream are checked for a
   BOM mark. If found, the BOM mark is analysed, the byte order
   adjusted and the BOM skipped.  In the other modes, no BOM mark
   interpretation is done. After completion, *byteorder is set to the
   current byte order at the end of input data.

   If byteorder is NULL, the codec starts in native order mode.

*/

@NoException public static native PyObject PyUnicode_DecodeUTF32(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntPointer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntBuffer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    int[] byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntPointer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntBuffer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    int[] byteorder
    );

@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntPointer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntBuffer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    int[] byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntPointer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntBuffer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    int[] byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );

/* Returns a Python string using the UTF-32 encoding in native byte
   order. The string always starts with a BOM mark.  */

@NoException public static native PyObject PyUnicode_AsUTF32String(
    PyObject unicode
    );

/* Returns a Python string object holding the UTF-32 encoded value of
   the Unicode data.

   If byteorder is not 0, output is written according to the following
   byte order:

   byteorder == -1: little endian
   byteorder == 0:  native byte order (writes a BOM mark)
   byteorder == 1:  big endian

   If byteorder is 0, the output string will always start with the
   Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is
   prepended.

*/

/* --- UTF-16 Codecs ------------------------------------------------------ */

/* Decodes length bytes from a UTF-16 encoded buffer string and returns
   the corresponding Unicode object.

   errors (if non-NULL) defines the error handling. It defaults
   to "strict".

   If byteorder is non-NULL, the decoder starts decoding using the
   given byte order:

    *byteorder == -1: little endian
    *byteorder == 0:  native order
    *byteorder == 1:  big endian

   In native mode, the first two bytes of the stream are checked for a
   BOM mark. If found, the BOM mark is analysed, the byte order
   adjusted and the BOM skipped.  In the other modes, no BOM mark
   interpretation is done. After completion, *byteorder is set to the
   current byte order at the end of input data.

   If byteorder is NULL, the codec starts in native order mode.

*/

@NoException public static native PyObject PyUnicode_DecodeUTF16(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntPointer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntBuffer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    int[] byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntPointer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntBuffer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    int[] byteorder
    );

@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntPointer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntBuffer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    int[] byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntPointer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntBuffer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    int[] byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );

/* Returns a Python string using the UTF-16 encoding in native byte
   order. The string always starts with a BOM mark.  */

@NoException public static native PyObject PyUnicode_AsUTF16String(
    PyObject unicode
    );

/* --- Unicode-Escape Codecs ---------------------------------------------- */

@NoException public static native PyObject PyUnicode_DecodeUnicodeEscape(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeUnicodeEscape(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

@NoException public static native PyObject PyUnicode_AsUnicodeEscapeString(
    PyObject unicode
    );

/* --- Raw-Unicode-Escape Codecs ------------------------------------------ */

@NoException public static native PyObject PyUnicode_DecodeRawUnicodeEscape(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeRawUnicodeEscape(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

@NoException public static native PyObject PyUnicode_AsRawUnicodeEscapeString(
    PyObject unicode
    );

/* --- Latin-1 Codecs -----------------------------------------------------

   Note: Latin-1 corresponds to the first 256 Unicode ordinals. */

@NoException public static native PyObject PyUnicode_DecodeLatin1(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeLatin1(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

@NoException public static native PyObject PyUnicode_AsLatin1String(
    PyObject unicode
    );

/* --- ASCII Codecs -------------------------------------------------------

   Only 7-bit ASCII data is expected. All other codes generate errors.

*/

@NoException public static native PyObject PyUnicode_DecodeASCII(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeASCII(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

@NoException public static native PyObject PyUnicode_AsASCIIString(
    PyObject unicode
    );

/* --- Character Map Codecs -----------------------------------------------

   This codec uses mappings to encode and decode characters.

   Decoding mappings must map byte ordinals (integers in the range from 0 to
   255) to Unicode strings, integers (which are then interpreted as Unicode
   ordinals) or None.  Unmapped data bytes (ones which cause a LookupError)
   as well as mapped to None, 0xFFFE or '\u005Cufffe' are treated as "undefined
   mapping" and cause an error.

   Encoding mappings must map Unicode ordinal integers to bytes objects,
   integers in the range from 0 to 255 or None.  Unmapped character
   ordinals (ones which cause a LookupError) as well as mapped to
   None are treated as "undefined mapping" and cause an error.

*/

@NoException public static native PyObject PyUnicode_DecodeCharmap(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    PyObject mapping,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeCharmap(
    String string,
    @Cast("Py_ssize_t") long length,
    PyObject mapping,
    String errors
    );

@NoException public static native PyObject PyUnicode_AsCharmapString(
    PyObject unicode,
    PyObject mapping
    );

/* --- MBCS codecs for Windows -------------------------------------------- */

// #ifdef MS_WINDOWS

// #endif /* MS_WINDOWS */

/* --- Locale encoding --------------------------------------------------- */

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
/* Decode a string from the current locale encoding. The decoder is strict if
   *surrogateescape* is equal to zero, otherwise it uses the 'surrogateescape'
   error handler (PEP 383) to escape undecodable bytes. If a byte sequence can
   be decoded as a surrogate character and *surrogateescape* is not equal to
   zero, the byte sequence is escaped using the 'surrogateescape' error handler
   instead of being decoded. *str* must end with a null character but cannot
   contain embedded null characters. */

@NoException public static native PyObject PyUnicode_DecodeLocaleAndSize(
    @Cast("const char*") BytePointer str,
    @Cast("Py_ssize_t") long len,
    @Cast("const char*") BytePointer errors);
@NoException public static native PyObject PyUnicode_DecodeLocaleAndSize(
    String str,
    @Cast("Py_ssize_t") long len,
    String errors);

/* Similar to PyUnicode_DecodeLocaleAndSize(), but compute the string
   length using strlen(). */

@NoException public static native PyObject PyUnicode_DecodeLocale(
    @Cast("const char*") BytePointer str,
    @Cast("const char*") BytePointer errors);
@NoException public static native PyObject PyUnicode_DecodeLocale(
    String str,
    String errors);

/* Encode a Unicode object to the current locale encoding. The encoder is
   strict is *surrogateescape* is equal to zero, otherwise the
   "surrogateescape" error handler is used. Return a bytes object. The string
   cannot contain embedded null characters. */

@NoException public static native PyObject PyUnicode_EncodeLocale(
    PyObject unicode,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_EncodeLocale(
    PyObject unicode,
    String errors
    );
// #endif

/* --- File system encoding ---------------------------------------------- */

/* ParseTuple converter: encode str objects to bytes using
   PyUnicode_EncodeFSDefault(); bytes objects are output as-is. */

@NoException public static native int PyUnicode_FSConverter(PyObject arg0, Pointer arg1);

/* ParseTuple converter: decode bytes objects to unicode using
   PyUnicode_DecodeFSDefaultAndSize(); str objects are output as-is. */

@NoException public static native int PyUnicode_FSDecoder(PyObject arg0, Pointer arg1);

/* Decode a null-terminated string from the Python filesystem encoding
   and error handler.

   If the string length is known, use PyUnicode_DecodeFSDefaultAndSize(). */
@NoException public static native PyObject PyUnicode_DecodeFSDefault(
    @Cast("const char*") BytePointer s
    );
@NoException public static native PyObject PyUnicode_DecodeFSDefault(
    String s
    );

/* Decode a string from the Python filesystem encoding and error handler. */
@NoException public static native PyObject PyUnicode_DecodeFSDefaultAndSize(
    @Cast("const char*") BytePointer s,
    @Cast("Py_ssize_t") long size
    );
@NoException public static native PyObject PyUnicode_DecodeFSDefaultAndSize(
    String s,
    @Cast("Py_ssize_t") long size
    );

/* Encode a Unicode object to the Python filesystem encoding and error handler.
   Return bytes. */
@NoException public static native PyObject PyUnicode_EncodeFSDefault(
    PyObject unicode
    );

/* --- Methods & Slots ----------------------------------------------------

   These are capable of handling Unicode objects and strings on input
   (we refer to them as strings in the descriptions) and return
   Unicode objects or integers as appropriate. */

/* Concat two strings giving a new Unicode string. */

@NoException public static native PyObject PyUnicode_Concat(
    PyObject left,
    PyObject right
    );

/* Concat two strings and put the result in *pleft
   (sets *pleft to NULL on error) */

@NoException public static native void PyUnicode_Append(
    @Cast("PyObject**") PointerPointer pleft,
    PyObject right
    );
@NoException public static native void PyUnicode_Append(
    @ByPtrPtr PyObject pleft,
    PyObject right
    );

/* Concat two strings, put the result in *pleft and drop the right object
   (sets *pleft to NULL on error) */

@NoException public static native void PyUnicode_AppendAndDel(
    @Cast("PyObject**") PointerPointer pleft,
    PyObject right
    );
@NoException public static native void PyUnicode_AppendAndDel(
    @ByPtrPtr PyObject pleft,
    PyObject right
    );

/* Split a string giving a list of Unicode strings.

   If sep is NULL, splitting will be done at all whitespace
   substrings. Otherwise, splits occur at the given separator.

   At most maxsplit splits will be done. If negative, no limit is set.

   Separators are not included in the resulting list.

*/

@NoException public static native PyObject PyUnicode_Split(
    PyObject s,
    PyObject sep,
    @Cast("Py_ssize_t") long maxsplit
    );

/* Dito, but split at line breaks.

   CRLF is considered to be one line break. Line breaks are not
   included in the resulting list. */

@NoException public static native PyObject PyUnicode_Splitlines(
    PyObject s,
    int keepends
    );

/* Partition a string using a given separator. */

@NoException public static native PyObject PyUnicode_Partition(
    PyObject s,
    PyObject sep
    );

/* Partition a string using a given separator, searching from the end of the
   string. */

@NoException public static native PyObject PyUnicode_RPartition(
    PyObject s,
    PyObject sep
    );

/* Split a string giving a list of Unicode strings.

   If sep is NULL, splitting will be done at all whitespace
   substrings. Otherwise, splits occur at the given separator.

   At most maxsplit splits will be done. But unlike PyUnicode_Split
   PyUnicode_RSplit splits from the end of the string. If negative,
   no limit is set.

   Separators are not included in the resulting list.

*/

@NoException public static native PyObject PyUnicode_RSplit(
    PyObject s,
    PyObject sep,
    @Cast("Py_ssize_t") long maxsplit
    );

/* Translate a string by applying a character mapping table to it and
   return the resulting Unicode object.

   The mapping table must map Unicode ordinal integers to Unicode strings,
   Unicode ordinal integers or None (causing deletion of the character).

   Mapping tables may be dictionaries or sequences. Unmapped character
   ordinals (ones which cause a LookupError) are left untouched and
   are copied as-is.

*/

@NoException public static native PyObject PyUnicode_Translate(
    PyObject str,
    PyObject table,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_Translate(
    PyObject str,
    PyObject table,
    String errors
    );

/* Join a sequence of strings using the given separator and return
   the resulting Unicode string. */

@NoException public static native PyObject PyUnicode_Join(
    PyObject separator,
    PyObject seq
    );

/* Return 1 if substr matches str[start:end] at the given tail end, 0
   otherwise. */

@NoException public static native @Cast("Py_ssize_t") long PyUnicode_Tailmatch(
    PyObject str,
    PyObject substr,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    int direction
    );

/* Return the first position of substr in str[start:end] using the
   given search direction or -1 if not found. -2 is returned in case
   an error occurred and an exception is set. */

@NoException public static native @Cast("Py_ssize_t") long PyUnicode_Find(
    PyObject str,
    PyObject substr,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    int direction
    );

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
/* Like PyUnicode_Find, but search for single character only. */
@NoException public static native @Cast("Py_ssize_t") long PyUnicode_FindChar(
    PyObject str,
    @Cast("Py_UCS4") int ch,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    int direction
    );
// #endif

/* Count the number of occurrences of substr in str[start:end]. */

@NoException public static native @Cast("Py_ssize_t") long PyUnicode_Count(
    PyObject str,
    PyObject substr,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end
    );

/* Replace at most maxcount occurrences of substr in str with replstr
   and return the resulting Unicode object. */

@NoException public static native PyObject PyUnicode_Replace(
    PyObject str,
    PyObject substr,
    PyObject replstr,
    @Cast("Py_ssize_t") long maxcount
    );

/* Compare two strings and return -1, 0, 1 for less than, equal,
   greater than resp.
   Raise an exception and return -1 on error. */

@NoException public static native int PyUnicode_Compare(
    PyObject left,
    PyObject right
    );

/* Compare a Unicode object with C string and return -1, 0, 1 for less than,
   equal, and greater than, respectively.  It is best to pass only
   ASCII-encoded strings, but the function interprets the input string as
   ISO-8859-1 if it contains non-ASCII characters.
   This function does not raise exceptions. */

@NoException public static native int PyUnicode_CompareWithASCIIString(
    PyObject left,
    @Cast("const char*") BytePointer right
    );
@NoException public static native int PyUnicode_CompareWithASCIIString(
    PyObject left,
    String right
    );

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030D0000
/* Compare a Unicode object with UTF-8 encoded C string.
   Return 1 if they are equal, or 0 otherwise.
   This function does not raise exceptions. */

@NoException public static native int PyUnicode_EqualToUTF8(PyObject arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native int PyUnicode_EqualToUTF8(PyObject arg0, String arg1);
@NoException public static native int PyUnicode_EqualToUTF8AndSize(PyObject arg0, @Cast("const char*") BytePointer arg1, @Cast("Py_ssize_t") long arg2);
@NoException public static native int PyUnicode_EqualToUTF8AndSize(PyObject arg0, String arg1, @Cast("Py_ssize_t") long arg2);
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030e0000
@NoException public static native int PyUnicode_Equal(PyObject str1, PyObject str2);
// #endif

/* Rich compare two strings and return one of the following:

   - NULL in case an exception was raised
   - Py_True or Py_False for successful comparisons
   - Py_NotImplemented in case the type combination is unknown

   Possible values for op:

     Py_GT, Py_GE, Py_EQ, Py_NE, Py_LT, Py_LE

*/

@NoException public static native PyObject PyUnicode_RichCompare(
    PyObject left,
    PyObject right,
    int op
    );

/* Apply an argument tuple or dictionary to a format string and return
   the resulting Unicode string. */

@NoException public static native PyObject PyUnicode_Format(
    PyObject format,
    PyObject args
    );

/* Checks whether element is contained in container and return 1/0
   accordingly.

   element has to coerce to a one element Unicode string. -1 is
   returned in case of an error. */

@NoException public static native int PyUnicode_Contains(
    PyObject container,
    PyObject element
    );

/* Checks whether argument is a valid identifier. */

@NoException public static native int PyUnicode_IsIdentifier(PyObject s);

/* === Characters Type APIs =============================================== */

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_UNICODEOBJECT_H
// #  include "cpython/unicodeobject.h"
// #  undef Py_CPYTHON_UNICODEOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_UNICODEOBJECT_H */


// Parsed from cpython/unicodeobject.h

// #ifndef Py_CPYTHON_UNICODEOBJECT_H
// #  error "this header file must not be included directly"
// #endif

/* Py_UNICODE was the native Unicode storage format (code unit) used by
   Python and represents a single Unicode element in the Unicode type.
   With PEP 393, Py_UNICODE is deprecated and replaced with a
   typedef to wchar_t. */


/* --- Internal Unicode Operations ---------------------------------------- */

// Static inline functions to work with surrogates
@NoException public static native int Py_UNICODE_IS_SURROGATE(@Cast("Py_UCS4") int ch);
@NoException public static native int Py_UNICODE_IS_HIGH_SURROGATE(@Cast("Py_UCS4") int ch);
@NoException public static native int Py_UNICODE_IS_LOW_SURROGATE(@Cast("Py_UCS4") int ch);

// Join two surrogate characters and return a single Py_UCS4 value.
@NoException public static native @Cast("Py_UCS4") int Py_UNICODE_JOIN_SURROGATES(@Cast("Py_UCS4") int high, @Cast("Py_UCS4") int low);

// High surrogate = top 10 bits added to 0xD800.
// The character must be in the range [U+10000; U+10ffff].
@NoException public static native @Cast("Py_UCS4") int Py_UNICODE_HIGH_SURROGATE(@Cast("Py_UCS4") int ch);

// Low surrogate = bottom 10 bits added to 0xDC00.
// The character must be in the range [U+10000; U+10ffff].
@NoException public static native @Cast("Py_UCS4") int Py_UNICODE_LOW_SURROGATE(@Cast("Py_UCS4") int ch);
// Targeting ../PyASCIIObject.java


// Targeting ../PyCompactUnicodeObject.java


// Targeting ../PyUnicodeObject.java




// #define _PyASCIIObject_CAST(op)
//     (assert(PyUnicode_Check(op)),
//      _Py_CAST(PyASCIIObject*, (op)))
// #define _PyCompactUnicodeObject_CAST(op)
//     (assert(PyUnicode_Check(op)),
//      _Py_CAST(PyCompactUnicodeObject*, (op)))
// #define _PyUnicodeObject_CAST(op)
//     (assert(PyUnicode_Check(op)),
//      _Py_CAST(PyUnicodeObject*, (op)))


/* --- Flexible String Representation Helper Macros (PEP 393) -------------- */

/* Values for PyASCIIObject.state: */

/* Interning state. */
public static final int SSTATE_NOT_INTERNED = 0;
public static final int SSTATE_INTERNED_MORTAL = 1;
public static final int SSTATE_INTERNED_IMMORTAL = 2;
public static final int SSTATE_INTERNED_IMMORTAL_STATIC = 3;

/* Use only if you know it's a string */
@NoException public static native @Cast("unsigned int") int PyUnicode_CHECK_INTERNED(PyObject op);
// #define PyUnicode_CHECK_INTERNED(op) PyUnicode_CHECK_INTERNED(_PyObject_CAST(op))

/* For backward compatibility. Soft-deprecated. */

// #define PyUnicode_IS_READY(op) PyUnicode_IS_READY(_PyObject_CAST(op))

/* Return true if the string contains only ASCII characters, or 0 if not. The
   string may be compact (PyUnicode_IS_COMPACT_ASCII) or not. */
@NoException public static native @Cast("unsigned int") int PyUnicode_IS_ASCII(PyObject op);
// #define PyUnicode_IS_ASCII(op) PyUnicode_IS_ASCII(_PyObject_CAST(op))

/* Return true if the string is compact or 0 if not.
   No type checks are performed. */
@NoException public static native @Cast("unsigned int") int PyUnicode_IS_COMPACT(PyObject op);
// #define PyUnicode_IS_COMPACT(op) PyUnicode_IS_COMPACT(_PyObject_CAST(op))

/* Return true if the string is a compact ASCII string (use PyASCIIObject
   structure), or 0 if not.  No type checks are performed. */
@NoException public static native int PyUnicode_IS_COMPACT_ASCII(PyObject op);
// #define PyUnicode_IS_COMPACT_ASCII(op) PyUnicode_IS_COMPACT_ASCII(_PyObject_CAST(op))

/** enum PyUnicode_Kind */
public static final int
/* Return values of the PyUnicode_KIND() function: */
    PyUnicode_1BYTE_KIND = 1,
    PyUnicode_2BYTE_KIND = 2,
    PyUnicode_4BYTE_KIND = 4;

@NoException public static native int PyUnicode_KIND(PyObject op);

// PyUnicode_KIND(): Return one of the PyUnicode_*_KIND values defined above.
//
// gh-89653: Converting this macro to a static inline function would introduce
// new compiler warnings on "kind < PyUnicode_KIND(str)" (compare signed and
// unsigned numbers) where kind type is an int or on
// "unsigned int kind = PyUnicode_KIND(str)" (cast signed to unsigned).
// #define PyUnicode_KIND(op) _Py_RVALUE(_PyASCIIObject_CAST(op)->state.kind)

/* Return a void pointer to the raw unicode buffer. */
@NoException public static native Pointer _PyUnicode_COMPACT_DATA(PyObject op);

@NoException public static native Pointer _PyUnicode_NONCOMPACT_DATA(PyObject op);

@NoException public static native Pointer PyUnicode_DATA(PyObject op);

@NoException public static native Pointer _PyUnicode_DATA(PyObject op);
// #define PyUnicode_DATA(op) _PyUnicode_DATA(_PyObject_CAST(op))

/* Return pointers to the canonical representation cast to unsigned char,
   Py_UCS2, or Py_UCS4 for direct character access.
   No checks are performed, use PyUnicode_KIND() before to ensure
   these will work correctly. */

// #define PyUnicode_1BYTE_DATA(op) _Py_STATIC_CAST(Py_UCS1*, PyUnicode_DATA(op))
// #define PyUnicode_2BYTE_DATA(op) _Py_STATIC_CAST(Py_UCS2*, PyUnicode_DATA(op))
// #define PyUnicode_4BYTE_DATA(op) _Py_STATIC_CAST(Py_UCS4*, PyUnicode_DATA(op))

/* Returns the length of the unicode string. */
@NoException public static native @Cast("Py_ssize_t") long PyUnicode_GET_LENGTH(PyObject op);
// #define PyUnicode_GET_LENGTH(op) PyUnicode_GET_LENGTH(_PyObject_CAST(op))

/* Write into the canonical representation, this function does not do any sanity
   checks and is intended for usage in loops.  The caller should cache the
   kind and data pointers obtained from other function calls.
   index is the index in the string (starts at 0) and value is the new
   code point value which should be written to that location. */
@NoException public static native void PyUnicode_WRITE(int kind, Pointer data,
                                   @Cast("Py_ssize_t") long index, @Cast("Py_UCS4") int value);
// #define PyUnicode_WRITE(kind, data, index, value)
//     PyUnicode_WRITE(_Py_STATIC_CAST(int, kind), _Py_CAST(void*, data),
//                     (index), _Py_STATIC_CAST(Py_UCS4, value))

/* Read a code point from the string's canonical representation.  No checks
   are performed. */
@NoException public static native @Cast("Py_UCS4") int PyUnicode_READ(int kind,
                                     @Const Pointer data, @Cast("Py_ssize_t") long index);
// #define PyUnicode_READ(kind, data, index)
//     PyUnicode_READ(_Py_STATIC_CAST(int, kind),
//                    _Py_STATIC_CAST(const void*, data),
//                    (index))

/* PyUnicode_READ_CHAR() is less efficient than PyUnicode_READ() because it
   calls PyUnicode_KIND() and might call it twice.  For single reads, use
   PyUnicode_READ_CHAR, for multiple consecutive reads callers should
   cache kind and use PyUnicode_READ instead. */
@NoException public static native @Cast("Py_UCS4") int PyUnicode_READ_CHAR(PyObject unicode, @Cast("Py_ssize_t") long index);
// #define PyUnicode_READ_CHAR(unicode, index)
//     PyUnicode_READ_CHAR(_PyObject_CAST(unicode), (index))

/* Return a maximum character value which is suitable for creating another
   string based on op.  This is always an approximation but more efficient
   than iterating over the string. */
@NoException public static native @Cast("Py_UCS4") int PyUnicode_MAX_CHAR_VALUE(PyObject op);
// #define PyUnicode_MAX_CHAR_VALUE(op)
//     PyUnicode_MAX_CHAR_VALUE(_PyObject_CAST(op))


/* === Public API ========================================================= */

/* With PEP 393, this is the recommended way to allocate a new unicode object.
   This function will allocate the object and its buffer in a single memory
   block.  Objects created using this function are not resizable. */
@NoException public static native PyObject PyUnicode_New(
    @Cast("Py_ssize_t") long size,
    @Cast("Py_UCS4") int maxchar
    );

/* For backward compatibility. Soft-deprecated. */

// #define PyUnicode_READY(op) PyUnicode_READY(_PyObject_CAST(op))

/* Copy character from one unicode object into another, this function performs
   character conversion when necessary and falls back to memcpy() if possible.

   Fail if to is too small (smaller than *how_many* or smaller than
   len(from)-from_start), or if kind(from[from_start:from_start+how_many]) >
   kind(to), or if *to* has more than 1 reference.

   Return the number of written character, or return -1 and raise an exception
   on error.

   Pseudo-code:

       how_many = min(how_many, len(from) - from_start)
       to[to_start:to_start+how_many] = from[from_start:from_start+how_many]
       return how_many

   Note: The function doesn't write a terminating null character.
   */
@NoException public static native @Cast("Py_ssize_t") long PyUnicode_CopyCharacters(
    PyObject to,
    @Cast("Py_ssize_t") long to_start,
    PyObject from,
    @Cast("Py_ssize_t") long from_start,
    @Cast("Py_ssize_t") long how_many
    );

/* Fill a string with a character: write fill_char into
   unicode[start:start+length].

   Fail if fill_char is bigger than the string maximum character, or if the
   string has more than 1 reference.

   Return the number of written character, or return -1 and raise an exception
   on error. */
@NoException public static native @Cast("Py_ssize_t") long PyUnicode_Fill(
    PyObject unicode,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_UCS4") int fill_char
    );

/* Create a new string from a buffer of Py_UCS1, Py_UCS2 or Py_UCS4 characters.
   Scan the string to find the maximum character. */
@NoException public static native PyObject PyUnicode_FromKindAndData(
    int kind,
    @Const Pointer buffer,
    @Cast("Py_ssize_t") long size);
// Targeting ../PyUnicodeWriter.java



@NoException public static native PyUnicodeWriter PyUnicodeWriter_Create(@Cast("Py_ssize_t") long length);
@NoException public static native void PyUnicodeWriter_Discard(PyUnicodeWriter writer);
@NoException public static native PyObject PyUnicodeWriter_Finish(PyUnicodeWriter writer);

@NoException public static native int PyUnicodeWriter_WriteChar(
    PyUnicodeWriter writer,
    @Cast("Py_UCS4") int ch);
@NoException public static native int PyUnicodeWriter_WriteUTF8(
    PyUnicodeWriter writer,
    @Cast("const char*") BytePointer str,
    @Cast("Py_ssize_t") long size);
@NoException public static native int PyUnicodeWriter_WriteUTF8(
    PyUnicodeWriter writer,
    String str,
    @Cast("Py_ssize_t") long size);
@NoException public static native int PyUnicodeWriter_WriteASCII(
    PyUnicodeWriter writer,
    @Cast("const char*") BytePointer str,
    @Cast("Py_ssize_t") long size);
@NoException public static native int PyUnicodeWriter_WriteASCII(
    PyUnicodeWriter writer,
    String str,
    @Cast("Py_ssize_t") long size);
@NoException public static native int PyUnicodeWriter_WriteWideChar(
    PyUnicodeWriter writer,
    @Cast("const wchar_t*") Pointer str,
    @Cast("Py_ssize_t") long size);
@NoException public static native int PyUnicodeWriter_WriteUCS4(
    PyUnicodeWriter writer,
    @Cast("Py_UCS4*") IntPointer str,
    @Cast("Py_ssize_t") long size);
@NoException public static native int PyUnicodeWriter_WriteUCS4(
    PyUnicodeWriter writer,
    @Cast("Py_UCS4*") IntBuffer str,
    @Cast("Py_ssize_t") long size);
@NoException public static native int PyUnicodeWriter_WriteUCS4(
    PyUnicodeWriter writer,
    @Cast("Py_UCS4*") int[] str,
    @Cast("Py_ssize_t") long size);

@NoException public static native int PyUnicodeWriter_WriteStr(
    PyUnicodeWriter writer,
    PyObject obj);
@NoException public static native int PyUnicodeWriter_WriteRepr(
    PyUnicodeWriter writer,
    PyObject obj);
@NoException public static native int PyUnicodeWriter_WriteSubstring(
    PyUnicodeWriter writer,
    PyObject str,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end);
@NoException public static native int PyUnicodeWriter_Format(
    PyUnicodeWriter writer,
    @Cast("const char*") BytePointer format);
@NoException public static native int PyUnicodeWriter_Format(
    PyUnicodeWriter writer,
    String format);
@NoException public static native int PyUnicodeWriter_DecodeUTF8Stateful(
    PyUnicodeWriter writer,
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    @Cast("Py_ssize_t*") SizeTPointer consumed);
@NoException public static native int PyUnicodeWriter_DecodeUTF8Stateful(
    PyUnicodeWriter writer,
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    @Cast("Py_ssize_t*") SizeTPointer consumed);
// Targeting ../_PyUnicodeWriter.java



// Initialize a Unicode writer.
//
// By default, the minimum buffer size is 0 character and overallocation is
// disabled. Set min_length, min_char and overallocate attributes to control
// the allocation of the buffer.
@NoException public static native @Deprecated void _PyUnicodeWriter_Init(
    _PyUnicodeWriter writer);

/* Prepare the buffer to write 'length' characters
   with the specified maximum character.

   Return 0 on success, raise an exception and return -1 on error. */
// #define _PyUnicodeWriter_Prepare(WRITER, LENGTH, MAXCHAR)
//     (((MAXCHAR) <= (WRITER)->maxchar
//       && (LENGTH) <= (WRITER)->size - (WRITER)->pos)
//      ? 0
//      : (((LENGTH) == 0)
//         ? 0
//         : _PyUnicodeWriter_PrepareInternal((WRITER), (LENGTH), (MAXCHAR))))

/* Don't call this function directly, use the _PyUnicodeWriter_Prepare() macro
   instead. */
@NoException public static native @Deprecated int _PyUnicodeWriter_PrepareInternal(
    _PyUnicodeWriter writer,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_UCS4") int maxchar);

/* Prepare the buffer to have at least the kind KIND.
   For example, kind=PyUnicode_2BYTE_KIND ensures that the writer will
   support characters in range U+000-U+FFFF.

   Return 0 on success, raise an exception and return -1 on error. */
// #define _PyUnicodeWriter_PrepareKind(WRITER, KIND)
//     ((KIND) <= (WRITER)->kind
//      ? 0
//      : _PyUnicodeWriter_PrepareKindInternal((WRITER), (KIND)))

/* Don't call this function directly, use the _PyUnicodeWriter_PrepareKind()
   macro instead. */
@NoException public static native @Deprecated int _PyUnicodeWriter_PrepareKindInternal(
    _PyUnicodeWriter writer,
    int kind);

/* Append a Unicode character.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native @Deprecated int _PyUnicodeWriter_WriteChar(
    _PyUnicodeWriter writer,
    @Cast("Py_UCS4") int ch);

/* Append a Unicode string.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native @Deprecated int _PyUnicodeWriter_WriteStr(
    _PyUnicodeWriter writer,
    PyObject str);               /* Unicode string */

/* Append a substring of a Unicode string.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native @Deprecated int _PyUnicodeWriter_WriteSubstring(
    _PyUnicodeWriter writer,
    PyObject str,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end);

/* Append an ASCII-encoded byte string.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native @Deprecated int _PyUnicodeWriter_WriteASCIIString(
    _PyUnicodeWriter writer,
    @Cast("const char*") BytePointer str,
    @Cast("Py_ssize_t") long len);
@NoException public static native @Deprecated int _PyUnicodeWriter_WriteASCIIString(
    _PyUnicodeWriter writer,
    String str,
    @Cast("Py_ssize_t") long len);           /* number of bytes, or -1 if unknown */

/* Append a latin1-encoded byte string.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native @Deprecated int _PyUnicodeWriter_WriteLatin1String(
    _PyUnicodeWriter writer,
    @Cast("const char*") BytePointer str,
    @Cast("Py_ssize_t") long len);
@NoException public static native @Deprecated int _PyUnicodeWriter_WriteLatin1String(
    _PyUnicodeWriter writer,
    String str,
    @Cast("Py_ssize_t") long len);           /* length in bytes */

/* Get the value of the writer as a Unicode string. Clear the
   buffer of the writer. Raise an exception and return NULL
   on error. */
@NoException public static native @Deprecated PyObject _PyUnicodeWriter_Finish(
    _PyUnicodeWriter writer);

/* Deallocate memory of a writer (clear its internal buffer). */
@NoException public static native @Deprecated void _PyUnicodeWriter_Dealloc(
    _PyUnicodeWriter writer);


/* --- Manage the default encoding ---------------------------------------- */

/* Returns a pointer to the default encoding (UTF-8) of the
   Unicode object unicode.

   Like PyUnicode_AsUTF8AndSize(), this also caches the UTF-8 representation
   in the unicodeobject.

   _PyUnicode_AsString is a #define for PyUnicode_AsUTF8 to
   support the previous internal function with the same behaviour.

   Use of this API is DEPRECATED since no size information can be
   extracted from the returned data.
*/

@NoException public static native @Cast("const char*") BytePointer PyUnicode_AsUTF8(PyObject unicode);

// Deprecated alias kept for backward compatibility
@NoException public static native @Deprecated @Cast("const char*") BytePointer _PyUnicode_AsString(PyObject unicode);


/* === Characters Type APIs =============================================== */

/* These should not be used directly. Use the Py_UNICODE_IS* and
   Py_UNICODE_TO* macros instead.

   These APIs are implemented in Objects/unicodectype.c.

*/

@NoException public static native int _PyUnicode_IsLowercase(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsUppercase(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsTitlecase(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsWhitespace(
    @Cast("const Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsLinebreak(
    @Cast("const Py_UCS4") int ch
    );

@NoException public static native @Cast("Py_UCS4") int _PyUnicode_ToLowercase(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native @Cast("Py_UCS4") int _PyUnicode_ToUppercase(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native @Cast("Py_UCS4") int _PyUnicode_ToTitlecase(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_ToDecimalDigit(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_ToDigit(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native double _PyUnicode_ToNumeric(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsDecimalDigit(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsDigit(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsNumeric(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsPrintable(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsAlpha(
    @Cast("Py_UCS4") int ch
    );

// Helper array used by Py_UNICODE_ISSPACE().
@MemberGetter public static native @Cast("const unsigned char") byte _Py_ascii_whitespace(int i);
@MemberGetter public static native @Cast("const unsigned char*") BytePointer _Py_ascii_whitespace();

// Since splitting on whitespace is an important use case, and
// whitespace in most situations is solely ASCII whitespace, we
// optimize for the common case by using a quick look-up table
// _Py_ascii_whitespace (see below) with an inlined check.
@NoException public static native int Py_UNICODE_ISSPACE(@Cast("Py_UCS4") int ch);

// #define Py_UNICODE_ISLOWER(ch) _PyUnicode_IsLowercase(ch)
// #define Py_UNICODE_ISUPPER(ch) _PyUnicode_IsUppercase(ch)
// #define Py_UNICODE_ISTITLE(ch) _PyUnicode_IsTitlecase(ch)
// #define Py_UNICODE_ISLINEBREAK(ch) _PyUnicode_IsLinebreak(ch)

// #define Py_UNICODE_TOLOWER(ch) _PyUnicode_ToLowercase(ch)
// #define Py_UNICODE_TOUPPER(ch) _PyUnicode_ToUppercase(ch)
// #define Py_UNICODE_TOTITLE(ch) _PyUnicode_ToTitlecase(ch)

// #define Py_UNICODE_ISDECIMAL(ch) _PyUnicode_IsDecimalDigit(ch)
// #define Py_UNICODE_ISDIGIT(ch) _PyUnicode_IsDigit(ch)
// #define Py_UNICODE_ISNUMERIC(ch) _PyUnicode_IsNumeric(ch)
// #define Py_UNICODE_ISPRINTABLE(ch) _PyUnicode_IsPrintable(ch)

// #define Py_UNICODE_TODECIMAL(ch) _PyUnicode_ToDecimalDigit(ch)
// #define Py_UNICODE_TODIGIT(ch) _PyUnicode_ToDigit(ch)
// #define Py_UNICODE_TONUMERIC(ch) _PyUnicode_ToNumeric(ch)

// #define Py_UNICODE_ISALPHA(ch) _PyUnicode_IsAlpha(ch)

@NoException public static native int Py_UNICODE_ISALNUM(@Cast("Py_UCS4") int ch);


/* === Misc functions ===================================================== */

// Return an interned Unicode object for an Identifier; may fail if there is no
// memory.
@NoException public static native PyObject _PyUnicode_FromId(_Py_Identifier arg0);


// Parsed from longobject.h

// #ifndef Py_LONGOBJECT_H
// #define Py_LONGOBJECT_H
// #ifdef __cplusplus
// #endif


/* Long (arbitrary precision) integer object interface */

// PyLong_Type is declared by object.h

// #define PyLong_Check(op)
//         PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_LONG_SUBCLASS)
// #define PyLong_CheckExact(op) Py_IS_TYPE((op), &PyLong_Type)

@NoException public static native PyObject PyLong_FromLong(long arg0);
@NoException public static native PyObject PyLong_FromUnsignedLong(@Cast("unsigned long") long arg0);
@NoException public static native PyObject PyLong_FromSize_t(@Cast("size_t") long arg0);
@NoException public static native PyObject PyLong_FromSsize_t(@Cast("Py_ssize_t") long arg0);
@NoException public static native PyObject PyLong_FromDouble(double arg0);

@NoException public static native long PyLong_AsLong(PyObject arg0);
@NoException public static native long PyLong_AsLongAndOverflow(PyObject arg0, IntPointer arg1);
@NoException public static native long PyLong_AsLongAndOverflow(PyObject arg0, IntBuffer arg1);
@NoException public static native long PyLong_AsLongAndOverflow(PyObject arg0, int[] arg1);
@NoException public static native @Cast("Py_ssize_t") long PyLong_AsSsize_t(PyObject arg0);
@NoException public static native @Cast("size_t") long PyLong_AsSize_t(PyObject arg0);
@NoException public static native @Cast("unsigned long") long PyLong_AsUnsignedLong(PyObject arg0);
@NoException public static native @Cast("unsigned long") long PyLong_AsUnsignedLongMask(PyObject arg0);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000
@NoException public static native int PyLong_AsInt(PyObject arg0);
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030e0000
@NoException public static native PyObject PyLong_FromInt32(int value);
@NoException public static native PyObject PyLong_FromUInt32(@Cast("uint32_t") int value);
@NoException public static native PyObject PyLong_FromInt64(@Cast("int64_t") long value);
@NoException public static native PyObject PyLong_FromUInt64(@Cast("uint64_t") long value);

@NoException public static native int PyLong_AsInt32(PyObject obj, IntPointer value);
@NoException public static native int PyLong_AsInt32(PyObject obj, IntBuffer value);
@NoException public static native int PyLong_AsInt32(PyObject obj, int[] value);
@NoException public static native int PyLong_AsUInt32(PyObject obj, @Cast("uint32_t*") IntPointer value);
@NoException public static native int PyLong_AsUInt32(PyObject obj, @Cast("uint32_t*") IntBuffer value);
@NoException public static native int PyLong_AsUInt32(PyObject obj, @Cast("uint32_t*") int[] value);
@NoException public static native int PyLong_AsInt64(PyObject obj, @Cast("int64_t*") LongPointer value);
@NoException public static native int PyLong_AsInt64(PyObject obj, @Cast("int64_t*") LongBuffer value);
@NoException public static native int PyLong_AsInt64(PyObject obj, @Cast("int64_t*") long[] value);
@NoException public static native int PyLong_AsUInt64(PyObject obj, @Cast("uint64_t*") LongPointer value);
@NoException public static native int PyLong_AsUInt64(PyObject obj, @Cast("uint64_t*") LongBuffer value);
@NoException public static native int PyLong_AsUInt64(PyObject obj, @Cast("uint64_t*") long[] value);

public static final int Py_ASNATIVEBYTES_DEFAULTS = -1;
public static final int Py_ASNATIVEBYTES_BIG_ENDIAN = 0;
public static final int Py_ASNATIVEBYTES_LITTLE_ENDIAN = 1;
public static final int Py_ASNATIVEBYTES_NATIVE_ENDIAN = 3;
public static final int Py_ASNATIVEBYTES_UNSIGNED_BUFFER = 4;
public static final int Py_ASNATIVEBYTES_REJECT_NEGATIVE = 8;
public static final int Py_ASNATIVEBYTES_ALLOW_INDEX = 16;

/* PyLong_AsNativeBytes: Copy the integer value to a native variable.
   buffer points to the first byte of the variable.
   n_bytes is the number of bytes available in the buffer. Pass 0 to request
   the required size for the value.
   flags is a bitfield of the following flags:
   * 1 - little endian
   * 2 - native endian
   * 4 - unsigned destination (e.g. don't reject copying 255 into one byte)
   * 8 - raise an exception for negative inputs
   * 16 - call __index__ on non-int types
   If flags is -1 (all bits set), native endian is used, value truncation
   behaves most like C (allows negative inputs and allow MSB set), and non-int
   objects will raise a TypeError.
   Big endian mode will write the most significant byte into the address
   directly referenced by buffer; little endian will write the least significant
   byte into that address.

   If an exception is raised, returns a negative value.
   Otherwise, returns the number of bytes that are required to store the value.
   To check that the full value is represented, ensure that the return value is
   equal or less than n_bytes.
   All n_bytes are guaranteed to be written (unless an exception occurs), and
   so ignoring a positive return value is the equivalent of a downcast in C.
   In cases where the full value could not be represented, the returned value
   may be larger than necessary - this function is not an accurate way to
   calculate the bit length of an integer object.
   */
@NoException public static native @Cast("Py_ssize_t") long PyLong_AsNativeBytes(PyObject v, Pointer buffer,
    @Cast("Py_ssize_t") long n_bytes, int flags);

/* PyLong_FromNativeBytes: Create an int value from a native integer
   n_bytes is the number of bytes to read from the buffer. Passing 0 will
   always produce the zero int.
   PyLong_FromUnsignedNativeBytes always produces a non-negative int.
   flags is the same as for PyLong_AsNativeBytes, but only supports selecting
   the endianness or forcing an unsigned buffer.

   Returns the int object, or NULL with an exception set. */
@NoException public static native PyObject PyLong_FromNativeBytes(@Const Pointer buffer, @Cast("size_t") long n_bytes,
    int flags);
@NoException public static native PyObject PyLong_FromUnsignedNativeBytes(@Const Pointer buffer,
    @Cast("size_t") long n_bytes, int flags);

// #endif

@NoException public static native PyObject PyLong_GetInfo();

/* It may be useful in the future. I've added it in the PyInt -> PyLong
   cleanup to keep the extra information. [CH] */
// #define PyLong_AS_LONG(op) PyLong_AsLong(op)

/* Issue #1983: pid_t can be longer than a C long on some systems */
// #if !defined(SIZEOF_PID_T) || SIZEOF_PID_T == SIZEOF_INT
public static final String _Py_PARSE_PID = "i";
// #define PyLong_FromPid PyLong_FromLong
// # if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000
// #   define PyLong_AsPid PyLong_AsInt
// # elif SIZEOF_INT == SIZEOF_LONG
// # else
// # endif
// #elif SIZEOF_PID_T == SIZEOF_LONG
// #define PyLong_FromPid PyLong_FromLong
// #define PyLong_AsPid PyLong_AsLong
// #elif defined(SIZEOF_LONG_LONG) && SIZEOF_PID_T == SIZEOF_LONG_LONG
// #define PyLong_FromPid PyLong_FromLongLong
// #define PyLong_AsPid PyLong_AsLongLong
// #else
// #error "sizeof(pid_t) is neither sizeof(int), sizeof(long) or sizeof(long long)"
// #endif /* SIZEOF_PID_T */

// #if SIZEOF_VOID_P == SIZEOF_INT
public static final String _Py_PARSE_INTPTR = "i";
public static final String _Py_PARSE_UINTPTR = "I";
// #elif SIZEOF_VOID_P == SIZEOF_LONG
// #elif defined(SIZEOF_LONG_LONG) && SIZEOF_VOID_P == SIZEOF_LONG_LONG
// #else
// #  error "void* different in size from int, long and long long"
// #endif /* SIZEOF_VOID_P */

@NoException public static native double PyLong_AsDouble(PyObject arg0);
@NoException public static native PyObject PyLong_FromVoidPtr(Pointer arg0);
@NoException public static native Pointer PyLong_AsVoidPtr(PyObject arg0);

@NoException public static native PyObject PyLong_FromLongLong(long arg0);
@NoException public static native PyObject PyLong_FromUnsignedLongLong(@Cast("unsigned long long") long arg0);
@NoException public static native long PyLong_AsLongLong(PyObject arg0);
@NoException public static native @Cast("unsigned long long") long PyLong_AsUnsignedLongLong(PyObject arg0);
@NoException public static native @Cast("unsigned long long") long PyLong_AsUnsignedLongLongMask(PyObject arg0);
@NoException public static native long PyLong_AsLongLongAndOverflow(PyObject arg0, IntPointer arg1);
@NoException public static native long PyLong_AsLongLongAndOverflow(PyObject arg0, IntBuffer arg1);
@NoException public static native long PyLong_AsLongLongAndOverflow(PyObject arg0, int[] arg1);

@NoException public static native PyObject PyLong_FromString(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);

/* These aren't really part of the int object, but they're handy. The
   functions are in Python/mystrtoul.c.
 */
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
@NoException public static native long PyOS_strtol(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1, int arg2);
@NoException public static native long PyOS_strtol(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native long PyOS_strtol(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native long PyOS_strtol(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
@NoException public static native long PyOS_strtol(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native long PyOS_strtol(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native long PyOS_strtol(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_LONGOBJECT_H
// #  include "cpython/longobject.h"
// #  undef Py_CPYTHON_LONGOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_LONGOBJECT_H */


// Parsed from cpython/longintrepr.h

// #ifndef Py_LIMITED_API
// #ifndef Py_LONGINTREPR_H
// #define Py_LONGINTREPR_H
// #ifdef __cplusplus
// #endif


/* This is published for the benefit of "friends" marshal.c and _decimal.c. */

/* Parameters of the integer representation.  There are two different
   sets of parameters: one set for 30-bit digits, stored in an unsigned 32-bit
   integer type, and one set for 15-bit digits with each digit stored in an
   unsigned short.  The value of PYLONG_BITS_IN_DIGIT, defined either at
   configure time or in pyport.h, is used to decide which digit size to use.

   Type 'digit' should be able to hold 2*PyLong_BASE-1, and type 'twodigits'
   should be an unsigned integer type able to hold all integers up to
   PyLong_BASE*PyLong_BASE-1.  x_sub assumes that 'digit' is an unsigned type,
   and that overflow is handled by taking the result modulo 2**N for some N >
   PyLong_SHIFT.  The majority of the code doesn't care about the precise
   value of PyLong_SHIFT, but there are some notable exceptions:

   - PyLong_{As,From}ByteArray require that PyLong_SHIFT be at least 8

   - long_hash() requires that PyLong_SHIFT is *strictly* less than the number
     of bits in an unsigned long, as do the PyLong <-> long (or unsigned long)
     conversion functions

   - the Python int <-> size_t/Py_ssize_t conversion functions expect that
     PyLong_SHIFT is strictly less than the number of bits in a size_t

   - the marshal code currently expects that PyLong_SHIFT is a multiple of 15

   - NSMALLNEGINTS and NSMALLPOSINTS should be small enough to fit in a single
     digit; with the current values this forces PyLong_SHIFT >= 9

  The values 15 and 30 should fit all of the above requirements, on any
  platform.
*/

// #if PYLONG_BITS_IN_DIGIT == 30 /* signed variant of digit */ /* signed variant of twodigits */
public static final int PyLong_SHIFT =    30;
public static final int _PyLong_DECIMAL_SHIFT =   9; /* max(e such that 10**e fits in a digit) */
public static final int _PyLong_DECIMAL_BASE =    ((int)1000000000); /* 10 ** DECIMAL_SHIFT */
// #elif PYLONG_BITS_IN_DIGIT == 15 /* signed variant of digit */ /* signed variant of twodigits */ /* max(e such that 10**e fits in a digit) */ /* 10 ** DECIMAL_SHIFT */
// #else
// #error "PYLONG_BITS_IN_DIGIT should be 15 or 30"
// #endif
public static native @MemberGetter long PyLong_BASE();
public static final long PyLong_BASE = PyLong_BASE();
public static native @MemberGetter long PyLong_MASK();
public static final long PyLong_MASK = PyLong_MASK();
// Targeting ../_PyLongValue.java


// Targeting ../_longobject.java



@NoException public static native @Deprecated PyLongObject _PyLong_New(@Cast("Py_ssize_t") long arg0);

// Return a copy of src.
@NoException public static native PyObject _PyLong_Copy(PyLongObject src);

@NoException public static native @Deprecated PyLongObject _PyLong_FromDigits(
    int negative,
    @Cast("Py_ssize_t") long digit_count,
    @Cast("digit*") IntPointer digits);
@NoException public static native @Deprecated PyLongObject _PyLong_FromDigits(
    int negative,
    @Cast("Py_ssize_t") long digit_count,
    @Cast("digit*") IntBuffer digits);
@NoException public static native @Deprecated PyLongObject _PyLong_FromDigits(
    int negative,
    @Cast("Py_ssize_t") long digit_count,
    @Cast("digit*") int[] digits);


/* Inline some internals for speed. These should be in pycore_long.h
 * if user code didn't need them inlined. */

public static final int _PyLong_SIGN_MASK = 3;
public static final int _PyLong_NON_SIZE_BITS = 3;


@NoException public static native int _PyLong_IsCompact(@Const PyLongObject op);

// #define PyUnstable_Long_IsCompact _PyLong_IsCompact

@NoException public static native @Cast("Py_ssize_t") long _PyLong_CompactValue(@Const PyLongObject op);

// #define PyUnstable_Long_CompactValue _PyLong_CompactValue
// Targeting ../PyLongLayout.java



@NoException public static native @Const PyLongLayout PyLong_GetNativeLayout();
// Targeting ../PyLongExport.java



@NoException public static native int PyLong_Export(
    PyObject obj,
    PyLongExport export_long);
@NoException public static native void PyLong_FreeExport(
    PyLongExport export_long);
// Targeting ../PyLongWriter.java



@NoException public static native PyLongWriter PyLongWriter_Create(
    int negative,
    @Cast("Py_ssize_t") long ndigits,
    @Cast("void**") PointerPointer digits);
@NoException public static native PyLongWriter PyLongWriter_Create(
    int negative,
    @Cast("Py_ssize_t") long ndigits,
    @Cast("void**") @ByPtrPtr Pointer digits);
@NoException public static native PyObject PyLongWriter_Finish(PyLongWriter writer);
@NoException public static native void PyLongWriter_Discard(PyLongWriter writer);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_LONGINTREPR_H */
// #endif /* Py_LIMITED_API */


// Parsed from boolobject.h

/* Boolean object interface */

// #ifndef Py_BOOLOBJECT_H
// #define Py_BOOLOBJECT_H
// #ifdef __cplusplus
// #endif


// PyBool_Type is declared by object.h

// #define PyBool_Check(x) Py_IS_TYPE((x), &PyBool_Type)

/* Py_False and Py_True are the only two bools in existence. */

/* Don't use these directly */
public static native @ByRef PyLongObject _Py_FalseStruct(); public static native void _Py_FalseStruct(PyLongObject setter);
public static native @ByRef PyLongObject _Py_TrueStruct(); public static native void _Py_TrueStruct(PyLongObject setter);

/* Use these macros */
// #if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030D0000
// #  define Py_False Py_GetConstantBorrowed(Py_CONSTANT_FALSE)
// #  define Py_True Py_GetConstantBorrowed(Py_CONSTANT_TRUE)
// #else
// #  define Py_False _PyObject_CAST(&_Py_FalseStruct)
// #  define Py_True _PyObject_CAST(&_Py_TrueStruct)
// #endif

// Test if an object is the True singleton, the same as "x is True" in Python.
@NoException public static native int Py_IsTrue(PyObject x);
// #define Py_IsTrue(x) Py_Is((x), Py_True)

// Test if an object is the False singleton, the same as "x is False" in Python.
@NoException public static native int Py_IsFalse(PyObject x);
// #define Py_IsFalse(x) Py_Is((x), Py_False)

/* Macros for returning Py_True or Py_False, respectively.
 * Only treat Py_True and Py_False as immortal in the limited C API 3.12
 * and newer. */
// #if defined(Py_LIMITED_API) && Py_LIMITED_API+0 < 0x030c0000
// #  define Py_RETURN_TRUE return Py_NewRef(Py_True)
// #  define Py_RETURN_FALSE return Py_NewRef(Py_False)
// #else
// #  define Py_RETURN_TRUE return Py_True
// #  define Py_RETURN_FALSE return Py_False
// #endif

/* Function to return a bool from a C long */
@NoException public static native PyObject PyBool_FromLong(long arg0);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_BOOLOBJECT_H */


// Parsed from floatobject.h


/* Float object interface */

/*
PyFloatObject represents a (double precision) floating-point number.
*/

// #ifndef Py_FLOATOBJECT_H
// #define Py_FLOATOBJECT_H
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyFloat_Type(); public static native void PyFloat_Type(PyTypeObject setter);

// #define PyFloat_Check(op) PyObject_TypeCheck(op, &PyFloat_Type)
// #define PyFloat_CheckExact(op) Py_IS_TYPE((op), &PyFloat_Type)

// #define Py_RETURN_NAN return PyFloat_FromDouble(Py_NAN)

// #define Py_RETURN_INF(sign)
//     do {
//         if (copysign(1., sign) == 1.) {
//             return PyFloat_FromDouble(Py_INFINITY);
//         }
//         else {
//             return PyFloat_FromDouble(-Py_INFINITY);
//         }
//     } while(0)

@NoException public static native double PyFloat_GetMax();
@NoException public static native double PyFloat_GetMin();
@NoException public static native PyObject PyFloat_GetInfo();

/* Return Python float from string PyObject. */
@NoException public static native PyObject PyFloat_FromString(PyObject arg0);

/* Return Python float from C double. */
@NoException public static native PyObject PyFloat_FromDouble(double arg0);

/* Extract C double from Python float.  The macro version trades safety for
   speed. */
@NoException public static native double PyFloat_AsDouble(PyObject arg0);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_FLOATOBJECT_H
// #  include "cpython/floatobject.h"
// #  undef Py_CPYTHON_FLOATOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_FLOATOBJECT_H */


// Parsed from complexobject.h

/* Complex number structure */

// #ifndef Py_COMPLEXOBJECT_H
// #define Py_COMPLEXOBJECT_H
// #ifdef __cplusplus
// #endif

/* Complex object interface */

public static native @ByRef PyTypeObject PyComplex_Type(); public static native void PyComplex_Type(PyTypeObject setter);

// #define PyComplex_Check(op) PyObject_TypeCheck((op), &PyComplex_Type)
// #define PyComplex_CheckExact(op) Py_IS_TYPE((op), &PyComplex_Type)

@NoException public static native PyObject PyComplex_FromDoubles(double real, double imag);

@NoException public static native double PyComplex_RealAsDouble(PyObject op);
@NoException public static native double PyComplex_ImagAsDouble(PyObject op);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_COMPLEXOBJECT_H
// #  include "cpython/complexobject.h"
// #  undef Py_CPYTHON_COMPLEXOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_COMPLEXOBJECT_H */


// Parsed from rangeobject.h


/* Range object interface */

// #ifndef Py_RANGEOBJECT_H
// #define Py_RANGEOBJECT_H
// #ifdef __cplusplus
// #endif

/*
A range object represents an integer range.  This is an immutable object;
a range cannot change its value after creation.

Range objects behave like the corresponding tuple objects except that
they are represented by a start, stop, and step datamembers.
*/

public static native @ByRef PyTypeObject PyRange_Type(); public static native void PyRange_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyRangeIter_Type(); public static native void PyRangeIter_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyLongRangeIter_Type(); public static native void PyLongRangeIter_Type(PyTypeObject setter);

// #define PyRange_Check(op) Py_IS_TYPE((op), &PyRange_Type)

// #ifdef __cplusplus
// #endif
// #endif /* !Py_RANGEOBJECT_H */


// Parsed from memoryobject.h

/* Memory view object. In Python this is available as "memoryview". */

// #ifndef Py_MEMORYOBJECT_H
// #define Py_MEMORYOBJECT_H
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyMemoryView_Type(); public static native void PyMemoryView_Type(PyTypeObject setter);

// #define PyMemoryView_Check(op) Py_IS_TYPE((op), &PyMemoryView_Type)

@NoException public static native PyObject PyMemoryView_FromObject(PyObject base);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyMemoryView_FromMemory(@Cast("char*") BytePointer mem, @Cast("Py_ssize_t") long size,
                                               int flags);
@NoException public static native PyObject PyMemoryView_FromMemory(@Cast("char*") ByteBuffer mem, @Cast("Py_ssize_t") long size,
                                               int flags);
@NoException public static native PyObject PyMemoryView_FromMemory(@Cast("char*") byte[] mem, @Cast("Py_ssize_t") long size,
                                               int flags);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030b0000
@NoException public static native PyObject PyMemoryView_FromBuffer(@Const Py_buffer info);
// #endif
@NoException public static native PyObject PyMemoryView_GetContiguous(PyObject base,
                                                  int buffertype,
                                                  @Cast("char") byte order);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_MEMORYOBJECT_H
// #  include "cpython/memoryobject.h"
// #  undef Py_CPYTHON_MEMORYOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_MEMORYOBJECT_H */


// Parsed from tupleobject.h

/* Tuple object interface */

// #ifndef Py_TUPLEOBJECT_H
// #define Py_TUPLEOBJECT_H
// #ifdef __cplusplus
// #endif

/*
Another generally useful object type is a tuple of object pointers.
For Python, this is an immutable type.  C code can change the tuple items
(but not their number), and even use tuples as general-purpose arrays of
object references, but in general only brand new tuples should be mutated,
not ones that might already have been exposed to Python code.

*** WARNING *** PyTuple_SetItem does not increment the new item's reference
count, but does decrement the reference count of the item it replaces,
if not nil.  It does *decrement* the reference count if it is *not*
inserted in the tuple.  Similarly, PyTuple_GetItem does not increment the
returned item's reference count.
*/

public static native @ByRef PyTypeObject PyTuple_Type(); public static native void PyTuple_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyTupleIter_Type(); public static native void PyTupleIter_Type(PyTypeObject setter);

// #define PyTuple_Check(op)
//                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TUPLE_SUBCLASS)
// #define PyTuple_CheckExact(op) Py_IS_TYPE((op), &PyTuple_Type)

@NoException public static native PyObject PyTuple_New(@Cast("Py_ssize_t") long size);
@NoException public static native @Cast("Py_ssize_t") long PyTuple_Size(PyObject arg0);
@NoException public static native PyObject PyTuple_GetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int PyTuple_SetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1, PyObject arg2);
@NoException public static native PyObject PyTuple_GetSlice(PyObject arg0, @Cast("Py_ssize_t") long arg1, @Cast("Py_ssize_t") long arg2);
@NoException public static native PyObject PyTuple_Pack(@Cast("Py_ssize_t") long arg0);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_TUPLEOBJECT_H
// #  include "cpython/tupleobject.h"
// #  undef Py_CPYTHON_TUPLEOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_TUPLEOBJECT_H */


// Parsed from cpython/tupleobject.h

// #ifndef Py_CPYTHON_TUPLEOBJECT_H
// #  error "this header file must not be included directly"
// Targeting ../PyTupleObject.java



@NoException public static native int _PyTuple_Resize(@Cast("PyObject**") PointerPointer arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int _PyTuple_Resize(@ByPtrPtr PyObject arg0, @Cast("Py_ssize_t") long arg1);

/* Cast argument to PyTupleObject* type. */
// #define _PyTuple_CAST(op)
//     (assert(PyTuple_Check(op)), _Py_CAST(PyTupleObject*, (op)))

// Macros and static inline functions, trading safety for speed

@NoException public static native @Cast("Py_ssize_t") long PyTuple_GET_SIZE(PyObject op);
// #define PyTuple_GET_SIZE(op) PyTuple_GET_SIZE(_PyObject_CAST(op))

// #define PyTuple_GET_ITEM(op, index) (_PyTuple_CAST(op)->ob_item[(index)])

/* Function *only* to be used to fill in brand new tuples */
@NoException public static native void PyTuple_SET_ITEM(PyObject op, @Cast("Py_ssize_t") long index, PyObject value);
// #define PyTuple_SET_ITEM(op, index, value)
//     PyTuple_SET_ITEM(_PyObject_CAST(op), (index), _PyObject_CAST(value))


// Parsed from listobject.h

/* List object interface

   Another generally useful object type is a list of object pointers.
   This is a mutable type: the list items can be changed, and items can be
   added or removed. Out-of-range indices or non-list objects are ignored.

   WARNING: PyList_SetItem does not increment the new item's reference count,
   but does decrement the reference count of the item it replaces, if not nil.
   It does *decrement* the reference count if it is *not* inserted in the list.
   Similarly, PyList_GetItem does not increment the returned item's reference
   count.
*/

// #ifndef Py_LISTOBJECT_H
// #define Py_LISTOBJECT_H
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyList_Type(); public static native void PyList_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyListIter_Type(); public static native void PyListIter_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyListRevIter_Type(); public static native void PyListRevIter_Type(PyTypeObject setter);

// #define PyList_Check(op)
//     PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_LIST_SUBCLASS)
// #define PyList_CheckExact(op) Py_IS_TYPE((op), &PyList_Type)

@NoException public static native PyObject PyList_New(@Cast("Py_ssize_t") long size);
@NoException public static native @Cast("Py_ssize_t") long PyList_Size(PyObject arg0);

@NoException public static native PyObject PyList_GetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000
@NoException public static native PyObject PyList_GetItemRef(PyObject arg0, @Cast("Py_ssize_t") long arg1);
// #endif
@NoException public static native int PyList_SetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1, PyObject arg2);
@NoException public static native int PyList_Insert(PyObject arg0, @Cast("Py_ssize_t") long arg1, PyObject arg2);
@NoException public static native int PyList_Append(PyObject arg0, PyObject arg1);

@NoException public static native PyObject PyList_GetSlice(PyObject arg0, @Cast("Py_ssize_t") long arg1, @Cast("Py_ssize_t") long arg2);
@NoException public static native int PyList_SetSlice(PyObject arg0, @Cast("Py_ssize_t") long arg1, @Cast("Py_ssize_t") long arg2, PyObject arg3);

@NoException public static native int PyList_Sort(PyObject arg0);
@NoException public static native int PyList_Reverse(PyObject arg0);
@NoException public static native PyObject PyList_AsTuple(PyObject arg0);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_LISTOBJECT_H
// #  include "cpython/listobject.h"
// #  undef Py_CPYTHON_LISTOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_LISTOBJECT_H */


// Parsed from cpython/listobject.h

// #ifndef Py_CPYTHON_LISTOBJECT_H
// #  error "this header file must not be included directly"
// Targeting ../PyListObject.java



/* Cast argument to PyListObject* type. */
// #define _PyList_CAST(op)
//     (assert(PyList_Check(op)), _Py_CAST(PyListObject*, (op)))

// Macros and static inline functions, trading safety for speed

@NoException public static native @Cast("Py_ssize_t") long PyList_GET_SIZE(PyObject op);
// #define PyList_GET_SIZE(op) PyList_GET_SIZE(_PyObject_CAST(op))

// #define PyList_GET_ITEM(op, index) (_PyList_CAST(op)->ob_item[(index)])

@NoException public static native void PyList_SET_ITEM(PyObject op, @Cast("Py_ssize_t") long index, PyObject value);
// #define PyList_SET_ITEM(op, index, value)
//     PyList_SET_ITEM(_PyObject_CAST(op), (index), _PyObject_CAST(value))

@NoException public static native int PyList_Extend(PyObject self, PyObject iterable);
@NoException public static native int PyList_Clear(PyObject self);


// Parsed from dictobject.h

// #ifndef Py_DICTOBJECT_H
// #define Py_DICTOBJECT_H
// #ifdef __cplusplus
// #endif

/* Dictionary object type -- mapping from hashable object to object */

/* The distribution includes a separate file, Objects/dictnotes.txt,
   describing explorations into dictionary design and optimization.
   It covers typical dictionary use patterns, the parameters for
   tuning dictionaries, and several ideas for possible optimizations.
*/

public static native @ByRef PyTypeObject PyDict_Type(); public static native void PyDict_Type(PyTypeObject setter);

// #define PyDict_Check(op)
//                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_DICT_SUBCLASS)
// #define PyDict_CheckExact(op) Py_IS_TYPE((op), &PyDict_Type)

@NoException public static native PyObject PyDict_New();
@NoException public static native PyObject PyDict_GetItem(PyObject mp, PyObject key);
@NoException public static native PyObject PyDict_GetItemWithError(PyObject mp, PyObject key);
@NoException public static native int PyDict_SetItem(PyObject mp, PyObject key, PyObject item);
@NoException public static native int PyDict_DelItem(PyObject mp, PyObject key);
@NoException public static native void PyDict_Clear(PyObject mp);
@NoException public static native int PyDict_Next(
    PyObject mp, @Cast("Py_ssize_t*") SizeTPointer pos, @Cast("PyObject**") PointerPointer key, @Cast("PyObject**") PointerPointer value);
@NoException public static native int PyDict_Next(
    PyObject mp, @Cast("Py_ssize_t*") SizeTPointer pos, @ByPtrPtr PyObject key, @ByPtrPtr PyObject value);
@NoException public static native PyObject PyDict_Keys(PyObject mp);
@NoException public static native PyObject PyDict_Values(PyObject mp);
@NoException public static native PyObject PyDict_Items(PyObject mp);
@NoException public static native @Cast("Py_ssize_t") long PyDict_Size(PyObject mp);
@NoException public static native PyObject PyDict_Copy(PyObject mp);
@NoException public static native int PyDict_Contains(PyObject mp, PyObject key);

/* PyDict_Update(mp, other) is equivalent to PyDict_Merge(mp, other, 1). */
@NoException public static native int PyDict_Update(PyObject mp, PyObject other);

/* PyDict_Merge updates/merges from a mapping object (an object that
   supports PyMapping_Keys() and PyObject_GetItem()).  If override is true,
   the last occurrence of a key wins, else the first.  The Python
   dict.update(other) is equivalent to PyDict_Merge(dict, other, 1).
*/
@NoException public static native int PyDict_Merge(PyObject mp,
                             PyObject other,
                             int override);

/* PyDict_MergeFromSeq2 updates/merges from an iterable object producing
   iterable objects of length 2.  If override is true, the last occurrence
   of a key wins, else the first.  The Python dict constructor dict(seq2)
   is equivalent to dict={}; PyDict_MergeFromSeq(dict, seq2, 1).
*/
@NoException public static native int PyDict_MergeFromSeq2(PyObject d,
                                     PyObject seq2,
                                     int override);

@NoException public static native PyObject PyDict_GetItemString(PyObject dp, @Cast("const char*") BytePointer key);
@NoException public static native PyObject PyDict_GetItemString(PyObject dp, String key);
@NoException public static native int PyDict_SetItemString(PyObject dp, @Cast("const char*") BytePointer key, PyObject item);
@NoException public static native int PyDict_SetItemString(PyObject dp, String key, PyObject item);
@NoException public static native int PyDict_DelItemString(PyObject dp, @Cast("const char*") BytePointer key);
@NoException public static native int PyDict_DelItemString(PyObject dp, String key);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030D0000
// Return the object from dictionary *op* which has a key *key*.
// - If the key is present, set *result to a new strong reference to the value
//   and return 1.
// - If the key is missing, set *result to NULL and return 0 .
// - On error, raise an exception and return -1.
@NoException public static native int PyDict_GetItemRef(PyObject mp, PyObject key, @Cast("PyObject**") PointerPointer result);
@NoException public static native int PyDict_GetItemRef(PyObject mp, PyObject key, @ByPtrPtr PyObject result);
@NoException public static native int PyDict_GetItemStringRef(PyObject mp, @Cast("const char*") BytePointer key, @Cast("PyObject**") PointerPointer result);
@NoException public static native int PyDict_GetItemStringRef(PyObject mp, @Cast("const char*") BytePointer key, @ByPtrPtr PyObject result);
@NoException public static native int PyDict_GetItemStringRef(PyObject mp, String key, @ByPtrPtr PyObject result);
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
@NoException public static native PyObject PyObject_GenericGetDict(PyObject arg0, Pointer arg1);
// #endif

/* Dictionary (keys, values, items) views */

public static native @ByRef PyTypeObject PyDictKeys_Type(); public static native void PyDictKeys_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyDictValues_Type(); public static native void PyDictValues_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyDictItems_Type(); public static native void PyDictItems_Type(PyTypeObject setter);

// #define PyDictKeys_Check(op) PyObject_TypeCheck((op), &PyDictKeys_Type)
// #define PyDictValues_Check(op) PyObject_TypeCheck((op), &PyDictValues_Type)
// #define PyDictItems_Check(op) PyObject_TypeCheck((op), &PyDictItems_Type)
/* This excludes Values, since they are not sets. */
// # define PyDictViewSet_Check(op)
//     (PyDictKeys_Check(op) || PyDictItems_Check(op))

/* Dictionary (key, value, items) iterators */

public static native @ByRef PyTypeObject PyDictIterKey_Type(); public static native void PyDictIterKey_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyDictIterValue_Type(); public static native void PyDictIterValue_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyDictIterItem_Type(); public static native void PyDictIterItem_Type(PyTypeObject setter);

public static native @ByRef PyTypeObject PyDictRevIterKey_Type(); public static native void PyDictRevIterKey_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyDictRevIterItem_Type(); public static native void PyDictRevIterItem_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyDictRevIterValue_Type(); public static native void PyDictRevIterValue_Type(PyTypeObject setter);


// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_DICTOBJECT_H
// #  include "cpython/dictobject.h"
// #  undef Py_CPYTHON_DICTOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_DICTOBJECT_H */


// Parsed from cpython/dictobject.h

// #ifndef Py_CPYTHON_DICTOBJECT_H
// #  error "this header file must not be included directly"
// Targeting ../PyDictKeysObject.java


// Targeting ../PyDictValues.java


// Targeting ../PyDictObject.java



@NoException public static native PyObject _PyDict_GetItem_KnownHash(PyObject mp, PyObject key,
                                                 @Cast("Py_hash_t") long hash);
// PyDict_GetItemStringRef() can be used instead
@NoException public static native @Deprecated PyObject _PyDict_GetItemStringWithError(PyObject arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native @Deprecated PyObject _PyDict_GetItemStringWithError(PyObject arg0, String arg1);
@NoException public static native PyObject PyDict_SetDefault(
    PyObject mp, PyObject key, PyObject defaultobj);

// Inserts `key` with a value `default_value`, if `key` is not already present
// in the dictionary.  If `result` is not NULL, then the value associated
// with `key` is returned in `*result` (either the existing value, or the now
// inserted `default_value`).
// Returns:
//   -1 on error
//    0 if `key` was not present and `default_value` was inserted
//    1 if `key` was present and `default_value` was not inserted
@NoException public static native int PyDict_SetDefaultRef(PyObject mp, PyObject key, PyObject default_value, @Cast("PyObject**") PointerPointer result);
@NoException public static native int PyDict_SetDefaultRef(PyObject mp, PyObject key, PyObject default_value, @ByPtrPtr PyObject result);

/* Get the number of items of a dictionary. */
@NoException public static native @Cast("Py_ssize_t") long PyDict_GET_SIZE(PyObject op);
// #define PyDict_GET_SIZE(op) PyDict_GET_SIZE(_PyObject_CAST(op))

@NoException public static native int PyDict_ContainsString(PyObject mp, @Cast("const char*") BytePointer key);
@NoException public static native int PyDict_ContainsString(PyObject mp, String key);

@NoException public static native PyObject _PyDict_NewPresized(@Cast("Py_ssize_t") long minused);

@NoException public static native int PyDict_Pop(PyObject dict, PyObject key, @Cast("PyObject**") PointerPointer result);
@NoException public static native int PyDict_Pop(PyObject dict, PyObject key, @ByPtrPtr PyObject result);
@NoException public static native int PyDict_PopString(PyObject dict, @Cast("const char*") BytePointer key, @Cast("PyObject**") PointerPointer result);
@NoException public static native int PyDict_PopString(PyObject dict, @Cast("const char*") BytePointer key, @ByPtrPtr PyObject result);
@NoException public static native int PyDict_PopString(PyObject dict, String key, @ByPtrPtr PyObject result);

// Use PyDict_Pop() instead
@NoException public static native @Deprecated PyObject _PyDict_Pop(
    PyObject dict,
    PyObject key,
    PyObject default_value);

/* Dictionary watchers */

// #define PY_FOREACH_DICT_EVENT(V)
//     V(ADDED)
//     V(MODIFIED)
//     V(DELETED)
//     V(CLONED)
//     V(CLEARED)
//     V(DEALLOCATED)

/** enum PyDict_WatchEvent */

//     #define PY_DEF_EVENT(EVENT) PyDict_EVENT_##EVENT,
public static final int
    PyDict_EVENT_ADDED = 0,
    PyDict_EVENT_MODIFIED = 1,
    PyDict_EVENT_DELETED = 2,
    PyDict_EVENT_CLONED = 3,
    PyDict_EVENT_CLEARED = 4,
    PyDict_EVENT_DEALLOCATED = 5;
//     #undef PY_DEF_EVENT
// Targeting ../PyDict_WatchCallback.java



// Register/unregister a dict-watcher callback
@NoException public static native int PyDict_AddWatcher(PyDict_WatchCallback callback);
@NoException public static native int PyDict_ClearWatcher(int watcher_id);

// Mark given dictionary as "watched" (callback will be called if it is modified)
@NoException public static native int PyDict_Watch(int watcher_id, PyObject dict);
@NoException public static native int PyDict_Unwatch(int watcher_id, PyObject dict);


// Parsed from structmember.h

// #ifndef Py_STRUCTMEMBER_H
// #define Py_STRUCTMEMBER_H
// #ifdef __cplusplus
// #endif


/* Interface to map C struct members to Python object attributes
 *
 * This header is deprecated: new code should not use stuff from here.
 * New definitions are in descrobject.h.
 *
 * However, there's nothing wrong with old code continuing to use it,
 * and there's not much maintenance overhead in maintaining a few aliases.
 * So, don't be too eager to convert old code.
 *
 * It uses names not prefixed with Py_.
 * It is also *not* included from Python.h and must be included individually.
 */

// #include <stddef.h> /* For offsetof (not always provided by Python.h) */

/* Types */
public static final int T_SHORT =     Py_T_SHORT;
public static final int T_INT =       Py_T_INT;
public static final int T_LONG =      Py_T_LONG;
public static final int T_FLOAT =     Py_T_FLOAT;
public static final int T_DOUBLE =    Py_T_DOUBLE;
public static final int T_STRING =    Py_T_STRING;
public static final int T_OBJECT =    _Py_T_OBJECT;
public static final int T_CHAR =      Py_T_CHAR;
public static final int T_BYTE =      Py_T_BYTE;
public static final int T_UBYTE =     Py_T_UBYTE;
public static final int T_USHORT =    Py_T_USHORT;
public static final int T_UINT =      Py_T_UINT;
public static final int T_ULONG =     Py_T_ULONG;
public static final int T_STRING_INPLACE =    Py_T_STRING_INPLACE;
public static final int T_BOOL =      Py_T_BOOL;
public static final int T_OBJECT_EX = Py_T_OBJECT_EX;
public static final int T_LONGLONG =  Py_T_LONGLONG;
public static final int T_ULONGLONG = Py_T_ULONGLONG;
public static final int T_PYSSIZET =  Py_T_PYSSIZET;
public static final int T_NONE =      _Py_T_NONE;

/* Flags */
public static final int READONLY =            Py_READONLY;
public static final int PY_AUDIT_READ =        Py_AUDIT_READ;
public static final int READ_RESTRICTED =     Py_AUDIT_READ;
public static final int PY_WRITE_RESTRICTED = _Py_WRITE_RESTRICTED;
public static final int RESTRICTED =          (READ_RESTRICTED | PY_WRITE_RESTRICTED);


// #ifdef __cplusplus
// #endif
// #endif /* !Py_STRUCTMEMBER_H */


// Parsed from cpython/odictobject.h

// #ifndef Py_ODICTOBJECT_H
// #define Py_ODICTOBJECT_H
// #ifdef __cplusplus
// Targeting ../PyODictObject.java



public static native @ByRef PyTypeObject PyODict_Type(); public static native void PyODict_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyODictIter_Type(); public static native void PyODictIter_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyODictKeys_Type(); public static native void PyODictKeys_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyODictItems_Type(); public static native void PyODictItems_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyODictValues_Type(); public static native void PyODictValues_Type(PyTypeObject setter);

// #define PyODict_Check(op) PyObject_TypeCheck((op), &PyODict_Type)
// #define PyODict_CheckExact(op) Py_IS_TYPE((op), &PyODict_Type)
// #define PyODict_SIZE(op) PyDict_GET_SIZE((op))

@NoException public static native PyObject PyODict_New();
@NoException public static native int PyODict_SetItem(PyObject od, PyObject key, PyObject item);
@NoException public static native int PyODict_DelItem(PyObject od, PyObject key);

/* wrappers around PyDict* functions */
// #define PyODict_GetItem(od, key) PyDict_GetItem(_PyObject_CAST(od), (key))
// #define PyODict_GetItemWithError(od, key)
//     PyDict_GetItemWithError(_PyObject_CAST(od), (key))
// #define PyODict_Contains(od, key) PyDict_Contains(_PyObject_CAST(od), (key))
// #define PyODict_Size(od) PyDict_Size(_PyObject_CAST(od))
// #define PyODict_GetItemString(od, key)
//     PyDict_GetItemString(_PyObject_CAST(od), (key))

// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_ODICTOBJECT_H */


// Parsed from enumobject.h

// #ifndef Py_ENUMOBJECT_H
// #define Py_ENUMOBJECT_H

/* Enumerate Object */

// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyEnum_Type(); public static native void PyEnum_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyReversed_Type(); public static native void PyReversed_Type(PyTypeObject setter);

// #ifdef __cplusplus
// #endif

// #endif /* !Py_ENUMOBJECT_H */


// Parsed from setobject.h

/* Set object interface */

// #ifndef Py_SETOBJECT_H
// #define Py_SETOBJECT_H
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PySet_Type(); public static native void PySet_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyFrozenSet_Type(); public static native void PyFrozenSet_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PySetIter_Type(); public static native void PySetIter_Type(PyTypeObject setter);

@NoException public static native PyObject PySet_New(PyObject arg0);
@NoException public static native PyObject PyFrozenSet_New(PyObject arg0);

@NoException public static native int PySet_Add(PyObject set, PyObject key);
@NoException public static native int PySet_Clear(PyObject set);
@NoException public static native int PySet_Contains(PyObject anyset, PyObject key);
@NoException public static native int PySet_Discard(PyObject set, PyObject key);
@NoException public static native PyObject PySet_Pop(PyObject set);
@NoException public static native @Cast("Py_ssize_t") long PySet_Size(PyObject anyset);

// #define PyFrozenSet_CheckExact(ob) Py_IS_TYPE((ob), &PyFrozenSet_Type)
// #define PyFrozenSet_Check(ob)
//     (Py_IS_TYPE((ob), &PyFrozenSet_Type) ||
//       PyType_IsSubtype(Py_TYPE(ob), &PyFrozenSet_Type))

// #define PyAnySet_CheckExact(ob)
//     (Py_IS_TYPE((ob), &PySet_Type) || Py_IS_TYPE((ob), &PyFrozenSet_Type))
// #define PyAnySet_Check(ob)
//     (Py_IS_TYPE((ob), &PySet_Type) || Py_IS_TYPE((ob), &PyFrozenSet_Type) ||
//       PyType_IsSubtype(Py_TYPE(ob), &PySet_Type) ||
//       PyType_IsSubtype(Py_TYPE(ob), &PyFrozenSet_Type))

// #define PySet_CheckExact(op) Py_IS_TYPE(op, &PySet_Type)
// #define PySet_Check(ob)
//     (Py_IS_TYPE((ob), &PySet_Type) ||
//     PyType_IsSubtype(Py_TYPE(ob), &PySet_Type))

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_SETOBJECT_H
// #  include "cpython/setobject.h"
// #  undef Py_CPYTHON_SETOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_SETOBJECT_H */


// Parsed from methodobject.h


/* Method object interface */

// #ifndef Py_METHODOBJECT_H
// #define Py_METHODOBJECT_H
// #ifdef __cplusplus
// #endif

/* This is about the type 'builtin_function_or_method',
   not Python methods in user-defined classes.  See classobject.h
   for the latter. */

public static native @ByRef PyTypeObject PyCFunction_Type(); public static native void PyCFunction_Type(PyTypeObject setter);

// #define PyCFunction_CheckExact(op) Py_IS_TYPE((op), &PyCFunction_Type)
// #define PyCFunction_Check(op) PyObject_TypeCheck((op), &PyCFunction_Type)
// Targeting ../PyCFunction.java


// Targeting ../PyCFunctionFast.java


// Targeting ../PyCFunctionWithKeywords.java


// Targeting ../PyCFunctionFastWithKeywords.java


// Targeting ../PyCMethod.java



// For backwards compatibility. `METH_FASTCALL` was added to the stable API in
// 3.10 alongside `_PyCFunctionFastWithKeywords` and `_PyCFunctionFast`.
// Note that the underscore-prefixed names were documented in public docs;
// people may be using them.

// Cast a function to the PyCFunction type to use it with PyMethodDef.
//
// This macro can be used to prevent compiler warnings if the first parameter
// uses a different pointer type than PyObject* (ex: METH_VARARGS and METH_O
// calling conventions).
//
// The macro can also be used for METH_FASTCALL and METH_VARARGS|METH_KEYWORDS
// calling conventions to avoid compiler warnings because the function has more
// than 2 parameters. The macro first casts the function to the
// "void func(void)" type to prevent compiler warnings.
//
// If a function is declared with the METH_NOARGS calling convention, it must
// have 2 parameters. Since the second parameter is unused, Py_UNUSED() can be
// used to prevent a compiler warning. If the function has a single parameter,
// it triggers an undefined behavior when Python calls it with 2 parameters
// (bpo-33012).
// #define _PyCFunction_CAST(func)
//     _Py_FUNC_CAST(PyCFunction, func)
// The macros below are given for semantic convenience, allowing users
// to see whether a cast to suppress an undefined behavior is necessary.
// Note: At runtime, the original function signature must be respected.
// #define _PyCFunctionFast_CAST(func)
//     _Py_FUNC_CAST(PyCFunctionFast, func)
// #define _PyCFunctionWithKeywords_CAST(func)
//     _Py_FUNC_CAST(PyCFunctionWithKeywords, func)
// #define _PyCFunctionFastWithKeywords_CAST(func)
//     _Py_FUNC_CAST(PyCFunctionFastWithKeywords, func)

@NoException public static native PyCFunction PyCFunction_GetFunction(PyObject arg0);
@NoException public static native PyObject PyCFunction_GetSelf(PyObject arg0);
@NoException public static native int PyCFunction_GetFlags(PyObject arg0);
// Targeting ../PyMethodDef.java



/* PyCFunction_New is declared as a function for stable ABI (declaration is
 * needed for e.g. GCC with -fvisibility=hidden), but redefined as a macro
 * that calls PyCFunction_NewEx. */
@NoException public static native PyObject PyCFunction_New(PyMethodDef arg0, PyObject arg1);
// #define PyCFunction_New(ML, SELF) PyCFunction_NewEx((ML), (SELF), NULL)

/* PyCFunction_NewEx is similar: on 3.9+, this calls PyCMethod_New. */
@NoException public static native PyObject PyCFunction_NewEx(PyMethodDef arg0, PyObject arg1,
                                         PyObject arg2);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
// #define PyCFunction_NewEx(ML, SELF, MOD) PyCMethod_New((ML), (SELF), (MOD), NULL)
@NoException public static native PyObject PyCMethod_New(PyMethodDef arg0, PyObject arg1,
                                     PyObject arg2, PyTypeObject arg3);
// #endif


/* Flag passed to newmethodobject */
/* #define METH_OLDARGS  0x0000   -- unsupported now */
public static final int METH_VARARGS =  0x0001;
public static final int METH_KEYWORDS = 0x0002;
/* METH_NOARGS and METH_O must not be combined with the flags above. */
public static final int METH_NOARGS =   0x0004;
public static final int METH_O =        0x0008;

/* METH_CLASS and METH_STATIC are a little different; these control
   the construction of methods for a class.  These cannot be used for
   functions in modules. */
public static final int METH_CLASS =    0x0010;
public static final int METH_STATIC =   0x0020;

/* METH_COEXIST allows a method to be entered even though a slot has
   already filled the entry.  When defined, the flag allows a separate
   method, "__contains__" for example, to coexist with a defined
   slot like sq_contains. */

public static final int METH_COEXIST =   0x0040;

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030a0000
public static final int METH_FASTCALL =  0x0080;
// #endif

/* This bit is preserved for Stackless Python */
// #ifdef STACKLESS
public static final int METH_STACKLESS = 0x0100;
// #else
// #endif

/* METH_METHOD means the function stores an
 * additional reference to the class that defines it;
 * both self and class are passed to it.
 * It uses PyCMethodObject instead of PyCFunctionObject.
 * May not be combined with METH_NOARGS, METH_O, METH_CLASS or METH_STATIC.
 */

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
public static final int METH_METHOD = 0x0200;
// #endif


// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_METHODOBJECT_H
// #  include "cpython/methodobject.h"
// #  undef Py_CPYTHON_METHODOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_METHODOBJECT_H */


// Parsed from cpython/methodobject.h

// #ifndef Py_CPYTHON_METHODOBJECT_H
// #  error "this header file must not be included directly"
// Targeting ../PyCFunctionObject.java



// #define _PyCFunctionObject_CAST(func)
//     (assert(PyCFunction_Check(func)),
//      _Py_CAST(PyCFunctionObject*, (func)))
// Targeting ../PyCMethodObject.java



// #define _PyCMethodObject_CAST(func)
//     (assert(PyCMethod_Check(func)),
//      _Py_CAST(PyCMethodObject*, (func)))

public static native @ByRef PyTypeObject PyCMethod_Type(); public static native void PyCMethod_Type(PyTypeObject setter);

// #define PyCMethod_CheckExact(op) Py_IS_TYPE((op), &PyCMethod_Type)
// #define PyCMethod_Check(op) PyObject_TypeCheck((op), &PyCMethod_Type)


/* Static inline functions for direct access to these values.
   Type checks are *not* done, so use with care. */
@NoException public static native PyCFunction PyCFunction_GET_FUNCTION(PyObject func);
// #define PyCFunction_GET_FUNCTION(func) PyCFunction_GET_FUNCTION(_PyObject_CAST(func))

@NoException public static native PyObject PyCFunction_GET_SELF(PyObject func_obj);
// #define PyCFunction_GET_SELF(func) PyCFunction_GET_SELF(_PyObject_CAST(func))

@NoException public static native int PyCFunction_GET_FLAGS(PyObject func);
// #define PyCFunction_GET_FLAGS(func) PyCFunction_GET_FLAGS(_PyObject_CAST(func))

@NoException public static native PyTypeObject PyCFunction_GET_CLASS(PyObject func_obj);
// #define PyCFunction_GET_CLASS(func) PyCFunction_GET_CLASS(_PyObject_CAST(func))


// Parsed from moduleobject.h


/* Module object interface */

// #ifndef Py_MODULEOBJECT_H
// #define Py_MODULEOBJECT_H
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyModule_Type(); public static native void PyModule_Type(PyTypeObject setter);

// #define PyModule_Check(op) PyObject_TypeCheck((op), &PyModule_Type)
// #define PyModule_CheckExact(op) Py_IS_TYPE((op), &PyModule_Type)

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyModule_NewObject(
    PyObject name
    );
// #endif
@NoException public static native PyObject PyModule_New(
    @Cast("const char*") BytePointer name
    );
@NoException public static native PyObject PyModule_New(
    String name
    );
@NoException public static native PyObject PyModule_GetDict(PyObject arg0);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyModule_GetNameObject(PyObject arg0);
// #endif
@NoException public static native @Cast("const char*") BytePointer PyModule_GetName(PyObject arg0);
@NoException public static native @Deprecated @Cast("const char*") BytePointer PyModule_GetFilename(PyObject arg0);
@NoException public static native PyObject PyModule_GetFilenameObject(PyObject arg0);
@NoException public static native PyModuleDef PyModule_GetDef(PyObject arg0);
@NoException public static native Pointer PyModule_GetState(PyObject arg0);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* New in 3.5 */
@NoException public static native PyObject PyModuleDef_Init(PyModuleDef arg0);
public static native @ByRef PyTypeObject PyModuleDef_Type(); public static native void PyModuleDef_Type(PyTypeObject setter);
// Targeting ../PyModuleDef_Base.java



// #define PyModuleDef_HEAD_INIT {
//     PyObject_HEAD_INIT(_Py_NULL)
//     _Py_NULL, /* m_init */
//     0,        /* m_index */
//     _Py_NULL, /* m_copy */
//   }
// Targeting ../PyModuleDef_Slot.java



public static final int Py_mod_create = 1;
public static final int Py_mod_exec = 2;
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030c0000
public static final int Py_mod_multiple_interpreters = 3;
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000
public static final int Py_mod_gil = 4;
// #endif


// #ifndef Py_LIMITED_API
public static final int _Py_mod_LAST_SLOT = 4;
// #endif

// #endif /* New in 3.5 */

/* for Py_mod_multiple_interpreters: */
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030c0000
public static native @MemberGetter Pointer Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED();
public static final Pointer Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED = Py_MOD_MULTIPLE_INTERPRETERS_NOT_SUPPORTED();
public static native @MemberGetter Pointer Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED();
public static final Pointer Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED = Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED();
public static native @MemberGetter Pointer Py_MOD_PER_INTERPRETER_GIL_SUPPORTED();
public static final Pointer Py_MOD_PER_INTERPRETER_GIL_SUPPORTED = Py_MOD_PER_INTERPRETER_GIL_SUPPORTED();
// #endif

/* for Py_mod_gil: */
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000
public static native @MemberGetter Pointer Py_MOD_GIL_USED();
public static final Pointer Py_MOD_GIL_USED = Py_MOD_GIL_USED();
public static native @MemberGetter Pointer Py_MOD_GIL_NOT_USED();
public static final Pointer Py_MOD_GIL_NOT_USED = Py_MOD_GIL_NOT_USED();
// Targeting ../PyModuleDef.java



// #ifdef __cplusplus
// #endif
// #endif /* !Py_MODULEOBJECT_H */


// Parsed from cpython/funcobject.h

/* Function object interface */

// #ifndef Py_LIMITED_API
// #ifndef Py_FUNCOBJECT_H
// #define Py_FUNCOBJECT_H
// #ifdef __cplusplus
// #endif


// #define _Py_COMMON_FIELDS(PREFIX)
//     PyObject *PREFIX ## globals;
//     PyObject *PREFIX ## builtins;
//     PyObject *PREFIX ## name;
//     PyObject *PREFIX ## qualname;
//     PyObject *PREFIX ## code;        /* A code object, the __code__ attribute */
//     PyObject *PREFIX ## defaults;    /* NULL or a tuple */
//     PyObject *PREFIX ## kwdefaults;  /* NULL or a dict */
//     PyObject *PREFIX ## closure;
// Targeting ../PyFrameConstructor.java


// Targeting ../PyFunctionObject.java



// #undef _Py_COMMON_FIELDS

public static native @ByRef PyTypeObject PyFunction_Type(); public static native void PyFunction_Type(PyTypeObject setter);

// #define PyFunction_Check(op) Py_IS_TYPE((op), &PyFunction_Type)

@NoException public static native PyObject PyFunction_New(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyFunction_NewWithQualName(PyObject arg0, PyObject arg1, PyObject arg2);
@NoException public static native PyObject PyFunction_GetCode(PyObject arg0);
@NoException public static native PyObject PyFunction_GetGlobals(PyObject arg0);
@NoException public static native PyObject PyFunction_GetModule(PyObject arg0);
@NoException public static native PyObject PyFunction_GetDefaults(PyObject arg0);
@NoException public static native int PyFunction_SetDefaults(PyObject arg0, PyObject arg1);
@NoException public static native void PyFunction_SetVectorcall(PyFunctionObject arg0, vectorcallfunc arg1);
@NoException public static native PyObject PyFunction_GetKwDefaults(PyObject arg0);
@NoException public static native int PyFunction_SetKwDefaults(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyFunction_GetClosure(PyObject arg0);
@NoException public static native int PyFunction_SetClosure(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyFunction_GetAnnotations(PyObject arg0);
@NoException public static native int PyFunction_SetAnnotations(PyObject arg0, PyObject arg1);

// #define _PyFunction_CAST(func)
//     (assert(PyFunction_Check(func)), _Py_CAST(PyFunctionObject*, func))

/* Static inline functions for direct access to these values.
   Type checks are *not* done, so use with care. */
@NoException public static native PyObject PyFunction_GET_CODE(PyObject func);
// #define PyFunction_GET_CODE(func) PyFunction_GET_CODE(_PyObject_CAST(func))

@NoException public static native PyObject PyFunction_GET_GLOBALS(PyObject func);
// #define PyFunction_GET_GLOBALS(func) PyFunction_GET_GLOBALS(_PyObject_CAST(func))

@NoException public static native PyObject PyFunction_GET_MODULE(PyObject func);
// #define PyFunction_GET_MODULE(func) PyFunction_GET_MODULE(_PyObject_CAST(func))

@NoException public static native PyObject PyFunction_GET_DEFAULTS(PyObject func);
// #define PyFunction_GET_DEFAULTS(func) PyFunction_GET_DEFAULTS(_PyObject_CAST(func))

@NoException public static native PyObject PyFunction_GET_KW_DEFAULTS(PyObject func);
// #define PyFunction_GET_KW_DEFAULTS(func) PyFunction_GET_KW_DEFAULTS(_PyObject_CAST(func))

@NoException public static native PyObject PyFunction_GET_CLOSURE(PyObject func);
// #define PyFunction_GET_CLOSURE(func) PyFunction_GET_CLOSURE(_PyObject_CAST(func))

@NoException public static native PyObject PyFunction_GET_ANNOTATIONS(PyObject func);
// #define PyFunction_GET_ANNOTATIONS(func) PyFunction_GET_ANNOTATIONS(_PyObject_CAST(func))

/* The classmethod and staticmethod types lives here, too */
public static native @ByRef PyTypeObject PyClassMethod_Type(); public static native void PyClassMethod_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyStaticMethod_Type(); public static native void PyStaticMethod_Type(PyTypeObject setter);

@NoException public static native PyObject PyClassMethod_New(PyObject arg0);
@NoException public static native PyObject PyStaticMethod_New(PyObject arg0);

// #define PY_FOREACH_FUNC_EVENT(V)
//     V(CREATE)
//     V(DESTROY)
//     V(MODIFY_CODE)
//     V(MODIFY_DEFAULTS)
//     V(MODIFY_KWDEFAULTS)

/** enum PyFunction_WatchEvent */

//     #define PY_DEF_EVENT(EVENT) PyFunction_EVENT_##EVENT,
public static final int
    PyFunction_EVENT_CREATE = 0,
    PyFunction_EVENT_DESTROY = 1,
    PyFunction_EVENT_MODIFY_CODE = 2,
    PyFunction_EVENT_MODIFY_DEFAULTS = 3,
    PyFunction_EVENT_MODIFY_KWDEFAULTS = 4;
//     #undef PY_DEF_EVENT
// Targeting ../PyFunction_WatchCallback.java



/*
 * Register a per-interpreter callback that will be invoked for function lifecycle
 * events.
 *
 * Returns a handle that may be passed to PyFunction_ClearWatcher on success,
 * or -1 and sets an error if no more handles are available.
 */
@NoException public static native int PyFunction_AddWatcher(PyFunction_WatchCallback callback);

/*
 * Clear the watcher associated with the watcher_id handle.
 *
 * Returns 0 on success or -1 if no watcher exists for the supplied id.
 */
@NoException public static native int PyFunction_ClearWatcher(int watcher_id);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_FUNCOBJECT_H */
// #endif /* Py_LIMITED_API */


// Parsed from cpython/classobject.h

/* Former class object interface -- now only bound methods are here  */

/* Revealing some structures (not for general use) */

// #ifndef Py_LIMITED_API
// #ifndef Py_CLASSOBJECT_H
// #define Py_CLASSOBJECT_H
// #ifdef __cplusplus
// Targeting ../PyMethodObject.java



public static native @ByRef PyTypeObject PyMethod_Type(); public static native void PyMethod_Type(PyTypeObject setter);

// #define PyMethod_Check(op) Py_IS_TYPE((op), &PyMethod_Type)

@NoException public static native PyObject PyMethod_New(PyObject arg0, PyObject arg1);

@NoException public static native PyObject PyMethod_Function(PyObject arg0);
@NoException public static native PyObject PyMethod_Self(PyObject arg0);

// #define _PyMethod_CAST(meth)
//     (assert(PyMethod_Check(meth)), _Py_CAST(PyMethodObject*, meth))

/* Static inline functions for direct access to these values.
   Type checks are *not* done, so use with care. */
@NoException public static native PyObject PyMethod_GET_FUNCTION(PyObject meth);
// #define PyMethod_GET_FUNCTION(meth) PyMethod_GET_FUNCTION(_PyObject_CAST(meth))

@NoException public static native PyObject PyMethod_GET_SELF(PyObject meth);
// #define PyMethod_GET_SELF(meth) PyMethod_GET_SELF(_PyObject_CAST(meth))
// Targeting ../PyInstanceMethodObject.java



public static native @ByRef PyTypeObject PyInstanceMethod_Type(); public static native void PyInstanceMethod_Type(PyTypeObject setter);

// #define PyInstanceMethod_Check(op) Py_IS_TYPE((op), &PyInstanceMethod_Type)

@NoException public static native PyObject PyInstanceMethod_New(PyObject arg0);
@NoException public static native PyObject PyInstanceMethod_Function(PyObject arg0);

// #define _PyInstanceMethod_CAST(meth)
//     (assert(PyInstanceMethod_Check(meth)),
//      _Py_CAST(PyInstanceMethodObject*, meth))

/* Static inline function for direct access to these values.
   Type checks are *not* done, so use with care. */
@NoException public static native PyObject PyInstanceMethod_GET_FUNCTION(PyObject meth);
// #define PyInstanceMethod_GET_FUNCTION(meth) PyInstanceMethod_GET_FUNCTION(_PyObject_CAST(meth))

// #ifdef __cplusplus
// #endif
// #endif   // !Py_CLASSOBJECT_H
// #endif   // !Py_LIMITED_API


// Parsed from fileobject.h

/* File object interface (what's left of it -- see io.py) */

// #ifndef Py_FILEOBJECT_H
// #define Py_FILEOBJECT_H
// #ifdef __cplusplus
// #endif

public static final String PY_STDIOTEXTMODE = "b";

@NoException public static native PyObject PyFile_FromFd(int arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2, int arg3,
                                     @Cast("const char*") BytePointer arg4, @Cast("const char*") BytePointer arg5,
                                     @Cast("const char*") BytePointer arg6, int arg7);
@NoException public static native PyObject PyFile_FromFd(int arg0, String arg1, String arg2, int arg3,
                                     String arg4, String arg5,
                                     String arg6, int arg7);
@NoException public static native PyObject PyFile_GetLine(PyObject arg0, int arg1);
@NoException public static native int PyFile_WriteObject(PyObject arg0, PyObject arg1, int arg2);
@NoException public static native int PyFile_WriteString(@Cast("const char*") BytePointer arg0, PyObject arg1);
@NoException public static native int PyFile_WriteString(String arg0, PyObject arg1);
@NoException public static native int PyObject_AsFileDescriptor(PyObject arg0);

/* The default encoding used by the platform file system APIs
   If non-NULL, this is different than the default encoding for strings
*/
public static native @Deprecated @Cast("const char*") BytePointer Py_FileSystemDefaultEncoding(); public static native void Py_FileSystemDefaultEncoding(BytePointer setter);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
public static native @Deprecated @Cast("const char*") BytePointer Py_FileSystemDefaultEncodeErrors(); public static native void Py_FileSystemDefaultEncodeErrors(BytePointer setter);
// #endif
public static native @Deprecated int Py_HasFileSystemDefaultEncoding(); public static native void Py_HasFileSystemDefaultEncoding(int setter);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000
public static native @Deprecated int Py_UTF8Mode(); public static native void Py_UTF8Mode(int setter);
// #endif

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_FILEOBJECT_H
// #  include "cpython/fileobject.h"
// #  undef Py_CPYTHON_FILEOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_FILEOBJECT_H */


// Parsed from cpython/fileobject.h

// #ifndef Py_CPYTHON_FILEOBJECT_H
// #  error "this header file must not be included directly"
// #endif

@NoException public static native @Cast("char*") BytePointer Py_UniversalNewlineFgets(@Cast("char*") BytePointer arg0, int arg1, @Cast("FILE*") Pointer arg2, PyObject arg3);
@NoException public static native @Cast("char*") ByteBuffer Py_UniversalNewlineFgets(@Cast("char*") ByteBuffer arg0, int arg1, @Cast("FILE*") Pointer arg2, PyObject arg3);
@NoException public static native @Cast("char*") byte[] Py_UniversalNewlineFgets(@Cast("char*") byte[] arg0, int arg1, @Cast("FILE*") Pointer arg2, PyObject arg3);

/* The std printer acts as a preliminary sys.stderr until the new io
   infrastructure is in place. */
@NoException public static native PyObject PyFile_NewStdPrinter(int arg0);
public static native @ByRef PyTypeObject PyStdPrinter_Type(); public static native void PyStdPrinter_Type(PyTypeObject setter);
// Targeting ../Py_OpenCodeHookFunction.java



@NoException public static native PyObject PyFile_OpenCode(@Cast("const char*") BytePointer utf8path);
@NoException public static native PyObject PyFile_OpenCode(String utf8path);
@NoException public static native PyObject PyFile_OpenCodeObject(PyObject path);
@NoException public static native int PyFile_SetOpenCodeHook(Py_OpenCodeHookFunction hook, Pointer userData);


// Parsed from frameobject.h

/* Frame object interface */

// #ifndef Py_FRAMEOBJECT_H
// #define Py_FRAMEOBJECT_H
// #ifdef __cplusplus
// #endif

// #include "pyframe.h"

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_FRAMEOBJECT_H
// #  include "cpython/frameobject.h"
// #  undef Py_CPYTHON_FRAMEOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_FRAMEOBJECT_H */


// Parsed from cpython/frameobject.h

/* Frame object interface */

// #ifndef Py_CPYTHON_FRAMEOBJECT_H
// #  error "this header file must not be included directly"
// #endif

/* Standard object interface */

@NoException public static native PyFrameObject PyFrame_New(PyThreadState arg0, PyCodeObject arg1,
                                        PyObject arg2, PyObject arg3);

/* The rest of the interface is specific for frame objects */

/* Conversions between "fast locals" and locals in dictionary */

@NoException public static native void PyFrame_LocalsToFast(PyFrameObject arg0, int arg1);

/* -- Caveat emptor --
 * The concept of entry frames is an implementation detail of the CPython
 * interpreter. This API is considered unstable and is provided for the
 * convenience of debuggers, profilers and state-inspecting tools. Notice that
 * this API can be changed in future minor versions if the underlying frame
 * mechanism change or the concept of an 'entry frame' or its semantics becomes
 * obsolete or outdated. */

@NoException public static native int _PyFrame_IsEntryFrame(PyFrameObject frame);

@NoException public static native int PyFrame_FastToLocalsWithError(PyFrameObject f);
@NoException public static native void PyFrame_FastToLocals(PyFrameObject arg0);
// Targeting ../PyFrameLocalsProxyObject.java




// Parsed from pycapsule.h


/* Capsule objects let you wrap a C "void *" pointer in a Python
   object.  They're a way of passing data through the Python interpreter
   without creating your own custom type.

   Capsules are used for communication between extension modules.
   They provide a way for an extension module to export a C interface
   to other extension modules, so that extension modules can use the
   Python import mechanism to link to one another.

   For more information, please see "c-api/capsule.html" in the
   documentation.
*/

// #ifndef Py_CAPSULE_H
// #define Py_CAPSULE_H
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyCapsule_Type(); public static native void PyCapsule_Type(PyTypeObject setter);
// Targeting ../PyCapsule_Destructor.java



// #define PyCapsule_CheckExact(op) Py_IS_TYPE((op), &PyCapsule_Type)


@NoException public static native PyObject PyCapsule_New(
    Pointer pointer,
    @Cast("const char*") BytePointer name,
    PyCapsule_Destructor destructor);
@NoException public static native PyObject PyCapsule_New(
    Pointer pointer,
    String name,
    PyCapsule_Destructor destructor);

@NoException public static native Pointer PyCapsule_GetPointer(PyObject capsule, @Cast("const char*") BytePointer name);
@NoException public static native Pointer PyCapsule_GetPointer(PyObject capsule, String name);

@NoException public static native PyCapsule_Destructor PyCapsule_GetDestructor(PyObject capsule);

@NoException public static native @Cast("const char*") BytePointer PyCapsule_GetName(PyObject capsule);

@NoException public static native Pointer PyCapsule_GetContext(PyObject capsule);

@NoException public static native int PyCapsule_IsValid(PyObject capsule, @Cast("const char*") BytePointer name);
@NoException public static native int PyCapsule_IsValid(PyObject capsule, String name);

@NoException public static native int PyCapsule_SetPointer(PyObject capsule, Pointer pointer);

@NoException public static native int PyCapsule_SetDestructor(PyObject capsule, PyCapsule_Destructor destructor);

@NoException public static native int PyCapsule_SetName(PyObject capsule, @Cast("const char*") BytePointer name);
@NoException public static native int PyCapsule_SetName(PyObject capsule, String name);

@NoException public static native int PyCapsule_SetContext(PyObject capsule, Pointer context);

@NoException public static native Pointer PyCapsule_Import(
    @Cast("const char*") BytePointer name,
    int no_block);
@NoException public static native Pointer PyCapsule_Import(
    String name,
    int no_block);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_CAPSULE_H */


// Parsed from pyframe.h

/* Limited C API of PyFrame API
 *
 * Include "frameobject.h" to get the PyFrameObject structure.
 */

// #ifndef Py_PYFRAME_H
// #define Py_PYFRAME_H
// #ifdef __cplusplus
// #endif

/* Return the line of code the frame is currently executing. */
@NoException public static native int PyFrame_GetLineNumber(PyFrameObject arg0);

@NoException public static native PyCodeObject PyFrame_GetCode(PyFrameObject frame);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_PYFRAME_H
// #  include "cpython/pyframe.h"
// #  undef Py_CPYTHON_PYFRAME_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYFRAME_H */


// Parsed from traceback.h

// #ifndef Py_TRACEBACK_H
// #define Py_TRACEBACK_H
// #ifdef __cplusplus
// #endif

/* Traceback interface */

@NoException public static native int PyTraceBack_Here(PyFrameObject arg0);
@NoException public static native int PyTraceBack_Print(PyObject arg0, PyObject arg1);

/* Reveal traceback type so we can typecheck traceback objects */
public static native @ByRef PyTypeObject PyTraceBack_Type(); public static native void PyTraceBack_Type(PyTypeObject setter);
// #define PyTraceBack_Check(v) Py_IS_TYPE((v), &PyTraceBack_Type)


// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_TRACEBACK_H
// #  include "cpython/traceback.h"
// #  undef Py_CPYTHON_TRACEBACK_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_TRACEBACK_H */


// Parsed from cpython/traceback.h

// #ifndef Py_CPYTHON_TRACEBACK_H
// #  error "this header file must not be included directly"
// Targeting ../PyTracebackObject.java




// Parsed from sliceobject.h

// #ifndef Py_SLICEOBJECT_H
// #define Py_SLICEOBJECT_H
// #ifdef __cplusplus
// #endif

/* The unique ellipsis object "..." */

public static native @ByRef PyObject _Py_EllipsisObject(); public static native void _Py_EllipsisObject(PyObject setter); /* Don't use this directly */

// #if defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030D0000
// #  define Py_Ellipsis Py_GetConstantBorrowed(Py_CONSTANT_ELLIPSIS)
// #else
// #  define Py_Ellipsis (&_Py_EllipsisObject)
// Targeting ../PySliceObject.java


// #endif

public static native @ByRef PyTypeObject PySlice_Type(); public static native void PySlice_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyEllipsis_Type(); public static native void PyEllipsis_Type(PyTypeObject setter);

// #define PySlice_Check(op) Py_IS_TYPE((op), &PySlice_Type)

@NoException public static native PyObject PySlice_New(PyObject start, PyObject stop,
                                  PyObject step);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PySlice_FromIndices(@Cast("Py_ssize_t") long start, @Cast("Py_ssize_t") long stop);
@NoException public static native int _PySlice_GetLongIndices(PySliceObject self, PyObject length,
                                 @Cast("PyObject**") PointerPointer start_ptr, @Cast("PyObject**") PointerPointer stop_ptr,
                                 @Cast("PyObject**") PointerPointer step_ptr);
@NoException public static native int _PySlice_GetLongIndices(PySliceObject self, PyObject length,
                                 @ByPtrPtr PyObject start_ptr, @ByPtrPtr PyObject stop_ptr,
                                 @ByPtrPtr PyObject step_ptr);
// #endif
@NoException public static native int PySlice_GetIndices(PyObject r, @Cast("Py_ssize_t") long length,
                                  @Cast("Py_ssize_t*") SizeTPointer start, @Cast("Py_ssize_t*") SizeTPointer stop, @Cast("Py_ssize_t*") SizeTPointer step);
@NoException public static native @Deprecated int PySlice_GetIndicesEx(PyObject r, @Cast("Py_ssize_t") long length,
                                     @Cast("Py_ssize_t*") SizeTPointer start, @Cast("Py_ssize_t*") SizeTPointer stop,
                                     @Cast("Py_ssize_t*") SizeTPointer step,
                                     @Cast("Py_ssize_t*") SizeTPointer slicelength);

// #if !defined(Py_LIMITED_API) || (Py_LIMITED_API+0 >= 0x03050400 && Py_LIMITED_API+0 < 0x03060000) || Py_LIMITED_API+0 >= 0x03060100
// #define PySlice_GetIndicesEx(slice, length, start, stop, step, slicelen) (
//     PySlice_Unpack((slice), (start), (stop), (step)) < 0 ?
//     ((*(slicelen) = 0), -1) :
//     ((*(slicelen) = PySlice_AdjustIndices((length), (start), (stop), *(step))),
//      0))
@NoException public static native int PySlice_Unpack(PyObject slice,
                               @Cast("Py_ssize_t*") SizeTPointer start, @Cast("Py_ssize_t*") SizeTPointer stop, @Cast("Py_ssize_t*") SizeTPointer step);
@NoException public static native @Cast("Py_ssize_t") long PySlice_AdjustIndices(@Cast("Py_ssize_t") long length,
                                             @Cast("Py_ssize_t*") SizeTPointer start, @Cast("Py_ssize_t*") SizeTPointer stop,
                                             @Cast("Py_ssize_t") long step);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_SLICEOBJECT_H */


// Parsed from cpython/cellobject.h

/* Cell object interface */

// #ifndef Py_LIMITED_API
// #ifndef Py_CELLOBJECT_H
// #define Py_CELLOBJECT_H
// #ifdef __cplusplus
// Targeting ../PyCellObject.java



public static native @ByRef PyTypeObject PyCell_Type(); public static native void PyCell_Type(PyTypeObject setter);

// #define PyCell_Check(op) Py_IS_TYPE((op), &PyCell_Type)

@NoException public static native PyObject PyCell_New(PyObject arg0);
@NoException public static native PyObject PyCell_Get(PyObject arg0);
@NoException public static native int PyCell_Set(PyObject arg0, PyObject arg1);

@NoException public static native PyObject PyCell_GET(PyObject op);
// #define PyCell_GET(op) PyCell_GET(_PyObject_CAST(op))

@NoException public static native void PyCell_SET(PyObject op, PyObject value);
// #define PyCell_SET(op, value) PyCell_SET(_PyObject_CAST(op), (value))

// #ifdef __cplusplus
// #endif
// #endif /* !Py_TUPLEOBJECT_H */
// #endif /* Py_LIMITED_API */


// Parsed from iterobject.h

// #ifndef Py_ITEROBJECT_H
// #define Py_ITEROBJECT_H
/* Iterators (the basic kind, over a sequence) */
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PySeqIter_Type(); public static native void PySeqIter_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyCallIter_Type(); public static native void PyCallIter_Type(PyTypeObject setter);

// #define PySeqIter_Check(op) Py_IS_TYPE((op), &PySeqIter_Type)

@NoException public static native PyObject PySeqIter_New(PyObject arg0);


// #define PyCallIter_Check(op) Py_IS_TYPE((op), &PyCallIter_Type)

@NoException public static native PyObject PyCallIter_New(PyObject arg0, PyObject arg1);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_ITEROBJECT_H */



// Parsed from cpython/genobject.h

/* Generator object interface */

// #ifndef Py_LIMITED_API
// #ifndef Py_GENOBJECT_H
// #define Py_GENOBJECT_H
// #ifdef __cplusplus
// Targeting ../PyGenObject.java



public static native @ByRef PyTypeObject PyGen_Type(); public static native void PyGen_Type(PyTypeObject setter);

// #define PyGen_Check(op) PyObject_TypeCheck((op), &PyGen_Type)
// #define PyGen_CheckExact(op) Py_IS_TYPE((op), &PyGen_Type)

@NoException public static native PyObject PyGen_New(PyFrameObject arg0);
@NoException public static native PyObject PyGen_NewWithQualName(PyFrameObject arg0,
    PyObject name, PyObject qualname);
@NoException public static native PyCodeObject PyGen_GetCode(PyGenObject gen);
// Targeting ../PyCoroObject.java



public static native @ByRef PyTypeObject PyCoro_Type(); public static native void PyCoro_Type(PyTypeObject setter);

// #define PyCoro_CheckExact(op) Py_IS_TYPE((op), &PyCoro_Type)
@NoException public static native PyObject PyCoro_New(PyFrameObject arg0,
    PyObject name, PyObject qualname);
// Targeting ../PyAsyncGenObject.java



public static native @ByRef PyTypeObject PyAsyncGen_Type(); public static native void PyAsyncGen_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject _PyAsyncGenASend_Type(); public static native void _PyAsyncGenASend_Type(PyTypeObject setter);

@NoException public static native PyObject PyAsyncGen_New(PyFrameObject arg0,
    PyObject name, PyObject qualname);

// #define PyAsyncGen_CheckExact(op) Py_IS_TYPE((op), &PyAsyncGen_Type)

// #define PyAsyncGenASend_CheckExact(op) Py_IS_TYPE((op), &_PyAsyncGenASend_Type)

// #undef _PyGenObject_HEAD

// #ifdef __cplusplus
// #endif
// #endif /* !Py_GENOBJECT_H */
// #endif /* Py_LIMITED_API */


// Parsed from genericaliasobject.h

// Implementation of PEP 585: support list[int] etc.
// #ifndef Py_GENERICALIASOBJECT_H
// #define Py_GENERICALIASOBJECT_H
// #ifdef __cplusplus
// #endif

@NoException public static native PyObject Py_GenericAlias(PyObject arg0, PyObject arg1);
public static native @ByRef PyTypeObject Py_GenericAliasType(); public static native void Py_GenericAliasType(PyTypeObject setter);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_GENERICALIASOBJECT_H */


// Parsed from warnings.h

// #ifndef Py_WARNINGS_H
// #define Py_WARNINGS_H
// #ifdef __cplusplus
// #endif

@NoException public static native int PyErr_WarnEx(
    PyObject category,
    @Cast("const char*") BytePointer message,
    @Cast("Py_ssize_t") long stack_level);
@NoException public static native int PyErr_WarnEx(
    PyObject category,
    String message,
    @Cast("Py_ssize_t") long stack_level);

@NoException public static native int PyErr_WarnFormat(
    PyObject category,
    @Cast("Py_ssize_t") long stack_level,
    @Cast("const char*") BytePointer format);
@NoException public static native int PyErr_WarnFormat(
    PyObject category,
    @Cast("Py_ssize_t") long stack_level,
    String format);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
/* Emit a ResourceWarning warning */
@NoException public static native int PyErr_ResourceWarning(
    PyObject source,
    @Cast("Py_ssize_t") long stack_level,
    @Cast("const char*") BytePointer format);
@NoException public static native int PyErr_ResourceWarning(
    PyObject source,
    @Cast("Py_ssize_t") long stack_level,
    String format);
// #endif

@NoException public static native int PyErr_WarnExplicit(
    PyObject category,
    @Cast("const char*") BytePointer message,
    @Cast("const char*") BytePointer filename,
    int lineno,
    @Cast("const char*") BytePointer module,
    PyObject registry);
@NoException public static native int PyErr_WarnExplicit(
    PyObject category,
    String message,
    String filename,
    int lineno,
    String module,
    PyObject registry);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_WARNINGS_H
// #  include "cpython/warnings.h"
// #  undef Py_CPYTHON_WARNINGS_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_WARNINGS_H */



// Parsed from weakrefobject.h

/* Weak references objects for Python. */

// #ifndef Py_WEAKREFOBJECT_H
// #define Py_WEAKREFOBJECT_H
// #ifdef __cplusplus
// Targeting ../PyWeakReference.java



public static native @ByRef PyTypeObject _PyWeakref_RefType(); public static native void _PyWeakref_RefType(PyTypeObject setter);
public static native @ByRef PyTypeObject _PyWeakref_ProxyType(); public static native void _PyWeakref_ProxyType(PyTypeObject setter);
public static native @ByRef PyTypeObject _PyWeakref_CallableProxyType(); public static native void _PyWeakref_CallableProxyType(PyTypeObject setter);

// #define PyWeakref_CheckRef(op) PyObject_TypeCheck((op), &_PyWeakref_RefType)
// #define PyWeakref_CheckRefExact(op)
//         Py_IS_TYPE((op), &_PyWeakref_RefType)
// #define PyWeakref_CheckProxy(op)
//         (Py_IS_TYPE((op), &_PyWeakref_ProxyType)
//          || Py_IS_TYPE((op), &_PyWeakref_CallableProxyType))

// #define PyWeakref_Check(op)
//         (PyWeakref_CheckRef(op) || PyWeakref_CheckProxy(op))


@NoException public static native PyObject PyWeakref_NewRef(PyObject ob,
                                        PyObject callback);
@NoException public static native PyObject PyWeakref_NewProxy(PyObject ob,
                                          PyObject callback);
@NoException public static native @Deprecated PyObject PyWeakref_GetObject(PyObject ref);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030D0000
@NoException public static native int PyWeakref_GetRef(PyObject ref, @Cast("PyObject**") PointerPointer pobj);
@NoException public static native int PyWeakref_GetRef(PyObject ref, @ByPtrPtr PyObject pobj);
// #endif


// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_WEAKREFOBJECT_H
// #  include "cpython/weakrefobject.h"
// #  undef Py_CPYTHON_WEAKREFOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_WEAKREFOBJECT_H */


// Parsed from structseq.h


/* Named tuple object interface */

// #ifndef Py_STRUCTSEQ_H
// #define Py_STRUCTSEQ_H
// #ifdef __cplusplus
// Targeting ../PyStructSequence_Field.java


// Targeting ../PyStructSequence_Desc.java





// #ifndef Py_LIMITED_API
@NoException public static native void PyStructSequence_InitType(PyTypeObject type,
                                           PyStructSequence_Desc desc);
@NoException public static native int PyStructSequence_InitType2(PyTypeObject type,
                                           PyStructSequence_Desc desc);
// #endif
@NoException public static native PyTypeObject PyStructSequence_NewType(PyStructSequence_Desc desc);

@NoException public static native PyObject PyStructSequence_New(PyTypeObject type);

@NoException public static native void PyStructSequence_SetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1, PyObject arg2);
@NoException public static native PyObject PyStructSequence_GetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1);

// #ifndef Py_LIMITED_API
// #define PyStructSequence_SET_ITEM PyStructSequence_SetItem
// #define PyStructSequence_GET_ITEM PyStructSequence_GetItem
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_STRUCTSEQ_H */


// Parsed from cpython/picklebufobject.h

/* PickleBuffer object. This is built-in for ease of use from third-party
 * C extensions.
 */

// #ifndef Py_PICKLEBUFOBJECT_H
// #define Py_PICKLEBUFOBJECT_H
// #ifdef __cplusplus
// #endif

// #ifndef Py_LIMITED_API

public static native @ByRef PyTypeObject PyPickleBuffer_Type(); public static native void PyPickleBuffer_Type(PyTypeObject setter);

// #define PyPickleBuffer_Check(op) Py_IS_TYPE((op), &PyPickleBuffer_Type)

/* Create a PickleBuffer redirecting to the given buffer-enabled object */
@NoException public static native PyObject PyPickleBuffer_FromObject(PyObject arg0);
/* Get the PickleBuffer's underlying view to the original object
 * (NULL if released)
 */
@NoException public static native @Const Py_buffer PyPickleBuffer_GetBuffer(PyObject arg0);
/* Release the PickleBuffer.  Returns 0 on success, -1 on error. */
@NoException public static native int PyPickleBuffer_Release(PyObject arg0);

// #endif /* !Py_LIMITED_API */

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PICKLEBUFOBJECT_H */


// Parsed from codecs.h

// #ifndef Py_CODECREGISTRY_H
// #define Py_CODECREGISTRY_H
// #ifdef __cplusplus
// #endif

/* ------------------------------------------------------------------------

   Python Codec Registry and support functions


Written by Marc-Andre Lemburg (mal@lemburg.com).

Copyright (c) Corporation for National Research Initiatives.

   ------------------------------------------------------------------------ */

/* Register a new codec search function.

   As side effect, this tries to load the encodings package, if not
   yet done, to make sure that it is always first in the list of
   search functions.

   The search_function's refcount is incremented by this function. */

@NoException public static native int PyCodec_Register(
       PyObject search_function
       );

/* Unregister a codec search function and clear the registry's cache.
   If the search function is not registered, do nothing.
   Return 0 on success. Raise an exception and return -1 on error. */

@NoException public static native int PyCodec_Unregister(
       PyObject search_function
       );

/* Codec registry encoding check API.

   Returns 1/0 depending on whether there is a registered codec for
   the given encoding.

*/

@NoException public static native int PyCodec_KnownEncoding(
       @Cast("const char*") BytePointer encoding
       );
@NoException public static native int PyCodec_KnownEncoding(
       String encoding
       );

/* Generic codec based encoding API.

   object is passed through the encoder function found for the given
   encoding using the error handling method defined by errors. errors
   may be NULL to use the default method defined for the codec.

   Raises a LookupError in case no encoder can be found.

 */

@NoException public static native PyObject PyCodec_Encode(
       PyObject object,
       @Cast("const char*") BytePointer encoding,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject PyCodec_Encode(
       PyObject object,
       String encoding,
       String errors
       );

/* Generic codec based decoding API.

   object is passed through the decoder function found for the given
   encoding using the error handling method defined by errors. errors
   may be NULL to use the default method defined for the codec.

   Raises a LookupError in case no encoder can be found.

 */

@NoException public static native PyObject PyCodec_Decode(
       PyObject object,
       @Cast("const char*") BytePointer encoding,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject PyCodec_Decode(
       PyObject object,
       String encoding,
       String errors
       );

// --- Codec Lookup APIs --------------------------------------------------

/* Codec registry lookup API.

   Looks up the given encoding and returns a CodecInfo object with
   function attributes which implement the different aspects of
   processing the encoding.

   The encoding string is looked up converted to all lower-case
   characters. This makes encodings looked up through this mechanism
   effectively case-insensitive.

   If no codec is found, a KeyError is set and NULL returned.

   As side effect, this tries to load the encodings package, if not
   yet done. This is part of the lazy load strategy for the encodings
   package.
 */

/* Get an encoder function for the given encoding. */

@NoException public static native PyObject PyCodec_Encoder(@Cast("const char*") BytePointer encoding);
@NoException public static native PyObject PyCodec_Encoder(String encoding);

/* Get a decoder function for the given encoding. */

@NoException public static native PyObject PyCodec_Decoder(@Cast("const char*") BytePointer encoding);
@NoException public static native PyObject PyCodec_Decoder(String encoding);

/* Get an IncrementalEncoder object for the given encoding. */

@NoException public static native PyObject PyCodec_IncrementalEncoder(
   @Cast("const char*") BytePointer encoding,
   @Cast("const char*") BytePointer errors);
@NoException public static native PyObject PyCodec_IncrementalEncoder(
   String encoding,
   String errors);

/* Get an IncrementalDecoder object function for the given encoding. */

@NoException public static native PyObject PyCodec_IncrementalDecoder(
   @Cast("const char*") BytePointer encoding,
   @Cast("const char*") BytePointer errors);
@NoException public static native PyObject PyCodec_IncrementalDecoder(
   String encoding,
   String errors);

/* Get a StreamReader factory function for the given encoding. */

@NoException public static native PyObject PyCodec_StreamReader(
   @Cast("const char*") BytePointer encoding,
   PyObject stream,
   @Cast("const char*") BytePointer errors);
@NoException public static native PyObject PyCodec_StreamReader(
   String encoding,
   PyObject stream,
   String errors);

/* Get a StreamWriter factory function for the given encoding. */

@NoException public static native PyObject PyCodec_StreamWriter(
   @Cast("const char*") BytePointer encoding,
   PyObject stream,
   @Cast("const char*") BytePointer errors);
@NoException public static native PyObject PyCodec_StreamWriter(
   String encoding,
   PyObject stream,
   String errors);

/* Unicode encoding error handling callback registry API */

/* Register the error handling callback function error under the given
   name. This function will be called by the codec when it encounters
   unencodable characters/undecodable bytes and doesn't know the
   callback name, when name is specified as the error parameter
   in the call to the encode/decode function.
   Return 0 on success, -1 on error */
@NoException public static native int PyCodec_RegisterError(@Cast("const char*") BytePointer name, PyObject error);
@NoException public static native int PyCodec_RegisterError(String name, PyObject error);

/* Lookup the error handling callback function registered under the given
   name. As a special case NULL can be passed, in which case
   the error handling callback for "strict" will be returned. */
@NoException public static native PyObject PyCodec_LookupError(@Cast("const char*") BytePointer name);
@NoException public static native PyObject PyCodec_LookupError(String name);

/* raise exc as an exception */
@NoException public static native PyObject PyCodec_StrictErrors(PyObject exc);

/* ignore the unicode error, skipping the faulty input */
@NoException public static native PyObject PyCodec_IgnoreErrors(PyObject exc);

/* replace the unicode encode error with ? or U+FFFD */
@NoException public static native PyObject PyCodec_ReplaceErrors(PyObject exc);

/* replace the unicode encode error with XML character references */
@NoException public static native PyObject PyCodec_XMLCharRefReplaceErrors(PyObject exc);

/* replace the unicode encode error with backslash escapes (\x, \u005Cu and \U) */
@NoException public static native PyObject PyCodec_BackslashReplaceErrors(PyObject exc);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* replace the unicode encode error with backslash escapes (\N, \x, \u005Cu and \U) */
@NoException public static native PyObject PyCodec_NameReplaceErrors(PyObject exc);
// #endif

// #ifndef Py_LIMITED_API
public static native @Cast("const char*") BytePointer Py_hexdigits(); public static native void Py_hexdigits(BytePointer setter);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_CODECREGISTRY_H */


// Parsed from pyerrors.h

// Error handling definitions

// #ifndef Py_ERRORS_H
// #define Py_ERRORS_H
// #ifdef __cplusplus
// #endif

@NoException public static native void PyErr_SetNone(PyObject arg0);
@NoException public static native void PyErr_SetObject(PyObject arg0, PyObject arg1);
@NoException public static native void PyErr_SetString(
    PyObject exception,
    @Cast("const char*") BytePointer string
    );
@NoException public static native void PyErr_SetString(
    PyObject exception,
    String string
    );
@NoException public static native PyObject PyErr_Occurred();
@NoException public static native void PyErr_Clear();
@NoException public static native void PyErr_Fetch(@Cast("PyObject**") PointerPointer arg0, @Cast("PyObject**") PointerPointer arg1, @Cast("PyObject**") PointerPointer arg2);
@NoException public static native void PyErr_Fetch(@ByPtrPtr PyObject arg0, @ByPtrPtr PyObject arg1, @ByPtrPtr PyObject arg2);
@NoException public static native void PyErr_Restore(PyObject arg0, PyObject arg1, PyObject arg2);
@NoException public static native PyObject PyErr_GetRaisedException();
@NoException public static native void PyErr_SetRaisedException(PyObject arg0);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030b0000
@NoException public static native PyObject PyErr_GetHandledException();
@NoException public static native void PyErr_SetHandledException(PyObject arg0);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native void PyErr_GetExcInfo(@Cast("PyObject**") PointerPointer arg0, @Cast("PyObject**") PointerPointer arg1, @Cast("PyObject**") PointerPointer arg2);
@NoException public static native void PyErr_GetExcInfo(@ByPtrPtr PyObject arg0, @ByPtrPtr PyObject arg1, @ByPtrPtr PyObject arg2);
@NoException public static native void PyErr_SetExcInfo(PyObject arg0, PyObject arg1, PyObject arg2);
// #endif

/* Defined in Python/pylifecycle.c

   The Py_FatalError() function is replaced with a macro which logs
   automatically the name of the current function, unless the Py_LIMITED_API
   macro is defined. */
@NoException public static native void Py_FatalError(@Cast("const char*") BytePointer message);
@NoException public static native void Py_FatalError(String message);

/* Error testing and normalization */
@NoException public static native int PyErr_GivenExceptionMatches(PyObject arg0, PyObject arg1);
@NoException public static native int PyErr_ExceptionMatches(PyObject arg0);
@NoException public static native void PyErr_NormalizeException(@Cast("PyObject**") PointerPointer arg0, @Cast("PyObject**") PointerPointer arg1, @Cast("PyObject**") PointerPointer arg2);
@NoException public static native void PyErr_NormalizeException(@ByPtrPtr PyObject arg0, @ByPtrPtr PyObject arg1, @ByPtrPtr PyObject arg2);

/* Traceback manipulation (PEP 3134) */
@NoException public static native int PyException_SetTraceback(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyException_GetTraceback(PyObject arg0);

/* Cause manipulation (PEP 3134) */
@NoException public static native PyObject PyException_GetCause(PyObject arg0);
@NoException public static native void PyException_SetCause(PyObject arg0, PyObject arg1);

/* Context manipulation (PEP 3134) */
@NoException public static native PyObject PyException_GetContext(PyObject arg0);
@NoException public static native void PyException_SetContext(PyObject arg0, PyObject arg1);


@NoException public static native PyObject PyException_GetArgs(PyObject arg0);
@NoException public static native void PyException_SetArgs(PyObject arg0, PyObject arg1);

/* */

// #define PyExceptionClass_Check(x)
//     (PyType_Check((x)) &&
//      PyType_FastSubclass((PyTypeObject*)(x), Py_TPFLAGS_BASE_EXC_SUBCLASS))

// #define PyExceptionInstance_Check(x)
//     PyType_FastSubclass(Py_TYPE(x), Py_TPFLAGS_BASE_EXC_SUBCLASS)

@NoException public static native @Cast("const char*") BytePointer PyExceptionClass_Name(PyObject arg0);

// #define PyExceptionInstance_Class(x) _PyObject_CAST(Py_TYPE(x))

// #define _PyBaseExceptionGroup_Check(x)
//     PyObject_TypeCheck((x), (PyTypeObject *)PyExc_BaseExceptionGroup)

/* Predefined exceptions */

public static native PyObject PyExc_BaseException(); public static native void PyExc_BaseException(PyObject setter);
public static native PyObject PyExc_Exception(); public static native void PyExc_Exception(PyObject setter);
public static native PyObject PyExc_BaseExceptionGroup(); public static native void PyExc_BaseExceptionGroup(PyObject setter);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
public static native PyObject PyExc_StopAsyncIteration(); public static native void PyExc_StopAsyncIteration(PyObject setter);
// #endif
public static native PyObject PyExc_StopIteration(); public static native void PyExc_StopIteration(PyObject setter);
public static native PyObject PyExc_GeneratorExit(); public static native void PyExc_GeneratorExit(PyObject setter);
public static native PyObject PyExc_ArithmeticError(); public static native void PyExc_ArithmeticError(PyObject setter);
public static native PyObject PyExc_LookupError(); public static native void PyExc_LookupError(PyObject setter);

public static native PyObject PyExc_AssertionError(); public static native void PyExc_AssertionError(PyObject setter);
public static native PyObject PyExc_AttributeError(); public static native void PyExc_AttributeError(PyObject setter);
public static native PyObject PyExc_BufferError(); public static native void PyExc_BufferError(PyObject setter);
public static native PyObject PyExc_EOFError(); public static native void PyExc_EOFError(PyObject setter);
public static native PyObject PyExc_FloatingPointError(); public static native void PyExc_FloatingPointError(PyObject setter);
public static native PyObject PyExc_OSError(); public static native void PyExc_OSError(PyObject setter);
public static native PyObject PyExc_ImportError(); public static native void PyExc_ImportError(PyObject setter);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
public static native PyObject PyExc_ModuleNotFoundError(); public static native void PyExc_ModuleNotFoundError(PyObject setter);
// #endif
public static native PyObject PyExc_IndexError(); public static native void PyExc_IndexError(PyObject setter);
public static native PyObject PyExc_KeyError(); public static native void PyExc_KeyError(PyObject setter);
public static native PyObject PyExc_KeyboardInterrupt(); public static native void PyExc_KeyboardInterrupt(PyObject setter);
public static native PyObject PyExc_MemoryError(); public static native void PyExc_MemoryError(PyObject setter);
public static native PyObject PyExc_NameError(); public static native void PyExc_NameError(PyObject setter);
public static native PyObject PyExc_OverflowError(); public static native void PyExc_OverflowError(PyObject setter);
public static native PyObject PyExc_RuntimeError(); public static native void PyExc_RuntimeError(PyObject setter);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
public static native PyObject PyExc_RecursionError(); public static native void PyExc_RecursionError(PyObject setter);
// #endif
public static native PyObject PyExc_NotImplementedError(); public static native void PyExc_NotImplementedError(PyObject setter);
public static native PyObject PyExc_SyntaxError(); public static native void PyExc_SyntaxError(PyObject setter);
public static native PyObject PyExc_IndentationError(); public static native void PyExc_IndentationError(PyObject setter);
public static native PyObject PyExc_TabError(); public static native void PyExc_TabError(PyObject setter);
public static native PyObject PyExc_ReferenceError(); public static native void PyExc_ReferenceError(PyObject setter);
public static native PyObject PyExc_SystemError(); public static native void PyExc_SystemError(PyObject setter);
public static native PyObject PyExc_SystemExit(); public static native void PyExc_SystemExit(PyObject setter);
public static native PyObject PyExc_TypeError(); public static native void PyExc_TypeError(PyObject setter);
public static native PyObject PyExc_UnboundLocalError(); public static native void PyExc_UnboundLocalError(PyObject setter);
public static native PyObject PyExc_UnicodeError(); public static native void PyExc_UnicodeError(PyObject setter);
public static native PyObject PyExc_UnicodeEncodeError(); public static native void PyExc_UnicodeEncodeError(PyObject setter);
public static native PyObject PyExc_UnicodeDecodeError(); public static native void PyExc_UnicodeDecodeError(PyObject setter);
public static native PyObject PyExc_UnicodeTranslateError(); public static native void PyExc_UnicodeTranslateError(PyObject setter);
public static native PyObject PyExc_ValueError(); public static native void PyExc_ValueError(PyObject setter);
public static native PyObject PyExc_ZeroDivisionError(); public static native void PyExc_ZeroDivisionError(PyObject setter);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
public static native PyObject PyExc_BlockingIOError(); public static native void PyExc_BlockingIOError(PyObject setter);
public static native PyObject PyExc_BrokenPipeError(); public static native void PyExc_BrokenPipeError(PyObject setter);
public static native PyObject PyExc_ChildProcessError(); public static native void PyExc_ChildProcessError(PyObject setter);
public static native PyObject PyExc_ConnectionError(); public static native void PyExc_ConnectionError(PyObject setter);
public static native PyObject PyExc_ConnectionAbortedError(); public static native void PyExc_ConnectionAbortedError(PyObject setter);
public static native PyObject PyExc_ConnectionRefusedError(); public static native void PyExc_ConnectionRefusedError(PyObject setter);
public static native PyObject PyExc_ConnectionResetError(); public static native void PyExc_ConnectionResetError(PyObject setter);
public static native PyObject PyExc_FileExistsError(); public static native void PyExc_FileExistsError(PyObject setter);
public static native PyObject PyExc_FileNotFoundError(); public static native void PyExc_FileNotFoundError(PyObject setter);
public static native PyObject PyExc_InterruptedError(); public static native void PyExc_InterruptedError(PyObject setter);
public static native PyObject PyExc_IsADirectoryError(); public static native void PyExc_IsADirectoryError(PyObject setter);
public static native PyObject PyExc_NotADirectoryError(); public static native void PyExc_NotADirectoryError(PyObject setter);
public static native PyObject PyExc_PermissionError(); public static native void PyExc_PermissionError(PyObject setter);
public static native PyObject PyExc_ProcessLookupError(); public static native void PyExc_ProcessLookupError(PyObject setter);
public static native PyObject PyExc_TimeoutError(); public static native void PyExc_TimeoutError(PyObject setter);
// #endif


/* Compatibility aliases */
public static native PyObject PyExc_EnvironmentError(); public static native void PyExc_EnvironmentError(PyObject setter);
public static native PyObject PyExc_IOError(); public static native void PyExc_IOError(PyObject setter);
// #ifdef MS_WINDOWS
// #endif

/* Predefined warning categories */
public static native PyObject PyExc_Warning(); public static native void PyExc_Warning(PyObject setter);
public static native PyObject PyExc_UserWarning(); public static native void PyExc_UserWarning(PyObject setter);
public static native PyObject PyExc_DeprecationWarning(); public static native void PyExc_DeprecationWarning(PyObject setter);
public static native PyObject PyExc_PendingDeprecationWarning(); public static native void PyExc_PendingDeprecationWarning(PyObject setter);
public static native PyObject PyExc_SyntaxWarning(); public static native void PyExc_SyntaxWarning(PyObject setter);
public static native PyObject PyExc_RuntimeWarning(); public static native void PyExc_RuntimeWarning(PyObject setter);
public static native PyObject PyExc_FutureWarning(); public static native void PyExc_FutureWarning(PyObject setter);
public static native PyObject PyExc_ImportWarning(); public static native void PyExc_ImportWarning(PyObject setter);
public static native PyObject PyExc_UnicodeWarning(); public static native void PyExc_UnicodeWarning(PyObject setter);
public static native PyObject PyExc_BytesWarning(); public static native void PyExc_BytesWarning(PyObject setter);
public static native PyObject PyExc_EncodingWarning(); public static native void PyExc_EncodingWarning(PyObject setter);
public static native PyObject PyExc_ResourceWarning(); public static native void PyExc_ResourceWarning(PyObject setter);


/* Convenience functions */

@NoException public static native int PyErr_BadArgument();
@NoException public static native PyObject PyErr_NoMemory();
@NoException public static native PyObject PyErr_SetFromErrno(PyObject arg0);
@NoException public static native PyObject PyErr_SetFromErrnoWithFilenameObject(
    PyObject arg0, PyObject arg1);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
@NoException public static native PyObject PyErr_SetFromErrnoWithFilenameObjects(
    PyObject arg0, PyObject arg1, PyObject arg2);
// #endif
@NoException public static native PyObject PyErr_SetFromErrnoWithFilename(
    PyObject exc,
    @Cast("const char*") BytePointer filename
    );
@NoException public static native PyObject PyErr_SetFromErrnoWithFilename(
    PyObject exc,
    String filename
    );

@NoException public static native PyObject PyErr_Format(
    PyObject exception,
    @Cast("const char*") BytePointer format
    );
@NoException public static native PyObject PyErr_Format(
    PyObject exception,
    String format
    );
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
@NoException public static native PyObject PyErr_FormatV(
    PyObject exception,
    @Cast("const char*") BytePointer format,
    @ByVal @Cast("va_list*") Pointer vargs);
@NoException public static native PyObject PyErr_FormatV(
    PyObject exception,
    String format,
    @ByVal @Cast("va_list*") Pointer vargs);
// #endif

// #ifdef MS_WINDOWS
// #endif /* MS_WINDOWS */

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
@NoException public static native PyObject PyErr_SetImportErrorSubclass(PyObject arg0, PyObject arg1,
    PyObject arg2, PyObject arg3);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyErr_SetImportError(PyObject arg0, PyObject arg1,
    PyObject arg2);
// #endif

/* Export the old function so that the existing API remains available: */
@NoException public static native void PyErr_BadInternalCall();
@NoException public static native void _PyErr_BadInternalCall(@Cast("const char*") BytePointer filename, int lineno);
@NoException public static native void _PyErr_BadInternalCall(String filename, int lineno);
/* Mask the old API with a call to the new API for code compiled under
   Python 2.0: */
// #define PyErr_BadInternalCall() _PyErr_BadInternalCall(__FILE__, __LINE__)

/* Function to create a new exception */
@NoException public static native PyObject PyErr_NewException(
    @Cast("const char*") BytePointer name, PyObject base, PyObject dict);
@NoException public static native PyObject PyErr_NewException(
    String name, PyObject base, PyObject dict);
@NoException public static native PyObject PyErr_NewExceptionWithDoc(
    @Cast("const char*") BytePointer name, @Cast("const char*") BytePointer doc, PyObject base, PyObject dict);
@NoException public static native PyObject PyErr_NewExceptionWithDoc(
    String name, String doc, PyObject base, PyObject dict);
@NoException public static native void PyErr_WriteUnraisable(PyObject arg0);


/* In signalmodule.c */
@NoException public static native int PyErr_CheckSignals();
@NoException public static native void PyErr_SetInterrupt();
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
@NoException public static native int PyErr_SetInterruptEx(int signum);
// #endif

/* Support for adding program text to SyntaxErrors */
@NoException public static native void PyErr_SyntaxLocation(
    @Cast("const char*") BytePointer filename,
    int lineno);
@NoException public static native void PyErr_SyntaxLocation(
    String filename,
    int lineno);
@NoException public static native void PyErr_SyntaxLocationEx(
    @Cast("const char*") BytePointer filename,
    int lineno,
    int col_offset);
@NoException public static native void PyErr_SyntaxLocationEx(
    String filename,
    int lineno,
    int col_offset);
@NoException public static native PyObject PyErr_ProgramText(
    @Cast("const char*") BytePointer filename,
    int lineno);
@NoException public static native PyObject PyErr_ProgramText(
    String filename,
    int lineno);

/* The following functions are used to create and modify unicode
   exceptions from C */

/* create a UnicodeDecodeError object */
@NoException public static native PyObject PyUnicodeDecodeError_Create(
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer object,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native PyObject PyUnicodeDecodeError_Create(
    String encoding,
    String object,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    String reason
    );

/* get the encoding attribute */
@NoException public static native PyObject PyUnicodeEncodeError_GetEncoding(PyObject arg0);
@NoException public static native PyObject PyUnicodeDecodeError_GetEncoding(PyObject arg0);

/* get the object attribute */
@NoException public static native PyObject PyUnicodeEncodeError_GetObject(PyObject arg0);
@NoException public static native PyObject PyUnicodeDecodeError_GetObject(PyObject arg0);
@NoException public static native PyObject PyUnicodeTranslateError_GetObject(PyObject arg0);

/* get the value of the start attribute (the int * may not be NULL)
   return 0 on success, -1 on failure */
@NoException public static native int PyUnicodeEncodeError_GetStart(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);
@NoException public static native int PyUnicodeDecodeError_GetStart(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);
@NoException public static native int PyUnicodeTranslateError_GetStart(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);

/* assign a new value to the start attribute
   return 0 on success, -1 on failure */
@NoException public static native int PyUnicodeEncodeError_SetStart(PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int PyUnicodeDecodeError_SetStart(PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int PyUnicodeTranslateError_SetStart(PyObject arg0, @Cast("Py_ssize_t") long arg1);

/* get the value of the end attribute (the int *may not be NULL)
 return 0 on success, -1 on failure */
@NoException public static native int PyUnicodeEncodeError_GetEnd(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);
@NoException public static native int PyUnicodeDecodeError_GetEnd(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);
@NoException public static native int PyUnicodeTranslateError_GetEnd(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);

/* assign a new value to the end attribute
   return 0 on success, -1 on failure */
@NoException public static native int PyUnicodeEncodeError_SetEnd(PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int PyUnicodeDecodeError_SetEnd(PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int PyUnicodeTranslateError_SetEnd(PyObject arg0, @Cast("Py_ssize_t") long arg1);

/* get the value of the reason attribute */
@NoException public static native PyObject PyUnicodeEncodeError_GetReason(PyObject arg0);
@NoException public static native PyObject PyUnicodeDecodeError_GetReason(PyObject arg0);
@NoException public static native PyObject PyUnicodeTranslateError_GetReason(PyObject arg0);

/* assign a new value to the reason attribute
   return 0 on success, -1 on failure */
@NoException public static native int PyUnicodeEncodeError_SetReason(
    PyObject exc,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native int PyUnicodeEncodeError_SetReason(
    PyObject exc,
    String reason
    );
@NoException public static native int PyUnicodeDecodeError_SetReason(
    PyObject exc,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native int PyUnicodeDecodeError_SetReason(
    PyObject exc,
    String reason
    );
@NoException public static native int PyUnicodeTranslateError_SetReason(
    PyObject exc,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native int PyUnicodeTranslateError_SetReason(
    PyObject exc,
    String reason
    );

@NoException public static native int PyOS_snprintf(@Cast("char*") BytePointer str, @Cast("size_t") long size, @Cast("const char*") BytePointer format);
@NoException public static native int PyOS_snprintf(@Cast("char*") ByteBuffer str, @Cast("size_t") long size, String format);
@NoException public static native int PyOS_snprintf(@Cast("char*") byte[] str, @Cast("size_t") long size, @Cast("const char*") BytePointer format);
@NoException public static native int PyOS_snprintf(@Cast("char*") BytePointer str, @Cast("size_t") long size, String format);
@NoException public static native int PyOS_snprintf(@Cast("char*") ByteBuffer str, @Cast("size_t") long size, @Cast("const char*") BytePointer format);
@NoException public static native int PyOS_snprintf(@Cast("char*") byte[] str, @Cast("size_t") long size, String format);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") BytePointer str, @Cast("size_t") long size, @Cast("const char*") BytePointer format, @ByVal @Cast("va_list*") Pointer va);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") ByteBuffer str, @Cast("size_t") long size, String format, @ByVal @Cast("va_list*") Pointer va);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") byte[] str, @Cast("size_t") long size, @Cast("const char*") BytePointer format, @ByVal @Cast("va_list*") Pointer va);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") BytePointer str, @Cast("size_t") long size, String format, @ByVal @Cast("va_list*") Pointer va);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") ByteBuffer str, @Cast("size_t") long size, @Cast("const char*") BytePointer format, @ByVal @Cast("va_list*") Pointer va);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") byte[] str, @Cast("size_t") long size, String format, @ByVal @Cast("va_list*") Pointer va);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_ERRORS_H
// #  include "cpython/pyerrors.h"
// #  undef Py_CPYTHON_ERRORS_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_ERRORS_H */


// Parsed from cpython/pyerrors.h

// #ifndef Py_CPYTHON_ERRORS_H
// #  error "this header file must not be included directly"
// #endif

/* Error objects */

/* PyException_HEAD defines the initial segment of every exception class. */
// #define PyException_HEAD PyObject_HEAD PyObject *dict;
//              PyObject *args; PyObject *notes; PyObject *traceback;
//              PyObject *context; PyObject *cause;
//              char suppress_context;
// Targeting ../PyBaseExceptionObject.java


// Targeting ../PyBaseExceptionGroupObject.java


// Targeting ../PySyntaxErrorObject.java


// Targeting ../PyImportErrorObject.java


// Targeting ../PyUnicodeErrorObject.java


// Targeting ../PySystemExitObject.java


// Targeting ../PyOSErrorObject.java


// Targeting ../PyStopIterationObject.java


// Targeting ../PyNameErrorObject.java


// Targeting ../PyAttributeErrorObject.java



/* Compatibility typedefs */
// #ifdef MS_WINDOWS
// #endif

/* Context manipulation (PEP 3134) */

@NoException public static native void _PyErr_ChainExceptions1(PyObject arg0);

/* In exceptions.c */

@NoException public static native PyObject PyUnstable_Exc_PrepReraiseStar(
     PyObject orig,
     PyObject excs);

/* In signalmodule.c */



/* Support for adding program text to SyntaxErrors */

@NoException public static native void PyErr_SyntaxLocationObject(
    PyObject filename,
    int lineno,
    int col_offset);

@NoException public static native void PyErr_RangedSyntaxLocationObject(
    PyObject filename,
    int lineno,
    int col_offset,
    int end_lineno,
    int end_col_offset);

@NoException public static native PyObject PyErr_ProgramTextObject(
    PyObject filename,
    int lineno);

@NoException public static native void _Py_FatalErrorFunc(
    @Cast("const char*") BytePointer func,
    @Cast("const char*") BytePointer message);
@NoException public static native void _Py_FatalErrorFunc(
    String func,
    String message);

@NoException public static native void PyErr_FormatUnraisable(@Cast("const char*") BytePointer arg0);
@NoException public static native void PyErr_FormatUnraisable(String arg0);

public static native PyObject PyExc_PythonFinalizationError(); public static native void PyExc_PythonFinalizationError(PyObject setter);

// #define Py_FatalError(message) _Py_FatalErrorFunc(__func__, (message))


// Parsed from pythread.h

// #ifndef Py_PYTHREAD_H
// #define Py_PYTHREAD_H
// Targeting ../PyThread_type_lock.java



// #ifdef __cplusplus
// #endif

/* Return status codes for Python lock acquisition.  Chosen for maximum
 * backwards compatibility, ie failure -> 0, success -> 1.  */
/** enum PyLockStatus */
public static final int
    PY_LOCK_FAILURE = 0,
    PY_LOCK_ACQUIRED = 1,
    PY_LOCK_INTR = 2;

@NoException public static native void PyThread_init_thread();
// Targeting ../Arg0_Pointer.java


@NoException public static native @Cast("unsigned long") long PyThread_start_new_thread(Arg0_Pointer arg0, Pointer arg1);
/* Terminates the current thread. Considered unsafe.
 *
 * WARNING: This function is only safe to call if all functions in the full call
 * stack are written to safely allow it.  Additionally, the behavior is
 * platform-dependent.  This function should be avoided, and is no longer called
 * by Python itself.  It is retained only for compatibility with existing C
 * extension code.
 *
 * With pthreads, calls `pthread_exit` causes some libcs (glibc?) to attempt to
 * unwind the stack and call C++ destructors; if a `noexcept` function is
 * reached, they may terminate the process. Others (macOS) do unwinding.
 *
 * On Windows, calls `_endthreadex` which kills the thread without calling C++
 * destructors.
 *
 * In either case there is a risk of invalid references remaining to data on the
 * thread stack.
 */
@NoException public static native @Deprecated void PyThread_exit_thread();

@NoException public static native @Cast("unsigned long") long PyThread_get_thread_ident();

// #if (defined(__APPLE__) || defined(__linux__) || defined(_WIN32)
//      || defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
//      || defined(__OpenBSD__) || defined(__NetBSD__)
//      || defined(__DragonFly__) || defined(_AIX))
// #define PY_HAVE_THREAD_NATIVE_ID
@NoException public static native @Cast("unsigned long") long PyThread_get_thread_native_id();
// #endif

@NoException public static native PyThread_type_lock PyThread_allocate_lock();
@NoException public static native void PyThread_free_lock(PyThread_type_lock arg0);
@NoException public static native int PyThread_acquire_lock(PyThread_type_lock arg0, int arg1);
public static final int WAIT_LOCK =       1;
public static final int NOWAIT_LOCK =     0;

// PY_TIMEOUT_T is the integral type used to specify timeouts when waiting
// on a lock (see PyThread_acquire_lock_timed() below).
// #define PY_TIMEOUT_T long long


/* If microseconds == 0, the call is non-blocking: it returns immediately
   even when the lock can't be acquired.
   If microseconds > 0, the call waits up to the specified duration.
   If microseconds < 0, the call waits until success (or abnormal failure)

   If *microseconds* is greater than PY_TIMEOUT_MAX, clamp the timeout to
   PY_TIMEOUT_MAX microseconds.

   If intr_flag is true and the acquire is interrupted by a signal, then the
   call will return PY_LOCK_INTR.  The caller may reattempt to acquire the
   lock.
*/
@NoException public static native @Cast("PyLockStatus") int PyThread_acquire_lock_timed(PyThread_type_lock arg0,
                                                     long microseconds,
                                                     int intr_flag);

@NoException public static native void PyThread_release_lock(PyThread_type_lock arg0);

@NoException public static native @Cast("size_t") long PyThread_get_stacksize();
@NoException public static native int PyThread_set_stacksize(@Cast("size_t") long arg0);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyThread_GetInfo();
// #endif


/* Thread Local Storage (TLS) API
   TLS API is DEPRECATED.  Use Thread Specific Storage (TSS) API.

   The existing TLS API has used int to represent TLS keys across all
   platforms, but it is not POSIX-compliant.  Therefore, the new TSS API uses
   opaque data type to represent TSS keys to be compatible (see PEP 539).
*/
@NoException public static native @Deprecated int PyThread_create_key();
@NoException public static native @Deprecated void PyThread_delete_key(int key);
@NoException public static native @Deprecated int PyThread_set_key_value(int key,
                                                          Pointer value);
@NoException public static native @Deprecated Pointer PyThread_get_key_value(int key);
@NoException public static native @Deprecated void PyThread_delete_key_value(int key);

/* Cleanup after a fork */
@NoException public static native @Deprecated void PyThread_ReInitTLS();
// Targeting ../Py_tss_t.java

  /* opaque */

@NoException public static native Py_tss_t PyThread_tss_alloc();
@NoException public static native void PyThread_tss_free(Py_tss_t key);

/* The parameter key must not be NULL. */
@NoException public static native int PyThread_tss_is_created(Py_tss_t key);
@NoException public static native int PyThread_tss_create(Py_tss_t key);
@NoException public static native void PyThread_tss_delete(Py_tss_t key);
@NoException public static native int PyThread_tss_set(Py_tss_t key, Pointer value);
@NoException public static native Pointer PyThread_tss_get(Py_tss_t key);
// #endif  /* New in 3.7 */

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_PYTHREAD_H
// #  include "cpython/pythread.h"
// #  undef Py_CPYTHON_PYTHREAD_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYTHREAD_H */


// Parsed from pystate.h

/* Thread and interpreter state structures and their interfaces */


// #ifndef Py_PYSTATE_H
// #define Py_PYSTATE_H
// #ifdef __cplusplus
// #endif

/* This limitation is for performance and simplicity. If needed it can be
removed (with effort). */
public static final int MAX_CO_EXTRA_USERS = 255;

@NoException public static native PyInterpreterState PyInterpreterState_New();
@NoException public static native void PyInterpreterState_Clear(PyInterpreterState arg0);
@NoException public static native void PyInterpreterState_Delete(PyInterpreterState arg0);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
/* New in 3.9 */
/* Get the current interpreter state.

   Issue a fatal error if there no current Python thread state or no current
   interpreter. It cannot return NULL.

   The caller must hold the GIL. */
@NoException public static native PyInterpreterState PyInterpreterState_Get();
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03080000
/* New in 3.8 */
@NoException public static native PyObject PyInterpreterState_GetDict(PyInterpreterState arg0);
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000
/* New in 3.7 */
@NoException public static native @Cast("int64_t") long PyInterpreterState_GetID(PyInterpreterState arg0);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000

/* State unique per thread */

/* New in 3.3 */
@NoException public static native int PyState_AddModule(PyObject arg0, PyModuleDef arg1);
@NoException public static native int PyState_RemoveModule(PyModuleDef arg0);
// #endif
@NoException public static native PyObject PyState_FindModule(PyModuleDef arg0);

@NoException public static native PyThreadState PyThreadState_New(PyInterpreterState arg0);
@NoException public static native void PyThreadState_Clear(PyThreadState arg0);
@NoException public static native void PyThreadState_Delete(PyThreadState arg0);

/* Get the current thread state.

   When the current thread state is NULL, this issues a fatal error (so that
   the caller needn't check for NULL).

   The caller must hold the GIL.

   See also PyThreadState_GetUnchecked() and _PyThreadState_GET(). */
@NoException public static native PyThreadState PyThreadState_Get();

// Alias to PyThreadState_Get()
// #define PyThreadState_GET() PyThreadState_Get()

@NoException public static native PyThreadState PyThreadState_Swap(PyThreadState arg0);
@NoException public static native PyObject PyThreadState_GetDict();
@NoException public static native int PyThreadState_SetAsyncExc(@Cast("unsigned long") long arg0, PyObject arg1);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
/* New in 3.9 */
@NoException public static native PyInterpreterState PyThreadState_GetInterpreter(PyThreadState tstate);
@NoException public static native PyFrameObject PyThreadState_GetFrame(PyThreadState tstate);
@NoException public static native @Cast("uint64_t") long PyThreadState_GetID(PyThreadState tstate);
// #endif

/** enum PyGILState_STATE */
public static final int PyGILState_LOCKED = 0, PyGILState_UNLOCKED = 1;


/* Ensure that the current thread is ready to call the Python
   C API, regardless of the current state of Python, or of its
   thread lock.  This may be called as many times as desired
   by a thread so long as each call is matched with a call to
   PyGILState_Release().  In general, other thread-state APIs may
   be used between _Ensure() and _Release() calls, so long as the
   thread-state is restored to its previous state before the Release().
   For example, normal use of the Py_BEGIN_ALLOW_THREADS/
   Py_END_ALLOW_THREADS macros are acceptable.

   The return value is an opaque "handle" to the thread state when
   PyGILState_Ensure() was called, and must be passed to
   PyGILState_Release() to ensure Python is left in the same state. Even
   though recursive calls are allowed, these handles can *not* be shared -
   each unique call to PyGILState_Ensure must save the handle for its
   call to PyGILState_Release.

   When the function returns, the current thread will hold the GIL.

   Failure is a fatal error.
*/
@NoException public static native @Cast("PyGILState_STATE") int PyGILState_Ensure();

/* Release any resources previously acquired.  After this call, Python's
   state will be the same as it was prior to the corresponding
   PyGILState_Ensure() call (but generally this state will be unknown to
   the caller, hence the use of the GILState API.)

   Every call to PyGILState_Ensure must be matched by a call to
   PyGILState_Release on the same thread.
*/
@NoException public static native void PyGILState_Release(@Cast("PyGILState_STATE") int arg0);

/* Helper/diagnostic function - get the current thread state for
   this thread.  May return NULL if no GILState API has been used
   on the current thread.  Note that the main thread always has such a
   thread-state, even if no auto-thread-state call has been made
   on the main thread.
*/
@NoException public static native PyThreadState PyGILState_GetThisThreadState();


// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_PYSTATE_H
// #  include "cpython/pystate.h"
// #  undef Py_CPYTHON_PYSTATE_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYSTATE_H */


// Parsed from cpython/context.h

// #ifndef Py_LIMITED_API
// #ifndef Py_CONTEXT_H
// #define Py_CONTEXT_H
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyContext_Type(); public static native void PyContext_Type(PyTypeObject setter);
// Targeting ../PyContext.java



public static native @ByRef PyTypeObject PyContextVar_Type(); public static native void PyContextVar_Type(PyTypeObject setter);
// Targeting ../PyContextVar.java



public static native @ByRef PyTypeObject PyContextToken_Type(); public static native void PyContextToken_Type(PyTypeObject setter);
// Targeting ../PyContextToken.java




// #define PyContext_CheckExact(o) Py_IS_TYPE((o), &PyContext_Type)
// #define PyContextVar_CheckExact(o) Py_IS_TYPE((o), &PyContextVar_Type)
// #define PyContextToken_CheckExact(o) Py_IS_TYPE((o), &PyContextToken_Type)


@NoException public static native PyObject PyContext_New();
@NoException public static native PyObject PyContext_Copy(PyObject arg0);
@NoException public static native PyObject PyContext_CopyCurrent();

@NoException public static native int PyContext_Enter(PyObject arg0);
@NoException public static native int PyContext_Exit(PyObject arg0);

/** enum PyContextEvent */
public static final int
    /*
     * The current context has switched to a different context.  The object
     * passed to the watch callback is the now-current contextvars.Context
     * object, or None if no context is current.
     */
    Py_CONTEXT_SWITCHED = 1;
// Targeting ../PyContext_WatchCallback.java



/*
 * Register a per-interpreter callback that will be invoked for context object
 * enter/exit events.
 *
 * Returns a handle that may be passed to PyContext_ClearWatcher on success,
 * or -1 and sets and error if no more handles are available.
 */
@NoException public static native int PyContext_AddWatcher(PyContext_WatchCallback callback);

/*
 * Clear the watcher associated with the watcher_id handle.
 *
 * Returns 0 on success or -1 if no watcher exists for the provided id.
 */
@NoException public static native int PyContext_ClearWatcher(int watcher_id);

/* Create a new context variable.

   default_value can be NULL.
*/
@NoException public static native PyObject PyContextVar_New(
    @Cast("const char*") BytePointer name, PyObject default_value);
@NoException public static native PyObject PyContextVar_New(
    String name, PyObject default_value);


/* Get a value for the variable.

   Returns -1 if an error occurred during lookup.

   Returns 0 if value either was or was not found.

   If value was found, *value will point to it.
   If not, it will point to:

   - default_value, if not NULL;
   - the default value of "var", if not NULL;
   - NULL.

   '*value' will be a new ref, if not NULL.
*/
@NoException public static native int PyContextVar_Get(
    PyObject var, PyObject default_value, @Cast("PyObject**") PointerPointer value);
@NoException public static native int PyContextVar_Get(
    PyObject var, PyObject default_value, @ByPtrPtr PyObject value);


/* Set a new value for the variable.
   Returns NULL if an error occurs.
*/
@NoException public static native PyObject PyContextVar_Set(PyObject var, PyObject value);


/* Reset a variable to its previous value.
   Returns 0 on success, -1 on error.
*/
@NoException public static native int PyContextVar_Reset(PyObject var, PyObject token);


// #ifdef __cplusplus
// #endif
// #endif /* !Py_CONTEXT_H */
// #endif /* !Py_LIMITED_API */


// Parsed from cpython/initconfig.h

// #ifndef Py_PYCORECONFIG_H
// #define Py_PYCORECONFIG_H
// #ifndef Py_LIMITED_API
// #ifdef __cplusplus
// Targeting ../PyStatus.java



@NoException public static native @ByVal PyStatus PyStatus_Ok();
@NoException public static native @ByVal PyStatus PyStatus_Error(@Cast("const char*") BytePointer err_msg);
@NoException public static native @ByVal PyStatus PyStatus_Error(String err_msg);
@NoException public static native @ByVal PyStatus PyStatus_NoMemory();
@NoException public static native @ByVal PyStatus PyStatus_Exit(int exitcode);
@NoException public static native int PyStatus_IsError(@ByVal PyStatus err);
@NoException public static native int PyStatus_IsExit(@ByVal PyStatus err);
@NoException public static native int PyStatus_Exception(@ByVal PyStatus err);
// Targeting ../PyWideStringList.java



@NoException public static native @ByVal PyStatus PyWideStringList_Append(PyWideStringList list,
    @Cast("const wchar_t*") Pointer item);
@NoException public static native @ByVal PyStatus PyWideStringList_Insert(PyWideStringList list,
    @Cast("Py_ssize_t") long index,
    @Cast("const wchar_t*") Pointer item);
// Targeting ../PyPreConfig.java



@NoException public static native void PyPreConfig_InitPythonConfig(PyPreConfig config);
@NoException public static native void PyPreConfig_InitIsolatedConfig(PyPreConfig config);
// Targeting ../PyConfig.java



@NoException public static native void PyConfig_InitPythonConfig(PyConfig config);
@NoException public static native void PyConfig_InitIsolatedConfig(PyConfig config);
@NoException public static native void PyConfig_Clear(PyConfig arg0);
@NoException public static native @ByVal PyStatus PyConfig_SetString(
    PyConfig config,
    @Cast("wchar_t**") PointerPointer config_str,
    @Cast("const wchar_t*") Pointer str);
@NoException public static native @ByVal PyStatus PyConfig_SetString(
    PyConfig config,
    @Cast("wchar_t**") @ByPtrPtr Pointer config_str,
    @Cast("const wchar_t*") Pointer str);
@NoException public static native @ByVal PyStatus PyConfig_SetBytesString(
    PyConfig config,
    @Cast("wchar_t**") PointerPointer config_str,
    @Cast("const char*") BytePointer str);
@NoException public static native @ByVal PyStatus PyConfig_SetBytesString(
    PyConfig config,
    @Cast("wchar_t**") @ByPtrPtr Pointer config_str,
    @Cast("const char*") BytePointer str);
@NoException public static native @ByVal PyStatus PyConfig_SetBytesString(
    PyConfig config,
    @Cast("wchar_t**") @ByPtrPtr Pointer config_str,
    String str);
@NoException public static native @ByVal PyStatus PyConfig_Read(PyConfig config);
@NoException public static native @ByVal PyStatus PyConfig_SetBytesArgv(
    PyConfig config,
    @Cast("Py_ssize_t") long argc,
    @Cast("char*const*") PointerPointer argv);
@NoException public static native @ByVal PyStatus PyConfig_SetBytesArgv(
    PyConfig config,
    @Cast("Py_ssize_t") long argc,
    @Cast("char*const*") @ByPtrPtr BytePointer argv);
@NoException public static native @ByVal PyStatus PyConfig_SetBytesArgv(
    PyConfig config,
    @Cast("Py_ssize_t") long argc,
    @Cast("char*const*") @ByPtrPtr ByteBuffer argv);
@NoException public static native @ByVal PyStatus PyConfig_SetBytesArgv(
    PyConfig config,
    @Cast("Py_ssize_t") long argc,
    @Cast("char*const*") @ByPtrPtr byte[] argv);
@NoException public static native @ByVal PyStatus PyConfig_SetArgv(PyConfig config,
    @Cast("Py_ssize_t") long argc,
    @Cast("wchar_t*const*") PointerPointer argv);
@NoException public static native @ByVal PyStatus PyConfig_SetArgv(PyConfig config,
    @Cast("Py_ssize_t") long argc,
    @Cast("wchar_t*const*") @ByPtrPtr Pointer argv);
@NoException public static native @ByVal PyStatus PyConfig_SetWideStringList(PyConfig config,
    PyWideStringList list,
    @Cast("Py_ssize_t") long length, @Cast("wchar_t**") PointerPointer items);
@NoException public static native @ByVal PyStatus PyConfig_SetWideStringList(PyConfig config,
    PyWideStringList list,
    @Cast("Py_ssize_t") long length, @Cast("wchar_t**") @ByPtrPtr Pointer items);


/* --- PyConfig_Get() ----------------------------------------- */

@NoException public static native PyObject PyConfig_Get(@Cast("const char*") BytePointer name);
@NoException public static native PyObject PyConfig_Get(String name);
@NoException public static native int PyConfig_GetInt(@Cast("const char*") BytePointer name, IntPointer value);
@NoException public static native int PyConfig_GetInt(String name, IntBuffer value);
@NoException public static native int PyConfig_GetInt(@Cast("const char*") BytePointer name, int[] value);
@NoException public static native int PyConfig_GetInt(String name, IntPointer value);
@NoException public static native int PyConfig_GetInt(@Cast("const char*") BytePointer name, IntBuffer value);
@NoException public static native int PyConfig_GetInt(String name, int[] value);
@NoException public static native PyObject PyConfig_Names();
@NoException public static native int PyConfig_Set(@Cast("const char*") BytePointer name, PyObject value);
@NoException public static native int PyConfig_Set(String name, PyObject value);


/* --- Helper functions --------------------------------------- */

/* Get the original command line arguments, before Python modified them.

   See also PyConfig.orig_argv. */
@NoException public static native void Py_GetArgcArgv(IntPointer argc, @Cast("wchar_t***") @ByPtrPtr PointerPointer argv);
@NoException public static native void Py_GetArgcArgv(IntBuffer argc, @Cast("wchar_t***") @ByPtrPtr PointerPointer argv);
@NoException public static native void Py_GetArgcArgv(int[] argc, @Cast("wchar_t***") @ByPtrPtr PointerPointer argv);
// Targeting ../PyInitConfig.java



@NoException public static native PyInitConfig PyInitConfig_Create();
@NoException public static native void PyInitConfig_Free(PyInitConfig config);

@NoException public static native int PyInitConfig_GetError(PyInitConfig config,
    @Cast("const char**") PointerPointer err_msg);
@NoException public static native int PyInitConfig_GetError(PyInitConfig config,
    @Cast("const char**") @ByPtrPtr BytePointer err_msg);
@NoException public static native int PyInitConfig_GetError(PyInitConfig config,
    @Cast("const char**") @ByPtrPtr ByteBuffer err_msg);
@NoException public static native int PyInitConfig_GetError(PyInitConfig config,
    @Cast("const char**") @ByPtrPtr byte[] err_msg);
@NoException public static native int PyInitConfig_GetExitCode(PyInitConfig config,
    IntPointer exitcode);
@NoException public static native int PyInitConfig_GetExitCode(PyInitConfig config,
    IntBuffer exitcode);
@NoException public static native int PyInitConfig_GetExitCode(PyInitConfig config,
    int[] exitcode);

@NoException public static native int PyInitConfig_HasOption(PyInitConfig config,
    @Cast("const char*") BytePointer name);
@NoException public static native int PyInitConfig_HasOption(PyInitConfig config,
    String name);
@NoException public static native int PyInitConfig_GetInt(PyInitConfig config,
    @Cast("const char*") BytePointer name,
    @Cast("int64_t*") LongPointer value);
@NoException public static native int PyInitConfig_GetInt(PyInitConfig config,
    String name,
    @Cast("int64_t*") LongBuffer value);
@NoException public static native int PyInitConfig_GetInt(PyInitConfig config,
    @Cast("const char*") BytePointer name,
    @Cast("int64_t*") long[] value);
@NoException public static native int PyInitConfig_GetInt(PyInitConfig config,
    String name,
    @Cast("int64_t*") LongPointer value);
@NoException public static native int PyInitConfig_GetInt(PyInitConfig config,
    @Cast("const char*") BytePointer name,
    @Cast("int64_t*") LongBuffer value);
@NoException public static native int PyInitConfig_GetInt(PyInitConfig config,
    String name,
    @Cast("int64_t*") long[] value);
@NoException public static native int PyInitConfig_GetStr(PyInitConfig config,
    @Cast("const char*") BytePointer name,
    @Cast("char**") PointerPointer value);
@NoException public static native int PyInitConfig_GetStr(PyInitConfig config,
    @Cast("const char*") BytePointer name,
    @Cast("char**") @ByPtrPtr BytePointer value);
@NoException public static native int PyInitConfig_GetStr(PyInitConfig config,
    String name,
    @Cast("char**") @ByPtrPtr ByteBuffer value);
@NoException public static native int PyInitConfig_GetStr(PyInitConfig config,
    @Cast("const char*") BytePointer name,
    @Cast("char**") @ByPtrPtr byte[] value);
@NoException public static native int PyInitConfig_GetStr(PyInitConfig config,
    String name,
    @Cast("char**") @ByPtrPtr BytePointer value);
@NoException public static native int PyInitConfig_GetStr(PyInitConfig config,
    @Cast("const char*") BytePointer name,
    @Cast("char**") @ByPtrPtr ByteBuffer value);
@NoException public static native int PyInitConfig_GetStr(PyInitConfig config,
    String name,
    @Cast("char**") @ByPtrPtr byte[] value);
@NoException public static native int PyInitConfig_GetStrList(PyInitConfig config,
    @Cast("const char*") BytePointer name,
    @Cast("size_t*") SizeTPointer length,
    @Cast("char***") @ByPtrPtr PointerPointer items);
@NoException public static native int PyInitConfig_GetStrList(PyInitConfig config,
    String name,
    @Cast("size_t*") SizeTPointer length,
    @Cast("char***") @ByPtrPtr PointerPointer items);
@NoException public static native void PyInitConfig_FreeStrList(@Cast("size_t") long length, @Cast("char**") PointerPointer items);
@NoException public static native void PyInitConfig_FreeStrList(@Cast("size_t") long length, @Cast("char**") @ByPtrPtr BytePointer items);
@NoException public static native void PyInitConfig_FreeStrList(@Cast("size_t") long length, @Cast("char**") @ByPtrPtr ByteBuffer items);
@NoException public static native void PyInitConfig_FreeStrList(@Cast("size_t") long length, @Cast("char**") @ByPtrPtr byte[] items);

@NoException public static native int PyInitConfig_SetInt(PyInitConfig config,
    @Cast("const char*") BytePointer name,
    @Cast("int64_t") long value);
@NoException public static native int PyInitConfig_SetInt(PyInitConfig config,
    String name,
    @Cast("int64_t") long value);
@NoException public static native int PyInitConfig_SetStr(PyInitConfig config,
    @Cast("const char*") BytePointer name,
    @Cast("const char*") BytePointer value);
@NoException public static native int PyInitConfig_SetStr(PyInitConfig config,
    String name,
    String value);
@NoException public static native int PyInitConfig_SetStrList(PyInitConfig config,
    @Cast("const char*") BytePointer name,
    @Cast("size_t") long length,
    @Cast("char*const*") PointerPointer items);
@NoException public static native int PyInitConfig_SetStrList(PyInitConfig config,
    @Cast("const char*") BytePointer name,
    @Cast("size_t") long length,
    @Cast("char*const*") @ByPtrPtr BytePointer items);
@NoException public static native int PyInitConfig_SetStrList(PyInitConfig config,
    String name,
    @Cast("size_t") long length,
    @Cast("char*const*") @ByPtrPtr ByteBuffer items);
@NoException public static native int PyInitConfig_SetStrList(PyInitConfig config,
    @Cast("const char*") BytePointer name,
    @Cast("size_t") long length,
    @Cast("char*const*") @ByPtrPtr byte[] items);
@NoException public static native int PyInitConfig_SetStrList(PyInitConfig config,
    String name,
    @Cast("size_t") long length,
    @Cast("char*const*") @ByPtrPtr BytePointer items);
@NoException public static native int PyInitConfig_SetStrList(PyInitConfig config,
    @Cast("const char*") BytePointer name,
    @Cast("size_t") long length,
    @Cast("char*const*") @ByPtrPtr ByteBuffer items);
@NoException public static native int PyInitConfig_SetStrList(PyInitConfig config,
    String name,
    @Cast("size_t") long length,
    @Cast("char*const*") @ByPtrPtr byte[] items);
// Targeting ../PyObject_Initfunc.java


@NoException public static native int PyInitConfig_AddModule(PyInitConfig config,
    @Cast("const char*") BytePointer name,
    PyObject_Initfunc initfunc);
@NoException public static native int PyInitConfig_AddModule(PyInitConfig config,
    String name,
    PyObject_Initfunc initfunc);

@NoException public static native int Py_InitializeFromInitConfig(PyInitConfig config);


// #ifdef __cplusplus
// #endif
// #endif /* !Py_LIMITED_API */
// #endif /* !Py_PYCORECONFIG_H */


// Parsed from cpython/pystate.h

// #ifndef Py_CPYTHON_PYSTATE_H
// #  error "this header file must not be included directly"
// #endif


/* private interpreter helpers */

@NoException public static native int _PyInterpreterState_RequiresIDRef(PyInterpreterState arg0);
@NoException public static native void _PyInterpreterState_RequireIDRef(PyInterpreterState arg0, int arg1);
// Targeting ../Py_tracefunc.java



/* The following values are used for 'what' for tracefunc functions
 *
 * To add a new kind of trace event, also update "trace_init" in
 * Python/sysmodule.c to define the Python level event name
 */
public static final int PyTrace_CALL = 0;
public static final int PyTrace_EXCEPTION = 1;
public static final int PyTrace_LINE = 2;
public static final int PyTrace_RETURN = 3;
public static final int PyTrace_C_CALL = 4;
public static final int PyTrace_C_EXCEPTION = 5;
public static final int PyTrace_C_RETURN = 6;
public static final int PyTrace_OPCODE = 7;

/* Remote debugger support */
public static final int _Py_MAX_SCRIPT_PATH_SIZE = 512;
// Targeting ../_PyRemoteDebuggerSupport.java


// Targeting ../_PyErr_StackItem.java


// Targeting ../_PyStackChunk.java



/* Minimum size of data stack chunk */
public static final int _PY_DATA_STACK_CHUNK_SIZE = (16*1024);
// Targeting ../PyThreadState.java



/* other API */

/* Similar to PyThreadState_Get(), but don't issue a fatal error
 * if it is NULL. */
@NoException public static native PyThreadState PyThreadState_GetUnchecked();

// Deprecated alias kept for backward compatibility
@NoException public static native @Deprecated PyThreadState _PyThreadState_UncheckedGet();

// Disable tracing and profiling.
@NoException public static native void PyThreadState_EnterTracing(PyThreadState tstate);

// Reset tracing and profiling: enable them if a trace function or a profile
// function is set, otherwise disable them.
@NoException public static native void PyThreadState_LeaveTracing(PyThreadState tstate);

/* PyGILState */

/* Helper/diagnostic function - return 1 if the current thread
   currently holds the GIL, 0 otherwise.

   The function returns 1 if _PyGILState_check_enabled is non-zero. */
@NoException public static native int PyGILState_Check();

/* The implementation of sys._current_frames()  Returns a dict mapping
   thread id to that thread's current frame.
*/
@NoException public static native PyObject _PyThread_CurrentFrames();

// Set the stack protection start address and stack protection size
// of a Python thread state
@NoException public static native int PyUnstable_ThreadState_SetStackProtection(
    PyThreadState tstate,
    Pointer stack_start_addr,
    @Cast("size_t") long stack_size);      // Stack size (in bytes)

// Reset the stack protection start address and stack protection size
// of a Python thread state
@NoException public static native void PyUnstable_ThreadState_ResetStackProtection(
    PyThreadState tstate);

/* Routines for advanced debuggers, requested by David Beazley.
   Don't use unless you know what you are doing! */
@NoException public static native PyInterpreterState PyInterpreterState_Main();
@NoException public static native PyInterpreterState PyInterpreterState_Head();
@NoException public static native PyInterpreterState PyInterpreterState_Next(PyInterpreterState arg0);
@NoException public static native PyThreadState PyInterpreterState_ThreadHead(PyInterpreterState arg0);
@NoException public static native PyThreadState PyThreadState_Next(PyThreadState arg0);
@NoException public static native void PyThreadState_DeleteCurrent();
// Targeting ../_PyFrameEvalFunction.java



@NoException public static native _PyFrameEvalFunction _PyInterpreterState_GetEvalFrameFunc(
    PyInterpreterState interp);
@NoException public static native void _PyInterpreterState_SetEvalFrameFunc(
    PyInterpreterState interp,
    _PyFrameEvalFunction eval_frame);


// Parsed from modsupport.h

// Module support interface

// #ifndef Py_MODSUPPORT_H
// #define Py_MODSUPPORT_H
// #ifdef __cplusplus
// #endif

public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7, Pointer vararg8);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7, Pointer vararg8, Pointer vararg9);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7, Pointer vararg8);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7, Pointer vararg8, Pointer vararg9);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1, Pointer vararg2);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7, Pointer vararg8);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7, Pointer vararg8, Pointer vararg9);
@NoException public static native int PyArg_VaParse(PyObject arg0, @Cast("const char*") BytePointer arg1, @ByVal @Cast("va_list*") Pointer arg2);
@NoException public static native int PyArg_VaParse(PyObject arg0, String arg1, @ByVal @Cast("va_list*") Pointer arg2);
@NoException public static native int PyArg_VaParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                              @Cast("const char*") BytePointer arg2, @Cast("char*const*") PointerPointer arg3, @ByVal @Cast("va_list*") Pointer arg4);
@NoException public static native int PyArg_VaParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                              @Cast("const char*") BytePointer arg2, @Cast("char*const*") @ByPtrPtr BytePointer arg3, @ByVal @Cast("va_list*") Pointer arg4);
@NoException public static native int PyArg_VaParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                              String arg2, @Cast("char*const*") @ByPtrPtr ByteBuffer arg3, @ByVal @Cast("va_list*") Pointer arg4);
@NoException public static native int PyArg_VaParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                              @Cast("const char*") BytePointer arg2, @Cast("char*const*") @ByPtrPtr byte[] arg3, @ByVal @Cast("va_list*") Pointer arg4);
@NoException public static native int PyArg_VaParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                              String arg2, @Cast("char*const*") @ByPtrPtr BytePointer arg3, @ByVal @Cast("va_list*") Pointer arg4);
@NoException public static native int PyArg_VaParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                              @Cast("const char*") BytePointer arg2, @Cast("char*const*") @ByPtrPtr ByteBuffer arg3, @ByVal @Cast("va_list*") Pointer arg4);
@NoException public static native int PyArg_VaParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                              String arg2, @Cast("char*const*") @ByPtrPtr byte[] arg3, @ByVal @Cast("va_list*") Pointer arg4);

@NoException public static native int PyArg_ValidateKeywordArguments(PyObject arg0);
@NoException public static native int PyArg_UnpackTuple(PyObject arg0, @Cast("const char*") BytePointer arg1, @Cast("Py_ssize_t") long arg2, @Cast("Py_ssize_t") long arg3);
@NoException public static native int PyArg_UnpackTuple(PyObject arg0, String arg1, @Cast("Py_ssize_t") long arg2, @Cast("Py_ssize_t") long arg3);
@NoException public static native PyObject Py_BuildValue(@Cast("const char*") BytePointer arg0);
@NoException public static native PyObject Py_BuildValue(String arg0);
@NoException public static native PyObject Py_VaBuildValue(@Cast("const char*") BytePointer arg0, @ByVal @Cast("va_list*") Pointer arg1);
@NoException public static native PyObject Py_VaBuildValue(String arg0, @ByVal @Cast("va_list*") Pointer arg1);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030a0000
// Add an attribute with name 'name' and value 'obj' to the module 'mod.
// On success, return 0.
// On error, raise an exception and return -1.
@NoException public static native int PyModule_AddObjectRef(PyObject mod, @Cast("const char*") BytePointer name, PyObject value);
@NoException public static native int PyModule_AddObjectRef(PyObject mod, String name, PyObject value);
// #endif   /* Py_LIMITED_API */

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000
// Similar to PyModule_AddObjectRef() but steal a reference to 'value'.
@NoException public static native int PyModule_Add(PyObject mod, @Cast("const char*") BytePointer name, PyObject value);
@NoException public static native int PyModule_Add(PyObject mod, String name, PyObject value);
// #endif   /* Py_LIMITED_API */

// Similar to PyModule_AddObjectRef() and PyModule_Add() but steal
// a reference to 'value' on success and only on success.
// Errorprone. Should not be used in new code.
@NoException public static native int PyModule_AddObject(PyObject mod, @Cast("const char*") BytePointer arg1, PyObject value);
@NoException public static native int PyModule_AddObject(PyObject mod, String arg1, PyObject value);

@NoException public static native int PyModule_AddIntConstant(PyObject arg0, @Cast("const char*") BytePointer arg1, long arg2);
@NoException public static native int PyModule_AddIntConstant(PyObject arg0, String arg1, long arg2);
@NoException public static native int PyModule_AddStringConstant(PyObject arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2);
@NoException public static native int PyModule_AddStringConstant(PyObject arg0, String arg1, String arg2);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
/* New in 3.9 */
@NoException public static native int PyModule_AddType(PyObject module, PyTypeObject type);
// #endif /* Py_LIMITED_API */

// #define PyModule_AddIntMacro(m, c) PyModule_AddIntConstant((m), #c, (c))
// #define PyModule_AddStringMacro(m, c) PyModule_AddStringConstant((m), #c, (c))

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* New in 3.5 */
@NoException public static native int PyModule_SetDocString(PyObject arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native int PyModule_SetDocString(PyObject arg0, String arg1);
@NoException public static native int PyModule_AddFunctions(PyObject arg0, PyMethodDef arg1);
@NoException public static native int PyModule_ExecDef(PyObject module, PyModuleDef def);
// #endif

public static final int Py_CLEANUP_SUPPORTED = 0x20000;

public static final int PYTHON_API_VERSION = 1013;
public static final String PYTHON_API_STRING = "1013";
/* The API version is maintained (independently from the Python version)
   so we can detect mismatches between the interpreter and dynamically
   loaded modules.  These are diagnosed by an error message but
   the module is still loaded (because the mismatch can only be tested
   after loading the module).  The error message is intended to
   explain the core dump a few seconds later.

   The symbol PYTHON_API_STRING defines the same value as a string
   literal.  *** PLEASE MAKE SURE THE DEFINITIONS MATCH. ***

   Please add a line or two to the top of this log for each API
   version change:

   22-Feb-2006  MvL     1013    PEP 353 - long indices for sequence lengths

   19-Aug-2002  GvR     1012    Changes to string object struct for
                                interning changes, saving 3 bytes.

   17-Jul-2001  GvR     1011    Descr-branch, just to be on the safe side

   25-Jan-2001  FLD     1010    Parameters added to PyCode_New() and
                                PyFrame_New(); Python 2.1a2

   14-Mar-2000  GvR     1009    Unicode API added

   3-Jan-1999   GvR     1007    Decided to change back!  (Don't reuse 1008!)

   3-Dec-1998   GvR     1008    Python 1.5.2b1

   18-Jan-1997  GvR     1007    string interning and other speedups

   11-Oct-1996  GvR     renamed Py_Ellipses to Py_Ellipsis :-(

   30-Jul-1996  GvR     Slice and ellipses syntax added

   23-Jul-1996  GvR     For 1.4 -- better safe than sorry this time :-)

   7-Nov-1995   GvR     Keyword arguments (should've been done at 1.3 :-( )

   10-Jan-1995  GvR     Renamed globals to new naming scheme

   9-Jan-1995   GvR     Initial version (incompatible with older API)
*/

/* The PYTHON_ABI_VERSION is introduced in PEP 384. For the lifetime of
   Python 3, it will stay at the value of 3; changes to the limited API
   must be performed in a strictly backwards-compatible manner. */
public static final int PYTHON_ABI_VERSION = 3;
public static final String PYTHON_ABI_STRING = "3";

@NoException public static native PyObject PyModule_Create2(PyModuleDef arg0, int apiver);

// #ifdef Py_LIMITED_API
// #define PyModule_Create(module)
//         PyModule_Create2((module), PYTHON_ABI_VERSION)
// #else
// #define PyModule_Create(module)
//         PyModule_Create2((module), PYTHON_API_VERSION)
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* New in 3.5 */
@NoException public static native PyObject PyModule_FromDefAndSpec2(PyModuleDef def,
                                                PyObject spec,
                                                int module_api_version);

// #ifdef Py_LIMITED_API
// #define PyModule_FromDefAndSpec(module, spec)
//     PyModule_FromDefAndSpec2((module), (spec), PYTHON_ABI_VERSION)
// #else
// #define PyModule_FromDefAndSpec(module, spec)
//     PyModule_FromDefAndSpec2((module), (spec), PYTHON_API_VERSION)
// #endif /* Py_LIMITED_API */

// #endif /* New in 3.5 */

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_MODSUPPORT_H
// #  include "cpython/modsupport.h"
// #  undef Py_CPYTHON_MODSUPPORT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_MODSUPPORT_H */


// Parsed from ceval.h

/* Interface to random parts in ceval.c */

// #ifndef Py_CEVAL_H
// #define Py_CEVAL_H
// #ifdef __cplusplus
// #endif


@NoException public static native PyObject PyEval_EvalCode(PyObject arg0, PyObject arg1, PyObject arg2);

@NoException public static native PyObject PyEval_EvalCodeEx(PyObject co,
                                         PyObject globals,
                                         PyObject locals,
                                         @Cast("PyObject*const*") PointerPointer args, int argc,
                                         @Cast("PyObject*const*") PointerPointer kwds, int kwdc,
                                         @Cast("PyObject*const*") PointerPointer defs, int defc,
                                         PyObject kwdefs, PyObject closure);
@NoException public static native PyObject PyEval_EvalCodeEx(PyObject co,
                                         PyObject globals,
                                         PyObject locals,
                                         @ByPtrPtr PyObject args, int argc,
                                         @ByPtrPtr PyObject kwds, int kwdc,
                                         @ByPtrPtr PyObject defs, int defc,
                                         PyObject kwdefs, PyObject closure);

@NoException public static native PyObject PyEval_GetBuiltins();
@NoException public static native PyObject PyEval_GetGlobals();
@NoException public static native PyObject PyEval_GetLocals();
@NoException public static native PyFrameObject PyEval_GetFrame();

@NoException public static native PyObject PyEval_GetFrameBuiltins();
@NoException public static native PyObject PyEval_GetFrameGlobals();
@NoException public static native PyObject PyEval_GetFrameLocals();
// Targeting ../Func_Pointer.java


@NoException public static native int Py_AddPendingCall(Func_Pointer func, Pointer arg);
@NoException public static native int Py_MakePendingCalls();

/* Protection against deeply nested recursive calls

   In Python 3.0, this protection has two levels:
   * normal anti-recursion protection is triggered when the recursion level
     exceeds the current recursion limit. It raises a RecursionError, and sets
     the "overflowed" flag in the thread state structure. This flag
     temporarily *disables* the normal protection; this allows cleanup code
     to potentially outgrow the recursion limit while processing the
     RecursionError.
   * "last chance" anti-recursion protection is triggered when the recursion
     level exceeds "current recursion limit + 50". By construction, this
     protection can only be triggered when the "overflowed" flag is set. It
     means the cleanup code has itself gone into an infinite loop, or the
     RecursionError has been mistakenly ignored. When this protection is
     triggered, the interpreter aborts with a Fatal Error.

   In addition, the "overflowed" flag is automatically reset when the
   recursion level drops below "current recursion limit - 50". This heuristic
   is meant to ensure that the normal anti-recursion protection doesn't get
   disabled too long.

   Please note: this scheme has its own limitations. See:
   http://mail.python.org/pipermail/python-dev/2008-August/082106.html
   for some observations.
*/
@NoException public static native void Py_SetRecursionLimit(int arg0);
@NoException public static native int Py_GetRecursionLimit();

@NoException public static native int Py_EnterRecursiveCall(@Cast("const char*") BytePointer where);
@NoException public static native int Py_EnterRecursiveCall(String where);
@NoException public static native void Py_LeaveRecursiveCall();

@NoException public static native @Cast("const char*") BytePointer PyEval_GetFuncName(PyObject arg0);
@NoException public static native @Cast("const char*") BytePointer PyEval_GetFuncDesc(PyObject arg0);

@NoException public static native PyObject PyEval_EvalFrame(PyFrameObject arg0);
@NoException public static native PyObject PyEval_EvalFrameEx(PyFrameObject f, int exc);

/* Interface for threads.

   A module that plans to do a blocking system call (or something else
   that lasts a long time and doesn't touch Python data) can allow other
   threads to run as follows:

    ...preparations here...
    Py_BEGIN_ALLOW_THREADS
    ...blocking system call here...
    Py_END_ALLOW_THREADS
    ...interpret result here...

   The Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS pair expands to a
   {}-surrounded block.
   To leave the block in the middle (e.g., with return), you must insert
   a line containing Py_BLOCK_THREADS before the return, e.g.

    if (...premature_exit...) {
        Py_BLOCK_THREADS
        PyErr_SetFromErrno(PyExc_OSError);
        return NULL;
    }

   An alternative is:

    Py_BLOCK_THREADS
    if (...premature_exit...) {
        PyErr_SetFromErrno(PyExc_OSError);
        return NULL;
    }
    Py_UNBLOCK_THREADS

   For convenience, that the value of 'errno' is restored across
   Py_END_ALLOW_THREADS and Py_BLOCK_THREADS.

   WARNING: NEVER NEST CALLS TO Py_BEGIN_ALLOW_THREADS AND
   Py_END_ALLOW_THREADS!!!

   Note that not yet all candidates have been converted to use this
   mechanism!
*/

@NoException public static native PyThreadState PyEval_SaveThread();
@NoException public static native void PyEval_RestoreThread(PyThreadState arg0);

@NoException public static native @Deprecated void PyEval_InitThreads();

@NoException public static native void PyEval_AcquireThread(PyThreadState tstate);
@NoException public static native void PyEval_ReleaseThread(PyThreadState tstate);

// #define Py_BEGIN_ALLOW_THREADS {
//                         PyThreadState *_save;
//                         _save = PyEval_SaveThread();
// #define Py_BLOCK_THREADS        PyEval_RestoreThread(_save);
// #define Py_UNBLOCK_THREADS      _save = PyEval_SaveThread();
// #define Py_END_ALLOW_THREADS    PyEval_RestoreThread(_save);
//                  }

/* Masks and values used by FORMAT_VALUE opcode. */
public static final int FVC_MASK =      0x3;
public static final int FVC_NONE =      0x0;
public static final int FVC_STR =       0x1;
public static final int FVC_REPR =      0x2;
public static final int FVC_ASCII =     0x3;
public static final int FVS_MASK =      0x4;
public static final int FVS_HAVE_SPEC = 0x4;

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_CEVAL_H
// #  include "cpython/ceval.h"
// #  undef Py_CPYTHON_CEVAL_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_CEVAL_H */


// Parsed from cpython/ceval.h

// #ifndef Py_CPYTHON_CEVAL_H
// #  error "this header file must not be included directly"
// #endif

@NoException public static native void PyEval_SetProfile(Py_tracefunc arg0, PyObject arg1);
@NoException public static native void PyEval_SetProfileAllThreads(Py_tracefunc arg0, PyObject arg1);
@NoException public static native void PyEval_SetTrace(Py_tracefunc arg0, PyObject arg1);
@NoException public static native void PyEval_SetTraceAllThreads(Py_tracefunc arg0, PyObject arg1);

/* Look at the current frame's (if any) code's co_flags, and turn on
   the corresponding compiler flags in cf->cf_flags.  Return 1 if any
   flag was set, else return 0. */
@NoException public static native int PyEval_MergeCompilerFlags(PyCompilerFlags cf);

@NoException public static native PyObject _PyEval_EvalFrameDefault(PyThreadState tstate, @Cast("_PyInterpreterFrame*") Pointer f, int exc);

@NoException public static native @Cast("Py_ssize_t") long PyUnstable_Eval_RequestCodeExtraIndex(freefunc arg0);
// Old name -- remove when this API changes:
@NoException public static native @Cast("Py_ssize_t") @Deprecated long _PyEval_RequestCodeExtraIndex(freefunc f);

@NoException public static native int _PyEval_SliceIndex(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);
@NoException public static native int _PyEval_SliceIndexNotNone(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);
// Targeting ../PerfMapState.java



@NoException public static native int PyUnstable_PerfMapState_Init();
@NoException public static native int PyUnstable_WritePerfMapEntry(
    @Const Pointer code_addr,
    @Cast("unsigned int") int code_size,
    @Cast("const char*") BytePointer entry_name);
@NoException public static native int PyUnstable_WritePerfMapEntry(
    @Const Pointer code_addr,
    @Cast("unsigned int") int code_size,
    String entry_name);
@NoException public static native void PyUnstable_PerfMapState_Fini();
@NoException public static native int PyUnstable_CopyPerfMapFile(@Cast("const char*") BytePointer parent_filename);
@NoException public static native int PyUnstable_CopyPerfMapFile(String parent_filename);
@NoException public static native int PyUnstable_PerfTrampoline_CompileCode(PyCodeObject arg0);
@NoException public static native int PyUnstable_PerfTrampoline_SetPersistAfterFork(int enable);


// Parsed from sysmodule.h

// #ifndef Py_SYSMODULE_H
// #define Py_SYSMODULE_H
// #ifdef __cplusplus
// #endif

@NoException public static native PyObject PySys_GetObject(@Cast("const char*") BytePointer arg0);
@NoException public static native PyObject PySys_GetObject(String arg0);
@NoException public static native int PySys_SetObject(@Cast("const char*") BytePointer arg0, PyObject arg1);
@NoException public static native int PySys_SetObject(String arg0, PyObject arg1);

@NoException public static native @Deprecated void PySys_SetArgv(int arg0, @Cast("wchar_t**") PointerPointer arg1);
@NoException public static native @Deprecated void PySys_SetArgv(int arg0, @Cast("wchar_t**") @ByPtrPtr Pointer arg1);
@NoException public static native @Deprecated void PySys_SetArgvEx(int arg0, @Cast("wchar_t**") PointerPointer arg1, int arg2);
@NoException public static native @Deprecated void PySys_SetArgvEx(int arg0, @Cast("wchar_t**") @ByPtrPtr Pointer arg1, int arg2);

@NoException public static native void PySys_WriteStdout(@Cast("const char*") BytePointer format);
@NoException public static native void PySys_WriteStdout(String format);
@NoException public static native void PySys_WriteStderr(@Cast("const char*") BytePointer format);
@NoException public static native void PySys_WriteStderr(String format);
@NoException public static native void PySys_FormatStdout(@Cast("const char*") BytePointer format);
@NoException public static native void PySys_FormatStdout(String format);
@NoException public static native void PySys_FormatStderr(@Cast("const char*") BytePointer format);
@NoException public static native void PySys_FormatStderr(String format);

@NoException public static native @Deprecated void PySys_ResetWarnOptions();

@NoException public static native PyObject PySys_GetXOptions();

// #ifdef __cplusplus
// #endif
// #endif /* !Py_SYSMODULE_H */


// Parsed from osmodule.h


/* os module interface */

// #ifndef Py_OSMODULE_H
// #define Py_OSMODULE_H
// #ifdef __cplusplus
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
@NoException public static native PyObject PyOS_FSPath(PyObject path);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_OSMODULE_H */


// Parsed from intrcheck.h

// #ifndef Py_INTRCHECK_H
// #define Py_INTRCHECK_H
// #ifdef __cplusplus
// #endif

@NoException public static native int PyOS_InterruptOccurred();

// #ifdef HAVE_FORK
// #endif

/* Deprecated, please use PyOS_AfterFork_Child() instead */
@NoException public static native @Deprecated void PyOS_AfterFork();

// #ifdef __cplusplus
// #endif
// #endif /* !Py_INTRCHECK_H */


// Parsed from import.h

/* Module definition and import interface */

// #ifndef Py_IMPORT_H
// #define Py_IMPORT_H
// #ifdef __cplusplus
// #endif

@NoException public static native long PyImport_GetMagicNumber();
@NoException public static native @Cast("const char*") BytePointer PyImport_GetMagicTag();
@NoException public static native PyObject PyImport_ExecCodeModule(
    @Cast("const char*") BytePointer name,
    PyObject co
    );
@NoException public static native PyObject PyImport_ExecCodeModule(
    String name,
    PyObject co
    );
@NoException public static native PyObject PyImport_ExecCodeModuleEx(
    @Cast("const char*") BytePointer name,
    PyObject co,
    @Cast("const char*") BytePointer pathname
    );
@NoException public static native PyObject PyImport_ExecCodeModuleEx(
    String name,
    PyObject co,
    String pathname
    );
@NoException public static native PyObject PyImport_ExecCodeModuleWithPathnames(
    @Cast("const char*") BytePointer name,
    PyObject co,
    @Cast("const char*") BytePointer pathname,
    @Cast("const char*") BytePointer cpathname
    );
@NoException public static native PyObject PyImport_ExecCodeModuleWithPathnames(
    String name,
    PyObject co,
    String pathname,
    String cpathname
    );
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyImport_ExecCodeModuleObject(
    PyObject name,
    PyObject co,
    PyObject pathname,
    PyObject cpathname
    );
// #endif
@NoException public static native PyObject PyImport_GetModuleDict();
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000
@NoException public static native PyObject PyImport_GetModule(PyObject name);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyImport_AddModuleObject(
    PyObject name
    );
// #endif
@NoException public static native PyObject PyImport_AddModule(
    @Cast("const char*") BytePointer name
    );
@NoException public static native PyObject PyImport_AddModule(
    String name
    );
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000
@NoException public static native PyObject PyImport_AddModuleRef(
    @Cast("const char*") BytePointer name
    );
@NoException public static native PyObject PyImport_AddModuleRef(
    String name
    );
// #endif
@NoException public static native PyObject PyImport_ImportModule(
    @Cast("const char*") BytePointer name
    );
@NoException public static native PyObject PyImport_ImportModule(
    String name
    );
@NoException public static native @Deprecated PyObject PyImport_ImportModuleNoBlock(
    @Cast("const char*") BytePointer name
    );
@NoException public static native @Deprecated PyObject PyImport_ImportModuleNoBlock(
    String name
    );
@NoException public static native PyObject PyImport_ImportModuleLevel(
    @Cast("const char*") BytePointer name,
    PyObject globals,
    PyObject locals,
    PyObject fromlist,
    int level
    );
@NoException public static native PyObject PyImport_ImportModuleLevel(
    String name,
    PyObject globals,
    PyObject locals,
    PyObject fromlist,
    int level
    );
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
@NoException public static native PyObject PyImport_ImportModuleLevelObject(
    PyObject name,
    PyObject globals,
    PyObject locals,
    PyObject fromlist,
    int level
    );
// #endif

// #define PyImport_ImportModuleEx(n, g, l, f)
//     PyImport_ImportModuleLevel((n), (g), (l), (f), 0)

@NoException public static native PyObject PyImport_GetImporter(PyObject path);
@NoException public static native PyObject PyImport_Import(PyObject name);
@NoException public static native PyObject PyImport_ReloadModule(PyObject m);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native int PyImport_ImportFrozenModuleObject(
    PyObject name
    );
// #endif
@NoException public static native int PyImport_ImportFrozenModule(
    @Cast("const char*") BytePointer name
    );
@NoException public static native int PyImport_ImportFrozenModule(
    String name
    );

@NoException public static native int PyImport_AppendInittab(
    @Cast("const char*") BytePointer name,
    PyObject_Initfunc initfunc
    );
@NoException public static native int PyImport_AppendInittab(
    String name,
    PyObject_Initfunc initfunc
    );

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_IMPORT_H
// #  include "cpython/import.h"
// #  undef Py_CPYTHON_IMPORT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_IMPORT_H */


// Parsed from cpython/import.h

// #ifndef Py_CPYTHON_IMPORT_H
// #  error "this header file must not be included directly"
// Targeting ../_inittab.java


// This is not used after Py_Initialize() is called.
public static native _inittab PyImport_Inittab(); public static native void PyImport_Inittab(_inittab setter);
@NoException public static native int PyImport_ExtendInittab(_inittab newtab);
// Targeting ../_frozen.java



/* Embedding apps may change this pointer to point to their favorite
   collection of frozen modules: */

public static native @Const _frozen PyImport_FrozenModules(); public static native void PyImport_FrozenModules(_frozen setter);

@NoException public static native PyObject PyImport_ImportModuleAttr(
    PyObject mod_name,
    PyObject attr_name);
@NoException public static native PyObject PyImport_ImportModuleAttrString(
    @Cast("const char*") BytePointer mod_name,
    @Cast("const char*") BytePointer attr_name);
@NoException public static native PyObject PyImport_ImportModuleAttrString(
    String mod_name,
    String attr_name);


// Parsed from abstract.h

/* Abstract Object Interface (many thanks to Jim Fulton) */

// #ifndef Py_ABSTRACTOBJECT_H
// #define Py_ABSTRACTOBJECT_H
// #ifdef __cplusplus
// #endif

/* === Object Protocol ================================================== */

/* Implemented elsewhere:

   int PyObject_Print(PyObject *o, FILE *fp, int flags);

   Print an object 'o' on file 'fp'.  Returns -1 on error. The flags argument
   is used to enable certain printing options. The only option currently
   supported is Py_PRINT_RAW. By default (flags=0), PyObject_Print() formats
   the object by calling PyObject_Repr(). If flags equals to Py_PRINT_RAW, it
   formats the object by calling PyObject_Str(). */


/* Implemented elsewhere:

   int PyObject_HasAttrString(PyObject *o, const char *attr_name);

   Returns 1 if object 'o' has the attribute attr_name, and 0 otherwise.

   This is equivalent to the Python expression: hasattr(o,attr_name).

   This function always succeeds. */


/* Implemented elsewhere:

   PyObject* PyObject_GetAttrString(PyObject *o, const char *attr_name);

   Retrieve an attributed named attr_name form object o.
   Returns the attribute value on success, or NULL on failure.

   This is the equivalent of the Python expression: o.attr_name. */


/* Implemented elsewhere:

   int PyObject_HasAttr(PyObject *o, PyObject *attr_name);

   Returns 1 if o has the attribute attr_name, and 0 otherwise.

   This is equivalent to the Python expression: hasattr(o,attr_name).

   This function always succeeds. */


/* Implemented elsewhere:

   int PyObject_HasAttrStringWithError(PyObject *o, const char *attr_name);

   Returns 1 if object 'o' has the attribute attr_name, and 0 otherwise.
   This is equivalent to the Python expression: hasattr(o,attr_name).
   Returns -1 on failure. */


/* Implemented elsewhere:

   int PyObject_HasAttrWithError(PyObject *o, PyObject *attr_name);

   Returns 1 if o has the attribute attr_name, and 0 otherwise.
   This is equivalent to the Python expression: hasattr(o,attr_name).
   Returns -1 on failure. */


/* Implemented elsewhere:

   PyObject* PyObject_GetAttr(PyObject *o, PyObject *attr_name);

   Retrieve an attributed named 'attr_name' form object 'o'.
   Returns the attribute value on success, or NULL on failure.

   This is the equivalent of the Python expression: o.attr_name. */


/* Implemented elsewhere:

   int PyObject_GetOptionalAttr(PyObject *obj, PyObject *attr_name, PyObject **result);

   Variant of PyObject_GetAttr() which doesn't raise AttributeError
   if the attribute is not found.

   If the attribute is found, return 1 and set *result to a new strong
   reference to the attribute.
   If the attribute is not found, return 0 and set *result to NULL;
   the AttributeError is silenced.
   If an error other than AttributeError is raised, return -1 and
   set *result to NULL.
*/


/* Implemented elsewhere:

   int PyObject_GetOptionalAttrString(PyObject *obj, const char *attr_name, PyObject **result);

   Variant of PyObject_GetAttrString() which doesn't raise AttributeError
   if the attribute is not found.

   If the attribute is found, return 1 and set *result to a new strong
   reference to the attribute.
   If the attribute is not found, return 0 and set *result to NULL;
   the AttributeError is silenced.
   If an error other than AttributeError is raised, return -1 and
   set *result to NULL.
*/


/* Implemented elsewhere:

   int PyObject_SetAttrString(PyObject *o, const char *attr_name, PyObject *v);

   Set the value of the attribute named attr_name, for object 'o',
   to the value 'v'. Raise an exception and return -1 on failure; return 0 on
   success.

   This is the equivalent of the Python statement o.attr_name=v. */


/* Implemented elsewhere:

   int PyObject_SetAttr(PyObject *o, PyObject *attr_name, PyObject *v);

   Set the value of the attribute named attr_name, for object 'o', to the value
   'v'. an exception and return -1 on failure; return 0 on success.

   This is the equivalent of the Python statement o.attr_name=v. */

/* Implemented elsewhere:

   int PyObject_DelAttrString(PyObject *o, const char *attr_name);

   Delete attribute named attr_name, for object o. Returns
   -1 on failure.

   This is the equivalent of the Python statement: del o.attr_name.

   Implemented as a macro in the limited C API 3.12 and older. */
// #if defined(Py_LIMITED_API) && Py_LIMITED_API+0 < 0x030d0000
// #  define PyObject_DelAttrString(O, A) PyObject_SetAttrString((O), (A), NULL)
// #endif


/* Implemented elsewhere:

   int PyObject_DelAttr(PyObject *o, PyObject *attr_name);

   Delete attribute named attr_name, for object o. Returns -1
   on failure.  This is the equivalent of the Python
   statement: del o.attr_name.

   Implemented as a macro in the limited C API 3.12 and older. */
// #if defined(Py_LIMITED_API) && Py_LIMITED_API+0 < 0x030d0000
// #  define PyObject_DelAttr(O, A) PyObject_SetAttr((O), (A), NULL)
// #endif


/* Implemented elsewhere:

   PyObject *PyObject_Repr(PyObject *o);

   Compute the string representation of object 'o'.  Returns the
   string representation on success, NULL on failure.

   This is the equivalent of the Python expression: repr(o).

   Called by the repr() built-in function. */


/* Implemented elsewhere:

   PyObject *PyObject_Str(PyObject *o);

   Compute the string representation of object, o.  Returns the
   string representation on success, NULL on failure.

   This is the equivalent of the Python expression: str(o).

   Called by the str() and print() built-in functions. */


/* Declared elsewhere

   PyAPI_FUNC(int) PyCallable_Check(PyObject *o);

   Determine if the object, o, is callable.  Return 1 if the object is callable
   and 0 otherwise.

   This function always succeeds. */


// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
/* Call a callable Python object without any arguments */
@NoException public static native PyObject PyObject_CallNoArgs(PyObject func);
// #endif


/* Call a callable Python object 'callable' with arguments given by the
   tuple 'args' and keywords arguments given by the dictionary 'kwargs'.

   'args' must not be NULL, use an empty tuple if no arguments are
   needed. If no named arguments are needed, 'kwargs' can be NULL.

   This is the equivalent of the Python expression:
   callable(*args, **kwargs). */
@NoException public static native PyObject PyObject_Call(PyObject callable,
                                     PyObject args, PyObject kwargs);


/* Call a callable Python object 'callable', with arguments given by the
   tuple 'args'.  If no arguments are needed, then 'args' can be NULL.

   Returns the result of the call on success, or NULL on failure.

   This is the equivalent of the Python expression:
   callable(*args). */
@NoException public static native PyObject PyObject_CallObject(PyObject callable,
                                           PyObject args);

/* Call a callable Python object, callable, with a variable number of C
   arguments. The C arguments are described using a mkvalue-style format
   string.

   The format may be NULL, indicating that no arguments are provided.

   Returns the result of the call on success, or NULL on failure.

   This is the equivalent of the Python expression:
   callable(arg1, arg2, ...). */
@NoException public static native PyObject PyObject_CallFunction(PyObject callable,
                                             @Cast("const char*") BytePointer format);
@NoException public static native PyObject PyObject_CallFunction(PyObject callable,
                                             String format);

/* Call the method named 'name' of object 'obj' with a variable number of
   C arguments.  The C arguments are described by a mkvalue format string.

   The format can be NULL, indicating that no arguments are provided.

   Returns the result of the call on success, or NULL on failure.

   This is the equivalent of the Python expression:
   obj.name(arg1, arg2, ...). */
@NoException public static native PyObject PyObject_CallMethod(PyObject obj,
                                           @Cast("const char*") BytePointer name,
                                           @Cast("const char*") BytePointer format);
@NoException public static native PyObject PyObject_CallMethod(PyObject obj,
                                           String name,
                                           String format);

/* Call a callable Python object 'callable' with a variable number of C
   arguments. The C arguments are provided as PyObject* values, terminated
   by a NULL.

   Returns the result of the call on success, or NULL on failure.

   This is the equivalent of the Python expression:
   callable(arg1, arg2, ...). */
@NoException public static native PyObject PyObject_CallFunctionObjArgs(PyObject callable);

/* Call the method named 'name' of object 'obj' with a variable number of
   C arguments.  The C arguments are provided as PyObject* values, terminated
   by NULL.

   Returns the result of the call on success, or NULL on failure.

   This is the equivalent of the Python expression: obj.name(*args). */

@NoException public static native PyObject PyObject_CallMethodObjArgs(
    PyObject obj,
    PyObject name);

/* Given a vectorcall nargsf argument, return the actual number of arguments.
 * (For use outside the limited API, this is re-defined as a static inline
 * function in cpython/abstract.h)
 */
@NoException public static native @Cast("Py_ssize_t") long PyVectorcall_NARGS(@Cast("size_t") long nargsf);

/* Call "callable" (which must support vectorcall) with positional arguments
   "tuple" and keyword arguments "dict". "dict" may also be NULL */
@NoException public static native PyObject PyVectorcall_Call(PyObject callable, PyObject tuple, PyObject dict);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000
public static native @MemberGetter long PY_VECTORCALL_ARGUMENTS_OFFSET();
public static final long PY_VECTORCALL_ARGUMENTS_OFFSET = PY_VECTORCALL_ARGUMENTS_OFFSET();

/* Perform a PEP 590-style vector call on 'callable' */
@NoException public static native PyObject PyObject_Vectorcall(
    PyObject callable,
    @Cast("PyObject*const*") PointerPointer args,
    @Cast("size_t") long nargsf,
    PyObject kwnames);
@NoException public static native PyObject PyObject_Vectorcall(
    PyObject callable,
    @ByPtrPtr PyObject args,
    @Cast("size_t") long nargsf,
    PyObject kwnames);

/* Call the method 'name' on args[0] with arguments in args[1..nargsf-1]. */
@NoException public static native PyObject PyObject_VectorcallMethod(
    PyObject name, @Cast("PyObject*const*") PointerPointer args,
    @Cast("size_t") long nargsf, PyObject kwnames);
@NoException public static native PyObject PyObject_VectorcallMethod(
    PyObject name, @ByPtrPtr PyObject args,
    @Cast("size_t") long nargsf, PyObject kwnames);
// #endif

/* Implemented elsewhere:

   Py_hash_t PyObject_Hash(PyObject *o);

   Compute and return the hash, hash_value, of an object, o.  On
   failure, return -1.

   This is the equivalent of the Python expression: hash(o). */


/* Implemented elsewhere:

   int PyObject_IsTrue(PyObject *o);

   Returns 1 if the object, o, is considered to be true, 0 if o is
   considered to be false and -1 on failure.

   This is equivalent to the Python expression: not not o. */


/* Implemented elsewhere:

   int PyObject_Not(PyObject *o);

   Returns 0 if the object, o, is considered to be true, 1 if o is
   considered to be false and -1 on failure.

   This is equivalent to the Python expression: not o. */


/* Get the type of an object.

   On success, returns a type object corresponding to the object type of object
   'o'. On failure, returns NULL.

   This is equivalent to the Python expression: type(o) */
@NoException public static native PyObject PyObject_Type(PyObject o);


/* Return the size of object 'o'.  If the object 'o' provides both sequence and
   mapping protocols, the sequence size is returned.

   On error, -1 is returned.

   This is the equivalent to the Python expression: len(o) */
@NoException public static native @Cast("Py_ssize_t") long PyObject_Size(PyObject o);


/* For DLL compatibility */
// #undef PyObject_Length
// #define PyObject_Length PyObject_Size

/* Return element of 'o' corresponding to the object 'key'. Return NULL
  on failure.

  This is the equivalent of the Python expression: o[key] */
@NoException public static native PyObject PyObject_GetItem(PyObject o, PyObject key);


/* Map the object 'key' to the value 'v' into 'o'.

   Raise an exception and return -1 on failure; return 0 on success.

   This is the equivalent of the Python statement: o[key]=v. */
@NoException public static native int PyObject_SetItem(PyObject o, PyObject key, PyObject v);

/* Remove the mapping for the string 'key' from the object 'o'.
   Returns -1 on failure.

   This is equivalent to the Python statement: del o[key]. */
@NoException public static native int PyObject_DelItemString(PyObject o, @Cast("const char*") BytePointer key);
@NoException public static native int PyObject_DelItemString(PyObject o, String key);

/* Delete the mapping for the object 'key' from the object 'o'.
   Returns -1 on failure.

   This is the equivalent of the Python statement: del o[key]. */
@NoException public static native int PyObject_DelItem(PyObject o, PyObject key);


/* Takes an arbitrary object and returns the result of calling
   obj.__format__(format_spec). */
@NoException public static native PyObject PyObject_Format(PyObject obj,
                                       PyObject format_spec);


/* ==== Iterators ================================================ */

/* Takes an object and returns an iterator for it.
   This is typically a new iterator but if the argument is an iterator, this
   returns itself. */
@NoException public static native PyObject PyObject_GetIter(PyObject arg0);

/* Takes an AsyncIterable object and returns an AsyncIterator for it.
   This is typically a new iterator but if the argument is an AsyncIterator,
   this returns itself. */
@NoException public static native PyObject PyObject_GetAIter(PyObject arg0);

/* Returns non-zero if the object 'obj' provides iterator protocols, and 0 otherwise.

   This function always succeeds. */
@NoException public static native int PyIter_Check(PyObject arg0);

/* Returns non-zero if the object 'obj' provides AsyncIterator protocols, and 0 otherwise.

   This function always succeeds. */
@NoException public static native int PyAIter_Check(PyObject arg0);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030e0000
/* Return 1 and set 'item' to the next item of 'iter' on success.
 * Return 0 and set 'item' to NULL when there are no remaining values.
 * Return -1, set 'item' to NULL and set an exception on error.
 */
@NoException public static native int PyIter_NextItem(PyObject iter, @Cast("PyObject**") PointerPointer item);
@NoException public static native int PyIter_NextItem(PyObject iter, @ByPtrPtr PyObject item);
// #endif

/* Takes an iterator object and calls its tp_iternext slot,
   returning the next value.

   If the iterator is exhausted, this returns NULL without setting an
   exception.

   NULL with an exception means an error occurred.

   Prefer PyIter_NextItem() instead. */
@NoException public static native PyObject PyIter_Next(PyObject arg0);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000

/* Takes generator, coroutine or iterator object and sends the value into it.
   Returns:
   - PYGEN_RETURN (0) if generator has returned.
     'result' parameter is filled with return value
   - PYGEN_ERROR (-1) if exception was raised.
     'result' parameter is NULL
   - PYGEN_NEXT (1) if generator has yielded.
     'result' parameter is filled with yielded value. */
@NoException public static native @Cast("PySendResult") int PyIter_Send(PyObject arg0, PyObject arg1, @Cast("PyObject**") PointerPointer arg2);
@NoException public static native @Cast("PySendResult") int PyIter_Send(PyObject arg0, PyObject arg1, @ByPtrPtr PyObject arg2);
// #endif


/* === Number Protocol ================================================== */

/* Returns 1 if the object 'o' provides numeric protocols, and 0 otherwise.

   This function always succeeds. */
@NoException public static native int PyNumber_Check(PyObject o);

/* Returns the result of adding o1 and o2, or NULL on failure.

   This is the equivalent of the Python expression: o1 + o2. */
@NoException public static native PyObject PyNumber_Add(PyObject o1, PyObject o2);

/* Returns the result of subtracting o2 from o1, or NULL on failure.

   This is the equivalent of the Python expression: o1 - o2. */
@NoException public static native PyObject PyNumber_Subtract(PyObject o1, PyObject o2);

/* Returns the result of multiplying o1 and o2, or NULL on failure.

   This is the equivalent of the Python expression: o1 * o2. */
@NoException public static native PyObject PyNumber_Multiply(PyObject o1, PyObject o2);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* This is the equivalent of the Python expression: o1 @ o2. */
@NoException public static native PyObject PyNumber_MatrixMultiply(PyObject o1, PyObject o2);
// #endif

/* Returns the result of dividing o1 by o2 giving an integral result,
   or NULL on failure.

   This is the equivalent of the Python expression: o1 // o2. */
@NoException public static native PyObject PyNumber_FloorDivide(PyObject o1, PyObject o2);

/* Returns the result of dividing o1 by o2 giving a float result, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 / o2. */
@NoException public static native PyObject PyNumber_TrueDivide(PyObject o1, PyObject o2);

/* Returns the remainder of dividing o1 by o2, or NULL on failure.

   This is the equivalent of the Python expression: o1 % o2. */
@NoException public static native PyObject PyNumber_Remainder(PyObject o1, PyObject o2);

/* See the built-in function divmod.

   Returns NULL on failure.

   This is the equivalent of the Python expression: divmod(o1, o2). */
@NoException public static native PyObject PyNumber_Divmod(PyObject o1, PyObject o2);

/* See the built-in function pow. Returns NULL on failure.

   This is the equivalent of the Python expression: pow(o1, o2, o3),
   where o3 is optional. */
@NoException public static native PyObject PyNumber_Power(PyObject o1, PyObject o2,
                                      PyObject o3);

/* Returns the negation of o on success, or NULL on failure.

 This is the equivalent of the Python expression: -o. */
@NoException public static native PyObject PyNumber_Negative(PyObject o);

/* Returns the positive of o on success, or NULL on failure.

   This is the equivalent of the Python expression: +o. */
@NoException public static native PyObject PyNumber_Positive(PyObject o);

/* Returns the absolute value of 'o', or NULL on failure.

   This is the equivalent of the Python expression: abs(o). */
@NoException public static native PyObject PyNumber_Absolute(PyObject o);

/* Returns the bitwise negation of 'o' on success, or NULL on failure.

   This is the equivalent of the Python expression: ~o. */
@NoException public static native PyObject PyNumber_Invert(PyObject o);

/* Returns the result of left shifting o1 by o2 on success, or NULL on failure.

   This is the equivalent of the Python expression: o1 << o2. */
@NoException public static native PyObject PyNumber_Lshift(PyObject o1, PyObject o2);

/* Returns the result of right shifting o1 by o2 on success, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 >> o2. */
@NoException public static native PyObject PyNumber_Rshift(PyObject o1, PyObject o2);

/* Returns the result of bitwise and of o1 and o2 on success, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 & o2. */
@NoException public static native PyObject PyNumber_And(PyObject o1, PyObject o2);

/* Returns the bitwise exclusive or of o1 by o2 on success, or NULL on failure.

   This is the equivalent of the Python expression: o1 ^ o2. */
@NoException public static native PyObject PyNumber_Xor(PyObject o1, PyObject o2);

/* Returns the result of bitwise or on o1 and o2 on success, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 | o2. */
@NoException public static native PyObject PyNumber_Or(PyObject o1, PyObject o2);

/* Returns 1 if obj is an index integer (has the nb_index slot of the
   tp_as_number structure filled in), and 0 otherwise. */
@NoException public static native int PyIndex_Check(PyObject arg0);

/* Returns the object 'o' converted to a Python int, or NULL with an exception
   raised on failure. */
@NoException public static native PyObject PyNumber_Index(PyObject o);

/* Returns the object 'o' converted to Py_ssize_t by going through
   PyNumber_Index() first.

   If an overflow error occurs while converting the int to Py_ssize_t, then the
   second argument 'exc' is the error-type to return.  If it is NULL, then the
   overflow error is cleared and the value is clipped. */
@NoException public static native @Cast("Py_ssize_t") long PyNumber_AsSsize_t(PyObject o, PyObject exc);

/* Returns the object 'o' converted to an integer object on success, or NULL
   on failure.

   This is the equivalent of the Python expression: int(o). */
@NoException public static native PyObject PyNumber_Long(PyObject o);

/* Returns the object 'o' converted to a float object on success, or NULL
  on failure.

  This is the equivalent of the Python expression: float(o). */
@NoException public static native PyObject PyNumber_Float(PyObject o);


/* --- In-place variants of (some of) the above number protocol functions -- */

/* Returns the result of adding o2 to o1, possibly in-place, or NULL
   on failure.

   This is the equivalent of the Python expression: o1 += o2. */
@NoException public static native PyObject PyNumber_InPlaceAdd(PyObject o1, PyObject o2);

/* Returns the result of subtracting o2 from o1, possibly in-place or
   NULL on failure.

   This is the equivalent of the Python expression: o1 -= o2. */
@NoException public static native PyObject PyNumber_InPlaceSubtract(PyObject o1, PyObject o2);

/* Returns the result of multiplying o1 by o2, possibly in-place, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 *= o2. */
@NoException public static native PyObject PyNumber_InPlaceMultiply(PyObject o1, PyObject o2);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* This is the equivalent of the Python expression: o1 @= o2. */
@NoException public static native PyObject PyNumber_InPlaceMatrixMultiply(PyObject o1, PyObject o2);
// #endif

/* Returns the result of dividing o1 by o2 giving an integral result, possibly
   in-place, or NULL on failure.

   This is the equivalent of the Python expression: o1 /= o2. */
@NoException public static native PyObject PyNumber_InPlaceFloorDivide(PyObject o1,
                                                   PyObject o2);

/* Returns the result of dividing o1 by o2 giving a float result, possibly
   in-place, or null on failure.

   This is the equivalent of the Python expression: o1 /= o2. */
@NoException public static native PyObject PyNumber_InPlaceTrueDivide(PyObject o1,
                                                  PyObject o2);

/* Returns the remainder of dividing o1 by o2, possibly in-place, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 %= o2. */
@NoException public static native PyObject PyNumber_InPlaceRemainder(PyObject o1, PyObject o2);

/* Returns the result of raising o1 to the power of o2, possibly in-place,
   or NULL on failure.

   This is the equivalent of the Python expression: o1 **= o2,
   or o1 = pow(o1, o2, o3) if o3 is present. */
@NoException public static native PyObject PyNumber_InPlacePower(PyObject o1, PyObject o2,
                                             PyObject o3);

/* Returns the result of left shifting o1 by o2, possibly in-place, or NULL
   on failure.

   This is the equivalent of the Python expression: o1 <<= o2. */
@NoException public static native PyObject PyNumber_InPlaceLshift(PyObject o1, PyObject o2);

/* Returns the result of right shifting o1 by o2, possibly in-place or NULL
   on failure.

   This is the equivalent of the Python expression: o1 >>= o2. */
@NoException public static native PyObject PyNumber_InPlaceRshift(PyObject o1, PyObject o2);

/* Returns the result of bitwise and of o1 and o2, possibly in-place, or NULL
   on failure.

   This is the equivalent of the Python expression: o1 &= o2. */
@NoException public static native PyObject PyNumber_InPlaceAnd(PyObject o1, PyObject o2);

/* Returns the bitwise exclusive or of o1 by o2, possibly in-place, or NULL
   on failure.

   This is the equivalent of the Python expression: o1 ^= o2. */
@NoException public static native PyObject PyNumber_InPlaceXor(PyObject o1, PyObject o2);

/* Returns the result of bitwise or of o1 and o2, possibly in-place,
   or NULL on failure.

   This is the equivalent of the Python expression: o1 |= o2. */
@NoException public static native PyObject PyNumber_InPlaceOr(PyObject o1, PyObject o2);

/* Returns the integer n converted to a string with a base, with a base
   marker of 0b, 0o or 0x prefixed if applicable.

   If n is not an int object, it is converted with PyNumber_Index first. */
@NoException public static native PyObject PyNumber_ToBase(PyObject n, int base);


/* === Sequence protocol ================================================ */

/* Return 1 if the object provides sequence protocol, and zero
   otherwise.

   This function always succeeds. */
@NoException public static native int PySequence_Check(PyObject o);

/* Return the size of sequence object o, or -1 on failure. */
@NoException public static native @Cast("Py_ssize_t") long PySequence_Size(PyObject o);

/* For DLL compatibility */
// #undef PySequence_Length
// #define PySequence_Length PySequence_Size


/* Return the concatenation of o1 and o2 on success, and NULL on failure.

   This is the equivalent of the Python expression: o1 + o2. */
@NoException public static native PyObject PySequence_Concat(PyObject o1, PyObject o2);

/* Return the result of repeating sequence object 'o' 'count' times,
  or NULL on failure.

  This is the equivalent of the Python expression: o * count. */
@NoException public static native PyObject PySequence_Repeat(PyObject o, @Cast("Py_ssize_t") long count);

/* Return the ith element of o, or NULL on failure.

   This is the equivalent of the Python expression: o[i]. */
@NoException public static native PyObject PySequence_GetItem(PyObject o, @Cast("Py_ssize_t") long i);

/* Return the slice of sequence object o between i1 and i2, or NULL on failure.

   This is the equivalent of the Python expression: o[i1:i2]. */
@NoException public static native PyObject PySequence_GetSlice(PyObject o, @Cast("Py_ssize_t") long i1, @Cast("Py_ssize_t") long i2);

/* Assign object 'v' to the ith element of the sequence 'o'. Raise an exception
   and return -1 on failure; return 0 on success.

   This is the equivalent of the Python statement o[i] = v. */
@NoException public static native int PySequence_SetItem(PyObject o, @Cast("Py_ssize_t") long i, PyObject v);

/* Delete the 'i'-th element of the sequence 'v'. Returns -1 on failure.

   This is the equivalent of the Python statement: del o[i]. */
@NoException public static native int PySequence_DelItem(PyObject o, @Cast("Py_ssize_t") long i);

/* Assign the sequence object 'v' to the slice in sequence object 'o',
   from 'i1' to 'i2'. Returns -1 on failure.

   This is the equivalent of the Python statement: o[i1:i2] = v. */
@NoException public static native int PySequence_SetSlice(PyObject o, @Cast("Py_ssize_t") long i1, @Cast("Py_ssize_t") long i2,
                                    PyObject v);

/* Delete the slice in sequence object 'o' from 'i1' to 'i2'.
   Returns -1 on failure.

   This is the equivalent of the Python statement: del o[i1:i2]. */
@NoException public static native int PySequence_DelSlice(PyObject o, @Cast("Py_ssize_t") long i1, @Cast("Py_ssize_t") long i2);

/* Returns the sequence 'o' as a tuple on success, and NULL on failure.

   This is equivalent to the Python expression: tuple(o). */
@NoException public static native PyObject PySequence_Tuple(PyObject o);

/* Returns the sequence 'o' as a list on success, and NULL on failure.
   This is equivalent to the Python expression: list(o) */
@NoException public static native PyObject PySequence_List(PyObject o);

/* Return the sequence 'o' as a list, unless it's already a tuple or list.

   Use PySequence_Fast_GET_ITEM to access the members of this list, and
   PySequence_Fast_GET_SIZE to get its length.

   Returns NULL on failure.  If the object does not support iteration, raises a
   TypeError exception with 'm' as the message text. */
@NoException public static native PyObject PySequence_Fast(PyObject o, @Cast("const char*") BytePointer m);
@NoException public static native PyObject PySequence_Fast(PyObject o, String m);

/* Return the number of occurrences on value on 'o', that is, return
   the number of keys for which o[key] == value.

   On failure, return -1.  This is equivalent to the Python expression:
   o.count(value). */
@NoException public static native @Cast("Py_ssize_t") long PySequence_Count(PyObject o, PyObject value);

/* Return 1 if 'ob' is in the sequence 'seq'; 0 if 'ob' is not in the sequence
   'seq'; -1 on error.

   Use __contains__ if possible, else _PySequence_IterSearch(). */
@NoException public static native int PySequence_Contains(PyObject seq, PyObject ob);

/* For DLL-level backwards compatibility */
// #undef PySequence_In
/* Determine if the sequence 'o' contains 'value'. If an item in 'o' is equal
   to 'value', return 1, otherwise return 0. On error, return -1.

   This is equivalent to the Python expression: value in o. */

/* For source-level backwards compatibility */
// #define PySequence_In PySequence_Contains


/* Return the first index for which o[i] == value.
   On error, return -1.

   This is equivalent to the Python expression: o.index(value). */
@NoException public static native @Cast("Py_ssize_t") long PySequence_Index(PyObject o, PyObject value);


/* --- In-place versions of some of the above Sequence functions --- */

/* Append sequence 'o2' to sequence 'o1', in-place when possible. Return the
   resulting object, which could be 'o1', or NULL on failure.

  This is the equivalent of the Python expression: o1 += o2. */
@NoException public static native PyObject PySequence_InPlaceConcat(PyObject o1, PyObject o2);

/* Repeat sequence 'o' by 'count', in-place when possible. Return the resulting
   object, which could be 'o', or NULL on failure.

   This is the equivalent of the Python expression: o1 *= count.  */
@NoException public static native PyObject PySequence_InPlaceRepeat(PyObject o, @Cast("Py_ssize_t") long count);


/* === Mapping protocol ================================================= */

/* Return 1 if the object provides mapping protocol, and 0 otherwise.

   This function always succeeds. */
@NoException public static native int PyMapping_Check(PyObject o);

/* Returns the number of keys in mapping object 'o' on success, and -1 on
  failure. This is equivalent to the Python expression: len(o). */
@NoException public static native @Cast("Py_ssize_t") long PyMapping_Size(PyObject o);

/* For DLL compatibility */
// #undef PyMapping_Length
// #define PyMapping_Length PyMapping_Size


/* Implemented as a macro:

   int PyMapping_DelItemString(PyObject *o, const char *key);

   Remove the mapping for the string 'key' from the mapping 'o'. Returns -1 on
   failure.

   This is equivalent to the Python statement: del o[key]. */
// #define PyMapping_DelItemString(O, K) PyObject_DelItemString((O), (K))

/* Implemented as a macro:

   int PyMapping_DelItem(PyObject *o, PyObject *key);

   Remove the mapping for the object 'key' from the mapping object 'o'.
   Returns -1 on failure.

   This is equivalent to the Python statement: del o[key]. */
// #define PyMapping_DelItem(O, K) PyObject_DelItem((O), (K))

/* On success, return 1 if the mapping object 'o' has the key 'key',
   and 0 otherwise.

   This is equivalent to the Python expression: key in o.

   This function always succeeds. */
@NoException public static native int PyMapping_HasKeyString(PyObject o, @Cast("const char*") BytePointer key);
@NoException public static native int PyMapping_HasKeyString(PyObject o, String key);

/* Return 1 if the mapping object has the key 'key', and 0 otherwise.

   This is equivalent to the Python expression: key in o.

   This function always succeeds. */
@NoException public static native int PyMapping_HasKey(PyObject o, PyObject key);

/* Return 1 if the mapping object has the key 'key', and 0 otherwise.
   This is equivalent to the Python expression: key in o.
   On failure, return -1. */

@NoException public static native int PyMapping_HasKeyWithError(PyObject o, PyObject key);

/* Return 1 if the mapping object has the key 'key', and 0 otherwise.
   This is equivalent to the Python expression: key in o.
   On failure, return -1. */

@NoException public static native int PyMapping_HasKeyStringWithError(PyObject o, @Cast("const char*") BytePointer key);
@NoException public static native int PyMapping_HasKeyStringWithError(PyObject o, String key);

/* On success, return a list of the keys in mapping object 'o'.
   On failure, return NULL. */
@NoException public static native PyObject PyMapping_Keys(PyObject o);

/* On success, return a list of the values in mapping object 'o'.
   On failure, return NULL. */
@NoException public static native PyObject PyMapping_Values(PyObject o);

/* On success, return a list of the items in mapping object 'o',
   where each item is a tuple containing a key-value pair. On failure, return
   NULL. */
@NoException public static native PyObject PyMapping_Items(PyObject o);

/* Return element of 'o' corresponding to the string 'key' or NULL on failure.

   This is the equivalent of the Python expression: o[key]. */
@NoException public static native PyObject PyMapping_GetItemString(PyObject o,
                                               @Cast("const char*") BytePointer key);
@NoException public static native PyObject PyMapping_GetItemString(PyObject o,
                                               String key);

/* Variants of PyObject_GetItem() and PyMapping_GetItemString() which don't
   raise KeyError if the key is not found.

   If the key is found, return 1 and set *result to a new strong
   reference to the corresponding value.
   If the key is not found, return 0 and set *result to NULL;
   the KeyError is silenced.
   If an error other than KeyError is raised, return -1 and
   set *result to NULL.
*/
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030d0000
@NoException public static native int PyMapping_GetOptionalItem(PyObject arg0, PyObject arg1, @Cast("PyObject**") PointerPointer arg2);
@NoException public static native int PyMapping_GetOptionalItem(PyObject arg0, PyObject arg1, @ByPtrPtr PyObject arg2);
@NoException public static native int PyMapping_GetOptionalItemString(PyObject arg0, @Cast("const char*") BytePointer arg1, @Cast("PyObject**") PointerPointer arg2);
@NoException public static native int PyMapping_GetOptionalItemString(PyObject arg0, @Cast("const char*") BytePointer arg1, @ByPtrPtr PyObject arg2);
@NoException public static native int PyMapping_GetOptionalItemString(PyObject arg0, String arg1, @ByPtrPtr PyObject arg2);
// #endif

/* Map the string 'key' to the value 'v' in the mapping 'o'.
   Returns -1 on failure.

   This is the equivalent of the Python statement: o[key]=v. */
@NoException public static native int PyMapping_SetItemString(PyObject o, @Cast("const char*") BytePointer key,
                                        PyObject value);
@NoException public static native int PyMapping_SetItemString(PyObject o, String key,
                                        PyObject value);

/* isinstance(object, typeorclass) */
@NoException public static native int PyObject_IsInstance(PyObject object, PyObject typeorclass);

/* issubclass(object, typeorclass) */
@NoException public static native int PyObject_IsSubclass(PyObject object, PyObject typeorclass);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_ABSTRACTOBJECT_H
// #  include "cpython/abstract.h"
// #  undef Py_CPYTHON_ABSTRACTOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* Py_ABSTRACTOBJECT_H */


// Parsed from cpython/abstract.h

// #ifndef Py_CPYTHON_ABSTRACTOBJECT_H
// #  error "this header file must not be included directly"
// #endif

/* === Object Protocol ================================================== */

/* Like PyObject_CallMethod(), but expect a _Py_Identifier*
   as the method name. */
@NoException public static native PyObject _PyObject_CallMethodId(
    PyObject obj,
    _Py_Identifier name,
    @Cast("const char*") BytePointer format);
@NoException public static native PyObject _PyObject_CallMethodId(
    PyObject obj,
    _Py_Identifier name,
    String format);

/* Convert keyword arguments from the FASTCALL (stack: C array, kwnames: tuple)
   format to a Python dictionary ("kwargs" dict).

   The type of kwnames keys is not checked. The final function getting
   arguments is responsible to check if all keys are strings, for example using
   PyArg_ParseTupleAndKeywords() or PyArg_ValidateKeywordArguments().

   Duplicate keys are merged using the last value. If duplicate keys must raise
   an exception, the caller is responsible to implement an explicit keys on
   kwnames. */
@NoException public static native PyObject _PyStack_AsDict(@Cast("PyObject*const*") PointerPointer values, PyObject kwnames);
@NoException public static native PyObject _PyStack_AsDict(@ByPtrPtr PyObject values, PyObject kwnames);


/* === Vectorcall protocol (PEP 590) ============================= */

// PyVectorcall_NARGS() is exported as a function for the stable ABI.
// Here (when we are not using the stable ABI), the name is overridden to
// call a static inline function for best performance.
@NoException public static native @Cast("Py_ssize_t") long _PyVectorcall_NARGS(@Cast("size_t") long n);
// #define PyVectorcall_NARGS(n) _PyVectorcall_NARGS(n)

@NoException public static native vectorcallfunc PyVectorcall_Function(PyObject callable);

// Backwards compatibility aliases (PEP 590) for API that was provisional
// in Python 3.8
// #define _PyObject_Vectorcall PyObject_Vectorcall
// #define _PyObject_VectorcallMethod PyObject_VectorcallMethod
// #define _PyObject_FastCallDict PyObject_VectorcallDict
// #define _PyVectorcall_Function PyVectorcall_Function
// #define _PyObject_CallOneArg PyObject_CallOneArg
// #define _PyObject_CallMethodNoArgs PyObject_CallMethodNoArgs
// #define _PyObject_CallMethodOneArg PyObject_CallMethodOneArg

/* Same as PyObject_Vectorcall except that keyword arguments are passed as
   dict, which may be NULL if there are no keyword arguments. */
@NoException public static native PyObject PyObject_VectorcallDict(
    PyObject callable,
    @Cast("PyObject*const*") PointerPointer args,
    @Cast("size_t") long nargsf,
    PyObject kwargs);
@NoException public static native PyObject PyObject_VectorcallDict(
    PyObject callable,
    @ByPtrPtr PyObject args,
    @Cast("size_t") long nargsf,
    PyObject kwargs);

@NoException public static native PyObject PyObject_CallOneArg(PyObject func, PyObject arg);

@NoException public static native PyObject PyObject_CallMethodNoArgs(PyObject self, PyObject name);

@NoException public static native PyObject PyObject_CallMethodOneArg(PyObject self, PyObject name, PyObject arg);

/* Guess the size of object 'o' using len(o) or o.__length_hint__().
   If neither of those return a non-negative value, then return the default
   value.  If one of the calls fails, this function returns -1. */
@NoException public static native @Cast("Py_ssize_t") long PyObject_LengthHint(PyObject o, @Cast("Py_ssize_t") long arg1);

/* === Sequence protocol ================================================ */

/* Assume tp_as_sequence and sq_item exist and that 'i' does not
   need to be corrected for a negative index. */
// #define PySequence_ITEM(o, i)
//     ( Py_TYPE(o)->tp_as_sequence->sq_item((o), (i)) )

/* Return the size of the sequence 'o', assuming that 'o' was returned by
   PySequence_Fast and is not NULL. */
// #define PySequence_Fast_GET_SIZE(o)
//     (PyList_Check(o) ? PyList_GET_SIZE(o) : PyTuple_GET_SIZE(o))

/* Return the 'i'-th element of the sequence 'o', assuming that o was returned
   by PySequence_Fast, and that i is within bounds. */
// #define PySequence_Fast_GET_ITEM(o, i)
//      (PyList_Check(o) ? PyList_GET_ITEM((o), (i)) : PyTuple_GET_ITEM((o), (i)))

/* Return a pointer to the underlying item array for
   an object returned by PySequence_Fast */
// #define PySequence_Fast_ITEMS(sf)
//     (PyList_Check(sf) ? ((PyListObject *)(sf))->ob_item
//                       : ((PyTupleObject *)(sf))->ob_item)



// Parsed from bltinmodule.h

// #ifndef Py_BLTINMODULE_H
// #define Py_BLTINMODULE_H
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyFilter_Type(); public static native void PyFilter_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyMap_Type(); public static native void PyMap_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyZip_Type(); public static native void PyZip_Type(PyTypeObject setter);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_BLTINMODULE_H */


// Parsed from cpython/code.h

/* Definitions for bytecode */

// #ifndef Py_LIMITED_API
// #ifndef Py_CODE_H
// #define Py_CODE_H

// #ifdef __cplusplus
// Targeting ../_PyCoCached.java


// Targeting ../_PyExecutorArray.java




// #ifdef Py_GIL_DISABLED
// #else
// #define _PyCode_DEF_THREAD_LOCAL_BYTECODE()
// #endif

// To avoid repeating ourselves in deepfreeze.py, all PyCodeObject members are
// defined in this macro:
// #define _PyCode_DEF(SIZE) {
//     PyObject_VAR_HEAD
// 
//     /* Note only the following fields are used in hash and/or comparisons      \
//     *                                                                         \
//     * - co_name                                                               \
//     * - co_argcount                                                           \
//     * - co_posonlyargcount                                                    \
//     * - co_kwonlyargcount                                                     \
//     * - co_nlocals                                                            \
//     * - co_stacksize                                                          \
//     * - co_flags                                                              \
//     * - co_firstlineno                                                        \
//     * - co_consts                                                             \
//     * - co_names                                                              \
//     * - co_localsplusnames                                                    \
//     * This is done to preserve the name and line number for tracebacks        \
//     * and debuggers; otherwise, constant de-duplication would collapse        \
//     * identical functions/lambdas defined on different lines.                 \
//     */
// 
//     /* These fields are set with provided values on new code objects. */
// 
//     /* The hottest fields (in the eval loop) are grouped here at the top. */
//     PyObject *co_consts;           /* list (constants used) */
//     PyObject *co_names;            /* list of strings (names used) */
//     PyObject *co_exceptiontable;   /* Byte string encoding exception handling  \
//                                      table */
//     int co_flags;                  /* CO_..., see below */
// 
//     /* The rest are not so impactful on performance. */
//     int co_argcount;              /* #arguments, except *args */
//     int co_posonlyargcount;       /* #positional only arguments */
//     int co_kwonlyargcount;        /* #keyword only arguments */
//     int co_stacksize;             /* #entries needed for evaluation stack */
//     int co_firstlineno;           /* first source line number */
// 
//     /* redundant values (derived from co_localsplusnames and                   \
//       co_localspluskinds) */
//     int co_nlocalsplus;           /* number of spaces for holding local, cell, \
//                                     and free variables */
//     int co_framesize;             /* Size of frame in words */
//     int co_nlocals;               /* number of local variables */
//     int co_ncellvars;             /* total number of cell variables */
//     int co_nfreevars;             /* number of free variables */
//     uint32_t co_version;          /* version number */
// 
//     PyObject *co_localsplusnames; /* tuple mapping offsets to names */
//     PyObject *co_localspluskinds; /* Bytes mapping to local kinds (one byte    \
//                                     per variable) */
//     PyObject *co_filename;        /* unicode (where it was loaded from) */
//     PyObject *co_name;            /* unicode (name, for reference) */
//     PyObject *co_qualname;        /* unicode (qualname, for reference) */
//     PyObject *co_linetable;       /* bytes object that holds location info */
//     PyObject *co_weakreflist;     /* to support weakrefs to code objects */
//     _PyExecutorArray *co_executors;      /* executors from optimizer */
//     _PyCoCached *_co_cached;      /* cached co_* attributes */
//     uintptr_t _co_instrumentation_version; /* current instrumentation version */
//     struct _PyCoMonitoringData *_co_monitoring; /* Monitoring data */
//     Py_ssize_t _co_unique_id;     /* ID used for per-thread refcounting */
//     int _co_firsttraceable;       /* index of first traceable instruction */
//     /* Scratch space for extra data relating to the code object.               \
//       Type is a void* to keep the format private in codeobject.c to force     \
//       people to go through the proper APIs. */
//     void *co_extra;
//     _PyCode_DEF_THREAD_LOCAL_BYTECODE()
//     char co_code_adaptive[(SIZE)];
// }
// Targeting ../PyCodeObject.java



/* Masks for co_flags above */
public static final int CO_OPTIMIZED =    0x0001;
public static final int CO_NEWLOCALS =    0x0002;
public static final int CO_VARARGS =      0x0004;
public static final int CO_VARKEYWORDS =  0x0008;
public static final int CO_NESTED =       0x0010;
public static final int CO_GENERATOR =    0x0020;

/* The CO_COROUTINE flag is set for coroutine functions (defined with
   ``async def`` keywords) */
public static final int CO_COROUTINE =            0x0080;
public static final int CO_ITERABLE_COROUTINE =   0x0100;
public static final int CO_ASYNC_GENERATOR =      0x0200;

/* bpo-39562: These constant values are changed in Python 3.9
   to prevent collision with compiler flags. CO_FUTURE_ and PyCF_
   constants must be kept unique. PyCF_ constants can use bits from
   0x0100 to 0x10000. CO_FUTURE_ constants use bits starting at 0x20000. */
public static final int CO_FUTURE_DIVISION =      0x20000;
public static final int CO_FUTURE_ABSOLUTE_IMPORT = 0x40000; /* do absolute imports by default */
public static final int CO_FUTURE_WITH_STATEMENT =  0x80000;
public static final int CO_FUTURE_PRINT_FUNCTION =  0x100000;
public static final int CO_FUTURE_UNICODE_LITERALS = 0x200000;

public static final int CO_FUTURE_BARRY_AS_BDFL =  0x400000;
public static final int CO_FUTURE_GENERATOR_STOP =  0x800000;
public static final int CO_FUTURE_ANNOTATIONS =    0x1000000;

public static final int CO_NO_MONITORING_EVENTS = 0x2000000;

/* Whether the code object has a docstring,
   If so, it will be the first item in co_consts
*/
public static final int CO_HAS_DOCSTRING = 0x4000000;

/* A function defined in class scope */
public static final int CO_METHOD =  0x8000000;

/* This should be defined if a future statement modifies the syntax.
   For example, when a keyword is added.
*/
// #define PY_PARSER_REQUIRES_FUTURE_KEYWORD

public static final int CO_MAXBLOCKS = 21; /* Max static block nesting within a function */

public static native @ByRef PyTypeObject PyCode_Type(); public static native void PyCode_Type(PyTypeObject setter);

// #define PyCode_Check(op) Py_IS_TYPE((op), &PyCode_Type)

@NoException public static native @Cast("Py_ssize_t") long PyCode_GetNumFree(PyCodeObject op);

@NoException public static native int PyUnstable_Code_GetFirstFree(PyCodeObject op);

@NoException public static native @Deprecated int PyCode_GetFirstFree(PyCodeObject op);

/* Unstable public interface */
@NoException public static native PyCodeObject PyUnstable_Code_New(
        int arg0, int arg1, int arg2, int arg3, int arg4, PyObject arg5, PyObject arg6,
        PyObject arg7, PyObject arg8, PyObject arg9, PyObject arg10,
        PyObject arg11, PyObject arg12, PyObject arg13, int arg14, PyObject arg15,
        PyObject arg16);

@NoException public static native PyCodeObject PyUnstable_Code_NewWithPosOnlyArgs(
        int arg0, int arg1, int arg2, int arg3, int arg4, int arg5, PyObject arg6, PyObject arg7,
        PyObject arg8, PyObject arg9, PyObject arg10, PyObject arg11,
        PyObject arg12, PyObject arg13, PyObject arg14, int arg15, PyObject arg16,
        PyObject arg17);
        /* same as struct above */
// Old names -- remove when this API changes:
@NoException public static native @Deprecated PyCodeObject PyCode_New(
        int a, int b, int c, int d, int e, PyObject f, PyObject g,
        PyObject h, PyObject i, PyObject j, PyObject k,
        PyObject l, PyObject m, PyObject n, int o, PyObject p,
        PyObject q);
@NoException public static native @Deprecated PyCodeObject PyCode_NewWithPosOnlyArgs(
        int a, int poac, int b, int c, int d, int e, PyObject f, PyObject g,
        PyObject h, PyObject i, PyObject j, PyObject k,
        PyObject l, PyObject m, PyObject n, int o, PyObject p,
        PyObject q);

/* Creates a new empty code object with the specified source location. */
@NoException public static native PyCodeObject PyCode_NewEmpty(@Cast("const char*") BytePointer filename, @Cast("const char*") BytePointer funcname, int firstlineno);
@NoException public static native PyCodeObject PyCode_NewEmpty(String filename, String funcname, int firstlineno);

/* Return the line number associated with the specified bytecode index
   in this code object.  If you just need the line number of a frame,
   use PyFrame_GetLineNumber() instead. */
@NoException public static native int PyCode_Addr2Line(PyCodeObject arg0, int arg1);

@NoException public static native int PyCode_Addr2Location(PyCodeObject arg0, int arg1, IntPointer arg2, IntPointer arg3, IntPointer arg4, IntPointer arg5);
@NoException public static native int PyCode_Addr2Location(PyCodeObject arg0, int arg1, IntBuffer arg2, IntBuffer arg3, IntBuffer arg4, IntBuffer arg5);
@NoException public static native int PyCode_Addr2Location(PyCodeObject arg0, int arg1, int[] arg2, int[] arg3, int[] arg4, int[] arg5);

// #define PY_FOREACH_CODE_EVENT(V)
//     V(CREATE)
//     V(DESTROY)

/** enum PyCodeEvent */

//     #define PY_DEF_EVENT(op) PY_CODE_EVENT_##op,
public static final int
    PY_CODE_EVENT_CREATE = 0,
    PY_CODE_EVENT_DESTROY = 1;
//     #undef PY_DEF_EVENT
// Targeting ../PyCode_WatchCallback.java



/*
 * Register a per-interpreter callback that will be invoked for code object
 * lifecycle events.
 *
 * Returns a handle that may be passed to PyCode_ClearWatcher on success,
 * or -1 and sets an error if no more handles are available.
 */
@NoException public static native int PyCode_AddWatcher(PyCode_WatchCallback callback);

/*
 * Clear the watcher associated with the watcher_id handle.
 *
 * Returns 0 on success or -1 if no watcher exists for the provided id.
 */
@NoException public static native int PyCode_ClearWatcher(int watcher_id);
// Targeting ../_opaque.java


// Targeting ../PyCodeAddressRange.java



/* Update *bounds to describe the first and one-past-the-last instructions in the
   same line as lasti.  Return the number of that line.
*/
@NoException public static native int _PyCode_CheckLineNumber(int lasti, PyCodeAddressRange bounds);

/* Create a comparable key used to compare constants taking in account the
 * object type. It is used to make sure types are not coerced (e.g., float and
 * complex) _and_ to distinguish 0.0 from -0.0 e.g. on IEEE platforms
 *
 * Return (type(obj), obj, ...): a tuple with variable size (at least 2 items)
 * depending on the type and the value. The type is the first item to not
 * compare bytes and str which can raise a BytesWarning exception. */
@NoException public static native PyObject _PyCode_ConstantKey(PyObject obj);

@NoException public static native PyObject PyCode_Optimize(PyObject code, PyObject consts,
                                      PyObject names, PyObject lnotab);

@NoException public static native int PyUnstable_Code_GetExtra(
    PyObject code, @Cast("Py_ssize_t") long index, @Cast("void**") PointerPointer extra);
@NoException public static native int PyUnstable_Code_GetExtra(
    PyObject code, @Cast("Py_ssize_t") long index, @Cast("void**") @ByPtrPtr Pointer extra);
@NoException public static native int PyUnstable_Code_SetExtra(
    PyObject code, @Cast("Py_ssize_t") long index, Pointer extra);
// Old names -- remove when this API changes:
@NoException public static native @Deprecated int _PyCode_GetExtra(PyObject code, @Cast("Py_ssize_t") long index, @Cast("void**") PointerPointer extra);
@NoException public static native @Deprecated int _PyCode_GetExtra(PyObject code, @Cast("Py_ssize_t") long index, @Cast("void**") @ByPtrPtr Pointer extra);
@NoException public static native @Deprecated int _PyCode_SetExtra(PyObject code, @Cast("Py_ssize_t") long index, Pointer extra);

/* Equivalent to getattr(code, 'co_code') in Python.
   Returns a strong reference to a bytes object. */
@NoException public static native PyObject PyCode_GetCode(PyCodeObject code);
/* Equivalent to getattr(code, 'co_varnames') in Python. */
@NoException public static native PyObject PyCode_GetVarnames(PyCodeObject code);
/* Equivalent to getattr(code, 'co_cellvars') in Python. */
@NoException public static native PyObject PyCode_GetCellvars(PyCodeObject code);
/* Equivalent to getattr(code, 'co_freevars') in Python. */
@NoException public static native PyObject PyCode_GetFreevars(PyCodeObject code);

/** enum _PyCodeLocationInfoKind */
public static final int
    /* short forms are 0 to 9 */
    PY_CODE_LOCATION_INFO_SHORT0 = 0,
    /* one lineforms are 10 to 12 */
    PY_CODE_LOCATION_INFO_ONE_LINE0 = 10,
    PY_CODE_LOCATION_INFO_ONE_LINE1 = 11,
    PY_CODE_LOCATION_INFO_ONE_LINE2 = 12,

    PY_CODE_LOCATION_INFO_NO_COLUMNS = 13,
    PY_CODE_LOCATION_INFO_LONG = 14,
    PY_CODE_LOCATION_INFO_NONE = 15;

// #ifdef __cplusplus
// #endif
// #endif  // !Py_CODE_H
// #endif  // !Py_LIMITED_API


// Parsed from compile.h

// #ifndef Py_COMPILE_H
// #define Py_COMPILE_H
// #ifdef __cplusplus
// #endif

/* These definitions must match corresponding definitions in graminit.h. */
public static final int Py_single_input = 256;
public static final int Py_file_input = 257;
public static final int Py_eval_input = 258;
public static final int Py_func_type_input = 345;

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_COMPILE_H
// #  include "cpython/compile.h"
// #  undef Py_CPYTHON_COMPILE_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_COMPILE_H */


// Parsed from cpython/compile.h

// #ifndef Py_CPYTHON_COMPILE_H
// #  error "this header file must not be included directly"
// #endif

/* Public interface */
public static final int PyCF_MASK = (CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | 
                   CO_FUTURE_WITH_STATEMENT | CO_FUTURE_PRINT_FUNCTION | 
                   CO_FUTURE_UNICODE_LITERALS | CO_FUTURE_BARRY_AS_BDFL | 
                   CO_FUTURE_GENERATOR_STOP | CO_FUTURE_ANNOTATIONS);
public static final int PyCF_MASK_OBSOLETE = (CO_NESTED);

/* bpo-39562: CO_FUTURE_ and PyCF_ constants must be kept unique.
   PyCF_ constants can use bits from 0x0100 to 0x10000.
   CO_FUTURE_ constants use bits starting at 0x20000. */
public static final int PyCF_SOURCE_IS_UTF8 =  0x0100;
public static final int PyCF_DONT_IMPLY_DEDENT = 0x0200;
public static final int PyCF_ONLY_AST = 0x0400;
public static final int PyCF_IGNORE_COOKIE = 0x0800;
public static final int PyCF_TYPE_COMMENTS = 0x1000;
public static final int PyCF_ALLOW_TOP_LEVEL_AWAIT = 0x2000;
public static final int PyCF_ALLOW_INCOMPLETE_INPUT = 0x4000;
public static final int PyCF_OPTIMIZED_AST = (0x8000 | PyCF_ONLY_AST);
public static final int PyCF_COMPILE_MASK = (PyCF_ONLY_AST | PyCF_ALLOW_TOP_LEVEL_AWAIT | 
                           PyCF_TYPE_COMMENTS | PyCF_DONT_IMPLY_DEDENT | 
                           PyCF_ALLOW_INCOMPLETE_INPUT | PyCF_OPTIMIZED_AST);
// Targeting ../PyCompilerFlags.java



// #define _PyCompilerFlags_INIT
//     (PyCompilerFlags){.cf_flags = 0, .cf_feature_version = PY_MINOR_VERSION}

/* Future feature support */

public static final String FUTURE_NESTED_SCOPES = "nested_scopes";
public static final String FUTURE_GENERATORS = "generators";
public static final String FUTURE_DIVISION = "division";
public static final String FUTURE_ABSOLUTE_IMPORT = "absolute_import";
public static final String FUTURE_WITH_STATEMENT = "with_statement";
public static final String FUTURE_PRINT_FUNCTION = "print_function";
public static final String FUTURE_UNICODE_LITERALS = "unicode_literals";
public static final String FUTURE_BARRY_AS_BDFL = "barry_as_FLUFL";
public static final String FUTURE_GENERATOR_STOP = "generator_stop";
public static final String FUTURE_ANNOTATIONS = "annotations";

public static final int PY_INVALID_STACK_EFFECT = INT_MAX;
@NoException public static native int PyCompile_OpcodeStackEffect(int opcode, int oparg);
@NoException public static native int PyCompile_OpcodeStackEffectWithJump(int opcode, int oparg, int jump);


// Parsed from pythonrun.h


/* Interfaces to parse and execute pieces of python code */

// #ifndef Py_PYTHONRUN_H
// #define Py_PYTHONRUN_H
// #ifdef __cplusplus
// #endif

@NoException public static native PyObject Py_CompileString(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, int arg2);
@NoException public static native PyObject Py_CompileString(String arg0, String arg1, int arg2);

@NoException public static native void PyErr_Print();
@NoException public static native void PyErr_PrintEx(int arg0);
@NoException public static native void PyErr_Display(PyObject arg0, PyObject arg1, PyObject arg2);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030C0000
@NoException public static native void PyErr_DisplayException(PyObject arg0);
// Targeting ../Int_PyOS_InputHook.java


public static native Int_PyOS_InputHook PyOS_InputHook(); public static native void PyOS_InputHook(Int_PyOS_InputHook setter);

// #if defined(WIN32)
// #  define USE_STACKCHECK
// #endif
// #ifdef USE_STACKCHECK
// #endif


// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_PYTHONRUN_H
// #  include "cpython/pythonrun.h"
// #  undef Py_CPYTHON_PYTHONRUN_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYTHONRUN_H */


// Parsed from cpython/pythonrun.h

// #ifndef Py_CPYTHON_PYTHONRUN_H
// #  error "this header file must not be included directly"
// #endif

@NoException public static native int PyRun_SimpleStringFlags(@Cast("const char*") BytePointer arg0, PyCompilerFlags arg1);
@NoException public static native int PyRun_SimpleStringFlags(String arg0, PyCompilerFlags arg1);
@NoException public static native int PyRun_AnyFileExFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int PyRun_AnyFileExFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int PyRun_SimpleFileExFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int PyRun_SimpleFileExFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveOneFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveOneFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveOneObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveLoopFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveLoopFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    PyCompilerFlags flags);


@NoException public static native PyObject PyRun_StringFlags(@Cast("const char*") BytePointer arg0, int arg1, PyObject arg2,
                                         PyObject arg3, PyCompilerFlags arg4);
@NoException public static native PyObject PyRun_StringFlags(String arg0, int arg1, PyObject arg2,
                                         PyObject arg3, PyCompilerFlags arg4);

@NoException public static native PyObject PyRun_FileExFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    int start,
    PyObject globals,
    PyObject locals,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native PyObject PyRun_FileExFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    int start,
    PyObject globals,
    PyObject locals,
    int closeit,
    PyCompilerFlags flags);


@NoException public static native PyObject Py_CompileStringExFlags(
    @Cast("const char*") BytePointer str,
    @Cast("const char*") BytePointer filename,
    int start,
    PyCompilerFlags flags,
    int optimize);
@NoException public static native PyObject Py_CompileStringExFlags(
    String str,
    String filename,
    int start,
    PyCompilerFlags flags,
    int optimize);
@NoException public static native PyObject Py_CompileStringObject(
    @Cast("const char*") BytePointer str,
    PyObject filename, int start,
    PyCompilerFlags flags,
    int optimize);
@NoException public static native PyObject Py_CompileStringObject(
    String str,
    PyObject filename, int start,
    PyCompilerFlags flags,
    int optimize);

// #define Py_CompileString(str, p, s) Py_CompileStringExFlags((str), (p), (s), NULL, -1)
// #define Py_CompileStringFlags(str, p, s, f) Py_CompileStringExFlags((str), (p), (s), (f), -1)

/* A function flavor is also exported by libpython. It is required when
    libpython is accessed directly rather than using header files which defines
    macros below. On Windows, for example, PyAPI_FUNC() uses dllexport to
    export functions in pythonXX.dll. */
@NoException public static native PyObject PyRun_String(@Cast("const char*") BytePointer str, int s, PyObject g, PyObject l);
@NoException public static native PyObject PyRun_String(String str, int s, PyObject g, PyObject l);
@NoException public static native int PyRun_AnyFile(@Cast("FILE*") Pointer fp, @Cast("const char*") BytePointer name);
@NoException public static native int PyRun_AnyFile(@Cast("FILE*") Pointer fp, String name);
@NoException public static native int PyRun_AnyFileEx(@Cast("FILE*") Pointer fp, @Cast("const char*") BytePointer name, int closeit);
@NoException public static native int PyRun_AnyFileEx(@Cast("FILE*") Pointer fp, String name, int closeit);
@NoException public static native int PyRun_AnyFileFlags(@Cast("FILE*") Pointer arg0, @Cast("const char*") BytePointer arg1, PyCompilerFlags arg2);
@NoException public static native int PyRun_AnyFileFlags(@Cast("FILE*") Pointer arg0, String arg1, PyCompilerFlags arg2);
@NoException public static native int PyRun_SimpleString(@Cast("const char*") BytePointer s);
@NoException public static native int PyRun_SimpleString(String s);
@NoException public static native int PyRun_SimpleFile(@Cast("FILE*") Pointer f, @Cast("const char*") BytePointer p);
@NoException public static native int PyRun_SimpleFile(@Cast("FILE*") Pointer f, String p);
@NoException public static native int PyRun_SimpleFileEx(@Cast("FILE*") Pointer f, @Cast("const char*") BytePointer p, int c);
@NoException public static native int PyRun_SimpleFileEx(@Cast("FILE*") Pointer f, String p, int c);
@NoException public static native int PyRun_InteractiveOne(@Cast("FILE*") Pointer f, @Cast("const char*") BytePointer p);
@NoException public static native int PyRun_InteractiveOne(@Cast("FILE*") Pointer f, String p);
@NoException public static native int PyRun_InteractiveLoop(@Cast("FILE*") Pointer f, @Cast("const char*") BytePointer p);
@NoException public static native int PyRun_InteractiveLoop(@Cast("FILE*") Pointer f, String p);
@NoException public static native PyObject PyRun_File(@Cast("FILE*") Pointer fp, @Cast("const char*") BytePointer p, int s, PyObject g, PyObject l);
@NoException public static native PyObject PyRun_File(@Cast("FILE*") Pointer fp, String p, int s, PyObject g, PyObject l);
@NoException public static native PyObject PyRun_FileEx(@Cast("FILE*") Pointer fp, @Cast("const char*") BytePointer p, int s, PyObject g, PyObject l, int c);
@NoException public static native PyObject PyRun_FileEx(@Cast("FILE*") Pointer fp, String p, int s, PyObject g, PyObject l, int c);
@NoException public static native PyObject PyRun_FileFlags(@Cast("FILE*") Pointer fp, @Cast("const char*") BytePointer p, int s, PyObject g, PyObject l, PyCompilerFlags flags);
@NoException public static native PyObject PyRun_FileFlags(@Cast("FILE*") Pointer fp, String p, int s, PyObject g, PyObject l, PyCompilerFlags flags);

/* Use macros for a bunch of old variants */
// #define PyRun_String(str, s, g, l) PyRun_StringFlags((str), (s), (g), (l), NULL)
// #define PyRun_AnyFile(fp, name) PyRun_AnyFileExFlags((fp), (name), 0, NULL)
// #define PyRun_AnyFileEx(fp, name, closeit)
//     PyRun_AnyFileExFlags((fp), (name), (closeit), NULL)
// #define PyRun_AnyFileFlags(fp, name, flags)
//     PyRun_AnyFileExFlags((fp), (name), 0, (flags))
// #define PyRun_SimpleString(s) PyRun_SimpleStringFlags((s), NULL)
// #define PyRun_SimpleFile(f, p) PyRun_SimpleFileExFlags((f), (p), 0, NULL)
// #define PyRun_SimpleFileEx(f, p, c) PyRun_SimpleFileExFlags((f), (p), (c), NULL)
// #define PyRun_InteractiveOne(f, p) PyRun_InteractiveOneFlags((f), (p), NULL)
// #define PyRun_InteractiveLoop(f, p) PyRun_InteractiveLoopFlags((f), (p), NULL)
// #define PyRun_File(fp, p, s, g, l)
//     PyRun_FileExFlags((fp), (p), (s), (g), (l), 0, NULL)
// #define PyRun_FileEx(fp, p, s, g, l, c)
//     PyRun_FileExFlags((fp), (p), (s), (g), (l), (c), NULL)
// #define PyRun_FileFlags(fp, p, s, g, l, flags)
//     PyRun_FileExFlags((fp), (p), (s), (g), (l), 0, (flags))

/* Stuff with no proper home (yet) */
@NoException public static native @Cast("char*") BytePointer PyOS_Readline(@Cast("FILE*") Pointer arg0, @Cast("FILE*") Pointer arg1, @Cast("const char*") BytePointer arg2);
@NoException public static native @Cast("char*") ByteBuffer PyOS_Readline(@Cast("FILE*") Pointer arg0, @Cast("FILE*") Pointer arg1, String arg2);
// Targeting ../PyOS_ReadlineFunctionPointer_Pointer_Pointer_BytePointer.java


public static native PyOS_ReadlineFunctionPointer_Pointer_Pointer_BytePointer PyOS_ReadlineFunctionPointer(); public static native void PyOS_ReadlineFunctionPointer(PyOS_ReadlineFunctionPointer_Pointer_Pointer_BytePointer setter);


// Parsed from pylifecycle.h


/* Interfaces to configure, query, create & destroy the Python runtime */

// #ifndef Py_PYLIFECYCLE_H
// #define Py_PYLIFECYCLE_H
// #ifdef __cplusplus
// #endif


/* Initialization and finalization */
@NoException public static native void Py_Initialize();
@NoException public static native void Py_InitializeEx(int arg0);
@NoException public static native void Py_Finalize();
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
@NoException public static native int Py_FinalizeEx();
// #endif
@NoException public static native int Py_IsInitialized();

/* Subinterpreter support */
@NoException public static native PyThreadState Py_NewInterpreter();
@NoException public static native void Py_EndInterpreter(PyThreadState arg0);
// Targeting ../Func.java


@NoException public static native int Py_AtExit(Func func);

@NoException public static native void Py_Exit(int arg0);

/* Bootstrap __main__ (defined in Modules/main.c) */
@NoException public static native int Py_Main(int argc, @Cast("wchar_t**") PointerPointer argv);
@NoException public static native int Py_Main(int argc, @Cast("wchar_t**") @ByPtrPtr Pointer argv);
@NoException public static native int Py_BytesMain(int argc, @Cast("char**") PointerPointer argv);
@NoException public static native int Py_BytesMain(int argc, @Cast("char**") @ByPtrPtr BytePointer argv);
@NoException public static native int Py_BytesMain(int argc, @Cast("char**") @ByPtrPtr ByteBuffer argv);
@NoException public static native int Py_BytesMain(int argc, @Cast("char**") @ByPtrPtr byte[] argv);

/* In pathconfig.c */
@NoException public static native @Deprecated void Py_SetProgramName(@Cast("const wchar_t*") Pointer arg0);
@NoException public static native @Cast("wchar_t*") @Deprecated Pointer Py_GetProgramName();

@NoException public static native @Deprecated void Py_SetPythonHome(@Cast("const wchar_t*") Pointer arg0);
@NoException public static native @Cast("wchar_t*") @Deprecated Pointer Py_GetPythonHome();

@NoException public static native @Cast("wchar_t*") @Deprecated Pointer Py_GetProgramFullPath();
@NoException public static native @Cast("wchar_t*") @Deprecated Pointer Py_GetPrefix();
@NoException public static native @Cast("wchar_t*") @Deprecated Pointer Py_GetExecPrefix();
@NoException public static native @Cast("wchar_t*") @Deprecated Pointer Py_GetPath();
// #ifdef MS_WINDOWS
// #endif

/* In their own files */
@NoException public static native @Cast("const char*") BytePointer Py_GetVersion();
@NoException public static native @Cast("const char*") BytePointer Py_GetPlatform();
@NoException public static native @Cast("const char*") BytePointer Py_GetCopyright();
@NoException public static native @Cast("const char*") BytePointer Py_GetCompiler();
@NoException public static native @Cast("const char*") BytePointer Py_GetBuildInfo();
// Targeting ../PyOS_sighandler_t.java


@NoException public static native PyOS_sighandler_t PyOS_getsig(int arg0);
@NoException public static native PyOS_sighandler_t PyOS_setsig(int arg0, PyOS_sighandler_t arg1);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030B0000
@MemberGetter public static native @Cast("const unsigned long") long Py_Version();
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030D0000
@NoException public static native int Py_IsFinalizing();
// #endif

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_PYLIFECYCLE_H
// #  include "cpython/pylifecycle.h"
// #  undef Py_CPYTHON_PYLIFECYCLE_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYLIFECYCLE_H */


// Parsed from cpython/pylifecycle.h

// #ifndef Py_CPYTHON_PYLIFECYCLE_H
// #  error "this header file must not be included directly"
// #endif

/* Py_FrozenMain is kept out of the Limited API until documented and present
   in all builds of Python */

/* PEP 432 Multi-phase initialization API (Private while provisional!) */

@NoException public static native @ByVal PyStatus Py_PreInitialize(
    @Const PyPreConfig src_config);
@NoException public static native @ByVal PyStatus Py_PreInitializeFromBytesArgs(
    @Const PyPreConfig src_config,
    @Cast("Py_ssize_t") long argc,
    @Cast("char**") PointerPointer argv);
@NoException public static native @ByVal PyStatus Py_PreInitializeFromBytesArgs(
    @Const PyPreConfig src_config,
    @Cast("Py_ssize_t") long argc,
    @Cast("char**") @ByPtrPtr BytePointer argv);
@NoException public static native @ByVal PyStatus Py_PreInitializeFromBytesArgs(
    @Const PyPreConfig src_config,
    @Cast("Py_ssize_t") long argc,
    @Cast("char**") @ByPtrPtr ByteBuffer argv);
@NoException public static native @ByVal PyStatus Py_PreInitializeFromBytesArgs(
    @Const PyPreConfig src_config,
    @Cast("Py_ssize_t") long argc,
    @Cast("char**") @ByPtrPtr byte[] argv);
@NoException public static native @ByVal PyStatus Py_PreInitializeFromArgs(
    @Const PyPreConfig src_config,
    @Cast("Py_ssize_t") long argc,
    @Cast("wchar_t**") PointerPointer argv);
@NoException public static native @ByVal PyStatus Py_PreInitializeFromArgs(
    @Const PyPreConfig src_config,
    @Cast("Py_ssize_t") long argc,
    @Cast("wchar_t**") @ByPtrPtr Pointer argv);


/* Initialization and finalization */

@NoException public static native @ByVal PyStatus Py_InitializeFromConfig(
    @Const PyConfig config);

@NoException public static native int Py_RunMain();


@NoException public static native void Py_ExitStatusException(@ByVal PyStatus err);

@NoException public static native int Py_FdIsInteractive(@Cast("FILE*") Pointer arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native int Py_FdIsInteractive(@Cast("FILE*") Pointer arg0, String arg1);

/* --- PyInterpreterConfig ------------------------------------ */

public static final int PyInterpreterConfig_DEFAULT_GIL = (0);
public static final int PyInterpreterConfig_SHARED_GIL = (1);
public static final int PyInterpreterConfig_OWN_GIL = (2);
// Targeting ../PyInterpreterConfig.java



// #define _PyInterpreterConfig_INIT
//     {
//         .se_main_obmalloc = 0,
//         .aow_fork = 0,
//         .aow_exec = 0,
//         .aow_threads = 1,
//         .aow_daemon_threads = 0,
//         .check_multi_interp_extensions = 1,
//         .gil = PyInterpreterConfig_OWN_GIL,
//     }

// gh-117649: The free-threaded build does not currently support single-phase
// init extensions in subinterpreters. For now, we ensure that
// `check_multi_interp_extensions` is always `1`, even in the legacy config.
// #ifdef Py_GIL_DISABLED
// #else
public static final int _PyInterpreterConfig_LEGACY_CHECK_MULTI_INTERP_EXTENSIONS = 0;
// #endif

// #define _PyInterpreterConfig_LEGACY_INIT
//     {
//         .se_main_obmalloc = 1,
//         .aow_fork = 1,
//         .aow_exec = 1,
//         .aow_threads = 1,
//         .aow_daemon_threads = 1,
//         .check_multi_interp_extensions = _PyInterpreterConfig_LEGACY_CHECK_MULTI_INTERP_EXTENSIONS,
//         .gil = PyInterpreterConfig_SHARED_GIL,
//     }

@NoException public static native @ByVal PyStatus Py_NewInterpreterFromConfig(
    @Cast("PyThreadState**") PointerPointer tstate_p,
    @Const PyInterpreterConfig config);
@NoException public static native @ByVal PyStatus Py_NewInterpreterFromConfig(
    @ByPtrPtr PyThreadState tstate_p,
    @Const PyInterpreterConfig config);
// Targeting ../atexit_datacallbackfunc.java


@NoException public static native int PyUnstable_AtExit(
        PyInterpreterState arg0, atexit_datacallbackfunc arg1, Pointer arg2);


// Parsed from cpython/pyctype.h

// #ifndef Py_LIMITED_API
// #ifndef PYCTYPE_H
// #define PYCTYPE_H
// #ifdef __cplusplus
// #endif

public static final int PY_CTF_LOWER =  0x01;
public static final int PY_CTF_UPPER =  0x02;
public static final int PY_CTF_ALPHA =  (PY_CTF_LOWER|PY_CTF_UPPER);
public static final int PY_CTF_DIGIT =  0x04;
public static final int PY_CTF_ALNUM =  (PY_CTF_ALPHA|PY_CTF_DIGIT);
public static final int PY_CTF_SPACE =  0x08;
public static final int PY_CTF_XDIGIT = 0x10;

@MemberGetter public static native @Cast("const unsigned int") int _Py_ctype_table(int i);
@MemberGetter public static native @Cast("const unsigned int*") IntPointer _Py_ctype_table();

/* Unlike their C counterparts, the following macros are not meant to
 * handle an int with any of the values [EOF, 0-UCHAR_MAX]. The argument
 * must be a signed/unsigned char. */
// #define Py_ISLOWER(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_LOWER)
// #define Py_ISUPPER(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_UPPER)
// #define Py_ISALPHA(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_ALPHA)
// #define Py_ISDIGIT(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_DIGIT)
// #define Py_ISXDIGIT(c) (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_XDIGIT)
// #define Py_ISALNUM(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_ALNUM)
// #define Py_ISSPACE(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_SPACE)

@MemberGetter public static native @Cast("const unsigned char") byte _Py_ctype_tolower(int i);
@MemberGetter public static native @Cast("const unsigned char*") BytePointer _Py_ctype_tolower();
@MemberGetter public static native @Cast("const unsigned char") byte _Py_ctype_toupper(int i);
@MemberGetter public static native @Cast("const unsigned char*") BytePointer _Py_ctype_toupper();

// #define Py_TOLOWER(c) (_Py_ctype_tolower[Py_CHARMASK(c)])
// #define Py_TOUPPER(c) (_Py_ctype_toupper[Py_CHARMASK(c)])

// #ifdef __cplusplus
// #endif
// #endif /* !PYCTYPE_H */
// #endif /* !Py_LIMITED_API */


// Parsed from pystrtod.h

// #ifndef Py_STRTOD_H
// #define Py_STRTOD_H

// #ifdef __cplusplus
// #endif


@NoException public static native double PyOS_string_to_double(@Cast("const char*") BytePointer str,
                                         @Cast("char**") PointerPointer endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(@Cast("const char*") BytePointer str,
                                         @Cast("char**") @ByPtrPtr BytePointer endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(String str,
                                         @Cast("char**") @ByPtrPtr ByteBuffer endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(@Cast("const char*") BytePointer str,
                                         @Cast("char**") @ByPtrPtr byte[] endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(String str,
                                         @Cast("char**") @ByPtrPtr BytePointer endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(@Cast("const char*") BytePointer str,
                                         @Cast("char**") @ByPtrPtr ByteBuffer endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(String str,
                                         @Cast("char**") @ByPtrPtr byte[] endptr,
                                         PyObject overflow_exception);

/* The caller is responsible for calling PyMem_Free to free the buffer
   that's is returned. */
@NoException public static native @Cast("char*") BytePointer PyOS_double_to_string(double val,
                                         @Cast("char") byte format_code,
                                         int precision,
                                         int flags,
                                         IntPointer type);
@NoException public static native @Cast("char*") ByteBuffer PyOS_double_to_string(double val,
                                         @Cast("char") byte format_code,
                                         int precision,
                                         int flags,
                                         IntBuffer type);
@NoException public static native @Cast("char*") byte[] PyOS_double_to_string(double val,
                                         @Cast("char") byte format_code,
                                         int precision,
                                         int flags,
                                         int[] type);

/* PyOS_double_to_string's "flags" parameter can be set to 0 or more of: */
public static final int Py_DTSF_SIGN =      0x01; /* always add the sign */
public static final int Py_DTSF_ADD_DOT_0 = 0x02; /* if the result is an integer add ".0" */
public static final int Py_DTSF_ALT =       0x04; /* "alternate" formatting. it's format_code
                                  specific */
public static final int Py_DTSF_NO_NEG_0 =  0x08; /* negative zero result is coerced to 0 */

/* PyOS_double_to_string's "type", if non-NULL, will be set to one of: */
public static final int Py_DTST_FINITE = 0;
public static final int Py_DTST_INFINITE = 1;
public static final int Py_DTST_NAN = 2;

// #ifdef __cplusplus
// #endif

// #endif /* !Py_STRTOD_H */


// Parsed from pystrcmp.h

// #ifndef Py_STRCMP_H
// #define Py_STRCMP_H

// #ifdef __cplusplus
// #endif

@NoException public static native int PyOS_mystrnicmp(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("Py_ssize_t") long arg2);
@NoException public static native int PyOS_mystrnicmp(String arg0, String arg1, @Cast("Py_ssize_t") long arg2);
@NoException public static native int PyOS_mystricmp(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native int PyOS_mystricmp(String arg0, String arg1);

// #ifdef MS_WINDOWS
// #else
// #define PyOS_strnicmp PyOS_mystrnicmp
// #define PyOS_stricmp PyOS_mystricmp
// #endif

// #ifdef __cplusplus
// #endif

// #endif /* !Py_STRCMP_H */


// Parsed from fileutils.h

// #ifndef Py_FILEUTILS_H
// #define Py_FILEUTILS_H

/*******************************
 * stat() and fstat() fiddling *
 *******************************/

// #ifdef HAVE_SYS_STAT_H
// #  include <sys/stat.h>           // S_ISREG()
// #elif defined(HAVE_STAT_H)
// #endif

// #ifndef S_IFMT
   // VisualAge C/C++ Failed to Define MountType Field in sys/stat.h.
public static final int S_IFMT = 0170000;
// #endif
// #ifndef S_IFLNK
   // Windows doesn't define S_IFLNK, but posixmodule.c maps
   // IO_REPARSE_TAG_SYMLINK to S_IFLNK.
public static final int S_IFLNK = 0120000;
// #endif
// #ifndef S_ISREG
// #  define S_ISREG(x) (((x) & S_IFMT) == S_IFREG)
// #endif
// #ifndef S_ISDIR
// #  define S_ISDIR(x) (((x) & S_IFMT) == S_IFDIR)
// #endif
// #ifndef S_ISCHR
// #  define S_ISCHR(x) (((x) & S_IFMT) == S_IFCHR)
// #endif
// #ifndef S_ISLNK
// #  define S_ISLNK(x) (((x) & S_IFMT) == S_IFLNK)
// #endif


// Move this down here since some C++ #include's don't like to be included
// inside an extern "C".
// #ifdef __cplusplus
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
@NoException public static native @Cast("wchar_t*") Pointer Py_DecodeLocale(
    @Cast("const char*") BytePointer arg,
    @Cast("size_t*") SizeTPointer size);
@NoException public static native @Cast("wchar_t*") Pointer Py_DecodeLocale(
    String arg,
    @Cast("size_t*") SizeTPointer size);

@NoException public static native @Cast("char*") BytePointer Py_EncodeLocale(
    @Cast("const wchar_t*") Pointer text,
    @Cast("size_t*") SizeTPointer error_pos);
// #endif

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_FILEUTILS_H
// #  include "cpython/fileutils.h"
// #  undef Py_CPYTHON_FILEUTILS_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_FILEUTILS_H */


// Parsed from cpython/fileutils.h

// #ifndef Py_CPYTHON_FILEUTILS_H
// #  error "this header file must not be included directly"
// #endif

@NoException public static native @Cast("FILE*") Pointer Py_fopen(
    PyObject path,
    @Cast("const char*") BytePointer mode);
@NoException public static native @Cast("FILE*") Pointer Py_fopen(
    PyObject path,
    String mode);

// Deprecated alias kept for backward compatibility
@NoException public static native @Cast("FILE*") @Deprecated Pointer _Py_fopen_obj(PyObject path, @Cast("const char*") BytePointer mode);
@NoException public static native @Cast("FILE*") @Deprecated Pointer _Py_fopen_obj(PyObject path, String mode);

@NoException public static native int Py_fclose(@Cast("FILE*") Pointer file);


// Parsed from cpython/pyfpe.h

// #ifndef Py_PYFPE_H
// #define Py_PYFPE_H
/* Header excluded from the stable API */
// #ifndef Py_LIMITED_API

/* These macros used to do something when Python was built with --with-fpectl,
 * but support for that was dropped in 3.7. We continue to define them though,
 * to avoid breaking API users.
 */

// #define PyFPE_START_PROTECT(err_string, leave_stmt)
// #define PyFPE_END_PROTECT(v)

// #endif /* !defined(Py_LIMITED_API) */
// #endif /* !Py_PYFPE_H */


// Parsed from cpython/pyhash.h

// #ifndef Py_CPYTHON_HASH_H
// #  error "this header file must not be included directly"
// #endif

/* Prime multiplier used in string and various other hashes. */
public static final long PyHASH_MULTIPLIER = 1000003L;  /* 0xf4243 */

/* Parameters used for the numeric hash implementation.  See notes for
   _Py_HashDouble in Python/pyhash.c.  Numeric hashes are based on
   reduction modulo the prime 2**_PyHASH_BITS - 1. */

// #if SIZEOF_VOID_P >= 8
public static final int PyHASH_BITS = 61;
// #else
// #endif

public static native @MemberGetter long PyHASH_MODULUS();
public static final long PyHASH_MODULUS = PyHASH_MODULUS();
public static final int PyHASH_INF = 314159;
public static final long PyHASH_IMAG = PyHASH_MULTIPLIER;

/* Aliases kept for backward compatibility with Python 3.12 */
public static final long _PyHASH_MULTIPLIER = PyHASH_MULTIPLIER;
public static final int _PyHASH_BITS = PyHASH_BITS;
public static native @MemberGetter long _PyHASH_MODULUS();
public static final long _PyHASH_MODULUS = _PyHASH_MODULUS();
public static final int _PyHASH_INF = PyHASH_INF;
public static final long _PyHASH_IMAG = PyHASH_IMAG;

/* Helpers for hash functions */
@NoException public static native @Cast("Py_hash_t") long _Py_HashDouble(PyObject arg0, double arg1);
// Targeting ../PyHash_FuncDef.java



@NoException public static native PyHash_FuncDef PyHash_GetFuncDef();

@NoException public static native @Cast("Py_hash_t") long Py_HashPointer(@Const Pointer ptr);

// Deprecated alias kept for backward compatibility
@NoException public static native @Cast("Py_hash_t") @Deprecated long _Py_HashPointer(@Const Pointer ptr);

@NoException public static native @Cast("Py_hash_t") long PyObject_GenericHash(PyObject arg0);

@NoException public static native @Cast("Py_hash_t") long Py_HashBuffer(@Const Pointer ptr, @Cast("Py_ssize_t") long len);


// Parsed from cpython/tracemalloc.h

// #ifndef Py_LIMITED_API
// #ifndef Py_TRACEMALLOC_H
// #define Py_TRACEMALLOC_H
// #ifdef __cplusplus
// #endif

/* Track an allocated memory block in the tracemalloc module.
   Return 0 on success, return -1 on error (failed to allocate memory to store
   the trace).

   Return -2 if tracemalloc is disabled.

   If memory block is already tracked, update the existing trace. */
@NoException public static native int PyTraceMalloc_Track(
    @Cast("unsigned int") int domain,
    @Cast("uintptr_t") long ptr,
    @Cast("size_t") long size);

/* Untrack an allocated memory block in the tracemalloc module.
   Do nothing if the block was not tracked.

   Return -2 if tracemalloc is disabled, otherwise return 0. */
@NoException public static native int PyTraceMalloc_Untrack(
    @Cast("unsigned int") int domain,
    @Cast("uintptr_t") long ptr);

// #ifdef __cplusplus
// #endif
// #endif  // !Py_TRACEMALLOC_H
// #endif  // !Py_LIMITED_API


// Parsed from datetime.h

/*  datetime.h
 */
// #ifndef Py_LIMITED_API
// #ifndef DATETIME_H
// #define DATETIME_H
// #ifdef __cplusplus
// #endif

/* Fields are packed into successive bytes, each viewed as unsigned and
 * big-endian, unless otherwise noted:
 *
 * byte offset
 *  0           year     2 bytes, 1-9999
 *  2           month    1 byte, 1-12
 *  3           day      1 byte, 1-31
 *  4           hour     1 byte, 0-23
 *  5           minute   1 byte, 0-59
 *  6           second   1 byte, 0-59
 *  7           usecond  3 bytes, 0-999999
 * 10
 */

/* # of bytes for year, month, and day. */
public static final int _PyDateTime_DATE_DATASIZE = 4;

/* # of bytes for hour, minute, second, and usecond. */
public static final int _PyDateTime_TIME_DATASIZE = 6;

/* # of bytes for year, month, day, hour, minute, second, and usecond. */
public static final int _PyDateTime_DATETIME_DATASIZE = 10;
// Targeting ../PyDateTime_Delta.java


// Targeting ../PyDateTime_TZInfo.java




/* The datetime and time types have hashcodes, and an optional tzinfo member,
 * present if and only if hastzinfo is true.
 */
// #define _PyTZINFO_HEAD
//     PyObject_HEAD
//     Py_hash_t hashcode;
//     char hastzinfo;
// Targeting ../_PyDateTime_BaseTZInfo.java



/* All time objects are of PyDateTime_TimeType, but that can be allocated
 * in two ways, with or without a tzinfo member.  Without is the same as
 * tzinfo == None, but consumes less memory.  _PyDateTime_BaseTime is an
 * internal struct used to allocate the right amount of space for the
 * "without" case.
 */
// #define _PyDateTime_TIMEHEAD
//     _PyTZINFO_HEAD
//     unsigned char data[_PyDateTime_TIME_DATASIZE];
// Targeting ../_PyDateTime_BaseTime.java


// Targeting ../PyDateTime_Time.java


// Targeting ../PyDateTime_Date.java



// #define _PyDateTime_DATETIMEHEAD
//     _PyTZINFO_HEAD
//     unsigned char data[_PyDateTime_DATETIME_DATASIZE];
// Targeting ../_PyDateTime_BaseDateTime.java


// Targeting ../PyDateTime_DateTime.java

          /* hastzinfo true */


/* Apply for date and datetime instances. */

// o is a pointer to a time or a datetime object.
// #define _PyDateTime_HAS_TZINFO(o)  (((_PyDateTime_BaseTZInfo *)(o))->hastzinfo)

// #define PyDateTime_GET_YEAR(o)     ((((PyDateTime_Date*)(o))->data[0] << 8) |
//                      ((PyDateTime_Date*)(o))->data[1])
// #define PyDateTime_GET_MONTH(o)    (((PyDateTime_Date*)(o))->data[2])
// #define PyDateTime_GET_DAY(o)      (((PyDateTime_Date*)(o))->data[3])

// #define PyDateTime_DATE_GET_HOUR(o)        (((PyDateTime_DateTime*)(o))->data[4])
// #define PyDateTime_DATE_GET_MINUTE(o)      (((PyDateTime_DateTime*)(o))->data[5])
// #define PyDateTime_DATE_GET_SECOND(o)      (((PyDateTime_DateTime*)(o))->data[6])
// #define PyDateTime_DATE_GET_MICROSECOND(o)
//     ((((PyDateTime_DateTime*)(o))->data[7] << 16) |
//      (((PyDateTime_DateTime*)(o))->data[8] << 8)  |
//       ((PyDateTime_DateTime*)(o))->data[9])
// #define PyDateTime_DATE_GET_FOLD(o)        (((PyDateTime_DateTime*)(o))->fold)
// #define PyDateTime_DATE_GET_TZINFO(o)      (_PyDateTime_HAS_TZINFO((o)) ?
//     ((PyDateTime_DateTime *)(o))->tzinfo : Py_None)

/* Apply for time instances. */
// #define PyDateTime_TIME_GET_HOUR(o)        (((PyDateTime_Time*)(o))->data[0])
// #define PyDateTime_TIME_GET_MINUTE(o)      (((PyDateTime_Time*)(o))->data[1])
// #define PyDateTime_TIME_GET_SECOND(o)      (((PyDateTime_Time*)(o))->data[2])
// #define PyDateTime_TIME_GET_MICROSECOND(o)
//     ((((PyDateTime_Time*)(o))->data[3] << 16) |
//      (((PyDateTime_Time*)(o))->data[4] << 8)  |
//       ((PyDateTime_Time*)(o))->data[5])
// #define PyDateTime_TIME_GET_FOLD(o)        (((PyDateTime_Time*)(o))->fold)
// #define PyDateTime_TIME_GET_TZINFO(o)      (_PyDateTime_HAS_TZINFO(o) ?
//     ((PyDateTime_Time *)(o))->tzinfo : Py_None)

/* Apply for time delta instances */
// #define PyDateTime_DELTA_GET_DAYS(o)         (((PyDateTime_Delta*)(o))->days)
// #define PyDateTime_DELTA_GET_SECONDS(o)      (((PyDateTime_Delta*)(o))->seconds)
// #define PyDateTime_DELTA_GET_MICROSECONDS(o)
//     (((PyDateTime_Delta*)(o))->microseconds)
// Targeting ../PyDateTime_CAPI.java



public static final String PyDateTime_CAPSULE_NAME = "datetime.datetime_CAPI";


/* This block is only used as part of the public API and should not be
 * included in _datetimemodule.c, which does not use the C API capsule.
 * See bpo-35081 for more details.
 * */
// #ifndef _PY_DATETIME_IMPL
/* Define global variable for the C API and a macro for setting it. */
public static native PyDateTime_CAPI PyDateTimeAPI(); public static native void PyDateTimeAPI(PyDateTime_CAPI setter);

// #define PyDateTime_IMPORT
//     PyDateTimeAPI = (PyDateTime_CAPI *)PyCapsule_Import(PyDateTime_CAPSULE_NAME, 0)

/* Macro for access to the UTC singleton */
// #define PyDateTime_TimeZone_UTC PyDateTimeAPI->TimeZone_UTC

/* Macros for type checking when not building the Python core. */
// #define PyDate_Check(op) PyObject_TypeCheck((op), PyDateTimeAPI->DateType)
// #define PyDate_CheckExact(op) Py_IS_TYPE((op), PyDateTimeAPI->DateType)

// #define PyDateTime_Check(op) PyObject_TypeCheck((op), PyDateTimeAPI->DateTimeType)
// #define PyDateTime_CheckExact(op) Py_IS_TYPE((op), PyDateTimeAPI->DateTimeType)

// #define PyTime_Check(op) PyObject_TypeCheck((op), PyDateTimeAPI->TimeType)
// #define PyTime_CheckExact(op) Py_IS_TYPE((op), PyDateTimeAPI->TimeType)

// #define PyDelta_Check(op) PyObject_TypeCheck((op), PyDateTimeAPI->DeltaType)
// #define PyDelta_CheckExact(op) Py_IS_TYPE((op), PyDateTimeAPI->DeltaType)

// #define PyTZInfo_Check(op) PyObject_TypeCheck((op), PyDateTimeAPI->TZInfoType)
// #define PyTZInfo_CheckExact(op) Py_IS_TYPE((op), PyDateTimeAPI->TZInfoType)


/* Macros for accessing constructors in a simplified fashion. */
// #define PyDate_FromDate(year, month, day)
//     PyDateTimeAPI->Date_FromDate((year), (month), (day), PyDateTimeAPI->DateType)

// #define PyDateTime_FromDateAndTime(year, month, day, hour, min, sec, usec)
//     PyDateTimeAPI->DateTime_FromDateAndTime((year), (month), (day), (hour),
//         (min), (sec), (usec), Py_None, PyDateTimeAPI->DateTimeType)

// #define PyDateTime_FromDateAndTimeAndFold(year, month, day, hour, min, sec, usec, fold)
//     PyDateTimeAPI->DateTime_FromDateAndTimeAndFold((year), (month), (day), (hour),
//         (min), (sec), (usec), Py_None, (fold), PyDateTimeAPI->DateTimeType)

// #define PyTime_FromTime(hour, minute, second, usecond)
//     PyDateTimeAPI->Time_FromTime((hour), (minute), (second), (usecond),
//         Py_None, PyDateTimeAPI->TimeType)

// #define PyTime_FromTimeAndFold(hour, minute, second, usecond, fold)
//     PyDateTimeAPI->Time_FromTimeAndFold((hour), (minute), (second), (usecond),
//         Py_None, (fold), PyDateTimeAPI->TimeType)

// #define PyDelta_FromDSU(days, seconds, useconds)
//     PyDateTimeAPI->Delta_FromDelta((days), (seconds), (useconds), 1,
//         PyDateTimeAPI->DeltaType)

// #define PyTimeZone_FromOffset(offset)
//     PyDateTimeAPI->TimeZone_FromTimeZone((offset), NULL)

// #define PyTimeZone_FromOffsetAndName(offset, name)
//     PyDateTimeAPI->TimeZone_FromTimeZone((offset), (name))

/* Macros supporting the DB API. */
// #define PyDateTime_FromTimestamp(args)
//     PyDateTimeAPI->DateTime_FromTimestamp(
//         (PyObject*) (PyDateTimeAPI->DateTimeType), (args), NULL)

// #define PyDate_FromTimestamp(args)
//     PyDateTimeAPI->Date_FromTimestamp(
//         (PyObject*) (PyDateTimeAPI->DateType), (args))

// #endif   /* !defined(_PY_DATETIME_IMPL) */

// #ifdef __cplusplus
// #endif
// #endif
// #endif /* !Py_LIMITED_API */


}
