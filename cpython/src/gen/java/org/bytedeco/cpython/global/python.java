// Targeted by JavaCPP version 1.5.7: DO NOT EDIT THIS FILE

package org.bytedeco.cpython.global;

import org.bytedeco.cpython.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

public class python extends org.bytedeco.cpython.helper.python {
    static { Loader.load(); }

// Parsed from Python.h

// #ifndef Py_PYTHON_H
// #define Py_PYTHON_H
/* Since this is a "meta-include" file, no #ifdef __cplusplus / extern "C" { */

/* Include nearly all Python header files */

// #include "patchlevel.h"
// #include "pyconfig.h"
// #include "pymacconfig.h"

// #include <limits.h>

// #ifndef UCHAR_MAX
// #error "Something's broken.  UCHAR_MAX should be defined in limits.h."
// #endif

// #if UCHAR_MAX != 255
// #error "Python's source code assumes C's unsigned char is an 8-bit type."
// #endif

// #if defined(__sgi) && !defined(_SGI_MP_SOURCE)
// #define _SGI_MP_SOURCE
// #endif

// #include <stdio.h>
// #ifndef NULL
// #   error "Python.h requires that stdio.h define NULL."
// #endif

// #include <string.h>
// #ifdef HAVE_ERRNO_H
// #include <errno.h>
// #endif
// #include <stdlib.h>
// #ifndef MS_WINDOWS
// #include <unistd.h>
// #endif

/* For size_t? */
// #ifdef HAVE_STDDEF_H
// #include <stddef.h>
// #endif

/* CAUTION:  Build setups should ensure that NDEBUG is defined on the
 * compiler command line when building Python in release mode; else
 * assert() calls won't be removed.
 */
// #include <assert.h>

// #include "pyport.h"
// #include "pymacro.h"

/* A convenient way for code to know if sanitizers are enabled. */
// #if defined(__has_feature)
// #  if __has_feature(memory_sanitizer)
// #    if !defined(_Py_MEMORY_SANITIZER)
// #      define _Py_MEMORY_SANITIZER
// #    endif
// #  endif
// #  if __has_feature(address_sanitizer)
// #    if !defined(_Py_ADDRESS_SANITIZER)
// #      define _Py_ADDRESS_SANITIZER
// #    endif
// #  endif
// #elif defined(__GNUC__)
// #  if defined(__SANITIZE_ADDRESS__)
// #    define _Py_ADDRESS_SANITIZER
// #  endif
// #endif

// #include "pymath.h"
// #include "pymem.h"

// #include "object.h"
// #include "objimpl.h"
// #include "typeslots.h"
// #include "pyhash.h"

// #include "cpython/pydebug.h"

// #include "bytearrayobject.h"
// #include "bytesobject.h"
// #include "unicodeobject.h"
// #include "longobject.h"
// #include "longintrepr.h"
// #include "boolobject.h"
// #include "floatobject.h"
// #include "complexobject.h"
// #include "rangeobject.h"
// #include "memoryobject.h"
// #include "tupleobject.h"
// #include "listobject.h"
// #include "dictobject.h"
// #include "cpython/odictobject.h"
// #include "enumobject.h"
// #include "setobject.h"
// #include "methodobject.h"
// #include "moduleobject.h"
// #include "funcobject.h"
// #include "classobject.h"
// #include "fileobject.h"
// #include "pycapsule.h"
// #include "code.h"
// #include "pyframe.h"
// #include "traceback.h"
// #include "sliceobject.h"
// #include "cellobject.h"
// #include "iterobject.h"
// #include "cpython/initconfig.h"
// #include "genobject.h"
// #include "descrobject.h"
// #include "genericaliasobject.h"
// #include "warnings.h"
// #include "weakrefobject.h"
// #include "structseq.h"
// #include "namespaceobject.h"
// #include "cpython/picklebufobject.h"
// #include "cpython/pytime.h"

// #include "codecs.h"
// #include "pyerrors.h"
// #include "pythread.h"
// #include "pystate.h"
// #include "context.h"

// #include "modsupport.h"
// #include "compile.h"
// #include "pythonrun.h"
// #include "pylifecycle.h"
// #include "ceval.h"
// #include "sysmodule.h"
// #include "osmodule.h"
// #include "intrcheck.h"
// #include "import.h"

// #include "abstract.h"
// #include "bltinmodule.h"

// #include "eval.h"

// #include "cpython/pyctype.h"
// #include "pystrtod.h"
// #include "pystrcmp.h"
// #include "fileutils.h"
// #include "cpython/pyfpe.h"
// #include "tracemalloc.h"

// #endif /* !Py_PYTHON_H */


// Parsed from patchlevel.h


/* Python version identification scheme.

   When the major or minor version changes, the VERSION variable in
   configure.ac must also be changed.

   There is also (independent) API version information in modsupport.h.
*/

/* Values for PY_RELEASE_LEVEL */
public static final int PY_RELEASE_LEVEL_ALPHA =  0xA;
public static final int PY_RELEASE_LEVEL_BETA =   0xB;
public static final int PY_RELEASE_LEVEL_GAMMA =  0xC;     /* For release candidates */
public static final int PY_RELEASE_LEVEL_FINAL =  0xF;     /* Serial should be 0 here */
                                        /* Higher for patch releases */

/* Version parsed out into numeric values */
/*--start constants--*/
public static final int PY_MAJOR_VERSION =        3;
public static final int PY_MINOR_VERSION =        10;
public static final int PY_MICRO_VERSION =        2;
public static final int PY_RELEASE_LEVEL =        PY_RELEASE_LEVEL_FINAL;
public static final int PY_RELEASE_SERIAL =       0;

/* Version as a string */
public static final String PY_VERSION =              "3.10.2";
/*--end constants--*/

/* Version as a single 4-byte hex number, e.g. 0x010502B2 == 1.5.2b2.
   Use this for numeric comparisons, e.g. #if PY_VERSION_HEX >= ... */
public static final int PY_VERSION_HEX = ((PY_MAJOR_VERSION << 24) | 
                        (PY_MINOR_VERSION << 16) | 
                        (PY_MICRO_VERSION <<  8) | 
                        (PY_RELEASE_LEVEL <<  4) | 
                        (PY_RELEASE_SERIAL << 0));


// Parsed from pyconfig.h

/* pyconfig.h.  Generated from pyconfig.h.in by configure.  */
/* pyconfig.h.in.  Generated from configure.ac by autoheader.  */


// #ifndef Py_PYCONFIG_H
// #define Py_PYCONFIG_H


/* Define if building universal (internal helper macro) */
/* #undef AC_APPLE_UNIVERSAL_BUILD */

/* BUILD_GNU_TYPE + AIX_BUILDDATE are used to construct the PEP425 tag of the
   build system. */
/* #undef AIX_BUILDDATE */

/* Define for AIX if your compiler is a genuine IBM xlC/xlC_r and you want
   support for AIX C++ shared extension modules. */
/* #undef AIX_GENUINE_CPLUSPLUS */

/* The normal alignment of `long', in bytes. */
public static final int ALIGNOF_LONG = 8;

/* The normal alignment of `size_t', in bytes. */
public static final int ALIGNOF_SIZE_T = 8;

/* Alternative SOABI used in debug build to load C extensions built in release
   mode */
/* #undef ALT_SOABI */

/* The Android API level. */
/* #undef ANDROID_API_LEVEL */

/* Define if C doubles are 64-bit IEEE 754 binary format, stored in ARM
   mixed-endian order (byte order 45670123) */
/* #undef DOUBLE_IS_ARM_MIXED_ENDIAN_IEEE754 */

/* Define if C doubles are 64-bit IEEE 754 binary format, stored with the most
   significant byte first */
/* #undef DOUBLE_IS_BIG_ENDIAN_IEEE754 */

/* Define if C doubles are 64-bit IEEE 754 binary format, stored with the
   least significant byte first */
public static final int DOUBLE_IS_LITTLE_ENDIAN_IEEE754 = 1;

/* Define if --enable-ipv6 is specified */
public static final int ENABLE_IPV6 = 1;

/* Better isolate subinterpreters, experimental build mode. */
/* #undef EXPERIMENTAL_ISOLATED_SUBINTERPRETERS */

/* Define to 1 if your system stores words within floats with the most
   significant word first */
/* #undef FLOAT_WORDS_BIGENDIAN */

/* Define if flock needs to be linked with bsd library. */
/* #undef FLOCK_NEEDS_LIBBSD */

/* Define if getpgrp() must be called as getpgrp(0). */
/* #undef GETPGRP_HAVE_ARG */

/* Define to 1 if you have the `accept4' function. */
public static final int HAVE_ACCEPT4 = 1;

/* Define to 1 if you have the `acosh' function. */
public static final int HAVE_ACOSH = 1;

/* struct addrinfo (netdb.h) */
public static final int HAVE_ADDRINFO = 1;

/* Define to 1 if you have the `alarm' function. */
public static final int HAVE_ALARM = 1;

/* Define if aligned memory access is required */
/* #undef HAVE_ALIGNED_REQUIRED */

/* Define to 1 if you have the <alloca.h> header file. */
public static final int HAVE_ALLOCA_H = 1;

/* Define this if your time.h defines altzone. */
/* #undef HAVE_ALTZONE */

/* Define to 1 if you have the `asinh' function. */
public static final int HAVE_ASINH = 1;

/* Define to 1 if you have the <asm/types.h> header file. */
public static final int HAVE_ASM_TYPES_H = 1;

/* Define to 1 if you have the `atanh' function. */
public static final int HAVE_ATANH = 1;

/* Define to 1 if you have the `bind_textdomain_codeset' function. */
public static final int HAVE_BIND_TEXTDOMAIN_CODESET = 1;

/* Define to 1 if you have the <bluetooth/bluetooth.h> header file. */
/* #undef HAVE_BLUETOOTH_BLUETOOTH_H */

/* Define to 1 if you have the <bluetooth.h> header file. */
/* #undef HAVE_BLUETOOTH_H */

/* Define if mbstowcs(NULL, "text", 0) does not return the number of wide
   chars that would be converted. */
/* #undef HAVE_BROKEN_MBSTOWCS */

/* Define if nice() returns success/failure instead of the new priority. */
/* #undef HAVE_BROKEN_NICE */

/* Define if the system reports an invalid PIPE_BUF value. */
/* #undef HAVE_BROKEN_PIPE_BUF */

/* Define if poll() sets errno on invalid file descriptors. */
/* #undef HAVE_BROKEN_POLL */

/* Define if the Posix semaphores do not work on your system */
/* #undef HAVE_BROKEN_POSIX_SEMAPHORES */

/* Define if pthread_sigmask() does not work on your system. */
/* #undef HAVE_BROKEN_PTHREAD_SIGMASK */

/* define to 1 if your sem_getvalue is broken. */
/* #undef HAVE_BROKEN_SEM_GETVALUE */

/* Define if `unsetenv` does not return an int. */
/* #undef HAVE_BROKEN_UNSETENV */

/* Has builtin __atomic_load_n() and __atomic_store_n() functions */
public static final int HAVE_BUILTIN_ATOMIC = 1;

/* Define to 1 if you have the 'chflags' function. */
/* #undef HAVE_CHFLAGS */

/* Define to 1 if you have the `chown' function. */
public static final int HAVE_CHOWN = 1;

/* Define if you have the 'chroot' function. */
public static final int HAVE_CHROOT = 1;

/* Define to 1 if you have the `clock' function. */
public static final int HAVE_CLOCK = 1;

/* Define to 1 if you have the `clock_getres' function. */
public static final int HAVE_CLOCK_GETRES = 1;

/* Define to 1 if you have the `clock_gettime' function. */
public static final int HAVE_CLOCK_GETTIME = 1;

/* Define to 1 if you have the `clock_settime' function. */
public static final int HAVE_CLOCK_SETTIME = 1;

/* Define to 1 if you have the `close_range' function. */
/* #undef HAVE_CLOSE_RANGE */

/* Define if the C compiler supports computed gotos. */
public static final int HAVE_COMPUTED_GOTOS = 1;

/* Define to 1 if you have the `confstr' function. */
public static final int HAVE_CONFSTR = 1;

/* Define to 1 if you have the <conio.h> header file. */
/* #undef HAVE_CONIO_H */

/* Define to 1 if you have the `copysign' function. */
public static final int HAVE_COPYSIGN = 1;

/* Define to 1 if you have the `copy_file_range' function. */
public static final int HAVE_COPY_FILE_RANGE = 1;

/* Define to 1 if you have the <crypt.h> header file. */
public static final int HAVE_CRYPT_H = 1;

/* Define if you have the crypt_r() function. */
public static final int HAVE_CRYPT_R = 1;

/* Define to 1 if you have the `ctermid' function. */
public static final int HAVE_CTERMID = 1;

/* Define if you have the 'ctermid_r' function. */
/* #undef HAVE_CTERMID_R */

/* Define if you have the 'filter' function. */
public static final int HAVE_CURSES_FILTER = 1;

/* Define to 1 if you have the <curses.h> header file. */
public static final int HAVE_CURSES_H = 1;

/* Define if you have the 'has_key' function. */
public static final int HAVE_CURSES_HAS_KEY = 1;

/* Define if you have the 'immedok' function. */
public static final int HAVE_CURSES_IMMEDOK = 1;

/* Define if you have the 'is_pad' function or macro. */
public static final int HAVE_CURSES_IS_PAD = 1;

/* Define if you have the 'is_term_resized' function. */
public static final int HAVE_CURSES_IS_TERM_RESIZED = 1;

/* Define if you have the 'resizeterm' function. */
public static final int HAVE_CURSES_RESIZETERM = 1;

/* Define if you have the 'resize_term' function. */
public static final int HAVE_CURSES_RESIZE_TERM = 1;

/* Define if you have the 'syncok' function. */
public static final int HAVE_CURSES_SYNCOK = 1;

/* Define if you have the 'typeahead' function. */
public static final int HAVE_CURSES_TYPEAHEAD = 1;

/* Define if you have the 'use_env' function. */
public static final int HAVE_CURSES_USE_ENV = 1;

/* Define if you have the 'wchgat' function. */
public static final int HAVE_CURSES_WCHGAT = 1;

/* Define to 1 if you have the declaration of `isfinite', and to 0 if you
   don't. */
public static final int HAVE_DECL_ISFINITE = 1;

/* Define to 1 if you have the declaration of `isinf', and to 0 if you don't.
   */
public static final int HAVE_DECL_ISINF = 1;

/* Define to 1 if you have the declaration of `isnan', and to 0 if you don't.
   */
public static final int HAVE_DECL_ISNAN = 1;

/* Define to 1 if you have the declaration of `RTLD_DEEPBIND', and to 0 if you
   don't. */
public static final int HAVE_DECL_RTLD_DEEPBIND = 1;

/* Define to 1 if you have the declaration of `RTLD_GLOBAL', and to 0 if you
   don't. */
public static final int HAVE_DECL_RTLD_GLOBAL = 1;

/* Define to 1 if you have the declaration of `RTLD_LAZY', and to 0 if you
   don't. */
public static final int HAVE_DECL_RTLD_LAZY = 1;

/* Define to 1 if you have the declaration of `RTLD_LOCAL', and to 0 if you
   don't. */
public static final int HAVE_DECL_RTLD_LOCAL = 1;

/* Define to 1 if you have the declaration of `RTLD_MEMBER', and to 0 if you
   don't. */
public static final int HAVE_DECL_RTLD_MEMBER = 0;

/* Define to 1 if you have the declaration of `RTLD_NODELETE', and to 0 if you
   don't. */
public static final int HAVE_DECL_RTLD_NODELETE = 1;

/* Define to 1 if you have the declaration of `RTLD_NOLOAD', and to 0 if you
   don't. */
public static final int HAVE_DECL_RTLD_NOLOAD = 1;

/* Define to 1 if you have the declaration of `RTLD_NOW', and to 0 if you
   don't. */
public static final int HAVE_DECL_RTLD_NOW = 1;

/* Define to 1 if you have the declaration of `tzname', and to 0 if you don't.
   */
/* #undef HAVE_DECL_TZNAME */

/* Define to 1 if you have the device macros. */
public static final int HAVE_DEVICE_MACROS = 1;

/* Define to 1 if you have the /dev/ptc device file. */
/* #undef HAVE_DEV_PTC */

/* Define to 1 if you have the /dev/ptmx device file. */
public static final int HAVE_DEV_PTMX = 1;

/* Define to 1 if you have the <direct.h> header file. */
/* #undef HAVE_DIRECT_H */

/* Define to 1 if the dirent structure has a d_type field */
public static final int HAVE_DIRENT_D_TYPE = 1;

/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
   */
public static final int HAVE_DIRENT_H = 1;

/* Define if you have the 'dirfd' function or macro. */
public static final int HAVE_DIRFD = 1;

/* Define to 1 if you have the <dlfcn.h> header file. */
public static final int HAVE_DLFCN_H = 1;

/* Define to 1 if you have the `dlopen' function. */
// #define HAVE_DLOPEN 1

/* Define to 1 if you have the `dup2' function. */
public static final int HAVE_DUP2 = 1;

/* Define to 1 if you have the `dup3' function. */
public static final int HAVE_DUP3 = 1;

/* Define if you have the '_dyld_shared_cache_contains_path' function. */
/* #undef HAVE_DYLD_SHARED_CACHE_CONTAINS_PATH */

/* Defined when any dynamic module loading is enabled. */
public static final int HAVE_DYNAMIC_LOADING = 1;

/* Define to 1 if you have the <endian.h> header file. */
public static final int HAVE_ENDIAN_H = 1;

/* Define if you have the 'epoll' functions. */
public static final int HAVE_EPOLL = 1;

/* Define if you have the 'epoll_create1' function. */
public static final int HAVE_EPOLL_CREATE1 = 1;

/* Define to 1 if you have the `erf' function. */
public static final int HAVE_ERF = 1;

/* Define to 1 if you have the `erfc' function. */
public static final int HAVE_ERFC = 1;

/* Define to 1 if you have the <errno.h> header file. */
public static final int HAVE_ERRNO_H = 1;

/* Define if you have the 'eventfd' function. */
public static final int HAVE_EVENTFD = 1;

/* Define to 1 if you have the `execv' function. */
public static final int HAVE_EXECV = 1;

/* Define to 1 if you have the `explicit_bzero' function. */
public static final int HAVE_EXPLICIT_BZERO = 1;

/* Define to 1 if you have the `explicit_memset' function. */
/* #undef HAVE_EXPLICIT_MEMSET */

/* Define to 1 if you have the `expm1' function. */
public static final int HAVE_EXPM1 = 1;

/* Define to 1 if you have the `faccessat' function. */
public static final int HAVE_FACCESSAT = 1;

/* Define if you have the 'fchdir' function. */
public static final int HAVE_FCHDIR = 1;

/* Define to 1 if you have the `fchmod' function. */
public static final int HAVE_FCHMOD = 1;

/* Define to 1 if you have the `fchmodat' function. */
public static final int HAVE_FCHMODAT = 1;

/* Define to 1 if you have the `fchown' function. */
public static final int HAVE_FCHOWN = 1;

/* Define to 1 if you have the `fchownat' function. */
public static final int HAVE_FCHOWNAT = 1;

/* Define to 1 if you have the <fcntl.h> header file. */
public static final int HAVE_FCNTL_H = 1;

/* Define if you have the 'fdatasync' function. */
public static final int HAVE_FDATASYNC = 1;

/* Define to 1 if you have the `fdopendir' function. */
public static final int HAVE_FDOPENDIR = 1;

/* Define to 1 if you have the `fdwalk' function. */
/* #undef HAVE_FDWALK */

/* Define to 1 if you have the `fexecve' function. */
public static final int HAVE_FEXECVE = 1;

/* Define to 1 if you have the `finite' function. */
public static final int HAVE_FINITE = 1;

/* Define to 1 if you have the `flock' function. */
public static final int HAVE_FLOCK = 1;

/* Define to 1 if you have the `fork' function. */
// #define HAVE_FORK 1

/* Define to 1 if you have the `forkpty' function. */
public static final int HAVE_FORKPTY = 1;

/* Define to 1 if you have the `fpathconf' function. */
public static final int HAVE_FPATHCONF = 1;

/* Define to 1 if you have the `fseek64' function. */
/* #undef HAVE_FSEEK64 */

/* Define to 1 if you have the `fseeko' function. */
public static final int HAVE_FSEEKO = 1;

/* Define to 1 if you have the `fstatat' function. */
public static final int HAVE_FSTATAT = 1;

/* Define to 1 if you have the `fstatvfs' function. */
public static final int HAVE_FSTATVFS = 1;

/* Define if you have the 'fsync' function. */
public static final int HAVE_FSYNC = 1;

/* Define to 1 if you have the `ftell64' function. */
/* #undef HAVE_FTELL64 */

/* Define to 1 if you have the `ftello' function. */
public static final int HAVE_FTELLO = 1;

/* Define to 1 if you have the `ftime' function. */
public static final int HAVE_FTIME = 1;

/* Define to 1 if you have the `ftruncate' function. */
public static final int HAVE_FTRUNCATE = 1;

/* Define to 1 if you have the `futimens' function. */
public static final int HAVE_FUTIMENS = 1;

/* Define to 1 if you have the `futimes' function. */
public static final int HAVE_FUTIMES = 1;

/* Define to 1 if you have the `futimesat' function. */
public static final int HAVE_FUTIMESAT = 1;

/* Define to 1 if you have the `gai_strerror' function. */
public static final int HAVE_GAI_STRERROR = 1;

/* Define to 1 if you have the `gamma' function. */
public static final int HAVE_GAMMA = 1;

/* Define if we can use gcc inline assembler to get and set mc68881 fpcr */
/* #undef HAVE_GCC_ASM_FOR_MC68881 */

/* Define if we can use x64 gcc inline assembler */
public static final int HAVE_GCC_ASM_FOR_X64 = 1;

/* Define if we can use gcc inline assembler to get and set x87 control word
   */
// #define HAVE_GCC_ASM_FOR_X87 1

/* Define if your compiler provides __uint128_t */
public static final int HAVE_GCC_UINT128_T = 1;

/* Define if you have the getaddrinfo function. */
public static final int HAVE_GETADDRINFO = 1;

/* Define this if you have flockfile(), getc_unlocked(), and funlockfile() */
public static final int HAVE_GETC_UNLOCKED = 1;

/* Define to 1 if you have the `getentropy' function. */
public static final int HAVE_GETENTROPY = 1;

/* Define to 1 if you have the `getgrgid_r' function. */
public static final int HAVE_GETGRGID_R = 1;

/* Define to 1 if you have the `getgrnam_r' function. */
public static final int HAVE_GETGRNAM_R = 1;

/* Define to 1 if you have the `getgrouplist' function. */
public static final int HAVE_GETGROUPLIST = 1;

/* Define to 1 if you have the `getgroups' function. */
public static final int HAVE_GETGROUPS = 1;

/* Define to 1 if you have the `gethostbyname' function. */
/* #undef HAVE_GETHOSTBYNAME */

/* Define this if you have some version of gethostbyname_r() */
public static final int HAVE_GETHOSTBYNAME_R = 1;

/* Define this if you have the 3-arg version of gethostbyname_r(). */
/* #undef HAVE_GETHOSTBYNAME_R_3_ARG */

/* Define this if you have the 5-arg version of gethostbyname_r(). */
/* #undef HAVE_GETHOSTBYNAME_R_5_ARG */

/* Define this if you have the 6-arg version of gethostbyname_r(). */
public static final int HAVE_GETHOSTBYNAME_R_6_ARG = 1;

/* Define to 1 if you have the `getitimer' function. */
public static final int HAVE_GETITIMER = 1;

/* Define to 1 if you have the `getloadavg' function. */
public static final int HAVE_GETLOADAVG = 1;

/* Define to 1 if you have the `getlogin' function. */
public static final int HAVE_GETLOGIN = 1;

/* Define to 1 if you have the `getnameinfo' function. */
public static final int HAVE_GETNAMEINFO = 1;

/* Define if you have the 'getpagesize' function. */
public static final int HAVE_GETPAGESIZE = 1;

/* Define to 1 if you have the `getpeername' function. */
public static final int HAVE_GETPEERNAME = 1;

/* Define to 1 if you have the `getpgid' function. */
public static final int HAVE_GETPGID = 1;

/* Define to 1 if you have the `getpgrp' function. */
public static final int HAVE_GETPGRP = 1;

/* Define to 1 if you have the `getpid' function. */
public static final int HAVE_GETPID = 1;

/* Define to 1 if you have the `getpriority' function. */
public static final int HAVE_GETPRIORITY = 1;

/* Define to 1 if you have the `getpwent' function. */
public static final int HAVE_GETPWENT = 1;

/* Define to 1 if you have the `getpwnam_r' function. */
public static final int HAVE_GETPWNAM_R = 1;

/* Define to 1 if you have the `getpwuid_r' function. */
public static final int HAVE_GETPWUID_R = 1;

/* Define to 1 if the getrandom() function is available */
public static final int HAVE_GETRANDOM = 1;

/* Define to 1 if the Linux getrandom() syscall is available */
public static final int HAVE_GETRANDOM_SYSCALL = 1;

/* Define to 1 if you have the `getresgid' function. */
public static final int HAVE_GETRESGID = 1;

/* Define to 1 if you have the `getresuid' function. */
public static final int HAVE_GETRESUID = 1;

/* Define to 1 if you have the `getsid' function. */
public static final int HAVE_GETSID = 1;

/* Define to 1 if you have the `getspent' function. */
public static final int HAVE_GETSPENT = 1;

/* Define to 1 if you have the `getspnam' function. */
public static final int HAVE_GETSPNAM = 1;

/* Define to 1 if you have the `getwd' function. */
public static final int HAVE_GETWD = 1;

/* Define if glibc has incorrect _FORTIFY_SOURCE wrappers for memmove and
   bcopy. */
/* #undef HAVE_GLIBC_MEMMOVE_BUG */

/* Define to 1 if you have the <grp.h> header file. */
public static final int HAVE_GRP_H = 1;

/* Define if you have the 'hstrerror' function. */
public static final int HAVE_HSTRERROR = 1;

/* Define this if you have le64toh() */
public static final int HAVE_HTOLE64 = 1;

/* Define to 1 if you have the `hypot' function. */
public static final int HAVE_HYPOT = 1;

/* Define to 1 if you have the <ieeefp.h> header file. */
/* #undef HAVE_IEEEFP_H */

/* Define to 1 if you have the `if_nameindex' function. */
public static final int HAVE_IF_NAMEINDEX = 1;

/* Define if you have the 'inet_aton' function. */
public static final int HAVE_INET_ATON = 1;

/* Define if you have the 'inet_pton' function. */
public static final int HAVE_INET_PTON = 1;

/* Define to 1 if you have the `initgroups' function. */
public static final int HAVE_INITGROUPS = 1;

/* Define to 1 if you have the <inttypes.h> header file. */
public static final int HAVE_INTTYPES_H = 1;

/* Define to 1 if you have the <io.h> header file. */
/* #undef HAVE_IO_H */

/* Define if gcc has the ipa-pure-const bug. */
/* #undef HAVE_IPA_PURE_CONST_BUG */

/* Define to 1 if you have the `kill' function. */
public static final int HAVE_KILL = 1;

/* Define to 1 if you have the `killpg' function. */
public static final int HAVE_KILLPG = 1;

/* Define if you have the 'kqueue' functions. */
/* #undef HAVE_KQUEUE */

/* Define to 1 if you have the <langinfo.h> header file. */
public static final int HAVE_LANGINFO_H = 1;

/* Defined to enable large file support when an off_t is bigger than a long
   and long long is at least as big as an off_t. You may need to add some
   flags for configuration and compilation to enable this mode. (For Solaris
   and Linux, the necessary defines are already defined.) */
/* #undef HAVE_LARGEFILE_SUPPORT */

/* Define to 1 if you have the 'lchflags' function. */
/* #undef HAVE_LCHFLAGS */

/* Define to 1 if you have the `lchmod' function. */
/* #undef HAVE_LCHMOD */

/* Define to 1 if you have the `lchown' function. */
public static final int HAVE_LCHOWN = 1;

/* Define to 1 if you have the `lgamma' function. */
public static final int HAVE_LGAMMA = 1;

/* Define to 1 if you have the `dl' library (-ldl). */
public static final int HAVE_LIBDL = 1;

/* Define to 1 if you have the `dld' library (-ldld). */
/* #undef HAVE_LIBDLD */

/* Define to 1 if you have the `ieee' library (-lieee). */
/* #undef HAVE_LIBIEEE */

/* Define to 1 if you have the <libintl.h> header file. */
public static final int HAVE_LIBINTL_H = 1;

/* Define to build the readline module. */
/* #undef HAVE_LIBREADLINE */

/* Define to 1 if you have the `resolv' library (-lresolv). */
/* #undef HAVE_LIBRESOLV */

/* Define to 1 if you have the `sendfile' library (-lsendfile). */
/* #undef HAVE_LIBSENDFILE */

/* Define to 1 if you have the <libutil.h> header file. */
/* #undef HAVE_LIBUTIL_H */

/* Define to 1 if you have the `uuid' library (-luuid). */
public static final int HAVE_LIBUUID = 1;

/* Define if you have the 'link' function. */
public static final int HAVE_LINK = 1;

/* Define to 1 if you have the `linkat' function. */
public static final int HAVE_LINKAT = 1;

/* Define to 1 if you have the <linux/can/bcm.h> header file. */
public static final int HAVE_LINUX_CAN_BCM_H = 1;

/* Define to 1 if you have the <linux/can.h> header file. */
public static final int HAVE_LINUX_CAN_H = 1;

/* Define to 1 if you have the <linux/can/j1939.h> header file. */
public static final int HAVE_LINUX_CAN_J1939_H = 1;

/* Define if compiling using Linux 3.6 or later. */
public static final int HAVE_LINUX_CAN_RAW_FD_FRAMES = 1;

/* Define to 1 if you have the <linux/can/raw.h> header file. */
public static final int HAVE_LINUX_CAN_RAW_H = 1;

/* Define if compiling using Linux 4.1 or later. */
public static final int HAVE_LINUX_CAN_RAW_JOIN_FILTERS = 1;

/* Define to 1 if you have the <linux/memfd.h> header file. */
public static final int HAVE_LINUX_MEMFD_H = 1;

/* Define to 1 if you have the <linux/netlink.h> header file. */
public static final int HAVE_LINUX_NETLINK_H = 1;

/* Define to 1 if you have the <linux/qrtr.h> header file. */
public static final int HAVE_LINUX_QRTR_H = 1;

/* Define to 1 if you have the <linux/random.h> header file. */
public static final int HAVE_LINUX_RANDOM_H = 1;

/* Define to 1 if you have the <linux/tipc.h> header file. */
public static final int HAVE_LINUX_TIPC_H = 1;

/* Define to 1 if you have the <linux/vm_sockets.h> header file. */
public static final int HAVE_LINUX_VM_SOCKETS_H = 1;

/* Define to 1 if you have the <linux/wait.h> header file. */
public static final int HAVE_LINUX_WAIT_H = 1;

/* Define to 1 if you have the `lockf' function. */
public static final int HAVE_LOCKF = 1;

/* Define to 1 if you have the `log1p' function. */
public static final int HAVE_LOG1P = 1;

/* Define to 1 if you have the `log2' function. */
public static final int HAVE_LOG2 = 1;

/* Define to 1 if the system has the type `long double'. */
public static final int HAVE_LONG_DOUBLE = 1;

/* Define to 1 if you have the `lstat' function. */
public static final int HAVE_LSTAT = 1;

/* Define to 1 if you have the `lutimes' function. */
public static final int HAVE_LUTIMES = 1;

/* Define to 1 if you have the `madvise' function. */
public static final int HAVE_MADVISE = 1;

/* Define this if you have the makedev macro. */
public static final int HAVE_MAKEDEV = 1;

/* Define to 1 if you have the `mbrtowc' function. */
public static final int HAVE_MBRTOWC = 1;

/* Define if you have the 'memfd_create' function. */
public static final int HAVE_MEMFD_CREATE = 1;

/* Define to 1 if you have the <memory.h> header file. */
public static final int HAVE_MEMORY_H = 1;

/* Define to 1 if you have the `memrchr' function. */
public static final int HAVE_MEMRCHR = 1;

/* Define to 1 if you have the `mkdirat' function. */
public static final int HAVE_MKDIRAT = 1;

/* Define to 1 if you have the `mkfifo' function. */
public static final int HAVE_MKFIFO = 1;

/* Define to 1 if you have the `mkfifoat' function. */
public static final int HAVE_MKFIFOAT = 1;

/* Define to 1 if you have the `mknod' function. */
public static final int HAVE_MKNOD = 1;

/* Define to 1 if you have the `mknodat' function. */
public static final int HAVE_MKNODAT = 1;

/* Define to 1 if you have the `mktime' function. */
public static final int HAVE_MKTIME = 1;

/* Define to 1 if you have the `mmap' function. */
public static final int HAVE_MMAP = 1;

/* Define to 1 if you have the `mremap' function. */
public static final int HAVE_MREMAP = 1;

/* Define to 1 if you have the <ncurses.h> header file. */
public static final int HAVE_NCURSES_H = 1;

/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
/* #undef HAVE_NDIR_H */

/* Define to 1 if you have the <netpacket/packet.h> header file. */
public static final int HAVE_NETPACKET_PACKET_H = 1;

/* Define to 1 if you have the <net/if.h> header file. */
public static final int HAVE_NET_IF_H = 1;

/* Define to 1 if you have the `nice' function. */
public static final int HAVE_NICE = 1;

/* Define if the internal form of wchar_t in non-Unicode locales is not
   Unicode. */
/* #undef HAVE_NON_UNICODE_WCHAR_T_REPRESENTATION */

/* Define to 1 if you have the `openat' function. */
public static final int HAVE_OPENAT = 1;

/* Define to 1 if you have the `openpty' function. */
public static final int HAVE_OPENPTY = 1;

/* Define to 1 if you have the `pathconf' function. */
public static final int HAVE_PATHCONF = 1;

/* Define to 1 if you have the `pause' function. */
public static final int HAVE_PAUSE = 1;

/* Define to 1 if you have the `pipe2' function. */
public static final int HAVE_PIPE2 = 1;

/* Define to 1 if you have the `plock' function. */
/* #undef HAVE_PLOCK */

/* Define to 1 if you have the `poll' function. */
public static final int HAVE_POLL = 1;

/* Define to 1 if you have the <poll.h> header file. */
public static final int HAVE_POLL_H = 1;

/* Define to 1 if you have the `posix_fadvise' function. */
public static final int HAVE_POSIX_FADVISE = 1;

/* Define to 1 if you have the `posix_fallocate' function. */
public static final int HAVE_POSIX_FALLOCATE = 1;

/* Define to 1 if you have the `posix_spawn' function. */
public static final int HAVE_POSIX_SPAWN = 1;

/* Define to 1 if you have the `posix_spawnp' function. */
public static final int HAVE_POSIX_SPAWNP = 1;

/* Define to 1 if you have the `pread' function. */
public static final int HAVE_PREAD = 1;

/* Define to 1 if you have the `preadv' function. */
public static final int HAVE_PREADV = 1;

/* Define to 1 if you have the `preadv2' function. */
public static final int HAVE_PREADV2 = 1;

/* Define if you have the 'prlimit' functions. */
public static final int HAVE_PRLIMIT = 1;

/* Define to 1 if you have the <process.h> header file. */
/* #undef HAVE_PROCESS_H */

/* Define if your compiler supports function prototype */
public static final int HAVE_PROTOTYPES = 1;

/* Define to 1 if you have the `pthread_condattr_setclock' function. */
public static final int HAVE_PTHREAD_CONDATTR_SETCLOCK = 1;

/* Defined for Solaris 2.6 bug in pthread header. */
/* #undef HAVE_PTHREAD_DESTRUCTOR */

/* Define to 1 if you have the `pthread_getcpuclockid' function. */
public static final int HAVE_PTHREAD_GETCPUCLOCKID = 1;

/* Define to 1 if you have the <pthread.h> header file. */
public static final int HAVE_PTHREAD_H = 1;

/* Define to 1 if you have the `pthread_init' function. */
/* #undef HAVE_PTHREAD_INIT */

/* Define to 1 if you have the `pthread_kill' function. */
public static final int HAVE_PTHREAD_KILL = 1;

/* Define to 1 if you have the `pthread_sigmask' function. */
public static final int HAVE_PTHREAD_SIGMASK = 1;

/* Define to 1 if you have the <pty.h> header file. */
public static final int HAVE_PTY_H = 1;

/* Define to 1 if you have the `pwrite' function. */
public static final int HAVE_PWRITE = 1;

/* Define to 1 if you have the `pwritev' function. */
public static final int HAVE_PWRITEV = 1;

/* Define to 1 if you have the `pwritev2' function. */
public static final int HAVE_PWRITEV2 = 1;

/* Define to 1 if you have the `readlink' function. */
public static final int HAVE_READLINK = 1;

/* Define to 1 if you have the `readlinkat' function. */
public static final int HAVE_READLINKAT = 1;

/* Define to 1 if you have the `readv' function. */
public static final int HAVE_READV = 1;

/* Define to 1 if you have the `realpath' function. */
public static final int HAVE_REALPATH = 1;

/* Define to 1 if you have the `renameat' function. */
public static final int HAVE_RENAMEAT = 1;

/* Define if readline supports append_history */
/* #undef HAVE_RL_APPEND_HISTORY */

/* Define if you can turn off readline's signal handling. */
/* #undef HAVE_RL_CATCH_SIGNAL */

/* Define if you have readline 2.2 */
/* #undef HAVE_RL_COMPLETION_APPEND_CHARACTER */

/* Define if you have readline 4.0 */
/* #undef HAVE_RL_COMPLETION_DISPLAY_MATCHES_HOOK */

/* Define if you have readline 4.2 */
/* #undef HAVE_RL_COMPLETION_MATCHES */

/* Define if you have rl_completion_suppress_append */
/* #undef HAVE_RL_COMPLETION_SUPPRESS_APPEND */

/* Define if you have readline 4.0 */
/* #undef HAVE_RL_PRE_INPUT_HOOK */

/* Define if you have readline 4.0 */
/* #undef HAVE_RL_RESIZE_TERMINAL */

/* Define to 1 if you have the `round' function. */
public static final int HAVE_ROUND = 1;

/* Define to 1 if you have the `rtpSpawn' function. */
/* #undef HAVE_RTPSPAWN */

/* Define to 1 if you have the `sched_get_priority_max' function. */
public static final int HAVE_SCHED_GET_PRIORITY_MAX = 1;

/* Define to 1 if you have the <sched.h> header file. */
public static final int HAVE_SCHED_H = 1;

/* Define to 1 if you have the `sched_rr_get_interval' function. */
public static final int HAVE_SCHED_RR_GET_INTERVAL = 1;

/* Define to 1 if you have the `sched_setaffinity' function. */
public static final int HAVE_SCHED_SETAFFINITY = 1;

/* Define to 1 if you have the `sched_setparam' function. */
public static final int HAVE_SCHED_SETPARAM = 1;

/* Define to 1 if you have the `sched_setscheduler' function. */
public static final int HAVE_SCHED_SETSCHEDULER = 1;

/* Define to 1 if you have the `sem_clockwait' function. */
public static final int HAVE_SEM_CLOCKWAIT = 1;

/* Define to 1 if you have the `sem_getvalue' function. */
public static final int HAVE_SEM_GETVALUE = 1;

/* Define to 1 if you have the `sem_open' function. */
public static final int HAVE_SEM_OPEN = 1;

/* Define to 1 if you have the `sem_timedwait' function. */
public static final int HAVE_SEM_TIMEDWAIT = 1;

/* Define to 1 if you have the `sem_unlink' function. */
public static final int HAVE_SEM_UNLINK = 1;

/* Define to 1 if you have the `sendfile' function. */
public static final int HAVE_SENDFILE = 1;

/* Define to 1 if you have the `setegid' function. */
public static final int HAVE_SETEGID = 1;

/* Define to 1 if you have the `seteuid' function. */
public static final int HAVE_SETEUID = 1;

/* Define to 1 if you have the `setgid' function. */
public static final int HAVE_SETGID = 1;

/* Define if you have the 'setgroups' function. */
public static final int HAVE_SETGROUPS = 1;

/* Define to 1 if you have the `sethostname' function. */
public static final int HAVE_SETHOSTNAME = 1;

/* Define to 1 if you have the `setitimer' function. */
public static final int HAVE_SETITIMER = 1;

/* Define to 1 if you have the `setlocale' function. */
public static final int HAVE_SETLOCALE = 1;

/* Define to 1 if you have the `setpgid' function. */
public static final int HAVE_SETPGID = 1;

/* Define to 1 if you have the `setpgrp' function. */
public static final int HAVE_SETPGRP = 1;

/* Define to 1 if you have the `setpriority' function. */
public static final int HAVE_SETPRIORITY = 1;

/* Define to 1 if you have the `setregid' function. */
public static final int HAVE_SETREGID = 1;

/* Define to 1 if you have the `setresgid' function. */
public static final int HAVE_SETRESGID = 1;

/* Define to 1 if you have the `setresuid' function. */
public static final int HAVE_SETRESUID = 1;

/* Define to 1 if you have the `setreuid' function. */
public static final int HAVE_SETREUID = 1;

/* Define to 1 if you have the `setsid' function. */
public static final int HAVE_SETSID = 1;

/* Define to 1 if you have the `setuid' function. */
public static final int HAVE_SETUID = 1;

/* Define to 1 if you have the `setvbuf' function. */
public static final int HAVE_SETVBUF = 1;

/* Define to 1 if you have the <shadow.h> header file. */
public static final int HAVE_SHADOW_H = 1;

/* Define to 1 if you have the `shm_open' function. */
public static final int HAVE_SHM_OPEN = 1;

/* Define to 1 if you have the `shm_unlink' function. */
public static final int HAVE_SHM_UNLINK = 1;

/* Define to 1 if you have the `sigaction' function. */
public static final int HAVE_SIGACTION = 1;

/* Define to 1 if you have the `sigaltstack' function. */
public static final int HAVE_SIGALTSTACK = 1;

/* Define to 1 if you have the `sigfillset' function. */
public static final int HAVE_SIGFILLSET = 1;

/* Define to 1 if `si_band' is a member of `siginfo_t'. */
public static final int HAVE_SIGINFO_T_SI_BAND = 1;

/* Define to 1 if you have the `siginterrupt' function. */
public static final int HAVE_SIGINTERRUPT = 1;

/* Define to 1 if you have the <signal.h> header file. */
public static final int HAVE_SIGNAL_H = 1;

/* Define to 1 if you have the `sigpending' function. */
public static final int HAVE_SIGPENDING = 1;

/* Define to 1 if you have the `sigrelse' function. */
public static final int HAVE_SIGRELSE = 1;

/* Define to 1 if you have the `sigtimedwait' function. */
public static final int HAVE_SIGTIMEDWAIT = 1;

/* Define to 1 if you have the `sigwait' function. */
public static final int HAVE_SIGWAIT = 1;

/* Define to 1 if you have the `sigwaitinfo' function. */
public static final int HAVE_SIGWAITINFO = 1;

/* Define to 1 if you have the `snprintf' function. */
public static final int HAVE_SNPRINTF = 1;

/* struct sockaddr_alg (linux/if_alg.h) */
public static final int HAVE_SOCKADDR_ALG = 1;

/* Define if sockaddr has sa_len member */
/* #undef HAVE_SOCKADDR_SA_LEN */

/* struct sockaddr_storage (sys/socket.h) */
public static final int HAVE_SOCKADDR_STORAGE = 1;

/* Define if you have the 'socketpair' function. */
public static final int HAVE_SOCKETPAIR = 1;

/* Define to 1 if you have the <spawn.h> header file. */
public static final int HAVE_SPAWN_H = 1;

/* Define to 1 if you have the `splice' function. */
public static final int HAVE_SPLICE = 1;

/* Define if your compiler provides ssize_t */
public static final int HAVE_SSIZE_T = 1;

/* Define to 1 if you have the `statvfs' function. */
public static final int HAVE_STATVFS = 1;

/* Define if you have struct stat.st_mtim.tv_nsec */
public static final int HAVE_STAT_TV_NSEC = 1;

/* Define if you have struct stat.st_mtimensec */
/* #undef HAVE_STAT_TV_NSEC2 */

/* Define if your compiler supports variable length function prototypes (e.g.
   void fprintf(FILE *, char *, ...);) *and* <stdarg.h> */
public static final int HAVE_STDARG_PROTOTYPES = 1;

/* Define to 1 if you have the <stdint.h> header file. */
public static final int HAVE_STDINT_H = 1;

/* Define to 1 if you have the <stdlib.h> header file. */
public static final int HAVE_STDLIB_H = 1;

/* Has stdatomic.h with atomic_int and atomic_uintptr_t */
public static final int HAVE_STD_ATOMIC = 1;

/* Define to 1 if you have the `strftime' function. */
public static final int HAVE_STRFTIME = 1;

/* Define to 1 if you have the <strings.h> header file. */
public static final int HAVE_STRINGS_H = 1;

/* Define to 1 if you have the <string.h> header file. */
public static final int HAVE_STRING_H = 1;

/* Define to 1 if you have the `strlcpy' function. */
/* #undef HAVE_STRLCPY */

/* Define to 1 if you have the <stropts.h> header file. */
/* #undef HAVE_STROPTS_H */

/* Define to 1 if you have the `strsignal' function. */
public static final int HAVE_STRSIGNAL = 1;

/* Define to 1 if `pw_gecos' is a member of `struct passwd'. */
public static final int HAVE_STRUCT_PASSWD_PW_GECOS = 1;

/* Define to 1 if `pw_passwd' is a member of `struct passwd'. */
public static final int HAVE_STRUCT_PASSWD_PW_PASSWD = 1;

/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */

/* Define to 1 if `st_blksize' is a member of `struct stat'. */
public static final int HAVE_STRUCT_STAT_ST_BLKSIZE = 1;

/* Define to 1 if `st_blocks' is a member of `struct stat'. */
public static final int HAVE_STRUCT_STAT_ST_BLOCKS = 1;

/* Define to 1 if `st_flags' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_FLAGS */

/* Define to 1 if `st_gen' is a member of `struct stat'. */
/* #undef HAVE_STRUCT_STAT_ST_GEN */

/* Define to 1 if `st_rdev' is a member of `struct stat'. */
public static final int HAVE_STRUCT_STAT_ST_RDEV = 1;

/* Define to 1 if `tm_zone' is a member of `struct tm'. */
public static final int HAVE_STRUCT_TM_TM_ZONE = 1;

/* Define if you have the 'symlink' function. */
public static final int HAVE_SYMLINK = 1;

/* Define to 1 if you have the `symlinkat' function. */
public static final int HAVE_SYMLINKAT = 1;

/* Define to 1 if you have the `sync' function. */
public static final int HAVE_SYNC = 1;

/* Define to 1 if you have the `sysconf' function. */
public static final int HAVE_SYSCONF = 1;

/* Define to 1 if you have the <sysexits.h> header file. */
public static final int HAVE_SYSEXITS_H = 1;

/* Define to 1 if you have the <sys/audioio.h> header file. */
/* #undef HAVE_SYS_AUDIOIO_H */

/* Define to 1 if you have the <sys/bsdtty.h> header file. */
/* #undef HAVE_SYS_BSDTTY_H */

/* Define to 1 if you have the <sys/devpoll.h> header file. */
/* #undef HAVE_SYS_DEVPOLL_H */

/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_DIR_H */

/* Define to 1 if you have the <sys/endian.h> header file. */
/* #undef HAVE_SYS_ENDIAN_H */

/* Define to 1 if you have the <sys/epoll.h> header file. */
public static final int HAVE_SYS_EPOLL_H = 1;

/* Define to 1 if you have the <sys/eventfd.h> header file. */
public static final int HAVE_SYS_EVENTFD_H = 1;

/* Define to 1 if you have the <sys/event.h> header file. */
/* #undef HAVE_SYS_EVENT_H */

/* Define to 1 if you have the <sys/file.h> header file. */
public static final int HAVE_SYS_FILE_H = 1;

/* Define to 1 if you have the <sys/ioctl.h> header file. */
public static final int HAVE_SYS_IOCTL_H = 1;

/* Define to 1 if you have the <sys/kern_control.h> header file. */
/* #undef HAVE_SYS_KERN_CONTROL_H */

/* Define to 1 if you have the <sys/loadavg.h> header file. */
/* #undef HAVE_SYS_LOADAVG_H */

/* Define to 1 if you have the <sys/lock.h> header file. */
/* #undef HAVE_SYS_LOCK_H */

/* Define to 1 if you have the <sys/memfd.h> header file. */
/* #undef HAVE_SYS_MEMFD_H */

/* Define to 1 if you have the <sys/mkdev.h> header file. */
/* #undef HAVE_SYS_MKDEV_H */

/* Define to 1 if you have the <sys/mman.h> header file. */
public static final int HAVE_SYS_MMAN_H = 1;

/* Define to 1 if you have the <sys/modem.h> header file. */
/* #undef HAVE_SYS_MODEM_H */

/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
   */
/* #undef HAVE_SYS_NDIR_H */

/* Define to 1 if you have the <sys/param.h> header file. */
public static final int HAVE_SYS_PARAM_H = 1;

/* Define to 1 if you have the <sys/poll.h> header file. */
public static final int HAVE_SYS_POLL_H = 1;

/* Define to 1 if you have the <sys/random.h> header file. */
public static final int HAVE_SYS_RANDOM_H = 1;

/* Define to 1 if you have the <sys/resource.h> header file. */
public static final int HAVE_SYS_RESOURCE_H = 1;

/* Define to 1 if you have the <sys/select.h> header file. */
public static final int HAVE_SYS_SELECT_H = 1;

/* Define to 1 if you have the <sys/sendfile.h> header file. */
public static final int HAVE_SYS_SENDFILE_H = 1;

/* Define to 1 if you have the <sys/socket.h> header file. */
public static final int HAVE_SYS_SOCKET_H = 1;

/* Define to 1 if you have the <sys/statvfs.h> header file. */
public static final int HAVE_SYS_STATVFS_H = 1;

/* Define to 1 if you have the <sys/stat.h> header file. */
public static final int HAVE_SYS_STAT_H = 1;

/* Define to 1 if you have the <sys/syscall.h> header file. */
public static final int HAVE_SYS_SYSCALL_H = 1;

/* Define to 1 if you have the <sys/sysmacros.h> header file. */
public static final int HAVE_SYS_SYSMACROS_H = 1;

/* Define to 1 if you have the <sys/sys_domain.h> header file. */
/* #undef HAVE_SYS_SYS_DOMAIN_H */

/* Define to 1 if you have the <sys/termio.h> header file. */
/* #undef HAVE_SYS_TERMIO_H */

/* Define to 1 if you have the <sys/times.h> header file. */
public static final int HAVE_SYS_TIMES_H = 1;

/* Define to 1 if you have the <sys/time.h> header file. */
public static final int HAVE_SYS_TIME_H = 1;

/* Define to 1 if you have the <sys/types.h> header file. */
public static final int HAVE_SYS_TYPES_H = 1;

/* Define to 1 if you have the <sys/uio.h> header file. */
public static final int HAVE_SYS_UIO_H = 1;

/* Define to 1 if you have the <sys/un.h> header file. */
public static final int HAVE_SYS_UN_H = 1;

/* Define to 1 if you have the <sys/utsname.h> header file. */
public static final int HAVE_SYS_UTSNAME_H = 1;

/* Define to 1 if you have the <sys/wait.h> header file. */
public static final int HAVE_SYS_WAIT_H = 1;

/* Define to 1 if you have the <sys/xattr.h> header file. */
public static final int HAVE_SYS_XATTR_H = 1;

/* Define to 1 if you have the `tcgetpgrp' function. */
public static final int HAVE_TCGETPGRP = 1;

/* Define to 1 if you have the `tcsetpgrp' function. */
public static final int HAVE_TCSETPGRP = 1;

/* Define to 1 if you have the `tempnam' function. */
public static final int HAVE_TEMPNAM = 1;

/* Define to 1 if you have the <termios.h> header file. */
public static final int HAVE_TERMIOS_H = 1;

/* Define to 1 if you have the <term.h> header file. */
public static final int HAVE_TERM_H = 1;

/* Define to 1 if you have the `tgamma' function. */
public static final int HAVE_TGAMMA = 1;

/* Define to 1 if you have the `timegm' function. */
public static final int HAVE_TIMEGM = 1;

/* Define to 1 if you have the `times' function. */
public static final int HAVE_TIMES = 1;

/* Define to 1 if you have the `tmpfile' function. */
public static final int HAVE_TMPFILE = 1;

/* Define to 1 if you have the `tmpnam' function. */
public static final int HAVE_TMPNAM = 1;

/* Define to 1 if you have the `tmpnam_r' function. */
public static final int HAVE_TMPNAM_R = 1;

/* Define to 1 if your `struct tm' has `tm_zone'. Deprecated, use
   `HAVE_STRUCT_TM_TM_ZONE' instead. */
public static final int HAVE_TM_ZONE = 1;

/* Define to 1 if you have the `truncate' function. */
public static final int HAVE_TRUNCATE = 1;

/* Define to 1 if you don't have `tm_zone' but do have the external array
   `tzname'. */
/* #undef HAVE_TZNAME */

/* Define this if you have tcl and TCL_UTF_MAX==6 */
/* #undef HAVE_UCS4_TCL */

/* Define to 1 if you have the `uname' function. */
public static final int HAVE_UNAME = 1;

/* Define to 1 if you have the <unistd.h> header file. */
public static final int HAVE_UNISTD_H = 1;

/* Define to 1 if you have the `unlinkat' function. */
public static final int HAVE_UNLINKAT = 1;

/* Define if you have a useable wchar_t type defined in wchar.h; useable means
   wchar_t must be an unsigned type with at least 16 bits. (see
   Include/unicodeobject.h). */
/* #undef HAVE_USABLE_WCHAR_T */

/* Define to 1 if you have the <util.h> header file. */
/* #undef HAVE_UTIL_H */

/* Define to 1 if you have the `utimensat' function. */
public static final int HAVE_UTIMENSAT = 1;

/* Define to 1 if you have the `utimes' function. */
public static final int HAVE_UTIMES = 1;

/* Define to 1 if you have the <utime.h> header file. */
public static final int HAVE_UTIME_H = 1;

/* Define if uuid_create() exists. */
/* #undef HAVE_UUID_CREATE */

/* Define if uuid_enc_be() exists. */
/* #undef HAVE_UUID_ENC_BE */

/* Define if uuid_generate_time_safe() exists. */
public static final int HAVE_UUID_GENERATE_TIME_SAFE = 1;

/* Define to 1 if you have the <uuid.h> header file. */
/* #undef HAVE_UUID_H */

/* Define to 1 if you have the <uuid/uuid.h> header file. */
public static final int HAVE_UUID_UUID_H = 1;

/* Define to 1 if you have the `vfork' function. */
public static final int HAVE_VFORK = 1;

/* Define to 1 if you have the `wait3' function. */
public static final int HAVE_WAIT3 = 1;

/* Define to 1 if you have the `wait4' function. */
public static final int HAVE_WAIT4 = 1;

/* Define to 1 if you have the `waitid' function. */
public static final int HAVE_WAITID = 1;

/* Define to 1 if you have the `waitpid' function. */
public static final int HAVE_WAITPID = 1;

/* Define if the compiler provides a wchar.h header file. */
public static final int HAVE_WCHAR_H = 1;

/* Define to 1 if you have the `wcscoll' function. */
public static final int HAVE_WCSCOLL = 1;

/* Define to 1 if you have the `wcsftime' function. */
public static final int HAVE_WCSFTIME = 1;

/* Define to 1 if you have the `wcsxfrm' function. */
public static final int HAVE_WCSXFRM = 1;

/* Define to 1 if you have the `wmemcmp' function. */
public static final int HAVE_WMEMCMP = 1;

/* Define if tzset() actually switches the local timezone in a meaningful way.
   */
public static final int HAVE_WORKING_TZSET = 1;

/* Define to 1 if you have the `writev' function. */
public static final int HAVE_WRITEV = 1;

/* Define if the zlib library has inflateCopy */
public static final int HAVE_ZLIB_COPY = 1;

/* Define to 1 if you have the `_getpty' function. */
/* #undef HAVE__GETPTY */

/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
   */
/* #undef MAJOR_IN_MKDEV */

/* Define to 1 if `major', `minor', and `makedev' are declared in
   <sysmacros.h>. */
public static final int MAJOR_IN_SYSMACROS = 1;

/* Define if mvwdelch in curses.h is an expression. */
public static final int MVWDELCH_IS_EXPRESSION = 1;

/* Define to the address where bug reports for this package should be sent. */
/* #undef PACKAGE_BUGREPORT */

/* Define to the full name of this package. */
/* #undef PACKAGE_NAME */

/* Define to the full name and version of this package. */
/* #undef PACKAGE_STRING */

/* Define to the one symbol short name of this package. */
/* #undef PACKAGE_TARNAME */

/* Define to the home page for this package. */
/* #undef PACKAGE_URL */

/* Define to the version of this package. */
/* #undef PACKAGE_VERSION */

/* Define if POSIX semaphores aren't enabled on your system */
/* #undef POSIX_SEMAPHORES_NOT_ENABLED */

/* Define if pthread_key_t is compatible with int. */
public static final int PTHREAD_KEY_T_IS_COMPATIBLE_WITH_INT = 1;

/* Defined if PTHREAD_SCOPE_SYSTEM supported. */
public static final int PTHREAD_SYSTEM_SCHED_SUPPORTED = 1;

/* Define as the preferred size in bits of long digits */
/* #undef PYLONG_BITS_IN_DIGIT */

/* enabled builtin hash modules */
public static final String PY_BUILTIN_HASHLIB_HASHES = "md5,sha1,sha256,sha512,sha3,blake2";

/* Define if you want to coerce the C locale to a UTF-8 based locale */
public static final int PY_COERCE_C_LOCALE = 1;

/* Define to printf format modifier for Py_ssize_t */
// #define PY_FORMAT_SIZE_T "z"

/* Default cipher suites list for ssl module. 1: Python's preferred selection,
   2: leave OpenSSL defaults untouched, 0: custom string */
public static final int PY_SSL_DEFAULT_CIPHERS = 1;

/* Cipher suite string for PY_SSL_DEFAULT_CIPHERS=0 */
/* #undef PY_SSL_DEFAULT_CIPHER_STRING */

/* Define if you want to build an interpreter with many run-time checks. */
/* #undef Py_DEBUG */

/* Defined if Python is built as a shared library. */
public static final int Py_ENABLE_SHARED = 1;

/* Define hash algorithm for str, bytes and memoryview. SipHash24: 1, FNV: 2,
   externally defined: 0 */
/* #undef Py_HASH_ALGORITHM */

/* Define if you want to enable tracing references for debugging purpose */
/* #undef Py_TRACE_REFS */

/* assume C89 semantics that RETSIGTYPE is always void */
// #define RETSIGTYPE void

/* Define if setpgrp() must be called as setpgrp(0, 0). */
/* #undef SETPGRP_HAVE_ARG */

/* Define to 1 if you must link with -lrt for shm_open(). */
public static final int SHM_NEEDS_LIBRT = 1;

/* Define if i>>j for signed int i does not extend the sign bit when i < 0 */
/* #undef SIGNED_RIGHT_SHIFT_ZERO_FILLS */

/* The size of `double', as computed by sizeof. */
public static final int SIZEOF_DOUBLE = 8;

/* The size of `float', as computed by sizeof. */
public static final int SIZEOF_FLOAT = 4;

/* The size of `fpos_t', as computed by sizeof. */
public static final int SIZEOF_FPOS_T = 16;

/* The size of `int', as computed by sizeof. */
public static final int SIZEOF_INT = 4;

/* The size of `long', as computed by sizeof. */
public static final int SIZEOF_LONG = 8;

/* The size of `long double', as computed by sizeof. */
public static final int SIZEOF_LONG_DOUBLE = 16;

/* The size of `long long', as computed by sizeof. */
public static final int SIZEOF_LONG_LONG = 8;

/* The size of `off_t', as computed by sizeof. */
public static final int SIZEOF_OFF_T = 8;

/* The size of `pid_t', as computed by sizeof. */
public static final int SIZEOF_PID_T = 4;

/* The size of `pthread_key_t', as computed by sizeof. */
public static final int SIZEOF_PTHREAD_KEY_T = 4;

/* The size of `pthread_t', as computed by sizeof. */
public static final int SIZEOF_PTHREAD_T = 8;

/* The size of `short', as computed by sizeof. */
public static final int SIZEOF_SHORT = 2;

/* The size of `size_t', as computed by sizeof. */
public static final int SIZEOF_SIZE_T = 8;

/* The size of `time_t', as computed by sizeof. */
public static final int SIZEOF_TIME_T = 8;

/* The size of `uintptr_t', as computed by sizeof. */
public static final int SIZEOF_UINTPTR_T = 8;

/* The size of `void *', as computed by sizeof. */
public static final int SIZEOF_VOID_P = 8;

/* The size of `wchar_t', as computed by sizeof. */
public static final int SIZEOF_WCHAR_T = 4;

/* The size of `_Bool', as computed by sizeof. */
public static final int SIZEOF__BOOL = 1;

/* Define to 1 if you have the ANSI C header files. */
public static final int STDC_HEADERS = 1;

/* Define if you can safely include both <sys/select.h> and <sys/time.h>
   (which you can't on SCO ODT 3.0). */
public static final int SYS_SELECT_WITH_SYS_TIME = 1;

/* Custom thread stack size depending on chosen sanitizer runtimes. */
/* #undef THREAD_STACK_SIZE */

/* Library needed by timemodule.c: librt may be needed for clock_gettime() */
/* #undef TIMEMODULE_LIB */

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
public static final int TIME_WITH_SYS_TIME = 1;

/* Define to 1 if your <sys/time.h> declares `struct tm'. */
/* #undef TM_IN_SYS_TIME */

/* Define if you want to use computed gotos in ceval.c. */
/* #undef USE_COMPUTED_GOTOS */

/* Enable extensions on AIX 3, Interix.  */
// #ifndef _ALL_SOURCE
public static final int _ALL_SOURCE = 1;
// #endif
/* Enable GNU extensions on systems that have them.  */
// #ifndef _GNU_SOURCE
public static final int _GNU_SOURCE = 1;
// #endif
/* Enable threading extensions on Solaris.  */
// #ifndef _POSIX_PTHREAD_SEMANTICS
public static final int _POSIX_PTHREAD_SEMANTICS = 1;
// #endif
/* Enable extensions on HP NonStop.  */
// #ifndef _TANDEM_SOURCE
public static final int _TANDEM_SOURCE = 1;
// #endif
/* Enable general extensions on Solaris.  */
// #ifndef __EXTENSIONS__
public static final int __EXTENSIONS__ = 1;
// #endif


/* Define if WINDOW in curses.h offers a field _flags. */
public static final int WINDOW_HAS_FLAGS = 1;

/* Define if you want build the _decimal module using a coroutine-local rather
   than a thread-local context */
public static final int WITH_DECIMAL_CONTEXTVAR = 1;

/* Define if you want documentation strings in extension modules */
public static final int WITH_DOC_STRINGS = 1;

/* Define if you want to compile in DTrace support */
/* #undef WITH_DTRACE */

/* Define if you want to use the new-style (Openstep, Rhapsody, MacOS) dynamic
   linker (dyld) instead of the old-style (NextStep) dynamic linker (rld).
   Dyld is necessary to support frameworks. */
/* #undef WITH_DYLD */

/* Define to build the readline module against Editline. */
/* #undef WITH_EDITLINE */

/* Define to 1 if libintl is needed for locale functions. */
/* #undef WITH_LIBINTL */

/* Define if you want to produce an OpenStep/Rhapsody framework (shared
   library plus accessory files). */
/* #undef WITH_NEXT_FRAMEWORK */

/* Define if you want to compile in Python-specific mallocs */
public static final int WITH_PYMALLOC = 1;

/* Define if you want pymalloc to be disabled when running under valgrind */
/* #undef WITH_VALGRIND */

/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
   significant byte first (like Motorola and SPARC, unlike Intel). */
// #if defined AC_APPLE_UNIVERSAL_BUILD
// # if defined __BIG_ENDIAN__
public static final int WORDS_BIGENDIAN = 1;
// # endif
// #else
// # ifndef WORDS_BIGENDIAN
// # endif
// #endif

/* Define if arithmetic is subject to x87-style double rounding issue */
/* #undef X87_DOUBLE_ROUNDING */

/* Define on OpenBSD to activate all library features */
/* #undef _BSD_SOURCE */

/* Define on Darwin to activate all library features */
public static final int _DARWIN_C_SOURCE = 1;

/* This must be set to 64 on some systems to enable large file support. */
public static final int _FILE_OFFSET_BITS = 64;

/* Define on Linux to activate all library features */

/* Define to include mbstate_t for mbrtowc */
/* #undef _INCLUDE__STDC_A1_SOURCE */

/* This must be defined on some systems to enable large file support. */
public static final int _LARGEFILE_SOURCE = 1;

/* This must be defined on AIX systems to enable large file support. */
/* #undef _LARGE_FILES */

/* Define to 1 if on MINIX. */
/* #undef _MINIX */

/* Define on NetBSD to activate all library features */
public static final int _NETBSD_SOURCE = 1;

/* Define to 2 if the system does not provide POSIX.1 features except with
   this defined. */
/* #undef _POSIX_1_SOURCE */

/* Define to activate features from IEEE Stds 1003.1-2008 */
public static final long _POSIX_C_SOURCE = 200809L;

/* Define to 1 if you need to in order for `stat' and other things to work. */
/* #undef _POSIX_SOURCE */

/* Define if you have POSIX threads, and your system does not define that. */
/* #undef _POSIX_THREADS */

/* framework name */
public static final String _PYTHONFRAMEWORK = "";

/* Define to force use of thread-safe errno, h_errno, and other functions */
/* #undef _REENTRANT */

/* Define to the level of X/Open that your system supports */
public static final int _XOPEN_SOURCE = 700;

/* Define to activate Unix95-and-earlier features */
public static final int _XOPEN_SOURCE_EXTENDED = 1;

/* Define on FreeBSD to activate all library features */
public static final int __BSD_VISIBLE = 1;

/* Define to 1 if type `char' is unsigned and you are not using gcc.  */
// #ifndef __CHAR_UNSIGNED__
/* # undef __CHAR_UNSIGNED__ */
// #endif

/* Define to 'long' if <time.h> doesn't define. */
/* #undef clock_t */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef gid_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef mode_t */

/* Define to `long int' if <sys/types.h> does not define. */
/* #undef off_t */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef pid_t */

/* Define to empty if the keyword does not work. */
/* #undef signed */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define to `int' if <sys/socket.h> does not define. */
/* #undef socklen_t */

/* Define to `int' if <sys/types.h> doesn't define. */
/* #undef uid_t */


/* Define the macros needed if on a UnixWare 7.x system. */
// #if defined(__USLC__) && defined(__SCO_VERSION__)
// #define STRICT_SYSV_CURSES /* Don't use ncurses extensions */
// #endif

// #endif /*Py_PYCONFIG_H*/



// Parsed from pymacconfig.h

// #ifndef PYMACCONFIG_H
// #define PYMACCONFIG_H
     /*
      * This file moves some of the autoconf magic to compile-time
      * when building on MacOSX. This is needed for building 4-way
      * universal binaries and for 64-bit universal binaries because
      * the values redefined below aren't configure-time constant but
      * only compile-time constant in these scenarios.
      */

// #if defined(__APPLE__)

// # undef SIZEOF_LONG
// # undef SIZEOF_PTHREAD_T
// # undef SIZEOF_SIZE_T
// # undef SIZEOF_TIME_T
// # undef SIZEOF_VOID_P
// # undef SIZEOF__BOOL
// # undef SIZEOF_UINTPTR_T
// # undef SIZEOF_PTHREAD_T
// # undef WORDS_BIGENDIAN
// # undef DOUBLE_IS_ARM_MIXED_ENDIAN_IEEE754
// # undef DOUBLE_IS_BIG_ENDIAN_IEEE754
// # undef DOUBLE_IS_LITTLE_ENDIAN_IEEE754
// # undef HAVE_GCC_ASM_FOR_X87

// #    undef VA_LIST_IS_ARRAY
// #    if defined(__LP64__) && defined(__x86_64__)
public static final int VA_LIST_IS_ARRAY = 1;
// #    endif

// #    undef HAVE_LARGEFILE_SUPPORT
// #    ifndef __LP64__
public static final int HAVE_LARGEFILE_SUPPORT = 1;
// #    endif

// #    undef SIZEOF_LONG
// #    ifdef __LP64__
// #    else
// #        ifdef __ppc__
// #        else
// #        endif
// #    endif

// #    if defined(__LP64__)
     /* MacOSX 10.4 (the first release to support 64-bit code
      * at all) only supports 64-bit in the UNIX layer.
      * Therefore suppress the toolbox-glue in 64-bit mode.
      */

    /* In 64-bit mode setpgrp always has no arguments, in 32-bit
     * mode that depends on the compilation environment
     */
// #       undef SETPGRP_HAVE_ARG

// #    endif

// #ifdef __BIG_ENDIAN__
// #define DOUBLE_IS_BIG_ENDIAN_IEEE754
// #else
// #define DOUBLE_IS_LITTLE_ENDIAN_IEEE754
// #endif /* __BIG_ENDIAN */

// #ifdef __i386__
// # define HAVE_GCC_ASM_FOR_X87
// #endif

    /*
     * The definition in pyconfig.h is only valid on the OS release
     * where configure ran on and not necessarily for all systems where
     * the executable can be used on.
     *
     * Specifically: OSX 10.4 has limited supported for '%zd', while
     * 10.5 has full support for '%zd'. A binary built on 10.5 won't
     * work properly on 10.4 unless we suppress the definition
     * of PY_FORMAT_SIZE_T
     */
// #undef  PY_FORMAT_SIZE_T


// #endif /* defined(_APPLE__) */

// #endif /* PYMACCONFIG_H */


// Parsed from pyport.h

// #ifndef Py_PYPORT_H
// #define Py_PYPORT_H

// #include "pyconfig.h" /* include for defines */

// #include <inttypes.h>


/* Defines to build Python and its standard library:
 *
 * - Py_BUILD_CORE: Build Python core. Give access to Python internals, but
 *   should not be used by third-party modules.
 * - Py_BUILD_CORE_BUILTIN: Build a Python stdlib module as a built-in module.
 * - Py_BUILD_CORE_MODULE: Build a Python stdlib module as a dynamic library.
 *
 * Py_BUILD_CORE_BUILTIN and Py_BUILD_CORE_MODULE imply Py_BUILD_CORE.
 *
 * On Windows, Py_BUILD_CORE_MODULE exports "PyInit_xxx" symbol, whereas
 * Py_BUILD_CORE_BUILTIN does not.
 */
// #if defined(Py_BUILD_CORE_BUILTIN) && !defined(Py_BUILD_CORE)
// #  define Py_BUILD_CORE
// #endif
// #if defined(Py_BUILD_CORE_MODULE) && !defined(Py_BUILD_CORE)
// #  define Py_BUILD_CORE
// #endif


/**************************************************************************
Symbols and macros to supply platform-independent interfaces to basic
C language & library operations whose spellings vary across platforms.
<p>
Please try to make documentation here as clear as possible:  by definition,
the stuff here is trying to illuminate C's darkest corners.
<p>
Config #defines referenced here:
<p>
SIGNED_RIGHT_SHIFT_ZERO_FILLS
Meaning:  To be defined iff i>>j does not extend the sign bit when i is a
          signed integral type and i < 0.
Used in:  Py_ARITHMETIC_RIGHT_SHIFT
<p>
Py_DEBUG
Meaning:  Extra checks compiled in for debug mode.
Used in:  Py_SAFE_DOWNCAST
<p>
**************************************************************************/

/* typedefs for some C9X-defined synonyms for integral types.
 *
 * The names in Python are exactly the same as the C9X names, except with a
 * Py_ prefix.  Until C9X is universally implemented, this is the only way
 * to ensure that Python gets reliable names that don't conflict with names
 * in non-Python code that are playing their own tricks to define the C9X
 * names.
 *
 * NOTE: don't go nuts here!  Python has no use for *most* of the C9X
 * integral synonyms.  Only define the ones we actually need.
 */

/* long long is required. Ensure HAVE_LONG_LONG is defined for compatibility. */
// #ifndef HAVE_LONG_LONG
public static final int HAVE_LONG_LONG = 1;
// #endif
// #ifndef PY_LONG_LONG
// #define PY_LONG_LONG long long
/* If LLONG_MAX is defined in limits.h, use that. */
public static native @MemberGetter long PY_LLONG_MIN();
public static final long PY_LLONG_MIN = PY_LLONG_MIN();
public static native @MemberGetter long PY_LLONG_MAX();
public static final long PY_LLONG_MAX = PY_LLONG_MAX();
public static native @MemberGetter long PY_ULLONG_MAX();
public static final long PY_ULLONG_MAX = PY_ULLONG_MAX();
// #endif

// #define PY_UINT32_T uint32_t
// #define PY_UINT64_T uint64_t

/* Signed variants of the above */
// #define PY_INT32_T int32_t
// #define PY_INT64_T int64_t

/* If PYLONG_BITS_IN_DIGIT is not defined then we'll use 30-bit digits if all
   the necessary integer types are available, and we're on a 64-bit platform
   (as determined by SIZEOF_VOID_P); otherwise we use 15-bit digits. */

// #ifndef PYLONG_BITS_IN_DIGIT
// #if SIZEOF_VOID_P >= 8
public static final int PYLONG_BITS_IN_DIGIT = 30;
// #else
// #endif
// #endif

/* uintptr_t is the C9X name for an unsigned integral type such that a
 * legitimate void* can be cast to uintptr_t and then back to void* again
 * without loss of information.  Similarly for intptr_t, wrt a signed
 * integral type.
 */

/* Py_ssize_t is a signed integral type such that sizeof(Py_ssize_t) ==
 * sizeof(size_t).  C99 doesn't define such a thing directly (size_t is an
 * unsigned integral type).  See PEP 353 for details.
 */
// #ifdef HAVE_PY_SSIZE_T

// #elif HAVE_SSIZE_T
// #elif SIZEOF_VOID_P == SIZEOF_SIZE_T
// #else
// #   error "Python needs a typedef for Py_ssize_t in pyport.h."
// #endif

/* Py_hash_t is the same size as a pointer. */
public static native @MemberGetter long SIZEOF_PY_HASH_T();
public static final long SIZEOF_PY_HASH_T = SIZEOF_PY_HASH_T();
/* Py_uhash_t is the unsigned equivalent needed to calculate numeric hash. */
public static native @MemberGetter long SIZEOF_PY_UHASH_T();
public static final long SIZEOF_PY_UHASH_T = SIZEOF_PY_UHASH_T();

/* Only used for compatibility with code that may not be PY_SSIZE_T_CLEAN. */
// #ifdef PY_SSIZE_T_CLEAN
// #else
// #endif

/* Largest possible value of size_t. */
// #define PY_SIZE_MAX SIZE_MAX

/* Largest positive value of type Py_ssize_t. */
public static native @MemberGetter long PY_SSIZE_T_MAX();
public static final long PY_SSIZE_T_MAX = PY_SSIZE_T_MAX();
/* Smallest negative value of type Py_ssize_t. */
public static native @MemberGetter long PY_SSIZE_T_MIN();
public static final long PY_SSIZE_T_MIN = PY_SSIZE_T_MIN();

/* Macro kept for backward compatibility: use "z" in new code.
 *
 * PY_FORMAT_SIZE_T is a platform-specific modifier for use in a printf
 * format to convert an argument with the width of a size_t or Py_ssize_t.
 * C99 introduced "z" for this purpose, but old MSVCs had not supported it.
 * Since MSVC supports "z" since (at least) 2015, we can just use "z"
 * for new code.
 *
 * These "high level" Python format functions interpret "z" correctly on
 * all platforms (Python interprets the format string itself, and does whatever
 * the platform C requires to convert a size_t/Py_ssize_t argument):
 *
 *     PyBytes_FromFormat
 *     PyErr_Format
 *     PyBytes_FromFormatV
 *     PyUnicode_FromFormatV
 *
 * Lower-level uses require that you interpolate the correct format modifier
 * yourself (e.g., calling printf, fprintf, sprintf, PyOS_snprintf); for
 * example,
 *
 *     Py_ssize_t index;
 *     fprintf(stderr, "index %" PY_FORMAT_SIZE_T "d sucks\n", index);
 *
 * That will expand to %zd or to something else correct for a Py_ssize_t on
 * the platform.
 */
// #ifndef PY_FORMAT_SIZE_T
// #   define PY_FORMAT_SIZE_T "z"
// #endif

/* Py_LOCAL can be used instead of static to get the fastest possible calling
 * convention for functions that are local to a given module.
 *
 * Py_LOCAL_INLINE does the same thing, and also explicitly requests inlining,
 * for platforms that support that.
 *
 * If PY_LOCAL_AGGRESSIVE is defined before python.h is included, more
 * "aggressive" inlining/optimization is enabled for the entire module.  This
 * may lead to code bloat, and may slow things down for those reasons.  It may
 * also lead to errors, if the code relies on pointer aliasing.  Use with
 * care.
 *
 * NOTE: You can only use this for functions that are entirely local to a
 * module; functions that are exported via method tables, callbacks, etc,
 * should keep using static.
 */

// #if defined(_MSC_VER)
// #  if defined(PY_LOCAL_AGGRESSIVE)
   /* enable more aggressive optimization for MSVC */
   /* active in both release and debug builds - see bpo-43271 */
// #  pragma optimize("gt", on)
// #endif
   /* ignore warnings if the compiler decides not to inline a function */
// #  pragma warning(disable: 4710)
   /* fastest possible local call under MSVC */
// #  define Py_LOCAL(type) static type __fastcall
// #  define Py_LOCAL_INLINE(type) static __inline type __fastcall
// #else
// #  define Py_LOCAL(type) static type
// #  define Py_LOCAL_INLINE(type) static inline type
// #endif

/* Py_MEMCPY is kept for backwards compatibility,
 * see https://bugs.python.org/issue28126 */
// #define Py_MEMCPY memcpy

// #include <stdlib.h>

// #ifdef HAVE_IEEEFP_H
// #include <ieeefp.h>  /* needed for 'finite' declaration on some platforms */
// #endif

// #include <math.h> /* Moved here from the math section, before extern "C" */

/********************************************
 * WRAPPER FOR <time.h> and/or <sys/time.h> *
 ********************************************/

// #ifdef TIME_WITH_SYS_TIME
// #include <sys/time.h>
// #include <time.h>
// #else /* !TIME_WITH_SYS_TIME */
// #endif /* !TIME_WITH_SYS_TIME */


/******************************
 * WRAPPER FOR <sys/select.h> *
 ******************************/

/* NB caller must include <sys/types.h> */

// #ifdef HAVE_SYS_SELECT_H
// #include <sys/select.h>
// #endif /* !HAVE_SYS_SELECT_H */

/*******************************
 * stat() and fstat() fiddling *
 *******************************/

// #ifdef HAVE_SYS_STAT_H
// #include <sys/stat.h>
// #elif defined(HAVE_STAT_H)
// #endif

// #ifndef S_IFMT
/* VisualAge C/C++ Failed to Define MountType Field in sys/stat.h */
public static final int S_IFMT = 0170000;
// #endif

// #ifndef S_IFLNK
/* Windows doesn't define S_IFLNK but posixmodule.c maps
 * IO_REPARSE_TAG_SYMLINK to S_IFLNK */
public static final int S_IFLNK = 0120000;
// #endif

// #ifndef S_ISREG
// #define S_ISREG(x) (((x) & S_IFMT) == S_IFREG)
// #endif

// #ifndef S_ISDIR
// #define S_ISDIR(x) (((x) & S_IFMT) == S_IFDIR)
// #endif

// #ifndef S_ISCHR
// #define S_ISCHR(x) (((x) & S_IFMT) == S_IFCHR)
// #endif

// #ifdef __cplusplus
/* Move this down here since some C++ #include's don't like to be included
   inside an extern "C" */
// #endif


/* Py_ARITHMETIC_RIGHT_SHIFT
 * C doesn't define whether a right-shift of a signed integer sign-extends
 * or zero-fills.  Here a macro to force sign extension:
 * Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J)
 *    Return I >> J, forcing sign extension.  Arithmetically, return the
 *    floor of I/2**J.
 * Requirements:
 *    I should have signed integer type.  In the terminology of C99, this can
 *    be either one of the five standard signed integer types (signed char,
 *    short, int, long, long long) or an extended signed integer type.
 *    J is an integer >= 0 and strictly less than the number of bits in the
 *    type of I (because C doesn't define what happens for J outside that
 *    range either).
 *    TYPE used to specify the type of I, but is now ignored.  It's been left
 *    in for backwards compatibility with versions <= 2.6 or 3.0.
 * Caution:
 *    I may be evaluated more than once.
 */
// #ifdef SIGNED_RIGHT_SHIFT_ZERO_FILLS
// #define Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J)
//     ((I) < 0 ? -1-((-1-(I)) >> (J)) : (I) >> (J))
// #else
// #define Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J) ((I) >> (J))
// #endif

/* Py_FORCE_EXPANSION(X)
 * "Simply" returns its argument.  However, macro expansions within the
 * argument are evaluated.  This unfortunate trickery is needed to get
 * token-pasting to work as desired in some cases.
 */
// #define Py_FORCE_EXPANSION(X) X

/* Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW)
 * Cast VALUE to type NARROW from type WIDE.  In Py_DEBUG mode, this
 * assert-fails if any information is lost.
 * Caution:
 *    VALUE may be evaluated more than once.
 */
// #ifdef Py_DEBUG
// #else
// #define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) (NARROW)(VALUE)
// #endif

/* Py_SET_ERRNO_ON_MATH_ERROR(x)
 * If a libm function did not set errno, but it looks like the result
 * overflowed or not-a-number, set errno to ERANGE or EDOM.  Set errno
 * to 0 before calling a libm function, and invoke this macro after,
 * passing the function result.
 * Caution:
 *    This isn't reliable.  See Py_OVERFLOWED comments.
 *    X is evaluated more than once.
 */
// #if defined(__FreeBSD__) || defined(__OpenBSD__) || (defined(__hpux) && defined(__ia64))
// #define _Py_SET_EDOM_FOR_NAN(X) if (isnan(X)) errno = EDOM;
// #else
// #define _Py_SET_EDOM_FOR_NAN(X) ;
// #endif
// #define Py_SET_ERRNO_ON_MATH_ERROR(X)
//     do {
//         if (errno == 0) {
//             if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL)
//                 errno = ERANGE;
//             else _Py_SET_EDOM_FOR_NAN(X)
//         }
//     } while(0)

/* Py_SET_ERANGE_IF_OVERFLOW(x)
 * An alias of Py_SET_ERRNO_ON_MATH_ERROR for backward-compatibility.
 */
// #define Py_SET_ERANGE_IF_OVERFLOW(X) Py_SET_ERRNO_ON_MATH_ERROR(X)

/* Py_ADJUST_ERANGE1(x)
 * Py_ADJUST_ERANGE2(x, y)
 * Set errno to 0 before calling a libm function, and invoke one of these
 * macros after, passing the function result(s) (Py_ADJUST_ERANGE2 is useful
 * for functions returning complex results).  This makes two kinds of
 * adjustments to errno:  (A) If it looks like the platform libm set
 * errno=ERANGE due to underflow, clear errno. (B) If it looks like the
 * platform libm overflowed but didn't set errno, force errno to ERANGE.  In
 * effect, we're trying to force a useful implementation of C89 errno
 * behavior.
 * Caution:
 *    This isn't reliable.  See Py_OVERFLOWED comments.
 *    X and Y may be evaluated more than once.
 */
// #define Py_ADJUST_ERANGE1(X)
//     do {
//         if (errno == 0) {
//             if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL)
//                 errno = ERANGE;
//         }
//         else if (errno == ERANGE && (X) == 0.0)
//             errno = 0;
//     } while(0)

// #define Py_ADJUST_ERANGE2(X, Y)
//     do {
//         if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL ||
//             (Y) == Py_HUGE_VAL || (Y) == -Py_HUGE_VAL) {
//                         if (errno == 0)
//                                 errno = ERANGE;
//         }
//         else if (errno == ERANGE)
//             errno = 0;
//     } while(0)

/*  The functions _Py_dg_strtod and _Py_dg_dtoa in Python/dtoa.c (which are
 *  required to support the short float repr introduced in Python 3.1) require
 *  that the floating-point unit that's being used for arithmetic operations
 *  on C doubles is set to use 53-bit precision.  It also requires that the
 *  FPU rounding mode is round-half-to-even, but that's less often an issue.
 *
 *  If your FPU isn't already set to 53-bit precision/round-half-to-even, and
 *  you want to make use of _Py_dg_strtod and _Py_dg_dtoa, then you should
 *
 *     #define HAVE_PY_SET_53BIT_PRECISION 1
 *
 *  and also give appropriate definitions for the following three macros:
 *
 *    _PY_SET_53BIT_PRECISION_START : store original FPU settings, and
 *        set FPU to 53-bit precision/round-half-to-even
 *    _PY_SET_53BIT_PRECISION_END : restore original FPU settings
 *    _PY_SET_53BIT_PRECISION_HEADER : any variable declarations needed to
 *        use the two macros above.
 *
 * The macros are designed to be used within a single C function: see
 * Python/pystrtod.c for an example of their use.
 */

/* get and set x87 control word for gcc/x86 */
// #ifdef HAVE_GCC_ASM_FOR_X87
// #endif

/* get and set x87 control word for VisualStudio/x86 */
// #if defined(_MSC_VER) && !defined(_WIN64) && !defined(_M_ARM) /* x87 not supported in 64-bit or ARM */
public static final int HAVE_PY_SET_53BIT_PRECISION = 1;
// #define _Py_SET_53BIT_PRECISION_HEADER
//     unsigned int old_387controlword, new_387controlword, out_387controlword
/* We use the __control87_2 function to set only the x87 control word.
   The SSE control word is unaffected. */
// #define _Py_SET_53BIT_PRECISION_START
//     do {
//         __control87_2(0, 0, &old_387controlword, NULL);
//         new_387controlword =
//           (old_387controlword & ~(_MCW_PC | _MCW_RC)) | (_PC_53 | _RC_NEAR);
//         if (new_387controlword != old_387controlword)
//             __control87_2(new_387controlword, _MCW_PC | _MCW_RC,
//                           &out_387controlword, NULL);
//     } while (0)
// #define _Py_SET_53BIT_PRECISION_END
//     do {
//         if (new_387controlword != old_387controlword)
//             __control87_2(old_387controlword, _MCW_PC | _MCW_RC,
//                           &out_387controlword, NULL);
//     } while (0)
// #endif

// #ifdef HAVE_GCC_ASM_FOR_MC68881
// #endif

/* default definitions are empty */
// #ifndef HAVE_PY_SET_53BIT_PRECISION
// #endif

/* If we can't guarantee 53-bit precision, don't use the code
   in Python/dtoa.c, but fall back to standard code.  This
   means that repr of a float will be long (17 sig digits).

   Realistically, there are two things that could go wrong:

   (1) doubles aren't IEEE 754 doubles, or
   (2) we're on x86 with the rounding precision set to 64-bits
       (extended precision), and we don't know how to change
       the rounding precision.
 */

// #if !defined(DOUBLE_IS_LITTLE_ENDIAN_IEEE754) &&
//     !defined(DOUBLE_IS_BIG_ENDIAN_IEEE754) &&
//     !defined(DOUBLE_IS_ARM_MIXED_ENDIAN_IEEE754)
// #define PY_NO_SHORT_FLOAT_REPR
// #endif

/* double rounding is symptomatic of use of extended precision on x86.  If
   we're seeing double rounding, and we don't have any mechanism available for
   changing the FPU rounding precision, then don't use Python/dtoa.c. */
// #if defined(X87_DOUBLE_ROUNDING) && !defined(HAVE_PY_SET_53BIT_PRECISION)
// #define PY_NO_SHORT_FLOAT_REPR
// #endif


/* Py_DEPRECATED(version)
 * Declare a variable, type, or function deprecated.
 * The macro must be placed before the declaration.
 * Usage:
 *    Py_DEPRECATED(3.3) extern int old_var;
 *    Py_DEPRECATED(3.4) typedef int T1;
 *    Py_DEPRECATED(3.8) PyAPI_FUNC(int) Py_OldFunction(void);
 */
// #if defined(__GNUC__)
//     && ((__GNUC__ >= 4) || (__GNUC__ == 3) && (__GNUC_MINOR__ >= 1))
// #define Py_DEPRECATED(VERSION_UNUSED) __attribute__((__deprecated__))
// #elif defined(_MSC_VER)
// #define Py_DEPRECATED(VERSION) __declspec(deprecated(
//                                           "deprecated in " #VERSION))
// #else
// #define Py_DEPRECATED(VERSION_UNUSED)
// #endif

// #if defined(__clang__)
// #define _Py_COMP_DIAG_PUSH _Pragma("clang diagnostic push")
// #define _Py_COMP_DIAG_IGNORE_DEPR_DECLS
//     _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
// #define _Py_COMP_DIAG_POP _Pragma("clang diagnostic pop")
// #elif defined(__GNUC__)
//     && ((__GNUC__ >= 5) || (__GNUC__ == 4) && (__GNUC_MINOR__ >= 6))
// #define _Py_COMP_DIAG_PUSH _Pragma("GCC diagnostic push")
// #define _Py_COMP_DIAG_IGNORE_DEPR_DECLS
//     _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
// #define _Py_COMP_DIAG_POP _Pragma("GCC diagnostic pop")
// #elif defined(_MSC_VER)
// #define _Py_COMP_DIAG_PUSH __pragma(warning(push))
// #define _Py_COMP_DIAG_IGNORE_DEPR_DECLS __pragma(warning(disable: 4996))
// #define _Py_COMP_DIAG_POP __pragma(warning(pop))
// #else
// #define _Py_COMP_DIAG_PUSH
// #define _Py_COMP_DIAG_IGNORE_DEPR_DECLS
// #define _Py_COMP_DIAG_POP
// #endif

/* _Py_HOT_FUNCTION
 * The hot attribute on a function is used to inform the compiler that the
 * function is a hot spot of the compiled program. The function is optimized
 * more aggressively and on many target it is placed into special subsection of
 * the text section so all hot functions appears close together improving
 * locality.
 *
 * Usage:
 *    int _Py_HOT_FUNCTION x(void) { return 3; }
 *
 * Issue #28618: This attribute must not be abused, otherwise it can have a
 * negative effect on performance. Only the functions were Python spend most of
 * its time must use it. Use a profiler when running performance benchmark
 * suite to find these functions.
 */
// #if defined(__GNUC__)
//     && ((__GNUC__ >= 5) || (__GNUC__ == 4) && (__GNUC_MINOR__ >= 3))
// #define _Py_HOT_FUNCTION __attribute__((hot))
// #else
// #define _Py_HOT_FUNCTION
// #endif

/* _Py_NO_INLINE
 * Disable inlining on a function. For example, it helps to reduce the C stack
 * consumption.
 *
 * Usage:
 *    int _Py_NO_INLINE x(void) { return 3; }
 */
// #if defined(_MSC_VER)
// #  define _Py_NO_INLINE __declspec(noinline)
// #elif defined(__GNUC__) || defined(__clang__)
// #  define _Py_NO_INLINE __attribute__ ((noinline))
// #else
// #  define _Py_NO_INLINE
// #endif

/**************************************************************************
Prototypes that are missing from the standard include files on some systems
(and possibly only some versions of such systems.)
<p>
Please be conservative with adding new ones, document them and enclose them
in platform-specific #ifdefs.
**************************************************************************/

// #ifdef SOLARIS
// #endif

// #ifdef HAVE__GETPTY
// #endif

/* On QNX 6, struct termio must be declared by including sys/termio.h
   if TCGETA, TCSETA, TCSETAW, or TCSETAF are used.  sys/termio.h must
   be included before termios.h or it will generate an error. */
// #if defined(HAVE_SYS_TERMIO_H) && !defined(__hpux)
// #include <sys/termio.h>
// #endif


/* On 4.4BSD-descendants, ctype functions serves the whole range of
 * wchar_t character set rather than single byte code points only.
 * This characteristic can break some operations of string object
 * including str.upper() and str.split() on UTF-8 locales.  This
 * workaround was provided by Tim Robbins of FreeBSD project.
 */

// #if defined(__APPLE__)
// #  define _PY_PORT_CTYPE_UTF8_ISSUE
// #endif

// #ifdef _PY_PORT_CTYPE_UTF8_ISSUE
// #endif


/* Declarations for symbol visibility.

  PyAPI_FUNC(type): Declares a public Python API function and return type
  PyAPI_DATA(type): Declares public Python data and its type
  PyMODINIT_FUNC:   A Python module init function.  If these functions are
                    inside the Python core, they are private to the core.
                    If in an extension module, it may be declared with
                    external linkage depending on the platform.

  As a number of platforms support/require "__declspec(dllimport/dllexport)",
  we support a HAVE_DECLSPEC_DLL macro to save duplication.
*/

/*
  All windows ports, except cygwin, are handled in PC/pyconfig.h.

  Cygwin is the only other autoconf platform requiring special
  linkage handling and it uses __declspec().
*/
// #if defined(__CYGWIN__)
// #       define HAVE_DECLSPEC_DLL
// #endif

// #include "exports.h"

/* only get special linkage if built as shared or platform is Cygwin */
// #if defined(Py_ENABLE_SHARED) || defined(__CYGWIN__)
// #       if defined(HAVE_DECLSPEC_DLL)
// #               if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
// #                       define PyAPI_FUNC(RTYPE) Py_EXPORTED_SYMBOL RTYPE
// #                       define PyAPI_DATA(RTYPE) extern Py_EXPORTED_SYMBOL RTYPE
        /* module init functions inside the core need no external linkage */
        /* except for Cygwin to handle embedding */
// #                       if defined(__CYGWIN__)
// #                               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL PyObject*
// #                       else /* __CYGWIN__ */
// #                               define PyMODINIT_FUNC PyObject*
// #                       endif /* __CYGWIN__ */
// #               else /* Py_BUILD_CORE */
        /* Building an extension module, or an embedded situation */
        /* public Python functions and data are imported */
        /* Under Cygwin, auto-import functions to prevent compilation */
        /* failures similar to those described at the bottom of 4.1: */
        /* http://docs.python.org/extending/windows.html#a-cookbook-approach */
// #                       if !defined(__CYGWIN__)
// #                               define PyAPI_FUNC(RTYPE) Py_IMPORTED_SYMBOL RTYPE
// #                       endif /* !__CYGWIN__ */
// #                       define PyAPI_DATA(RTYPE) extern Py_IMPORTED_SYMBOL RTYPE
        /* module init functions outside the core must be exported */
// #                       if defined(__cplusplus)
// #                               define PyMODINIT_FUNC extern "C" Py_EXPORTED_SYMBOL PyObject*
// #                       else /* __cplusplus */
// #                               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL PyObject*
// #                       endif /* __cplusplus */
// #               endif /* Py_BUILD_CORE */
// #       endif /* HAVE_DECLSPEC_DLL */
// #endif /* Py_ENABLE_SHARED */

/* If no external linkage macros defined by now, create defaults */
// #ifndef PyAPI_FUNC
// #       define PyAPI_FUNC(RTYPE) Py_EXPORTED_SYMBOL RTYPE
// #endif
// #ifndef PyAPI_DATA
// #       define PyAPI_DATA(RTYPE) extern Py_EXPORTED_SYMBOL RTYPE
// #endif
// #ifndef PyMODINIT_FUNC
// #       if defined(__cplusplus)
// #               define PyMODINIT_FUNC extern "C" Py_EXPORTED_SYMBOL PyObject*
// #       else /* __cplusplus */
// #               define PyMODINIT_FUNC Py_EXPORTED_SYMBOL PyObject*
// #       endif /* __cplusplus */
// #endif

/* limits.h constants that may be missing */

// #ifndef INT_MAX
public static final int INT_MAX = 2147483647;
// #endif

// #ifndef LONG_MAX
// #if SIZEOF_LONG == 4
public static final long LONG_MAX = 0X7FFFFFFFL;
// #elif SIZEOF_LONG == 8
// #else
// #error "could not set LONG_MAX in pyport.h"
// #endif
// #endif

// #ifndef LONG_MIN
public static final long LONG_MIN = (-LONG_MAX-1);
// #endif

// #ifndef LONG_BIT
public static native @MemberGetter long LONG_BIT();
public static final long LONG_BIT = LONG_BIT();
// #endif

// #if LONG_BIT != 8 * SIZEOF_LONG
/* 04-Oct-2000 LONG_BIT is apparently (mis)defined as 64 on some recent
 * 32-bit platforms using gcc.  We try to catch that here at compile-time
 * rather than waiting for integer multiplication to trigger bogus
 * overflows.
 */
// #error "LONG_BIT definition appears wrong for platform (bad gcc/glibc config?)."
// #endif

// #ifdef __cplusplus
// #endif

/*
 * Hide GCC attributes from compilers that don't support them.
 */
// #if (!defined(__GNUC__) || __GNUC__ < 2 ||
//      (__GNUC__ == 2 && __GNUC_MINOR__ < 7) )
// #define Py_GCC_ATTRIBUTE(x)
// #else
// #define Py_GCC_ATTRIBUTE(x) __attribute__(x)
// #endif

/*
 * Specify alignment on compilers that support it.
 */
// #if defined(__GNUC__) && __GNUC__ >= 3
// #define Py_ALIGNED(x) __attribute__((aligned(x)))
// #else
// #define Py_ALIGNED(x)
// #endif

/* Eliminate end-of-loop code not reached warnings from SunPro C
 * when using do{...}while(0) macros
 */
// #ifdef __SUNPRO_C
// #pragma error_messages (off,E_END_OF_LOOP_CODE_NOT_REACHED)
// #endif

// #ifndef Py_LL
// #define Py_LL(x) x##LL
// #endif

// #ifndef Py_ULL
// #define Py_ULL(x) Py_LL(x##U)
// #endif

// #define Py_VA_COPY va_copy

/*
 * Convenient macros to deal with endianness of the platform. WORDS_BIGENDIAN is
 * detected by configure and defined in pyconfig.h. The code in pyconfig.h
 * also takes care of Apple's universal builds.
 */

// #ifdef WORDS_BIGENDIAN
public static final int PY_BIG_ENDIAN = 1;
public static final int PY_LITTLE_ENDIAN = 0;
// #else
// #endif

// #ifdef Py_BUILD_CORE
// #endif /* Py_BUILD_CORE */

// #ifdef __ANDROID__
   /* The Android langinfo.h header is not used. */
// #  undef HAVE_LANGINFO_H
// #  undef CODESET
// #endif

/* Maximum value of the Windows DWORD type */
public static final long PY_DWORD_MAX = 4294967295L;

/* This macro used to tell whether Python was built with multithreading
 * enabled.  Now multithreading is always enabled, but keep the macro
 * for compatibility.
 */
// #ifndef WITH_THREAD
// #endif

/* Check that ALT_SOABI is consistent with Py_TRACE_REFS:
   ./configure --with-trace-refs should must be used to define Py_TRACE_REFS */
// #if defined(ALT_SOABI) && defined(Py_TRACE_REFS)
// #  error "Py_TRACE_REFS ABI is not compatible with release and debug ABI"
// #endif

// #if defined(__ANDROID__) || defined(__VXWORKS__)
   // Use UTF-8 as the locale encoding, ignore the LC_CTYPE locale.
   // See _Py_GetLocaleEncoding(), PyUnicode_DecodeLocale()
   // and PyUnicode_EncodeLocale().
// #  define _Py_FORCE_UTF8_LOCALE
// #endif

// #if defined(_Py_FORCE_UTF8_LOCALE) || defined(__APPLE__)
   // Use UTF-8 as the filesystem encoding.
   // See PyUnicode_DecodeFSDefaultAndSize(), PyUnicode_EncodeFSDefault(),
   // Py_DecodeLocale() and Py_EncodeLocale().
// #  define _Py_FORCE_UTF8_FS_ENCODING
// #endif

/* Mark a function which cannot return. Example:
   PyAPI_FUNC(void) _Py_NO_RETURN PyThread_exit_thread(void);

   XLC support is intentionally omitted due to bpo-40244 */
// #ifndef _Py_NO_RETURN
// #if defined(__clang__) ||
//     (defined(__GNUC__) &&
//      ((__GNUC__ >= 3) ||
//       (__GNUC__ == 2) && (__GNUC_MINOR__ >= 5)))
// #  define _Py_NO_RETURN __attribute__((__noreturn__))
// #elif defined(_MSC_VER)
// #  define _Py_NO_RETURN __declspec(noreturn)
// #else
// #  define _Py_NO_RETURN
// #endif
// #endif


// Preprocessor check for a builtin preprocessor function. Always return 0
// if __has_builtin() macro is not defined.
//
// __has_builtin() is available on clang and GCC 10.
// #ifdef __has_builtin
// #  define _Py__has_builtin(x) __has_builtin(x)
// #else
// #  define _Py__has_builtin(x) 0
// #endif


// #endif /* Py_PYPORT_H */


// Parsed from pymacro.h

// #ifndef Py_PYMACRO_H
// #define Py_PYMACRO_H

/* Minimum value between x and y */
// #define Py_MIN(x, y) (((x) > (y)) ? (y) : (x))

/* Maximum value between x and y */
// #define Py_MAX(x, y) (((x) > (y)) ? (x) : (y))

/* Absolute value of the number x */
// #define Py_ABS(x) ((x) < 0 ? -(x) : (x))

// #define _Py_XSTRINGIFY(x) #x

/* Convert the argument to a string. For example, Py_STRINGIFY(123) is replaced
   with "123" by the preprocessor. Defines are also replaced by their value.
   For example Py_STRINGIFY(__LINE__) is replaced by the line number, not
   by "__LINE__". */
// #define Py_STRINGIFY(x) _Py_XSTRINGIFY(x)

/* Get the size of a structure member in bytes */
// #define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)

/* Argument must be a char or an int in [-128, 127] or [0, 255]. */
// #define Py_CHARMASK(c) ((unsigned char)((c) & 0xff))

/* Assert a build-time dependency, as an expression.

   Your compile will fail if the condition isn't true, or can't be evaluated
   by the compiler. This can be used in an expression: its value is 0.

   Example:

   #define foo_to_char(foo)  \
       ((char *)(foo)        \
        + Py_BUILD_ASSERT_EXPR(offsetof(struct foo, string) == 0))

   Written by Rusty Russell, public domain, http://ccodearchive.net/ */
// #define Py_BUILD_ASSERT_EXPR(cond)
//     (sizeof(char [1 - 2*!(cond)]) - 1)

// #define Py_BUILD_ASSERT(cond)  do {
//         (void)Py_BUILD_ASSERT_EXPR(cond);
//     } while(0)

/* Get the number of elements in a visible array

   This does not work on pointers, or arrays declared as [], or function
   parameters. With correct compiler support, such usage will cause a build
   error (see Py_BUILD_ASSERT_EXPR).

   Written by Rusty Russell, public domain, http://ccodearchive.net/

   Requires at GCC 3.1+ */
// #if (defined(__GNUC__) && !defined(__STRICT_ANSI__) &&
//     (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 1)) || (__GNUC__ >= 4)))
/* Two gcc extensions.
   &a[0] degrades to a pointer: a different type from an array */
// #define Py_ARRAY_LENGTH(array)
//     (sizeof(array) / sizeof((array)[0])
//      + Py_BUILD_ASSERT_EXPR(!__builtin_types_compatible_p(typeof(array),
//                                                           typeof(&(array)[0]))))
// #else
// #define Py_ARRAY_LENGTH(array)
//     (sizeof(array) / sizeof((array)[0]))
// #endif


/* Define macros for inline documentation. */
// #define PyDoc_VAR(name) static const char name[]
// #define PyDoc_STRVAR(name,str) PyDoc_VAR(name) = PyDoc_STR(str)
// #ifdef WITH_DOC_STRINGS
// #define PyDoc_STR(str) str
// #else
// #endif

/* Below "a" is a power of 2. */
/* Round down size "n" to be a multiple of "a". */
// #define _Py_SIZE_ROUND_DOWN(n, a) ((size_t)(n) & ~(size_t)((a) - 1))
/* Round up size "n" to be a multiple of "a". */
// #define _Py_SIZE_ROUND_UP(n, a) (((size_t)(n) +
//         (size_t)((a) - 1)) & ~(size_t)((a) - 1))
/* Round pointer "p" down to the closest "a"-aligned address <= "p". */
// #define _Py_ALIGN_DOWN(p, a) ((void *)((uintptr_t)(p) & ~(uintptr_t)((a) - 1)))
/* Round pointer "p" up to the closest "a"-aligned address >= "p". */
// #define _Py_ALIGN_UP(p, a) ((void *)(((uintptr_t)(p) +
//         (uintptr_t)((a) - 1)) & ~(uintptr_t)((a) - 1)))
/* Check if pointer "p" is aligned to "a"-bytes boundary. */
// #define _Py_IS_ALIGNED(p, a) (!((uintptr_t)(p) & (uintptr_t)((a) - 1)))

/* Use this for unused arguments in a function definition to silence compiler
 * warnings. Example:
 *
 * int func(int a, int Py_UNUSED(b)) { return a; }
 */
// #if defined(__GNUC__) || defined(__clang__)
// #  define Py_UNUSED(name) _unused_ ## name __attribute__((unused))
// #else
// #  define Py_UNUSED(name) _unused_ ## name
// #endif

// #if defined(RANDALL_WAS_HERE)
// #  define Py_UNREACHABLE()
//     Py_FatalError(
//         "If you're seeing this, the code is in what I thought was\n"
//         "an unreachable state.\n\n"
//         "I could give you advice for what to do, but honestly, why\n"
//         "should you trust me?  I clearly screwed this up.  I'm writing\n"
//         "a message that should never appear, yet I know it will\n"
//         "probably appear someday.\n\n"
//         "On a deep level, I know I'm not up to this task.\n"
//         "I'm so sorry.\n"
//         "https://xkcd.com/2200")
// #elif defined(Py_DEBUG)
// #  define Py_UNREACHABLE()
//     Py_FatalError(
//         "We've reached an unreachable state. Anything is possible.\n"
//         "The limits were in our heads all along. Follow your dreams.\n"
//         "https://xkcd.com/2200")
// #elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5))
// #  define Py_UNREACHABLE() __builtin_unreachable()
// #elif defined(__clang__) || defined(__INTEL_COMPILER)
// #  define Py_UNREACHABLE() __builtin_unreachable()
// #elif defined(_MSC_VER)
// #  define Py_UNREACHABLE() __assume(0)
// #else
// #  define Py_UNREACHABLE()
//     Py_FatalError("Unreachable C code path reached")
// #endif

// #endif /* Py_PYMACRO_H */


// Parsed from pymath.h

// #ifndef Py_PYMATH_H
// #define Py_PYMATH_H

// #include "pyconfig.h" /* include for defines */

/**************************************************************************
Symbols and macros to supply platform-independent interfaces to mathematical
functions and constants
**************************************************************************/

/* Python provides implementations for copysign, round and hypot in
 * Python/pymath.c just in case your math library doesn't provide the
 * functions.
 *
 *Note: PC/pyconfig.h defines copysign as _copysign
 */
// #ifndef HAVE_COPYSIGN
// #endif

// #ifndef HAVE_ROUND
// #endif

// #ifndef HAVE_HYPOT
// #endif

/* extra declarations */
// #ifndef _MSC_VER
// #ifndef __STDC__
@NoException public static native double fmod(double arg0, double arg1);
@NoException public static native double frexp(double arg0, IntPointer arg1);
@NoException public static native double frexp(double arg0, IntBuffer arg1);
@NoException public static native double frexp(double arg0, int[] arg1);
@NoException public static native double ldexp(double arg0, int arg1);
@NoException public static native double modf(double arg0, DoublePointer arg1);
@NoException public static native double modf(double arg0, DoubleBuffer arg1);
@NoException public static native double modf(double arg0, double[] arg1);
@NoException public static native double pow(double arg0, double arg1);
// #endif /* __STDC__ */
// #endif /* _MSC_VER */

/* High precision definition of pi and e (Euler)
 * The values are taken from libc6's math.h.
 */
// #ifndef Py_MATH_PIl
public static final double Py_MATH_PIl = 3.1415926535897932384626433832795029;
// #endif
// #ifndef Py_MATH_PI
public static final double Py_MATH_PI = 3.14159265358979323846;
// #endif

// #ifndef Py_MATH_El
public static final double Py_MATH_El = 2.7182818284590452353602874713526625;
// #endif

// #ifndef Py_MATH_E
public static final double Py_MATH_E = 2.7182818284590452354;
// #endif

/* Tau (2pi) to 40 digits, taken from tauday.com/tau-digits. */
// #ifndef Py_MATH_TAU
public static final double Py_MATH_TAU = 6.2831853071795864769252867665590057683943;
// #endif


/* On x86, Py_FORCE_DOUBLE forces a floating-point number out of an x87 FPU
   register and into a 64-bit memory location, rounding from extended
   precision to double precision in the process.  On other platforms it does
   nothing. */

/* we take double rounding as evidence of x87 usage */
// #ifndef Py_LIMITED_API
// #ifndef Py_FORCE_DOUBLE
// #  ifdef X87_DOUBLE_ROUNDING
// #  else
// #    define Py_FORCE_DOUBLE(X) (X)
// #  endif
// #endif
// #endif

// #ifndef Py_LIMITED_API
// #ifdef HAVE_GCC_ASM_FOR_X87
// #endif
// #endif

/* Py_IS_NAN(X)
 * Return 1 if float or double arg is a NaN, else 0.
 * Caution:
 *     X is evaluated more than once.
 *     This may not work on all platforms.  Each platform has *some*
 *     way to spell this, though -- override in pyconfig.h if you have
 *     a platform where it doesn't work.
 * Note: PC/pyconfig.h defines Py_IS_NAN as _isnan
 */
// #ifndef Py_IS_NAN
// #if defined HAVE_DECL_ISNAN && HAVE_DECL_ISNAN == 1
// #define Py_IS_NAN(X) isnan(X)
// #else
// #define Py_IS_NAN(X) ((X) != (X))
// #endif
// #endif

/* Py_IS_INFINITY(X)
 * Return 1 if float or double arg is an infinity, else 0.
 * Caution:
 *    X is evaluated more than once.
 *    This implementation may set the underflow flag if |X| is very small;
 *    it really can't be implemented correctly (& easily) before C99.
 *    Override in pyconfig.h if you have a better spelling on your platform.
 *  Py_FORCE_DOUBLE is used to avoid getting false negatives from a
 *    non-infinite value v sitting in an 80-bit x87 register such that
 *    v becomes infinite when spilled from the register to 64-bit memory.
 * Note: PC/pyconfig.h defines Py_IS_INFINITY as _isinf
 */
// #ifndef Py_IS_INFINITY
// #  if defined HAVE_DECL_ISINF && HAVE_DECL_ISINF == 1
// #    define Py_IS_INFINITY(X) isinf(X)
// #  else
// #    define Py_IS_INFINITY(X) ((X) &&
//                                (Py_FORCE_DOUBLE(X)*0.5 == Py_FORCE_DOUBLE(X)))
// #  endif
// #endif

/* Py_IS_FINITE(X)
 * Return 1 if float or double arg is neither infinite nor NAN, else 0.
 * Some compilers (e.g. VisualStudio) have intrinsics for this, so a special
 * macro for this particular test is useful
 * Note: PC/pyconfig.h defines Py_IS_FINITE as _finite
 */
// #ifndef Py_IS_FINITE
// #if defined HAVE_DECL_ISFINITE && HAVE_DECL_ISFINITE == 1
// #define Py_IS_FINITE(X) isfinite(X)
// #elif defined HAVE_FINITE
// #define Py_IS_FINITE(X) finite(X)
// #else
// #define Py_IS_FINITE(X) (!Py_IS_INFINITY(X) && !Py_IS_NAN(X))
// #endif
// #endif

/* HUGE_VAL is supposed to expand to a positive double infinity.  Python
 * uses Py_HUGE_VAL instead because some platforms are broken in this
 * respect.  We used to embed code in pyport.h to try to worm around that,
 * but different platforms are broken in conflicting ways.  If you're on
 * a platform where HUGE_VAL is defined incorrectly, fiddle your Python
 * config to #define Py_HUGE_VAL to something that works on your platform.
 */
// #ifndef Py_HUGE_VAL
// #define Py_HUGE_VAL HUGE_VAL
// #endif

/* Py_NAN
 * A value that evaluates to a NaN. On IEEE 754 platforms INF*0 or
 * INF/INF works. Define Py_NO_NAN in pyconfig.h if your platform
 * doesn't support NaNs.
 */
// #if !defined(Py_NAN) && !defined(Py_NO_NAN)
// #if !defined(__INTEL_COMPILER)
//     #define Py_NAN (Py_HUGE_VAL * 0.)
// #else /* __INTEL_COMPILER */
// #endif /* __INTEL_COMPILER */
// #endif

/* Py_OVERFLOWED(X)
 * Return 1 iff a libm function overflowed.  Set errno to 0 before calling
 * a libm function, and invoke this macro after, passing the function
 * result.
 * Caution:
 *    This isn't reliable.  C99 no longer requires libm to set errno under
 *        any exceptional condition, but does require +- HUGE_VAL return
 *        values on overflow.  A 754 box *probably* maps HUGE_VAL to a
 *        double infinity, and we're cool if that's so, unless the input
 *        was an infinity and an infinity is the expected result.  A C89
 *        system sets errno to ERANGE, so we check for that too.  We're
 *        out of luck if a C99 754 box doesn't map HUGE_VAL to +Inf, or
 *        if the returned result is a NaN, or if a C89 box returns HUGE_VAL
 *        in non-overflow cases.
 *    X is evaluated more than once.
 * Some platforms have better way to spell this, so expect some #ifdef'ery.
 *
 * OpenBSD uses 'isinf()' because a compiler bug on that platform causes
 * the longer macro version to be mis-compiled. This isn't optimal, and
 * should be removed once a newer compiler is available on that platform.
 * The system that had the failure was running OpenBSD 3.2 on Intel, with
 * gcc 2.95.3.
 *
 * According to Tim's checkin, the FreeBSD systems use isinf() to work
 * around a FPE bug on that platform.
 */
// #if defined(__FreeBSD__) || defined(__OpenBSD__)
// #define Py_OVERFLOWED(X) isinf(X)
// #else
// #define Py_OVERFLOWED(X) ((X) != 0.0 && (errno == ERANGE ||
//                                          (X) == Py_HUGE_VAL ||
//                                          (X) == -Py_HUGE_VAL))
// #endif

/* Return whether integral type *type* is signed or not. */
// #define _Py_IntegralTypeSigned(type) ((type)(-1) < 0)
/* Return the maximum value of integral type *type*. */
// #define _Py_IntegralTypeMax(type) ((_Py_IntegralTypeSigned(type)) ? (((((type)1 << (sizeof(type)*CHAR_BIT - 2)) - 1) << 1) + 1) : ~(type)0)
/* Return the minimum value of integral type *type*. */
// #define _Py_IntegralTypeMin(type) ((_Py_IntegralTypeSigned(type)) ? -_Py_IntegralTypeMax(type) - 1 : 0)
/* Check whether *v* is in the range of integral type *type*. This is most
 * useful if *v* is floating-point, since demoting a floating-point *v* to an
 * integral type that cannot represent *v*'s integral part is undefined
 * behavior. */
// #define _Py_InIntegralTypeRange(type, v) (_Py_IntegralTypeMin(type) <= v && v <= _Py_IntegralTypeMax(type))

// #endif /* Py_PYMATH_H */


// Parsed from cpython/pytime.h

// #ifndef Py_LIMITED_API
// #ifndef Py_PYTIME_H
// #define Py_PYTIME_H

/**************************************************************************
Symbols and macros to supply platform-independent interfaces to time related
functions and constants
**************************************************************************/
// #ifdef __cplusplus
// #endif

/* _PyTime_t: Python timestamp with subsecond precision. It can be used to
   store a duration, and so indirectly a date (related to another date, like
   UNIX epoch). */
// #define _PyTime_MIN INT64_MIN
// #define _PyTime_MAX INT64_MAX

/** enum _PyTime_round_t */
public static final int
    /* Round towards minus infinity (-inf).
       For example, used to read a clock. */
    _PyTime_ROUND_FLOOR = 0,
    /* Round towards infinity (+inf).
       For example, used for timeout to wait "at least" N seconds. */
    _PyTime_ROUND_CEILING = 1,
    /* Round to nearest with ties going to nearest even integer.
       For example, used to round from a Python float. */
    _PyTime_ROUND_HALF_EVEN = 2,
    /* Round away from zero
       For example, used for timeout. _PyTime_ROUND_CEILING rounds
       -1e-9 to 0 milliseconds which causes bpo-31786 issue.
       _PyTime_ROUND_UP rounds -1e-9 to -1 millisecond which keeps
       the timeout sign as expected. select.poll(timeout) must block
       for negative values." */
    _PyTime_ROUND_UP = 3,
    /* _PyTime_ROUND_TIMEOUT (an alias for _PyTime_ROUND_UP) should be
       used for timeouts. */
    _PyTime_ROUND_TIMEOUT = _PyTime_ROUND_UP;


/* Convert a time_t to a PyLong. */
@NoException public static native PyObject _PyLong_FromTime_t(
    @ByVal @Cast("time_t*") Pointer sec);

/* Convert a PyLong to a time_t. */
@NoException public static native @ByVal @Cast("time_t*") Pointer _PyLong_AsTime_t(
    PyObject obj);

/* Convert a number of seconds, int or float, to time_t. */
@NoException public static native int _PyTime_ObjectToTime_t(
    PyObject obj,
    @Cast("time_t*") Pointer sec,
    @Cast("_PyTime_round_t") int arg2);

/* Convert a number of seconds, int or float, to a timeval structure.
   usec is in the range [0; 999999] and rounded towards zero.
   For example, -1.2 is converted to (-2, 800000). */
@NoException public static native int _PyTime_ObjectToTimeval(
    PyObject obj,
    @Cast("time_t*") Pointer sec,
    CLongPointer usec,
    @Cast("_PyTime_round_t") int arg3);

/* Convert a number of seconds, int or float, to a timespec structure.
   nsec is in the range [0; 999999999] and rounded towards zero.
   For example, -1.2 is converted to (-2, 800000000). */
@NoException public static native int _PyTime_ObjectToTimespec(
    PyObject obj,
    @Cast("time_t*") Pointer sec,
    CLongPointer nsec,
    @Cast("_PyTime_round_t") int arg3);


/* Create a timestamp from a number of seconds. */
@NoException public static native @Cast("_PyTime_t") long _PyTime_FromSeconds(int seconds);

/* Macro to create a timestamp from a number of seconds, no integer overflow.
   Only use the macro for small values, prefer _PyTime_FromSeconds(). */
// #define _PYTIME_FROMSECONDS(seconds)
//             ((_PyTime_t)(seconds) * (1000 * 1000 * 1000))

/* Create a timestamp from a number of nanoseconds. */
@NoException public static native @Cast("_PyTime_t") long _PyTime_FromNanoseconds(@Cast("_PyTime_t") long ns);

/* Create a timestamp from nanoseconds (Python int). */
@NoException public static native int _PyTime_FromNanosecondsObject(@Cast("_PyTime_t*") LongPointer t,
    PyObject obj);
@NoException public static native int _PyTime_FromNanosecondsObject(@Cast("_PyTime_t*") LongBuffer t,
    PyObject obj);
@NoException public static native int _PyTime_FromNanosecondsObject(@Cast("_PyTime_t*") long[] t,
    PyObject obj);

/* Convert a number of seconds (Python float or int) to a timestamp.
   Raise an exception and return -1 on error, return 0 on success. */
@NoException public static native int _PyTime_FromSecondsObject(@Cast("_PyTime_t*") LongPointer t,
    PyObject obj,
    @Cast("_PyTime_round_t") int round);
@NoException public static native int _PyTime_FromSecondsObject(@Cast("_PyTime_t*") LongBuffer t,
    PyObject obj,
    @Cast("_PyTime_round_t") int round);
@NoException public static native int _PyTime_FromSecondsObject(@Cast("_PyTime_t*") long[] t,
    PyObject obj,
    @Cast("_PyTime_round_t") int round);

/* Convert a number of milliseconds (Python float or int, 10^-3) to a timestamp.
   Raise an exception and return -1 on error, return 0 on success. */
@NoException public static native int _PyTime_FromMillisecondsObject(@Cast("_PyTime_t*") LongPointer t,
    PyObject obj,
    @Cast("_PyTime_round_t") int round);
@NoException public static native int _PyTime_FromMillisecondsObject(@Cast("_PyTime_t*") LongBuffer t,
    PyObject obj,
    @Cast("_PyTime_round_t") int round);
@NoException public static native int _PyTime_FromMillisecondsObject(@Cast("_PyTime_t*") long[] t,
    PyObject obj,
    @Cast("_PyTime_round_t") int round);

/* Convert a timestamp to a number of seconds as a C double. */
@NoException public static native double _PyTime_AsSecondsDouble(@Cast("_PyTime_t") long t);

/* Convert timestamp to a number of milliseconds (10^-3 seconds). */
@NoException public static native @Cast("_PyTime_t") long _PyTime_AsMilliseconds(@Cast("_PyTime_t") long t,
    @Cast("_PyTime_round_t") int round);

/* Convert timestamp to a number of microseconds (10^-6 seconds). */
@NoException public static native @Cast("_PyTime_t") long _PyTime_AsMicroseconds(@Cast("_PyTime_t") long t,
    @Cast("_PyTime_round_t") int round);

/* Convert timestamp to a number of nanoseconds (10^-9 seconds) as a Python int
   object. */
@NoException public static native PyObject _PyTime_AsNanosecondsObject(@Cast("_PyTime_t") long t);

/* Create a timestamp from a timeval structure.
   Raise an exception and return -1 on overflow, return 0 on success. */


/* Convert a timestamp to a timeval structure (microsecond resolution).
   tv_usec is always positive.
   Raise an exception and return -1 if the conversion overflowed,
   return 0 on success. */
@NoException public static native int _PyTime_AsTimeval(@Cast("_PyTime_t") long t,
    @Cast("timeval*") Pointer tv,
    @Cast("_PyTime_round_t") int round);

/* Similar to _PyTime_AsTimeval(), but don't raise an exception on error. */
@NoException public static native int _PyTime_AsTimeval_noraise(@Cast("_PyTime_t") long t,
    @Cast("timeval*") Pointer tv,
    @Cast("_PyTime_round_t") int round);

/* Convert a timestamp to a number of seconds (secs) and microseconds (us).
   us is always positive. This function is similar to _PyTime_AsTimeval()
   except that secs is always a time_t type, whereas the timeval structure
   uses a C long for tv_sec on Windows.
   Raise an exception and return -1 if the conversion overflowed,
   return 0 on success. */
@NoException public static native int _PyTime_AsTimevalTime_t(
    @Cast("_PyTime_t") long t,
    @Cast("time_t*") Pointer secs,
    IntPointer us,
    @Cast("_PyTime_round_t") int round);
@NoException public static native int _PyTime_AsTimevalTime_t(
    @Cast("_PyTime_t") long t,
    @Cast("time_t*") Pointer secs,
    IntBuffer us,
    @Cast("_PyTime_round_t") int round);
@NoException public static native int _PyTime_AsTimevalTime_t(
    @Cast("_PyTime_t") long t,
    @Cast("time_t*") Pointer secs,
    int[] us,
    @Cast("_PyTime_round_t") int round);

// #if defined(HAVE_CLOCK_GETTIME) || defined(HAVE_KQUEUE)
// #endif

/* Compute ticks * mul / div.
   The caller must ensure that ((div - 1) * mul) cannot overflow. */
@NoException public static native @Cast("_PyTime_t") long _PyTime_MulDiv(@Cast("_PyTime_t") long ticks,
    @Cast("_PyTime_t") long mul,
    @Cast("_PyTime_t") long div);
// Targeting ../_Py_clock_info_t.java



/* Get the current time from the system clock.

   If the internal clock fails, silently ignore the error and return 0.
   On integer overflow, silently ignore the overflow and truncated the clock to
   _PyTime_MIN or _PyTime_MAX.

   Use _PyTime_GetSystemClockWithInfo() to check for failure. */
@NoException public static native @Cast("_PyTime_t") long _PyTime_GetSystemClock();

/* Get the current time from the system clock.
 * On success, set *t and *info (if not NULL), and return 0.
 * On error, raise an exception and return -1.
 */
@NoException public static native int _PyTime_GetSystemClockWithInfo(
    @Cast("_PyTime_t*") LongPointer t,
    _Py_clock_info_t info);
@NoException public static native int _PyTime_GetSystemClockWithInfo(
    @Cast("_PyTime_t*") LongBuffer t,
    _Py_clock_info_t info);
@NoException public static native int _PyTime_GetSystemClockWithInfo(
    @Cast("_PyTime_t*") long[] t,
    _Py_clock_info_t info);

/* Get the time of a monotonic clock, i.e. a clock that cannot go backwards.
   The clock is not affected by system clock updates. The reference point of
   the returned value is undefined, so that only the difference between the
   results of consecutive calls is valid.

   If the internal clock fails, silently ignore the error and return 0.
   On integer overflow, silently ignore the overflow and truncated the clock to
   _PyTime_MIN or _PyTime_MAX.

   Use _PyTime_GetMonotonicClockWithInfo() to check for failure. */
@NoException public static native @Cast("_PyTime_t") long _PyTime_GetMonotonicClock();

/* Get the time of a monotonic clock, i.e. a clock that cannot go backwards.
   The clock is not affected by system clock updates. The reference point of
   the returned value is undefined, so that only the difference between the
   results of consecutive calls is valid.

   Fill info (if set) with information of the function used to get the time.

   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyTime_GetMonotonicClockWithInfo(
    @Cast("_PyTime_t*") LongPointer t,
    _Py_clock_info_t info);
@NoException public static native int _PyTime_GetMonotonicClockWithInfo(
    @Cast("_PyTime_t*") LongBuffer t,
    _Py_clock_info_t info);
@NoException public static native int _PyTime_GetMonotonicClockWithInfo(
    @Cast("_PyTime_t*") long[] t,
    _Py_clock_info_t info);


/* Converts a timestamp to the Gregorian time, using the local time zone.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyTime_localtime(@ByVal @Cast("time_t*") Pointer t, @Cast("tm*") Pointer tm);

/* Converts a timestamp to the Gregorian time, assuming UTC.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyTime_gmtime(@ByVal @Cast("time_t*") Pointer t, @Cast("tm*") Pointer tm);

/* Get the performance counter: clock with the highest available resolution to
   measure a short duration.

   If the internal clock fails, silently ignore the error and return 0.
   On integer overflow, silently ignore the overflow and truncated the clock to
   _PyTime_MIN or _PyTime_MAX.

   Use _PyTime_GetPerfCounterWithInfo() to check for failure. */
@NoException public static native @Cast("_PyTime_t") long _PyTime_GetPerfCounter();

/* Get the performance counter: clock with the highest available resolution to
   measure a short duration.

   Fill info (if set) with information of the function used to get the time.

   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyTime_GetPerfCounterWithInfo(
    @Cast("_PyTime_t*") LongPointer t,
    _Py_clock_info_t info);
@NoException public static native int _PyTime_GetPerfCounterWithInfo(
    @Cast("_PyTime_t*") LongBuffer t,
    _Py_clock_info_t info);
@NoException public static native int _PyTime_GetPerfCounterWithInfo(
    @Cast("_PyTime_t*") long[] t,
    _Py_clock_info_t info);

// #ifdef __cplusplus
// #endif

// #endif /* Py_PYTIME_H */
// #endif /* Py_LIMITED_API */


// Parsed from pymem.h

/* The PyMem_ family:  low-level memory allocation interfaces.
   See objimpl.h for the PyObject_ memory family.
*/

// #ifndef Py_PYMEM_H
// #define Py_PYMEM_H

// #include "pyport.h"

// #ifdef __cplusplus
// #endif

/* BEWARE:

   Each interface exports both functions and macros.  Extension modules should
   use the functions, to ensure binary compatibility across Python versions.
   Because the Python implementation is free to change internal details, and
   the macros may (or may not) expose details for speed, if you do use the
   macros you must recompile your extensions with each Python release.

   Never mix calls to PyMem_ with calls to the platform malloc/realloc/
   calloc/free.  For example, on Windows different DLLs may end up using
   different heaps, and if you use PyMem_Malloc you'll get the memory from the
   heap used by the Python DLL; it could be a disaster if you free()'ed that
   directly in your own extension.  Using PyMem_Free instead ensures Python
   can return the memory to the proper heap.  As another example, in
   a debug build (Py_DEBUG macro), Python wraps all calls to all PyMem_ and
   PyObject_ memory functions in special debugging wrappers that add additional
   debugging info to dynamic memory blocks.  The system routines have no idea
   what to do with that stuff, and the Python wrappers have no idea what to do
   with raw blocks obtained directly by the system routines then.

   The GIL must be held when using these APIs.
*/

/*
 * Raw memory interface
 * ====================
 */

/* Functions

   Functions supplying platform-independent semantics for malloc/realloc/
   free.  These functions make sure that allocating 0 bytes returns a distinct
   non-NULL pointer (whenever possible -- if we're flat out of memory, NULL
   may be returned), even if the platform malloc and realloc don't.
   Returned pointers must be checked for NULL explicitly.  No action is
   performed on failure (no exception is set, no warning is printed, etc).
*/

@NoException public static native Pointer PyMem_Malloc(@Cast("size_t") long size);
@NoException public static native Pointer PyMem_Calloc(@Cast("size_t") long nelem, @Cast("size_t") long elsize);
@NoException public static native Pointer PyMem_Realloc(Pointer ptr, @Cast("size_t") long new_size);
@NoException public static native void PyMem_Free(Pointer ptr);

/*
 * Type-oriented memory interface
 * ==============================
 *
 * Allocate memory for n objects of the given type.  Returns a new pointer
 * or NULL if the request was too large or memory allocation failed.  Use
 * these macros rather than doing the multiplication yourself so that proper
 * overflow checking is always done.
 */

// #define PyMem_New(type, n)
//   ( ((size_t)(n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL :
//         ( (type *) PyMem_Malloc((n) * sizeof(type)) ) )

/*
 * The value of (p) is always clobbered by this macro regardless of success.
 * The caller MUST check if (p) is NULL afterwards and deal with the memory
 * error if so.  This means the original value of (p) MUST be saved for the
 * caller's memory error handler to not lose track of it.
 */
// #define PyMem_Resize(p, type, n)
//   ( (p) = ((size_t)(n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL :
//         (type *) PyMem_Realloc((p), (n) * sizeof(type)) )


// Deprecated aliases only kept for backward compatibility.
// PyMem_Del and PyMem_DEL are defined with no parameter to be able to use
// them as function pointers (ex: dealloc = PyMem_Del).
// #define PyMem_MALLOC(n)           PyMem_Malloc(n)
// #define PyMem_NEW(type, n)        PyMem_New(type, n)
// #define PyMem_REALLOC(p, n)       PyMem_Realloc(p, n)
// #define PyMem_RESIZE(p, type, n)  PyMem_Resize(p, type, n)
// #define PyMem_FREE(p)             PyMem_Free(p)
// #define PyMem_Del                 PyMem_Free
// #define PyMem_DEL                 PyMem_Free


// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_PYMEM_H
// #  include  "cpython/pymem.h"
// #  undef Py_CPYTHON_PYMEM_H
// #endif

// #ifdef __cplusplus
// #endif

// #endif /* !Py_PYMEM_H */


// Parsed from cpython/pymem.h

// #ifndef Py_CPYTHON_PYMEM_H
// #  error "this header file must not be included directly"
// #endif

@NoException public static native Pointer PyMem_RawMalloc(@Cast("size_t") long size);
@NoException public static native Pointer PyMem_RawCalloc(@Cast("size_t") long nelem, @Cast("size_t") long elsize);
@NoException public static native Pointer PyMem_RawRealloc(Pointer ptr, @Cast("size_t") long new_size);
@NoException public static native void PyMem_RawFree(Pointer ptr);

/* Try to get the allocators name set by _PyMem_SetupAllocators(). */
@NoException public static native @Cast("const char*") BytePointer _PyMem_GetCurrentAllocatorName();

/* strdup() using PyMem_RawMalloc() */
@NoException public static native @Cast("char*") BytePointer _PyMem_RawStrdup(@Cast("const char*") BytePointer str);
@NoException public static native @Cast("char*") ByteBuffer _PyMem_RawStrdup(String str);

/* strdup() using PyMem_Malloc() */
@NoException public static native @Cast("char*") BytePointer _PyMem_Strdup(@Cast("const char*") BytePointer str);
@NoException public static native @Cast("char*") ByteBuffer _PyMem_Strdup(String str);

/* wcsdup() using PyMem_RawMalloc() */
@NoException public static native @Cast("wchar_t*") Pointer _PyMem_RawWcsdup(@Cast("const wchar_t*") Pointer str);


/** enum PyMemAllocatorDomain */
public static final int
    /* PyMem_RawMalloc(), PyMem_RawRealloc() and PyMem_RawFree() */
    PYMEM_DOMAIN_RAW = 0,

    /* PyMem_Malloc(), PyMem_Realloc() and PyMem_Free() */
    PYMEM_DOMAIN_MEM = 1,

    /* PyObject_Malloc(), PyObject_Realloc() and PyObject_Free() */
    PYMEM_DOMAIN_OBJ = 2;

/** enum PyMemAllocatorName */
public static final int
    PYMEM_ALLOCATOR_NOT_SET = 0,
    PYMEM_ALLOCATOR_DEFAULT = 1,
    PYMEM_ALLOCATOR_DEBUG = 2,
    PYMEM_ALLOCATOR_MALLOC = 3,
    PYMEM_ALLOCATOR_MALLOC_DEBUG = 4,
// #ifdef WITH_PYMALLOC
    PYMEM_ALLOCATOR_PYMALLOC = 5,
    PYMEM_ALLOCATOR_PYMALLOC_DEBUG = 6;
// #endif
// Targeting ../PyMemAllocatorEx.java



/* Get the memory block allocator of the specified domain. */
@NoException public static native void PyMem_GetAllocator(@Cast("PyMemAllocatorDomain") int domain,
                                    PyMemAllocatorEx allocator);

/* Set the memory block allocator of the specified domain.

   The new allocator must return a distinct non-NULL pointer when requesting
   zero bytes.

   For the PYMEM_DOMAIN_RAW domain, the allocator must be thread-safe: the GIL
   is not held when the allocator is called.

   If the new allocator is not a hook (don't call the previous allocator), the
   PyMem_SetupDebugHooks() function must be called to reinstall the debug hooks
   on top on the new allocator. */
@NoException public static native void PyMem_SetAllocator(@Cast("PyMemAllocatorDomain") int domain,
                                    PyMemAllocatorEx allocator);

/* Setup hooks to detect bugs in the following Python memory allocator
   functions:

   - PyMem_RawMalloc(), PyMem_RawRealloc(), PyMem_RawFree()
   - PyMem_Malloc(), PyMem_Realloc(), PyMem_Free()
   - PyObject_Malloc(), PyObject_Realloc() and PyObject_Free()

   Newly allocated memory is filled with the byte 0xCB, freed memory is filled
   with the byte 0xDB. Additional checks:

   - detect API violations, ex: PyObject_Free() called on a buffer allocated
     by PyMem_Malloc()
   - detect write before the start of the buffer (buffer underflow)
   - detect write after the end of the buffer (buffer overflow)

   The function does nothing if Python is not compiled is debug mode. */
@NoException public static native void PyMem_SetupDebugHooks();


// Parsed from object.h

// #ifndef Py_OBJECT_H
// #define Py_OBJECT_H

// #ifdef __cplusplus
// #endif


/* Object and type object interface */

/*
Objects are structures allocated on the heap.  Special rules apply to
the use of objects to ensure they are properly garbage-collected.
Objects are never allocated statically or on the stack; they must be
accessed through special macros and functions only.  (Type objects are
exceptions to the first rule; the standard types are represented by
statically initialized type objects, although work on type/class unification
for Python 2.2 made it possible to have heap-allocated type objects too).

An object has a 'reference count' that is increased or decreased when a
pointer to the object is copied or deleted; when the reference count
reaches zero there are no references to the object left and it can be
removed from the heap.

An object has a 'type' that determines what it represents and what kind
of data it contains.  An object's type is fixed when it is created.
Types themselves are represented as objects; an object contains a
pointer to the corresponding type object.  The type itself has a type
pointer pointing to the object representing the type 'type', which
contains a pointer to itself!.

Objects do not float around in memory; once allocated an object keeps
the same size and address.  Objects that must hold variable-size data
can contain pointers to variable-size parts of the object.  Not all
objects of the same type have the same size; but the size cannot change
after allocation.  (These restrictions are made so a reference to an
object can be simply a pointer -- moving an object would require
updating all the pointers, and changing an object's size would require
moving it if there was another object right next to it.)

Objects are always accessed through pointers of the type 'PyObject *'.
The type 'PyObject' is a structure that only contains the reference count
and the type pointer.  The actual memory allocated for an object
contains other data that can only be accessed after casting the pointer
to a pointer to a longer structure type.  This longer type must start
with the reference count and type fields; the macro PyObject_HEAD should be
used for this (to accommodate for future changes).  The implementation
of a particular object type can cast the object pointer to the proper
type and back.

A standard interface exists for objects that contain an array of items
whose size is determined when the object is allocated.
*/

/* Py_DEBUG implies Py_REF_DEBUG. */
// #if defined(Py_DEBUG) && !defined(Py_REF_DEBUG)
// #  define Py_REF_DEBUG
// #endif

// #if defined(Py_LIMITED_API) && defined(Py_TRACE_REFS)
// #  error Py_LIMITED_API is incompatible with Py_TRACE_REFS
// #endif

/* PyTypeObject structure is defined in cpython/object.h.
   In Py_LIMITED_API, PyTypeObject is an opaque structure. */

// #ifdef Py_TRACE_REFS

// #else
// #  define _PyObject_HEAD_EXTRA
// #  define _PyObject_EXTRA_INIT
// #endif

/* PyObject_HEAD defines the initial segment of every PyObject. */
// #define PyObject_HEAD                   PyObject ob_base;

// #define PyObject_HEAD_INIT(type)
//     { _PyObject_EXTRA_INIT
//     1, type },

// #define PyVarObject_HEAD_INIT(type, size)
//     { PyObject_HEAD_INIT(type) size },

/* PyObject_VAR_HEAD defines the initial segment of all variable-size
 * container objects.  These end with a declaration of an array with 1
 * element, but enough space is malloc'ed so that the array actually
 * has room for ob_size elements.  Note that ob_size is an element count,
 * not necessarily a byte count.
 */
// #define PyObject_VAR_HEAD      PyVarObject ob_base;
public static final long Py_INVALID_SIZE = (long)-1;
// Targeting ../PyObject.java



/* Cast argument to PyObject* type. */
// #define _PyObject_CAST(op) ((PyObject*)(op))
// #define _PyObject_CAST_CONST(op) ((const PyObject*)(op))
// Targeting ../PyVarObject.java



/* Cast argument to PyVarObject* type. */
// #define _PyVarObject_CAST(op) ((PyVarObject*)(op))
// #define _PyVarObject_CAST_CONST(op) ((const PyVarObject*)(op))


// Test if the 'x' object is the 'y' object, the same as "x is y" in Python.
@NoException public static native int Py_Is(PyObject x, PyObject y);
// #define Py_Is(x, y) ((x) == (y))


@NoException public static native @Cast("Py_ssize_t") long _Py_REFCNT(@Const PyObject ob);
// #define Py_REFCNT(ob) _Py_REFCNT(_PyObject_CAST_CONST(ob))


// bpo-39573: The Py_SET_TYPE() function must be used to set an object type.
// #define Py_TYPE(ob)             (_PyObject_CAST(ob)->ob_type)

// bpo-39573: The Py_SET_SIZE() function must be used to set an object size.
// #define Py_SIZE(ob)             (_PyVarObject_CAST(ob)->ob_size)


@NoException public static native int _Py_IS_TYPE(@Const PyObject ob, @Const PyTypeObject type);
// #define Py_IS_TYPE(ob, type) _Py_IS_TYPE(_PyObject_CAST_CONST(ob), type)


@NoException public static native void _Py_SET_REFCNT(PyObject ob, @Cast("Py_ssize_t") long refcnt);
// #define Py_SET_REFCNT(ob, refcnt) _Py_SET_REFCNT(_PyObject_CAST(ob), refcnt)


@NoException public static native void _Py_SET_TYPE(PyObject ob, PyTypeObject type);
// #define Py_SET_TYPE(ob, type) _Py_SET_TYPE(_PyObject_CAST(ob), type)


@NoException public static native void _Py_SET_SIZE(PyVarObject ob, @Cast("Py_ssize_t") long size);
// #define Py_SET_SIZE(ob, size) _Py_SET_SIZE(_PyVarObject_CAST(ob), size)
// Targeting ../unaryfunc.java


// Targeting ../binaryfunc.java


// Targeting ../ternaryfunc.java


// Targeting ../inquiry.java


// Targeting ../lenfunc.java


// Targeting ../ssizeargfunc.java


// Targeting ../ssizessizeargfunc.java


// Targeting ../ssizeobjargproc.java


// Targeting ../ssizessizeobjargproc.java


// Targeting ../objobjargproc.java


// Targeting ../objobjproc.java


// Targeting ../visitproc.java


// Targeting ../traverseproc.java


// Targeting ../freefunc.java


// Targeting ../destructor.java


// Targeting ../getattrfunc.java


// Targeting ../getattrofunc.java


// Targeting ../setattrfunc.java


// Targeting ../setattrofunc.java


// Targeting ../reprfunc.java


// Targeting ../hashfunc.java


// Targeting ../richcmpfunc.java


// Targeting ../getiterfunc.java


// Targeting ../iternextfunc.java


// Targeting ../descrgetfunc.java


// Targeting ../descrsetfunc.java


// Targeting ../initproc.java


// Targeting ../newfunc.java


// Targeting ../allocfunc.java


// Targeting ../PyType_Slot.java


// Targeting ../PyType_Spec.java



@NoException public static native PyObject PyType_FromSpec(PyType_Spec arg0);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyType_FromSpecWithBases(PyType_Spec arg0, PyObject arg1);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
@NoException public static native Pointer PyType_GetSlot(PyTypeObject arg0, int arg1);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
@NoException public static native PyObject PyType_FromModuleAndSpec(PyObject arg0, PyType_Spec arg1, PyObject arg2);
@NoException public static native PyObject PyType_GetModule(@Cast("_typeobject*") PyTypeObject arg0);
@NoException public static native Pointer PyType_GetModuleState(@Cast("_typeobject*") PyTypeObject arg0);
// #endif

/* Generic type check */
@NoException public static native int PyType_IsSubtype(PyTypeObject arg0, PyTypeObject arg1);

@NoException public static native int _PyObject_TypeCheck(PyObject ob, PyTypeObject type);
// #define PyObject_TypeCheck(ob, type) _PyObject_TypeCheck(_PyObject_CAST(ob), type)

public static native @ByRef PyTypeObject PyType_Type(); public static native void PyType_Type(PyTypeObject setter); /* built-in 'type' */
public static native @ByRef PyTypeObject PyBaseObject_Type(); public static native void PyBaseObject_Type(PyTypeObject setter); /* built-in 'object' */
public static native @ByRef PyTypeObject PySuper_Type(); public static native void PySuper_Type(PyTypeObject setter); /* built-in 'super' */

@NoException public static native @Cast("unsigned long") long PyType_GetFlags(PyTypeObject arg0);

@NoException public static native int PyType_Ready(PyTypeObject arg0);
@NoException public static native PyObject PyType_GenericAlloc(PyTypeObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native PyObject PyType_GenericNew(PyTypeObject arg0,
                                               PyObject arg1, PyObject arg2);
@NoException public static native @Cast("unsigned int") int PyType_ClearCache();
@NoException public static native void PyType_Modified(PyTypeObject arg0);

/* Generic operations on objects */
@NoException public static native PyObject PyObject_Repr(PyObject arg0);
@NoException public static native PyObject PyObject_Str(PyObject arg0);
@NoException public static native PyObject PyObject_ASCII(PyObject arg0);
@NoException public static native PyObject PyObject_Bytes(PyObject arg0);
@NoException public static native PyObject PyObject_RichCompare(PyObject arg0, PyObject arg1, int arg2);
@NoException public static native int PyObject_RichCompareBool(PyObject arg0, PyObject arg1, int arg2);
@NoException public static native PyObject PyObject_GetAttrString(PyObject arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native PyObject PyObject_GetAttrString(PyObject arg0, String arg1);
@NoException public static native int PyObject_SetAttrString(PyObject arg0, @Cast("const char*") BytePointer arg1, PyObject arg2);
@NoException public static native int PyObject_SetAttrString(PyObject arg0, String arg1, PyObject arg2);
@NoException public static native int PyObject_HasAttrString(PyObject arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native int PyObject_HasAttrString(PyObject arg0, String arg1);
@NoException public static native PyObject PyObject_GetAttr(PyObject arg0, PyObject arg1);
@NoException public static native int PyObject_SetAttr(PyObject arg0, PyObject arg1, PyObject arg2);
@NoException public static native int PyObject_HasAttr(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyObject_SelfIter(PyObject arg0);
@NoException public static native PyObject PyObject_GenericGetAttr(PyObject arg0, PyObject arg1);
@NoException public static native int PyObject_GenericSetAttr(PyObject arg0, PyObject arg1, PyObject arg2);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native int PyObject_GenericSetDict(PyObject arg0, PyObject arg1, Pointer arg2);
// #endif
@NoException public static native @Cast("Py_hash_t") long PyObject_Hash(PyObject arg0);
@NoException public static native @Cast("Py_hash_t") long PyObject_HashNotImplemented(PyObject arg0);
@NoException public static native int PyObject_IsTrue(PyObject arg0);
@NoException public static native int PyObject_Not(PyObject arg0);
@NoException public static native int PyCallable_Check(PyObject arg0);
@NoException public static native void PyObject_ClearWeakRefs(PyObject arg0);

/* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a
   list of strings.  PyObject_Dir(NULL) is like builtins.dir(),
   returning the names of the current locals.  In this case, if there are
   no current locals, NULL is returned, and PyErr_Occurred() is false.
*/
@NoException public static native PyObject PyObject_Dir(PyObject arg0);


/* Helpers for printing recursive container types */
@NoException public static native int Py_ReprEnter(PyObject arg0);
@NoException public static native void Py_ReprLeave(PyObject arg0);

/* Flag bits for printing: */
public static final int Py_PRINT_RAW =    1;       /* No string quotes etc. */

/*
Type flags (tp_flags)

These flags are used to change expected features and behavior for a
particular type.

Arbitration of the flag bit positions will need to be coordinated among
all extension writers who publicly release their extensions (this will
be fewer than you might expect!).

Most flags were removed as of Python 3.0 to make room for new flags.  (Some
flags are not for backwards compatibility but to indicate the presence of an
optional feature; these flags remain of course.)

Type definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.

Code can use PyType_HasFeature(type_ob, flag_value) to test whether the
given type object has a specified feature.
*/

// #ifndef Py_LIMITED_API
/* Set if instances of the type object are treated as sequences for pattern matching */
public static final int Py_TPFLAGS_SEQUENCE = (1 << 5);
/* Set if instances of the type object are treated as mappings for pattern matching */
public static final int Py_TPFLAGS_MAPPING = (1 << 6);
// #endif

/* Disallow creating instances of the type: set tp_new to NULL and don't create
 * the "__new__" key in the type dictionary. */
public static final long Py_TPFLAGS_DISALLOW_INSTANTIATION = (1L << 7);

/* Set if the type object is immutable: type attributes cannot be set nor deleted */
public static final long Py_TPFLAGS_IMMUTABLETYPE = (1L << 8);

/* Set if the type object is dynamically allocated */
public static final long Py_TPFLAGS_HEAPTYPE = (1L << 9);

/* Set if the type allows subclassing */
public static final long Py_TPFLAGS_BASETYPE = (1L << 10);

/* Set if the type implements the vectorcall protocol (PEP 590) */
// #ifndef Py_LIMITED_API
public static final long Py_TPFLAGS_HAVE_VECTORCALL = (1L << 11);
// Backwards compatibility alias for API that was provisional in Python 3.8
public static final long _Py_TPFLAGS_HAVE_VECTORCALL = Py_TPFLAGS_HAVE_VECTORCALL;
// #endif

/* Set if the type is 'ready' -- fully initialized */
public static final long Py_TPFLAGS_READY = (1L << 12);

/* Set while the type is being 'readied', to prevent recursive ready calls */
public static final long Py_TPFLAGS_READYING = (1L << 13);

/* Objects support garbage collection (see objimpl.h) */
public static final long Py_TPFLAGS_HAVE_GC = (1L << 14);

/* These two bits are preserved for Stackless Python, next after this is 17 */
// #ifdef STACKLESS
public static final long Py_TPFLAGS_HAVE_STACKLESS_EXTENSION = (3L << 15);
// #else
// #endif

/* Objects behave like an unbound method */
public static final long Py_TPFLAGS_METHOD_DESCRIPTOR = (1L << 17);

/* Object has up-to-date type attribute cache */
public static final long Py_TPFLAGS_VALID_VERSION_TAG =  (1L << 19);

/* Type is abstract and cannot be instantiated */
public static final long Py_TPFLAGS_IS_ABSTRACT = (1L << 20);

// This undocumented flag gives certain built-ins their unique pattern-matching
// behavior, which allows a single positional subpattern to match against the
// subject itself (rather than a mapped attribute on it):
public static final long _Py_TPFLAGS_MATCH_SELF = (1L << 22);

/* These flags are used to determine if a type is a subclass. */
public static final long Py_TPFLAGS_LONG_SUBCLASS =        (1L << 24);
public static final long Py_TPFLAGS_LIST_SUBCLASS =        (1L << 25);
public static final long Py_TPFLAGS_TUPLE_SUBCLASS =       (1L << 26);
public static final long Py_TPFLAGS_BYTES_SUBCLASS =       (1L << 27);
public static final long Py_TPFLAGS_UNICODE_SUBCLASS =     (1L << 28);
public static final long Py_TPFLAGS_DICT_SUBCLASS =        (1L << 29);
public static final long Py_TPFLAGS_BASE_EXC_SUBCLASS =    (1L << 30);
public static final long Py_TPFLAGS_TYPE_SUBCLASS =        (1L << 31);

public static final long Py_TPFLAGS_DEFAULT =  ( 
                 Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | 
                0);

/* NOTE: Some of the following flags reuse lower bits (removed as part of the
 * Python 3.0 transition). */

/* The following flags are kept for compatibility; in previous
 * versions they indicated presence of newer tp_* fields on the
 * type struct.
 * Starting with 3.8, binary compatibility of C extensions across
 * feature releases of Python is not supported anymore (except when
 * using the stable ABI, in which all classes are created dynamically,
 * using the interpreter's memory layout.)
 * Note that older extensions using the stable ABI set these flags,
 * so the bits must not be repurposed.
 */
public static final long Py_TPFLAGS_HAVE_FINALIZE = (1L << 0);
public static final long Py_TPFLAGS_HAVE_VERSION_TAG =   (1L << 18);


/*
The macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement
reference counts.  Py_DECREF calls the object's deallocator function when
the refcount falls to 0; for
objects that don't contain references to other objects or heap memory
this can be the standard function free().  Both macros can be used
wherever a void expression is allowed.  The argument must not be a
NULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.
The macro _Py_NewReference(op) initialize reference counts to 1, and
in special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional
bookkeeping appropriate to the special build.

We assume that the reference count field can never overflow; this can
be proven when the size of the field is the same as the pointer size, so
we ignore the possibility.  Provided a C int is at least 32 bits (which
is implicitly assumed in many parts of this code), that's enough for
about 2**31 references to an object.

XXX The following became out of date in Python 2.2, but I'm not sure
XXX what the full truth is now.  Certainly, heap-allocated type objects
XXX can and should be deallocated.
Type objects should never be deallocated; the type pointer in an object
is not considered to be a reference to the type object, to save
complications in the deallocation function.  (This is actually a
decision that's up to the implementer of each new type so if you want,
you can count such references to the type object.)
*/

// #ifdef Py_REF_DEBUG
// #endif /* Py_REF_DEBUG */

@NoException public static native void _Py_Dealloc(PyObject arg0);

/*
These are provided as conveniences to Python runtime embedders, so that
they can have object code that is not dependent on Python compilation flags.
*/
@NoException public static native void Py_IncRef(PyObject arg0);
@NoException public static native void Py_DecRef(PyObject arg0);

// Similar to Py_IncRef() and Py_DecRef() but the argument must be non-NULL.
// Private functions used by Py_INCREF() and Py_DECREF().
@NoException public static native void _Py_IncRef(PyObject arg0);
@NoException public static native void _Py_DecRef(PyObject arg0);

@NoException public static native void _Py_INCREF(PyObject op);
// #define Py_INCREF(op) _Py_INCREF(_PyObject_CAST(op))

@NoException public static native void _Py_DECREF(
    PyObject op);
// #if defined(Py_REF_DEBUG) && !(defined(Py_LIMITED_API) && Py_LIMITED_API+0 >= 0x030A0000)
// #else
// #  define Py_DECREF(op) _Py_DECREF(_PyObject_CAST(op))
// #endif


/* Safely decref `op` and set `op` to NULL, especially useful in tp_clear
 * and tp_dealloc implementations.
 *
 * Note that "the obvious" code can be deadly:
 *
 *     Py_XDECREF(op);
 *     op = NULL;
 *
 * Typically, `op` is something like self->containee, and `self` is done
 * using its `containee` member.  In the code sequence above, suppose
 * `containee` is non-NULL with a refcount of 1.  Its refcount falls to
 * 0 on the first line, which can trigger an arbitrary amount of code,
 * possibly including finalizers (like __del__ methods or weakref callbacks)
 * coded in Python, which in turn can release the GIL and allow other threads
 * to run, etc.  Such code may even invoke methods of `self` again, or cause
 * cyclic gc to trigger, but-- oops! --self->containee still points to the
 * object being torn down, and it may be in an insane state while being torn
 * down.  This has in fact been a rich historic source of miserable (rare &
 * hard-to-diagnose) segfaulting (and other) bugs.
 *
 * The safe way is:
 *
 *      Py_CLEAR(op);
 *
 * That arranges to set `op` to NULL _before_ decref'ing, so that any code
 * triggered as a side-effect of `op` getting torn down no longer believes
 * `op` points to a valid object.
 *
 * There are cases where it's safe to use the naive code, but they're brittle.
 * For example, if `op` points to a Python integer, you know that destroying
 * one of those can't cause problems -- but in part that relies on that
 * Python integers aren't currently weakly referencable.  Best practice is
 * to use Py_CLEAR() even if you can't think of a reason for why you need to.
 */
// #define Py_CLEAR(op)
//     do {
//         PyObject *_py_tmp = _PyObject_CAST(op);
//         if (_py_tmp != NULL) {
//             (op) = NULL;
//             Py_DECREF(_py_tmp);
//         }
//     } while (0)

/* Function to use in case the object pointer can be NULL: */
@NoException public static native void _Py_XINCREF(PyObject op);

// #define Py_XINCREF(op) _Py_XINCREF(_PyObject_CAST(op))

@NoException public static native void _Py_XDECREF(PyObject op);

// #define Py_XDECREF(op) _Py_XDECREF(_PyObject_CAST(op))

// Create a new strong reference to an object:
// increment the reference count of the object and return the object.
@NoException public static native PyObject Py_NewRef(PyObject obj);

// Similar to Py_NewRef(), but the object can be NULL.
@NoException public static native PyObject Py_XNewRef(PyObject obj);

@NoException public static native PyObject _Py_NewRef(PyObject obj);

@NoException public static native PyObject _Py_XNewRef(PyObject obj);

// Py_NewRef() and Py_XNewRef() are exported as functions for the stable ABI.
// Names overridden with macros by static inline functions for best
// performances.
// #define Py_NewRef(obj) _Py_NewRef(_PyObject_CAST(obj))
// #define Py_XNewRef(obj) _Py_XNewRef(_PyObject_CAST(obj))


/*
_Py_NoneStruct is an object of undefined type which can be used in contexts
where NULL (nil) is not suitable (since NULL often means 'error').

Don't forget to apply Py_INCREF() when returning this value!!!
*/
public static native @ByRef PyObject _Py_NoneStruct(); public static native void _Py_NoneStruct(PyObject setter); /* Don't use this directly */
// #define Py_None (&_Py_NoneStruct)

// Test if an object is the None singleton, the same as "x is None" in Python.
@NoException public static native int Py_IsNone(PyObject x);
// #define Py_IsNone(x) Py_Is((x), Py_None)

/* Macro for returning Py_None from a function */
// #define Py_RETURN_NONE return Py_NewRef(Py_None)

/*
Py_NotImplemented is a singleton used to signal that an operation is
not implemented for a given type combination.
*/
public static native @ByRef PyObject _Py_NotImplementedStruct(); public static native void _Py_NotImplementedStruct(PyObject setter); /* Don't use this directly */
// #define Py_NotImplemented (&_Py_NotImplementedStruct)

/* Macro for returning Py_NotImplemented from a function */
// #define Py_RETURN_NOTIMPLEMENTED return Py_NewRef(Py_NotImplemented)

/* Rich comparison opcodes */
public static final int Py_LT = 0;
public static final int Py_LE = 1;
public static final int Py_EQ = 2;
public static final int Py_NE = 3;
public static final int Py_GT = 4;
public static final int Py_GE = 5;

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
/* Result of calling PyIter_Send */
/** enum PySendResult */
public static final int
    PYGEN_RETURN = 0,
    PYGEN_ERROR = -1,
    PYGEN_NEXT = 1;
// #endif

/*
 * Macro for implementing rich comparisons
 *
 * Needs to be a macro because any C-comparable type can be used.
 */
// #define Py_RETURN_RICHCOMPARE(val1, val2, op)
//     do {
//         switch (op) {
//         case Py_EQ: if ((val1) == (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;
//         case Py_NE: if ((val1) != (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;
//         case Py_LT: if ((val1) < (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;
//         case Py_GT: if ((val1) > (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;
//         case Py_LE: if ((val1) <= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;
//         case Py_GE: if ((val1) >= (val2)) Py_RETURN_TRUE; Py_RETURN_FALSE;
//         default:
//             Py_UNREACHABLE();
//         }
//     } while (0)


/*
More conventions
================

Argument Checking
-----------------

Functions that take objects as arguments normally don't check for nil
arguments, but they do check the type of the argument, and return an
error if the function doesn't apply to the type.

Failure Modes
-------------

Functions may fail for a variety of reasons, including running out of
memory.  This is communicated to the caller in two ways: an error string
is set (see errors.h), and the function result differs: functions that
normally return a pointer return NULL for failure, functions returning
an integer return -1 (which could be a legal return value too!), and
other functions return 0 for success and -1 for failure.
Callers should always check for errors before using the result.  If
an error was set, the caller must either explicitly clear it, or pass
the error on to its caller.

Reference Counts
----------------

It takes a while to get used to the proper usage of reference counts.

Functions that create an object set the reference count to 1; such new
objects must be stored somewhere or destroyed again with Py_DECREF().
Some functions that 'store' objects, such as PyTuple_SetItem() and
PyList_SetItem(),
don't increment the reference count of the object, since the most
frequent use is to store a fresh object.  Functions that 'retrieve'
objects, such as PyTuple_GetItem() and PyDict_GetItemString(), also
don't increment
the reference count, since most frequently the object is only looked at
quickly.  Thus, to retrieve an object and store it again, the caller
must call Py_INCREF() explicitly.

NOTE: functions that 'consume' a reference count, like
PyList_SetItem(), consume the reference even if the object wasn't
successfully stored, to simplify error handling.

It seems attractive to make other functions that take an object as
argument consume a reference count; however, this may quickly get
confusing (even the current practice is already confusing).  Consider
it carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at
times.
*/

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_OBJECT_H
// #  include  "cpython/object.h"
// #  undef Py_CPYTHON_OBJECT_H
// #endif


@NoException public static native int PyType_HasFeature(PyTypeObject type, @Cast("unsigned long") long feature);

// #define PyType_FastSubclass(type, flag) PyType_HasFeature(type, flag)

@NoException public static native int _PyType_Check(PyObject op);
// #define PyType_Check(op) _PyType_Check(_PyObject_CAST(op))

@NoException public static native int _PyType_CheckExact(PyObject op);
// #define PyType_CheckExact(op) _PyType_CheckExact(_PyObject_CAST(op))

// #ifdef __cplusplus
// #endif
// #endif /* !Py_OBJECT_H */


// Parsed from cpython/object.h

// #ifndef Py_CPYTHON_OBJECT_H
// #  error "this header file must not be included directly"
// #endif

@NoException public static native void _Py_NewReference(PyObject op);
// Targeting ../_Py_Identifier.java



// #define _Py_static_string_init(value) { .string = value, .index = -1 }
// #define _Py_static_string(varname, value)  static _Py_Identifier varname = _Py_static_string_init(value)
// #define _Py_IDENTIFIER(varname) _Py_static_string(PyId_##varname, #varname)
// Targeting ../Py_buffer.java


// Targeting ../getbufferproc.java


// Targeting ../releasebufferproc.java


// Targeting ../vectorcallfunc.java



/* Maximum number of dimensions */
public static final int PyBUF_MAX_NDIM = 64;

/* Flags for getting buffers */
public static final int PyBUF_SIMPLE = 0;
public static final int PyBUF_WRITABLE = 0x0001;
/*  we used to include an E, backwards compatible alias  */
public static final int PyBUF_WRITEABLE = PyBUF_WRITABLE;
public static final int PyBUF_FORMAT = 0x0004;
public static final int PyBUF_ND = 0x0008;
public static final int PyBUF_STRIDES = (0x0010 | PyBUF_ND);
public static final int PyBUF_C_CONTIGUOUS = (0x0020 | PyBUF_STRIDES);
public static final int PyBUF_F_CONTIGUOUS = (0x0040 | PyBUF_STRIDES);
public static final int PyBUF_ANY_CONTIGUOUS = (0x0080 | PyBUF_STRIDES);
public static final int PyBUF_INDIRECT = (0x0100 | PyBUF_STRIDES);

public static final int PyBUF_CONTIG = (PyBUF_ND | PyBUF_WRITABLE);
public static final int PyBUF_CONTIG_RO = (PyBUF_ND);

public static final int PyBUF_STRIDED = (PyBUF_STRIDES | PyBUF_WRITABLE);
public static final int PyBUF_STRIDED_RO = (PyBUF_STRIDES);

public static final int PyBUF_RECORDS = (PyBUF_STRIDES | PyBUF_WRITABLE | PyBUF_FORMAT);
public static final int PyBUF_RECORDS_RO = (PyBUF_STRIDES | PyBUF_FORMAT);

public static final int PyBUF_FULL = (PyBUF_INDIRECT | PyBUF_WRITABLE | PyBUF_FORMAT);
public static final int PyBUF_FULL_RO = (PyBUF_INDIRECT | PyBUF_FORMAT);


public static final int PyBUF_READ =  0x100;
public static final int PyBUF_WRITE = 0x200;
// Targeting ../PyNumberMethods.java


// Targeting ../PySequenceMethods.java


// Targeting ../PyMappingMethods.java


// Targeting ../sendfunc.java


// Targeting ../PyAsyncMethods.java


// Targeting ../PyBufferProcs.java



/* Allow printfunc in the tp_vectorcall_offset slot for
 * backwards-compatibility */
// Targeting ../PyTypeObject.java


// Targeting ../PyHeapTypeObject.java



/* access macro to the members which are floating "behind" the object */
// #define PyHeapType_GET_MEMBERS(etype)
//     ((PyMemberDef *)(((char *)etype) + Py_TYPE(etype)->tp_basicsize))

@NoException public static native @Cast("const char*") BytePointer _PyType_Name(PyTypeObject arg0);
@NoException public static native PyObject _PyType_Lookup(PyTypeObject arg0, PyObject arg1);
@NoException public static native PyObject _PyType_LookupId(PyTypeObject arg0, _Py_Identifier arg1);
@NoException public static native PyObject _PyObject_LookupSpecial(PyObject arg0, _Py_Identifier arg1);
@NoException public static native PyTypeObject _PyType_CalculateMetaclass(PyTypeObject arg0, PyObject arg1);
@NoException public static native PyObject _PyType_GetDocFromInternalDoc(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native PyObject _PyType_GetDocFromInternalDoc(String arg0, String arg1);
@NoException public static native PyObject _PyType_GetTextSignatureFromInternalDoc(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native PyObject _PyType_GetTextSignatureFromInternalDoc(String arg0, String arg1);
@NoException public static native PyObject _PyType_GetModuleByDef(PyTypeObject arg0, PyModuleDef arg1);
@NoException public static native int PyObject_Print(PyObject arg0, @Cast("FILE*") Pointer arg1, int arg2);
@NoException public static native void _Py_BreakPoint();
@NoException public static native void _PyObject_Dump(PyObject arg0);
@NoException public static native int _PyObject_IsFreed(PyObject arg0);

@NoException public static native int _PyObject_IsAbstract(PyObject arg0);
@NoException public static native PyObject _PyObject_GetAttrId(PyObject arg0, _Py_Identifier arg1);
@NoException public static native int _PyObject_SetAttrId(PyObject arg0, _Py_Identifier arg1, PyObject arg2);
/* Replacements of PyObject_GetAttr() and _PyObject_GetAttrId() which
   don't raise AttributeError.

   Return 1 and set *result != NULL if an attribute is found.
   Return 0 and set *result == NULL if an attribute is not found;
   an AttributeError is silenced.
   Return -1 and set *result == NULL if an error other than AttributeError
   is raised.
*/
@NoException public static native int _PyObject_LookupAttr(PyObject arg0, PyObject arg1, @Cast("PyObject**") PointerPointer arg2);
@NoException public static native int _PyObject_LookupAttr(PyObject arg0, PyObject arg1, @ByPtrPtr PyObject arg2);
@NoException public static native int _PyObject_LookupAttrId(PyObject arg0, _Py_Identifier arg1, @Cast("PyObject**") PointerPointer arg2);
@NoException public static native int _PyObject_LookupAttrId(PyObject arg0, _Py_Identifier arg1, @ByPtrPtr PyObject arg2);

@NoException public static native int _PyObject_GetMethod(PyObject obj, PyObject name, @Cast("PyObject**") PointerPointer method);
@NoException public static native int _PyObject_GetMethod(PyObject obj, PyObject name, @ByPtrPtr PyObject method);

@NoException public static native @Cast("PyObject**") PointerPointer _PyObject_GetDictPtr(PyObject arg0);
@NoException public static native PyObject _PyObject_NextNotImplemented(PyObject arg0);
@NoException public static native void PyObject_CallFinalizer(PyObject arg0);
@NoException public static native int PyObject_CallFinalizerFromDealloc(PyObject arg0);

/* Same as PyObject_Generic{Get,Set}Attr, but passing the attributes
   dict as the last parameter. */
@NoException public static native PyObject _PyObject_GenericGetAttrWithDict(PyObject arg0, PyObject arg1, PyObject arg2, int arg3);
@NoException public static native int _PyObject_GenericSetAttrWithDict(PyObject arg0, PyObject arg1,
                                 PyObject arg2, PyObject arg3);

@NoException public static native PyObject _PyObject_FunctionStr(PyObject arg0);

/* Safely decref `op` and set `op` to `op2`.
 *
 * As in case of Py_CLEAR "the obvious" code can be deadly:
 *
 *     Py_DECREF(op);
 *     op = op2;
 *
 * The safe way is:
 *
 *      Py_SETREF(op, op2);
 *
 * That arranges to set `op` to `op2` _before_ decref'ing, so that any code
 * triggered as a side-effect of `op` getting torn down no longer believes
 * `op` points to a valid object.
 *
 * Py_XSETREF is a variant of Py_SETREF that uses Py_XDECREF instead of
 * Py_DECREF.
 */

// #define Py_SETREF(op, op2)
//     do {
//         PyObject *_py_tmp = _PyObject_CAST(op);
//         (op) = (op2);
//         Py_DECREF(_py_tmp);
//     } while (0)

// #define Py_XSETREF(op, op2)
//     do {
//         PyObject *_py_tmp = _PyObject_CAST(op);
//         (op) = (op2);
//         Py_XDECREF(_py_tmp);
//     } while (0)


public static native @ByRef PyTypeObject _PyNone_Type(); public static native void _PyNone_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject _PyNotImplemented_Type(); public static native void _PyNotImplemented_Type(PyTypeObject setter);

/* Maps Py_LT to Py_GT, ..., Py_GE to Py_LE.
 * Defined in object.c.
 */
public static native int _Py_SwappedOp(int i); public static native void _Py_SwappedOp(int i, int setter);
@MemberGetter public static native IntPointer _Py_SwappedOp();

@NoException public static native void _PyDebugAllocatorStats(@Cast("FILE*") Pointer out, @Cast("const char*") BytePointer block_name, int num_blocks,
                       @Cast("size_t") long sizeof_block);
@NoException public static native void _PyDebugAllocatorStats(@Cast("FILE*") Pointer out, String block_name, int num_blocks,
                       @Cast("size_t") long sizeof_block);
@NoException public static native void _PyObject_DebugTypeStats(@Cast("FILE*") Pointer out);

/* Define a pair of assertion macros:
   _PyObject_ASSERT_FROM(), _PyObject_ASSERT_WITH_MSG() and _PyObject_ASSERT().

   These work like the regular C assert(), in that they will abort the
   process with a message on stderr if the given condition fails to hold,
   but compile away to nothing if NDEBUG is defined.

   However, before aborting, Python will also try to call _PyObject_Dump() on
   the given object.  This may be of use when investigating bugs in which a
   particular object is corrupt (e.g. buggy a tp_visit method in an extension
   module breaking the garbage collector), to help locate the broken objects.

   The WITH_MSG variant allows you to supply an additional message that Python
   will attempt to print to stderr, after the object dump. */
// #ifdef NDEBUG
   /* No debugging: compile away the assertions: */
// #  define _PyObject_ASSERT_FROM(obj, expr, msg, filename, lineno, func)
//     ((void)0)
// #else
   /* With debugging: generate checks: */
// #  define _PyObject_ASSERT_FROM(obj, expr, msg, filename, lineno, func)
//     ((expr)
//       ? (void)(0)
//       : _PyObject_AssertFailed((obj), Py_STRINGIFY(expr),
//                                (msg), (filename), (lineno), (func)))
// #endif

// #define _PyObject_ASSERT_WITH_MSG(obj, expr, msg)
//     _PyObject_ASSERT_FROM(obj, expr, msg, __FILE__, __LINE__, __func__)
// #define _PyObject_ASSERT(obj, expr)
//     _PyObject_ASSERT_WITH_MSG(obj, expr, NULL)

// #define _PyObject_ASSERT_FAILED_MSG(obj, msg)
//     _PyObject_AssertFailed((obj), NULL, (msg), __FILE__, __LINE__, __func__)

/* Declare and define _PyObject_AssertFailed() even when NDEBUG is defined,
   to avoid causing compiler/linker errors when building extensions without
   NDEBUG against a Python built with NDEBUG defined.

   msg, expr and function can be NULL. */
@NoException public static native void _PyObject_AssertFailed(
    PyObject obj,
    @Cast("const char*") BytePointer expr,
    @Cast("const char*") BytePointer msg,
    @Cast("const char*") BytePointer file,
    int line,
    @Cast("const char*") BytePointer function);
@NoException public static native void _PyObject_AssertFailed(
    PyObject obj,
    String expr,
    String msg,
    String file,
    int line,
    String function);

/* Check if an object is consistent. For example, ensure that the reference
   counter is greater than or equal to 1, and ensure that ob_type is not NULL.

   Call _PyObject_AssertFailed() if the object is inconsistent.

   If check_content is zero, only check header fields: reduce the overhead.

   The function always return 1. The return value is just here to be able to
   write:

   assert(_PyObject_CheckConsistency(obj, 1)); */
@NoException public static native int _PyObject_CheckConsistency(
    PyObject op,
    int check_content);


/* Trashcan mechanism, thanks to Christian Tismer.

When deallocating a container object, it's possible to trigger an unbounded
chain of deallocations, as each Py_DECREF in turn drops the refcount on "the
next" object in the chain to 0.  This can easily lead to stack overflows,
especially in threads (which typically have less stack space to work with).

A container object can avoid this by bracketing the body of its tp_dealloc
function with a pair of macros:

static void
mytype_dealloc(mytype *p)
{
    ... declarations go here ...

    PyObject_GC_UnTrack(p);        // must untrack first
    Py_TRASHCAN_BEGIN(p, mytype_dealloc)
    ... The body of the deallocator goes here, including all calls ...
    ... to Py_DECREF on contained objects.                         ...
    Py_TRASHCAN_END                // there should be no code after this
}

CAUTION:  Never return from the middle of the body!  If the body needs to
"get out early", put a label immediately before the Py_TRASHCAN_END
call, and goto it.  Else the call-depth counter (see below) will stay
above 0 forever, and the trashcan will never get emptied.

How it works:  The BEGIN macro increments a call-depth counter.  So long
as this counter is small, the body of the deallocator is run directly without
further ado.  But if the counter gets large, it instead adds p to a list of
objects to be deallocated later, skips the body of the deallocator, and
resumes execution after the END macro.  The tp_dealloc routine then returns
without deallocating anything (and so unbounded call-stack depth is avoided).

When the call stack finishes unwinding again, code generated by the END macro
notices this, and calls another routine to deallocate all the objects that
may have been added to the list of deferred deallocations.  In effect, a
chain of N deallocations is broken into (N-1)/(PyTrash_UNWIND_LEVEL-1) pieces,
with the call stack never exceeding a depth of PyTrash_UNWIND_LEVEL.

Since the tp_dealloc of a subclass typically calls the tp_dealloc of the base
class, we need to ensure that the trashcan is only triggered on the tp_dealloc
of the actual class being deallocated. Otherwise we might end up with a
partially-deallocated object. To check this, the tp_dealloc function must be
passed as second argument to Py_TRASHCAN_BEGIN().
*/

/* This is the old private API, invoked by the macros before 3.2.4.
   Kept for binary compatibility of extensions using the stable ABI. */
@NoException public static native void _PyTrash_deposit_object(PyObject arg0);
@NoException public static native void _PyTrash_destroy_chain();

/* This is the old private API, invoked by the macros before 3.9.
   Kept for binary compatibility of extensions using the stable ABI. */
@NoException public static native void _PyTrash_thread_deposit_object(PyObject arg0);
@NoException public static native void _PyTrash_thread_destroy_chain();

/* Forward declarations for PyThreadState */

/* Python 3.9 private API, invoked by the macros below. */
@NoException public static native int _PyTrash_begin(@Cast("_ts*") PyThreadState tstate, PyObject op);
@NoException public static native void _PyTrash_end(@Cast("_ts*") PyThreadState tstate);
/* Python 3.10 private API, invoked by the Py_TRASHCAN_BEGIN(). */
@NoException public static native int _PyTrash_cond(PyObject op, destructor dealloc);

public static final int PyTrash_UNWIND_LEVEL = 50;

// #define Py_TRASHCAN_BEGIN_CONDITION(op, cond)
//     do {
//         PyThreadState *_tstate = NULL;
//         /* If "cond" is false, then _tstate remains NULL and the deallocator \
//         * is run normally without involving the trashcan */
//         if (cond) {
//             _tstate = PyThreadState_Get();
//             if (_PyTrash_begin(_tstate, _PyObject_CAST(op))) {
//                 break;
//             }
//         }
        /* The body of the deallocator is here. */
// #define Py_TRASHCAN_END
//         if (_tstate) {
//             _PyTrash_end(_tstate);
//         }
//     } while (0);

// #define Py_TRASHCAN_BEGIN(op, dealloc)
//     Py_TRASHCAN_BEGIN_CONDITION(op,
//         _PyTrash_cond(_PyObject_CAST(op), (destructor)dealloc))

/* For backwards compatibility, these macros enable the trashcan
 * unconditionally */
// #define Py_TRASHCAN_SAFE_BEGIN(op) Py_TRASHCAN_BEGIN_CONDITION(op, 1)
// #define Py_TRASHCAN_SAFE_END(op) Py_TRASHCAN_END


// Parsed from objimpl.h

/* The PyObject_ memory family:  high-level object memory interfaces.
   See pymem.h for the low-level PyMem_ family.
*/

// #ifndef Py_OBJIMPL_H
// #define Py_OBJIMPL_H

// #include "pymem.h"

// #ifdef __cplusplus
// #endif

/* BEWARE:

   Each interface exports both functions and macros.  Extension modules should
   use the functions, to ensure binary compatibility across Python versions.
   Because the Python implementation is free to change internal details, and
   the macros may (or may not) expose details for speed, if you do use the
   macros you must recompile your extensions with each Python release.

   Never mix calls to PyObject_ memory functions with calls to the platform
   malloc/realloc/ calloc/free, or with calls to PyMem_.
*/

/*
Functions and macros for modules that implement new object types.

 - PyObject_New(type, typeobj) allocates memory for a new object of the given
   type, and initializes part of it.  'type' must be the C structure type used
   to represent the object, and 'typeobj' the address of the corresponding
   type object.  Reference count and type pointer are filled in; the rest of
   the bytes of the object are *undefined*!  The resulting expression type is
   'type *'.  The size of the object is determined by the tp_basicsize field
   of the type object.

 - PyObject_NewVar(type, typeobj, n) is similar but allocates a variable-size
   object with room for n items.  In addition to the refcount and type pointer
   fields, this also fills in the ob_size field.

 - PyObject_Free(op) releases the memory allocated for an object.  It does not
   run a destructor -- it only frees the memory.  PyObject_Free is identical.

 - PyObject_Init(op, typeobj) and PyObject_InitVar(op, typeobj, n) don't
   allocate memory.  Instead of a 'type' parameter, they take a pointer to a
   new object (allocated by an arbitrary allocator), and initialize its object
   header fields.

Note that objects created with PyObject_{New, NewVar} are allocated using the
specialized Python allocator (implemented in obmalloc.c), if WITH_PYMALLOC is
enabled.  In addition, a special debugging allocator is used if Py_DEBUG
macro is also defined.

In case a specific form of memory management is needed (for example, if you
must use the platform malloc heap(s), or shared memory, or C++ local storage or
operator new), you must first allocate the object with your custom allocator,
then pass its pointer to PyObject_{Init, InitVar} for filling in its Python-
specific fields:  reference count, type pointer, possibly others.  You should
be aware that Python has no control over these objects because they don't
cooperate with the Python memory manager.  Such objects may not be eligible
for automatic garbage collection and you have to make sure that they are
released accordingly whenever their destructor gets called (cf. the specific
form of memory management you're using).

Unless you have specific memory management requirements, use
PyObject_{New, NewVar, Del}.
*/

/*
 * Raw object memory interface
 * ===========================
 */

/* Functions to call the same malloc/realloc/free as used by Python's
   object allocator.  If WITH_PYMALLOC is enabled, these may differ from
   the platform malloc/realloc/free.  The Python object allocator is
   designed for fast, cache-conscious allocation of many "small" objects,
   and with low hidden memory overhead.

   PyObject_Malloc(0) returns a unique non-NULL pointer if possible.

   PyObject_Realloc(NULL, n) acts like PyObject_Malloc(n).
   PyObject_Realloc(p != NULL, 0) does not return  NULL, or free the memory
   at p.

   Returned pointers must be checked for NULL explicitly; no action is
   performed on failure other than to return NULL (no warning it printed, no
   exception is set, etc).

   For allocating objects, use PyObject_{New, NewVar} instead whenever
   possible.  The PyObject_{Malloc, Realloc, Free} family is exposed
   so that you can exploit Python's small-block allocator for non-object
   uses.  If you must use these routines to allocate object memory, make sure
   the object gets initialized via PyObject_{Init, InitVar} after obtaining
   the raw memory.
*/
@NoException public static native Pointer PyObject_Malloc(@Cast("size_t") long size);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
@NoException public static native Pointer PyObject_Calloc(@Cast("size_t") long nelem, @Cast("size_t") long elsize);
// #endif
@NoException public static native Pointer PyObject_Realloc(Pointer ptr, @Cast("size_t") long new_size);
@NoException public static native void PyObject_Free(Pointer ptr);


// Deprecated aliases only kept for backward compatibility.
// PyObject_Del and PyObject_DEL are defined with no parameter to be able to
// use them as function pointers (ex: tp_free = PyObject_Del).
// #define PyObject_MALLOC         PyObject_Malloc
// #define PyObject_REALLOC        PyObject_Realloc
// #define PyObject_FREE           PyObject_Free
// #define PyObject_Del            PyObject_Free
// #define PyObject_DEL            PyObject_Free


/*
 * Generic object allocator interface
 * ==================================
 */

/* Functions */
@NoException public static native PyObject PyObject_Init(PyObject arg0, PyTypeObject arg1);
@NoException public static native PyVarObject PyObject_InitVar(PyVarObject arg0,
                                           PyTypeObject arg1, @Cast("Py_ssize_t") long arg2);

// #define PyObject_INIT(op, typeobj)
//     PyObject_Init(_PyObject_CAST(op), (typeobj))
// #define PyObject_INIT_VAR(op, typeobj, size)
//     PyObject_InitVar(_PyVarObject_CAST(op), (typeobj), (size))


@NoException public static native PyObject _PyObject_New(PyTypeObject arg0);
@NoException public static native PyVarObject _PyObject_NewVar(PyTypeObject arg0, @Cast("Py_ssize_t") long arg1);

// #define PyObject_New(type, typeobj) ((type *)_PyObject_New(typeobj))

// Alias to PyObject_New(). In Python 3.8, PyObject_NEW() called directly
// PyObject_MALLOC() with _PyObject_SIZE().
// #define PyObject_NEW(type, typeobj) PyObject_New(type, typeobj)

// #define PyObject_NewVar(type, typeobj, n)
//                 ( (type *) _PyObject_NewVar((typeobj), (n)) )

// Alias to PyObject_NewVar(). In Python 3.8, PyObject_NEW_VAR() called
// directly PyObject_MALLOC() with _PyObject_VAR_SIZE().
// #define PyObject_NEW_VAR(type, typeobj, n) PyObject_NewVar(type, typeobj, n)


/*
 * Garbage Collection Support
 * ==========================
 */

/* C equivalent of gc.collect(). */
@NoException public static native @Cast("Py_ssize_t") long PyGC_Collect();
/* C API for controlling the state of the garbage collector */
@NoException public static native int PyGC_Enable();
@NoException public static native int PyGC_Disable();
@NoException public static native int PyGC_IsEnabled();

/* Test if a type has a GC head */
// #define PyType_IS_GC(t) PyType_HasFeature((t), Py_TPFLAGS_HAVE_GC)

@NoException public static native PyVarObject _PyObject_GC_Resize(PyVarObject arg0, @Cast("Py_ssize_t") long arg1);
// #define PyObject_GC_Resize(type, op, n)
//                 ( (type *) _PyObject_GC_Resize(_PyVarObject_CAST(op), (n)) )



@NoException public static native PyObject _PyObject_GC_New(PyTypeObject arg0);
@NoException public static native PyVarObject _PyObject_GC_NewVar(PyTypeObject arg0, @Cast("Py_ssize_t") long arg1);

/* Tell the GC to track this object.
 *
 * See also private _PyObject_GC_TRACK() macro. */
@NoException public static native void PyObject_GC_Track(Pointer arg0);

/* Tell the GC to stop tracking this object.
 *
 * See also private _PyObject_GC_UNTRACK() macro. */
@NoException public static native void PyObject_GC_UnTrack(Pointer arg0);

@NoException public static native void PyObject_GC_Del(Pointer arg0);

// #define PyObject_GC_New(type, typeobj)
//                 ( (type *) _PyObject_GC_New(typeobj) )
// #define PyObject_GC_NewVar(type, typeobj, n)
//                 ( (type *) _PyObject_GC_NewVar((typeobj), (n)) )

@NoException public static native int PyObject_GC_IsTracked(PyObject arg0);
@NoException public static native int PyObject_GC_IsFinalized(PyObject arg0);

/* Utility macro to help write tp_traverse functions.
 * To use this macro, the tp_traverse function must name its arguments
 * "visit" and "arg".  This is intended to keep tp_traverse functions
 * looking as much alike as possible.
 */
// #define Py_VISIT(op)
//     do {
//         if (op) {
//             int vret = visit(_PyObject_CAST(op), arg);
//             if (vret)
//                 return vret;
//         }
//     } while (0)

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_OBJIMPL_H
// #  include  "cpython/objimpl.h"
// #  undef Py_CPYTHON_OBJIMPL_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_OBJIMPL_H */


// Parsed from cpython/objimpl.h

// #ifndef Py_CPYTHON_OBJIMPL_H
// #  error "this header file must not be included directly"
// #endif

// #define _PyObject_SIZE(typeobj) ( (typeobj)->tp_basicsize )

/* _PyObject_VAR_SIZE returns the number of bytes (as size_t) allocated for a
   vrbl-size object with nitems items, exclusive of gc overhead (if any).  The
   value is rounded up to the closest multiple of sizeof(void *), in order to
   ensure that pointer fields at the end of the object are correctly aligned
   for the platform (this is of special importance for subclasses of, e.g.,
   str or int, so that pointers can be stored after the embedded data).

   Note that there's no memory wastage in doing this, as malloc has to
   return (at worst) pointer-aligned memory anyway.
*/
// #if ((SIZEOF_VOID_P - 1) & SIZEOF_VOID_P) != 0
// #   error "_PyObject_VAR_SIZE requires SIZEOF_VOID_P be a power of 2"
// #endif

// #define _PyObject_VAR_SIZE(typeobj, nitems)
//     _Py_SIZE_ROUND_UP((typeobj)->tp_basicsize +
//         (nitems)*(typeobj)->tp_itemsize,
//         SIZEOF_VOID_P)


/* This example code implements an object constructor with a custom
   allocator, where PyObject_New is inlined, and shows the important
   distinction between two steps (at least):
       1) the actual allocation of the object storage;
       2) the initialization of the Python specific fields
      in this storage with PyObject_{Init, InitVar}.

   PyObject *
   YourObject_New(...)
   {
       PyObject *op;

       op = (PyObject *) Your_Allocator(_PyObject_SIZE(YourTypeStruct));
       if (op == NULL) {
           return PyErr_NoMemory();
       }

       PyObject_Init(op, &YourTypeStruct);

       op->ob_field = value;
       ...
       return op;
   }

   Note that in C++, the use of the new operator usually implies that
   the 1st step is performed automatically for you, so in a C++ class
   constructor you would start directly with PyObject_Init/InitVar. */

/* This function returns the number of allocated memory blocks, regardless of size */
@NoException public static native @Cast("Py_ssize_t") long _Py_GetAllocatedBlocks();

/* Macros */
// #ifdef WITH_PYMALLOC
@NoException public static native int _PyObject_DebugMallocStats(@Cast("FILE*") Pointer out);
// Targeting ../PyObjectArenaAllocator.java



/* Get the arena allocator. */
@NoException public static native void PyObject_GetArenaAllocator(PyObjectArenaAllocator allocator);

/* Set the arena allocator. */
@NoException public static native void PyObject_SetArenaAllocator(PyObjectArenaAllocator allocator);


/* Test if an object implements the garbage collector protocol */
@NoException public static native int PyObject_IS_GC(PyObject obj);


/* Code built with Py_BUILD_CORE must include pycore_gc.h instead which
   defines a different _PyGC_FINALIZED() macro. */
// #ifndef Py_BUILD_CORE
   // Kept for backward compatibility with Python 3.8
// #  define _PyGC_FINALIZED(o) PyObject_GC_IsFinalized(o)
// #endif

@NoException public static native PyObject _PyObject_GC_Malloc(@Cast("size_t") long size);
@NoException public static native PyObject _PyObject_GC_Calloc(@Cast("size_t") long size);


/* Test if a type supports weak references */
// #define PyType_SUPPORTS_WEAKREFS(t) ((t)->tp_weaklistoffset > 0)

@NoException public static native @Cast("PyObject**") PointerPointer PyObject_GET_WEAKREFS_LISTPTR(PyObject op);


// Parsed from typeslots.h

/* Do not renumber the file; these numbers are part of the stable ABI. */
// #if defined(Py_LIMITED_API)
/* Disabled, see #10181 */
// #undef Py_bf_getbuffer
// #undef Py_bf_releasebuffer
// #else
public static final int Py_bf_getbuffer = 1;
public static final int Py_bf_releasebuffer = 2;
// #endif
public static final int Py_mp_ass_subscript = 3;
public static final int Py_mp_length = 4;
public static final int Py_mp_subscript = 5;
public static final int Py_nb_absolute = 6;
public static final int Py_nb_add = 7;
public static final int Py_nb_and = 8;
public static final int Py_nb_bool = 9;
public static final int Py_nb_divmod = 10;
public static final int Py_nb_float = 11;
public static final int Py_nb_floor_divide = 12;
public static final int Py_nb_index = 13;
public static final int Py_nb_inplace_add = 14;
public static final int Py_nb_inplace_and = 15;
public static final int Py_nb_inplace_floor_divide = 16;
public static final int Py_nb_inplace_lshift = 17;
public static final int Py_nb_inplace_multiply = 18;
public static final int Py_nb_inplace_or = 19;
public static final int Py_nb_inplace_power = 20;
public static final int Py_nb_inplace_remainder = 21;
public static final int Py_nb_inplace_rshift = 22;
public static final int Py_nb_inplace_subtract = 23;
public static final int Py_nb_inplace_true_divide = 24;
public static final int Py_nb_inplace_xor = 25;
public static final int Py_nb_int = 26;
public static final int Py_nb_invert = 27;
public static final int Py_nb_lshift = 28;
public static final int Py_nb_multiply = 29;
public static final int Py_nb_negative = 30;
public static final int Py_nb_or = 31;
public static final int Py_nb_positive = 32;
public static final int Py_nb_power = 33;
public static final int Py_nb_remainder = 34;
public static final int Py_nb_rshift = 35;
public static final int Py_nb_subtract = 36;
public static final int Py_nb_true_divide = 37;
public static final int Py_nb_xor = 38;
public static final int Py_sq_ass_item = 39;
public static final int Py_sq_concat = 40;
public static final int Py_sq_contains = 41;
public static final int Py_sq_inplace_concat = 42;
public static final int Py_sq_inplace_repeat = 43;
public static final int Py_sq_item = 44;
public static final int Py_sq_length = 45;
public static final int Py_sq_repeat = 46;
public static final int Py_tp_alloc = 47;
public static final int Py_tp_base = 48;
public static final int Py_tp_bases = 49;
public static final int Py_tp_call = 50;
public static final int Py_tp_clear = 51;
public static final int Py_tp_dealloc = 52;
public static final int Py_tp_del = 53;
public static final int Py_tp_descr_get = 54;
public static final int Py_tp_descr_set = 55;
public static final int Py_tp_doc = 56;
public static final int Py_tp_getattr = 57;
public static final int Py_tp_getattro = 58;
public static final int Py_tp_hash = 59;
public static final int Py_tp_init = 60;
public static final int Py_tp_is_gc = 61;
public static final int Py_tp_iter = 62;
public static final int Py_tp_iternext = 63;
public static final int Py_tp_methods = 64;
public static final int Py_tp_new = 65;
public static final int Py_tp_repr = 66;
public static final int Py_tp_richcompare = 67;
public static final int Py_tp_setattr = 68;
public static final int Py_tp_setattro = 69;
public static final int Py_tp_str = 70;
public static final int Py_tp_traverse = 71;
public static final int Py_tp_members = 72;
public static final int Py_tp_getset = 73;
public static final int Py_tp_free = 74;
public static final int Py_nb_matrix_multiply = 75;
public static final int Py_nb_inplace_matrix_multiply = 76;
public static final int Py_am_await = 77;
public static final int Py_am_aiter = 78;
public static final int Py_am_anext = 79;
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* New in 3.5 */
public static final int Py_tp_finalize = 80;
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
/* New in 3.10 */
public static final int Py_am_send = 81;
// #endif


// Parsed from pyhash.h

// #ifndef Py_HASH_H

// #define Py_HASH_H
// #ifdef __cplusplus
// #endif

/* Helpers for hash functions */
// #ifndef Py_LIMITED_API
@NoException public static native @Cast("Py_hash_t") long _Py_HashDouble(PyObject arg0, double arg1);
@NoException public static native @Cast("Py_hash_t") long _Py_HashPointer(@Const Pointer arg0);
// Similar to _Py_HashPointer(), but don't replace -1 with -2
@NoException public static native @Cast("Py_hash_t") long _Py_HashPointerRaw(@Const Pointer arg0);
@NoException public static native @Cast("Py_hash_t") long _Py_HashBytes(@Const Pointer arg0, @Cast("Py_ssize_t") long arg1);
// #endif

/* Prime multiplier used in string and various other hashes. */
public static final long _PyHASH_MULTIPLIER = 1000003L;  /* 0xf4243 */

/* Parameters used for the numeric hash implementation.  See notes for
   _Py_HashDouble in Python/pyhash.c.  Numeric hashes are based on
   reduction modulo the prime 2**_PyHASH_BITS - 1. */

// #if SIZEOF_VOID_P >= 8
public static final int _PyHASH_BITS = 61;
// #else
// #endif

public static final long _PyHASH_MODULUS = (((long)1 << _PyHASH_BITS) - 1);
public static final int _PyHASH_INF = 314159;
public static final long _PyHASH_IMAG = _PyHASH_MULTIPLIER;
// Targeting ../_Py_HashSecret_t.java


public static native @ByRef _Py_HashSecret_t _Py_HashSecret(); public static native void _Py_HashSecret(_Py_HashSecret_t setter);
// Targeting ../PyHash_FuncDef.java



@NoException public static native PyHash_FuncDef PyHash_GetFuncDef();
// #endif


/* cutoff for small string DJBX33A optimization in range [1, cutoff).
 *
 * About 50% of the strings in a typical Python application are smaller than
 * 6 to 7 chars. However DJBX33A is vulnerable to hash collision attacks.
 * NEVER use DJBX33A for long strings!
 *
 * A Py_HASH_CUTOFF of 0 disables small string optimization. 32 bit platforms
 * should use a smaller cutoff because it is easier to create colliding
 * strings. A cutoff of 7 on 64bit platforms and 5 on 32bit platforms should
 * provide a decent safety margin.
 */
// #ifndef Py_HASH_CUTOFF
public static final int Py_HASH_CUTOFF = 0;
// #elif (Py_HASH_CUTOFF > 7 || Py_HASH_CUTOFF < 0)
// #  error Py_HASH_CUTOFF must in range 0...7.
// #endif /* Py_HASH_CUTOFF */


/* hash algorithm selection
 *
 * The values for Py_HASH_SIPHASH24 and Py_HASH_FNV are hard-coded in the
 * configure script.
 *
 * - FNV is available on all platforms and architectures.
 * - SIPHASH24 only works on platforms that don't require aligned memory for integers.
 * - With EXTERNAL embedders can provide an alternative implementation with::
 *
 *     PyHash_FuncDef PyHash_Func = {...};
 *
 * XXX: Figure out __declspec() for extern PyHash_FuncDef.
 */
public static final int Py_HASH_EXTERNAL = 0;
public static final int Py_HASH_SIPHASH24 = 1;
public static final int Py_HASH_FNV = 2;

// #ifndef Py_HASH_ALGORITHM
// #  ifndef HAVE_ALIGNED_REQUIRED
public static final int Py_HASH_ALGORITHM = Py_HASH_SIPHASH24;
// #  else
// #  endif /* uint64_t && uint32_t && aligned */
// #endif /* Py_HASH_ALGORITHM */

// #ifdef __cplusplus
// #endif

// #endif /* !Py_HASH_H */


// Parsed from cpython/pydebug.h

// #ifndef Py_LIMITED_API
// #ifndef Py_PYDEBUG_H
// #define Py_PYDEBUG_H
// #ifdef __cplusplus
// #endif

public static native int Py_DebugFlag(); public static native void Py_DebugFlag(int setter);
public static native int Py_VerboseFlag(); public static native void Py_VerboseFlag(int setter);
public static native int Py_QuietFlag(); public static native void Py_QuietFlag(int setter);
public static native int Py_InteractiveFlag(); public static native void Py_InteractiveFlag(int setter);
public static native int Py_InspectFlag(); public static native void Py_InspectFlag(int setter);
public static native int Py_OptimizeFlag(); public static native void Py_OptimizeFlag(int setter);
public static native int Py_NoSiteFlag(); public static native void Py_NoSiteFlag(int setter);
public static native int Py_BytesWarningFlag(); public static native void Py_BytesWarningFlag(int setter);
public static native int Py_FrozenFlag(); public static native void Py_FrozenFlag(int setter);
public static native int Py_IgnoreEnvironmentFlag(); public static native void Py_IgnoreEnvironmentFlag(int setter);
public static native int Py_DontWriteBytecodeFlag(); public static native void Py_DontWriteBytecodeFlag(int setter);
public static native int Py_NoUserSiteDirectory(); public static native void Py_NoUserSiteDirectory(int setter);
public static native int Py_UnbufferedStdioFlag(); public static native void Py_UnbufferedStdioFlag(int setter);
public static native int Py_HashRandomizationFlag(); public static native void Py_HashRandomizationFlag(int setter);
public static native int Py_IsolatedFlag(); public static native void Py_IsolatedFlag(int setter);

// #ifdef MS_WINDOWS
// #endif

/* this is a wrapper around getenv() that pays attention to
   Py_IgnoreEnvironmentFlag.  It should be used for getting variables like
   PYTHONPATH and PYTHONHOME from the environment */
// #define Py_GETENV(s) (Py_IgnoreEnvironmentFlag ? NULL : getenv(s))

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYDEBUG_H */
// #endif /* Py_LIMITED_API */


// Parsed from descrobject.h

/* Descriptors */
// #ifndef Py_DESCROBJECT_H
// #define Py_DESCROBJECT_H
// #ifdef __cplusplus
// Targeting ../getter.java


// Targeting ../setter.java


// Targeting ../PyGetSetDef.java


// Targeting ../wrapperfunc.java


// Targeting ../wrapperfunc_kwds.java


// Targeting ../wrapperbase.java



/* Flags for above struct */
public static final int PyWrapperFlag_KEYWORDS = 1;
// Targeting ../PyDescrObject.java



// #define PyDescr_COMMON PyDescrObject d_common

// #define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
// #define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
// Targeting ../PyMethodDescrObject.java


// Targeting ../PyMemberDescrObject.java


// Targeting ../PyGetSetDescrObject.java


// Targeting ../PyWrapperDescrObject.java


// #endif /* Py_LIMITED_API */

public static native @ByRef PyTypeObject PyClassMethodDescr_Type(); public static native void PyClassMethodDescr_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyGetSetDescr_Type(); public static native void PyGetSetDescr_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyMemberDescr_Type(); public static native void PyMemberDescr_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyMethodDescr_Type(); public static native void PyMethodDescr_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyWrapperDescr_Type(); public static native void PyWrapperDescr_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyDictProxy_Type(); public static native void PyDictProxy_Type(PyTypeObject setter);
// #ifndef Py_LIMITED_API
public static native @ByRef PyTypeObject _PyMethodWrapper_Type(); public static native void _PyMethodWrapper_Type(PyTypeObject setter);
// #endif /* Py_LIMITED_API */

@NoException public static native PyObject PyDescr_NewMethod(PyTypeObject arg0, PyMethodDef arg1);
@NoException public static native PyObject PyDescr_NewClassMethod(PyTypeObject arg0, PyMethodDef arg1); /* forward declaration for following prototype */
@NoException public static native PyObject PyDescr_NewMember(PyTypeObject arg0,
                                               PyMemberDef arg1);
@NoException public static native PyObject PyDescr_NewGetSet(PyTypeObject arg0,
                                               PyGetSetDef arg1);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyDescr_NewWrapper(PyTypeObject arg0,
                                                wrapperbase arg1, Pointer arg2);
@NoException public static native int PyDescr_IsData(PyObject arg0);
// #endif

@NoException public static native PyObject PyDictProxy_New(PyObject arg0);
@NoException public static native PyObject PyWrapper_New(PyObject arg0, PyObject arg1);


public static native @ByRef PyTypeObject PyProperty_Type(); public static native void PyProperty_Type(PyTypeObject setter);
// #ifdef __cplusplus
// #endif
// #endif /* !Py_DESCROBJECT_H */



// Parsed from bytearrayobject.h

/* ByteArray object interface */

// #ifndef Py_BYTEARRAYOBJECT_H
// #define Py_BYTEARRAYOBJECT_H
// #ifdef __cplusplus
// #endif

// #include <stdarg.h>

/* Type PyByteArrayObject represents a mutable array of bytes.
 * The Python API is that of a sequence;
 * the bytes are mapped to ints in [0, 256).
 * Bytes are not characters; they may be used to encode characters.
 * The only way to go between bytes and str/unicode is via encoding
 * and decoding.
 * For the convenience of C programmers, the bytes type is considered
 * to contain a char pointer, not an unsigned char pointer.
 */

/* Type object */
public static native @ByRef PyTypeObject PyByteArray_Type(); public static native void PyByteArray_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyByteArrayIter_Type(); public static native void PyByteArrayIter_Type(PyTypeObject setter);

/* Type check macros */
// #define PyByteArray_Check(self) PyObject_TypeCheck(self, &PyByteArray_Type)
// #define PyByteArray_CheckExact(self) Py_IS_TYPE(self, &PyByteArray_Type)

/* Direct API functions */
@NoException public static native PyObject PyByteArray_FromObject(PyObject arg0);
@NoException public static native PyObject PyByteArray_Concat(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyByteArray_FromStringAndSize(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native PyObject PyByteArray_FromStringAndSize(String arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native @Cast("Py_ssize_t") long PyByteArray_Size(PyObject arg0);
@NoException public static native @Cast("char*") BytePointer PyByteArray_AsString(PyObject arg0);
@NoException public static native int PyByteArray_Resize(PyObject arg0, @Cast("Py_ssize_t") long arg1);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_BYTEARRAYOBJECT_H
// #  include  "cpython/bytearrayobject.h"
// #  undef Py_CPYTHON_BYTEARRAYOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_BYTEARRAYOBJECT_H */


// Parsed from cpython/bytearrayobject.h

// #ifndef Py_CPYTHON_BYTEARRAYOBJECT_H
// #  error "this header file must not be included directly"
// Targeting ../PyByteArrayObject.java



/* Macros, trading safety for speed */
// #define PyByteArray_AS_STRING(self)
//     (assert(PyByteArray_Check(self)),
//      Py_SIZE(self) ? ((PyByteArrayObject *)(self))->ob_start : _PyByteArray_empty_string)
// #define PyByteArray_GET_SIZE(self) (assert(PyByteArray_Check(self)), Py_SIZE(self))

public static native @Cast("char") byte _PyByteArray_empty_string(int i); public static native void _PyByteArray_empty_string(int i, byte setter);
@MemberGetter public static native @Cast("char*") BytePointer _PyByteArray_empty_string();


// Parsed from bytesobject.h


/* Bytes object interface */

// #ifndef Py_BYTESOBJECT_H
// #define Py_BYTESOBJECT_H
// #ifdef __cplusplus
// #endif

// #include <stdarg.h>

/*
Type PyBytesObject represents a byte string.  An extra zero byte is
reserved at the end to ensure it is zero-terminated, but a size is
present so strings with null bytes in them can be represented.  This
is an immutable object type.

There are functions to create new bytes objects, to test
an object for bytes-ness, and to get the
byte string value.  The latter function returns a null pointer
if the object is not of the proper type.
There is a variant that takes an explicit size as well as a
variant that assumes a zero-terminated string.  Note that none of the
functions should be applied to NULL pointer.
*/

public static native @ByRef PyTypeObject PyBytes_Type(); public static native void PyBytes_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyBytesIter_Type(); public static native void PyBytesIter_Type(PyTypeObject setter);

// #define PyBytes_Check(op)
//                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_BYTES_SUBCLASS)
// #define PyBytes_CheckExact(op) Py_IS_TYPE(op, &PyBytes_Type)

@NoException public static native PyObject PyBytes_FromStringAndSize(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native PyObject PyBytes_FromStringAndSize(String arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native PyObject PyBytes_FromString(@Cast("const char*") BytePointer arg0);
@NoException public static native PyObject PyBytes_FromString(String arg0);
@NoException public static native PyObject PyBytes_FromObject(PyObject arg0);
@NoException public static native PyObject PyBytes_FromFormatV(@Cast("const char*") BytePointer arg0, @ByVal @Cast("va_list*") Pointer arg1);
@NoException public static native PyObject PyBytes_FromFormatV(String arg0, @ByVal @Cast("va_list*") Pointer arg1);
@NoException public static native PyObject PyBytes_FromFormat(@Cast("const char*") BytePointer arg0);
@NoException public static native PyObject PyBytes_FromFormat(String arg0);
@NoException public static native @Cast("Py_ssize_t") long PyBytes_Size(PyObject arg0);
@NoException public static native @Cast("char*") BytePointer PyBytes_AsString(PyObject arg0);
@NoException public static native PyObject PyBytes_Repr(PyObject arg0, int arg1);
@NoException public static native void PyBytes_Concat(@Cast("PyObject**") PointerPointer arg0, PyObject arg1);
@NoException public static native void PyBytes_Concat(@ByPtrPtr PyObject arg0, PyObject arg1);
@NoException public static native void PyBytes_ConcatAndDel(@Cast("PyObject**") PointerPointer arg0, PyObject arg1);
@NoException public static native void PyBytes_ConcatAndDel(@ByPtrPtr PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyBytes_DecodeEscape(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1,
                                            @Cast("const char*") BytePointer arg2, @Cast("Py_ssize_t") long arg3,
                                            @Cast("const char*") BytePointer arg4);
@NoException public static native PyObject PyBytes_DecodeEscape(String arg0, @Cast("Py_ssize_t") long arg1,
                                            String arg2, @Cast("Py_ssize_t") long arg3,
                                            String arg4);

/* Provides access to the internal data buffer and size of a bytes object.
   Passing NULL as len parameter will force the string buffer to be
   0-terminated (passing a string with embedded NUL characters will
   cause an exception).  */
@NoException public static native int PyBytes_AsStringAndSize(
    PyObject obj,
    @Cast("char**") PointerPointer s,
    @Cast("Py_ssize_t*") SizeTPointer len
    );
@NoException public static native int PyBytes_AsStringAndSize(
    PyObject obj,
    @Cast("char**") @ByPtrPtr BytePointer s,
    @Cast("Py_ssize_t*") SizeTPointer len
    );
@NoException public static native int PyBytes_AsStringAndSize(
    PyObject obj,
    @Cast("char**") @ByPtrPtr ByteBuffer s,
    @Cast("Py_ssize_t*") SizeTPointer len
    );
@NoException public static native int PyBytes_AsStringAndSize(
    PyObject obj,
    @Cast("char**") @ByPtrPtr byte[] s,
    @Cast("Py_ssize_t*") SizeTPointer len
    );

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_BYTESOBJECT_H
// #  include  "cpython/bytesobject.h"
// #  undef Py_CPYTHON_BYTESOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_BYTESOBJECT_H */


// Parsed from cpython/bytesobject.h

// #ifndef Py_CPYTHON_BYTESOBJECT_H
// #  error "this header file must not be included directly"
// Targeting ../PyBytesObject.java



@NoException public static native int _PyBytes_Resize(@Cast("PyObject**") PointerPointer arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int _PyBytes_Resize(@ByPtrPtr PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native PyObject _PyBytes_FormatEx(
    @Cast("const char*") BytePointer format,
    @Cast("Py_ssize_t") long format_len,
    PyObject args,
    int use_bytearray);
@NoException public static native PyObject _PyBytes_FormatEx(
    String format,
    @Cast("Py_ssize_t") long format_len,
    PyObject args,
    int use_bytearray);
@NoException public static native PyObject _PyBytes_FromHex(
    PyObject string,
    int use_bytearray);

/* Helper for PyBytes_DecodeEscape that detects invalid escape chars. */
@NoException public static native PyObject _PyBytes_DecodeEscape(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1,
                                             @Cast("const char*") BytePointer arg2, @Cast("const char**") PointerPointer arg3);
@NoException public static native PyObject _PyBytes_DecodeEscape(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1,
                                             @Cast("const char*") BytePointer arg2, @Cast("const char**") @ByPtrPtr BytePointer arg3);
@NoException public static native PyObject _PyBytes_DecodeEscape(String arg0, @Cast("Py_ssize_t") long arg1,
                                             String arg2, @Cast("const char**") @ByPtrPtr ByteBuffer arg3);
@NoException public static native PyObject _PyBytes_DecodeEscape(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1,
                                             @Cast("const char*") BytePointer arg2, @Cast("const char**") @ByPtrPtr byte[] arg3);
@NoException public static native PyObject _PyBytes_DecodeEscape(String arg0, @Cast("Py_ssize_t") long arg1,
                                             String arg2, @Cast("const char**") @ByPtrPtr BytePointer arg3);
@NoException public static native PyObject _PyBytes_DecodeEscape(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1,
                                             @Cast("const char*") BytePointer arg2, @Cast("const char**") @ByPtrPtr ByteBuffer arg3);
@NoException public static native PyObject _PyBytes_DecodeEscape(String arg0, @Cast("Py_ssize_t") long arg1,
                                             String arg2, @Cast("const char**") @ByPtrPtr byte[] arg3);

/* Macro, trading safety for speed */
// #define PyBytes_AS_STRING(op) (assert(PyBytes_Check(op)),
//                                 (((PyBytesObject *)(op))->ob_sval))
// #define PyBytes_GET_SIZE(op)  (assert(PyBytes_Check(op)),Py_SIZE(op))

/* _PyBytes_Join(sep, x) is like sep.join(x).  sep must be PyBytesObject*,
   x must be an iterable object. */
@NoException public static native PyObject _PyBytes_Join(PyObject sep, PyObject x);
// Targeting ../_PyBytesWriter.java



/* Initialize a bytes writer

   By default, the overallocation is disabled. Set the overallocate attribute
   to control the allocation of the buffer. */
@NoException public static native void _PyBytesWriter_Init(_PyBytesWriter writer);

/* Get the buffer content and reset the writer.
   Return a bytes object, or a bytearray object if use_bytearray is non-zero.
   Raise an exception and return NULL on error. */
@NoException public static native PyObject _PyBytesWriter_Finish(_PyBytesWriter writer,
    Pointer str);

/* Deallocate memory of a writer (clear its internal buffer). */
@NoException public static native void _PyBytesWriter_Dealloc(_PyBytesWriter writer);

/* Allocate the buffer to write size bytes.
   Return the pointer to the beginning of buffer data.
   Raise an exception and return NULL on error. */
@NoException public static native Pointer _PyBytesWriter_Alloc(_PyBytesWriter writer,
    @Cast("Py_ssize_t") long size);

/* Ensure that the buffer is large enough to write *size* bytes.
   Add size to the writer minimum size (min_size attribute).

   str is the current pointer inside the buffer.
   Return the updated current pointer inside the buffer.
   Raise an exception and return NULL on error. */
@NoException public static native Pointer _PyBytesWriter_Prepare(_PyBytesWriter writer,
    Pointer str,
    @Cast("Py_ssize_t") long size);

/* Resize the buffer to make it larger.
   The new buffer may be larger than size bytes because of overallocation.
   Return the updated current pointer inside the buffer.
   Raise an exception and return NULL on error.

   Note: size must be greater than the number of allocated bytes in the writer.

   This function doesn't use the writer minimum size (min_size attribute).

   See also _PyBytesWriter_Prepare().
   */
@NoException public static native Pointer _PyBytesWriter_Resize(_PyBytesWriter writer,
    Pointer str,
    @Cast("Py_ssize_t") long size);

/* Write bytes.
   Raise an exception and return NULL on error. */
@NoException public static native Pointer _PyBytesWriter_WriteBytes(_PyBytesWriter writer,
    Pointer str,
    @Const Pointer bytes,
    @Cast("Py_ssize_t") long size);


// Parsed from unicodeobject.h

// #ifndef Py_UNICODEOBJECT_H
// #define Py_UNICODEOBJECT_H

// #include <stdarg.h>

/*

Unicode implementation based on original code by Fredrik Lundh,
modified by Marc-Andre Lemburg (mal@lemburg.com) according to the
Unicode Integration Proposal. (See
http://www.egenix.com/files/python/unicode-proposal.txt).

Copyright (c) Corporation for National Research Initiatives.


 Original header:
 --------------------------------------------------------------------

 * Yet another Unicode string type for Python.  This type supports the
 * 16-bit Basic Multilingual Plane (BMP) only.
 *
 * Written by Fredrik Lundh, January 1999.
 *
 * Copyright (c) 1999 by Secret Labs AB.
 * Copyright (c) 1999 by Fredrik Lundh.
 *
 * fredrik@pythonware.com
 * http://www.pythonware.com
 *
 * --------------------------------------------------------------------
 * This Unicode String Type is
 *
 * Copyright (c) 1999 by Secret Labs AB
 * Copyright (c) 1999 by Fredrik Lundh
 *
 * By obtaining, using, and/or copying this software and/or its
 * associated documentation, you agree that you have read, understood,
 * and will comply with the following terms and conditions:
 *
 * Permission to use, copy, modify, and distribute this software and its
 * associated documentation for any purpose and without fee is hereby
 * granted, provided that the above copyright notice appears in all
 * copies, and that both that copyright notice and this permission notice
 * appear in supporting documentation, and that the name of Secret Labs
 * AB or the author not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior
 * permission.
 *
 * SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * -------------------------------------------------------------------- */

// #include <ctype.h>

/* === Internal API ======================================================= */

/* --- Internal Unicode Format -------------------------------------------- */

/* Python 3.x requires unicode */
// #define Py_USING_UNICODE

// #ifndef SIZEOF_WCHAR_T
// #endif

public static native @MemberGetter long Py_UNICODE_SIZE();
public static final long Py_UNICODE_SIZE = Py_UNICODE_SIZE();

/* If wchar_t can be used for UCS-4 storage, set Py_UNICODE_WIDE.
   Otherwise, Unicode strings are stored as UCS-2 (with limited support
   for UTF-16) */

// #if Py_UNICODE_SIZE >= 4
// #define Py_UNICODE_WIDE
// #endif

/* Set these flags if the platform has "wchar.h" and the
   wchar_t type is a 16-bit unsigned type */
/* #define HAVE_WCHAR_H */
/* #define HAVE_USABLE_WCHAR_T */

/* If the compiler provides a wchar_t type we try to support it
   through the interface functions PyUnicode_FromWideChar(),
   PyUnicode_AsWideChar() and PyUnicode_AsWideCharString(). */

// #ifdef HAVE_USABLE_WCHAR_T
// # ifndef HAVE_WCHAR_H
// # endif
// #endif

// #ifdef HAVE_WCHAR_H
// #  include <wchar.h>
// #endif

/* Py_UCS4 and Py_UCS2 are typedefs for the respective
   unicode representations. */

// #ifdef __cplusplus
// #endif


public static native @ByRef PyTypeObject PyUnicode_Type(); public static native void PyUnicode_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyUnicodeIter_Type(); public static native void PyUnicodeIter_Type(PyTypeObject setter);

// #define PyUnicode_Check(op)
//                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_UNICODE_SUBCLASS)
// #define PyUnicode_CheckExact(op) Py_IS_TYPE(op, &PyUnicode_Type)

/* --- Constants ---------------------------------------------------------- */

/* This Unicode character will be used as replacement character during
   decoding if the errors argument is set to "replace". Note: the
   Unicode character U+FFFD is the official REPLACEMENT CHARACTER in
   Unicode 3.0. */

public static final int Py_UNICODE_REPLACEMENT_CHARACTER = ((int) 0xFFFD);

/* === Public API ========================================================= */

/* Similar to PyUnicode_FromUnicode(), but u points to UTF-8 encoded bytes */
@NoException public static native PyObject PyUnicode_FromStringAndSize(
    @Cast("const char*") BytePointer u,
    @Cast("Py_ssize_t") long size
    );
@NoException public static native PyObject PyUnicode_FromStringAndSize(
    String u,
    @Cast("Py_ssize_t") long size
    );

/* Similar to PyUnicode_FromUnicode(), but u points to null-terminated
   UTF-8 encoded bytes.  The size is determined with strlen(). */
@NoException public static native PyObject PyUnicode_FromString(
    @Cast("const char*") BytePointer u
    );
@NoException public static native PyObject PyUnicode_FromString(
    String u
    );

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyUnicode_Substring(
    PyObject str,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end);
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
/* Copy the string into a UCS4 buffer including the null character if copy_null
   is set. Return NULL and raise an exception on error. Raise a SystemError if
   the buffer is smaller than the string. Return buffer on success.

   buflen is the length of the buffer in (Py_UCS4) characters. */
@NoException public static native @Cast("Py_UCS4*") IntPointer PyUnicode_AsUCS4(
    PyObject unicode,
    @Cast("Py_UCS4*") IntPointer buffer,
    @Cast("Py_ssize_t") long buflen,
    int copy_null);
@NoException public static native @Cast("Py_UCS4*") IntBuffer PyUnicode_AsUCS4(
    PyObject unicode,
    @Cast("Py_UCS4*") IntBuffer buffer,
    @Cast("Py_ssize_t") long buflen,
    int copy_null);
@NoException public static native @Cast("Py_UCS4*") int[] PyUnicode_AsUCS4(
    PyObject unicode,
    @Cast("Py_UCS4*") int[] buffer,
    @Cast("Py_ssize_t") long buflen,
    int copy_null);

/* Copy the string into a UCS4 buffer. A new buffer is allocated using
 * PyMem_Malloc; if this fails, NULL is returned with a memory error
   exception set. */
@NoException public static native @Cast("Py_UCS4*") IntPointer PyUnicode_AsUCS4Copy(PyObject unicode);
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
/* Get the length of the Unicode object. */

@NoException public static native @Cast("Py_ssize_t") long PyUnicode_GetLength(
    PyObject unicode
);
// #endif

/* Get the number of Py_UNICODE units in the
   string representation. */

@NoException public static native @Cast("Py_ssize_t") @Deprecated long PyUnicode_GetSize(
    PyObject unicode
    );

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
/* Read a character from the string. */

@NoException public static native @Cast("Py_UCS4") int PyUnicode_ReadChar(
    PyObject unicode,
    @Cast("Py_ssize_t") long index
    );

/* Write a character to the string. The string must have been created through
   PyUnicode_New, must not be shared, and must not have been hashed yet.

   Return 0 on success, -1 on error. */

@NoException public static native int PyUnicode_WriteChar(
    PyObject unicode,
    @Cast("Py_ssize_t") long index,
    @Cast("Py_UCS4") int character
    );
// #endif

/* Resize a Unicode object. The length is the number of characters, except
   if the kind of the string is PyUnicode_WCHAR_KIND: in this case, the length
   is the number of Py_UNICODE characters.

   *unicode is modified to point to the new (resized) object and 0
   returned on success.

   Try to resize the string in place (which is usually faster than allocating
   a new string and copy characters), or create a new string.

   Error handling is implemented as follows: an exception is set, -1
   is returned and *unicode left untouched.

   WARNING: The function doesn't check string content, the result may not be a
            string in canonical representation. */

@NoException public static native int PyUnicode_Resize(
    @Cast("PyObject**") PointerPointer unicode,
    @Cast("Py_ssize_t") long length
    );
@NoException public static native int PyUnicode_Resize(
    @ByPtrPtr PyObject unicode,
    @Cast("Py_ssize_t") long length
    );

/* Decode obj to a Unicode object.

   bytes, bytearray and other bytes-like objects are decoded according to the
   given encoding and error handler. The encoding and error handler can be
   NULL to have the interface use UTF-8 and "strict".

   All other objects (including Unicode objects) raise an exception.

   The API returns NULL in case of an error. The caller is responsible
   for decref'ing the returned objects.

*/

@NoException public static native PyObject PyUnicode_FromEncodedObject(
    PyObject obj,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_FromEncodedObject(
    PyObject obj,
    String encoding,
    String errors
    );

/* Copy an instance of a Unicode subtype to a new true Unicode object if
   necessary. If obj is already a true Unicode object (not a subtype), return
   the reference with *incremented* refcount.

   The API returns NULL in case of an error. The caller is responsible
   for decref'ing the returned objects.

*/

@NoException public static native PyObject PyUnicode_FromObject(
    PyObject obj
    );

@NoException public static native PyObject PyUnicode_FromFormatV(
    @Cast("const char*") BytePointer format,
    @ByVal @Cast("va_list*") Pointer vargs
    );
@NoException public static native PyObject PyUnicode_FromFormatV(
    String format,
    @ByVal @Cast("va_list*") Pointer vargs
    );
@NoException public static native PyObject PyUnicode_FromFormat(
    @Cast("const char*") BytePointer format
    );
@NoException public static native PyObject PyUnicode_FromFormat(
    String format
    );

@NoException public static native void PyUnicode_InternInPlace(@Cast("PyObject**") PointerPointer arg0);
@NoException public static native void PyUnicode_InternInPlace(@ByPtrPtr PyObject arg0);
@NoException public static native PyObject PyUnicode_InternFromString(
    @Cast("const char*") BytePointer u
    );
@NoException public static native PyObject PyUnicode_InternFromString(
    String u
    );

// PyUnicode_InternImmortal() is deprecated since Python 3.10
// and will be removed in Python 3.12. Use PyUnicode_InternInPlace() instead.
@NoException public static native @Deprecated void PyUnicode_InternImmortal(@Cast("PyObject**") PointerPointer arg0);
@NoException public static native @Deprecated void PyUnicode_InternImmortal(@ByPtrPtr PyObject arg0);

/* Use only if you know it's a string */
// #define PyUnicode_CHECK_INTERNED(op)
//     (((PyASCIIObject *)(op))->state.interned)

/* --- wchar_t support for platforms which support it --------------------- */

// #ifdef HAVE_WCHAR_H

/* Create a Unicode Object from the wchar_t buffer w of the given
   size.

   The buffer is copied into the new object. */

@NoException public static native PyObject PyUnicode_FromWideChar(
    @Cast("const wchar_t*") Pointer w,
    @Cast("Py_ssize_t") long size
    );

/* Copies the Unicode Object contents into the wchar_t buffer w.  At
   most size wchar_t characters are copied.

   Note that the resulting wchar_t string may or may not be
   0-terminated.  It is the responsibility of the caller to make sure
   that the wchar_t string is 0-terminated in case this is required by
   the application.

   Returns the number of wchar_t characters copied (excluding a
   possibly trailing 0-termination character) or -1 in case of an
   error. */

@NoException public static native @Cast("Py_ssize_t") long PyUnicode_AsWideChar(
    PyObject unicode,
    @Cast("wchar_t*") Pointer w,
    @Cast("Py_ssize_t") long size
    );

/* Convert the Unicode object to a wide character string. The output string
   always ends with a nul character. If size is not NULL, write the number of
   wide characters (excluding the null character) into *size.

   Returns a buffer allocated by PyMem_Malloc() (use PyMem_Free() to free it)
   on success. On error, returns NULL, *size is undefined and raises a
   MemoryError. */

@NoException public static native @Cast("wchar_t*") Pointer PyUnicode_AsWideCharString(
    PyObject unicode,
    @Cast("Py_ssize_t*") SizeTPointer size
    );

// #endif

/* --- Unicode ordinals --------------------------------------------------- */

/* Create a Unicode Object from the given Unicode code point ordinal.

   The ordinal must be in range(0x110000). A ValueError is
   raised in case it is not.

*/

@NoException public static native PyObject PyUnicode_FromOrdinal(int ordinal);

/* === Builtin Codecs =====================================================

   Many of these APIs take two arguments encoding and errors. These
   parameters encoding and errors have the same semantics as the ones
   of the builtin str() API.

   Setting encoding to NULL causes the default encoding (UTF-8) to be used.

   Error handling is set by errors which may also be set to NULL
   meaning to use the default handling defined for the codec. Default
   error handling for all builtin codecs is "strict" (ValueErrors are
   raised).

   The codecs all use a similar interface. Only deviation from the
   generic ones are documented.

*/

/* --- Manage the default encoding ---------------------------------------- */

/* Returns "utf-8".  */
@NoException public static native @Cast("const char*") BytePointer PyUnicode_GetDefaultEncoding();

/* --- Generic Codecs ----------------------------------------------------- */

/* Create a Unicode object by decoding the encoded string s of the
   given size. */

@NoException public static native PyObject PyUnicode_Decode(
    @Cast("const char*") BytePointer s,
    @Cast("Py_ssize_t") long size,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_Decode(
    String s,
    @Cast("Py_ssize_t") long size,
    String encoding,
    String errors
    );

/* Decode a Unicode object unicode and return the result as Python
   object.

   This API is DEPRECATED. The only supported standard encoding is rot13.
   Use PyCodec_Decode() to decode with rot13 and non-standard codecs
   that decode from str. */

@NoException public static native @Deprecated PyObject PyUnicode_AsDecodedObject(
    PyObject unicode,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated PyObject PyUnicode_AsDecodedObject(
    PyObject unicode,
    String encoding,
    String errors
    );

/* Decode a Unicode object unicode and return the result as Unicode
   object.

   This API is DEPRECATED. The only supported standard encoding is rot13.
   Use PyCodec_Decode() to decode with rot13 and non-standard codecs
   that decode from str to str. */

@NoException public static native @Deprecated PyObject PyUnicode_AsDecodedUnicode(
    PyObject unicode,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated PyObject PyUnicode_AsDecodedUnicode(
    PyObject unicode,
    String encoding,
    String errors
    );

/* Encodes a Unicode object and returns the result as Python
   object.

   This API is DEPRECATED.  It is superseded by PyUnicode_AsEncodedString()
   since all standard encodings (except rot13) encode str to bytes.
   Use PyCodec_Encode() for encoding with rot13 and non-standard codecs
   that encode form str to non-bytes. */

@NoException public static native @Deprecated PyObject PyUnicode_AsEncodedObject(
    PyObject unicode,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated PyObject PyUnicode_AsEncodedObject(
    PyObject unicode,
    String encoding,
    String errors
    );

/* Encodes a Unicode object and returns the result as Python string
   object. */

@NoException public static native PyObject PyUnicode_AsEncodedString(
    PyObject unicode,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_AsEncodedString(
    PyObject unicode,
    String encoding,
    String errors
    );

/* Encodes a Unicode object and returns the result as Unicode
   object.

   This API is DEPRECATED.  The only supported standard encodings is rot13.
   Use PyCodec_Encode() to encode with rot13 and non-standard codecs
   that encode from str to str. */

@NoException public static native @Deprecated PyObject PyUnicode_AsEncodedUnicode(
    PyObject unicode,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated PyObject PyUnicode_AsEncodedUnicode(
    PyObject unicode,
    String encoding,
    String errors
    );

/* Build an encoding map. */

@NoException public static native PyObject PyUnicode_BuildEncodingMap(
    PyObject string
   );

/* --- UTF-7 Codecs ------------------------------------------------------- */

@NoException public static native PyObject PyUnicode_DecodeUTF7(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeUTF7(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

@NoException public static native PyObject PyUnicode_DecodeUTF7Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF7Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );

/* --- UTF-8 Codecs ------------------------------------------------------- */

@NoException public static native PyObject PyUnicode_DecodeUTF8(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeUTF8(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

@NoException public static native PyObject PyUnicode_DecodeUTF8Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF8Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );

@NoException public static native PyObject PyUnicode_AsUTF8String(
    PyObject unicode
    );

/* Returns a pointer to the default encoding (UTF-8) of the
   Unicode object unicode and the size of the encoded representation
   in bytes stored in *size.

   In case of an error, no *size is set.

   This function caches the UTF-8 encoded string in the unicodeobject
   and subsequent calls will return the same string.  The memory is released
   when the unicodeobject is deallocated.
*/

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
@NoException public static native @Cast("const char*") BytePointer PyUnicode_AsUTF8AndSize(
    PyObject unicode,
    @Cast("Py_ssize_t*") SizeTPointer size);
// #endif

/* --- UTF-32 Codecs ------------------------------------------------------ */

/* Decodes length bytes from a UTF-32 encoded buffer string and returns
   the corresponding Unicode object.

   errors (if non-NULL) defines the error handling. It defaults
   to "strict".

   If byteorder is non-NULL, the decoder starts decoding using the
   given byte order:

    *byteorder == -1: little endian
    *byteorder == 0:  native order
    *byteorder == 1:  big endian

   In native mode, the first four bytes of the stream are checked for a
   BOM mark. If found, the BOM mark is analysed, the byte order
   adjusted and the BOM skipped.  In the other modes, no BOM mark
   interpretation is done. After completion, *byteorder is set to the
   current byte order at the end of input data.

   If byteorder is NULL, the codec starts in native order mode.

*/

@NoException public static native PyObject PyUnicode_DecodeUTF32(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntPointer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntBuffer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    int[] byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntPointer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntBuffer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    int[] byteorder
    );

@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntPointer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntBuffer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    int[] byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntPointer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntBuffer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    int[] byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );

/* Returns a Python string using the UTF-32 encoding in native byte
   order. The string always starts with a BOM mark.  */

@NoException public static native PyObject PyUnicode_AsUTF32String(
    PyObject unicode
    );

/* Returns a Python string object holding the UTF-32 encoded value of
   the Unicode data.

   If byteorder is not 0, output is written according to the following
   byte order:

   byteorder == -1: little endian
   byteorder == 0:  native byte order (writes a BOM mark)
   byteorder == 1:  big endian

   If byteorder is 0, the output string will always start with the
   Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is
   prepended.

*/

/* --- UTF-16 Codecs ------------------------------------------------------ */

/* Decodes length bytes from a UTF-16 encoded buffer string and returns
   the corresponding Unicode object.

   errors (if non-NULL) defines the error handling. It defaults
   to "strict".

   If byteorder is non-NULL, the decoder starts decoding using the
   given byte order:

    *byteorder == -1: little endian
    *byteorder == 0:  native order
    *byteorder == 1:  big endian

   In native mode, the first two bytes of the stream are checked for a
   BOM mark. If found, the BOM mark is analysed, the byte order
   adjusted and the BOM skipped.  In the other modes, no BOM mark
   interpretation is done. After completion, *byteorder is set to the
   current byte order at the end of input data.

   If byteorder is NULL, the codec starts in native order mode.

*/

@NoException public static native PyObject PyUnicode_DecodeUTF16(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntPointer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntBuffer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    int[] byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntPointer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntBuffer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    int[] byteorder
    );

@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntPointer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntBuffer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    int[] byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntPointer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntBuffer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    int[] byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );

/* Returns a Python string using the UTF-16 encoding in native byte
   order. The string always starts with a BOM mark.  */

@NoException public static native PyObject PyUnicode_AsUTF16String(
    PyObject unicode
    );

/* --- Unicode-Escape Codecs ---------------------------------------------- */

@NoException public static native PyObject PyUnicode_DecodeUnicodeEscape(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeUnicodeEscape(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

@NoException public static native PyObject PyUnicode_AsUnicodeEscapeString(
    PyObject unicode
    );

/* --- Raw-Unicode-Escape Codecs ------------------------------------------ */

@NoException public static native PyObject PyUnicode_DecodeRawUnicodeEscape(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeRawUnicodeEscape(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

@NoException public static native PyObject PyUnicode_AsRawUnicodeEscapeString(
    PyObject unicode
    );

/* --- Latin-1 Codecs -----------------------------------------------------

   Note: Latin-1 corresponds to the first 256 Unicode ordinals. */

@NoException public static native PyObject PyUnicode_DecodeLatin1(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeLatin1(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

@NoException public static native PyObject PyUnicode_AsLatin1String(
    PyObject unicode
    );

/* --- ASCII Codecs -------------------------------------------------------

   Only 7-bit ASCII data is excepted. All other codes generate errors.

*/

@NoException public static native PyObject PyUnicode_DecodeASCII(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeASCII(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

@NoException public static native PyObject PyUnicode_AsASCIIString(
    PyObject unicode
    );

/* --- Character Map Codecs -----------------------------------------------

   This codec uses mappings to encode and decode characters.

   Decoding mappings must map byte ordinals (integers in the range from 0 to
   255) to Unicode strings, integers (which are then interpreted as Unicode
   ordinals) or None.  Unmapped data bytes (ones which cause a LookupError)
   as well as mapped to None, 0xFFFE or '\u005Cufffe' are treated as "undefined
   mapping" and cause an error.

   Encoding mappings must map Unicode ordinal integers to bytes objects,
   integers in the range from 0 to 255 or None.  Unmapped character
   ordinals (ones which cause a LookupError) as well as mapped to
   None are treated as "undefined mapping" and cause an error.

*/

@NoException public static native PyObject PyUnicode_DecodeCharmap(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    PyObject mapping,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeCharmap(
    String string,
    @Cast("Py_ssize_t") long length,
    PyObject mapping,
    String errors
    );

@NoException public static native PyObject PyUnicode_AsCharmapString(
    PyObject unicode,
    PyObject mapping
    );

/* --- MBCS codecs for Windows -------------------------------------------- */

// #ifdef MS_WINDOWS

// #endif /* MS_WINDOWS */

/* --- Locale encoding --------------------------------------------------- */

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
/* Decode a string from the current locale encoding. The decoder is strict if
   *surrogateescape* is equal to zero, otherwise it uses the 'surrogateescape'
   error handler (PEP 383) to escape undecodable bytes. If a byte sequence can
   be decoded as a surrogate character and *surrogateescape* is not equal to
   zero, the byte sequence is escaped using the 'surrogateescape' error handler
   instead of being decoded. *str* must end with a null character but cannot
   contain embedded null characters. */

@NoException public static native PyObject PyUnicode_DecodeLocaleAndSize(
    @Cast("const char*") BytePointer str,
    @Cast("Py_ssize_t") long len,
    @Cast("const char*") BytePointer errors);
@NoException public static native PyObject PyUnicode_DecodeLocaleAndSize(
    String str,
    @Cast("Py_ssize_t") long len,
    String errors);

/* Similar to PyUnicode_DecodeLocaleAndSize(), but compute the string
   length using strlen(). */

@NoException public static native PyObject PyUnicode_DecodeLocale(
    @Cast("const char*") BytePointer str,
    @Cast("const char*") BytePointer errors);
@NoException public static native PyObject PyUnicode_DecodeLocale(
    String str,
    String errors);

/* Encode a Unicode object to the current locale encoding. The encoder is
   strict is *surrogateescape* is equal to zero, otherwise the
   "surrogateescape" error handler is used. Return a bytes object. The string
   cannot contain embedded null characters. */

@NoException public static native PyObject PyUnicode_EncodeLocale(
    PyObject unicode,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_EncodeLocale(
    PyObject unicode,
    String errors
    );
// #endif

/* --- File system encoding ---------------------------------------------- */

/* ParseTuple converter: encode str objects to bytes using
   PyUnicode_EncodeFSDefault(); bytes objects are output as-is. */

@NoException public static native int PyUnicode_FSConverter(PyObject arg0, Pointer arg1);

/* ParseTuple converter: decode bytes objects to unicode using
   PyUnicode_DecodeFSDefaultAndSize(); str objects are output as-is. */

@NoException public static native int PyUnicode_FSDecoder(PyObject arg0, Pointer arg1);

/* Decode a null-terminated string using Py_FileSystemDefaultEncoding
   and the "surrogateescape" error handler.

   If Py_FileSystemDefaultEncoding is not set, fall back to the locale
   encoding.

   Use PyUnicode_DecodeFSDefaultAndSize() if the string length is known.
*/

@NoException public static native PyObject PyUnicode_DecodeFSDefault(
    @Cast("const char*") BytePointer s
    );
@NoException public static native PyObject PyUnicode_DecodeFSDefault(
    String s
    );

/* Decode a string using Py_FileSystemDefaultEncoding
   and the "surrogateescape" error handler.

   If Py_FileSystemDefaultEncoding is not set, fall back to the locale
   encoding.
*/

@NoException public static native PyObject PyUnicode_DecodeFSDefaultAndSize(
    @Cast("const char*") BytePointer s,
    @Cast("Py_ssize_t") long size
    );
@NoException public static native PyObject PyUnicode_DecodeFSDefaultAndSize(
    String s,
    @Cast("Py_ssize_t") long size
    );

/* Encode a Unicode object to Py_FileSystemDefaultEncoding with the
   "surrogateescape" error handler, and return bytes.

   If Py_FileSystemDefaultEncoding is not set, fall back to the locale
   encoding.
*/

@NoException public static native PyObject PyUnicode_EncodeFSDefault(
    PyObject unicode
    );

/* --- Methods & Slots ----------------------------------------------------

   These are capable of handling Unicode objects and strings on input
   (we refer to them as strings in the descriptions) and return
   Unicode objects or integers as appropriate. */

/* Concat two strings giving a new Unicode string. */

@NoException public static native PyObject PyUnicode_Concat(
    PyObject left,
    PyObject right
    );

/* Concat two strings and put the result in *pleft
   (sets *pleft to NULL on error) */

@NoException public static native void PyUnicode_Append(
    @Cast("PyObject**") PointerPointer pleft,
    PyObject right
    );
@NoException public static native void PyUnicode_Append(
    @ByPtrPtr PyObject pleft,
    PyObject right
    );

/* Concat two strings, put the result in *pleft and drop the right object
   (sets *pleft to NULL on error) */

@NoException public static native void PyUnicode_AppendAndDel(
    @Cast("PyObject**") PointerPointer pleft,
    PyObject right
    );
@NoException public static native void PyUnicode_AppendAndDel(
    @ByPtrPtr PyObject pleft,
    PyObject right
    );

/* Split a string giving a list of Unicode strings.

   If sep is NULL, splitting will be done at all whitespace
   substrings. Otherwise, splits occur at the given separator.

   At most maxsplit splits will be done. If negative, no limit is set.

   Separators are not included in the resulting list.

*/

@NoException public static native PyObject PyUnicode_Split(
    PyObject s,
    PyObject sep,
    @Cast("Py_ssize_t") long maxsplit
    );

/* Dito, but split at line breaks.

   CRLF is considered to be one line break. Line breaks are not
   included in the resulting list. */

@NoException public static native PyObject PyUnicode_Splitlines(
    PyObject s,
    int keepends
    );

/* Partition a string using a given separator. */

@NoException public static native PyObject PyUnicode_Partition(
    PyObject s,
    PyObject sep
    );

/* Partition a string using a given separator, searching from the end of the
   string. */

@NoException public static native PyObject PyUnicode_RPartition(
    PyObject s,
    PyObject sep
    );

/* Split a string giving a list of Unicode strings.

   If sep is NULL, splitting will be done at all whitespace
   substrings. Otherwise, splits occur at the given separator.

   At most maxsplit splits will be done. But unlike PyUnicode_Split
   PyUnicode_RSplit splits from the end of the string. If negative,
   no limit is set.

   Separators are not included in the resulting list.

*/

@NoException public static native PyObject PyUnicode_RSplit(
    PyObject s,
    PyObject sep,
    @Cast("Py_ssize_t") long maxsplit
    );

/* Translate a string by applying a character mapping table to it and
   return the resulting Unicode object.

   The mapping table must map Unicode ordinal integers to Unicode strings,
   Unicode ordinal integers or None (causing deletion of the character).

   Mapping tables may be dictionaries or sequences. Unmapped character
   ordinals (ones which cause a LookupError) are left untouched and
   are copied as-is.

*/

@NoException public static native PyObject PyUnicode_Translate(
    PyObject str,
    PyObject table,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_Translate(
    PyObject str,
    PyObject table,
    String errors
    );

/* Join a sequence of strings using the given separator and return
   the resulting Unicode string. */

@NoException public static native PyObject PyUnicode_Join(
    PyObject separator,
    PyObject seq
    );

/* Return 1 if substr matches str[start:end] at the given tail end, 0
   otherwise. */

@NoException public static native @Cast("Py_ssize_t") long PyUnicode_Tailmatch(
    PyObject str,
    PyObject substr,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    int direction
    );

/* Return the first position of substr in str[start:end] using the
   given search direction or -1 if not found. -2 is returned in case
   an error occurred and an exception is set. */

@NoException public static native @Cast("Py_ssize_t") long PyUnicode_Find(
    PyObject str,
    PyObject substr,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    int direction
    );

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
/* Like PyUnicode_Find, but search for single character only. */
@NoException public static native @Cast("Py_ssize_t") long PyUnicode_FindChar(
    PyObject str,
    @Cast("Py_UCS4") int ch,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    int direction
    );
// #endif

/* Count the number of occurrences of substr in str[start:end]. */

@NoException public static native @Cast("Py_ssize_t") long PyUnicode_Count(
    PyObject str,
    PyObject substr,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end
    );

/* Replace at most maxcount occurrences of substr in str with replstr
   and return the resulting Unicode object. */

@NoException public static native PyObject PyUnicode_Replace(
    PyObject str,
    PyObject substr,
    PyObject replstr,
    @Cast("Py_ssize_t") long maxcount
    );

/* Compare two strings and return -1, 0, 1 for less than, equal,
   greater than resp.
   Raise an exception and return -1 on error. */

@NoException public static native int PyUnicode_Compare(
    PyObject left,
    PyObject right
    );

/* Compare a Unicode object with C string and return -1, 0, 1 for less than,
   equal, and greater than, respectively.  It is best to pass only
   ASCII-encoded strings, but the function interprets the input string as
   ISO-8859-1 if it contains non-ASCII characters.
   This function does not raise exceptions. */

@NoException public static native int PyUnicode_CompareWithASCIIString(
    PyObject left,
    @Cast("const char*") BytePointer right
    );
@NoException public static native int PyUnicode_CompareWithASCIIString(
    PyObject left,
    String right
    );

/* Rich compare two strings and return one of the following:

   - NULL in case an exception was raised
   - Py_True or Py_False for successful comparisons
   - Py_NotImplemented in case the type combination is unknown

   Possible values for op:

     Py_GT, Py_GE, Py_EQ, Py_NE, Py_LT, Py_LE

*/

@NoException public static native PyObject PyUnicode_RichCompare(
    PyObject left,
    PyObject right,
    int op
    );

/* Apply an argument tuple or dictionary to a format string and return
   the resulting Unicode string. */

@NoException public static native PyObject PyUnicode_Format(
    PyObject format,
    PyObject args
    );

/* Checks whether element is contained in container and return 1/0
   accordingly.

   element has to coerce to a one element Unicode string. -1 is
   returned in case of an error. */

@NoException public static native int PyUnicode_Contains(
    PyObject container,
    PyObject element
    );

/* Checks whether argument is a valid identifier. */

@NoException public static native int PyUnicode_IsIdentifier(PyObject s);

/* === Characters Type APIs =============================================== */

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_UNICODEOBJECT_H
// #  include  "cpython/unicodeobject.h"
// #  undef Py_CPYTHON_UNICODEOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_UNICODEOBJECT_H */


// Parsed from cpython/unicodeobject.h

// #ifndef Py_CPYTHON_UNICODEOBJECT_H
// #  error "this header file must not be included directly"
// #endif

/* Py_UNICODE was the native Unicode storage format (code unit) used by
   Python and represents a single Unicode element in the Unicode type.
   With PEP 393, Py_UNICODE is deprecated and replaced with a
   typedef to wchar_t. */
// #define PY_UNICODE_TYPE wchar_t
/* Py_DEPRECATED(3.3) */

/* --- Internal Unicode Operations ---------------------------------------- */

// #ifndef USE_UNICODE_WCHAR_CACHE
public static final int USE_UNICODE_WCHAR_CACHE = 1;
// #endif /* USE_UNICODE_WCHAR_CACHE */

/* Since splitting on whitespace is an important use case, and
   whitespace in most situations is solely ASCII whitespace, we
   optimize for the common case by using a quick look-up table
   _Py_ascii_whitespace (see below) with an inlined check.

 */
// #define Py_UNICODE_ISSPACE(ch)
//     ((Py_UCS4)(ch) < 128 ? _Py_ascii_whitespace[(ch)] : _PyUnicode_IsWhitespace(ch))

// #define Py_UNICODE_ISLOWER(ch) _PyUnicode_IsLowercase(ch)
// #define Py_UNICODE_ISUPPER(ch) _PyUnicode_IsUppercase(ch)
// #define Py_UNICODE_ISTITLE(ch) _PyUnicode_IsTitlecase(ch)
// #define Py_UNICODE_ISLINEBREAK(ch) _PyUnicode_IsLinebreak(ch)

// #define Py_UNICODE_TOLOWER(ch) _PyUnicode_ToLowercase(ch)
// #define Py_UNICODE_TOUPPER(ch) _PyUnicode_ToUppercase(ch)
// #define Py_UNICODE_TOTITLE(ch) _PyUnicode_ToTitlecase(ch)

// #define Py_UNICODE_ISDECIMAL(ch) _PyUnicode_IsDecimalDigit(ch)
// #define Py_UNICODE_ISDIGIT(ch) _PyUnicode_IsDigit(ch)
// #define Py_UNICODE_ISNUMERIC(ch) _PyUnicode_IsNumeric(ch)
// #define Py_UNICODE_ISPRINTABLE(ch) _PyUnicode_IsPrintable(ch)

// #define Py_UNICODE_TODECIMAL(ch) _PyUnicode_ToDecimalDigit(ch)
// #define Py_UNICODE_TODIGIT(ch) _PyUnicode_ToDigit(ch)
// #define Py_UNICODE_TONUMERIC(ch) _PyUnicode_ToNumeric(ch)

// #define Py_UNICODE_ISALPHA(ch) _PyUnicode_IsAlpha(ch)

// #define Py_UNICODE_ISALNUM(ch)
//        (Py_UNICODE_ISALPHA(ch) ||
//     Py_UNICODE_ISDECIMAL(ch) ||
//     Py_UNICODE_ISDIGIT(ch) ||
//     Py_UNICODE_ISNUMERIC(ch))

@NoException public static native @Deprecated void Py_UNICODE_COPY(@Cast("Py_UNICODE*") Pointer target, @Cast("const Py_UNICODE*") Pointer source, @Cast("Py_ssize_t") long length);

@NoException public static native @Deprecated void Py_UNICODE_FILL(@Cast("Py_UNICODE*") Pointer target, @Cast("Py_UNICODE") char value, @Cast("Py_ssize_t") long length);
@NoException public static native @Deprecated void Py_UNICODE_FILL(@Cast("Py_UNICODE*") Pointer target, @Cast("Py_UNICODE") int value, @Cast("Py_ssize_t") long length);

/* macros to work with surrogates */
// #define Py_UNICODE_IS_SURROGATE(ch) (0xD800 <= (ch) && (ch) <= 0xDFFF)
// #define Py_UNICODE_IS_HIGH_SURROGATE(ch) (0xD800 <= (ch) && (ch) <= 0xDBFF)
// #define Py_UNICODE_IS_LOW_SURROGATE(ch) (0xDC00 <= (ch) && (ch) <= 0xDFFF)
/* Join two surrogate characters and return a single Py_UCS4 value. */
// #define Py_UNICODE_JOIN_SURROGATES(high, low)
//     (((((Py_UCS4)(high) & 0x03FF) << 10) |
//       ((Py_UCS4)(low) & 0x03FF)) + 0x10000)
/* high surrogate = top 10 bits added to D800 */
// #define Py_UNICODE_HIGH_SURROGATE(ch) (0xD800 - (0x10000 >> 10) + ((ch) >> 10))
/* low surrogate = bottom 10 bits added to DC00 */
// #define Py_UNICODE_LOW_SURROGATE(ch) (0xDC00 + ((ch) & 0x3FF))
// Targeting ../PyASCIIObject.java


// Targeting ../PyCompactUnicodeObject.java


// Targeting ../PyUnicodeObject.java



@NoException public static native int _PyUnicode_CheckConsistency(
    PyObject op,
    int check_content);

/* Fast access macros */

/* Returns the deprecated Py_UNICODE representation's size in code units
   (this includes surrogate pairs as 2 units).
   If the Py_UNICODE representation is not available, it will be computed
   on request.  Use PyUnicode_GET_LENGTH() for the length in code points. */

/* Py_DEPRECATED(3.3) */
// #define PyUnicode_GET_SIZE(op)
//     (assert(PyUnicode_Check(op)),
//      (((PyASCIIObject *)(op))->wstr) ?
//       PyUnicode_WSTR_LENGTH(op) :
//       ((void)PyUnicode_AsUnicode(_PyObject_CAST(op)),
//        assert(((PyASCIIObject *)(op))->wstr),
//        PyUnicode_WSTR_LENGTH(op)))

/* Py_DEPRECATED(3.3) */
// #define PyUnicode_GET_DATA_SIZE(op)
//     (PyUnicode_GET_SIZE(op) * Py_UNICODE_SIZE)

/* Alias for PyUnicode_AsUnicode().  This will create a wchar_t/Py_UNICODE
   representation on demand.  Using this macro is very inefficient now,
   try to port your code to use the new PyUnicode_*BYTE_DATA() macros or
   use PyUnicode_WRITE() and PyUnicode_READ(). */

/* Py_DEPRECATED(3.3) */
// #define PyUnicode_AS_UNICODE(op)
//     (assert(PyUnicode_Check(op)),
//      (((PyASCIIObject *)(op))->wstr) ? (((PyASCIIObject *)(op))->wstr) :
//       PyUnicode_AsUnicode(_PyObject_CAST(op)))

/* Py_DEPRECATED(3.3) */
// #define PyUnicode_AS_DATA(op)
//     ((const char *)(PyUnicode_AS_UNICODE(op)))


/* --- Flexible String Representation Helper Macros (PEP 393) -------------- */

/* Values for PyASCIIObject.state: */

/* Interning state. */
public static final int SSTATE_NOT_INTERNED = 0;
public static final int SSTATE_INTERNED_MORTAL = 1;
public static final int SSTATE_INTERNED_IMMORTAL = 2;

/* Return true if the string contains only ASCII characters, or 0 if not. The
   string may be compact (PyUnicode_IS_COMPACT_ASCII) or not, but must be
   ready. */
// #define PyUnicode_IS_ASCII(op)
//     (assert(PyUnicode_Check(op)),
//      assert(PyUnicode_IS_READY(op)),
//      ((PyASCIIObject*)op)->state.ascii)

/* Return true if the string is compact or 0 if not.
   No type checks or Ready calls are performed. */
// #define PyUnicode_IS_COMPACT(op)
//     (((PyASCIIObject*)(op))->state.compact)

/* Return true if the string is a compact ASCII string (use PyASCIIObject
   structure), or 0 if not.  No type checks or Ready calls are performed. */
// #define PyUnicode_IS_COMPACT_ASCII(op)
//     (((PyASCIIObject*)op)->state.ascii && PyUnicode_IS_COMPACT(op))

/** enum PyUnicode_Kind */
public static final int
/* String contains only wstr byte characters.  This is only possible
   when the string was created with a legacy API and _PyUnicode_Ready()
   has not been called yet.  */
    PyUnicode_WCHAR_KIND = 0,
/* Return values of the PyUnicode_KIND() macro: */
    PyUnicode_1BYTE_KIND = 1,
    PyUnicode_2BYTE_KIND = 2,
    PyUnicode_4BYTE_KIND = 4;

/* Return pointers to the canonical representation cast to unsigned char,
   Py_UCS2, or Py_UCS4 for direct character access.
   No checks are performed, use PyUnicode_KIND() before to ensure
   these will work correctly. */

// #define PyUnicode_1BYTE_DATA(op) ((Py_UCS1*)PyUnicode_DATA(op))
// #define PyUnicode_2BYTE_DATA(op) ((Py_UCS2*)PyUnicode_DATA(op))
// #define PyUnicode_4BYTE_DATA(op) ((Py_UCS4*)PyUnicode_DATA(op))

/* Return one of the PyUnicode_*_KIND values defined above. */
// #define PyUnicode_KIND(op)
//     (assert(PyUnicode_Check(op)),
//      assert(PyUnicode_IS_READY(op)),
//      ((PyASCIIObject *)(op))->state.kind)

/* Return a void pointer to the raw unicode buffer. */
// #define _PyUnicode_COMPACT_DATA(op)
//     (PyUnicode_IS_ASCII(op) ?
//      ((void*)((PyASCIIObject*)(op) + 1)) :
//      ((void*)((PyCompactUnicodeObject*)(op) + 1)))

// #define _PyUnicode_NONCOMPACT_DATA(op)
//     (assert(((PyUnicodeObject*)(op))->data.any),
//      ((((PyUnicodeObject *)(op))->data.any)))

// #define PyUnicode_DATA(op)
//     (assert(PyUnicode_Check(op)),
//      PyUnicode_IS_COMPACT(op) ? _PyUnicode_COMPACT_DATA(op) :
//      _PyUnicode_NONCOMPACT_DATA(op))

/* In the access macros below, "kind" may be evaluated more than once.
   All other macro parameters are evaluated exactly once, so it is safe
   to put side effects into them (such as increasing the index). */

/* Write into the canonical representation, this macro does not do any sanity
   checks and is intended for usage in loops.  The caller should cache the
   kind and data pointers obtained from other macro calls.
   index is the index in the string (starts at 0) and value is the new
   code point value which should be written to that location. */
// #define PyUnicode_WRITE(kind, data, index, value)
//     do {
//         switch ((kind)) {
//         case PyUnicode_1BYTE_KIND: {
//             ((Py_UCS1 *)(data))[(index)] = (Py_UCS1)(value);
//             break;
//         }
//         case PyUnicode_2BYTE_KIND: {
//             ((Py_UCS2 *)(data))[(index)] = (Py_UCS2)(value);
//             break;
//         }
//         default: {
//             assert((kind) == PyUnicode_4BYTE_KIND);
//             ((Py_UCS4 *)(data))[(index)] = (Py_UCS4)(value);
//         }
//         }
//     } while (0)

/* Read a code point from the string's canonical representation.  No checks
   or ready calls are performed. */
// #define PyUnicode_READ(kind, data, index)
//     ((Py_UCS4)
//     ((kind) == PyUnicode_1BYTE_KIND ?
//         ((const Py_UCS1 *)(data))[(index)] :
//         ((kind) == PyUnicode_2BYTE_KIND ?
//             ((const Py_UCS2 *)(data))[(index)] :
//             ((const Py_UCS4 *)(data))[(index)]
//         )
//     ))

/* PyUnicode_READ_CHAR() is less efficient than PyUnicode_READ() because it
   calls PyUnicode_KIND() and might call it twice.  For single reads, use
   PyUnicode_READ_CHAR, for multiple consecutive reads callers should
   cache kind and use PyUnicode_READ instead. */
// #define PyUnicode_READ_CHAR(unicode, index)
//     (assert(PyUnicode_Check(unicode)),
//      assert(PyUnicode_IS_READY(unicode)),
//      (Py_UCS4)
//         (PyUnicode_KIND((unicode)) == PyUnicode_1BYTE_KIND ?
//             ((const Py_UCS1 *)(PyUnicode_DATA((unicode))))[(index)] :
//             (PyUnicode_KIND((unicode)) == PyUnicode_2BYTE_KIND ?
//                 ((const Py_UCS2 *)(PyUnicode_DATA((unicode))))[(index)] :
//                 ((const Py_UCS4 *)(PyUnicode_DATA((unicode))))[(index)]
//             )
//         ))

/* Returns the length of the unicode string. The caller has to make sure that
   the string has it's canonical representation set before calling
   this macro.  Call PyUnicode_(FAST_)Ready to ensure that. */
// #define PyUnicode_GET_LENGTH(op)
//     (assert(PyUnicode_Check(op)),
//      assert(PyUnicode_IS_READY(op)),
//      ((PyASCIIObject *)(op))->length)


/* Fast check to determine whether an object is ready. Equivalent to
   PyUnicode_IS_COMPACT(op) || ((PyUnicodeObject*)(op))->data.any */

// #define PyUnicode_IS_READY(op) (((PyASCIIObject*)op)->state.ready)

/* PyUnicode_READY() does less work than _PyUnicode_Ready() in the best
   case.  If the canonical representation is not yet set, it will still call
   _PyUnicode_Ready().
   Returns 0 on success and -1 on errors. */
// #define PyUnicode_READY(op)
//     (assert(PyUnicode_Check(op)),
//      (PyUnicode_IS_READY(op) ?
//       0 : _PyUnicode_Ready(_PyObject_CAST(op))))

/* Return a maximum character value which is suitable for creating another
   string based on op.  This is always an approximation but more efficient
   than iterating over the string. */
// #define PyUnicode_MAX_CHAR_VALUE(op)
//     (assert(PyUnicode_IS_READY(op)),
//      (PyUnicode_IS_ASCII(op) ?
//       (0x7f) :
//       (PyUnicode_KIND(op) == PyUnicode_1BYTE_KIND ?
//        (0xff) :
//        (PyUnicode_KIND(op) == PyUnicode_2BYTE_KIND ?
//         (0xffff) :
//         (0x10ffff)))))

@NoException public static native @Cast("Py_ssize_t") @Deprecated long _PyUnicode_get_wstr_length(PyObject op);
// #define PyUnicode_WSTR_LENGTH(op) _PyUnicode_get_wstr_length((PyObject*)op)

/* === Public API ========================================================= */

/* --- Plain Py_UNICODE --------------------------------------------------- */

/* With PEP 393, this is the recommended way to allocate a new unicode object.
   This function will allocate the object and its buffer in a single memory
   block.  Objects created using this function are not resizable. */
@NoException public static native PyObject PyUnicode_New(
    @Cast("Py_ssize_t") long size,
    @Cast("Py_UCS4") int maxchar
    );

/* Initializes the canonical string representation from the deprecated
   wstr/Py_UNICODE representation. This function is used to convert Unicode
   objects which were created using the old API to the new flexible format
   introduced with PEP 393.

   Don't call this function directly, use the public PyUnicode_READY() macro
   instead. */
@NoException public static native int _PyUnicode_Ready(
    PyObject unicode
    );

/* Get a copy of a Unicode string. */
@NoException public static native PyObject _PyUnicode_Copy(
    PyObject unicode
    );

/* Copy character from one unicode object into another, this function performs
   character conversion when necessary and falls back to memcpy() if possible.

   Fail if to is too small (smaller than *how_many* or smaller than
   len(from)-from_start), or if kind(from[from_start:from_start+how_many]) >
   kind(to), or if *to* has more than 1 reference.

   Return the number of written character, or return -1 and raise an exception
   on error.

   Pseudo-code:

       how_many = min(how_many, len(from) - from_start)
       to[to_start:to_start+how_many] = from[from_start:from_start+how_many]
       return how_many

   Note: The function doesn't write a terminating null character.
   */
@NoException public static native @Cast("Py_ssize_t") long PyUnicode_CopyCharacters(
    PyObject to,
    @Cast("Py_ssize_t") long to_start,
    PyObject from,
    @Cast("Py_ssize_t") long from_start,
    @Cast("Py_ssize_t") long how_many
    );

/* Unsafe version of PyUnicode_CopyCharacters(): don't check arguments and so
   may crash if parameters are invalid (e.g. if the output string
   is too short). */
@NoException public static native void _PyUnicode_FastCopyCharacters(
    PyObject to,
    @Cast("Py_ssize_t") long to_start,
    PyObject from,
    @Cast("Py_ssize_t") long from_start,
    @Cast("Py_ssize_t") long how_many
    );

/* Fill a string with a character: write fill_char into
   unicode[start:start+length].

   Fail if fill_char is bigger than the string maximum character, or if the
   string has more than 1 reference.

   Return the number of written character, or return -1 and raise an exception
   on error. */
@NoException public static native @Cast("Py_ssize_t") long PyUnicode_Fill(
    PyObject unicode,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_UCS4") int fill_char
    );

/* Unsafe version of PyUnicode_Fill(): don't check arguments and so may crash
   if parameters are invalid (e.g. if length is longer than the string). */
@NoException public static native void _PyUnicode_FastFill(
    PyObject unicode,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_UCS4") int fill_char
    );

/* Create a Unicode Object from the Py_UNICODE buffer u of the given
   size.

   u may be NULL which causes the contents to be undefined. It is the
   user's responsibility to fill in the needed data afterwards. Note
   that modifying the Unicode object contents after construction is
   only allowed if u was set to NULL.

   The buffer is copied into the new object. */
@NoException public static native @Deprecated PyObject PyUnicode_FromUnicode(
    @Cast("const Py_UNICODE*") Pointer u,
    @Cast("Py_ssize_t") long size
    );

/* Create a new string from a buffer of Py_UCS1, Py_UCS2 or Py_UCS4 characters.
   Scan the string to find the maximum character. */
@NoException public static native PyObject PyUnicode_FromKindAndData(
    int kind,
    @Const Pointer buffer,
    @Cast("Py_ssize_t") long size);

/* Create a new string from a buffer of ASCII characters.
   WARNING: Don't check if the string contains any non-ASCII character. */
@NoException public static native PyObject _PyUnicode_FromASCII(
    @Cast("const char*") BytePointer buffer,
    @Cast("Py_ssize_t") long size);
@NoException public static native PyObject _PyUnicode_FromASCII(
    String buffer,
    @Cast("Py_ssize_t") long size);

/* Compute the maximum character of the substring unicode[start:end].
   Return 127 for an empty string. */
@NoException public static native @Cast("Py_UCS4") int _PyUnicode_FindMaxChar(
    PyObject unicode,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end);

/* Return a read-only pointer to the Unicode object's internal
   Py_UNICODE buffer.
   If the wchar_t/Py_UNICODE representation is not yet available, this
   function will calculate it. */
@NoException public static native @Cast("Py_UNICODE*") @Deprecated Pointer PyUnicode_AsUnicode(
    PyObject unicode
    );

/* Similar to PyUnicode_AsUnicode(), but raises a ValueError if the string
   contains null characters. */
@NoException public static native @Cast("const Py_UNICODE*") Pointer _PyUnicode_AsUnicode(
    PyObject unicode
    );

/* Return a read-only pointer to the Unicode object's internal
   Py_UNICODE buffer and save the length at size.
   If the wchar_t/Py_UNICODE representation is not yet available, this
   function will calculate it. */

@NoException public static native @Cast("Py_UNICODE*") @Deprecated Pointer PyUnicode_AsUnicodeAndSize(
    PyObject unicode,
    @Cast("Py_ssize_t*") SizeTPointer size
    );
// Targeting ../_PyUnicodeWriter.java



/* Initialize a Unicode writer.
 *
 * By default, the minimum buffer size is 0 character and overallocation is
 * disabled. Set min_length, min_char and overallocate attributes to control
 * the allocation of the buffer. */
@NoException public static native void _PyUnicodeWriter_Init(_PyUnicodeWriter writer);

/* Prepare the buffer to write 'length' characters
   with the specified maximum character.

   Return 0 on success, raise an exception and return -1 on error. */
// #define _PyUnicodeWriter_Prepare(WRITER, LENGTH, MAXCHAR)
//     (((MAXCHAR) <= (WRITER)->maxchar
//       && (LENGTH) <= (WRITER)->size - (WRITER)->pos)
//      ? 0
//      : (((LENGTH) == 0)
//         ? 0
//         : _PyUnicodeWriter_PrepareInternal((WRITER), (LENGTH), (MAXCHAR))))

/* Don't call this function directly, use the _PyUnicodeWriter_Prepare() macro
   instead. */
@NoException public static native int _PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter writer,
                                 @Cast("Py_ssize_t") long length, @Cast("Py_UCS4") int maxchar);

/* Prepare the buffer to have at least the kind KIND.
   For example, kind=PyUnicode_2BYTE_KIND ensures that the writer will
   support characters in range U+000-U+FFFF.

   Return 0 on success, raise an exception and return -1 on error. */
// #define _PyUnicodeWriter_PrepareKind(WRITER, KIND)
//     (assert((KIND) != PyUnicode_WCHAR_KIND),
//      (KIND) <= (WRITER)->kind
//      ? 0
//      : _PyUnicodeWriter_PrepareKindInternal((WRITER), (KIND)))

/* Don't call this function directly, use the _PyUnicodeWriter_PrepareKind()
   macro instead. */
@NoException public static native int _PyUnicodeWriter_PrepareKindInternal(_PyUnicodeWriter writer,
                                     @Cast("PyUnicode_Kind") int kind);

/* Append a Unicode character.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyUnicodeWriter_WriteChar(_PyUnicodeWriter writer,
    @Cast("Py_UCS4") int ch
    );

/* Append a Unicode string.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyUnicodeWriter_WriteStr(_PyUnicodeWriter writer,
    PyObject str
    );

/* Append a substring of a Unicode string.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyUnicodeWriter_WriteSubstring(_PyUnicodeWriter writer,
    PyObject str,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end
    );

/* Append an ASCII-encoded byte string.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyUnicodeWriter_WriteASCIIString(_PyUnicodeWriter writer,
    @Cast("const char*") BytePointer str,
    @Cast("Py_ssize_t") long len
    );
@NoException public static native int _PyUnicodeWriter_WriteASCIIString(_PyUnicodeWriter writer,
    String str,
    @Cast("Py_ssize_t") long len
    );

/* Append a latin1-encoded byte string.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyUnicodeWriter_WriteLatin1String(_PyUnicodeWriter writer,
    @Cast("const char*") BytePointer str,
    @Cast("Py_ssize_t") long len
    );
@NoException public static native int _PyUnicodeWriter_WriteLatin1String(_PyUnicodeWriter writer,
    String str,
    @Cast("Py_ssize_t") long len
    );

/* Get the value of the writer as a Unicode string. Clear the
   buffer of the writer. Raise an exception and return NULL
   on error. */
@NoException public static native PyObject _PyUnicodeWriter_Finish(_PyUnicodeWriter writer);

/* Deallocate memory of a writer (clear its internal buffer). */
@NoException public static native void _PyUnicodeWriter_Dealloc(_PyUnicodeWriter writer);


/* Format the object based on the format_spec, as defined in PEP 3101
   (Advanced String Formatting). */
@NoException public static native int _PyUnicode_FormatAdvancedWriter(
    _PyUnicodeWriter writer,
    PyObject obj,
    PyObject format_spec,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end);

/* --- Manage the default encoding ---------------------------------------- */

/* Returns a pointer to the default encoding (UTF-8) of the
   Unicode object unicode.

   Like PyUnicode_AsUTF8AndSize(), this also caches the UTF-8 representation
   in the unicodeobject.

   _PyUnicode_AsString is a #define for PyUnicode_AsUTF8 to
   support the previous internal function with the same behaviour.

   Use of this API is DEPRECATED since no size information can be
   extracted from the returned data.
*/

@NoException public static native @Cast("const char*") BytePointer PyUnicode_AsUTF8(PyObject unicode);

// #define _PyUnicode_AsString PyUnicode_AsUTF8

/* --- Generic Codecs ----------------------------------------------------- */

/* Encodes a Py_UNICODE buffer of the given size and returns a
   Python string object. */
@NoException public static native @Deprecated PyObject PyUnicode_Encode(
    @Cast("const Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long size,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated PyObject PyUnicode_Encode(
    @Cast("const Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long size,
    String encoding,
    String errors
    );

/* --- UTF-7 Codecs ------------------------------------------------------- */

@NoException public static native @Deprecated PyObject PyUnicode_EncodeUTF7(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    int base64SetO,
    int base64WhiteSpace,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated PyObject PyUnicode_EncodeUTF7(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    int base64SetO,
    int base64WhiteSpace,
    String errors
    );

@NoException public static native PyObject _PyUnicode_EncodeUTF7(
    PyObject unicode,
    int base64SetO,
    int base64WhiteSpace,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject _PyUnicode_EncodeUTF7(
    PyObject unicode,
    int base64SetO,
    int base64WhiteSpace,
    String errors
    );

/* --- UTF-8 Codecs ------------------------------------------------------- */

@NoException public static native PyObject _PyUnicode_AsUTF8String(
    PyObject unicode,
    @Cast("const char*") BytePointer errors);
@NoException public static native PyObject _PyUnicode_AsUTF8String(
    PyObject unicode,
    String errors);

@NoException public static native @Deprecated PyObject PyUnicode_EncodeUTF8(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated PyObject PyUnicode_EncodeUTF8(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    String errors
    );

/* --- UTF-32 Codecs ------------------------------------------------------ */

@NoException public static native @Deprecated PyObject PyUnicode_EncodeUTF32(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    int byteorder
    );
@NoException public static native @Deprecated PyObject PyUnicode_EncodeUTF32(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    String errors,
    int byteorder
    );

@NoException public static native PyObject _PyUnicode_EncodeUTF32(
    PyObject object,
    @Cast("const char*") BytePointer errors,
    int byteorder
    );
@NoException public static native PyObject _PyUnicode_EncodeUTF32(
    PyObject object,
    String errors,
    int byteorder
    );

/* --- UTF-16 Codecs ------------------------------------------------------ */

/* Returns a Python string object holding the UTF-16 encoded value of
   the Unicode data.

   If byteorder is not 0, output is written according to the following
   byte order:

   byteorder == -1: little endian
   byteorder == 0:  native byte order (writes a BOM mark)
   byteorder == 1:  big endian

   If byteorder is 0, the output string will always start with the
   Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is
   prepended.

   Note that Py_UNICODE data is being interpreted as UTF-16 reduced to
   UCS-2. This trick makes it possible to add full UTF-16 capabilities
   at a later point without compromising the APIs.

*/
@NoException public static native @Deprecated PyObject PyUnicode_EncodeUTF16(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    int byteorder
    );
@NoException public static native @Deprecated PyObject PyUnicode_EncodeUTF16(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    String errors,
    int byteorder
    );

@NoException public static native PyObject _PyUnicode_EncodeUTF16(
    PyObject unicode,
    @Cast("const char*") BytePointer errors,
    int byteorder
    );
@NoException public static native PyObject _PyUnicode_EncodeUTF16(
    PyObject unicode,
    String errors,
    int byteorder
    );

/* --- Unicode-Escape Codecs ---------------------------------------------- */

/* Variant of PyUnicode_DecodeUnicodeEscape that supports partial decoding. */
@NoException public static native PyObject _PyUnicode_DecodeUnicodeEscapeStateful(
        @Cast("const char*") BytePointer string,
        @Cast("Py_ssize_t") long length,
        @Cast("const char*") BytePointer errors,
        @Cast("Py_ssize_t*") SizeTPointer consumed
);
@NoException public static native PyObject _PyUnicode_DecodeUnicodeEscapeStateful(
        String string,
        @Cast("Py_ssize_t") long length,
        String errors,
        @Cast("Py_ssize_t*") SizeTPointer consumed
);

/* Helper for PyUnicode_DecodeUnicodeEscape that detects invalid escape
   chars. */
@NoException public static native PyObject _PyUnicode_DecodeUnicodeEscapeInternal(
        @Cast("const char*") BytePointer string,
        @Cast("Py_ssize_t") long length,
        @Cast("const char*") BytePointer errors,
        @Cast("Py_ssize_t*") SizeTPointer consumed,
        @Cast("const char**") PointerPointer first_invalid_escape
);
@NoException public static native PyObject _PyUnicode_DecodeUnicodeEscapeInternal(
        @Cast("const char*") BytePointer string,
        @Cast("Py_ssize_t") long length,
        @Cast("const char*") BytePointer errors,
        @Cast("Py_ssize_t*") SizeTPointer consumed,
        @Cast("const char**") @ByPtrPtr BytePointer first_invalid_escape
);
@NoException public static native PyObject _PyUnicode_DecodeUnicodeEscapeInternal(
        String string,
        @Cast("Py_ssize_t") long length,
        String errors,
        @Cast("Py_ssize_t*") SizeTPointer consumed,
        @Cast("const char**") @ByPtrPtr ByteBuffer first_invalid_escape
);
@NoException public static native PyObject _PyUnicode_DecodeUnicodeEscapeInternal(
        @Cast("const char*") BytePointer string,
        @Cast("Py_ssize_t") long length,
        @Cast("const char*") BytePointer errors,
        @Cast("Py_ssize_t*") SizeTPointer consumed,
        @Cast("const char**") @ByPtrPtr byte[] first_invalid_escape
);
@NoException public static native PyObject _PyUnicode_DecodeUnicodeEscapeInternal(
        String string,
        @Cast("Py_ssize_t") long length,
        String errors,
        @Cast("Py_ssize_t*") SizeTPointer consumed,
        @Cast("const char**") @ByPtrPtr BytePointer first_invalid_escape
);
@NoException public static native PyObject _PyUnicode_DecodeUnicodeEscapeInternal(
        @Cast("const char*") BytePointer string,
        @Cast("Py_ssize_t") long length,
        @Cast("const char*") BytePointer errors,
        @Cast("Py_ssize_t*") SizeTPointer consumed,
        @Cast("const char**") @ByPtrPtr ByteBuffer first_invalid_escape
);
@NoException public static native PyObject _PyUnicode_DecodeUnicodeEscapeInternal(
        String string,
        @Cast("Py_ssize_t") long length,
        String errors,
        @Cast("Py_ssize_t*") SizeTPointer consumed,
        @Cast("const char**") @ByPtrPtr byte[] first_invalid_escape
);

@NoException public static native @Deprecated PyObject PyUnicode_EncodeUnicodeEscape(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length
    );

/* --- Raw-Unicode-Escape Codecs ------------------------------------------ */

@NoException public static native @Deprecated PyObject PyUnicode_EncodeRawUnicodeEscape(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length
    );

/* Variant of PyUnicode_DecodeRawUnicodeEscape that supports partial decoding. */
@NoException public static native PyObject _PyUnicode_DecodeRawUnicodeEscapeStateful(
        @Cast("const char*") BytePointer string,
        @Cast("Py_ssize_t") long length,
        @Cast("const char*") BytePointer errors,
        @Cast("Py_ssize_t*") SizeTPointer consumed
);
@NoException public static native PyObject _PyUnicode_DecodeRawUnicodeEscapeStateful(
        String string,
        @Cast("Py_ssize_t") long length,
        String errors,
        @Cast("Py_ssize_t*") SizeTPointer consumed
);

/* --- Latin-1 Codecs ----------------------------------------------------- */

@NoException public static native PyObject _PyUnicode_AsLatin1String(
    PyObject unicode,
    @Cast("const char*") BytePointer errors);
@NoException public static native PyObject _PyUnicode_AsLatin1String(
    PyObject unicode,
    String errors);

@NoException public static native @Deprecated PyObject PyUnicode_EncodeLatin1(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated PyObject PyUnicode_EncodeLatin1(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    String errors
    );

/* --- ASCII Codecs ------------------------------------------------------- */

@NoException public static native PyObject _PyUnicode_AsASCIIString(
    PyObject unicode,
    @Cast("const char*") BytePointer errors);
@NoException public static native PyObject _PyUnicode_AsASCIIString(
    PyObject unicode,
    String errors);

@NoException public static native @Deprecated PyObject PyUnicode_EncodeASCII(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated PyObject PyUnicode_EncodeASCII(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    String errors
    );

/* --- Character Map Codecs ----------------------------------------------- */

@NoException public static native @Deprecated PyObject PyUnicode_EncodeCharmap(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    PyObject mapping,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated PyObject PyUnicode_EncodeCharmap(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    PyObject mapping,
    String errors
    );

@NoException public static native PyObject _PyUnicode_EncodeCharmap(
    PyObject unicode,
    PyObject mapping,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject _PyUnicode_EncodeCharmap(
    PyObject unicode,
    PyObject mapping,
    String errors
    );

/* Translate a Py_UNICODE buffer of the given length by applying a
   character mapping table to it and return the resulting Unicode
   object.

   The mapping table must map Unicode ordinal integers to Unicode strings,
   Unicode ordinal integers or None (causing deletion of the character).

   Mapping tables may be dictionaries or sequences. Unmapped character
   ordinals (ones which cause a LookupError) are left untouched and
   are copied as-is.

*/
@NoException public static native @Deprecated PyObject PyUnicode_TranslateCharmap(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    PyObject table,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated PyObject PyUnicode_TranslateCharmap(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    PyObject table,
    String errors
    );

/* --- MBCS codecs for Windows -------------------------------------------- */

// #ifdef MS_WINDOWS
// #endif

/* --- Decimal Encoder ---------------------------------------------------- */

/* Takes a Unicode string holding a decimal value and writes it into
   an output buffer using standard ASCII digit codes.

   The output buffer has to provide at least length+1 bytes of storage
   area. The output string is 0-terminated.

   The encoder converts whitespace to ' ', decimal characters to their
   corresponding ASCII digit and all other Latin-1 characters except
   \0 as-is. Characters outside this range (Unicode ordinals 1-256)
   are treated as errors. This includes embedded NULL bytes.

   Error handling is defined by the errors argument:

      NULL or "strict": raise a ValueError
      "ignore": ignore the wrong characters (these are not copied to the
                output buffer)
      "replace": replaces illegal characters with '?'

   Returns 0 on success, -1 on failure.

*/

@NoException public static native @Deprecated int PyUnicode_EncodeDecimal(
    @Cast("Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long length,
    @Cast("char*") BytePointer output,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated int PyUnicode_EncodeDecimal(
    @Cast("Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long length,
    @Cast("char*") ByteBuffer output,
    String errors
    );
@NoException public static native @Deprecated int PyUnicode_EncodeDecimal(
    @Cast("Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long length,
    @Cast("char*") byte[] output,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated int PyUnicode_EncodeDecimal(
    @Cast("Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long length,
    @Cast("char*") BytePointer output,
    String errors
    );
@NoException public static native @Deprecated int PyUnicode_EncodeDecimal(
    @Cast("Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long length,
    @Cast("char*") ByteBuffer output,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native @Deprecated int PyUnicode_EncodeDecimal(
    @Cast("Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long length,
    @Cast("char*") byte[] output,
    String errors
    );

/* Transforms code points that have decimal digit property to the
   corresponding ASCII digit code points.

   Returns a new Unicode string on success, NULL on failure.
*/

@NoException public static native @Deprecated PyObject PyUnicode_TransformDecimalToASCII(
    @Cast("Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long length
    );

/* Coverts a Unicode object holding a decimal value to an ASCII string
   for using in int, float and complex parsers.
   Transforms code points that have decimal digit property to the
   corresponding ASCII digit code points.  Transforms spaces to ASCII.
   Transforms code points starting from the first non-ASCII code point that
   is neither a decimal digit nor a space to the end into '?'. */

@NoException public static native PyObject _PyUnicode_TransformDecimalAndSpaceToASCII(
    PyObject unicode
    );

/* --- Methods & Slots ---------------------------------------------------- */

@NoException public static native PyObject _PyUnicode_JoinArray(
    PyObject separator,
    @Cast("PyObject*const*") PointerPointer items,
    @Cast("Py_ssize_t") long seqlen
    );
@NoException public static native PyObject _PyUnicode_JoinArray(
    PyObject separator,
    @ByPtrPtr PyObject items,
    @Cast("Py_ssize_t") long seqlen
    );

/* Test whether a unicode is equal to ASCII identifier.  Return 1 if true,
   0 otherwise.  The right argument must be ASCII identifier.
   Any error occurs inside will be cleared before return. */
@NoException public static native int _PyUnicode_EqualToASCIIId(
    PyObject left,
    _Py_Identifier right
    );

/* Test whether a unicode is equal to ASCII string.  Return 1 if true,
   0 otherwise.  The right argument must be ASCII-encoded string.
   Any error occurs inside will be cleared before return. */
@NoException public static native int _PyUnicode_EqualToASCIIString(
    PyObject left,
    @Cast("const char*") BytePointer right
    );
@NoException public static native int _PyUnicode_EqualToASCIIString(
    PyObject left,
    String right
    );

/* Externally visible for str.strip(unicode) */
@NoException public static native PyObject _PyUnicode_XStrip(
    PyObject self,
    int striptype,
    PyObject sepobj
    );

/* Using explicit passed-in values, insert the thousands grouping
   into the string pointed to by buffer.  For the argument descriptions,
   see Objects/stringlib/localeutil.h */
@NoException public static native @Cast("Py_ssize_t") long _PyUnicode_InsertThousandsGrouping(
    _PyUnicodeWriter writer,
    @Cast("Py_ssize_t") long n_buffer,
    PyObject digits,
    @Cast("Py_ssize_t") long d_pos,
    @Cast("Py_ssize_t") long n_digits,
    @Cast("Py_ssize_t") long min_width,
    @Cast("const char*") BytePointer grouping,
    PyObject thousands_sep,
    @Cast("Py_UCS4*") IntPointer maxchar);
@NoException public static native @Cast("Py_ssize_t") long _PyUnicode_InsertThousandsGrouping(
    _PyUnicodeWriter writer,
    @Cast("Py_ssize_t") long n_buffer,
    PyObject digits,
    @Cast("Py_ssize_t") long d_pos,
    @Cast("Py_ssize_t") long n_digits,
    @Cast("Py_ssize_t") long min_width,
    String grouping,
    PyObject thousands_sep,
    @Cast("Py_UCS4*") IntBuffer maxchar);
@NoException public static native @Cast("Py_ssize_t") long _PyUnicode_InsertThousandsGrouping(
    _PyUnicodeWriter writer,
    @Cast("Py_ssize_t") long n_buffer,
    PyObject digits,
    @Cast("Py_ssize_t") long d_pos,
    @Cast("Py_ssize_t") long n_digits,
    @Cast("Py_ssize_t") long min_width,
    @Cast("const char*") BytePointer grouping,
    PyObject thousands_sep,
    @Cast("Py_UCS4*") int[] maxchar);
@NoException public static native @Cast("Py_ssize_t") long _PyUnicode_InsertThousandsGrouping(
    _PyUnicodeWriter writer,
    @Cast("Py_ssize_t") long n_buffer,
    PyObject digits,
    @Cast("Py_ssize_t") long d_pos,
    @Cast("Py_ssize_t") long n_digits,
    @Cast("Py_ssize_t") long min_width,
    String grouping,
    PyObject thousands_sep,
    @Cast("Py_UCS4*") IntPointer maxchar);
@NoException public static native @Cast("Py_ssize_t") long _PyUnicode_InsertThousandsGrouping(
    _PyUnicodeWriter writer,
    @Cast("Py_ssize_t") long n_buffer,
    PyObject digits,
    @Cast("Py_ssize_t") long d_pos,
    @Cast("Py_ssize_t") long n_digits,
    @Cast("Py_ssize_t") long min_width,
    @Cast("const char*") BytePointer grouping,
    PyObject thousands_sep,
    @Cast("Py_UCS4*") IntBuffer maxchar);
@NoException public static native @Cast("Py_ssize_t") long _PyUnicode_InsertThousandsGrouping(
    _PyUnicodeWriter writer,
    @Cast("Py_ssize_t") long n_buffer,
    PyObject digits,
    @Cast("Py_ssize_t") long d_pos,
    @Cast("Py_ssize_t") long n_digits,
    @Cast("Py_ssize_t") long min_width,
    String grouping,
    PyObject thousands_sep,
    @Cast("Py_UCS4*") int[] maxchar);

/* === Characters Type APIs =============================================== */

/* Helper array used by Py_UNICODE_ISSPACE(). */

@MemberGetter public static native @Cast("const unsigned char") byte _Py_ascii_whitespace(int i);
@MemberGetter public static native @Cast("const unsigned char*") BytePointer _Py_ascii_whitespace();

/* These should not be used directly. Use the Py_UNICODE_IS* and
   Py_UNICODE_TO* macros instead.

   These APIs are implemented in Objects/unicodectype.c.

*/

@NoException public static native int _PyUnicode_IsLowercase(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsUppercase(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsTitlecase(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsXidStart(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsXidContinue(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsWhitespace(
    @Cast("const Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsLinebreak(
    @Cast("const Py_UCS4") int ch
    );

/* Py_DEPRECATED(3.3) */ @NoException public static native @Cast("Py_UCS4") int _PyUnicode_ToLowercase(
    @Cast("Py_UCS4") int ch
    );

/* Py_DEPRECATED(3.3) */ @NoException public static native @Cast("Py_UCS4") int _PyUnicode_ToUppercase(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native @Cast("Py_UCS4") @Deprecated int _PyUnicode_ToTitlecase(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_ToLowerFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") IntPointer res
    );
@NoException public static native int _PyUnicode_ToLowerFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") IntBuffer res
    );
@NoException public static native int _PyUnicode_ToLowerFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") int[] res
    );

@NoException public static native int _PyUnicode_ToTitleFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") IntPointer res
    );
@NoException public static native int _PyUnicode_ToTitleFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") IntBuffer res
    );
@NoException public static native int _PyUnicode_ToTitleFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") int[] res
    );

@NoException public static native int _PyUnicode_ToUpperFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") IntPointer res
    );
@NoException public static native int _PyUnicode_ToUpperFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") IntBuffer res
    );
@NoException public static native int _PyUnicode_ToUpperFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") int[] res
    );

@NoException public static native int _PyUnicode_ToFoldedFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") IntPointer res
    );
@NoException public static native int _PyUnicode_ToFoldedFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") IntBuffer res
    );
@NoException public static native int _PyUnicode_ToFoldedFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") int[] res
    );

@NoException public static native int _PyUnicode_IsCaseIgnorable(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsCased(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_ToDecimalDigit(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_ToDigit(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native double _PyUnicode_ToNumeric(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsDecimalDigit(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsDigit(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsNumeric(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsPrintable(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsAlpha(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native PyObject _PyUnicode_FormatLong(PyObject arg0, int arg1, int arg2, int arg3);

/* Return an interned Unicode object for an Identifier; may fail if there is no memory.*/
@NoException public static native PyObject _PyUnicode_FromId(_Py_Identifier arg0);

/* Fast equality check when the inputs are known to be exact unicode types
   and where the hash values are equal (i.e. a very probable match) */
@NoException public static native int _PyUnicode_EQ(PyObject arg0, PyObject arg1);

@NoException public static native int _PyUnicode_WideCharString_Converter(PyObject arg0, Pointer arg1);
@NoException public static native int _PyUnicode_WideCharString_Opt_Converter(PyObject arg0, Pointer arg1);

@NoException public static native @Cast("Py_ssize_t") long _PyUnicode_ScanIdentifier(PyObject arg0);


// Parsed from longobject.h

// #ifndef Py_LONGOBJECT_H
// #define Py_LONGOBJECT_H
// #ifdef __cplusplus
// Targeting ../PyLongObject.java

 /* Revealed in longintrepr.h */

public static native @ByRef PyTypeObject PyLong_Type(); public static native void PyLong_Type(PyTypeObject setter);

// #define PyLong_Check(op)
//         PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_LONG_SUBCLASS)
// #define PyLong_CheckExact(op) Py_IS_TYPE(op, &PyLong_Type)

@NoException public static native PyObject PyLong_FromLong(long arg0);
@NoException public static native PyObject PyLong_FromUnsignedLong(@Cast("unsigned long") long arg0);
@NoException public static native PyObject PyLong_FromSize_t(@Cast("size_t") long arg0);
@NoException public static native PyObject PyLong_FromSsize_t(@Cast("Py_ssize_t") long arg0);
@NoException public static native PyObject PyLong_FromDouble(double arg0);
@NoException public static native long PyLong_AsLong(PyObject arg0);
@NoException public static native long PyLong_AsLongAndOverflow(PyObject arg0, IntPointer arg1);
@NoException public static native long PyLong_AsLongAndOverflow(PyObject arg0, IntBuffer arg1);
@NoException public static native long PyLong_AsLongAndOverflow(PyObject arg0, int[] arg1);
@NoException public static native @Cast("Py_ssize_t") long PyLong_AsSsize_t(PyObject arg0);
@NoException public static native @Cast("size_t") long PyLong_AsSize_t(PyObject arg0);
@NoException public static native @Cast("unsigned long") long PyLong_AsUnsignedLong(PyObject arg0);
@NoException public static native @Cast("unsigned long") long PyLong_AsUnsignedLongMask(PyObject arg0);
// #ifndef Py_LIMITED_API
@NoException public static native int _PyLong_AsInt(PyObject arg0);
// #endif
@NoException public static native PyObject PyLong_GetInfo();

/* It may be useful in the future. I've added it in the PyInt -> PyLong
   cleanup to keep the extra information. [CH] */
// #define PyLong_AS_LONG(op) PyLong_AsLong(op)

/* Issue #1983: pid_t can be longer than a C long on some systems */
// #if !defined(SIZEOF_PID_T) || SIZEOF_PID_T == SIZEOF_INT
public static final String _Py_PARSE_PID = "i";
// #define PyLong_FromPid PyLong_FromLong
// #define PyLong_AsPid PyLong_AsLong
// #elif SIZEOF_PID_T == SIZEOF_LONG
// #define PyLong_FromPid PyLong_FromLong
// #define PyLong_AsPid PyLong_AsLong
// #elif defined(SIZEOF_LONG_LONG) && SIZEOF_PID_T == SIZEOF_LONG_LONG
// #define PyLong_FromPid PyLong_FromLongLong
// #define PyLong_AsPid PyLong_AsLongLong
// #else
// #error "sizeof(pid_t) is neither sizeof(int), sizeof(long) or sizeof(long long)"
// #endif /* SIZEOF_PID_T */

// #if SIZEOF_VOID_P == SIZEOF_INT
public static final String _Py_PARSE_INTPTR = "i";
public static final String _Py_PARSE_UINTPTR = "I";
// #elif SIZEOF_VOID_P == SIZEOF_LONG
// #elif defined(SIZEOF_LONG_LONG) && SIZEOF_VOID_P == SIZEOF_LONG_LONG
// #else
// #  error "void* different in size from int, long and long long"
// #endif /* SIZEOF_VOID_P */

// #ifndef Py_LIMITED_API
@NoException public static native int _PyLong_UnsignedShort_Converter(PyObject arg0, Pointer arg1);
@NoException public static native int _PyLong_UnsignedInt_Converter(PyObject arg0, Pointer arg1);
@NoException public static native int _PyLong_UnsignedLong_Converter(PyObject arg0, Pointer arg1);
@NoException public static native int _PyLong_UnsignedLongLong_Converter(PyObject arg0, Pointer arg1);
@NoException public static native int _PyLong_Size_t_Converter(PyObject arg0, Pointer arg1);
// #endif

/* Used by Python/mystrtoul.c, _PyBytes_FromHex(),
   _PyBytes_DecodeEscape(), etc. */
// #ifndef Py_LIMITED_API
public static native @Cast("unsigned char") byte _PyLong_DigitValue(int i); public static native void _PyLong_DigitValue(int i, byte setter);
@MemberGetter public static native @Cast("unsigned char*") BytePointer _PyLong_DigitValue();
// #endif

/* _PyLong_Frexp returns a double x and an exponent e such that the
   true value is approximately equal to x * 2**e.  e is >= 0.  x is
   0.0 if and only if the input is 0 (in which case, e and x are both
   zeroes); otherwise, 0.5 <= abs(x) < 1.0.  On overflow, which is
   possible if the number of bits doesn't fit into a Py_ssize_t, sets
   OverflowError and returns -1.0 for x, 0 for e. */
// #ifndef Py_LIMITED_API
@NoException public static native double _PyLong_Frexp(PyLongObject a, @Cast("Py_ssize_t*") SizeTPointer e);
// #endif

@NoException public static native double PyLong_AsDouble(PyObject arg0);
@NoException public static native PyObject PyLong_FromVoidPtr(Pointer arg0);
@NoException public static native Pointer PyLong_AsVoidPtr(PyObject arg0);

@NoException public static native PyObject PyLong_FromLongLong(long arg0);
@NoException public static native PyObject PyLong_FromUnsignedLongLong(@Cast("unsigned long long") long arg0);
@NoException public static native long PyLong_AsLongLong(PyObject arg0);
@NoException public static native @Cast("unsigned long long") long PyLong_AsUnsignedLongLong(PyObject arg0);
@NoException public static native @Cast("unsigned long long") long PyLong_AsUnsignedLongLongMask(PyObject arg0);
@NoException public static native long PyLong_AsLongLongAndOverflow(PyObject arg0, IntPointer arg1);
@NoException public static native long PyLong_AsLongLongAndOverflow(PyObject arg0, IntBuffer arg1);
@NoException public static native long PyLong_AsLongLongAndOverflow(PyObject arg0, int[] arg1);

@NoException public static native PyObject PyLong_FromString(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyLong_FromUnicodeObject(PyObject u, int base);
@NoException public static native PyObject _PyLong_FromBytes(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1, int arg2);
@NoException public static native PyObject _PyLong_FromBytes(String arg0, @Cast("Py_ssize_t") long arg1, int arg2);
// #endif

// #ifndef Py_LIMITED_API
/* _PyLong_Sign.  Return 0 if v is 0, -1 if v < 0, +1 if v > 0.
   v must not be NULL, and must be a normalized long.
   There are no error cases.
*/
@NoException public static native int _PyLong_Sign(PyObject v);


/* _PyLong_NumBits.  Return the number of bits needed to represent the
   absolute value of a long.  For example, this returns 1 for 1 and -1, 2
   for 2 and -2, and 2 for 3 and -3.  It returns 0 for 0.
   v must not be NULL, and must be a normalized long.
   (size_t)-1 is returned and OverflowError set if the true result doesn't
   fit in a size_t.
*/
@NoException public static native @Cast("size_t") long _PyLong_NumBits(PyObject v);

/* _PyLong_DivmodNear.  Given integers a and b, compute the nearest
   integer q to the exact quotient a / b, rounding to the nearest even integer
   in the case of a tie.  Return (q, r), where r = a - q*b.  The remainder r
   will satisfy abs(r) <= abs(b)/2, with equality possible only if q is
   even.
*/
@NoException public static native PyObject _PyLong_DivmodNear(PyObject arg0, PyObject arg1);

/* _PyLong_FromByteArray:  View the n unsigned bytes as a binary integer in
   base 256, and return a Python int with the same numeric value.
   If n is 0, the integer is 0.  Else:
   If little_endian is 1/true, bytes[n-1] is the MSB and bytes[0] the LSB;
   else (little_endian is 0/false) bytes[0] is the MSB and bytes[n-1] the
   LSB.
   If is_signed is 0/false, view the bytes as a non-negative integer.
   If is_signed is 1/true, view the bytes as a 2's-complement integer,
   non-negative if bit 0x80 of the MSB is clear, negative if set.
   Error returns:
   + Return NULL with the appropriate exception set if there's not
     enough memory to create the Python int.
*/
@NoException public static native PyObject _PyLong_FromByteArray(
    @Cast("const unsigned char*") BytePointer bytes, @Cast("size_t") long n,
    int little_endian, int is_signed);
@NoException public static native PyObject _PyLong_FromByteArray(
    @Cast("const unsigned char*") ByteBuffer bytes, @Cast("size_t") long n,
    int little_endian, int is_signed);
@NoException public static native PyObject _PyLong_FromByteArray(
    @Cast("const unsigned char*") byte[] bytes, @Cast("size_t") long n,
    int little_endian, int is_signed);

/* _PyLong_AsByteArray: Convert the least-significant 8*n bits of long
   v to a base-256 integer, stored in array bytes.  Normally return 0,
   return -1 on error.
   If little_endian is 1/true, store the MSB at bytes[n-1] and the LSB at
   bytes[0]; else (little_endian is 0/false) store the MSB at bytes[0] and
   the LSB at bytes[n-1].
   If is_signed is 0/false, it's an error if v < 0; else (v >= 0) n bytes
   are filled and there's nothing special about bit 0x80 of the MSB.
   If is_signed is 1/true, bytes is filled with the 2's-complement
   representation of v's value.  Bit 0x80 of the MSB is the sign bit.
   Error returns (-1):
   + is_signed is 0 and v < 0.  TypeError is set in this case, and bytes
     isn't altered.
   + n isn't big enough to hold the full mathematical value of v.  For
     example, if is_signed is 0 and there are more digits in the v than
     fit in n; or if is_signed is 1, v < 0, and n is just 1 bit shy of
     being large enough to hold a sign bit.  OverflowError is set in this
     case, but bytes holds the least-significant n bytes of the true value.
*/
@NoException public static native int _PyLong_AsByteArray(PyLongObject v,
    @Cast("unsigned char*") BytePointer bytes, @Cast("size_t") long n,
    int little_endian, int is_signed);
@NoException public static native int _PyLong_AsByteArray(PyLongObject v,
    @Cast("unsigned char*") ByteBuffer bytes, @Cast("size_t") long n,
    int little_endian, int is_signed);
@NoException public static native int _PyLong_AsByteArray(PyLongObject v,
    @Cast("unsigned char*") byte[] bytes, @Cast("size_t") long n,
    int little_endian, int is_signed);

/* _PyLong_Format: Convert the long to a string object with given base,
   appending a base prefix of 0[box] if base is 2, 8 or 16. */
@NoException public static native PyObject _PyLong_Format(PyObject obj, int base);

@NoException public static native int _PyLong_FormatWriter(
    _PyUnicodeWriter writer,
    PyObject obj,
    int base,
    int alternate);

@NoException public static native @Cast("char*") BytePointer _PyLong_FormatBytesWriter(
    _PyBytesWriter writer,
    @Cast("char*") BytePointer str,
    PyObject obj,
    int base,
    int alternate);
@NoException public static native @Cast("char*") ByteBuffer _PyLong_FormatBytesWriter(
    _PyBytesWriter writer,
    @Cast("char*") ByteBuffer str,
    PyObject obj,
    int base,
    int alternate);
@NoException public static native @Cast("char*") byte[] _PyLong_FormatBytesWriter(
    _PyBytesWriter writer,
    @Cast("char*") byte[] str,
    PyObject obj,
    int base,
    int alternate);

/* Format the object based on the format_spec, as defined in PEP 3101
   (Advanced String Formatting). */
@NoException public static native int _PyLong_FormatAdvancedWriter(
    _PyUnicodeWriter writer,
    PyObject obj,
    PyObject format_spec,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end);
// #endif /* Py_LIMITED_API */

/* These aren't really part of the int object, but they're handy. The
   functions are in Python/mystrtoul.c.
 */
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
@NoException public static native long PyOS_strtol(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1, int arg2);
@NoException public static native long PyOS_strtol(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native long PyOS_strtol(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native long PyOS_strtol(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
@NoException public static native long PyOS_strtol(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native long PyOS_strtol(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native long PyOS_strtol(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);

// #ifndef Py_LIMITED_API
/* For use by the gcd function in mathmodule.c */
@NoException public static native PyObject _PyLong_GCD(PyObject arg0, PyObject arg1);
// #endif /* !Py_LIMITED_API */

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyLong_Rshift(PyObject arg0, @Cast("size_t") long arg1);
@NoException public static native PyObject _PyLong_Lshift(PyObject arg0, @Cast("size_t") long arg1);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_LONGOBJECT_H */


// Parsed from longintrepr.h

// #ifndef Py_LIMITED_API
// #ifndef Py_LONGINTREPR_H
// #define Py_LONGINTREPR_H
// #ifdef __cplusplus
// #endif


/* This is published for the benefit of "friends" marshal.c and _decimal.c. */

/* Parameters of the integer representation.  There are two different
   sets of parameters: one set for 30-bit digits, stored in an unsigned 32-bit
   integer type, and one set for 15-bit digits with each digit stored in an
   unsigned short.  The value of PYLONG_BITS_IN_DIGIT, defined either at
   configure time or in pyport.h, is used to decide which digit size to use.

   Type 'digit' should be able to hold 2*PyLong_BASE-1, and type 'twodigits'
   should be an unsigned integer type able to hold all integers up to
   PyLong_BASE*PyLong_BASE-1.  x_sub assumes that 'digit' is an unsigned type,
   and that overflow is handled by taking the result modulo 2**N for some N >
   PyLong_SHIFT.  The majority of the code doesn't care about the precise
   value of PyLong_SHIFT, but there are some notable exceptions:

   - long_pow() requires that PyLong_SHIFT be divisible by 5

   - PyLong_{As,From}ByteArray require that PyLong_SHIFT be at least 8

   - long_hash() requires that PyLong_SHIFT is *strictly* less than the number
     of bits in an unsigned long, as do the PyLong <-> long (or unsigned long)
     conversion functions

   - the Python int <-> size_t/Py_ssize_t conversion functions expect that
     PyLong_SHIFT is strictly less than the number of bits in a size_t

   - the marshal code currently expects that PyLong_SHIFT is a multiple of 15

   - NSMALLNEGINTS and NSMALLPOSINTS should be small enough to fit in a single
     digit; with the current values this forces PyLong_SHIFT >= 9

  The values 15 and 30 should fit all of the above requirements, on any
  platform.
*/

// #if PYLONG_BITS_IN_DIGIT == 30 /* signed variant of digit */ /* signed variant of twodigits */
public static final int PyLong_SHIFT =    30;
public static final int _PyLong_DECIMAL_SHIFT =   9; /* max(e such that 10**e fits in a digit) */
public static final int _PyLong_DECIMAL_BASE =    ((int)1000000000); /* 10 ** DECIMAL_SHIFT */
// #elif PYLONG_BITS_IN_DIGIT == 15 /* signed variant of digit */ /* signed variant of twodigits */ /* max(e such that 10**e fits in a digit) */ /* 10 ** DECIMAL_SHIFT */
// #else
// #error "PYLONG_BITS_IN_DIGIT should be 15 or 30"
// #endif
public static native @MemberGetter long PyLong_BASE();
public static final long PyLong_BASE = PyLong_BASE();
public static native @MemberGetter long PyLong_MASK();
public static final long PyLong_MASK = PyLong_MASK();

// #if PyLong_SHIFT % 5 != 0
// #error "longobject.c requires that PyLong_SHIFT be divisible by 5"
// Targeting ../_longobject.java



@NoException public static native PyLongObject _PyLong_New(@Cast("Py_ssize_t") long arg0);

/* Return a copy of src. */
@NoException public static native PyObject _PyLong_Copy(PyLongObject src);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_LONGINTREPR_H */
// #endif /* Py_LIMITED_API */


// Parsed from boolobject.h

/* Boolean object interface */

// #ifndef Py_BOOLOBJECT_H
// #define Py_BOOLOBJECT_H
// #ifdef __cplusplus
// #endif


public static native @ByRef PyTypeObject PyBool_Type(); public static native void PyBool_Type(PyTypeObject setter);

// #define PyBool_Check(x) Py_IS_TYPE(x, &PyBool_Type)

/* Py_False and Py_True are the only two bools in existence.
Don't forget to apply Py_INCREF() when returning either!!! */

/* Don't use these directly */
public static native @ByRef _longobject _Py_FalseStruct(); public static native void _Py_FalseStruct(_longobject setter);
public static native @ByRef _longobject _Py_TrueStruct(); public static native void _Py_TrueStruct(_longobject setter);

/* Use these macros */
// #define Py_False ((PyObject *) &_Py_FalseStruct)
// #define Py_True ((PyObject *) &_Py_TrueStruct)

// Test if an object is the True singleton, the same as "x is True" in Python.
@NoException public static native int Py_IsTrue(PyObject x);
// #define Py_IsTrue(x) Py_Is((x), Py_True)

// Test if an object is the False singleton, the same as "x is False" in Python.
@NoException public static native int Py_IsFalse(PyObject x);
// #define Py_IsFalse(x) Py_Is((x), Py_False)

/* Macros for returning Py_True or Py_False, respectively */
// #define Py_RETURN_TRUE return Py_NewRef(Py_True)
// #define Py_RETURN_FALSE return Py_NewRef(Py_False)

/* Function to return a bool from a C long */
@NoException public static native PyObject PyBool_FromLong(long arg0);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_BOOLOBJECT_H */


// Parsed from floatobject.h


/* Float object interface */

/*
PyFloatObject represents a (double precision) floating point number.
*/

// #ifndef Py_FLOATOBJECT_H
// #define Py_FLOATOBJECT_H
// #ifdef __cplusplus
// Targeting ../PyFloatObject.java


// #endif

public static native @ByRef PyTypeObject PyFloat_Type(); public static native void PyFloat_Type(PyTypeObject setter);

// #define PyFloat_Check(op) PyObject_TypeCheck(op, &PyFloat_Type)
// #define PyFloat_CheckExact(op) Py_IS_TYPE(op, &PyFloat_Type)

// #ifdef Py_NAN
// #endif

// #define Py_RETURN_INF(sign) do
//     if (copysign(1., sign) == 1.) {
//         return PyFloat_FromDouble(Py_HUGE_VAL);
//     } else {
//         return PyFloat_FromDouble(-Py_HUGE_VAL);
//     } while(0)

@NoException public static native double PyFloat_GetMax();
@NoException public static native double PyFloat_GetMin();
@NoException public static native PyObject PyFloat_GetInfo();

/* Return Python float from string PyObject. */
@NoException public static native PyObject PyFloat_FromString(PyObject arg0);

/* Return Python float from C double. */
@NoException public static native PyObject PyFloat_FromDouble(double arg0);

/* Extract C double from Python float.  The macro version trades safety for
   speed. */
@NoException public static native double PyFloat_AsDouble(PyObject arg0);
// #ifndef Py_LIMITED_API
// #define PyFloat_AS_DOUBLE(op) (((PyFloatObject *)(op))->ob_fval)
// #endif

// #ifndef Py_LIMITED_API
/* _PyFloat_{Pack,Unpack}{4,8}
 *
 * The struct and pickle (at least) modules need an efficient platform-
 * independent way to store floating-point values as byte strings.
 * The Pack routines produce a string from a C double, and the Unpack
 * routines produce a C double from such a string.  The suffix (4 or 8)
 * specifies the number of bytes in the string.
 *
 * On platforms that appear to use (see _PyFloat_Init()) IEEE-754 formats
 * these functions work by copying bits.  On other platforms, the formats the
 * 4- byte format is identical to the IEEE-754 single precision format, and
 * the 8-byte format to the IEEE-754 double precision format, although the
 * packing of INFs and NaNs (if such things exist on the platform) isn't
 * handled correctly, and attempting to unpack a string containing an IEEE
 * INF or NaN will raise an exception.
 *
 * On non-IEEE platforms with more precision, or larger dynamic range, than
 * 754 supports, not all values can be packed; on non-IEEE platforms with less
 * precision, or smaller dynamic range, not all values can be unpacked.  What
 * happens in such cases is partly accidental (alas).
 */

/* The pack routines write 2, 4 or 8 bytes, starting at p.  le is a bool
 * argument, true if you want the string in little-endian format (exponent
 * last, at p+1, p+3 or p+7), false if you want big-endian format (exponent
 * first, at p).
 * Return value:  0 if all is OK, -1 if error (and an exception is
 * set, most likely OverflowError).
 * There are two problems on non-IEEE platforms:
 * 1):  What this does is undefined if x is a NaN or infinity.
 * 2):  -0.0 and +0.0 produce the same string.
 */
@NoException public static native int _PyFloat_Pack2(double x, @Cast("unsigned char*") BytePointer p, int le);
@NoException public static native int _PyFloat_Pack2(double x, @Cast("unsigned char*") ByteBuffer p, int le);
@NoException public static native int _PyFloat_Pack2(double x, @Cast("unsigned char*") byte[] p, int le);
@NoException public static native int _PyFloat_Pack4(double x, @Cast("unsigned char*") BytePointer p, int le);
@NoException public static native int _PyFloat_Pack4(double x, @Cast("unsigned char*") ByteBuffer p, int le);
@NoException public static native int _PyFloat_Pack4(double x, @Cast("unsigned char*") byte[] p, int le);
@NoException public static native int _PyFloat_Pack8(double x, @Cast("unsigned char*") BytePointer p, int le);
@NoException public static native int _PyFloat_Pack8(double x, @Cast("unsigned char*") ByteBuffer p, int le);
@NoException public static native int _PyFloat_Pack8(double x, @Cast("unsigned char*") byte[] p, int le);

/* The unpack routines read 2, 4 or 8 bytes, starting at p.  le is a bool
 * argument, true if the string is in little-endian format (exponent
 * last, at p+1, p+3 or p+7), false if big-endian (exponent first, at p).
 * Return value:  The unpacked double.  On error, this is -1.0 and
 * PyErr_Occurred() is true (and an exception is set, most likely
 * OverflowError).  Note that on a non-IEEE platform this will refuse
 * to unpack a string that represents a NaN or infinity.
 */
@NoException public static native double _PyFloat_Unpack2(@Cast("const unsigned char*") BytePointer p, int le);
@NoException public static native double _PyFloat_Unpack2(@Cast("const unsigned char*") ByteBuffer p, int le);
@NoException public static native double _PyFloat_Unpack2(@Cast("const unsigned char*") byte[] p, int le);
@NoException public static native double _PyFloat_Unpack4(@Cast("const unsigned char*") BytePointer p, int le);
@NoException public static native double _PyFloat_Unpack4(@Cast("const unsigned char*") ByteBuffer p, int le);
@NoException public static native double _PyFloat_Unpack4(@Cast("const unsigned char*") byte[] p, int le);
@NoException public static native double _PyFloat_Unpack8(@Cast("const unsigned char*") BytePointer p, int le);
@NoException public static native double _PyFloat_Unpack8(@Cast("const unsigned char*") ByteBuffer p, int le);
@NoException public static native double _PyFloat_Unpack8(@Cast("const unsigned char*") byte[] p, int le);

@NoException public static native void _PyFloat_DebugMallocStats(@Cast("FILE*") Pointer out);

/* Format the object based on the format_spec, as defined in PEP 3101
   (Advanced String Formatting). */
@NoException public static native int _PyFloat_FormatAdvancedWriter(
    _PyUnicodeWriter writer,
    PyObject obj,
    PyObject format_spec,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end);
// #endif /* Py_LIMITED_API */

// #ifdef __cplusplus
// #endif
// #endif /* !Py_FLOATOBJECT_H */


// Parsed from complexobject.h

/* Complex number structure */

// #ifndef Py_COMPLEXOBJECT_H
// #define Py_COMPLEXOBJECT_H
// #ifdef __cplusplus
// Targeting ../Py_complex.java



/* Operations on complex numbers from complexmodule.c */

@NoException public static native @ByVal Py_complex _Py_c_sum(@ByVal Py_complex arg0, @ByVal Py_complex arg1);
@NoException public static native @ByVal Py_complex _Py_c_diff(@ByVal Py_complex arg0, @ByVal Py_complex arg1);
@NoException public static native @ByVal Py_complex _Py_c_neg(@ByVal Py_complex arg0);
@NoException public static native @ByVal Py_complex _Py_c_prod(@ByVal Py_complex arg0, @ByVal Py_complex arg1);
@NoException public static native @ByVal Py_complex _Py_c_quot(@ByVal Py_complex arg0, @ByVal Py_complex arg1);
@NoException public static native @ByVal Py_complex _Py_c_pow(@ByVal Py_complex arg0, @ByVal Py_complex arg1);
@NoException public static native double _Py_c_abs(@ByVal Py_complex arg0);
// Targeting ../PyComplexObject.java


// #endif

public static native @ByRef PyTypeObject PyComplex_Type(); public static native void PyComplex_Type(PyTypeObject setter);

// #define PyComplex_Check(op) PyObject_TypeCheck(op, &PyComplex_Type)
// #define PyComplex_CheckExact(op) Py_IS_TYPE(op, &PyComplex_Type)

// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyComplex_FromCComplex(@ByVal Py_complex arg0);
// #endif
@NoException public static native PyObject PyComplex_FromDoubles(double real, double imag);

@NoException public static native double PyComplex_RealAsDouble(PyObject op);
@NoException public static native double PyComplex_ImagAsDouble(PyObject op);
// #ifndef Py_LIMITED_API
@NoException public static native @ByVal Py_complex PyComplex_AsCComplex(PyObject op);
// #endif

/* Format the object based on the format_spec, as defined in PEP 3101
   (Advanced String Formatting). */
// #ifndef Py_LIMITED_API
@NoException public static native int _PyComplex_FormatAdvancedWriter(
    _PyUnicodeWriter writer,
    PyObject obj,
    PyObject format_spec,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_COMPLEXOBJECT_H */


// Parsed from rangeobject.h


/* Range object interface */

// #ifndef Py_RANGEOBJECT_H
// #define Py_RANGEOBJECT_H
// #ifdef __cplusplus
// #endif

/*
A range object represents an integer range.  This is an immutable object;
a range cannot change its value after creation.

Range objects behave like the corresponding tuple objects except that
they are represented by a start, stop, and step datamembers.
*/

public static native @ByRef PyTypeObject PyRange_Type(); public static native void PyRange_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyRangeIter_Type(); public static native void PyRangeIter_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyLongRangeIter_Type(); public static native void PyLongRangeIter_Type(PyTypeObject setter);

// #define PyRange_Check(op) Py_IS_TYPE(op, &PyRange_Type)

// #ifdef __cplusplus
// #endif
// #endif /* !Py_RANGEOBJECT_H */


// Parsed from memoryobject.h

/* Memory view object. In Python this is available as "memoryview". */

// #ifndef Py_MEMORYOBJECT_H
// #define Py_MEMORYOBJECT_H
// #ifdef __cplusplus
// #endif

// #ifndef Py_LIMITED_API
public static native @ByRef PyTypeObject _PyManagedBuffer_Type(); public static native void _PyManagedBuffer_Type(PyTypeObject setter);
// #endif
public static native @ByRef PyTypeObject PyMemoryView_Type(); public static native void PyMemoryView_Type(PyTypeObject setter);

// #define PyMemoryView_Check(op) Py_IS_TYPE(op, &PyMemoryView_Type)

// #ifndef Py_LIMITED_API
/* Get a pointer to the memoryview's private copy of the exporter's buffer. */
// #define PyMemoryView_GET_BUFFER(op) (&((PyMemoryViewObject *)(op))->view)
/* Get a pointer to the exporting object (this may be NULL!). */
// #define PyMemoryView_GET_BASE(op) (((PyMemoryViewObject *)(op))->view.obj)
// #endif

@NoException public static native PyObject PyMemoryView_FromObject(PyObject base);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyMemoryView_FromMemory(@Cast("char*") BytePointer mem, @Cast("Py_ssize_t") long size,
                                               int flags);
@NoException public static native PyObject PyMemoryView_FromMemory(@Cast("char*") ByteBuffer mem, @Cast("Py_ssize_t") long size,
                                               int flags);
@NoException public static native PyObject PyMemoryView_FromMemory(@Cast("char*") byte[] mem, @Cast("Py_ssize_t") long size,
                                               int flags);
// #endif
// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyMemoryView_FromBuffer(Py_buffer info);
// #endif
@NoException public static native PyObject PyMemoryView_GetContiguous(PyObject base,
                                                  int buffertype,
                                                  @Cast("char") byte order);


/* The structs are declared here so that macros can work, but they shouldn't
   be considered public. Don't access their fields directly, use the macros
   and functions instead! */
// #ifndef Py_LIMITED_API
public static final int _Py_MANAGED_BUFFER_RELEASED =    0x001;  /* access to exporter blocked */
public static final int _Py_MANAGED_BUFFER_FREE_FORMAT = 0x002;
// Targeting ../_PyManagedBufferObject.java




/* memoryview state flags */
public static final int _Py_MEMORYVIEW_RELEASED =    0x001;  /* access to master buffer blocked */
public static final int _Py_MEMORYVIEW_C =           0x002;  /* C-contiguous layout */
public static final int _Py_MEMORYVIEW_FORTRAN =     0x004;  /* Fortran contiguous layout */
public static final int _Py_MEMORYVIEW_SCALAR =      0x008;  /* scalar: ndim = 0 */
public static final int _Py_MEMORYVIEW_PIL =         0x010;
// Targeting ../PyMemoryViewObject.java


// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_MEMORYOBJECT_H */


// Parsed from tupleobject.h

/* Tuple object interface */

// #ifndef Py_TUPLEOBJECT_H
// #define Py_TUPLEOBJECT_H
// #ifdef __cplusplus
// #endif

/*
Another generally useful object type is a tuple of object pointers.
For Python, this is an immutable type.  C code can change the tuple items
(but not their number), and even use tuples as general-purpose arrays of
object references, but in general only brand new tuples should be mutated,
not ones that might already have been exposed to Python code.

*** WARNING *** PyTuple_SetItem does not increment the new item's reference
count, but does decrement the reference count of the item it replaces,
if not nil.  It does *decrement* the reference count if it is *not*
inserted in the tuple.  Similarly, PyTuple_GetItem does not increment the
returned item's reference count.
*/

public static native @ByRef PyTypeObject PyTuple_Type(); public static native void PyTuple_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyTupleIter_Type(); public static native void PyTupleIter_Type(PyTypeObject setter);

// #define PyTuple_Check(op)
//                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TUPLE_SUBCLASS)
// #define PyTuple_CheckExact(op) Py_IS_TYPE(op, &PyTuple_Type)

@NoException public static native PyObject PyTuple_New(@Cast("Py_ssize_t") long size);
@NoException public static native @Cast("Py_ssize_t") long PyTuple_Size(PyObject arg0);
@NoException public static native PyObject PyTuple_GetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int PyTuple_SetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1, PyObject arg2);
@NoException public static native PyObject PyTuple_GetSlice(PyObject arg0, @Cast("Py_ssize_t") long arg1, @Cast("Py_ssize_t") long arg2);
@NoException public static native PyObject PyTuple_Pack(@Cast("Py_ssize_t") long arg0);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_TUPLEOBJECT_H
// #  include  "cpython/tupleobject.h"
// #  undef Py_CPYTHON_TUPLEOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_TUPLEOBJECT_H */


// Parsed from cpython/tupleobject.h

// #ifndef Py_CPYTHON_TUPLEOBJECT_H
// #  error "this header file must not be included directly"
// Targeting ../PyTupleObject.java



@NoException public static native int _PyTuple_Resize(@Cast("PyObject**") PointerPointer arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int _PyTuple_Resize(@ByPtrPtr PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native void _PyTuple_MaybeUntrack(PyObject arg0);

/* Macros trading safety for speed */

/* Cast argument to PyTupleObject* type. */
// #define _PyTuple_CAST(op) (assert(PyTuple_Check(op)), (PyTupleObject *)(op))

// #define PyTuple_GET_SIZE(op)    Py_SIZE(_PyTuple_CAST(op))

// #define PyTuple_GET_ITEM(op, i) (_PyTuple_CAST(op)->ob_item[i])

/* Macro, *only* to be used to fill in brand new tuples */
// #define PyTuple_SET_ITEM(op, i, v) ((void)(_PyTuple_CAST(op)->ob_item[i] = v))

@NoException public static native void _PyTuple_DebugMallocStats(@Cast("FILE*") Pointer out);


// Parsed from listobject.h

/* List object interface

   Another generally useful object type is a list of object pointers.
   This is a mutable type: the list items can be changed, and items can be
   added or removed. Out-of-range indices or non-list objects are ignored.

   WARNING: PyList_SetItem does not increment the new item's reference count,
   but does decrement the reference count of the item it replaces, if not nil.
   It does *decrement* the reference count if it is *not* inserted in the list.
   Similarly, PyList_GetItem does not increment the returned item's reference
   count.
*/

// #ifndef Py_LISTOBJECT_H
// #define Py_LISTOBJECT_H
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyList_Type(); public static native void PyList_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyListIter_Type(); public static native void PyListIter_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyListRevIter_Type(); public static native void PyListRevIter_Type(PyTypeObject setter);

// #define PyList_Check(op)
//     PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_LIST_SUBCLASS)
// #define PyList_CheckExact(op) Py_IS_TYPE(op, &PyList_Type)

@NoException public static native PyObject PyList_New(@Cast("Py_ssize_t") long size);
@NoException public static native @Cast("Py_ssize_t") long PyList_Size(PyObject arg0);

@NoException public static native PyObject PyList_GetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int PyList_SetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1, PyObject arg2);
@NoException public static native int PyList_Insert(PyObject arg0, @Cast("Py_ssize_t") long arg1, PyObject arg2);
@NoException public static native int PyList_Append(PyObject arg0, PyObject arg1);

@NoException public static native PyObject PyList_GetSlice(PyObject arg0, @Cast("Py_ssize_t") long arg1, @Cast("Py_ssize_t") long arg2);
@NoException public static native int PyList_SetSlice(PyObject arg0, @Cast("Py_ssize_t") long arg1, @Cast("Py_ssize_t") long arg2, PyObject arg3);

@NoException public static native int PyList_Sort(PyObject arg0);
@NoException public static native int PyList_Reverse(PyObject arg0);
@NoException public static native PyObject PyList_AsTuple(PyObject arg0);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_LISTOBJECT_H
// #  include  "cpython/listobject.h"
// #  undef Py_CPYTHON_LISTOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_LISTOBJECT_H */


// Parsed from cpython/listobject.h

// #ifndef Py_CPYTHON_LISTOBJECT_H
// #  error "this header file must not be included directly"
// Targeting ../PyListObject.java



@NoException public static native PyObject _PyList_Extend(PyListObject arg0, PyObject arg1);
@NoException public static native void _PyList_DebugMallocStats(@Cast("FILE*") Pointer out);

/* Macro, trading safety for speed */

/* Cast argument to PyListObject* type. */
// #define _PyList_CAST(op) (assert(PyList_Check(op)), (PyListObject *)(op))

// #define PyList_GET_ITEM(op, i) (_PyList_CAST(op)->ob_item[i])
// #define PyList_SET_ITEM(op, i, v) ((void)(_PyList_CAST(op)->ob_item[i] = (v)))
// #define PyList_GET_SIZE(op)    Py_SIZE(_PyList_CAST(op))


// Parsed from dictobject.h

// #ifndef Py_DICTOBJECT_H
// #define Py_DICTOBJECT_H
// #ifdef __cplusplus
// #endif

/* Dictionary object type -- mapping from hashable object to object */

/* The distribution includes a separate file, Objects/dictnotes.txt,
   describing explorations into dictionary design and optimization.
   It covers typical dictionary use patterns, the parameters for
   tuning dictionaries, and several ideas for possible optimizations.
*/

public static native @ByRef PyTypeObject PyDict_Type(); public static native void PyDict_Type(PyTypeObject setter);

// #define PyDict_Check(op)
//                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_DICT_SUBCLASS)
// #define PyDict_CheckExact(op) Py_IS_TYPE(op, &PyDict_Type)

@NoException public static native PyObject PyDict_New();
@NoException public static native PyObject PyDict_GetItem(PyObject mp, PyObject key);
@NoException public static native PyObject PyDict_GetItemWithError(PyObject mp, PyObject key);
@NoException public static native int PyDict_SetItem(PyObject mp, PyObject key, PyObject item);
@NoException public static native int PyDict_DelItem(PyObject mp, PyObject key);
@NoException public static native void PyDict_Clear(PyObject mp);
@NoException public static native int PyDict_Next(
    PyObject mp, @Cast("Py_ssize_t*") SizeTPointer pos, @Cast("PyObject**") PointerPointer key, @Cast("PyObject**") PointerPointer value);
@NoException public static native int PyDict_Next(
    PyObject mp, @Cast("Py_ssize_t*") SizeTPointer pos, @ByPtrPtr PyObject key, @ByPtrPtr PyObject value);
@NoException public static native PyObject PyDict_Keys(PyObject mp);
@NoException public static native PyObject PyDict_Values(PyObject mp);
@NoException public static native PyObject PyDict_Items(PyObject mp);
@NoException public static native @Cast("Py_ssize_t") long PyDict_Size(PyObject mp);
@NoException public static native PyObject PyDict_Copy(PyObject mp);
@NoException public static native int PyDict_Contains(PyObject mp, PyObject key);

/* PyDict_Update(mp, other) is equivalent to PyDict_Merge(mp, other, 1). */
@NoException public static native int PyDict_Update(PyObject mp, PyObject other);

/* PyDict_Merge updates/merges from a mapping object (an object that
   supports PyMapping_Keys() and PyObject_GetItem()).  If override is true,
   the last occurrence of a key wins, else the first.  The Python
   dict.update(other) is equivalent to PyDict_Merge(dict, other, 1).
*/
@NoException public static native int PyDict_Merge(PyObject mp,
                             PyObject other,
                             int override);

/* PyDict_MergeFromSeq2 updates/merges from an iterable object producing
   iterable objects of length 2.  If override is true, the last occurrence
   of a key wins, else the first.  The Python dict constructor dict(seq2)
   is equivalent to dict={}; PyDict_MergeFromSeq(dict, seq2, 1).
*/
@NoException public static native int PyDict_MergeFromSeq2(PyObject d,
                                     PyObject seq2,
                                     int override);

@NoException public static native PyObject PyDict_GetItemString(PyObject dp, @Cast("const char*") BytePointer key);
@NoException public static native PyObject PyDict_GetItemString(PyObject dp, String key);
@NoException public static native int PyDict_SetItemString(PyObject dp, @Cast("const char*") BytePointer key, PyObject item);
@NoException public static native int PyDict_SetItemString(PyObject dp, String key, PyObject item);
@NoException public static native int PyDict_DelItemString(PyObject dp, @Cast("const char*") BytePointer key);
@NoException public static native int PyDict_DelItemString(PyObject dp, String key);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
@NoException public static native PyObject PyObject_GenericGetDict(PyObject arg0, Pointer arg1);
// #endif

/* Dictionary (keys, values, items) views */

public static native @ByRef PyTypeObject PyDictKeys_Type(); public static native void PyDictKeys_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyDictValues_Type(); public static native void PyDictValues_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyDictItems_Type(); public static native void PyDictItems_Type(PyTypeObject setter);

// #define PyDictKeys_Check(op) PyObject_TypeCheck(op, &PyDictKeys_Type)
// #define PyDictValues_Check(op) PyObject_TypeCheck(op, &PyDictValues_Type)
// #define PyDictItems_Check(op) PyObject_TypeCheck(op, &PyDictItems_Type)
/* This excludes Values, since they are not sets. */
// # define PyDictViewSet_Check(op)
//     (PyDictKeys_Check(op) || PyDictItems_Check(op))

/* Dictionary (key, value, items) iterators */

public static native @ByRef PyTypeObject PyDictIterKey_Type(); public static native void PyDictIterKey_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyDictIterValue_Type(); public static native void PyDictIterValue_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyDictIterItem_Type(); public static native void PyDictIterItem_Type(PyTypeObject setter);

public static native @ByRef PyTypeObject PyDictRevIterKey_Type(); public static native void PyDictRevIterKey_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyDictRevIterItem_Type(); public static native void PyDictRevIterItem_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyDictRevIterValue_Type(); public static native void PyDictRevIterValue_Type(PyTypeObject setter);


// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_DICTOBJECT_H
// #  include  "cpython/dictobject.h"
// #  undef Py_CPYTHON_DICTOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_DICTOBJECT_H */


// Parsed from cpython/dictobject.h

// #ifndef Py_CPYTHON_DICTOBJECT_H
// #  error "this header file must not be included directly"
// Targeting ../PyDictKeysObject.java


// Targeting ../PyDictObject.java



@NoException public static native PyObject _PyDict_GetItem_KnownHash(PyObject mp, PyObject key,
                                       @Cast("Py_hash_t") long hash);
@NoException public static native PyObject _PyDict_GetItemIdWithError(PyObject dp,
                                                  _Py_Identifier key);
@NoException public static native PyObject _PyDict_GetItemStringWithError(PyObject arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native PyObject _PyDict_GetItemStringWithError(PyObject arg0, String arg1);
@NoException public static native PyObject PyDict_SetDefault(
    PyObject mp, PyObject key, PyObject defaultobj);
@NoException public static native int _PyDict_SetItem_KnownHash(PyObject mp, PyObject key,
                                          PyObject item, @Cast("Py_hash_t") long hash);
@NoException public static native int _PyDict_DelItem_KnownHash(PyObject mp, PyObject key,
                                          @Cast("Py_hash_t") long hash);
// Targeting ../Predicate_PyObject.java


@NoException public static native int _PyDict_DelItemIf(PyObject mp, PyObject key,
                                  Predicate_PyObject predicate);

@NoException public static native int _PyDict_Next(
    PyObject mp, @Cast("Py_ssize_t*") SizeTPointer pos, @Cast("PyObject**") PointerPointer key, @Cast("PyObject**") PointerPointer value, @Cast("Py_hash_t*") SizeTPointer hash);
@NoException public static native int _PyDict_Next(
    PyObject mp, @Cast("Py_ssize_t*") SizeTPointer pos, @ByPtrPtr PyObject key, @ByPtrPtr PyObject value, @Cast("Py_hash_t*") SizeTPointer hash);

/* Get the number of items of a dictionary. */
// #define PyDict_GET_SIZE(mp)  (assert(PyDict_Check(mp)),((PyDictObject *)mp)->ma_used)
@NoException public static native int _PyDict_Contains_KnownHash(PyObject arg0, PyObject arg1, @Cast("Py_hash_t") long arg2);
@NoException public static native int _PyDict_ContainsId(PyObject arg0, _Py_Identifier arg1);
@NoException public static native PyObject _PyDict_NewPresized(@Cast("Py_ssize_t") long minused);
@NoException public static native void _PyDict_MaybeUntrack(PyObject mp);
@NoException public static native int _PyDict_HasOnlyStringKeys(PyObject mp);


@NoException public static native PyObject _PyDict_Pop(PyObject arg0, PyObject arg1, PyObject arg2);


// #define _PyDict_HasSplitTable(d) ((d)->ma_values != NULL)

/* Like PyDict_Merge, but override can be 0, 1 or 2.  If override is 0,
   the first occurrence of a key wins, if override is 1, the last occurrence
   of a key wins, if override is 2, a KeyError with conflicting key as
   argument is raised.
*/
@NoException public static native int _PyDict_MergeEx(PyObject mp, PyObject other, int override);
@NoException public static native int _PyDict_SetItemId(PyObject dp, _Py_Identifier key, PyObject item);

@NoException public static native int _PyDict_DelItemId(PyObject mp, _Py_Identifier key);
@NoException public static native void _PyDict_DebugMallocStats(@Cast("FILE*") Pointer out);




// Targeting ../_PyDictViewObject.java




@NoException public static native PyObject _PyDictView_Intersect(PyObject self, PyObject other);


// Parsed from structmember.h

// #ifndef Py_STRUCTMEMBER_H
// #define Py_STRUCTMEMBER_H
// #ifdef __cplusplus
// #endif


/* Interface to map C struct members to Python object attributes */

// #include <stddef.h>
// Targeting ../PyMemberDef.java



/* Types */
public static final int T_SHORT =     0;
public static final int T_INT =       1;
public static final int T_LONG =      2;
public static final int T_FLOAT =     3;
public static final int T_DOUBLE =    4;
public static final int T_STRING =    5;
public static final int T_OBJECT =    6;
/* XXX the ordering here is weird for binary compatibility */
public static final int T_CHAR =      7;   /* 1-character string */
public static final int T_BYTE =      8;   /* 8-bit signed int */
/* unsigned variants: */
public static final int T_UBYTE =     9;
public static final int T_USHORT =    10;
public static final int T_UINT =      11;
public static final int T_ULONG =     12;

/* Added by Jack: strings contained in the structure */
public static final int T_STRING_INPLACE =    13;

/* Added by Lillo: bools contained in the structure (assumed char) */
public static final int T_BOOL =      14;

public static final int T_OBJECT_EX = 16;  /* Like T_OBJECT, but raises AttributeError
                           when the value is NULL, instead of
                           converting to None. */
public static final int T_LONGLONG =      17;
public static final int T_ULONGLONG =     18;

public static final int T_PYSSIZET =      19;      /* Py_ssize_t */
public static final int T_NONE =          20;      /* Value is always None */


/* Flags */
public static final int READONLY =            1;
public static final int READ_RESTRICTED =     2;
public static final int PY_WRITE_RESTRICTED = 4;
public static final int RESTRICTED =          (READ_RESTRICTED | PY_WRITE_RESTRICTED);

public static final int PY_AUDIT_READ =       READ_RESTRICTED;

/* Current API, use this */
@NoException public static native PyObject PyMember_GetOne(@Cast("const char*") BytePointer arg0, PyMemberDef arg1);
@NoException public static native PyObject PyMember_GetOne(String arg0, PyMemberDef arg1);
@NoException public static native int PyMember_SetOne(@Cast("char*") BytePointer arg0, PyMemberDef arg1, PyObject arg2);
@NoException public static native int PyMember_SetOne(@Cast("char*") ByteBuffer arg0, PyMemberDef arg1, PyObject arg2);
@NoException public static native int PyMember_SetOne(@Cast("char*") byte[] arg0, PyMemberDef arg1, PyObject arg2);


// #ifdef __cplusplus
// #endif
// #endif /* !Py_STRUCTMEMBER_H */


// Parsed from cpython/odictobject.h

// #ifndef Py_ODICTOBJECT_H
// #define Py_ODICTOBJECT_H
// #ifdef __cplusplus
// Targeting ../PyODictObject.java



public static native @ByRef PyTypeObject PyODict_Type(); public static native void PyODict_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyODictIter_Type(); public static native void PyODictIter_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyODictKeys_Type(); public static native void PyODictKeys_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyODictItems_Type(); public static native void PyODictItems_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyODictValues_Type(); public static native void PyODictValues_Type(PyTypeObject setter);

// #define PyODict_Check(op) PyObject_TypeCheck(op, &PyODict_Type)
// #define PyODict_CheckExact(op) Py_IS_TYPE(op, &PyODict_Type)
// #define PyODict_SIZE(op) PyDict_GET_SIZE((op))

@NoException public static native PyObject PyODict_New();
@NoException public static native int PyODict_SetItem(PyObject od, PyObject key, PyObject item);
@NoException public static native int PyODict_DelItem(PyObject od, PyObject key);

/* wrappers around PyDict* functions */
// #define PyODict_GetItem(od, key) PyDict_GetItem(_PyObject_CAST(od), key)
// #define PyODict_GetItemWithError(od, key)
//     PyDict_GetItemWithError(_PyObject_CAST(od), key)
// #define PyODict_Contains(od, key) PyDict_Contains(_PyObject_CAST(od), key)
// #define PyODict_Size(od) PyDict_Size(_PyObject_CAST(od))
// #define PyODict_GetItemString(od, key)
//     PyDict_GetItemString(_PyObject_CAST(od), key)

// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_ODICTOBJECT_H */


// Parsed from enumobject.h

// #ifndef Py_ENUMOBJECT_H
// #define Py_ENUMOBJECT_H

/* Enumerate Object */

// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyEnum_Type(); public static native void PyEnum_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyReversed_Type(); public static native void PyReversed_Type(PyTypeObject setter);

// #ifdef __cplusplus
// #endif

// #endif /* !Py_ENUMOBJECT_H */


// Parsed from setobject.h

/* Set object interface */

// #ifndef Py_SETOBJECT_H
// #define Py_SETOBJECT_H
// #ifdef __cplusplus
// #endif

// #ifndef Py_LIMITED_API

/* There are three kinds of entries in the table:

1. Unused:  key == NULL and hash == 0
2. Dummy:   key == dummy and hash == -1
3. Active:  key != NULL and key != dummy and hash != -1

The hash field of Unused slots is always zero.

The hash field of Dummy slots are set to -1
meaning that dummy entries can be detected by
either entry->key==dummy or by entry->hash==-1.
*/

public static final int PySet_MINSIZE = 8;
// Targeting ../setentry.java


// Targeting ../PySetObject.java



// #define PySet_GET_SIZE(so) (assert(PyAnySet_Check(so)),(((PySetObject *)(so))->used))

public static native PyObject _PySet_Dummy(); public static native void _PySet_Dummy(PyObject setter);

@NoException public static native int _PySet_NextEntry(PyObject set, @Cast("Py_ssize_t*") SizeTPointer pos, @Cast("PyObject**") PointerPointer key, @Cast("Py_hash_t*") SizeTPointer hash);
@NoException public static native int _PySet_NextEntry(PyObject set, @Cast("Py_ssize_t*") SizeTPointer pos, @ByPtrPtr PyObject key, @Cast("Py_hash_t*") SizeTPointer hash);
@NoException public static native int _PySet_Update(PyObject set, PyObject iterable);

// #endif /* Section excluded by Py_LIMITED_API */

public static native @ByRef PyTypeObject PySet_Type(); public static native void PySet_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyFrozenSet_Type(); public static native void PyFrozenSet_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PySetIter_Type(); public static native void PySetIter_Type(PyTypeObject setter);

@NoException public static native PyObject PySet_New(PyObject arg0);
@NoException public static native PyObject PyFrozenSet_New(PyObject arg0);

@NoException public static native int PySet_Add(PyObject set, PyObject key);
@NoException public static native int PySet_Clear(PyObject set);
@NoException public static native int PySet_Contains(PyObject anyset, PyObject key);
@NoException public static native int PySet_Discard(PyObject set, PyObject key);
@NoException public static native PyObject PySet_Pop(PyObject set);
@NoException public static native @Cast("Py_ssize_t") long PySet_Size(PyObject anyset);

// #define PyFrozenSet_CheckExact(ob) Py_IS_TYPE(ob, &PyFrozenSet_Type)
// #define PyFrozenSet_Check(ob)
//     (Py_IS_TYPE(ob, &PyFrozenSet_Type) ||
//       PyType_IsSubtype(Py_TYPE(ob), &PyFrozenSet_Type))

// #define PyAnySet_CheckExact(ob)
//     (Py_IS_TYPE(ob, &PySet_Type) || Py_IS_TYPE(ob, &PyFrozenSet_Type))
// #define PyAnySet_Check(ob)
//     (Py_IS_TYPE(ob, &PySet_Type) || Py_IS_TYPE(ob, &PyFrozenSet_Type) ||
//       PyType_IsSubtype(Py_TYPE(ob), &PySet_Type) ||
//       PyType_IsSubtype(Py_TYPE(ob), &PyFrozenSet_Type))

// #define PySet_CheckExact(op) Py_IS_TYPE(op, &PySet_Type)
// #define PySet_Check(ob)
//     (Py_IS_TYPE(ob, &PySet_Type) ||
//     PyType_IsSubtype(Py_TYPE(ob), &PySet_Type))

// #ifdef __cplusplus
// #endif
// #endif /* !Py_SETOBJECT_H */


// Parsed from methodobject.h


/* Method object interface */

// #ifndef Py_METHODOBJECT_H
// #define Py_METHODOBJECT_H
// #ifdef __cplusplus
// #endif

/* This is about the type 'builtin_function_or_method',
   not Python methods in user-defined classes.  See classobject.h
   for the latter. */

public static native @ByRef PyTypeObject PyCFunction_Type(); public static native void PyCFunction_Type(PyTypeObject setter);

// #define PyCFunction_CheckExact(op) Py_IS_TYPE(op, &PyCFunction_Type)
// #define PyCFunction_Check(op) PyObject_TypeCheck(op, &PyCFunction_Type)
// Targeting ../PyCFunction.java


// Targeting ../_PyCFunctionFast.java


// Targeting ../PyCFunctionWithKeywords.java


// Targeting ../_PyCFunctionFastWithKeywords.java


// Targeting ../PyCMethod.java



@NoException public static native PyCFunction PyCFunction_GetFunction(PyObject arg0);
@NoException public static native PyObject PyCFunction_GetSelf(PyObject arg0);
@NoException public static native int PyCFunction_GetFlags(PyObject arg0);

@NoException public static native @Deprecated PyObject PyCFunction_Call(PyObject arg0, PyObject arg1, PyObject arg2);
// Targeting ../PyMethodDef.java



/* PyCFunction_New is declared as a function for stable ABI (declaration is
 * needed for e.g. GCC with -fvisibility=hidden), but redefined as a macro
 * that calls PyCFunction_NewEx. */
@NoException public static native PyObject PyCFunction_New(PyMethodDef arg0, PyObject arg1);
// #define PyCFunction_New(ML, SELF) PyCFunction_NewEx((ML), (SELF), NULL)

/* PyCFunction_NewEx is similar: on 3.9+, this calls PyCMethod_New. */
@NoException public static native PyObject PyCFunction_NewEx(PyMethodDef arg0, PyObject arg1,
                                         PyObject arg2);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
// #define PyCFunction_NewEx(ML, SELF, MOD) PyCMethod_New((ML), (SELF), (MOD), NULL)
@NoException public static native PyObject PyCMethod_New(PyMethodDef arg0, PyObject arg1,
                                     PyObject arg2, PyTypeObject arg3);
// #endif


/* Flag passed to newmethodobject */
/* #define METH_OLDARGS  0x0000   -- unsupported now */
public static final int METH_VARARGS =  0x0001;
public static final int METH_KEYWORDS = 0x0002;
/* METH_NOARGS and METH_O must not be combined with the flags above. */
public static final int METH_NOARGS =   0x0004;
public static final int METH_O =        0x0008;

/* METH_CLASS and METH_STATIC are a little different; these control
   the construction of methods for a class.  These cannot be used for
   functions in modules. */
public static final int METH_CLASS =    0x0010;
public static final int METH_STATIC =   0x0020;

/* METH_COEXIST allows a method to be entered even though a slot has
   already filled the entry.  When defined, the flag allows a separate
   method, "__contains__" for example, to coexist with a defined
   slot like sq_contains. */

public static final int METH_COEXIST =   0x0040;

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030a0000
public static final int METH_FASTCALL =  0x0080;
// #endif

/* This bit is preserved for Stackless Python */
// #ifdef STACKLESS
public static final int METH_STACKLESS = 0x0100;
// #else
// #endif

/* METH_METHOD means the function stores an
 * additional reference to the class that defines it;
 * both self and class are passed to it.
 * It uses PyCMethodObject instead of PyCFunctionObject.
 * May not be combined with METH_NOARGS, METH_O, METH_CLASS or METH_STATIC.
 */

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
public static final int METH_METHOD = 0x0200;
// #endif


// #ifndef Py_LIMITED_API

// #define Py_CPYTHON_METHODOBJECT_H
// #include  "cpython/methodobject.h"
// #undef Py_CPYTHON_METHODOBJECT_H

// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_METHODOBJECT_H */


// Parsed from cpython/methodobject.h

// #ifndef Py_CPYTHON_METHODOBJECT_H
// #  error "this header file must not be included directly"
// #endif

public static native @ByRef PyTypeObject PyCMethod_Type(); public static native void PyCMethod_Type(PyTypeObject setter);

// #define PyCMethod_CheckExact(op) Py_IS_TYPE(op, &PyCMethod_Type)
// #define PyCMethod_Check(op) PyObject_TypeCheck(op, &PyCMethod_Type)

/* Macros for direct access to these values. Type checks are *not*
   done, so use with care. */
// #define PyCFunction_GET_FUNCTION(func)
//         (((PyCFunctionObject *)func) -> m_ml -> ml_meth)
// #define PyCFunction_GET_SELF(func)
//         (((PyCFunctionObject *)func) -> m_ml -> ml_flags & METH_STATIC ?
//          NULL : ((PyCFunctionObject *)func) -> m_self)
// #define PyCFunction_GET_FLAGS(func)
//         (((PyCFunctionObject *)func) -> m_ml -> ml_flags)
// #define PyCFunction_GET_CLASS(func)
//     (((PyCFunctionObject *)func) -> m_ml -> ml_flags & METH_METHOD ?
//          ((PyCMethodObject *)func) -> mm_class : NULL)
// Targeting ../PyCFunctionObject.java


// Targeting ../PyCMethodObject.java




// Parsed from moduleobject.h


/* Module object interface */

// #ifndef Py_MODULEOBJECT_H
// #define Py_MODULEOBJECT_H
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyModule_Type(); public static native void PyModule_Type(PyTypeObject setter);

// #define PyModule_Check(op) PyObject_TypeCheck(op, &PyModule_Type)
// #define PyModule_CheckExact(op) Py_IS_TYPE(op, &PyModule_Type)

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyModule_NewObject(
    PyObject name
    );
// #endif
@NoException public static native PyObject PyModule_New(
    @Cast("const char*") BytePointer name
    );
@NoException public static native PyObject PyModule_New(
    String name
    );
@NoException public static native PyObject PyModule_GetDict(PyObject arg0);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyModule_GetNameObject(PyObject arg0);
// #endif
@NoException public static native @Cast("const char*") BytePointer PyModule_GetName(PyObject arg0);
@NoException public static native @Deprecated @Cast("const char*") BytePointer PyModule_GetFilename(PyObject arg0);
@NoException public static native PyObject PyModule_GetFilenameObject(PyObject arg0);
// #ifndef Py_LIMITED_API
@NoException public static native void _PyModule_Clear(PyObject arg0);
@NoException public static native void _PyModule_ClearDict(PyObject arg0);
@NoException public static native int _PyModuleSpec_IsInitializing(PyObject arg0);
// #endif
@NoException public static native PyModuleDef PyModule_GetDef(PyObject arg0);
@NoException public static native Pointer PyModule_GetState(PyObject arg0);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* New in 3.5 */
@NoException public static native PyObject PyModuleDef_Init(PyModuleDef arg0);
public static native @ByRef PyTypeObject PyModuleDef_Type(); public static native void PyModuleDef_Type(PyTypeObject setter);
// Targeting ../PyModuleDef_Base.java



// #define PyModuleDef_HEAD_INIT {
//     PyObject_HEAD_INIT(NULL)
//     NULL, /* m_init */
//     0,    /* m_index */
//     NULL, /* m_copy */
//   }
// Targeting ../PyModuleDef_Slot.java



public static final int Py_mod_create = 1;
public static final int Py_mod_exec = 2;

// #ifndef Py_LIMITED_API
public static final int _Py_mod_LAST_SLOT = 2;
// Targeting ../PyModuleDef.java




// Internal C API
// #ifdef Py_BUILD_CORE
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_MODULEOBJECT_H */


// Parsed from funcobject.h


/* Function object interface */
// #ifndef Py_LIMITED_API
// #ifndef Py_FUNCOBJECT_H
// #define Py_FUNCOBJECT_H
// #ifdef __cplusplus
// #endif


// #define COMMON_FIELDS(PREFIX)
//     PyObject *PREFIX ## globals;
//     PyObject *PREFIX ## builtins;
//     PyObject *PREFIX ## name;
//     PyObject *PREFIX ## qualname;
//     PyObject *PREFIX ## code;        /* A code object, the __code__ attribute */
//     PyObject *PREFIX ## defaults;    /* NULL or a tuple */
//     PyObject *PREFIX ## kwdefaults;  /* NULL or a dict */
//     PyObject *PREFIX ## closure;
// Targeting ../PyFrameConstructor.java


// Targeting ../PyFunctionObject.java



public static native @ByRef PyTypeObject PyFunction_Type(); public static native void PyFunction_Type(PyTypeObject setter);

// #define PyFunction_Check(op) Py_IS_TYPE(op, &PyFunction_Type)

@NoException public static native PyObject PyFunction_New(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyFunction_NewWithQualName(PyObject arg0, PyObject arg1, PyObject arg2);
@NoException public static native PyObject PyFunction_GetCode(PyObject arg0);
@NoException public static native PyObject PyFunction_GetGlobals(PyObject arg0);
@NoException public static native PyObject PyFunction_GetModule(PyObject arg0);
@NoException public static native PyObject PyFunction_GetDefaults(PyObject arg0);
@NoException public static native int PyFunction_SetDefaults(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyFunction_GetKwDefaults(PyObject arg0);
@NoException public static native int PyFunction_SetKwDefaults(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyFunction_GetClosure(PyObject arg0);
@NoException public static native int PyFunction_SetClosure(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyFunction_GetAnnotations(PyObject arg0);
@NoException public static native int PyFunction_SetAnnotations(PyObject arg0, PyObject arg1);

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyFunction_Vectorcall(
    PyObject func,
    @Cast("PyObject*const*") PointerPointer stack,
    @Cast("size_t") long nargsf,
    PyObject kwnames);
@NoException public static native PyObject _PyFunction_Vectorcall(
    PyObject func,
    @ByPtrPtr PyObject stack,
    @Cast("size_t") long nargsf,
    PyObject kwnames);
// #endif

/* Macros for direct access to these values. Type checks are *not*
   done, so use with care. */
// #define PyFunction_GET_CODE(func)
//         (((PyFunctionObject *)func) -> func_code)
// #define PyFunction_GET_GLOBALS(func)
//         (((PyFunctionObject *)func) -> func_globals)
// #define PyFunction_GET_MODULE(func)
//         (((PyFunctionObject *)func) -> func_module)
// #define PyFunction_GET_DEFAULTS(func)
//         (((PyFunctionObject *)func) -> func_defaults)
// #define PyFunction_GET_KW_DEFAULTS(func)
//         (((PyFunctionObject *)func) -> func_kwdefaults)
// #define PyFunction_GET_CLOSURE(func)
//         (((PyFunctionObject *)func) -> func_closure)
// #define PyFunction_GET_ANNOTATIONS(func)
//         (((PyFunctionObject *)func) -> func_annotations)

// #define PyFunction_AS_FRAME_CONSTRUCTOR(func)
//         ((PyFrameConstructor *)&((PyFunctionObject *)(func))->func_globals)

/* The classmethod and staticmethod types lives here, too */
public static native @ByRef PyTypeObject PyClassMethod_Type(); public static native void PyClassMethod_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyStaticMethod_Type(); public static native void PyStaticMethod_Type(PyTypeObject setter);

@NoException public static native PyObject PyClassMethod_New(PyObject arg0);
@NoException public static native PyObject PyStaticMethod_New(PyObject arg0);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_FUNCOBJECT_H */
// #endif /* Py_LIMITED_API */


// Parsed from classobject.h

/* Former class object interface -- now only bound methods are here  */

/* Revealing some structures (not for general use) */

// #ifndef Py_LIMITED_API
// #ifndef Py_CLASSOBJECT_H
// #define Py_CLASSOBJECT_H
// #ifdef __cplusplus
// Targeting ../PyMethodObject.java



public static native @ByRef PyTypeObject PyMethod_Type(); public static native void PyMethod_Type(PyTypeObject setter);

// #define PyMethod_Check(op) Py_IS_TYPE(op, &PyMethod_Type)

@NoException public static native PyObject PyMethod_New(PyObject arg0, PyObject arg1);

@NoException public static native PyObject PyMethod_Function(PyObject arg0);
@NoException public static native PyObject PyMethod_Self(PyObject arg0);

/* Macros for direct access to these values. Type checks are *not*
   done, so use with care. */
// #define PyMethod_GET_FUNCTION(meth)
//         (((PyMethodObject *)meth) -> im_func)
// #define PyMethod_GET_SELF(meth)
//         (((PyMethodObject *)meth) -> im_self)
// Targeting ../PyInstanceMethodObject.java



public static native @ByRef PyTypeObject PyInstanceMethod_Type(); public static native void PyInstanceMethod_Type(PyTypeObject setter);

// #define PyInstanceMethod_Check(op) Py_IS_TYPE(op, &PyInstanceMethod_Type)

@NoException public static native PyObject PyInstanceMethod_New(PyObject arg0);
@NoException public static native PyObject PyInstanceMethod_Function(PyObject arg0);

/* Macros for direct access to these values. Type checks are *not*
   done, so use with care. */
// #define PyInstanceMethod_GET_FUNCTION(meth)
//         (((PyInstanceMethodObject *)meth) -> func)

// #ifdef __cplusplus
// #endif
// #endif /* !Py_CLASSOBJECT_H */
// #endif /* Py_LIMITED_API */


// Parsed from fileobject.h

/* File object interface (what's left of it -- see io.py) */

// #ifndef Py_FILEOBJECT_H
// #define Py_FILEOBJECT_H
// #ifdef __cplusplus
// #endif

public static final String PY_STDIOTEXTMODE = "b";

@NoException public static native PyObject PyFile_FromFd(int arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2, int arg3,
                                     @Cast("const char*") BytePointer arg4, @Cast("const char*") BytePointer arg5,
                                     @Cast("const char*") BytePointer arg6, int arg7);
@NoException public static native PyObject PyFile_FromFd(int arg0, String arg1, String arg2, int arg3,
                                     String arg4, String arg5,
                                     String arg6, int arg7);
@NoException public static native PyObject PyFile_GetLine(PyObject arg0, int arg1);
@NoException public static native int PyFile_WriteObject(PyObject arg0, PyObject arg1, int arg2);
@NoException public static native int PyFile_WriteString(@Cast("const char*") BytePointer arg0, PyObject arg1);
@NoException public static native int PyFile_WriteString(String arg0, PyObject arg1);
@NoException public static native int PyObject_AsFileDescriptor(PyObject arg0);

/* The default encoding used by the platform file system APIs
   If non-NULL, this is different than the default encoding for strings
*/
public static native @Cast("const char*") BytePointer Py_FileSystemDefaultEncoding(); public static native void Py_FileSystemDefaultEncoding(BytePointer setter);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
public static native @Cast("const char*") BytePointer Py_FileSystemDefaultEncodeErrors(); public static native void Py_FileSystemDefaultEncodeErrors(BytePointer setter);
// #endif
public static native int Py_HasFileSystemDefaultEncoding(); public static native void Py_HasFileSystemDefaultEncoding(int setter);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000
public static native int Py_UTF8Mode(); public static native void Py_UTF8Mode(int setter);
// #endif

/* A routine to check if a file descriptor can be select()-ed. */
// #ifdef _MSC_VER
    /* On Windows, any socket fd can be select()-ed, no matter how high */
//     #define _PyIsSelectable_fd(FD) (1)
// #else
//     #define _PyIsSelectable_fd(FD) ((unsigned int)(FD) < (unsigned int)FD_SETSIZE)
// #endif

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_FILEOBJECT_H
// #  include  "cpython/fileobject.h"
// #  undef Py_CPYTHON_FILEOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_FILEOBJECT_H */


// Parsed from cpython/fileobject.h

// #ifndef Py_CPYTHON_FILEOBJECT_H
// #  error "this header file must not be included directly"
// #endif

@NoException public static native @Cast("char*") BytePointer Py_UniversalNewlineFgets(@Cast("char*") BytePointer arg0, int arg1, @Cast("FILE*") Pointer arg2, PyObject arg3);
@NoException public static native @Cast("char*") ByteBuffer Py_UniversalNewlineFgets(@Cast("char*") ByteBuffer arg0, int arg1, @Cast("FILE*") Pointer arg2, PyObject arg3);
@NoException public static native @Cast("char*") byte[] Py_UniversalNewlineFgets(@Cast("char*") byte[] arg0, int arg1, @Cast("FILE*") Pointer arg2, PyObject arg3);

/* The std printer acts as a preliminary sys.stderr until the new io
   infrastructure is in place. */
@NoException public static native PyObject PyFile_NewStdPrinter(int arg0);
public static native @ByRef PyTypeObject PyStdPrinter_Type(); public static native void PyStdPrinter_Type(PyTypeObject setter);
// Targeting ../Py_OpenCodeHookFunction.java



@NoException public static native PyObject PyFile_OpenCode(@Cast("const char*") BytePointer utf8path);
@NoException public static native PyObject PyFile_OpenCode(String utf8path);
@NoException public static native PyObject PyFile_OpenCodeObject(PyObject path);
@NoException public static native int PyFile_SetOpenCodeHook(Py_OpenCodeHookFunction hook, Pointer userData);

@NoException public static native int _PyLong_FileDescriptor_Converter(PyObject arg0, Pointer arg1);


// Parsed from frameobject.h

/* Frame object interface */

// #ifndef Py_FRAMEOBJECT_H
// #define Py_FRAMEOBJECT_H
// #ifdef __cplusplus
// #endif

// #include "pyframe.h"

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_FRAMEOBJECT_H
// #  include  "cpython/frameobject.h"
// #  undef Py_CPYTHON_FRAMEOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_FRAMEOBJECT_H */


// Parsed from cpython/frameobject.h

/* Frame object interface */

// #ifndef Py_CPYTHON_FRAMEOBJECT_H
// #  error "this header file must not be included directly"
// #endif

/* These values are chosen so that the inline functions below all
 * compare f_state to zero.
 */
/** enum _framestate */
public static final int
    FRAME_CREATED = -2,
    FRAME_SUSPENDED = -1,
    FRAME_EXECUTING = 0,
    FRAME_RETURNED = 1,
    FRAME_UNWINDING = 2,
    FRAME_RAISED = 3,
    FRAME_CLEARED = 4;
// Targeting ../PyTryBlock.java


// Targeting ../_frame.java



@NoException public static native int _PyFrame_IsRunnable(_frame f);

@NoException public static native int _PyFrame_IsExecuting(_frame f);

@NoException public static native int _PyFrameHasCompleted(_frame f);

/* Standard object interface */

public static native @ByRef PyTypeObject PyFrame_Type(); public static native void PyFrame_Type(PyTypeObject setter);

// #define PyFrame_Check(op) Py_IS_TYPE(op, &PyFrame_Type)

@NoException public static native PyFrameObject PyFrame_New(PyThreadState arg0, PyCodeObject arg1,
                                        PyObject arg2, PyObject arg3);

/* only internal use */



/* The rest of the interface is specific for frame objects */

/* Block management functions */

@NoException public static native void PyFrame_BlockSetup(PyFrameObject arg0, int arg1, int arg2, int arg3);
@NoException public static native PyTryBlock PyFrame_BlockPop(PyFrameObject arg0);

/* Conversions between "fast locals" and locals in dictionary */

@NoException public static native void PyFrame_LocalsToFast(PyFrameObject arg0, int arg1);

@NoException public static native int PyFrame_FastToLocalsWithError(PyFrameObject f);
@NoException public static native void PyFrame_FastToLocals(PyFrameObject arg0);

@NoException public static native void _PyFrame_DebugMallocStats(@Cast("FILE*") Pointer out);

@NoException public static native PyFrameObject PyFrame_GetBack(PyFrameObject frame);


// Parsed from pycapsule.h


/* Capsule objects let you wrap a C "void *" pointer in a Python
   object.  They're a way of passing data through the Python interpreter
   without creating your own custom type.

   Capsules are used for communication between extension modules.
   They provide a way for an extension module to export a C interface
   to other extension modules, so that extension modules can use the
   Python import mechanism to link to one another.

   For more information, please see "c-api/capsule.html" in the
   documentation.
*/

// #ifndef Py_CAPSULE_H
// #define Py_CAPSULE_H
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyCapsule_Type(); public static native void PyCapsule_Type(PyTypeObject setter);
// Targeting ../PyCapsule_Destructor.java



// #define PyCapsule_CheckExact(op) Py_IS_TYPE(op, &PyCapsule_Type)


@NoException public static native PyObject PyCapsule_New(
    Pointer pointer,
    @Cast("const char*") BytePointer name,
    PyCapsule_Destructor destructor);
@NoException public static native PyObject PyCapsule_New(
    Pointer pointer,
    String name,
    PyCapsule_Destructor destructor);

@NoException public static native Pointer PyCapsule_GetPointer(PyObject capsule, @Cast("const char*") BytePointer name);
@NoException public static native Pointer PyCapsule_GetPointer(PyObject capsule, String name);

@NoException public static native PyCapsule_Destructor PyCapsule_GetDestructor(PyObject capsule);

@NoException public static native @Cast("const char*") BytePointer PyCapsule_GetName(PyObject capsule);

@NoException public static native Pointer PyCapsule_GetContext(PyObject capsule);

@NoException public static native int PyCapsule_IsValid(PyObject capsule, @Cast("const char*") BytePointer name);
@NoException public static native int PyCapsule_IsValid(PyObject capsule, String name);

@NoException public static native int PyCapsule_SetPointer(PyObject capsule, Pointer pointer);

@NoException public static native int PyCapsule_SetDestructor(PyObject capsule, PyCapsule_Destructor destructor);

@NoException public static native int PyCapsule_SetName(PyObject capsule, @Cast("const char*") BytePointer name);
@NoException public static native int PyCapsule_SetName(PyObject capsule, String name);

@NoException public static native int PyCapsule_SetContext(PyObject capsule, Pointer context);

@NoException public static native Pointer PyCapsule_Import(
    @Cast("const char*") BytePointer name,
    int no_block);
@NoException public static native Pointer PyCapsule_Import(
    String name,
    int no_block);


// #ifdef __cplusplus
// #endif
// #endif /* !Py_CAPSULE_H */


// Parsed from pyframe.h

/* Limited C API of PyFrame API
 *
 * Include "frameobject.h" to get the PyFrameObject structure.
 */

// #ifndef Py_PYFRAME_H
// #define Py_PYFRAME_H
// #ifdef __cplusplus
// Targeting ../PyFrameObject.java



/* Return the line of code the frame is currently executing. */
@NoException public static native int PyFrame_GetLineNumber(PyFrameObject arg0);

@NoException public static native PyCodeObject PyFrame_GetCode(PyFrameObject frame);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYFRAME_H */


// Parsed from traceback.h

// #ifndef Py_TRACEBACK_H
// #define Py_TRACEBACK_H
// #ifdef __cplusplus
// #endif

/* Traceback interface */

@NoException public static native int PyTraceBack_Here(PyFrameObject arg0);
@NoException public static native int PyTraceBack_Print(PyObject arg0, PyObject arg1);

/* Reveal traceback type so we can typecheck traceback objects */
public static native @ByRef PyTypeObject PyTraceBack_Type(); public static native void PyTraceBack_Type(PyTypeObject setter);
// #define PyTraceBack_Check(v) Py_IS_TYPE(v, &PyTraceBack_Type)


// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_TRACEBACK_H
// #  include  "cpython/traceback.h"
// #  undef Py_CPYTHON_TRACEBACK_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_TRACEBACK_H */


// Parsed from cpython/traceback.h

// #ifndef Py_CPYTHON_TRACEBACK_H
// #  error "this header file must not be included directly"
// Targeting ../PyTracebackObject.java



@NoException public static native int _Py_DisplaySourceLine(PyObject arg0, PyObject arg1, int arg2, int arg3);
@NoException public static native void _PyTraceback_Add(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, int arg2);
@NoException public static native void _PyTraceback_Add(String arg0, String arg1, int arg2);


// Parsed from sliceobject.h

// #ifndef Py_SLICEOBJECT_H
// #define Py_SLICEOBJECT_H
// #ifdef __cplusplus
// #endif

/* The unique ellipsis object "..." */

public static native @ByRef PyObject _Py_EllipsisObject(); public static native void _Py_EllipsisObject(PyObject setter); /* Don't use this directly */

// #define Py_Ellipsis (&_Py_EllipsisObject)
// Targeting ../PySliceObject.java


// #endif

public static native @ByRef PyTypeObject PySlice_Type(); public static native void PySlice_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyEllipsis_Type(); public static native void PyEllipsis_Type(PyTypeObject setter);

// #define PySlice_Check(op) Py_IS_TYPE(op, &PySlice_Type)

@NoException public static native PyObject PySlice_New(PyObject start, PyObject stop,
                                  PyObject step);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PySlice_FromIndices(@Cast("Py_ssize_t") long start, @Cast("Py_ssize_t") long stop);
@NoException public static native int _PySlice_GetLongIndices(PySliceObject self, PyObject length,
                                 @Cast("PyObject**") PointerPointer start_ptr, @Cast("PyObject**") PointerPointer stop_ptr,
                                 @Cast("PyObject**") PointerPointer step_ptr);
@NoException public static native int _PySlice_GetLongIndices(PySliceObject self, PyObject length,
                                 @ByPtrPtr PyObject start_ptr, @ByPtrPtr PyObject stop_ptr,
                                 @ByPtrPtr PyObject step_ptr);
// #endif
@NoException public static native int PySlice_GetIndices(PyObject r, @Cast("Py_ssize_t") long length,
                                  @Cast("Py_ssize_t*") SizeTPointer start, @Cast("Py_ssize_t*") SizeTPointer stop, @Cast("Py_ssize_t*") SizeTPointer step);
@NoException public static native @Deprecated int PySlice_GetIndicesEx(PyObject r, @Cast("Py_ssize_t") long length,
                                     @Cast("Py_ssize_t*") SizeTPointer start, @Cast("Py_ssize_t*") SizeTPointer stop,
                                     @Cast("Py_ssize_t*") SizeTPointer step,
                                     @Cast("Py_ssize_t*") SizeTPointer slicelength);

// #if !defined(Py_LIMITED_API) || (Py_LIMITED_API+0 >= 0x03050400 && Py_LIMITED_API+0 < 0x03060000) || Py_LIMITED_API+0 >= 0x03060100
// #define PySlice_GetIndicesEx(slice, length, start, stop, step, slicelen) (
//     PySlice_Unpack((slice), (start), (stop), (step)) < 0 ?
//     ((*(slicelen) = 0), -1) :
//     ((*(slicelen) = PySlice_AdjustIndices((length), (start), (stop), *(step))),
//      0))
@NoException public static native int PySlice_Unpack(PyObject slice,
                               @Cast("Py_ssize_t*") SizeTPointer start, @Cast("Py_ssize_t*") SizeTPointer stop, @Cast("Py_ssize_t*") SizeTPointer step);
@NoException public static native @Cast("Py_ssize_t") long PySlice_AdjustIndices(@Cast("Py_ssize_t") long length,
                                             @Cast("Py_ssize_t*") SizeTPointer start, @Cast("Py_ssize_t*") SizeTPointer stop,
                                             @Cast("Py_ssize_t") long step);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_SLICEOBJECT_H */


// Parsed from cellobject.h

/* Cell object interface */
// #ifndef Py_LIMITED_API
// #ifndef Py_CELLOBJECT_H
// #define Py_CELLOBJECT_H
// #ifdef __cplusplus
// Targeting ../PyCellObject.java



public static native @ByRef PyTypeObject PyCell_Type(); public static native void PyCell_Type(PyTypeObject setter);

// #define PyCell_Check(op) Py_IS_TYPE(op, &PyCell_Type)

@NoException public static native PyObject PyCell_New(PyObject arg0);
@NoException public static native PyObject PyCell_Get(PyObject arg0);
@NoException public static native int PyCell_Set(PyObject arg0, PyObject arg1);

// #define PyCell_GET(op) (((PyCellObject *)(op))->ob_ref)
// #define PyCell_SET(op, v) ((void)(((PyCellObject *)(op))->ob_ref = v))

// #ifdef __cplusplus
// #endif
// #endif /* !Py_TUPLEOBJECT_H */
// #endif /* Py_LIMITED_API */


// Parsed from iterobject.h

// #ifndef Py_ITEROBJECT_H
// #define Py_ITEROBJECT_H
/* Iterators (the basic kind, over a sequence) */
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PySeqIter_Type(); public static native void PySeqIter_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyCallIter_Type(); public static native void PyCallIter_Type(PyTypeObject setter);
// #ifdef Py_BUILD_CORE
// #endif

// #define PySeqIter_Check(op) Py_IS_TYPE(op, &PySeqIter_Type)

@NoException public static native PyObject PySeqIter_New(PyObject arg0);


// #define PyCallIter_Check(op) Py_IS_TYPE(op, &PyCallIter_Type)

@NoException public static native PyObject PyCallIter_New(PyObject arg0, PyObject arg1);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_ITEROBJECT_H */



// Parsed from genobject.h


/* Generator object interface */

// #ifndef Py_LIMITED_API
// #ifndef Py_GENOBJECT_H
// #define Py_GENOBJECT_H
// #ifdef __cplusplus
// #endif

// #include "pystate.h"   /* _PyErr_StackItem */
// #include "abstract.h" /* PySendResult */

/* _PyGenObject_HEAD defines the initial segment of generator
   and coroutine objects. */
// #define _PyGenObject_HEAD(prefix)
//     PyObject_HEAD
//     /* Note: gi_frame can be NULL if the generator is "finished" */
//     PyFrameObject *prefix##_frame;
//     /* The code object backing the generator */
//     PyObject *prefix##_code;
//     /* List of weak reference. */
//     PyObject *prefix##_weakreflist;
//     /* Name of the generator. */
//     PyObject *prefix##_name;
//     /* Qualified name of the generator. */
//     PyObject *prefix##_qualname;
//     _PyErr_StackItem prefix##_exc_state;
// Targeting ../PyGenObject.java



public static native @ByRef PyTypeObject PyGen_Type(); public static native void PyGen_Type(PyTypeObject setter);

// #define PyGen_Check(op) PyObject_TypeCheck(op, &PyGen_Type)
// #define PyGen_CheckExact(op) Py_IS_TYPE(op, &PyGen_Type)

@NoException public static native PyObject PyGen_New(PyFrameObject arg0);
@NoException public static native PyObject PyGen_NewWithQualName(PyFrameObject arg0,
    PyObject name, PyObject qualname);
@NoException public static native int _PyGen_SetStopIterationValue(PyObject arg0);
@NoException public static native int _PyGen_FetchStopIterationValue(@Cast("PyObject**") PointerPointer arg0);
@NoException public static native int _PyGen_FetchStopIterationValue(@ByPtrPtr PyObject arg0);

@NoException public static native void _PyGen_Finalize(PyObject self);
// Targeting ../PyCoroObject.java



public static native @ByRef PyTypeObject PyCoro_Type(); public static native void PyCoro_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject _PyCoroWrapper_Type(); public static native void _PyCoroWrapper_Type(PyTypeObject setter);

// #define PyCoro_CheckExact(op) Py_IS_TYPE(op, &PyCoro_Type)

@NoException public static native PyObject PyCoro_New(PyFrameObject arg0,
    PyObject name, PyObject qualname);
// Targeting ../PyAsyncGenObject.java



public static native @ByRef PyTypeObject PyAsyncGen_Type(); public static native void PyAsyncGen_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject _PyAsyncGenASend_Type(); public static native void _PyAsyncGenASend_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject _PyAsyncGenWrappedValue_Type(); public static native void _PyAsyncGenWrappedValue_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject _PyAsyncGenAThrow_Type(); public static native void _PyAsyncGenAThrow_Type(PyTypeObject setter);

@NoException public static native PyObject PyAsyncGen_New(PyFrameObject arg0,
    PyObject name, PyObject qualname);

// #define PyAsyncGen_CheckExact(op) Py_IS_TYPE(op, &PyAsyncGen_Type)



// #endif

// #undef _PyGenObject_HEAD

// #ifdef __cplusplus
// #endif
// #endif /* !Py_GENOBJECT_H */
// #endif /* Py_LIMITED_API */


// Parsed from genericaliasobject.h

// Implementation of PEP 585: support list[int] etc.
// #ifndef Py_GENERICALIASOBJECT_H
// #define Py_GENERICALIASOBJECT_H
// #ifdef __cplusplus
// #endif

@NoException public static native PyObject Py_GenericAlias(PyObject arg0, PyObject arg1);
public static native @ByRef PyTypeObject Py_GenericAliasType(); public static native void Py_GenericAliasType(PyTypeObject setter);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_GENERICALIASOBJECT_H */


// Parsed from warnings.h

// #ifndef Py_WARNINGS_H
// #define Py_WARNINGS_H
// #ifdef __cplusplus
// #endif

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyWarnings_Init();
// #endif

@NoException public static native int PyErr_WarnEx(
    PyObject category,
    @Cast("const char*") BytePointer message,
    @Cast("Py_ssize_t") long stack_level);
@NoException public static native int PyErr_WarnEx(
    PyObject category,
    String message,
    @Cast("Py_ssize_t") long stack_level);
@NoException public static native int PyErr_WarnFormat(
    PyObject category,
    @Cast("Py_ssize_t") long stack_level,
    @Cast("const char*") BytePointer format);
@NoException public static native int PyErr_WarnFormat(
    PyObject category,
    @Cast("Py_ssize_t") long stack_level,
    String format);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
/* Emit a ResourceWarning warning */
@NoException public static native int PyErr_ResourceWarning(
    PyObject source,
    @Cast("Py_ssize_t") long stack_level,
    @Cast("const char*") BytePointer format);
@NoException public static native int PyErr_ResourceWarning(
    PyObject source,
    @Cast("Py_ssize_t") long stack_level,
    String format);
// #endif
// #ifndef Py_LIMITED_API
@NoException public static native int PyErr_WarnExplicitObject(
    PyObject category,
    PyObject message,
    PyObject filename,
    int lineno,
    PyObject module,
    PyObject registry);
// #endif
@NoException public static native int PyErr_WarnExplicit(
    PyObject category,
    @Cast("const char*") BytePointer message,
    @Cast("const char*") BytePointer filename,
    int lineno,
    @Cast("const char*") BytePointer module,
    PyObject registry);
@NoException public static native int PyErr_WarnExplicit(
    PyObject category,
    String message,
    String filename,
    int lineno,
    String module,
    PyObject registry);

// #ifndef Py_LIMITED_API
@NoException public static native int PyErr_WarnExplicitFormat(PyObject category,
                         @Cast("const char*") BytePointer filename, int lineno,
                         @Cast("const char*") BytePointer module, PyObject registry,
                         @Cast("const char*") BytePointer format);
@NoException public static native int PyErr_WarnExplicitFormat(PyObject category,
                         String filename, int lineno,
                         String module, PyObject registry,
                         String format);
// #endif

/* DEPRECATED: Use PyErr_WarnEx() instead. */
// #ifndef Py_LIMITED_API
// #define PyErr_Warn(category, msg) PyErr_WarnEx(category, msg, 1)
// #endif

// #ifndef Py_LIMITED_API

// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_WARNINGS_H */



// Parsed from weakrefobject.h

/* Weak references objects for Python. */

// #ifndef Py_WEAKREFOBJECT_H
// #define Py_WEAKREFOBJECT_H
// #ifdef __cplusplus
// Targeting ../PyWeakReference.java


// Targeting ../_PyWeakReference.java


// #endif

public static native @ByRef PyTypeObject _PyWeakref_RefType(); public static native void _PyWeakref_RefType(PyTypeObject setter);
public static native @ByRef PyTypeObject _PyWeakref_ProxyType(); public static native void _PyWeakref_ProxyType(PyTypeObject setter);
public static native @ByRef PyTypeObject _PyWeakref_CallableProxyType(); public static native void _PyWeakref_CallableProxyType(PyTypeObject setter);

// #define PyWeakref_CheckRef(op) PyObject_TypeCheck(op, &_PyWeakref_RefType)
// #define PyWeakref_CheckRefExact(op)
//         Py_IS_TYPE(op, &_PyWeakref_RefType)
// #define PyWeakref_CheckProxy(op)
//         (Py_IS_TYPE(op, &_PyWeakref_ProxyType) ||
//          Py_IS_TYPE(op, &_PyWeakref_CallableProxyType))

// #define PyWeakref_Check(op)
//         (PyWeakref_CheckRef(op) || PyWeakref_CheckProxy(op))


@NoException public static native PyObject PyWeakref_NewRef(PyObject ob,
                                              PyObject callback);
@NoException public static native PyObject PyWeakref_NewProxy(PyObject ob,
                                                PyObject callback);
@NoException public static native PyObject PyWeakref_GetObject(PyObject ref);

// #ifndef Py_LIMITED_API
@NoException public static native @Cast("Py_ssize_t") long _PyWeakref_GetWeakrefCount(PyWeakReference head);

@NoException public static native void _PyWeakref_ClearRef(PyWeakReference self);
// #endif

/* Explanation for the Py_REFCNT() check: when a weakref's target is part
   of a long chain of deallocations which triggers the trashcan mechanism,
   clearing the weakrefs can be delayed long after the target's refcount
   has dropped to zero.  In the meantime, code accessing the weakref will
   be able to "see" the target object even though it is supposed to be
   unreachable.  See issue #16602. */

// #define PyWeakref_GET_OBJECT(ref)
//     (Py_REFCNT(((PyWeakReference *)(ref))->wr_object) > 0
//      ? ((PyWeakReference *)(ref))->wr_object
//      : Py_None)


// #ifdef __cplusplus
// #endif
// #endif /* !Py_WEAKREFOBJECT_H */


// Parsed from structseq.h


/* Named tuple object interface */

// #ifndef Py_STRUCTSEQ_H
// #define Py_STRUCTSEQ_H
// #ifdef __cplusplus
// Targeting ../PyStructSequence_Field.java


// Targeting ../PyStructSequence_Desc.java





// #ifndef Py_LIMITED_API
@NoException public static native void PyStructSequence_InitType(PyTypeObject type,
                                           PyStructSequence_Desc desc);
@NoException public static native int PyStructSequence_InitType2(PyTypeObject type,
                                           PyStructSequence_Desc desc);
// #endif
@NoException public static native PyTypeObject PyStructSequence_NewType(PyStructSequence_Desc desc);

@NoException public static native PyObject PyStructSequence_New(PyTypeObject type);

// #ifndef Py_LIMITED_API

/* Macro, *only* to be used to fill in brand new objects */
// #define PyStructSequence_SET_ITEM(op, i, v) PyTuple_SET_ITEM(op, i, v)

// #define PyStructSequence_GET_ITEM(op, i) PyTuple_GET_ITEM(op, i)
// #endif

@NoException public static native void PyStructSequence_SetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1, PyObject arg2);
@NoException public static native PyObject PyStructSequence_GetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_STRUCTSEQ_H */


// Parsed from namespaceobject.h


/* simple namespace object interface */

// #ifndef NAMESPACEOBJECT_H
// #define NAMESPACEOBJECT_H
// #ifdef __cplusplus
// #endif

// #ifndef Py_LIMITED_API
public static native @ByRef PyTypeObject _PyNamespace_Type(); public static native void _PyNamespace_Type(PyTypeObject setter);

@NoException public static native PyObject _PyNamespace_New(PyObject kwds);
// #endif /* !Py_LIMITED_API */

// #ifdef __cplusplus
// #endif
// #endif /* !NAMESPACEOBJECT_H */


// Parsed from cpython/picklebufobject.h

/* PickleBuffer object. This is built-in for ease of use from third-party
 * C extensions.
 */

// #ifndef Py_PICKLEBUFOBJECT_H
// #define Py_PICKLEBUFOBJECT_H
// #ifdef __cplusplus
// #endif

// #ifndef Py_LIMITED_API

public static native @ByRef PyTypeObject PyPickleBuffer_Type(); public static native void PyPickleBuffer_Type(PyTypeObject setter);

// #define PyPickleBuffer_Check(op) Py_IS_TYPE(op, &PyPickleBuffer_Type)

/* Create a PickleBuffer redirecting to the given buffer-enabled object */
@NoException public static native PyObject PyPickleBuffer_FromObject(PyObject arg0);
/* Get the PickleBuffer's underlying view to the original object
 * (NULL if released)
 */
@NoException public static native @Const Py_buffer PyPickleBuffer_GetBuffer(PyObject arg0);
/* Release the PickleBuffer.  Returns 0 on success, -1 on error. */
@NoException public static native int PyPickleBuffer_Release(PyObject arg0);

// #endif /* !Py_LIMITED_API */

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PICKLEBUFOBJECT_H */


// Parsed from codecs.h

// #ifndef Py_CODECREGISTRY_H
// #define Py_CODECREGISTRY_H
// #ifdef __cplusplus
// #endif

/* ------------------------------------------------------------------------

   Python Codec Registry and support functions


Written by Marc-Andre Lemburg (mal@lemburg.com).

Copyright (c) Corporation for National Research Initiatives.

   ------------------------------------------------------------------------ */

/* Register a new codec search function.

   As side effect, this tries to load the encodings package, if not
   yet done, to make sure that it is always first in the list of
   search functions.

   The search_function's refcount is incremented by this function. */

@NoException public static native int PyCodec_Register(
       PyObject search_function
       );

/* Unregister a codec search function and clear the registry's cache.
   If the search function is not registered, do nothing.
   Return 0 on success. Raise an exception and return -1 on error. */

@NoException public static native int PyCodec_Unregister(
       PyObject search_function
       );

/* Codec registry lookup API.

   Looks up the given encoding and returns a CodecInfo object with
   function attributes which implement the different aspects of
   processing the encoding.

   The encoding string is looked up converted to all lower-case
   characters. This makes encodings looked up through this mechanism
   effectively case-insensitive.

   If no codec is found, a KeyError is set and NULL returned.

   As side effect, this tries to load the encodings package, if not
   yet done. This is part of the lazy load strategy for the encodings
   package.

 */

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyCodec_Lookup(
       @Cast("const char*") BytePointer encoding
       );
@NoException public static native PyObject _PyCodec_Lookup(
       String encoding
       );


// #endif

/* Codec registry encoding check API.

   Returns 1/0 depending on whether there is a registered codec for
   the given encoding.

*/

@NoException public static native int PyCodec_KnownEncoding(
       @Cast("const char*") BytePointer encoding
       );
@NoException public static native int PyCodec_KnownEncoding(
       String encoding
       );

/* Generic codec based encoding API.

   object is passed through the encoder function found for the given
   encoding using the error handling method defined by errors. errors
   may be NULL to use the default method defined for the codec.

   Raises a LookupError in case no encoder can be found.

 */

@NoException public static native PyObject PyCodec_Encode(
       PyObject object,
       @Cast("const char*") BytePointer encoding,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject PyCodec_Encode(
       PyObject object,
       String encoding,
       String errors
       );

/* Generic codec based decoding API.

   object is passed through the decoder function found for the given
   encoding using the error handling method defined by errors. errors
   may be NULL to use the default method defined for the codec.

   Raises a LookupError in case no encoder can be found.

 */

@NoException public static native PyObject PyCodec_Decode(
       PyObject object,
       @Cast("const char*") BytePointer encoding,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject PyCodec_Decode(
       PyObject object,
       String encoding,
       String errors
       );

// #ifndef Py_LIMITED_API
/* Text codec specific encoding and decoding API.

   Checks the encoding against a list of codecs which do not
   implement a str<->bytes encoding before attempting the
   operation.

   Please note that these APIs are internal and should not
   be used in Python C extensions.

   XXX (ncoghlan): should we make these, or something like them, public
   in Python 3.5+?

 */
@NoException public static native PyObject _PyCodec_LookupTextEncoding(
       @Cast("const char*") BytePointer encoding,
       @Cast("const char*") BytePointer alternate_command
       );
@NoException public static native PyObject _PyCodec_LookupTextEncoding(
       String encoding,
       String alternate_command
       );

@NoException public static native PyObject _PyCodec_EncodeText(
       PyObject object,
       @Cast("const char*") BytePointer encoding,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject _PyCodec_EncodeText(
       PyObject object,
       String encoding,
       String errors
       );

@NoException public static native PyObject _PyCodec_DecodeText(
       PyObject object,
       @Cast("const char*") BytePointer encoding,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject _PyCodec_DecodeText(
       PyObject object,
       String encoding,
       String errors
       );

/* These two aren't actually text encoding specific, but _io.TextIOWrapper
 * is the only current API consumer.
 */
@NoException public static native PyObject _PyCodecInfo_GetIncrementalDecoder(
       PyObject codec_info,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject _PyCodecInfo_GetIncrementalDecoder(
       PyObject codec_info,
       String errors
       );

@NoException public static native PyObject _PyCodecInfo_GetIncrementalEncoder(
       PyObject codec_info,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject _PyCodecInfo_GetIncrementalEncoder(
       PyObject codec_info,
       String errors
       );
// #endif



/* --- Codec Lookup APIs --------------------------------------------------

   All APIs return a codec object with incremented refcount and are
   based on _PyCodec_Lookup().  The same comments w/r to the encoding
   name also apply to these APIs.

*/

/* Get an encoder function for the given encoding. */

@NoException public static native PyObject PyCodec_Encoder(
       @Cast("const char*") BytePointer encoding
       );
@NoException public static native PyObject PyCodec_Encoder(
       String encoding
       );

/* Get a decoder function for the given encoding. */

@NoException public static native PyObject PyCodec_Decoder(
       @Cast("const char*") BytePointer encoding
       );
@NoException public static native PyObject PyCodec_Decoder(
       String encoding
       );

/* Get an IncrementalEncoder object for the given encoding. */

@NoException public static native PyObject PyCodec_IncrementalEncoder(
       @Cast("const char*") BytePointer encoding,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject PyCodec_IncrementalEncoder(
       String encoding,
       String errors
       );

/* Get an IncrementalDecoder object function for the given encoding. */

@NoException public static native PyObject PyCodec_IncrementalDecoder(
       @Cast("const char*") BytePointer encoding,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject PyCodec_IncrementalDecoder(
       String encoding,
       String errors
       );

/* Get a StreamReader factory function for the given encoding. */

@NoException public static native PyObject PyCodec_StreamReader(
       @Cast("const char*") BytePointer encoding,
       PyObject stream,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject PyCodec_StreamReader(
       String encoding,
       PyObject stream,
       String errors
       );

/* Get a StreamWriter factory function for the given encoding. */

@NoException public static native PyObject PyCodec_StreamWriter(
       @Cast("const char*") BytePointer encoding,
       PyObject stream,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject PyCodec_StreamWriter(
       String encoding,
       PyObject stream,
       String errors
       );

/* Unicode encoding error handling callback registry API */

/* Register the error handling callback function error under the given
   name. This function will be called by the codec when it encounters
   unencodable characters/undecodable bytes and doesn't know the
   callback name, when name is specified as the error parameter
   in the call to the encode/decode function.
   Return 0 on success, -1 on error */
@NoException public static native int PyCodec_RegisterError(@Cast("const char*") BytePointer name, PyObject error);
@NoException public static native int PyCodec_RegisterError(String name, PyObject error);

/* Lookup the error handling callback function registered under the given
   name. As a special case NULL can be passed, in which case
   the error handling callback for "strict" will be returned. */
@NoException public static native PyObject PyCodec_LookupError(@Cast("const char*") BytePointer name);
@NoException public static native PyObject PyCodec_LookupError(String name);

/* raise exc as an exception */
@NoException public static native PyObject PyCodec_StrictErrors(PyObject exc);

/* ignore the unicode error, skipping the faulty input */
@NoException public static native PyObject PyCodec_IgnoreErrors(PyObject exc);

/* replace the unicode encode error with ? or U+FFFD */
@NoException public static native PyObject PyCodec_ReplaceErrors(PyObject exc);

/* replace the unicode encode error with XML character references */
@NoException public static native PyObject PyCodec_XMLCharRefReplaceErrors(PyObject exc);

/* replace the unicode encode error with backslash escapes (\x, \u005Cu and \U) */
@NoException public static native PyObject PyCodec_BackslashReplaceErrors(PyObject exc);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* replace the unicode encode error with backslash escapes (\N, \x, \u005Cu and \U) */
@NoException public static native PyObject PyCodec_NameReplaceErrors(PyObject exc);
// #endif

// #ifndef Py_LIMITED_API
public static native @Cast("const char*") BytePointer Py_hexdigits(); public static native void Py_hexdigits(BytePointer setter);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_CODECREGISTRY_H */


// Parsed from pyerrors.h

// #ifndef Py_ERRORS_H
// #define Py_ERRORS_H
// #ifdef __cplusplus
// #endif

// #include <stdarg.h>               // va_list

/* Error handling definitions */

@NoException public static native void PyErr_SetNone(PyObject arg0);
@NoException public static native void PyErr_SetObject(PyObject arg0, PyObject arg1);
@NoException public static native void PyErr_SetString(
    PyObject exception,
    @Cast("const char*") BytePointer string
    );
@NoException public static native void PyErr_SetString(
    PyObject exception,
    String string
    );
@NoException public static native PyObject PyErr_Occurred();
@NoException public static native void PyErr_Clear();
@NoException public static native void PyErr_Fetch(@Cast("PyObject**") PointerPointer arg0, @Cast("PyObject**") PointerPointer arg1, @Cast("PyObject**") PointerPointer arg2);
@NoException public static native void PyErr_Fetch(@ByPtrPtr PyObject arg0, @ByPtrPtr PyObject arg1, @ByPtrPtr PyObject arg2);
@NoException public static native void PyErr_Restore(PyObject arg0, PyObject arg1, PyObject arg2);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native void PyErr_GetExcInfo(@Cast("PyObject**") PointerPointer arg0, @Cast("PyObject**") PointerPointer arg1, @Cast("PyObject**") PointerPointer arg2);
@NoException public static native void PyErr_GetExcInfo(@ByPtrPtr PyObject arg0, @ByPtrPtr PyObject arg1, @ByPtrPtr PyObject arg2);
@NoException public static native void PyErr_SetExcInfo(PyObject arg0, PyObject arg1, PyObject arg2);
// #endif

/* Defined in Python/pylifecycle.c

   The Py_FatalError() function is replaced with a macro which logs
   automatically the name of the current function, unless the Py_LIMITED_API
   macro is defined. */
@NoException public static native void Py_FatalError(@Cast("const char*") BytePointer message);
@NoException public static native void Py_FatalError(String message);

/* Error testing and normalization */
@NoException public static native int PyErr_GivenExceptionMatches(PyObject arg0, PyObject arg1);
@NoException public static native int PyErr_ExceptionMatches(PyObject arg0);
@NoException public static native void PyErr_NormalizeException(@Cast("PyObject**") PointerPointer arg0, @Cast("PyObject**") PointerPointer arg1, @Cast("PyObject**") PointerPointer arg2);
@NoException public static native void PyErr_NormalizeException(@ByPtrPtr PyObject arg0, @ByPtrPtr PyObject arg1, @ByPtrPtr PyObject arg2);

/* Traceback manipulation (PEP 3134) */
@NoException public static native int PyException_SetTraceback(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyException_GetTraceback(PyObject arg0);

/* Cause manipulation (PEP 3134) */
@NoException public static native PyObject PyException_GetCause(PyObject arg0);
@NoException public static native void PyException_SetCause(PyObject arg0, PyObject arg1);

/* Context manipulation (PEP 3134) */
@NoException public static native PyObject PyException_GetContext(PyObject arg0);
@NoException public static native void PyException_SetContext(PyObject arg0, PyObject arg1);

/* */

// #define PyExceptionClass_Check(x)
//     (PyType_Check((x)) &&
//      PyType_FastSubclass((PyTypeObject*)(x), Py_TPFLAGS_BASE_EXC_SUBCLASS))

// #define PyExceptionInstance_Check(x)
//     PyType_FastSubclass(Py_TYPE(x), Py_TPFLAGS_BASE_EXC_SUBCLASS)

@NoException public static native @Cast("const char*") BytePointer PyExceptionClass_Name(PyObject arg0);

// #define PyExceptionInstance_Class(x) ((PyObject*)Py_TYPE(x))


/* Predefined exceptions */

public static native PyObject PyExc_BaseException(); public static native void PyExc_BaseException(PyObject setter);
public static native PyObject PyExc_Exception(); public static native void PyExc_Exception(PyObject setter);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
public static native PyObject PyExc_StopAsyncIteration(); public static native void PyExc_StopAsyncIteration(PyObject setter);
// #endif
public static native PyObject PyExc_StopIteration(); public static native void PyExc_StopIteration(PyObject setter);
public static native PyObject PyExc_GeneratorExit(); public static native void PyExc_GeneratorExit(PyObject setter);
public static native PyObject PyExc_ArithmeticError(); public static native void PyExc_ArithmeticError(PyObject setter);
public static native PyObject PyExc_LookupError(); public static native void PyExc_LookupError(PyObject setter);

public static native PyObject PyExc_AssertionError(); public static native void PyExc_AssertionError(PyObject setter);
public static native PyObject PyExc_AttributeError(); public static native void PyExc_AttributeError(PyObject setter);
public static native PyObject PyExc_BufferError(); public static native void PyExc_BufferError(PyObject setter);
public static native PyObject PyExc_EOFError(); public static native void PyExc_EOFError(PyObject setter);
public static native PyObject PyExc_FloatingPointError(); public static native void PyExc_FloatingPointError(PyObject setter);
public static native PyObject PyExc_OSError(); public static native void PyExc_OSError(PyObject setter);
public static native PyObject PyExc_ImportError(); public static native void PyExc_ImportError(PyObject setter);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
public static native PyObject PyExc_ModuleNotFoundError(); public static native void PyExc_ModuleNotFoundError(PyObject setter);
// #endif
public static native PyObject PyExc_IndexError(); public static native void PyExc_IndexError(PyObject setter);
public static native PyObject PyExc_KeyError(); public static native void PyExc_KeyError(PyObject setter);
public static native PyObject PyExc_KeyboardInterrupt(); public static native void PyExc_KeyboardInterrupt(PyObject setter);
public static native PyObject PyExc_MemoryError(); public static native void PyExc_MemoryError(PyObject setter);
public static native PyObject PyExc_NameError(); public static native void PyExc_NameError(PyObject setter);
public static native PyObject PyExc_OverflowError(); public static native void PyExc_OverflowError(PyObject setter);
public static native PyObject PyExc_RuntimeError(); public static native void PyExc_RuntimeError(PyObject setter);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
public static native PyObject PyExc_RecursionError(); public static native void PyExc_RecursionError(PyObject setter);
// #endif
public static native PyObject PyExc_NotImplementedError(); public static native void PyExc_NotImplementedError(PyObject setter);
public static native PyObject PyExc_SyntaxError(); public static native void PyExc_SyntaxError(PyObject setter);
public static native PyObject PyExc_IndentationError(); public static native void PyExc_IndentationError(PyObject setter);
public static native PyObject PyExc_TabError(); public static native void PyExc_TabError(PyObject setter);
public static native PyObject PyExc_ReferenceError(); public static native void PyExc_ReferenceError(PyObject setter);
public static native PyObject PyExc_SystemError(); public static native void PyExc_SystemError(PyObject setter);
public static native PyObject PyExc_SystemExit(); public static native void PyExc_SystemExit(PyObject setter);
public static native PyObject PyExc_TypeError(); public static native void PyExc_TypeError(PyObject setter);
public static native PyObject PyExc_UnboundLocalError(); public static native void PyExc_UnboundLocalError(PyObject setter);
public static native PyObject PyExc_UnicodeError(); public static native void PyExc_UnicodeError(PyObject setter);
public static native PyObject PyExc_UnicodeEncodeError(); public static native void PyExc_UnicodeEncodeError(PyObject setter);
public static native PyObject PyExc_UnicodeDecodeError(); public static native void PyExc_UnicodeDecodeError(PyObject setter);
public static native PyObject PyExc_UnicodeTranslateError(); public static native void PyExc_UnicodeTranslateError(PyObject setter);
public static native PyObject PyExc_ValueError(); public static native void PyExc_ValueError(PyObject setter);
public static native PyObject PyExc_ZeroDivisionError(); public static native void PyExc_ZeroDivisionError(PyObject setter);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
public static native PyObject PyExc_BlockingIOError(); public static native void PyExc_BlockingIOError(PyObject setter);
public static native PyObject PyExc_BrokenPipeError(); public static native void PyExc_BrokenPipeError(PyObject setter);
public static native PyObject PyExc_ChildProcessError(); public static native void PyExc_ChildProcessError(PyObject setter);
public static native PyObject PyExc_ConnectionError(); public static native void PyExc_ConnectionError(PyObject setter);
public static native PyObject PyExc_ConnectionAbortedError(); public static native void PyExc_ConnectionAbortedError(PyObject setter);
public static native PyObject PyExc_ConnectionRefusedError(); public static native void PyExc_ConnectionRefusedError(PyObject setter);
public static native PyObject PyExc_ConnectionResetError(); public static native void PyExc_ConnectionResetError(PyObject setter);
public static native PyObject PyExc_FileExistsError(); public static native void PyExc_FileExistsError(PyObject setter);
public static native PyObject PyExc_FileNotFoundError(); public static native void PyExc_FileNotFoundError(PyObject setter);
public static native PyObject PyExc_InterruptedError(); public static native void PyExc_InterruptedError(PyObject setter);
public static native PyObject PyExc_IsADirectoryError(); public static native void PyExc_IsADirectoryError(PyObject setter);
public static native PyObject PyExc_NotADirectoryError(); public static native void PyExc_NotADirectoryError(PyObject setter);
public static native PyObject PyExc_PermissionError(); public static native void PyExc_PermissionError(PyObject setter);
public static native PyObject PyExc_ProcessLookupError(); public static native void PyExc_ProcessLookupError(PyObject setter);
public static native PyObject PyExc_TimeoutError(); public static native void PyExc_TimeoutError(PyObject setter);
// #endif


/* Compatibility aliases */
public static native PyObject PyExc_EnvironmentError(); public static native void PyExc_EnvironmentError(PyObject setter);
public static native PyObject PyExc_IOError(); public static native void PyExc_IOError(PyObject setter);
// #ifdef MS_WINDOWS
// #endif

/* Predefined warning categories */
public static native PyObject PyExc_Warning(); public static native void PyExc_Warning(PyObject setter);
public static native PyObject PyExc_UserWarning(); public static native void PyExc_UserWarning(PyObject setter);
public static native PyObject PyExc_DeprecationWarning(); public static native void PyExc_DeprecationWarning(PyObject setter);
public static native PyObject PyExc_PendingDeprecationWarning(); public static native void PyExc_PendingDeprecationWarning(PyObject setter);
public static native PyObject PyExc_SyntaxWarning(); public static native void PyExc_SyntaxWarning(PyObject setter);
public static native PyObject PyExc_RuntimeWarning(); public static native void PyExc_RuntimeWarning(PyObject setter);
public static native PyObject PyExc_FutureWarning(); public static native void PyExc_FutureWarning(PyObject setter);
public static native PyObject PyExc_ImportWarning(); public static native void PyExc_ImportWarning(PyObject setter);
public static native PyObject PyExc_UnicodeWarning(); public static native void PyExc_UnicodeWarning(PyObject setter);
public static native PyObject PyExc_BytesWarning(); public static native void PyExc_BytesWarning(PyObject setter);
public static native PyObject PyExc_EncodingWarning(); public static native void PyExc_EncodingWarning(PyObject setter);
public static native PyObject PyExc_ResourceWarning(); public static native void PyExc_ResourceWarning(PyObject setter);


/* Convenience functions */

@NoException public static native int PyErr_BadArgument();
@NoException public static native PyObject PyErr_NoMemory();
@NoException public static native PyObject PyErr_SetFromErrno(PyObject arg0);
@NoException public static native PyObject PyErr_SetFromErrnoWithFilenameObject(
    PyObject arg0, PyObject arg1);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
@NoException public static native PyObject PyErr_SetFromErrnoWithFilenameObjects(
    PyObject arg0, PyObject arg1, PyObject arg2);
// #endif
@NoException public static native PyObject PyErr_SetFromErrnoWithFilename(
    PyObject exc,
    @Cast("const char*") BytePointer filename
    );
@NoException public static native PyObject PyErr_SetFromErrnoWithFilename(
    PyObject exc,
    String filename
    );

@NoException public static native PyObject PyErr_Format(
    PyObject exception,
    @Cast("const char*") BytePointer format
    );
@NoException public static native PyObject PyErr_Format(
    PyObject exception,
    String format
    );
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
@NoException public static native PyObject PyErr_FormatV(
    PyObject exception,
    @Cast("const char*") BytePointer format,
    @ByVal @Cast("va_list*") Pointer vargs);
@NoException public static native PyObject PyErr_FormatV(
    PyObject exception,
    String format,
    @ByVal @Cast("va_list*") Pointer vargs);
// #endif

// #ifdef MS_WINDOWS
// #endif /* MS_WINDOWS */

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
@NoException public static native PyObject PyErr_SetImportErrorSubclass(PyObject arg0, PyObject arg1,
    PyObject arg2, PyObject arg3);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyErr_SetImportError(PyObject arg0, PyObject arg1,
    PyObject arg2);
// #endif

/* Export the old function so that the existing API remains available: */
@NoException public static native void PyErr_BadInternalCall();
@NoException public static native void _PyErr_BadInternalCall(@Cast("const char*") BytePointer filename, int lineno);
@NoException public static native void _PyErr_BadInternalCall(String filename, int lineno);
/* Mask the old API with a call to the new API for code compiled under
   Python 2.0: */
// #define PyErr_BadInternalCall() _PyErr_BadInternalCall(__FILE__, __LINE__)

/* Function to create a new exception */
@NoException public static native PyObject PyErr_NewException(
    @Cast("const char*") BytePointer name, PyObject base, PyObject dict);
@NoException public static native PyObject PyErr_NewException(
    String name, PyObject base, PyObject dict);
@NoException public static native PyObject PyErr_NewExceptionWithDoc(
    @Cast("const char*") BytePointer name, @Cast("const char*") BytePointer doc, PyObject base, PyObject dict);
@NoException public static native PyObject PyErr_NewExceptionWithDoc(
    String name, String doc, PyObject base, PyObject dict);
@NoException public static native void PyErr_WriteUnraisable(PyObject arg0);


/* In signalmodule.c */
@NoException public static native int PyErr_CheckSignals();
@NoException public static native void PyErr_SetInterrupt();
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000
@NoException public static native int PyErr_SetInterruptEx(int signum);
// #endif

/* Support for adding program text to SyntaxErrors */
@NoException public static native void PyErr_SyntaxLocation(
    @Cast("const char*") BytePointer filename,
    int lineno);
@NoException public static native void PyErr_SyntaxLocation(
    String filename,
    int lineno);
@NoException public static native void PyErr_SyntaxLocationEx(
    @Cast("const char*") BytePointer filename,
    int lineno,
    int col_offset);
@NoException public static native void PyErr_SyntaxLocationEx(
    String filename,
    int lineno,
    int col_offset);
@NoException public static native PyObject PyErr_ProgramText(
    @Cast("const char*") BytePointer filename,
    int lineno);
@NoException public static native PyObject PyErr_ProgramText(
    String filename,
    int lineno);

/* The following functions are used to create and modify unicode
   exceptions from C */

/* create a UnicodeDecodeError object */
@NoException public static native PyObject PyUnicodeDecodeError_Create(
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer object,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native PyObject PyUnicodeDecodeError_Create(
    String encoding,
    String object,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    String reason
    );

/* get the encoding attribute */
@NoException public static native PyObject PyUnicodeEncodeError_GetEncoding(PyObject arg0);
@NoException public static native PyObject PyUnicodeDecodeError_GetEncoding(PyObject arg0);

/* get the object attribute */
@NoException public static native PyObject PyUnicodeEncodeError_GetObject(PyObject arg0);
@NoException public static native PyObject PyUnicodeDecodeError_GetObject(PyObject arg0);
@NoException public static native PyObject PyUnicodeTranslateError_GetObject(PyObject arg0);

/* get the value of the start attribute (the int * may not be NULL)
   return 0 on success, -1 on failure */
@NoException public static native int PyUnicodeEncodeError_GetStart(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);
@NoException public static native int PyUnicodeDecodeError_GetStart(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);
@NoException public static native int PyUnicodeTranslateError_GetStart(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);

/* assign a new value to the start attribute
   return 0 on success, -1 on failure */
@NoException public static native int PyUnicodeEncodeError_SetStart(PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int PyUnicodeDecodeError_SetStart(PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int PyUnicodeTranslateError_SetStart(PyObject arg0, @Cast("Py_ssize_t") long arg1);

/* get the value of the end attribute (the int *may not be NULL)
 return 0 on success, -1 on failure */
@NoException public static native int PyUnicodeEncodeError_GetEnd(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);
@NoException public static native int PyUnicodeDecodeError_GetEnd(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);
@NoException public static native int PyUnicodeTranslateError_GetEnd(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);

/* assign a new value to the end attribute
   return 0 on success, -1 on failure */
@NoException public static native int PyUnicodeEncodeError_SetEnd(PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int PyUnicodeDecodeError_SetEnd(PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int PyUnicodeTranslateError_SetEnd(PyObject arg0, @Cast("Py_ssize_t") long arg1);

/* get the value of the reason attribute */
@NoException public static native PyObject PyUnicodeEncodeError_GetReason(PyObject arg0);
@NoException public static native PyObject PyUnicodeDecodeError_GetReason(PyObject arg0);
@NoException public static native PyObject PyUnicodeTranslateError_GetReason(PyObject arg0);

/* assign a new value to the reason attribute
   return 0 on success, -1 on failure */
@NoException public static native int PyUnicodeEncodeError_SetReason(
    PyObject exc,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native int PyUnicodeEncodeError_SetReason(
    PyObject exc,
    String reason
    );
@NoException public static native int PyUnicodeDecodeError_SetReason(
    PyObject exc,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native int PyUnicodeDecodeError_SetReason(
    PyObject exc,
    String reason
    );
@NoException public static native int PyUnicodeTranslateError_SetReason(
    PyObject exc,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native int PyUnicodeTranslateError_SetReason(
    PyObject exc,
    String reason
    );

@NoException public static native int PyOS_snprintf(@Cast("char*") BytePointer str, @Cast("size_t") long size, @Cast("const char*") BytePointer format);
@NoException public static native int PyOS_snprintf(@Cast("char*") ByteBuffer str, @Cast("size_t") long size, String format);
@NoException public static native int PyOS_snprintf(@Cast("char*") byte[] str, @Cast("size_t") long size, @Cast("const char*") BytePointer format);
@NoException public static native int PyOS_snprintf(@Cast("char*") BytePointer str, @Cast("size_t") long size, String format);
@NoException public static native int PyOS_snprintf(@Cast("char*") ByteBuffer str, @Cast("size_t") long size, @Cast("const char*") BytePointer format);
@NoException public static native int PyOS_snprintf(@Cast("char*") byte[] str, @Cast("size_t") long size, String format);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") BytePointer str, @Cast("size_t") long size, @Cast("const char*") BytePointer format, @ByVal @Cast("va_list*") Pointer va);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") ByteBuffer str, @Cast("size_t") long size, String format, @ByVal @Cast("va_list*") Pointer va);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") byte[] str, @Cast("size_t") long size, @Cast("const char*") BytePointer format, @ByVal @Cast("va_list*") Pointer va);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") BytePointer str, @Cast("size_t") long size, String format, @ByVal @Cast("va_list*") Pointer va);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") ByteBuffer str, @Cast("size_t") long size, @Cast("const char*") BytePointer format, @ByVal @Cast("va_list*") Pointer va);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") byte[] str, @Cast("size_t") long size, String format, @ByVal @Cast("va_list*") Pointer va);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_ERRORS_H
// #  include  "cpython/pyerrors.h"
// #  undef Py_CPYTHON_ERRORS_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_ERRORS_H */


// Parsed from cpython/pyerrors.h

// #ifndef Py_CPYTHON_ERRORS_H
// #  error "this header file must not be included directly"
// #endif

/* Error objects */

/* PyException_HEAD defines the initial segment of every exception class. */
// #define PyException_HEAD PyObject_HEAD PyObject *dict;
//              PyObject *args; PyObject *traceback;
//              PyObject *context; PyObject *cause;
//              char suppress_context;
// Targeting ../PyBaseExceptionObject.java


// Targeting ../PySyntaxErrorObject.java


// Targeting ../PyImportErrorObject.java


// Targeting ../PyUnicodeErrorObject.java


// Targeting ../PySystemExitObject.java


// Targeting ../PyOSErrorObject.java


// Targeting ../PyStopIterationObject.java


// Targeting ../PyNameErrorObject.java


// Targeting ../PyAttributeErrorObject.java



/* Compatibility typedefs */
// #ifdef MS_WINDOWS
// #endif

/* Error handling definitions */

@NoException public static native void _PyErr_SetKeyError(PyObject arg0);

@NoException public static native void _PyErr_GetExcInfo(PyThreadState arg0, @Cast("PyObject**") PointerPointer arg1, @Cast("PyObject**") PointerPointer arg2, @Cast("PyObject**") PointerPointer arg3);
@NoException public static native void _PyErr_GetExcInfo(PyThreadState arg0, @ByPtrPtr PyObject arg1, @ByPtrPtr PyObject arg2, @ByPtrPtr PyObject arg3);

/* Context manipulation (PEP 3134) */

@NoException public static native void _PyErr_ChainExceptions(PyObject arg0, PyObject arg1, PyObject arg2);

/* Convenience functions */

// #ifdef MS_WINDOWS
// #endif /* MS_WINDOWS */

/* Like PyErr_Format(), but saves current exception as __context__ and
   __cause__.
 */
@NoException public static native PyObject _PyErr_FormatFromCause(
    PyObject exception,
    @Cast("const char*") BytePointer format
    );
@NoException public static native PyObject _PyErr_FormatFromCause(
    PyObject exception,
    String format
    );

// #ifdef MS_WINDOWS
// #endif

/* In exceptions.c */

/* Helper that attempts to replace the current exception with one of the
 * same type but with a prefix added to the exception text. The resulting
 * exception description looks like:
 *
 *     prefix (exc_type: original_exc_str)
 *
 * Only some exceptions can be safely replaced. If the function determines
 * it isn't safe to perform the replacement, it will leave the original
 * unmodified exception in place.
 *
 * Returns a borrowed reference to the new exception (if any), NULL if the
 * existing exception was left in place.
 */
@NoException public static native PyObject _PyErr_TrySetFromCause(
    @Cast("const char*") BytePointer prefix_format
    );
@NoException public static native PyObject _PyErr_TrySetFromCause(
    String prefix_format
    );

/* In signalmodule.c */


@NoException public static native int _PyErr_CheckSignals();

/* Support for adding program text to SyntaxErrors */

@NoException public static native void PyErr_SyntaxLocationObject(
    PyObject filename,
    int lineno,
    int col_offset);

@NoException public static native void PyErr_RangedSyntaxLocationObject(
    PyObject filename,
    int lineno,
    int col_offset,
    int end_lineno,
    int end_col_offset);

@NoException public static native PyObject PyErr_ProgramTextObject(
    PyObject filename,
    int lineno);

/* Create a UnicodeEncodeError object.
 *
 * TODO: This API will be removed in Python 3.11.
 */
@NoException public static native @Deprecated PyObject PyUnicodeEncodeError_Create(
    @Cast("const char*") BytePointer encoding,
    @Cast("const Py_UNICODE*") Pointer object,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native @Deprecated PyObject PyUnicodeEncodeError_Create(
    String encoding,
    @Cast("const Py_UNICODE*") Pointer object,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    String reason
    );

/* Create a UnicodeTranslateError object.
 *
 * TODO: This API will be removed in Python 3.11.
 */
@NoException public static native @Deprecated PyObject PyUnicodeTranslateError_Create(
    @Cast("const Py_UNICODE*") Pointer object,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native @Deprecated PyObject PyUnicodeTranslateError_Create(
    @Cast("const Py_UNICODE*") Pointer object,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    String reason
    );

@NoException public static native PyObject _PyErr_ProgramDecodedTextObject(
    PyObject filename,
    int lineno,
    @Cast("const char*") BytePointer encoding);
@NoException public static native PyObject _PyErr_ProgramDecodedTextObject(
    PyObject filename,
    int lineno,
    String encoding);

@NoException public static native PyObject _PyUnicodeTranslateError_Create(
    PyObject object,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native PyObject _PyUnicodeTranslateError_Create(
    PyObject object,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    String reason
    );

@NoException public static native void _PyErr_WriteUnraisableMsg(
    @Cast("const char*") BytePointer err_msg,
    PyObject obj);
@NoException public static native void _PyErr_WriteUnraisableMsg(
    String err_msg,
    PyObject obj);

@NoException public static native void _Py_FatalErrorFunc(
    @Cast("const char*") BytePointer func,
    @Cast("const char*") BytePointer message);
@NoException public static native void _Py_FatalErrorFunc(
    String func,
    String message);

@NoException public static native void _Py_FatalErrorFormat(
    @Cast("const char*") BytePointer func,
    @Cast("const char*") BytePointer format);
@NoException public static native void _Py_FatalErrorFormat(
    String func,
    String format);

// #define Py_FatalError(message) _Py_FatalErrorFunc(__func__, message)


// Parsed from pythread.h


// #ifndef Py_PYTHREAD_H
// #define Py_PYTHREAD_H
// Targeting ../PyThread_type_lock.java



// #ifdef __cplusplus
// #endif

/* Return status codes for Python lock acquisition.  Chosen for maximum
 * backwards compatibility, ie failure -> 0, success -> 1.  */
/** enum PyLockStatus */
public static final int
    PY_LOCK_FAILURE = 0,
    PY_LOCK_ACQUIRED = 1,
    PY_LOCK_INTR = 2;

// #ifndef Py_LIMITED_API
// #define PYTHREAD_INVALID_THREAD_ID ((unsigned long)-1)
// #endif

@NoException public static native void PyThread_init_thread();
// Targeting ../Arg0_Pointer.java


@NoException public static native @Cast("unsigned long") long PyThread_start_new_thread(Arg0_Pointer arg0, Pointer arg1);
@NoException public static native void PyThread_exit_thread();
@NoException public static native @Cast("unsigned long") long PyThread_get_thread_ident();

// #if defined(__APPLE__) || defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(_WIN32) || defined(_AIX)
// #define PY_HAVE_THREAD_NATIVE_ID
@NoException public static native @Cast("unsigned long") long PyThread_get_thread_native_id();
// #endif

@NoException public static native PyThread_type_lock PyThread_allocate_lock();
@NoException public static native void PyThread_free_lock(PyThread_type_lock arg0);
@NoException public static native int PyThread_acquire_lock(PyThread_type_lock arg0, int arg1);
public static final int WAIT_LOCK =       1;
public static final int NOWAIT_LOCK =     0;

// #ifndef Py_LIMITED_API
// #ifdef HAVE_FORK
// #endif  /* HAVE_FORK */
// #endif  /* !Py_LIMITED_API */

/* PY_TIMEOUT_T is the integral type used to specify timeouts when waiting
   on a lock (see PyThread_acquire_lock_timed() below).
   PY_TIMEOUT_MAX is the highest usable value (in microseconds) of that
   type, and depends on the system threading API.

   NOTE: this isn't the same value as `_thread.TIMEOUT_MAX`.  The _thread
   module exposes a higher-level API, with timeouts expressed in seconds
   and floating-point numbers allowed.
*/
// #define PY_TIMEOUT_T long long

// #if defined(_POSIX_THREADS)
   /* PyThread_acquire_lock_timed() uses _PyTime_FromNanoseconds(us * 1000),
      convert microseconds to nanoseconds. */
public static native @MemberGetter long PY_TIMEOUT_MAX();
public static final long PY_TIMEOUT_MAX = PY_TIMEOUT_MAX();
// #elif defined (NT_THREADS)
   /* In the NT API, the timeout is a DWORD and is expressed in milliseconds */
// #  if 0xFFFFFFFFL * 1000 < LLONG_MAX
// #  else
// #  endif
// #else
// #endif


/* If microseconds == 0, the call is non-blocking: it returns immediately
   even when the lock can't be acquired.
   If microseconds > 0, the call waits up to the specified duration.
   If microseconds < 0, the call waits until success (or abnormal failure)

   microseconds must be less than PY_TIMEOUT_MAX. Behaviour otherwise is
   undefined.

   If intr_flag is true and the acquire is interrupted by a signal, then the
   call will return PY_LOCK_INTR.  The caller may reattempt to acquire the
   lock.
*/
@NoException public static native @Cast("PyLockStatus") int PyThread_acquire_lock_timed(PyThread_type_lock arg0,
                                                     long microseconds,
                                                     int intr_flag);

@NoException public static native void PyThread_release_lock(PyThread_type_lock arg0);

@NoException public static native @Cast("size_t") long PyThread_get_stacksize();
@NoException public static native int PyThread_set_stacksize(@Cast("size_t") long arg0);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyThread_GetInfo();
// #endif


/* Thread Local Storage (TLS) API
   TLS API is DEPRECATED.  Use Thread Specific Storage (TSS) API.

   The existing TLS API has used int to represent TLS keys across all
   platforms, but it is not POSIX-compliant.  Therefore, the new TSS API uses
   opaque data type to represent TSS keys to be compatible (see PEP 539).
*/
@NoException public static native @Deprecated int PyThread_create_key();
@NoException public static native @Deprecated void PyThread_delete_key(int key);
@NoException public static native @Deprecated int PyThread_set_key_value(int key,
                                                          Pointer value);
@NoException public static native @Deprecated Pointer PyThread_get_key_value(int key);
@NoException public static native @Deprecated void PyThread_delete_key_value(int key);

/* Cleanup after a fork */
@NoException public static native @Deprecated void PyThread_ReInitTLS();
// Targeting ../Py_tss_t.java

  /* opaque */

// #ifndef Py_LIMITED_API
// #if defined(_POSIX_THREADS)
    /* Darwin needs pthread.h to know type name the pthread_key_t. */
// #   include <pthread.h>
// #   define NATIVE_TSS_KEY_T     pthread_key_t
// #elif defined(NT_THREADS)
    /* In Windows, native TSS key type is DWORD,
       but hardcode the unsigned long to avoid errors for include directive.
    */
// #   define NATIVE_TSS_KEY_T     unsigned long
// #else
// #   error "Require native threads. See https://bugs.python.org/issue31370"
// Targeting ../_Py_tss_t.java



// #undef NATIVE_TSS_KEY_T

/* When static allocation, you must initialize with Py_tss_NEEDS_INIT. */
public static native @MemberGetter int Py_tss_NEEDS_INIT();
public static final int Py_tss_NEEDS_INIT = Py_tss_NEEDS_INIT();
// #endif  /* !Py_LIMITED_API */

@NoException public static native Py_tss_t PyThread_tss_alloc();
@NoException public static native void PyThread_tss_free(Py_tss_t key);

/* The parameter key must not be NULL. */
@NoException public static native int PyThread_tss_is_created(Py_tss_t key);
@NoException public static native int PyThread_tss_create(Py_tss_t key);
@NoException public static native void PyThread_tss_delete(Py_tss_t key);
@NoException public static native int PyThread_tss_set(Py_tss_t key, Pointer value);
@NoException public static native Pointer PyThread_tss_get(Py_tss_t key);
// #endif  /* New in 3.7 */

// #ifdef __cplusplus
// #endif

// #endif /* !Py_PYTHREAD_H */


// Parsed from pystate.h

/* Thread and interpreter state structures and their interfaces */


// #ifndef Py_PYSTATE_H
// #define Py_PYSTATE_H
// #ifdef __cplusplus
// #endif

/* This limitation is for performance and simplicity. If needed it can be
removed (with effort). */
public static final int MAX_CO_EXTRA_USERS = 255;
// Targeting ../PyInterpreterState.java



/* struct _ts is defined in cpython/pystate.h */
/* struct _is is defined in internal/pycore_interp.h */

@NoException public static native PyInterpreterState PyInterpreterState_New();
@NoException public static native void PyInterpreterState_Clear(PyInterpreterState arg0);
@NoException public static native void PyInterpreterState_Delete(PyInterpreterState arg0);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
/* New in 3.9 */
/* Get the current interpreter state.

   Issue a fatal error if there no current Python thread state or no current
   interpreter. It cannot return NULL.

   The caller must hold the GIL. */
@NoException public static native PyInterpreterState PyInterpreterState_Get();
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03080000
/* New in 3.8 */
@NoException public static native PyObject PyInterpreterState_GetDict(PyInterpreterState arg0);
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000
/* New in 3.7 */
@NoException public static native @Cast("int64_t") long PyInterpreterState_GetID(PyInterpreterState arg0);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000

/* State unique per thread */

/* New in 3.3 */
@NoException public static native int PyState_AddModule(PyObject arg0, PyModuleDef arg1);
@NoException public static native int PyState_RemoveModule(PyModuleDef arg0);
// #endif
@NoException public static native PyObject PyState_FindModule(PyModuleDef arg0);

@NoException public static native PyThreadState PyThreadState_New(PyInterpreterState arg0);
@NoException public static native void PyThreadState_Clear(PyThreadState arg0);
@NoException public static native void PyThreadState_Delete(PyThreadState arg0);

/* Get the current thread state.

   When the current thread state is NULL, this issues a fatal error (so that
   the caller needn't check for NULL).

   The caller must hold the GIL.

   See also PyThreadState_GET() and _PyThreadState_GET(). */
@NoException public static native PyThreadState PyThreadState_Get();

/* Get the current Python thread state.

   Macro using PyThreadState_Get() or _PyThreadState_GET() depending if
   pycore_pystate.h is included or not (this header redefines the macro).

   If PyThreadState_Get() is used, issue a fatal error if the current thread
   state is NULL.

   See also PyThreadState_Get() and _PyThreadState_GET(). */
// #define PyThreadState_GET() PyThreadState_Get()

@NoException public static native PyThreadState PyThreadState_Swap(PyThreadState arg0);
@NoException public static native PyObject PyThreadState_GetDict();
@NoException public static native int PyThreadState_SetAsyncExc(@Cast("unsigned long") long arg0, PyObject arg1);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
/* New in 3.9 */
@NoException public static native PyInterpreterState PyThreadState_GetInterpreter(PyThreadState tstate);
@NoException public static native PyFrameObject PyThreadState_GetFrame(PyThreadState tstate);
@NoException public static native @Cast("uint64_t") long PyThreadState_GetID(PyThreadState tstate);
// #endif

/** enum PyGILState_STATE */
public static final int PyGILState_LOCKED = 0, PyGILState_UNLOCKED = 1;


/* Ensure that the current thread is ready to call the Python
   C API, regardless of the current state of Python, or of its
   thread lock.  This may be called as many times as desired
   by a thread so long as each call is matched with a call to
   PyGILState_Release().  In general, other thread-state APIs may
   be used between _Ensure() and _Release() calls, so long as the
   thread-state is restored to its previous state before the Release().
   For example, normal use of the Py_BEGIN_ALLOW_THREADS/
   Py_END_ALLOW_THREADS macros are acceptable.

   The return value is an opaque "handle" to the thread state when
   PyGILState_Ensure() was called, and must be passed to
   PyGILState_Release() to ensure Python is left in the same state. Even
   though recursive calls are allowed, these handles can *not* be shared -
   each unique call to PyGILState_Ensure must save the handle for its
   call to PyGILState_Release.

   When the function returns, the current thread will hold the GIL.

   Failure is a fatal error.
*/
@NoException public static native @Cast("PyGILState_STATE") int PyGILState_Ensure();

/* Release any resources previously acquired.  After this call, Python's
   state will be the same as it was prior to the corresponding
   PyGILState_Ensure() call (but generally this state will be unknown to
   the caller, hence the use of the GILState API.)

   Every call to PyGILState_Ensure must be matched by a call to
   PyGILState_Release on the same thread.
*/
@NoException public static native void PyGILState_Release(@Cast("PyGILState_STATE") int arg0);

/* Helper/diagnostic function - get the current thread state for
   this thread.  May return NULL if no GILState API has been used
   on the current thread.  Note that the main thread always has such a
   thread-state, even if no auto-thread-state call has been made
   on the main thread.
*/
@NoException public static native PyThreadState PyGILState_GetThisThreadState();


// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_PYSTATE_H
// #  include  "cpython/pystate.h"
// #  undef Py_CPYTHON_PYSTATE_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYSTATE_H */


// Parsed from context.h

// #ifndef Py_CONTEXT_H
// #define Py_CONTEXT_H
// #ifdef __cplusplus
// #endif

// #ifndef Py_LIMITED_API


public static native @ByRef PyTypeObject PyContext_Type(); public static native void PyContext_Type(PyTypeObject setter);
// Targeting ../PyContext.java



public static native @ByRef PyTypeObject PyContextVar_Type(); public static native void PyContextVar_Type(PyTypeObject setter);
// Targeting ../PyContextVar.java



public static native @ByRef PyTypeObject PyContextToken_Type(); public static native void PyContextToken_Type(PyTypeObject setter);
// Targeting ../PyContextToken.java




// #define PyContext_CheckExact(o) Py_IS_TYPE(o, &PyContext_Type)
// #define PyContextVar_CheckExact(o) Py_IS_TYPE(o, &PyContextVar_Type)
// #define PyContextToken_CheckExact(o) Py_IS_TYPE(o, &PyContextToken_Type)


@NoException public static native PyObject PyContext_New();
@NoException public static native PyObject PyContext_Copy(PyObject arg0);
@NoException public static native PyObject PyContext_CopyCurrent();

@NoException public static native int PyContext_Enter(PyObject arg0);
@NoException public static native int PyContext_Exit(PyObject arg0);


/* Create a new context variable.

   default_value can be NULL.
*/
@NoException public static native PyObject PyContextVar_New(
    @Cast("const char*") BytePointer name, PyObject default_value);
@NoException public static native PyObject PyContextVar_New(
    String name, PyObject default_value);


/* Get a value for the variable.

   Returns -1 if an error occurred during lookup.

   Returns 0 if value either was or was not found.

   If value was found, *value will point to it.
   If not, it will point to:

   - default_value, if not NULL;
   - the default value of "var", if not NULL;
   - NULL.

   '*value' will be a new ref, if not NULL.
*/
@NoException public static native int PyContextVar_Get(
    PyObject var, PyObject default_value, @Cast("PyObject**") PointerPointer value);
@NoException public static native int PyContextVar_Get(
    PyObject var, PyObject default_value, @ByPtrPtr PyObject value);


/* Set a new value for the variable.
   Returns NULL if an error occurs.
*/
@NoException public static native PyObject PyContextVar_Set(PyObject var, PyObject value);


/* Reset a variable to its previous value.
   Returns 0 on success, -1 on error.
*/
@NoException public static native int PyContextVar_Reset(PyObject var, PyObject token);


/* This method is exposed only for CPython tests. Don not use it. */
@NoException public static native PyObject _PyContext_NewHamtForTests();


// #endif /* !Py_LIMITED_API */

// #ifdef __cplusplus
// #endif
// #endif /* !Py_CONTEXT_H */


// Parsed from cpython/initconfig.h

// #ifndef Py_PYCORECONFIG_H
// #define Py_PYCORECONFIG_H
// #ifndef Py_LIMITED_API
// #ifdef __cplusplus
// Targeting ../PyStatus.java



@NoException public static native @ByVal PyStatus PyStatus_Ok();
@NoException public static native @ByVal PyStatus PyStatus_Error(@Cast("const char*") BytePointer err_msg);
@NoException public static native @ByVal PyStatus PyStatus_Error(String err_msg);
@NoException public static native @ByVal PyStatus PyStatus_NoMemory();
@NoException public static native @ByVal PyStatus PyStatus_Exit(int exitcode);
@NoException public static native int PyStatus_IsError(@ByVal PyStatus err);
@NoException public static native int PyStatus_IsExit(@ByVal PyStatus err);
@NoException public static native int PyStatus_Exception(@ByVal PyStatus err);
// Targeting ../PyWideStringList.java



@NoException public static native @ByVal PyStatus PyWideStringList_Append(PyWideStringList list,
    @Cast("const wchar_t*") Pointer item);
@NoException public static native @ByVal PyStatus PyWideStringList_Insert(PyWideStringList list,
    @Cast("Py_ssize_t") long index,
    @Cast("const wchar_t*") Pointer item);
// Targeting ../PyPreConfig.java



@NoException public static native void PyPreConfig_InitPythonConfig(PyPreConfig config);
@NoException public static native void PyPreConfig_InitIsolatedConfig(PyPreConfig config);
// Targeting ../PyConfig.java



@NoException public static native void PyConfig_InitPythonConfig(PyConfig config);
@NoException public static native void PyConfig_InitIsolatedConfig(PyConfig config);
@NoException public static native void PyConfig_Clear(PyConfig arg0);
@NoException public static native @ByVal PyStatus PyConfig_SetString(
    PyConfig config,
    @Cast("wchar_t**") PointerPointer config_str,
    @Cast("const wchar_t*") Pointer str);
@NoException public static native @ByVal PyStatus PyConfig_SetString(
    PyConfig config,
    @Cast("wchar_t**") @ByPtrPtr Pointer config_str,
    @Cast("const wchar_t*") Pointer str);
@NoException public static native @ByVal PyStatus PyConfig_SetBytesString(
    PyConfig config,
    @Cast("wchar_t**") PointerPointer config_str,
    @Cast("const char*") BytePointer str);
@NoException public static native @ByVal PyStatus PyConfig_SetBytesString(
    PyConfig config,
    @Cast("wchar_t**") @ByPtrPtr Pointer config_str,
    @Cast("const char*") BytePointer str);
@NoException public static native @ByVal PyStatus PyConfig_SetBytesString(
    PyConfig config,
    @Cast("wchar_t**") @ByPtrPtr Pointer config_str,
    String str);
@NoException public static native @ByVal PyStatus PyConfig_Read(PyConfig config);
@NoException public static native @ByVal PyStatus PyConfig_SetBytesArgv(
    PyConfig config,
    @Cast("Py_ssize_t") long argc,
    @Cast("char*const*") PointerPointer argv);
@NoException public static native @ByVal PyStatus PyConfig_SetBytesArgv(
    PyConfig config,
    @Cast("Py_ssize_t") long argc,
    @Cast("char*const*") @ByPtrPtr BytePointer argv);
@NoException public static native @ByVal PyStatus PyConfig_SetBytesArgv(
    PyConfig config,
    @Cast("Py_ssize_t") long argc,
    @Cast("char*const*") @ByPtrPtr ByteBuffer argv);
@NoException public static native @ByVal PyStatus PyConfig_SetBytesArgv(
    PyConfig config,
    @Cast("Py_ssize_t") long argc,
    @Cast("char*const*") @ByPtrPtr byte[] argv);
@NoException public static native @ByVal PyStatus PyConfig_SetArgv(PyConfig config,
    @Cast("Py_ssize_t") long argc,
    @Cast("wchar_t*const*") PointerPointer argv);
@NoException public static native @ByVal PyStatus PyConfig_SetArgv(PyConfig config,
    @Cast("Py_ssize_t") long argc,
    @Cast("wchar_t*const*") @ByPtrPtr Pointer argv);
@NoException public static native @ByVal PyStatus PyConfig_SetWideStringList(PyConfig config,
    PyWideStringList list,
    @Cast("Py_ssize_t") long length, @Cast("wchar_t**") PointerPointer items);
@NoException public static native @ByVal PyStatus PyConfig_SetWideStringList(PyConfig config,
    PyWideStringList list,
    @Cast("Py_ssize_t") long length, @Cast("wchar_t**") @ByPtrPtr Pointer items);


/* --- Helper functions --------------------------------------- */

/* Get the original command line arguments, before Python modified them.

   See also PyConfig.orig_argv. */
@NoException public static native void Py_GetArgcArgv(IntPointer argc, @Cast("wchar_t***") @ByPtrPtr PointerPointer argv);
@NoException public static native void Py_GetArgcArgv(IntBuffer argc, @Cast("wchar_t***") @ByPtrPtr PointerPointer argv);
@NoException public static native void Py_GetArgcArgv(int[] argc, @Cast("wchar_t***") @ByPtrPtr PointerPointer argv);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_LIMITED_API */
// #endif /* !Py_PYCORECONFIG_H */


// Parsed from cpython/pystate.h

// #ifndef Py_CPYTHON_PYSTATE_H
// #  error "this header file must not be included directly"
// #endif

@NoException public static native int _PyInterpreterState_RequiresIDRef(PyInterpreterState arg0);
@NoException public static native void _PyInterpreterState_RequireIDRef(PyInterpreterState arg0, int arg1);

@NoException public static native PyObject _PyInterpreterState_GetMainModule(PyInterpreterState arg0);
// Targeting ../Py_tracefunc.java



/* The following values are used for 'what' for tracefunc functions
 *
 * To add a new kind of trace event, also update "trace_init" in
 * Python/sysmodule.c to define the Python level event name
 */
public static final int PyTrace_CALL = 0;
public static final int PyTrace_EXCEPTION = 1;
public static final int PyTrace_LINE = 2;
public static final int PyTrace_RETURN = 3;
public static final int PyTrace_C_CALL = 4;
public static final int PyTrace_C_EXCEPTION = 5;
public static final int PyTrace_C_RETURN = 6;
public static final int PyTrace_OPCODE = 7;
// Targeting ../CFrame.java


// Targeting ../_PyErr_StackItem.java


// Targeting ../PyThreadState.java



// Alias for backward compatibility with Python 3.8
// #define _PyInterpreterState_Get PyInterpreterState_Get

@NoException public static native PyThreadState _PyThreadState_Prealloc(PyInterpreterState arg0);

/* Similar to PyThreadState_Get(), but don't issue a fatal error
 * if it is NULL. */
@NoException public static native PyThreadState _PyThreadState_UncheckedGet();

@NoException public static native PyObject _PyThreadState_GetDict(PyThreadState tstate);

/* PyGILState */

/* Helper/diagnostic function - return 1 if the current thread
   currently holds the GIL, 0 otherwise.

   The function returns 1 if _PyGILState_check_enabled is non-zero. */
@NoException public static native int PyGILState_Check();

/* Get the single PyInterpreterState used by this process' GILState
   implementation.

   This function doesn't check for error. Return NULL before _PyGILState_Init()
   is called and after _PyGILState_Fini() is called.

   See also _PyInterpreterState_Get() and _PyInterpreterState_GET(). */
@NoException public static native PyInterpreterState _PyGILState_GetInterpreterStateUnsafe();

/* The implementation of sys._current_frames()  Returns a dict mapping
   thread id to that thread's current frame.
*/
@NoException public static native PyObject _PyThread_CurrentFrames();

/* The implementation of sys._current_exceptions()  Returns a dict mapping
   thread id to that thread's current exception.
*/
@NoException public static native PyObject _PyThread_CurrentExceptions();

/* Routines for advanced debuggers, requested by David Beazley.
   Don't use unless you know what you are doing! */
@NoException public static native PyInterpreterState PyInterpreterState_Main();
@NoException public static native PyInterpreterState PyInterpreterState_Head();
@NoException public static native PyInterpreterState PyInterpreterState_Next(PyInterpreterState arg0);
@NoException public static native PyThreadState PyInterpreterState_ThreadHead(PyInterpreterState arg0);
@NoException public static native PyThreadState PyThreadState_Next(PyThreadState arg0);
@NoException public static native void PyThreadState_DeleteCurrent();
// Targeting ../_PyFrameEvalFunction.java



@NoException public static native _PyFrameEvalFunction _PyInterpreterState_GetEvalFrameFunc(
    PyInterpreterState interp);
@NoException public static native void _PyInterpreterState_SetEvalFrameFunc(
    PyInterpreterState interp,
    _PyFrameEvalFunction eval_frame);

@NoException public static native @Const PyConfig _PyInterpreterState_GetConfig(PyInterpreterState interp);

/* Get a copy of the current interpreter configuration.

   Return 0 on success. Raise an exception and return -1 on error.

   The caller must initialize 'config', using PyConfig_InitPythonConfig()
   for example.

   Python must be preinitialized to call this method.
   The caller must hold the GIL. */
@NoException public static native int _PyInterpreterState_GetConfigCopy(
    PyConfig config);

/* Set the configuration of the current interpreter.

   This function should be called during or just after the Python
   initialization.

   Update the sys module with the new configuration. If the sys module was
   modified directly after the Python initialization, these changes are lost.

   Some configuration like faulthandler or warnoptions can be updated in the
   configuration, but don't reconfigure Python (don't enable/disable
   faulthandler and don't reconfigure warnings filters).

   Return 0 on success. Raise an exception and return -1 on error.

   The configuration should come from _PyInterpreterState_GetConfigCopy(). */
@NoException public static native int _PyInterpreterState_SetConfig(
    @Const PyConfig config);

// Get the configuration of the current interpreter.
// The caller must hold the GIL.
@NoException public static native @Const PyConfig _Py_GetConfig();
// Targeting ../_xid.java


// Targeting ../_PyCrossInterpreterData.java



@NoException public static native int _PyObject_GetCrossInterpreterData(PyObject arg0, _PyCrossInterpreterData arg1);
@NoException public static native PyObject _PyCrossInterpreterData_NewObject(_PyCrossInterpreterData arg0);
@NoException public static native void _PyCrossInterpreterData_Release(_PyCrossInterpreterData arg0);

@NoException public static native int _PyObject_CheckCrossInterpreterData(PyObject arg0);
// Targeting ../crossinterpdatafunc.java



@NoException public static native int _PyCrossInterpreterData_RegisterClass(PyTypeObject arg0, crossinterpdatafunc arg1);
@NoException public static native crossinterpdatafunc _PyCrossInterpreterData_Lookup(PyObject arg0);


// Parsed from modsupport.h


// #ifndef Py_MODSUPPORT_H
// #define Py_MODSUPPORT_H
// #ifdef __cplusplus
// #endif

/* Module support interface */

// #include <stdarg.h>

/* If PY_SSIZE_T_CLEAN is defined, each functions treats #-specifier
   to mean Py_ssize_t */
// #ifdef PY_SSIZE_T_CLEAN
// #else
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _Py_VaBuildValue_SizeT(@Cast("const char*") BytePointer arg0, @ByVal @Cast("va_list*") Pointer arg1);
@NoException public static native PyObject _Py_VaBuildValue_SizeT(String arg0, @ByVal @Cast("va_list*") Pointer arg1);
@NoException public static native @Cast("PyObject**") PointerPointer _Py_VaBuildStack_SizeT(
    @Cast("PyObject**") PointerPointer small_stack,
    @Cast("Py_ssize_t") long small_stack_len,
    @Cast("const char*") BytePointer format,
    @ByVal @Cast("va_list*") Pointer va,
    @Cast("Py_ssize_t*") SizeTPointer p_nargs);
@NoException public static native @ByPtrPtr PyObject _Py_VaBuildStack_SizeT(
    @ByPtrPtr PyObject small_stack,
    @Cast("Py_ssize_t") long small_stack_len,
    @Cast("const char*") BytePointer format,
    @ByVal @Cast("va_list*") Pointer va,
    @Cast("Py_ssize_t*") SizeTPointer p_nargs);
@NoException public static native @ByPtrPtr PyObject _Py_VaBuildStack_SizeT(
    @ByPtrPtr PyObject small_stack,
    @Cast("Py_ssize_t") long small_stack_len,
    String format,
    @ByVal @Cast("va_list*") Pointer va,
    @Cast("Py_ssize_t*") SizeTPointer p_nargs);
// #endif /* !Py_LIMITED_API */
// #endif

/* Due to a glitch in 3.2, the _SizeT versions weren't exported from the DLL. */
// #if !defined(PY_SSIZE_T_CLEAN) || !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7, Pointer vararg8);
public static native int PyArg_Parse(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7, Pointer vararg8, Pointer vararg9);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7, Pointer vararg8);
public static native int PyArg_ParseTuple(PyObject arg0, String arg1, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7, Pointer vararg8, Pointer vararg9);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1, Pointer vararg2);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7, Pointer vararg8);
public static native int PyArg_ParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") PointerPointer arg3, Pointer vararg0, Pointer vararg1, Pointer vararg2, Pointer vararg3, Pointer vararg4, Pointer vararg5, Pointer vararg6, Pointer vararg7, Pointer vararg8, Pointer vararg9);
@NoException public static native int PyArg_VaParse(PyObject arg0, @Cast("const char*") BytePointer arg1, @ByVal @Cast("va_list*") Pointer arg2);
@NoException public static native int PyArg_VaParse(PyObject arg0, String arg1, @ByVal @Cast("va_list*") Pointer arg2);
@NoException public static native int PyArg_VaParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  @Cast("const char*") BytePointer arg2, @Cast("char**") PointerPointer arg3, @ByVal @Cast("va_list*") Pointer arg4);
@NoException public static native int PyArg_VaParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  @Cast("const char*") BytePointer arg2, @Cast("char**") @ByPtrPtr BytePointer arg3, @ByVal @Cast("va_list*") Pointer arg4);
@NoException public static native int PyArg_VaParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") @ByPtrPtr ByteBuffer arg3, @ByVal @Cast("va_list*") Pointer arg4);
@NoException public static native int PyArg_VaParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  @Cast("const char*") BytePointer arg2, @Cast("char**") @ByPtrPtr byte[] arg3, @ByVal @Cast("va_list*") Pointer arg4);
@NoException public static native int PyArg_VaParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") @ByPtrPtr BytePointer arg3, @ByVal @Cast("va_list*") Pointer arg4);
@NoException public static native int PyArg_VaParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  @Cast("const char*") BytePointer arg2, @Cast("char**") @ByPtrPtr ByteBuffer arg3, @ByVal @Cast("va_list*") Pointer arg4);
@NoException public static native int PyArg_VaParseTupleAndKeywords(PyObject arg0, PyObject arg1,
                                                  String arg2, @Cast("char**") @ByPtrPtr byte[] arg3, @ByVal @Cast("va_list*") Pointer arg4);
// #endif
@NoException public static native int PyArg_ValidateKeywordArguments(PyObject arg0);
@NoException public static native int PyArg_UnpackTuple(PyObject arg0, @Cast("const char*") BytePointer arg1, @Cast("Py_ssize_t") long arg2, @Cast("Py_ssize_t") long arg3);
@NoException public static native int PyArg_UnpackTuple(PyObject arg0, String arg1, @Cast("Py_ssize_t") long arg2, @Cast("Py_ssize_t") long arg3);
@NoException public static native PyObject Py_BuildValue(@Cast("const char*") BytePointer arg0);
@NoException public static native PyObject Py_BuildValue(String arg0);
@NoException public static native PyObject _Py_BuildValue_SizeT(@Cast("const char*") BytePointer arg0);
@NoException public static native PyObject _Py_BuildValue_SizeT(String arg0);


// #ifndef Py_LIMITED_API
@NoException public static native int _PyArg_UnpackStack(
    @Cast("PyObject*const*") PointerPointer args,
    @Cast("Py_ssize_t") long nargs,
    @Cast("const char*") BytePointer name,
    @Cast("Py_ssize_t") long min,
    @Cast("Py_ssize_t") long max);
@NoException public static native int _PyArg_UnpackStack(
    @ByPtrPtr PyObject args,
    @Cast("Py_ssize_t") long nargs,
    @Cast("const char*") BytePointer name,
    @Cast("Py_ssize_t") long min,
    @Cast("Py_ssize_t") long max);
@NoException public static native int _PyArg_UnpackStack(
    @ByPtrPtr PyObject args,
    @Cast("Py_ssize_t") long nargs,
    String name,
    @Cast("Py_ssize_t") long min,
    @Cast("Py_ssize_t") long max);

@NoException public static native int _PyArg_NoKeywords(@Cast("const char*") BytePointer funcname, PyObject kwargs);
@NoException public static native int _PyArg_NoKeywords(String funcname, PyObject kwargs);
@NoException public static native int _PyArg_NoKwnames(@Cast("const char*") BytePointer funcname, PyObject kwnames);
@NoException public static native int _PyArg_NoKwnames(String funcname, PyObject kwnames);
@NoException public static native int _PyArg_NoPositional(@Cast("const char*") BytePointer funcname, PyObject args);
@NoException public static native int _PyArg_NoPositional(String funcname, PyObject args);
// #define _PyArg_NoKeywords(funcname, kwargs)
//     ((kwargs) == NULL || _PyArg_NoKeywords((funcname), (kwargs)))
// #define _PyArg_NoKwnames(funcname, kwnames)
//     ((kwnames) == NULL || _PyArg_NoKwnames((funcname), (kwnames)))
// #define _PyArg_NoPositional(funcname, args)
//     ((args) == NULL || _PyArg_NoPositional((funcname), (args)))

@NoException public static native void _PyArg_BadArgument(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2, PyObject arg3);
@NoException public static native void _PyArg_BadArgument(String arg0, String arg1, String arg2, PyObject arg3);
@NoException public static native int _PyArg_CheckPositional(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1,
                                       @Cast("Py_ssize_t") long arg2, @Cast("Py_ssize_t") long arg3);
@NoException public static native int _PyArg_CheckPositional(String arg0, @Cast("Py_ssize_t") long arg1,
                                       @Cast("Py_ssize_t") long arg2, @Cast("Py_ssize_t") long arg3);
// #define _PyArg_CheckPositional(funcname, nargs, min, max)
//     (((min) <= (nargs) && (nargs) <= (max))
//      || _PyArg_CheckPositional((funcname), (nargs), (min), (max)))

// #endif

@NoException public static native PyObject Py_VaBuildValue(@Cast("const char*") BytePointer arg0, @ByVal @Cast("va_list*") Pointer arg1);
@NoException public static native PyObject Py_VaBuildValue(String arg0, @ByVal @Cast("va_list*") Pointer arg1);
// #ifndef Py_LIMITED_API
@NoException public static native @Cast("PyObject**") PointerPointer _Py_VaBuildStack(
    @Cast("PyObject**") PointerPointer small_stack,
    @Cast("Py_ssize_t") long small_stack_len,
    @Cast("const char*") BytePointer format,
    @ByVal @Cast("va_list*") Pointer va,
    @Cast("Py_ssize_t*") SizeTPointer p_nargs);
@NoException public static native @ByPtrPtr PyObject _Py_VaBuildStack(
    @ByPtrPtr PyObject small_stack,
    @Cast("Py_ssize_t") long small_stack_len,
    @Cast("const char*") BytePointer format,
    @ByVal @Cast("va_list*") Pointer va,
    @Cast("Py_ssize_t*") SizeTPointer p_nargs);
@NoException public static native @ByPtrPtr PyObject _Py_VaBuildStack(
    @ByPtrPtr PyObject small_stack,
    @Cast("Py_ssize_t") long small_stack_len,
    String format,
    @ByVal @Cast("va_list*") Pointer va,
    @Cast("Py_ssize_t*") SizeTPointer p_nargs);
// Targeting ../_PyArg_Parser.java


// #ifdef PY_SSIZE_T_CLEAN
// #endif
@NoException public static native int _PyArg_ParseTupleAndKeywordsFast(PyObject arg0, PyObject arg1,
                                                 _PyArg_Parser arg2);
@NoException public static native int _PyArg_ParseStack(
    @Cast("PyObject*const*") PointerPointer args,
    @Cast("Py_ssize_t") long nargs,
    @Cast("const char*") BytePointer format);
@NoException public static native int _PyArg_ParseStack(
    @ByPtrPtr PyObject args,
    @Cast("Py_ssize_t") long nargs,
    @Cast("const char*") BytePointer format);
@NoException public static native int _PyArg_ParseStack(
    @ByPtrPtr PyObject args,
    @Cast("Py_ssize_t") long nargs,
    String format);
@NoException public static native int _PyArg_ParseStackAndKeywords(
    @Cast("PyObject*const*") PointerPointer args,
    @Cast("Py_ssize_t") long nargs,
    PyObject kwnames,
    _PyArg_Parser arg3);
@NoException public static native int _PyArg_ParseStackAndKeywords(
    @ByPtrPtr PyObject args,
    @Cast("Py_ssize_t") long nargs,
    PyObject kwnames,
    _PyArg_Parser arg3);
@NoException public static native int _PyArg_VaParseTupleAndKeywordsFast(PyObject arg0, PyObject arg1,
                                                   _PyArg_Parser arg2, @ByVal @Cast("va_list*") Pointer arg3);
@NoException public static native @Cast("PyObject *const *") PointerPointer _PyArg_UnpackKeywords(
        @Cast("PyObject *const *") PointerPointer args, @Cast("Py_ssize_t") long nargs,
        PyObject kwargs, PyObject kwnames,
        _PyArg_Parser parser,
        int minpos, int maxpos, int minkw,
        @Cast("PyObject**") PointerPointer buf);


// #endif   /* Py_LIMITED_API */

// Add an attribute with name 'name' and value 'obj' to the module 'mod.
// On success, return 0 on success.
// On error, raise an exception and return -1.
@NoException public static native int PyModule_AddObjectRef(PyObject mod, @Cast("const char*") BytePointer name, PyObject value);
@NoException public static native int PyModule_AddObjectRef(PyObject mod, String name, PyObject value);

// Similar to PyModule_AddObjectRef() but steal a reference to 'obj'
// (Py_DECREF(obj)) on success (if it returns 0).
@NoException public static native int PyModule_AddObject(PyObject mod, @Cast("const char*") BytePointer arg1, PyObject value);
@NoException public static native int PyModule_AddObject(PyObject mod, String arg1, PyObject value);

@NoException public static native int PyModule_AddIntConstant(PyObject arg0, @Cast("const char*") BytePointer arg1, long arg2);
@NoException public static native int PyModule_AddIntConstant(PyObject arg0, String arg1, long arg2);
@NoException public static native int PyModule_AddStringConstant(PyObject arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2);
@NoException public static native int PyModule_AddStringConstant(PyObject arg0, String arg1, String arg2);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
/* New in 3.9 */
@NoException public static native int PyModule_AddType(PyObject module, PyTypeObject type);
// #endif /* Py_LIMITED_API */
// #define PyModule_AddIntMacro(m, c) PyModule_AddIntConstant(m, #c, c)
// #define PyModule_AddStringMacro(m, c) PyModule_AddStringConstant(m, #c, c)

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* New in 3.5 */
@NoException public static native int PyModule_SetDocString(PyObject arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native int PyModule_SetDocString(PyObject arg0, String arg1);
@NoException public static native int PyModule_AddFunctions(PyObject arg0, PyMethodDef arg1);
@NoException public static native int PyModule_ExecDef(PyObject module, PyModuleDef def);
// #endif

public static final int Py_CLEANUP_SUPPORTED = 0x20000;

public static final int PYTHON_API_VERSION = 1013;
public static final String PYTHON_API_STRING = "1013";
/* The API version is maintained (independently from the Python version)
   so we can detect mismatches between the interpreter and dynamically
   loaded modules.  These are diagnosed by an error message but
   the module is still loaded (because the mismatch can only be tested
   after loading the module).  The error message is intended to
   explain the core dump a few seconds later.

   The symbol PYTHON_API_STRING defines the same value as a string
   literal.  *** PLEASE MAKE SURE THE DEFINITIONS MATCH. ***

   Please add a line or two to the top of this log for each API
   version change:

   22-Feb-2006  MvL     1013    PEP 353 - long indices for sequence lengths

   19-Aug-2002  GvR     1012    Changes to string object struct for
                                interning changes, saving 3 bytes.

   17-Jul-2001  GvR     1011    Descr-branch, just to be on the safe side

   25-Jan-2001  FLD     1010    Parameters added to PyCode_New() and
                                PyFrame_New(); Python 2.1a2

   14-Mar-2000  GvR     1009    Unicode API added

   3-Jan-1999   GvR     1007    Decided to change back!  (Don't reuse 1008!)

   3-Dec-1998   GvR     1008    Python 1.5.2b1

   18-Jan-1997  GvR     1007    string interning and other speedups

   11-Oct-1996  GvR     renamed Py_Ellipses to Py_Ellipsis :-(

   30-Jul-1996  GvR     Slice and ellipses syntax added

   23-Jul-1996  GvR     For 1.4 -- better safe than sorry this time :-)

   7-Nov-1995   GvR     Keyword arguments (should've been done at 1.3 :-( )

   10-Jan-1995  GvR     Renamed globals to new naming scheme

   9-Jan-1995   GvR     Initial version (incompatible with older API)
*/

/* The PYTHON_ABI_VERSION is introduced in PEP 384. For the lifetime of
   Python 3, it will stay at the value of 3; changes to the limited API
   must be performed in a strictly backwards-compatible manner. */
public static final int PYTHON_ABI_VERSION = 3;
public static final String PYTHON_ABI_STRING = "3";

// #ifdef Py_TRACE_REFS
// #endif

@NoException public static native PyObject PyModule_Create2(PyModuleDef arg0,
                                     int apiver);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyModule_CreateInitialized(PyModuleDef arg0,
                                                   int apiver);
// #endif

// #ifdef Py_LIMITED_API
// #define PyModule_Create(module)
//         PyModule_Create2(module, PYTHON_ABI_VERSION)
// #else
// #define PyModule_Create(module)
//         PyModule_Create2(module, PYTHON_API_VERSION)
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* New in 3.5 */
@NoException public static native PyObject PyModule_FromDefAndSpec2(PyModuleDef def,
                                                PyObject spec,
                                                int module_api_version);

// #ifdef Py_LIMITED_API
// #define PyModule_FromDefAndSpec(module, spec)
//     PyModule_FromDefAndSpec2(module, spec, PYTHON_ABI_VERSION)
// #else
// #define PyModule_FromDefAndSpec(module, spec)
//     PyModule_FromDefAndSpec2(module, spec, PYTHON_API_VERSION)
// #endif /* Py_LIMITED_API */
// #endif /* New in 3.5 */

// #ifndef Py_LIMITED_API
public static native @Cast("const char*") BytePointer _Py_PackageContext(); public static native void _Py_PackageContext(BytePointer setter);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_MODSUPPORT_H */


// Parsed from ceval.h

// #ifndef Py_CEVAL_H
// #define Py_CEVAL_H
// #ifdef __cplusplus
// #endif


/* Interface to random parts in ceval.c */

/* PyEval_CallObjectWithKeywords(), PyEval_CallObject(), PyEval_CallFunction
 * and PyEval_CallMethod are deprecated. Since they are officially part of the
 * stable ABI (PEP 384), they must be kept for backward compatibility.
 * PyObject_Call(), PyObject_CallFunction() and PyObject_CallMethod() are
 * recommended to call a callable object.
 */

@NoException public static native @Deprecated PyObject PyEval_CallObjectWithKeywords(
    PyObject callable,
    PyObject args,
    PyObject kwargs);

/* Deprecated since PyEval_CallObjectWithKeywords is deprecated */
// #define PyEval_CallObject(callable, arg)
//     PyEval_CallObjectWithKeywords(callable, arg, (PyObject *)NULL)

@NoException public static native @Deprecated PyObject PyEval_CallFunction(
    PyObject callable, @Cast("const char*") BytePointer format);
@NoException public static native @Deprecated PyObject PyEval_CallFunction(
    PyObject callable, String format);
@NoException public static native @Deprecated PyObject PyEval_CallMethod(
    PyObject obj, @Cast("const char*") BytePointer name, @Cast("const char*") BytePointer format);
@NoException public static native @Deprecated PyObject PyEval_CallMethod(
    PyObject obj, String name, String format);

@NoException public static native PyObject PyEval_GetBuiltins();
@NoException public static native PyObject PyEval_GetGlobals();
@NoException public static native PyObject PyEval_GetLocals();
@NoException public static native PyFrameObject PyEval_GetFrame();
// Targeting ../Func_Pointer.java


@NoException public static native int Py_AddPendingCall(Func_Pointer func, Pointer arg);
@NoException public static native int Py_MakePendingCalls();

/* Protection against deeply nested recursive calls

   In Python 3.0, this protection has two levels:
   * normal anti-recursion protection is triggered when the recursion level
     exceeds the current recursion limit. It raises a RecursionError, and sets
     the "overflowed" flag in the thread state structure. This flag
     temporarily *disables* the normal protection; this allows cleanup code
     to potentially outgrow the recursion limit while processing the
     RecursionError.
   * "last chance" anti-recursion protection is triggered when the recursion
     level exceeds "current recursion limit + 50". By construction, this
     protection can only be triggered when the "overflowed" flag is set. It
     means the cleanup code has itself gone into an infinite loop, or the
     RecursionError has been mistakingly ignored. When this protection is
     triggered, the interpreter aborts with a Fatal Error.

   In addition, the "overflowed" flag is automatically reset when the
   recursion level drops below "current recursion limit - 50". This heuristic
   is meant to ensure that the normal anti-recursion protection doesn't get
   disabled too long.

   Please note: this scheme has its own limitations. See:
   http://mail.python.org/pipermail/python-dev/2008-August/082106.html
   for some observations.
*/
@NoException public static native void Py_SetRecursionLimit(int arg0);
@NoException public static native int Py_GetRecursionLimit();

@NoException public static native int Py_EnterRecursiveCall(@Cast("const char*") BytePointer where);
@NoException public static native int Py_EnterRecursiveCall(String where);
@NoException public static native void Py_LeaveRecursiveCall();

@NoException public static native @Cast("const char*") BytePointer PyEval_GetFuncName(PyObject arg0);
@NoException public static native @Cast("const char*") BytePointer PyEval_GetFuncDesc(PyObject arg0);

@NoException public static native PyObject PyEval_EvalFrame(PyFrameObject arg0);
@NoException public static native PyObject PyEval_EvalFrameEx(PyFrameObject f, int exc);

/* Interface for threads.

   A module that plans to do a blocking system call (or something else
   that lasts a long time and doesn't touch Python data) can allow other
   threads to run as follows:

    ...preparations here...
    Py_BEGIN_ALLOW_THREADS
    ...blocking system call here...
    Py_END_ALLOW_THREADS
    ...interpret result here...

   The Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS pair expands to a
   {}-surrounded block.
   To leave the block in the middle (e.g., with return), you must insert
   a line containing Py_BLOCK_THREADS before the return, e.g.

    if (...premature_exit...) {
        Py_BLOCK_THREADS
        PyErr_SetFromErrno(PyExc_OSError);
        return NULL;
    }

   An alternative is:

    Py_BLOCK_THREADS
    if (...premature_exit...) {
        PyErr_SetFromErrno(PyExc_OSError);
        return NULL;
    }
    Py_UNBLOCK_THREADS

   For convenience, that the value of 'errno' is restored across
   Py_END_ALLOW_THREADS and Py_BLOCK_THREADS.

   WARNING: NEVER NEST CALLS TO Py_BEGIN_ALLOW_THREADS AND
   Py_END_ALLOW_THREADS!!!

   Note that not yet all candidates have been converted to use this
   mechanism!
*/

@NoException public static native PyThreadState PyEval_SaveThread();
@NoException public static native void PyEval_RestoreThread(PyThreadState arg0);

@NoException public static native @Deprecated int PyEval_ThreadsInitialized();
@NoException public static native @Deprecated void PyEval_InitThreads();
/* PyEval_AcquireLock() and PyEval_ReleaseLock() are part of stable ABI.
 * They will be removed from this header file in the future version.
 * But they will be remained in ABI until Python 4.0.
 */
@NoException public static native @Deprecated void PyEval_AcquireLock();
@NoException public static native @Deprecated void PyEval_ReleaseLock();
@NoException public static native void PyEval_AcquireThread(PyThreadState tstate);
@NoException public static native void PyEval_ReleaseThread(PyThreadState tstate);

// #define Py_BEGIN_ALLOW_THREADS {
//                         PyThreadState *_save;
//                         _save = PyEval_SaveThread();
// #define Py_BLOCK_THREADS        PyEval_RestoreThread(_save);
// #define Py_UNBLOCK_THREADS      _save = PyEval_SaveThread();
// #define Py_END_ALLOW_THREADS    PyEval_RestoreThread(_save);
//                  }

/* Masks and values used by FORMAT_VALUE opcode. */
public static final int FVC_MASK =      0x3;
public static final int FVC_NONE =      0x0;
public static final int FVC_STR =       0x1;
public static final int FVC_REPR =      0x2;
public static final int FVC_ASCII =     0x3;
public static final int FVS_MASK =      0x4;
public static final int FVS_HAVE_SPEC = 0x4;

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_CEVAL_H
// #  include  "cpython/ceval.h"
// #  undef Py_CPYTHON_CEVAL_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_CEVAL_H */


// Parsed from cpython/ceval.h

// #ifndef Py_CPYTHON_CEVAL_H
// #  error "this header file must not be included directly"
// #endif

@NoException public static native void PyEval_SetProfile(Py_tracefunc arg0, PyObject arg1);
@NoException public static native int _PyEval_SetProfile(PyThreadState tstate, Py_tracefunc func, PyObject arg);
@NoException public static native void PyEval_SetTrace(Py_tracefunc arg0, PyObject arg1);
@NoException public static native int _PyEval_SetTrace(PyThreadState tstate, Py_tracefunc func, PyObject arg);
@NoException public static native int _PyEval_GetCoroutineOriginTrackingDepth();
@NoException public static native int _PyEval_SetAsyncGenFirstiter(PyObject arg0);
@NoException public static native PyObject _PyEval_GetAsyncGenFirstiter();
@NoException public static native int _PyEval_SetAsyncGenFinalizer(PyObject arg0);
@NoException public static native PyObject _PyEval_GetAsyncGenFinalizer();

/* Helper to look up a builtin object */
@NoException public static native PyObject _PyEval_GetBuiltinId(_Py_Identifier arg0);
/* Look at the current frame's (if any) code's co_flags, and turn on
   the corresponding compiler flags in cf->cf_flags.  Return 1 if any
   flag was set, else return 0. */
@NoException public static native int PyEval_MergeCompilerFlags(PyCompilerFlags cf);

@NoException public static native PyObject _PyEval_EvalFrameDefault(PyThreadState tstate, PyFrameObject f, int exc);

@NoException public static native void _PyEval_SetSwitchInterval(@Cast("unsigned long") long microseconds);
@NoException public static native @Cast("unsigned long") long _PyEval_GetSwitchInterval();

@NoException public static native @Cast("Py_ssize_t") long _PyEval_RequestCodeExtraIndex(freefunc arg0);

@NoException public static native int _PyEval_SliceIndex(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);
@NoException public static native int _PyEval_SliceIndexNotNone(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);


// Parsed from sysmodule.h


/* System module interface */

// #ifndef Py_SYSMODULE_H
// #define Py_SYSMODULE_H
// #ifdef __cplusplus
// #endif

@NoException public static native PyObject PySys_GetObject(@Cast("const char*") BytePointer arg0);
@NoException public static native PyObject PySys_GetObject(String arg0);
@NoException public static native int PySys_SetObject(@Cast("const char*") BytePointer arg0, PyObject arg1);
@NoException public static native int PySys_SetObject(String arg0, PyObject arg1);

@NoException public static native void PySys_SetArgv(int arg0, @Cast("wchar_t**") PointerPointer arg1);
@NoException public static native void PySys_SetArgv(int arg0, @Cast("wchar_t**") @ByPtrPtr Pointer arg1);
@NoException public static native void PySys_SetArgvEx(int arg0, @Cast("wchar_t**") PointerPointer arg1, int arg2);
@NoException public static native void PySys_SetArgvEx(int arg0, @Cast("wchar_t**") @ByPtrPtr Pointer arg1, int arg2);
@NoException public static native void PySys_SetPath(@Cast("const wchar_t*") Pointer arg0);

@NoException public static native void PySys_WriteStdout(@Cast("const char*") BytePointer format);
@NoException public static native void PySys_WriteStdout(String format);
@NoException public static native void PySys_WriteStderr(@Cast("const char*") BytePointer format);
@NoException public static native void PySys_WriteStderr(String format);
@NoException public static native void PySys_FormatStdout(@Cast("const char*") BytePointer format);
@NoException public static native void PySys_FormatStdout(String format);
@NoException public static native void PySys_FormatStderr(@Cast("const char*") BytePointer format);
@NoException public static native void PySys_FormatStderr(String format);

@NoException public static native void PySys_ResetWarnOptions();
@NoException public static native void PySys_AddWarnOption(@Cast("const wchar_t*") Pointer arg0);
@NoException public static native void PySys_AddWarnOptionUnicode(PyObject arg0);
@NoException public static native int PySys_HasWarnOptions();

@NoException public static native void PySys_AddXOption(@Cast("const wchar_t*") Pointer arg0);
@NoException public static native PyObject PySys_GetXOptions();

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_SYSMODULE_H
// #  include  "cpython/sysmodule.h"
// #  undef Py_CPYTHON_SYSMODULE_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_SYSMODULE_H */


// Parsed from cpython/sysmodule.h

// #ifndef Py_CPYTHON_SYSMODULE_H
// #  error "this header file must not be included directly"
// #endif

@NoException public static native PyObject _PySys_GetObjectId(_Py_Identifier key);
@NoException public static native int _PySys_SetObjectId(_Py_Identifier key, PyObject arg1);

@NoException public static native @Cast("size_t") long _PySys_GetSizeOf(PyObject arg0);
// Targeting ../Py_AuditHookFunction.java



@NoException public static native int PySys_Audit(
    @Cast("const char*") BytePointer event,
    @Cast("const char*") BytePointer argFormat);
@NoException public static native int PySys_Audit(
    String event,
    String argFormat);
@NoException public static native int PySys_AddAuditHook(Py_AuditHookFunction arg0, Pointer arg1);


// Parsed from osmodule.h


/* os module interface */

// #ifndef Py_OSMODULE_H
// #define Py_OSMODULE_H
// #ifdef __cplusplus
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
@NoException public static native PyObject PyOS_FSPath(PyObject path);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_OSMODULE_H */


// Parsed from intrcheck.h

// #ifndef Py_INTRCHECK_H
// #define Py_INTRCHECK_H
// #ifdef __cplusplus
// #endif

@NoException public static native int PyOS_InterruptOccurred();
// #ifdef HAVE_FORK
// #endif
/* Deprecated, please use PyOS_AfterFork_Child() instead */
@NoException public static native @Deprecated void PyOS_AfterFork();

// #ifndef Py_LIMITED_API
@NoException public static native int _PyOS_IsMainThread();

// #ifdef MS_WINDOWS
// #endif
// #endif /* !Py_LIMITED_API */

// #ifdef __cplusplus
// #endif
// #endif /* !Py_INTRCHECK_H */


// Parsed from import.h

/* Module definition and import interface */

// #ifndef Py_IMPORT_H
// #define Py_IMPORT_H
// #ifdef __cplusplus
// #endif

@NoException public static native long PyImport_GetMagicNumber();
@NoException public static native @Cast("const char*") BytePointer PyImport_GetMagicTag();
@NoException public static native PyObject PyImport_ExecCodeModule(
    @Cast("const char*") BytePointer name,
    PyObject co
    );
@NoException public static native PyObject PyImport_ExecCodeModule(
    String name,
    PyObject co
    );
@NoException public static native PyObject PyImport_ExecCodeModuleEx(
    @Cast("const char*") BytePointer name,
    PyObject co,
    @Cast("const char*") BytePointer pathname
    );
@NoException public static native PyObject PyImport_ExecCodeModuleEx(
    String name,
    PyObject co,
    String pathname
    );
@NoException public static native PyObject PyImport_ExecCodeModuleWithPathnames(
    @Cast("const char*") BytePointer name,
    PyObject co,
    @Cast("const char*") BytePointer pathname,
    @Cast("const char*") BytePointer cpathname
    );
@NoException public static native PyObject PyImport_ExecCodeModuleWithPathnames(
    String name,
    PyObject co,
    String pathname,
    String cpathname
    );
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyImport_ExecCodeModuleObject(
    PyObject name,
    PyObject co,
    PyObject pathname,
    PyObject cpathname
    );
// #endif
@NoException public static native PyObject PyImport_GetModuleDict();
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03070000
@NoException public static native PyObject PyImport_GetModule(PyObject name);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyImport_AddModuleObject(
    PyObject name
    );
// #endif
@NoException public static native PyObject PyImport_AddModule(
    @Cast("const char*") BytePointer name
    );
@NoException public static native PyObject PyImport_AddModule(
    String name
    );
@NoException public static native PyObject PyImport_ImportModule(
    @Cast("const char*") BytePointer name
    );
@NoException public static native PyObject PyImport_ImportModule(
    String name
    );
@NoException public static native PyObject PyImport_ImportModuleNoBlock(
    @Cast("const char*") BytePointer name
    );
@NoException public static native PyObject PyImport_ImportModuleNoBlock(
    String name
    );
@NoException public static native PyObject PyImport_ImportModuleLevel(
    @Cast("const char*") BytePointer name,
    PyObject globals,
    PyObject locals,
    PyObject fromlist,
    int level
    );
@NoException public static native PyObject PyImport_ImportModuleLevel(
    String name,
    PyObject globals,
    PyObject locals,
    PyObject fromlist,
    int level
    );
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
@NoException public static native PyObject PyImport_ImportModuleLevelObject(
    PyObject name,
    PyObject globals,
    PyObject locals,
    PyObject fromlist,
    int level
    );
// #endif

// #define PyImport_ImportModuleEx(n, g, l, f)
//     PyImport_ImportModuleLevel(n, g, l, f, 0)

@NoException public static native PyObject PyImport_GetImporter(PyObject path);
@NoException public static native PyObject PyImport_Import(PyObject name);
@NoException public static native PyObject PyImport_ReloadModule(PyObject m);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native int PyImport_ImportFrozenModuleObject(
    PyObject name
    );
// #endif
@NoException public static native int PyImport_ImportFrozenModule(
    @Cast("const char*") BytePointer name
    );
@NoException public static native int PyImport_ImportFrozenModule(
    String name
    );
// Targeting ../PyObject_Initfunc.java


@NoException public static native int PyImport_AppendInittab(
    @Cast("const char*") BytePointer name,
    PyObject_Initfunc initfunc
    );
@NoException public static native int PyImport_AppendInittab(
    String name,
    PyObject_Initfunc initfunc
    );

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_IMPORT_H
// #  include  "cpython/import.h"
// #  undef Py_CPYTHON_IMPORT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_IMPORT_H */


// Parsed from cpython/import.h

// #ifndef Py_CPYTHON_IMPORT_H
// #  error "this header file must not be included directly"
// #endif



@NoException public static native int _PyImport_IsInitialized(PyInterpreterState arg0);

@NoException public static native PyObject _PyImport_GetModuleId(_Py_Identifier name);
@NoException public static native int _PyImport_SetModule(PyObject name, PyObject module);
@NoException public static native int _PyImport_SetModuleString(@Cast("const char*") BytePointer name, PyObject module);
@NoException public static native int _PyImport_SetModuleString(String name, PyObject module);

@NoException public static native void _PyImport_AcquireLock();
@NoException public static native int _PyImport_ReleaseLock();

/* Obsolete since 3.5, will be removed in 3.11. */
@NoException public static native @Deprecated PyObject _PyImport_FindExtensionObject(PyObject arg0, PyObject arg1);

@NoException public static native int _PyImport_FixupBuiltin(
    PyObject mod,
    @Cast("const char*") BytePointer name,
    PyObject modules
    );
@NoException public static native int _PyImport_FixupBuiltin(
    PyObject mod,
    String name,
    PyObject modules
    );
@NoException public static native int _PyImport_FixupExtensionObject(PyObject arg0, PyObject arg1,
                                               PyObject arg2, PyObject arg3);
// Targeting ../_inittab.java


public static native _inittab PyImport_Inittab(); public static native void PyImport_Inittab(_inittab setter);
@NoException public static native int PyImport_ExtendInittab(_inittab newtab);
// Targeting ../_frozen.java



/* Embedding apps may change this pointer to point to their favorite
   collection of frozen modules: */

public static native @Const _frozen PyImport_FrozenModules(); public static native void PyImport_FrozenModules(_frozen setter);


// Parsed from abstract.h

/* Abstract Object Interface (many thanks to Jim Fulton) */

// #ifndef Py_ABSTRACTOBJECT_H
// #define Py_ABSTRACTOBJECT_H
// #ifdef __cplusplus
// #endif

/* === Object Protocol ================================================== */

/* Implemented elsewhere:

   int PyObject_Print(PyObject *o, FILE *fp, int flags);

   Print an object 'o' on file 'fp'.  Returns -1 on error. The flags argument
   is used to enable certain printing options. The only option currently
   supported is Py_Print_RAW.

   (What should be said about Py_Print_RAW?). */


/* Implemented elsewhere:

   int PyObject_HasAttrString(PyObject *o, const char *attr_name);

   Returns 1 if object 'o' has the attribute attr_name, and 0 otherwise.

   This is equivalent to the Python expression: hasattr(o,attr_name).

   This function always succeeds. */


/* Implemented elsewhere:

   PyObject* PyObject_GetAttrString(PyObject *o, const char *attr_name);

   Retrieve an attributed named attr_name form object o.
   Returns the attribute value on success, or NULL on failure.

   This is the equivalent of the Python expression: o.attr_name. */


/* Implemented elsewhere:

   int PyObject_HasAttr(PyObject *o, PyObject *attr_name);

   Returns 1 if o has the attribute attr_name, and 0 otherwise.

   This is equivalent to the Python expression: hasattr(o,attr_name).

   This function always succeeds. */

/* Implemented elsewhere:

   PyObject* PyObject_GetAttr(PyObject *o, PyObject *attr_name);

   Retrieve an attributed named 'attr_name' form object 'o'.
   Returns the attribute value on success, or NULL on failure.

   This is the equivalent of the Python expression: o.attr_name. */


/* Implemented elsewhere:

   int PyObject_SetAttrString(PyObject *o, const char *attr_name, PyObject *v);

   Set the value of the attribute named attr_name, for object 'o',
   to the value 'v'. Raise an exception and return -1 on failure; return 0 on
   success.

   This is the equivalent of the Python statement o.attr_name=v. */


/* Implemented elsewhere:

   int PyObject_SetAttr(PyObject *o, PyObject *attr_name, PyObject *v);

   Set the value of the attribute named attr_name, for object 'o', to the value
   'v'. an exception and return -1 on failure; return 0 on success.

   This is the equivalent of the Python statement o.attr_name=v. */

/* Implemented as a macro:

   int PyObject_DelAttrString(PyObject *o, const char *attr_name);

   Delete attribute named attr_name, for object o. Returns
   -1 on failure.

   This is the equivalent of the Python statement: del o.attr_name. */
// #define PyObject_DelAttrString(O,A) PyObject_SetAttrString((O),(A), NULL)


/* Implemented as a macro:

   int PyObject_DelAttr(PyObject *o, PyObject *attr_name);

   Delete attribute named attr_name, for object o. Returns -1
   on failure.  This is the equivalent of the Python
   statement: del o.attr_name. */
// #define  PyObject_DelAttr(O,A) PyObject_SetAttr((O),(A), NULL)


/* Implemented elsewhere:

   PyObject *PyObject_Repr(PyObject *o);

   Compute the string representation of object 'o'.  Returns the
   string representation on success, NULL on failure.

   This is the equivalent of the Python expression: repr(o).

   Called by the repr() built-in function. */


/* Implemented elsewhere:

   PyObject *PyObject_Str(PyObject *o);

   Compute the string representation of object, o.  Returns the
   string representation on success, NULL on failure.

   This is the equivalent of the Python expression: str(o).

   Called by the str() and print() built-in functions. */


/* Declared elsewhere

   PyAPI_FUNC(int) PyCallable_Check(PyObject *o);

   Determine if the object, o, is callable.  Return 1 if the object is callable
   and 0 otherwise.

   This function always succeeds. */


// #ifdef PY_SSIZE_T_CLEAN
// #endif


// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03090000
/* Call a callable Python object without any arguments */
@NoException public static native PyObject PyObject_CallNoArgs(PyObject func);
// #endif


/* Call a callable Python object 'callable' with arguments given by the
   tuple 'args' and keywords arguments given by the dictionary 'kwargs'.

   'args' must not be NULL, use an empty tuple if no arguments are
   needed. If no named arguments are needed, 'kwargs' can be NULL.

   This is the equivalent of the Python expression:
   callable(*args, **kwargs). */
@NoException public static native PyObject PyObject_Call(PyObject callable,
                                     PyObject args, PyObject kwargs);


/* Call a callable Python object 'callable', with arguments given by the
   tuple 'args'.  If no arguments are needed, then 'args' can be NULL.

   Returns the result of the call on success, or NULL on failure.

   This is the equivalent of the Python expression:
   callable(*args). */
@NoException public static native PyObject PyObject_CallObject(PyObject callable,
                                           PyObject args);

/* Call a callable Python object, callable, with a variable number of C
   arguments. The C arguments are described using a mkvalue-style format
   string.

   The format may be NULL, indicating that no arguments are provided.

   Returns the result of the call on success, or NULL on failure.

   This is the equivalent of the Python expression:
   callable(arg1, arg2, ...). */
@NoException public static native PyObject PyObject_CallFunction(PyObject callable,
                                             @Cast("const char*") BytePointer format);
@NoException public static native PyObject PyObject_CallFunction(PyObject callable,
                                             String format);

/* Call the method named 'name' of object 'obj' with a variable number of
   C arguments.  The C arguments are described by a mkvalue format string.

   The format can be NULL, indicating that no arguments are provided.

   Returns the result of the call on success, or NULL on failure.

   This is the equivalent of the Python expression:
   obj.name(arg1, arg2, ...). */
@NoException public static native PyObject PyObject_CallMethod(PyObject obj,
                                           @Cast("const char*") BytePointer name,
                                           @Cast("const char*") BytePointer format);
@NoException public static native PyObject PyObject_CallMethod(PyObject obj,
                                           String name,
                                           String format);

@NoException public static native PyObject _PyObject_CallFunction_SizeT(PyObject callable,
                                                    @Cast("const char*") BytePointer format);
@NoException public static native PyObject _PyObject_CallFunction_SizeT(PyObject callable,
                                                    String format);

@NoException public static native PyObject _PyObject_CallMethod_SizeT(PyObject obj,
                                                  @Cast("const char*") BytePointer name,
                                                  @Cast("const char*") BytePointer format);
@NoException public static native PyObject _PyObject_CallMethod_SizeT(PyObject obj,
                                                  String name,
                                                  String format);

/* Call a callable Python object 'callable' with a variable number of C
   arguments. The C arguments are provided as PyObject* values, terminated
   by a NULL.

   Returns the result of the call on success, or NULL on failure.

   This is the equivalent of the Python expression:
   callable(arg1, arg2, ...). */
@NoException public static native PyObject PyObject_CallFunctionObjArgs(PyObject callable);

/* Call the method named 'name' of object 'obj' with a variable number of
   C arguments.  The C arguments are provided as PyObject* values, terminated
   by NULL.

   Returns the result of the call on success, or NULL on failure.

   This is the equivalent of the Python expression: obj.name(*args). */

@NoException public static native PyObject PyObject_CallMethodObjArgs(
    PyObject obj,
    PyObject name);


/* Implemented elsewhere:

   Py_hash_t PyObject_Hash(PyObject *o);

   Compute and return the hash, hash_value, of an object, o.  On
   failure, return -1.

   This is the equivalent of the Python expression: hash(o). */


/* Implemented elsewhere:

   int PyObject_IsTrue(PyObject *o);

   Returns 1 if the object, o, is considered to be true, 0 if o is
   considered to be false and -1 on failure.

   This is equivalent to the Python expression: not not o. */


/* Implemented elsewhere:

   int PyObject_Not(PyObject *o);

   Returns 0 if the object, o, is considered to be true, 1 if o is
   considered to be false and -1 on failure.

   This is equivalent to the Python expression: not o. */


/* Get the type of an object.

   On success, returns a type object corresponding to the object type of object
   'o'. On failure, returns NULL.

   This is equivalent to the Python expression: type(o) */
@NoException public static native PyObject PyObject_Type(PyObject o);


/* Return the size of object 'o'.  If the object 'o' provides both sequence and
   mapping protocols, the sequence size is returned.

   On error, -1 is returned.

   This is the equivalent to the Python expression: len(o) */
@NoException public static native @Cast("Py_ssize_t") long PyObject_Size(PyObject o);


/* For DLL compatibility */
// #undef PyObject_Length
// #define PyObject_Length PyObject_Size

/* Return element of 'o' corresponding to the object 'key'. Return NULL
  on failure.

  This is the equivalent of the Python expression: o[key] */
@NoException public static native PyObject PyObject_GetItem(PyObject o, PyObject key);


/* Map the object 'key' to the value 'v' into 'o'.

   Raise an exception and return -1 on failure; return 0 on success.

   This is the equivalent of the Python statement: o[key]=v. */
@NoException public static native int PyObject_SetItem(PyObject o, PyObject key, PyObject v);

/* Remove the mapping for the string 'key' from the object 'o'.
   Returns -1 on failure.

   This is equivalent to the Python statement: del o[key]. */
@NoException public static native int PyObject_DelItemString(PyObject o, @Cast("const char*") BytePointer key);
@NoException public static native int PyObject_DelItemString(PyObject o, String key);

/* Delete the mapping for the object 'key' from the object 'o'.
   Returns -1 on failure.

   This is the equivalent of the Python statement: del o[key]. */
@NoException public static native int PyObject_DelItem(PyObject o, PyObject key);


/* === Old Buffer API ============================================ */

/* FIXME:  usage of these should all be replaced in Python itself
   but for backwards compatibility we will implement them.
   Their usage without a corresponding "unlock" mechanism
   may create issues (but they would already be there). */

/* Takes an arbitrary object which must support the (character, single segment)
   buffer interface and returns a pointer to a read-only memory location
   usable as character based input for subsequent processing.

   Return 0 on success.  buffer and buffer_len are only set in case no error
   occurs. Otherwise, -1 is returned and an exception set. */
@NoException public static native @Deprecated int PyObject_AsCharBuffer(PyObject obj,
                                      @Cast("const char**") PointerPointer buffer,
                                      @Cast("Py_ssize_t*") SizeTPointer buffer_len);
@NoException public static native @Deprecated int PyObject_AsCharBuffer(PyObject obj,
                                      @Cast("const char**") @ByPtrPtr BytePointer buffer,
                                      @Cast("Py_ssize_t*") SizeTPointer buffer_len);
@NoException public static native @Deprecated int PyObject_AsCharBuffer(PyObject obj,
                                      @Cast("const char**") @ByPtrPtr ByteBuffer buffer,
                                      @Cast("Py_ssize_t*") SizeTPointer buffer_len);
@NoException public static native @Deprecated int PyObject_AsCharBuffer(PyObject obj,
                                      @Cast("const char**") @ByPtrPtr byte[] buffer,
                                      @Cast("Py_ssize_t*") SizeTPointer buffer_len);

/* Checks whether an arbitrary object supports the (character, single segment)
   buffer interface.

   Returns 1 on success, 0 on failure. */
@NoException public static native @Deprecated int PyObject_CheckReadBuffer(PyObject obj);

/* Same as PyObject_AsCharBuffer() except that this API expects (readable,
   single segment) buffer interface and returns a pointer to a read-only memory
   location which can contain arbitrary data.

   0 is returned on success.  buffer and buffer_len are only set in case no
   error occurs.  Otherwise, -1 is returned and an exception set. */
@NoException public static native @Deprecated int PyObject_AsReadBuffer(PyObject obj,
                                      @Cast("const void**") PointerPointer buffer,
                                      @Cast("Py_ssize_t*") SizeTPointer buffer_len);
@NoException public static native @Deprecated int PyObject_AsReadBuffer(PyObject obj,
                                      @Cast("const void**") @ByPtrPtr Pointer buffer,
                                      @Cast("Py_ssize_t*") SizeTPointer buffer_len);

/* Takes an arbitrary object which must support the (writable, single segment)
   buffer interface and returns a pointer to a writable memory location in
   buffer of size 'buffer_len'.

   Return 0 on success.  buffer and buffer_len are only set in case no error
   occurs. Otherwise, -1 is returned and an exception set. */
@NoException public static native @Deprecated int PyObject_AsWriteBuffer(PyObject obj,
                                       @Cast("void**") PointerPointer buffer,
                                       @Cast("Py_ssize_t*") SizeTPointer buffer_len);
@NoException public static native @Deprecated int PyObject_AsWriteBuffer(PyObject obj,
                                       @Cast("void**") @ByPtrPtr Pointer buffer,
                                       @Cast("Py_ssize_t*") SizeTPointer buffer_len);


/* === New Buffer API ============================================ */

/* Takes an arbitrary object and returns the result of calling
   obj.__format__(format_spec). */
@NoException public static native PyObject PyObject_Format(PyObject obj,
                                       PyObject format_spec);


/* ==== Iterators ================================================ */

/* Takes an object and returns an iterator for it.
   This is typically a new iterator but if the argument is an iterator, this
   returns itself. */
@NoException public static native PyObject PyObject_GetIter(PyObject arg0);

/* Takes an AsyncIterable object and returns an AsyncIterator for it.
   This is typically a new iterator but if the argument is an AsyncIterator,
   this returns itself. */
@NoException public static native PyObject PyObject_GetAIter(PyObject arg0);

/* Returns non-zero if the object 'obj' provides iterator protocols, and 0 otherwise.

   This function always succeeds. */
@NoException public static native int PyIter_Check(PyObject arg0);

/* Returns non-zero if the object 'obj' provides AsyncIterator protocols, and 0 otherwise.

   This function always succeeds. */
@NoException public static native int PyAIter_Check(PyObject arg0);

/* Takes an iterator object and calls its tp_iternext slot,
   returning the next value.

   If the iterator is exhausted, this returns NULL without setting an
   exception.

   NULL with an exception means an error occurred. */
@NoException public static native PyObject PyIter_Next(PyObject arg0);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030A0000

/* Takes generator, coroutine or iterator object and sends the value into it.
   Returns:
   - PYGEN_RETURN (0) if generator has returned.
     'result' parameter is filled with return value
   - PYGEN_ERROR (-1) if exception was raised.
     'result' parameter is NULL
   - PYGEN_NEXT (1) if generator has yielded.
     'result' parameter is filled with yielded value. */
@NoException public static native @Cast("PySendResult") int PyIter_Send(PyObject arg0, PyObject arg1, @Cast("PyObject**") PointerPointer arg2);
@NoException public static native @Cast("PySendResult") int PyIter_Send(PyObject arg0, PyObject arg1, @ByPtrPtr PyObject arg2);
// #endif


/* === Number Protocol ================================================== */

/* Returns 1 if the object 'o' provides numeric protocols, and 0 otherwise.

   This function always succeeds. */
@NoException public static native int PyNumber_Check(PyObject o);

/* Returns the result of adding o1 and o2, or NULL on failure.

   This is the equivalent of the Python expression: o1 + o2. */
@NoException public static native PyObject PyNumber_Add(PyObject o1, PyObject o2);

/* Returns the result of subtracting o2 from o1, or NULL on failure.

   This is the equivalent of the Python expression: o1 - o2. */
@NoException public static native PyObject PyNumber_Subtract(PyObject o1, PyObject o2);

/* Returns the result of multiplying o1 and o2, or NULL on failure.

   This is the equivalent of the Python expression: o1 * o2. */
@NoException public static native PyObject PyNumber_Multiply(PyObject o1, PyObject o2);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* This is the equivalent of the Python expression: o1 @ o2. */
@NoException public static native PyObject PyNumber_MatrixMultiply(PyObject o1, PyObject o2);
// #endif

/* Returns the result of dividing o1 by o2 giving an integral result,
   or NULL on failure.

   This is the equivalent of the Python expression: o1 // o2. */
@NoException public static native PyObject PyNumber_FloorDivide(PyObject o1, PyObject o2);

/* Returns the result of dividing o1 by o2 giving a float result, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 / o2. */
@NoException public static native PyObject PyNumber_TrueDivide(PyObject o1, PyObject o2);

/* Returns the remainder of dividing o1 by o2, or NULL on failure.

   This is the equivalent of the Python expression: o1 % o2. */
@NoException public static native PyObject PyNumber_Remainder(PyObject o1, PyObject o2);

/* See the built-in function divmod.

   Returns NULL on failure.

   This is the equivalent of the Python expression: divmod(o1, o2). */
@NoException public static native PyObject PyNumber_Divmod(PyObject o1, PyObject o2);

/* See the built-in function pow. Returns NULL on failure.

   This is the equivalent of the Python expression: pow(o1, o2, o3),
   where o3 is optional. */
@NoException public static native PyObject PyNumber_Power(PyObject o1, PyObject o2,
                                      PyObject o3);

/* Returns the negation of o on success, or NULL on failure.

 This is the equivalent of the Python expression: -o. */
@NoException public static native PyObject PyNumber_Negative(PyObject o);

/* Returns the positive of o on success, or NULL on failure.

   This is the equivalent of the Python expression: +o. */
@NoException public static native PyObject PyNumber_Positive(PyObject o);

/* Returns the absolute value of 'o', or NULL on failure.

   This is the equivalent of the Python expression: abs(o). */
@NoException public static native PyObject PyNumber_Absolute(PyObject o);

/* Returns the bitwise negation of 'o' on success, or NULL on failure.

   This is the equivalent of the Python expression: ~o. */
@NoException public static native PyObject PyNumber_Invert(PyObject o);

/* Returns the result of left shifting o1 by o2 on success, or NULL on failure.

   This is the equivalent of the Python expression: o1 << o2. */
@NoException public static native PyObject PyNumber_Lshift(PyObject o1, PyObject o2);

/* Returns the result of right shifting o1 by o2 on success, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 >> o2. */
@NoException public static native PyObject PyNumber_Rshift(PyObject o1, PyObject o2);

/* Returns the result of bitwise and of o1 and o2 on success, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 & o2. */
@NoException public static native PyObject PyNumber_And(PyObject o1, PyObject o2);

/* Returns the bitwise exclusive or of o1 by o2 on success, or NULL on failure.

   This is the equivalent of the Python expression: o1 ^ o2. */
@NoException public static native PyObject PyNumber_Xor(PyObject o1, PyObject o2);

/* Returns the result of bitwise or on o1 and o2 on success, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 | o2. */
@NoException public static native PyObject PyNumber_Or(PyObject o1, PyObject o2);

/* Returns 1 if obj is an index integer (has the nb_index slot of the
   tp_as_number structure filled in), and 0 otherwise. */
@NoException public static native int PyIndex_Check(PyObject arg0);

/* Returns the object 'o' converted to a Python int, or NULL with an exception
   raised on failure. */
@NoException public static native PyObject PyNumber_Index(PyObject o);

/* Returns the object 'o' converted to Py_ssize_t by going through
   PyNumber_Index() first.

   If an overflow error occurs while converting the int to Py_ssize_t, then the
   second argument 'exc' is the error-type to return.  If it is NULL, then the
   overflow error is cleared and the value is clipped. */
@NoException public static native @Cast("Py_ssize_t") long PyNumber_AsSsize_t(PyObject o, PyObject exc);

/* Returns the object 'o' converted to an integer object on success, or NULL
   on failure.

   This is the equivalent of the Python expression: int(o). */
@NoException public static native PyObject PyNumber_Long(PyObject o);

/* Returns the object 'o' converted to a float object on success, or NULL
  on failure.

  This is the equivalent of the Python expression: float(o). */
@NoException public static native PyObject PyNumber_Float(PyObject o);


/* --- In-place variants of (some of) the above number protocol functions -- */

/* Returns the result of adding o2 to o1, possibly in-place, or NULL
   on failure.

   This is the equivalent of the Python expression: o1 += o2. */
@NoException public static native PyObject PyNumber_InPlaceAdd(PyObject o1, PyObject o2);

/* Returns the result of subtracting o2 from o1, possibly in-place or
   NULL on failure.

   This is the equivalent of the Python expression: o1 -= o2. */
@NoException public static native PyObject PyNumber_InPlaceSubtract(PyObject o1, PyObject o2);

/* Returns the result of multiplying o1 by o2, possibly in-place, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 *= o2. */
@NoException public static native PyObject PyNumber_InPlaceMultiply(PyObject o1, PyObject o2);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* This is the equivalent of the Python expression: o1 @= o2. */
@NoException public static native PyObject PyNumber_InPlaceMatrixMultiply(PyObject o1, PyObject o2);
// #endif

/* Returns the result of dividing o1 by o2 giving an integral result, possibly
   in-place, or NULL on failure.

   This is the equivalent of the Python expression: o1 /= o2. */
@NoException public static native PyObject PyNumber_InPlaceFloorDivide(PyObject o1,
                                                   PyObject o2);

/* Returns the result of dividing o1 by o2 giving a float result, possibly
   in-place, or null on failure.

   This is the equivalent of the Python expression: o1 /= o2. */
@NoException public static native PyObject PyNumber_InPlaceTrueDivide(PyObject o1,
                                                  PyObject o2);

/* Returns the remainder of dividing o1 by o2, possibly in-place, or NULL on
   failure.

   This is the equivalent of the Python expression: o1 %= o2. */
@NoException public static native PyObject PyNumber_InPlaceRemainder(PyObject o1, PyObject o2);

/* Returns the result of raising o1 to the power of o2, possibly in-place,
   or NULL on failure.

   This is the equivalent of the Python expression: o1 **= o2,
   or o1 = pow(o1, o2, o3) if o3 is present. */
@NoException public static native PyObject PyNumber_InPlacePower(PyObject o1, PyObject o2,
                                             PyObject o3);

/* Returns the result of left shifting o1 by o2, possibly in-place, or NULL
   on failure.

   This is the equivalent of the Python expression: o1 <<= o2. */
@NoException public static native PyObject PyNumber_InPlaceLshift(PyObject o1, PyObject o2);

/* Returns the result of right shifting o1 by o2, possibly in-place or NULL
   on failure.

   This is the equivalent of the Python expression: o1 >>= o2. */
@NoException public static native PyObject PyNumber_InPlaceRshift(PyObject o1, PyObject o2);

/* Returns the result of bitwise and of o1 and o2, possibly in-place, or NULL
   on failure.

   This is the equivalent of the Python expression: o1 &= o2. */
@NoException public static native PyObject PyNumber_InPlaceAnd(PyObject o1, PyObject o2);

/* Returns the bitwise exclusive or of o1 by o2, possibly in-place, or NULL
   on failure.

   This is the equivalent of the Python expression: o1 ^= o2. */
@NoException public static native PyObject PyNumber_InPlaceXor(PyObject o1, PyObject o2);

/* Returns the result of bitwise or of o1 and o2, possibly in-place,
   or NULL on failure.

   This is the equivalent of the Python expression: o1 |= o2. */
@NoException public static native PyObject PyNumber_InPlaceOr(PyObject o1, PyObject o2);

/* Returns the integer n converted to a string with a base, with a base
   marker of 0b, 0o or 0x prefixed if applicable.

   If n is not an int object, it is converted with PyNumber_Index first. */
@NoException public static native PyObject PyNumber_ToBase(PyObject n, int base);


/* === Sequence protocol ================================================ */

/* Return 1 if the object provides sequence protocol, and zero
   otherwise.

   This function always succeeds. */
@NoException public static native int PySequence_Check(PyObject o);

/* Return the size of sequence object o, or -1 on failure. */
@NoException public static native @Cast("Py_ssize_t") long PySequence_Size(PyObject o);

/* For DLL compatibility */
// #undef PySequence_Length
// #define PySequence_Length PySequence_Size


/* Return the concatenation of o1 and o2 on success, and NULL on failure.

   This is the equivalent of the Python expression: o1 + o2. */
@NoException public static native PyObject PySequence_Concat(PyObject o1, PyObject o2);

/* Return the result of repeating sequence object 'o' 'count' times,
  or NULL on failure.

  This is the equivalent of the Python expression: o * count. */
@NoException public static native PyObject PySequence_Repeat(PyObject o, @Cast("Py_ssize_t") long count);

/* Return the ith element of o, or NULL on failure.

   This is the equivalent of the Python expression: o[i]. */
@NoException public static native PyObject PySequence_GetItem(PyObject o, @Cast("Py_ssize_t") long i);

/* Return the slice of sequence object o between i1 and i2, or NULL on failure.

   This is the equivalent of the Python expression: o[i1:i2]. */
@NoException public static native PyObject PySequence_GetSlice(PyObject o, @Cast("Py_ssize_t") long i1, @Cast("Py_ssize_t") long i2);

/* Assign object 'v' to the ith element of the sequence 'o'. Raise an exception
   and return -1 on failure; return 0 on success.

   This is the equivalent of the Python statement o[i] = v. */
@NoException public static native int PySequence_SetItem(PyObject o, @Cast("Py_ssize_t") long i, PyObject v);

/* Delete the 'i'-th element of the sequence 'v'. Returns -1 on failure.

   This is the equivalent of the Python statement: del o[i]. */
@NoException public static native int PySequence_DelItem(PyObject o, @Cast("Py_ssize_t") long i);

/* Assign the sequence object 'v' to the slice in sequence object 'o',
   from 'i1' to 'i2'. Returns -1 on failure.

   This is the equivalent of the Python statement: o[i1:i2] = v. */
@NoException public static native int PySequence_SetSlice(PyObject o, @Cast("Py_ssize_t") long i1, @Cast("Py_ssize_t") long i2,
                                    PyObject v);

/* Delete the slice in sequence object 'o' from 'i1' to 'i2'.
   Returns -1 on failure.

   This is the equivalent of the Python statement: del o[i1:i2]. */
@NoException public static native int PySequence_DelSlice(PyObject o, @Cast("Py_ssize_t") long i1, @Cast("Py_ssize_t") long i2);

/* Returns the sequence 'o' as a tuple on success, and NULL on failure.

   This is equivalent to the Python expression: tuple(o). */
@NoException public static native PyObject PySequence_Tuple(PyObject o);

/* Returns the sequence 'o' as a list on success, and NULL on failure.
   This is equivalent to the Python expression: list(o) */
@NoException public static native PyObject PySequence_List(PyObject o);

/* Return the sequence 'o' as a list, unless it's already a tuple or list.

   Use PySequence_Fast_GET_ITEM to access the members of this list, and
   PySequence_Fast_GET_SIZE to get its length.

   Returns NULL on failure.  If the object does not support iteration, raises a
   TypeError exception with 'm' as the message text. */
@NoException public static native PyObject PySequence_Fast(PyObject o, @Cast("const char*") BytePointer m);
@NoException public static native PyObject PySequence_Fast(PyObject o, String m);

/* Return the size of the sequence 'o', assuming that 'o' was returned by
   PySequence_Fast and is not NULL. */
// #define PySequence_Fast_GET_SIZE(o)
//     (PyList_Check(o) ? PyList_GET_SIZE(o) : PyTuple_GET_SIZE(o))

/* Return the 'i'-th element of the sequence 'o', assuming that o was returned
   by PySequence_Fast, and that i is within bounds. */
// #define PySequence_Fast_GET_ITEM(o, i)
//      (PyList_Check(o) ? PyList_GET_ITEM(o, i) : PyTuple_GET_ITEM(o, i))

/* Return a pointer to the underlying item array for
   an object returned by PySequence_Fast */
// #define PySequence_Fast_ITEMS(sf)
//     (PyList_Check(sf) ? ((PyListObject *)(sf))->ob_item
//                       : ((PyTupleObject *)(sf))->ob_item)

/* Return the number of occurrences on value on 'o', that is, return
   the number of keys for which o[key] == value.

   On failure, return -1.  This is equivalent to the Python expression:
   o.count(value). */
@NoException public static native @Cast("Py_ssize_t") long PySequence_Count(PyObject o, PyObject value);

/* Return 1 if 'ob' is in the sequence 'seq'; 0 if 'ob' is not in the sequence
   'seq'; -1 on error.

   Use __contains__ if possible, else _PySequence_IterSearch(). */
@NoException public static native int PySequence_Contains(PyObject seq, PyObject ob);

/* For DLL-level backwards compatibility */
// #undef PySequence_In
/* Determine if the sequence 'o' contains 'value'. If an item in 'o' is equal
   to 'value', return 1, otherwise return 0. On error, return -1.

   This is equivalent to the Python expression: value in o. */

/* For source-level backwards compatibility */
// #define PySequence_In PySequence_Contains


/* Return the first index for which o[i] == value.
   On error, return -1.

   This is equivalent to the Python expression: o.index(value). */
@NoException public static native @Cast("Py_ssize_t") long PySequence_Index(PyObject o, PyObject value);


/* --- In-place versions of some of the above Sequence functions --- */

/* Append sequence 'o2' to sequence 'o1', in-place when possible. Return the
   resulting object, which could be 'o1', or NULL on failure.

  This is the equivalent of the Python expression: o1 += o2. */
@NoException public static native PyObject PySequence_InPlaceConcat(PyObject o1, PyObject o2);

/* Repeat sequence 'o' by 'count', in-place when possible. Return the resulting
   object, which could be 'o', or NULL on failure.

   This is the equivalent of the Python expression: o1 *= count.  */
@NoException public static native PyObject PySequence_InPlaceRepeat(PyObject o, @Cast("Py_ssize_t") long count);


/* === Mapping protocol ================================================= */

/* Return 1 if the object provides mapping protocol, and 0 otherwise.

   This function always succeeds. */
@NoException public static native int PyMapping_Check(PyObject o);

/* Returns the number of keys in mapping object 'o' on success, and -1 on
  failure. This is equivalent to the Python expression: len(o). */
@NoException public static native @Cast("Py_ssize_t") long PyMapping_Size(PyObject o);

/* For DLL compatibility */
// #undef PyMapping_Length
// #define PyMapping_Length PyMapping_Size


/* Implemented as a macro:

   int PyMapping_DelItemString(PyObject *o, const char *key);

   Remove the mapping for the string 'key' from the mapping 'o'. Returns -1 on
   failure.

   This is equivalent to the Python statement: del o[key]. */
// #define PyMapping_DelItemString(O,K) PyObject_DelItemString((O),(K))

/* Implemented as a macro:

   int PyMapping_DelItem(PyObject *o, PyObject *key);

   Remove the mapping for the object 'key' from the mapping object 'o'.
   Returns -1 on failure.

   This is equivalent to the Python statement: del o[key]. */
// #define PyMapping_DelItem(O,K) PyObject_DelItem((O),(K))

/* On success, return 1 if the mapping object 'o' has the key 'key',
   and 0 otherwise.

   This is equivalent to the Python expression: key in o.

   This function always succeeds. */
@NoException public static native int PyMapping_HasKeyString(PyObject o, @Cast("const char*") BytePointer key);
@NoException public static native int PyMapping_HasKeyString(PyObject o, String key);

/* Return 1 if the mapping object has the key 'key', and 0 otherwise.

   This is equivalent to the Python expression: key in o.

   This function always succeeds. */
@NoException public static native int PyMapping_HasKey(PyObject o, PyObject key);

/* On success, return a list or tuple of the keys in mapping object 'o'.
   On failure, return NULL. */
@NoException public static native PyObject PyMapping_Keys(PyObject o);

/* On success, return a list or tuple of the values in mapping object 'o'.
   On failure, return NULL. */
@NoException public static native PyObject PyMapping_Values(PyObject o);

/* On success, return a list or tuple of the items in mapping object 'o',
   where each item is a tuple containing a key-value pair. On failure, return
   NULL. */
@NoException public static native PyObject PyMapping_Items(PyObject o);

/* Return element of 'o' corresponding to the string 'key' or NULL on failure.

   This is the equivalent of the Python expression: o[key]. */
@NoException public static native PyObject PyMapping_GetItemString(PyObject o,
                                               @Cast("const char*") BytePointer key);
@NoException public static native PyObject PyMapping_GetItemString(PyObject o,
                                               String key);

/* Map the string 'key' to the value 'v' in the mapping 'o'.
   Returns -1 on failure.

   This is the equivalent of the Python statement: o[key]=v. */
@NoException public static native int PyMapping_SetItemString(PyObject o, @Cast("const char*") BytePointer key,
                                        PyObject value);
@NoException public static native int PyMapping_SetItemString(PyObject o, String key,
                                        PyObject value);

/* isinstance(object, typeorclass) */
@NoException public static native int PyObject_IsInstance(PyObject object, PyObject typeorclass);

/* issubclass(object, typeorclass) */
@NoException public static native int PyObject_IsSubclass(PyObject object, PyObject typeorclass);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_ABSTRACTOBJECT_H
// #  include  "cpython/abstract.h"
// #  undef Py_CPYTHON_ABSTRACTOBJECT_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* Py_ABSTRACTOBJECT_H */


// Parsed from cpython/abstract.h

// #ifndef Py_CPYTHON_ABSTRACTOBJECT_H
// #  error "this header file must not be included directly"
// #endif

/* === Object Protocol ================================================== */

// #ifdef PY_SSIZE_T_CLEAN
// #endif

/* Convert keyword arguments from the FASTCALL (stack: C array, kwnames: tuple)
   format to a Python dictionary ("kwargs" dict).

   The type of kwnames keys is not checked. The final function getting
   arguments is responsible to check if all keys are strings, for example using
   PyArg_ParseTupleAndKeywords() or PyArg_ValidateKeywordArguments().

   Duplicate keys are merged using the last value. If duplicate keys must raise
   an exception, the caller is responsible to implement an explicit keys on
   kwnames. */
@NoException public static native PyObject _PyStack_AsDict(
    @Cast("PyObject*const*") PointerPointer values,
    PyObject kwnames);
@NoException public static native PyObject _PyStack_AsDict(
    @ByPtrPtr PyObject values,
    PyObject kwnames);

/* Suggested size (number of positional arguments) for arrays of PyObject*
   allocated on a C stack to avoid allocating memory on the heap memory. Such
   array is used to pass positional arguments to call functions of the
   PyObject_Vectorcall() family.

   The size is chosen to not abuse the C stack and so limit the risk of stack
   overflow. The size is also chosen to allow using the small stack for most
   function calls of the Python standard library. On 64-bit CPU, it allocates
   40 bytes on the stack. */
public static final int _PY_FASTCALL_SMALL_STACK = 5;

@NoException public static native PyObject _Py_CheckFunctionResult(
    PyThreadState tstate,
    PyObject callable,
    PyObject result,
    @Cast("const char*") BytePointer where);
@NoException public static native PyObject _Py_CheckFunctionResult(
    PyThreadState tstate,
    PyObject callable,
    PyObject result,
    String where);

/* === Vectorcall protocol (PEP 590) ============================= */

/* Call callable using tp_call. Arguments are like PyObject_Vectorcall()
   or PyObject_FastCallDict() (both forms are supported),
   except that nargs is plainly the number of arguments without flags. */
@NoException public static native PyObject _PyObject_MakeTpCall(
    PyThreadState tstate,
    PyObject callable,
    @Cast("PyObject*const*") PointerPointer args, @Cast("Py_ssize_t") long nargs,
    PyObject keywords);
@NoException public static native PyObject _PyObject_MakeTpCall(
    PyThreadState tstate,
    PyObject callable,
    @ByPtrPtr PyObject args, @Cast("Py_ssize_t") long nargs,
    PyObject keywords);

public static native @MemberGetter int PY_VECTORCALL_ARGUMENTS_OFFSET();
public static final int PY_VECTORCALL_ARGUMENTS_OFFSET = PY_VECTORCALL_ARGUMENTS_OFFSET();

@NoException public static native @Cast("Py_ssize_t") long PyVectorcall_NARGS(@Cast("size_t") long n);

@NoException public static native vectorcallfunc PyVectorcall_Function(PyObject callable);

/* Call the callable object 'callable' with the "vectorcall" calling
   convention.

   args is a C array for positional arguments.

   nargsf is the number of positional arguments plus optionally the flag
   PY_VECTORCALL_ARGUMENTS_OFFSET which means that the caller is allowed to
   modify args[-1].

   kwnames is a tuple of keyword names. The values of the keyword arguments
   are stored in "args" after the positional arguments (note that the number
   of keyword arguments does not change nargsf). kwnames can also be NULL if
   there are no keyword arguments.

   keywords must only contain strings and all keys must be unique.

   Return the result on success. Raise an exception and return NULL on
   error. */
@NoException public static native PyObject _PyObject_VectorcallTstate(PyThreadState tstate, PyObject callable,
                           @Cast("PyObject*const*") PointerPointer args, @Cast("size_t") long nargsf,
                           PyObject kwnames);
@NoException public static native PyObject _PyObject_VectorcallTstate(PyThreadState tstate, PyObject callable,
                           @ByPtrPtr PyObject args, @Cast("size_t") long nargsf,
                           PyObject kwnames);

@NoException public static native PyObject PyObject_Vectorcall(PyObject callable, @Cast("PyObject*const*") PointerPointer args,
                     @Cast("size_t") long nargsf, PyObject kwnames);
@NoException public static native PyObject PyObject_Vectorcall(PyObject callable, @ByPtrPtr PyObject args,
                     @Cast("size_t") long nargsf, PyObject kwnames);

// Backwards compatibility aliases for API that was provisional in Python 3.8
// #define _PyObject_Vectorcall PyObject_Vectorcall
// #define _PyObject_VectorcallMethod PyObject_VectorcallMethod
// #define _PyObject_FastCallDict PyObject_VectorcallDict
// #define _PyVectorcall_Function PyVectorcall_Function
// #define _PyObject_CallOneArg PyObject_CallOneArg
// #define _PyObject_CallMethodNoArgs PyObject_CallMethodNoArgs
// #define _PyObject_CallMethodOneArg PyObject_CallMethodOneArg

/* Same as PyObject_Vectorcall except that keyword arguments are passed as
   dict, which may be NULL if there are no keyword arguments. */
@NoException public static native PyObject PyObject_VectorcallDict(
    PyObject callable,
    @Cast("PyObject*const*") PointerPointer args,
    @Cast("size_t") long nargsf,
    PyObject kwargs);
@NoException public static native PyObject PyObject_VectorcallDict(
    PyObject callable,
    @ByPtrPtr PyObject args,
    @Cast("size_t") long nargsf,
    PyObject kwargs);

/* Call "callable" (which must support vectorcall) with positional arguments
   "tuple" and keyword arguments "dict". "dict" may also be NULL */
@NoException public static native PyObject PyVectorcall_Call(PyObject callable, PyObject tuple, PyObject dict);

@NoException public static native PyObject _PyObject_FastCallTstate(PyThreadState tstate, PyObject func, @Cast("PyObject*const*") PointerPointer args, @Cast("Py_ssize_t") long nargs);
@NoException public static native PyObject _PyObject_FastCallTstate(PyThreadState tstate, PyObject func, @ByPtrPtr PyObject args, @Cast("Py_ssize_t") long nargs);

/* Same as PyObject_Vectorcall except without keyword arguments */
@NoException public static native PyObject _PyObject_FastCall(PyObject func, @Cast("PyObject*const*") PointerPointer args, @Cast("Py_ssize_t") long nargs);
@NoException public static native PyObject _PyObject_FastCall(PyObject func, @ByPtrPtr PyObject args, @Cast("Py_ssize_t") long nargs);

/* Call a callable without any arguments
   Private static inline function variant of public function
   PyObject_CallNoArgs(). */
@NoException public static native PyObject _PyObject_CallNoArg(PyObject func);

@NoException public static native PyObject PyObject_CallOneArg(PyObject func, PyObject arg);

@NoException public static native PyObject PyObject_VectorcallMethod(
    PyObject name, @Cast("PyObject*const*") PointerPointer args,
    @Cast("size_t") long nargsf, PyObject kwnames);
@NoException public static native PyObject PyObject_VectorcallMethod(
    PyObject name, @ByPtrPtr PyObject args,
    @Cast("size_t") long nargsf, PyObject kwnames);

@NoException public static native PyObject PyObject_CallMethodNoArgs(PyObject self, PyObject name);

@NoException public static native PyObject PyObject_CallMethodOneArg(PyObject self, PyObject name, PyObject arg);

/* Like PyObject_CallMethod(), but expect a _Py_Identifier*
   as the method name. */
@NoException public static native PyObject _PyObject_CallMethodId(PyObject obj,
                                              _Py_Identifier name,
                                              @Cast("const char*") BytePointer format);
@NoException public static native PyObject _PyObject_CallMethodId(PyObject obj,
                                              _Py_Identifier name,
                                              String format);

@NoException public static native PyObject _PyObject_CallMethodId_SizeT(PyObject obj,
                                                    _Py_Identifier name,
                                                    @Cast("const char*") BytePointer format);
@NoException public static native PyObject _PyObject_CallMethodId_SizeT(PyObject obj,
                                                    _Py_Identifier name,
                                                    String format);

@NoException public static native PyObject _PyObject_CallMethodIdObjArgs(
    PyObject obj,
    _Py_Identifier name);

@NoException public static native PyObject _PyObject_VectorcallMethodId(
    _Py_Identifier name, @Cast("PyObject*const*") PointerPointer args,
    @Cast("size_t") long nargsf, PyObject kwnames);
@NoException public static native PyObject _PyObject_VectorcallMethodId(
    _Py_Identifier name, @ByPtrPtr PyObject args,
    @Cast("size_t") long nargsf, PyObject kwnames);

@NoException public static native PyObject _PyObject_CallMethodIdNoArgs(PyObject self, _Py_Identifier name);

@NoException public static native PyObject _PyObject_CallMethodIdOneArg(PyObject self, _Py_Identifier name, PyObject arg);

@NoException public static native int _PyObject_HasLen(PyObject o);

/* Guess the size of object 'o' using len(o) or o.__length_hint__().
   If neither of those return a non-negative value, then return the default
   value.  If one of the calls fails, this function returns -1. */
@NoException public static native @Cast("Py_ssize_t") long PyObject_LengthHint(PyObject o, @Cast("Py_ssize_t") long arg1);

/* === New Buffer API ============================================ */

/* Return 1 if the getbuffer function is available, otherwise return 0. */
@NoException public static native int PyObject_CheckBuffer(PyObject obj);

/* This is a C-API version of the getbuffer function call.  It checks
   to make sure object has the required function pointer and issues the
   call.

   Returns -1 and raises an error on failure and returns 0 on success. */
@NoException public static native int PyObject_GetBuffer(PyObject obj, Py_buffer view,
                                   int flags);

/* Get the memory area pointed to by the indices for the buffer given.
   Note that view->ndim is the assumed size of indices. */
@NoException public static native Pointer PyBuffer_GetPointer(Py_buffer view, @Cast("Py_ssize_t*") SizeTPointer indices);

/* Return the implied itemsize of the data-format area from a
   struct-style description. */


/* Implementation in memoryobject.c */
@NoException public static native int PyBuffer_ToContiguous(Pointer buf, Py_buffer view,
                                      @Cast("Py_ssize_t") long len, @Cast("char") byte order);

@NoException public static native int PyBuffer_FromContiguous(Py_buffer view, Pointer buf,
                                        @Cast("Py_ssize_t") long len, @Cast("char") byte order);

/* Copy len bytes of data from the contiguous chunk of memory
   pointed to by buf into the buffer exported by obj.  Return
   0 on success and return -1 and raise a PyBuffer_Error on
   error (i.e. the object does not have a buffer interface or
   it is not working).

   If fort is 'F', then if the object is multi-dimensional,
   then the data will be copied into the array in
   Fortran-style (first dimension varies the fastest).  If
   fort is 'C', then the data will be copied into the array
   in C-style (last dimension varies the fastest).  If fort
   is 'A', then it does not matter and the copy will be made
   in whatever way is more efficient. */
@NoException public static native int PyObject_CopyData(PyObject dest, PyObject src);

/* Copy the data from the src buffer to the buffer of destination. */
@NoException public static native int PyBuffer_IsContiguous(@Const Py_buffer view, @Cast("char") byte fort);

/*Fill the strides array with byte-strides of a contiguous
  (Fortran-style if fort is 'F' or C-style otherwise)
  array of the given shape with the given number of bytes
  per element. */
@NoException public static native void PyBuffer_FillContiguousStrides(int ndims,
                                               @Cast("Py_ssize_t*") SizeTPointer shape,
                                               @Cast("Py_ssize_t*") SizeTPointer strides,
                                               int itemsize,
                                               @Cast("char") byte fort);

/* Fills in a buffer-info structure correctly for an exporter
   that can only share a contiguous chunk of memory of
   "unsigned bytes" of the given length.

   Returns 0 on success and -1 (with raising an error) on error. */
@NoException public static native int PyBuffer_FillInfo(Py_buffer view, PyObject o, Pointer buf,
                                  @Cast("Py_ssize_t") long len, int readonly,
                                  int flags);

/* Releases a Py_buffer obtained from getbuffer ParseTuple's "s*". */
@NoException public static native void PyBuffer_Release(Py_buffer view);

/* === Sequence protocol ================================================ */

/* Assume tp_as_sequence and sq_item exist and that 'i' does not
   need to be corrected for a negative index. */
// #define PySequence_ITEM(o, i)
//     ( Py_TYPE(o)->tp_as_sequence->sq_item(o, i) )

public static final int PY_ITERSEARCH_COUNT =    1;
public static final int PY_ITERSEARCH_INDEX =    2;
public static final int PY_ITERSEARCH_CONTAINS = 3;

/* Iterate over seq.

   Result depends on the operation:

   PY_ITERSEARCH_COUNT:  return # of times obj appears in seq; -1 if
     error.
   PY_ITERSEARCH_INDEX:  return 0-based index of first occurrence of
     obj in seq; set ValueError and return -1 if none found;
     also return -1 on error.
   PY_ITERSEARCH_CONTAINS:  return 1 if obj in seq, else 0; -1 on
     error. */
@NoException public static native @Cast("Py_ssize_t") long _PySequence_IterSearch(PyObject seq,
                                              PyObject obj, int operation);

/* === Mapping protocol ================================================= */

@NoException public static native int _PyObject_RealIsInstance(PyObject inst, PyObject cls);

@NoException public static native int _PyObject_RealIsSubclass(PyObject derived, PyObject cls);

@NoException public static native @Cast("char*const*") PointerPointer _PySequence_BytesToCharpArray(PyObject self);

@NoException public static native void _Py_FreeCharPArray(@Cast("char*const*") PointerPointer array);
@NoException public static native void _Py_FreeCharPArray(@Cast("char*const*") @ByPtrPtr BytePointer array);
@NoException public static native void _Py_FreeCharPArray(@Cast("char*const*") @ByPtrPtr ByteBuffer array);
@NoException public static native void _Py_FreeCharPArray(@Cast("char*const*") @ByPtrPtr byte[] array);

/* For internal use by buffer API functions */
@NoException public static native void _Py_add_one_to_index_F(int nd, @Cast("Py_ssize_t*") SizeTPointer index,
                                        @Cast("const Py_ssize_t*") SizeTPointer shape);
@NoException public static native void _Py_add_one_to_index_C(int nd, @Cast("Py_ssize_t*") SizeTPointer index,
                                        @Cast("const Py_ssize_t*") SizeTPointer shape);

/* Convert Python int to Py_ssize_t. Do nothing if the argument is None. */
@NoException public static native int _Py_convert_optional_to_ssize_t(PyObject arg0, Pointer arg1);

/* Same as PyNumber_Index but can return an instance of a subclass of int. */
@NoException public static native PyObject _PyNumber_Index(PyObject o);


// Parsed from bltinmodule.h

// #ifndef Py_BLTINMODULE_H
// #define Py_BLTINMODULE_H
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyFilter_Type(); public static native void PyFilter_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyMap_Type(); public static native void PyMap_Type(PyTypeObject setter);
public static native @ByRef PyTypeObject PyZip_Type(); public static native void PyZip_Type(PyTypeObject setter);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_BLTINMODULE_H */


// Parsed from code.h

/* Definitions for bytecode */

// #ifndef Py_CODE_H
// #define Py_CODE_H
// #ifdef __cplusplus
// #endif

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_CODE_H
// #  include  "cpython/code.h"
// #  undef Py_CPYTHON_CODE_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_CODE_H */


// Parsed from cpython/code.h

// #ifndef Py_CPYTHON_CODE_H
// #  error "this header file must not be included directly"
// #endif

// #ifdef WORDS_BIGENDIAN
// #  define _Py_OPCODE(word) ((word) >> 8)
// #  define _Py_OPARG(word) ((word) & 255)
// Targeting ../_PyOpcache.java


// Targeting ../PyCodeObject.java



/* Masks for co_flags above */
public static final int CO_OPTIMIZED =    0x0001;
public static final int CO_NEWLOCALS =    0x0002;
public static final int CO_VARARGS =      0x0004;
public static final int CO_VARKEYWORDS =  0x0008;
public static final int CO_NESTED =       0x0010;
public static final int CO_GENERATOR =    0x0020;
/* The CO_NOFREE flag is set if there are no free or cell variables.
   This information is redundant, but it allows a single flag test
   to determine whether there is any extra work to be done when the
   call frame it setup.
*/
public static final int CO_NOFREE =       0x0040;

/* The CO_COROUTINE flag is set for coroutine functions (defined with
   ``async def`` keywords) */
public static final int CO_COROUTINE =            0x0080;
public static final int CO_ITERABLE_COROUTINE =   0x0100;
public static final int CO_ASYNC_GENERATOR =      0x0200;

/* bpo-39562: These constant values are changed in Python 3.9
   to prevent collision with compiler flags. CO_FUTURE_ and PyCF_
   constants must be kept unique. PyCF_ constants can use bits from
   0x0100 to 0x10000. CO_FUTURE_ constants use bits starting at 0x20000. */
public static final int CO_FUTURE_DIVISION =      0x20000;
public static final int CO_FUTURE_ABSOLUTE_IMPORT = 0x40000; /* do absolute imports by default */
public static final int CO_FUTURE_WITH_STATEMENT =  0x80000;
public static final int CO_FUTURE_PRINT_FUNCTION =  0x100000;
public static final int CO_FUTURE_UNICODE_LITERALS = 0x200000;

public static final int CO_FUTURE_BARRY_AS_BDFL =  0x400000;
public static final int CO_FUTURE_GENERATOR_STOP =  0x800000;
public static final int CO_FUTURE_ANNOTATIONS =    0x1000000;

/* This value is found in the co_cell2arg array when the associated cell
   variable does not correspond to an argument. */
public static final int CO_CELL_NOT_AN_ARG = (-1);

/* This should be defined if a future statement modifies the syntax.
   For example, when a keyword is added.
*/
// #define PY_PARSER_REQUIRES_FUTURE_KEYWORD

public static final int CO_MAXBLOCKS = 20; /* Max static block nesting within a function */

public static native @ByRef PyTypeObject PyCode_Type(); public static native void PyCode_Type(PyTypeObject setter);

// #define PyCode_Check(op) Py_IS_TYPE(op, &PyCode_Type)
// #define PyCode_GetNumFree(op) (PyTuple_GET_SIZE((op)->co_freevars))

/* Public interface */
@NoException public static native PyCodeObject PyCode_New(
        int arg0, int arg1, int arg2, int arg3, int arg4, PyObject arg5, PyObject arg6,
        PyObject arg7, PyObject arg8, PyObject arg9, PyObject arg10,
        PyObject arg11, PyObject arg12, int arg13, PyObject arg14);

@NoException public static native PyCodeObject PyCode_NewWithPosOnlyArgs(
        int arg0, int arg1, int arg2, int arg3, int arg4, int arg5, PyObject arg6, PyObject arg7,
        PyObject arg8, PyObject arg9, PyObject arg10, PyObject arg11,
        PyObject arg12, PyObject arg13, int arg14, PyObject arg15);
        /* same as struct above */

/* Creates a new empty code object with the specified source location. */
@NoException public static native PyCodeObject PyCode_NewEmpty(@Cast("const char*") BytePointer filename, @Cast("const char*") BytePointer funcname, int firstlineno);
@NoException public static native PyCodeObject PyCode_NewEmpty(String filename, String funcname, int firstlineno);

/* Return the line number associated with the specified bytecode index
   in this code object.  If you just need the line number of a frame,
   use PyFrame_GetLineNumber() instead. */
@NoException public static native int PyCode_Addr2Line(PyCodeObject arg0, int arg1);
// Targeting ../_opaque.java


// Targeting ../PyCodeAddressRange.java



/* Update *bounds to describe the first and one-past-the-last instructions in the
   same line as lasti.  Return the number of that line.
*/
@NoException public static native int _PyCode_CheckLineNumber(int lasti, PyCodeAddressRange bounds);

/* Create a comparable key used to compare constants taking in account the
 * object type. It is used to make sure types are not coerced (e.g., float and
 * complex) _and_ to distinguish 0.0 from -0.0 e.g. on IEEE platforms
 *
 * Return (type(obj), obj, ...): a tuple with variable size (at least 2 items)
 * depending on the type and the value. The type is the first item to not
 * compare bytes and str which can raise a BytesWarning exception. */
@NoException public static native PyObject _PyCode_ConstantKey(PyObject obj);

@NoException public static native PyObject PyCode_Optimize(PyObject code, PyObject consts,
                                      PyObject names, PyObject lnotab);


@NoException public static native int _PyCode_GetExtra(PyObject code, @Cast("Py_ssize_t") long index,
                                 @Cast("void**") PointerPointer extra);
@NoException public static native int _PyCode_GetExtra(PyObject code, @Cast("Py_ssize_t") long index,
                                 @Cast("void**") @ByPtrPtr Pointer extra);
@NoException public static native int _PyCode_SetExtra(PyObject code, @Cast("Py_ssize_t") long index,
                                 Pointer extra);

/** API for initializing the line number table. */


/** Out of process API for initializing the line number table. */


/** API for traversing the line number table. */






// Parsed from compile.h

// #ifndef Py_COMPILE_H
// #define Py_COMPILE_H
// #ifdef __cplusplus
// #endif

/* These definitions must match corresponding definitions in graminit.h. */
public static final int Py_single_input = 256;
public static final int Py_file_input = 257;
public static final int Py_eval_input = 258;
public static final int Py_func_type_input = 345;

/* This doesn't need to match anything */
public static final int Py_fstring_input = 800;

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_COMPILE_H
// #  include "cpython/compile.h"
// #  undef Py_CPYTHON_COMPILE_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_COMPILE_H */


// Parsed from cpython/compile.h

// #ifndef Py_CPYTHON_COMPILE_H
// #  error "this header file must not be included directly"
// #endif

/* Public interface */
public static final int PyCF_MASK = (CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | 
                   CO_FUTURE_WITH_STATEMENT | CO_FUTURE_PRINT_FUNCTION | 
                   CO_FUTURE_UNICODE_LITERALS | CO_FUTURE_BARRY_AS_BDFL | 
                   CO_FUTURE_GENERATOR_STOP | CO_FUTURE_ANNOTATIONS);
public static final int PyCF_MASK_OBSOLETE = (CO_NESTED);

/* bpo-39562: CO_FUTURE_ and PyCF_ constants must be kept unique.
   PyCF_ constants can use bits from 0x0100 to 0x10000.
   CO_FUTURE_ constants use bits starting at 0x20000. */
public static final int PyCF_SOURCE_IS_UTF8 =  0x0100;
public static final int PyCF_DONT_IMPLY_DEDENT = 0x0200;
public static final int PyCF_ONLY_AST = 0x0400;
public static final int PyCF_IGNORE_COOKIE = 0x0800;
public static final int PyCF_TYPE_COMMENTS = 0x1000;
public static final int PyCF_ALLOW_TOP_LEVEL_AWAIT = 0x2000;
public static final int PyCF_COMPILE_MASK = (PyCF_ONLY_AST | PyCF_ALLOW_TOP_LEVEL_AWAIT | 
                           PyCF_TYPE_COMMENTS | PyCF_DONT_IMPLY_DEDENT);
// Targeting ../PyCompilerFlags.java



// #define _PyCompilerFlags_INIT
//     (PyCompilerFlags){.cf_flags = 0, .cf_feature_version = PY_MINOR_VERSION}
// Targeting ../PyFutureFeatures.java



public static final String FUTURE_NESTED_SCOPES = "nested_scopes";
public static final String FUTURE_GENERATORS = "generators";
public static final String FUTURE_DIVISION = "division";
public static final String FUTURE_ABSOLUTE_IMPORT = "absolute_import";
public static final String FUTURE_WITH_STATEMENT = "with_statement";
public static final String FUTURE_PRINT_FUNCTION = "print_function";
public static final String FUTURE_UNICODE_LITERALS = "unicode_literals";
public static final String FUTURE_BARRY_AS_BDFL = "barry_as_FLUFL";
public static final String FUTURE_GENERATOR_STOP = "generator_stop";
public static final String FUTURE_ANNOTATIONS = "annotations";

public static final int PY_INVALID_STACK_EFFECT = INT_MAX;
@NoException public static native int PyCompile_OpcodeStackEffect(int opcode, int oparg);
@NoException public static native int PyCompile_OpcodeStackEffectWithJump(int opcode, int oparg, int jump);


// Parsed from pythonrun.h


/* Interfaces to parse and execute pieces of python code */

// #ifndef Py_PYTHONRUN_H
// #define Py_PYTHONRUN_H
// #ifdef __cplusplus
// #endif

@NoException public static native PyObject Py_CompileString(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, int arg2);
@NoException public static native PyObject Py_CompileString(String arg0, String arg1, int arg2);

@NoException public static native void PyErr_Print();
@NoException public static native void PyErr_PrintEx(int arg0);
@NoException public static native void PyErr_Display(PyObject arg0, PyObject arg1, PyObject arg2);
// Targeting ../Int_PyOS_InputHook.java


public static native Int_PyOS_InputHook PyOS_InputHook(); public static native void PyOS_InputHook(Int_PyOS_InputHook setter);

/* Stack size, in "pointers" (so we get extra safety margins
   on 64-bit platforms).  On a 32-bit platform, this translates
   to an 8k margin. */
public static final int PYOS_STACK_MARGIN = 2048;

// #if defined(WIN32) && !defined(MS_WIN64) && !defined(_M_ARM) && defined(_MSC_VER) && _MSC_VER >= 1300
/* Enable stack checking under Microsoft C */
// #define USE_STACKCHECK
// #endif

// #ifdef USE_STACKCHECK
// #endif

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_PYTHONRUN_H
// #  include  "cpython/pythonrun.h"
// #  undef Py_CPYTHON_PYTHONRUN_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYTHONRUN_H */


// Parsed from cpython/pythonrun.h

// #ifndef Py_CPYTHON_PYTHONRUN_H
// #  error "this header file must not be included directly"
// #endif

@NoException public static native int PyRun_SimpleStringFlags(@Cast("const char*") BytePointer arg0, PyCompilerFlags arg1);
@NoException public static native int PyRun_SimpleStringFlags(String arg0, PyCompilerFlags arg1);
@NoException public static native int _PyRun_SimpleFileObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int PyRun_AnyFileExFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int PyRun_AnyFileExFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int _PyRun_AnyFileObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int PyRun_SimpleFileExFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int PyRun_SimpleFileExFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveOneFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveOneFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveOneObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveLoopFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveLoopFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    PyCompilerFlags flags);
@NoException public static native int _PyRun_InteractiveLoopObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    PyCompilerFlags flags);


@NoException public static native PyObject PyRun_StringFlags(@Cast("const char*") BytePointer arg0, int arg1, PyObject arg2,
                                         PyObject arg3, PyCompilerFlags arg4);
@NoException public static native PyObject PyRun_StringFlags(String arg0, int arg1, PyObject arg2,
                                         PyObject arg3, PyCompilerFlags arg4);

@NoException public static native PyObject PyRun_FileExFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    int start,
    PyObject globals,
    PyObject locals,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native PyObject PyRun_FileExFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    int start,
    PyObject globals,
    PyObject locals,
    int closeit,
    PyCompilerFlags flags);


@NoException public static native PyObject Py_CompileStringExFlags(
    @Cast("const char*") BytePointer str,
    @Cast("const char*") BytePointer filename,
    int start,
    PyCompilerFlags flags,
    int optimize);
@NoException public static native PyObject Py_CompileStringExFlags(
    String str,
    String filename,
    int start,
    PyCompilerFlags flags,
    int optimize);
@NoException public static native PyObject Py_CompileStringObject(
    @Cast("const char*") BytePointer str,
    PyObject filename, int start,
    PyCompilerFlags flags,
    int optimize);
@NoException public static native PyObject Py_CompileStringObject(
    String str,
    PyObject filename, int start,
    PyCompilerFlags flags,
    int optimize);

// #define Py_CompileString(str, p, s) Py_CompileStringExFlags(str, p, s, NULL, -1)
// #define Py_CompileStringFlags(str, p, s, f) Py_CompileStringExFlags(str, p, s, f, -1)


@NoException public static native @Cast("const char*") BytePointer _Py_SourceAsString(
    PyObject cmd,
    @Cast("const char*") BytePointer funcname,
    @Cast("const char*") BytePointer what,
    PyCompilerFlags cf,
    @Cast("PyObject**") PointerPointer cmd_copy);
@NoException public static native @Cast("const char*") BytePointer _Py_SourceAsString(
    PyObject cmd,
    @Cast("const char*") BytePointer funcname,
    @Cast("const char*") BytePointer what,
    PyCompilerFlags cf,
    @ByPtrPtr PyObject cmd_copy);
@NoException public static native String _Py_SourceAsString(
    PyObject cmd,
    String funcname,
    String what,
    PyCompilerFlags cf,
    @ByPtrPtr PyObject cmd_copy);


/* A function flavor is also exported by libpython. It is required when
    libpython is accessed directly rather than using header files which defines
    macros below. On Windows, for example, PyAPI_FUNC() uses dllexport to
    export functions in pythonXX.dll. */
@NoException public static native PyObject PyRun_String(@Cast("const char*") BytePointer str, int s, PyObject g, PyObject l);
@NoException public static native PyObject PyRun_String(String str, int s, PyObject g, PyObject l);
@NoException public static native int PyRun_AnyFile(@Cast("FILE*") Pointer fp, @Cast("const char*") BytePointer name);
@NoException public static native int PyRun_AnyFile(@Cast("FILE*") Pointer fp, String name);
@NoException public static native int PyRun_AnyFileEx(@Cast("FILE*") Pointer fp, @Cast("const char*") BytePointer name, int closeit);
@NoException public static native int PyRun_AnyFileEx(@Cast("FILE*") Pointer fp, String name, int closeit);
@NoException public static native int PyRun_AnyFileFlags(@Cast("FILE*") Pointer arg0, @Cast("const char*") BytePointer arg1, PyCompilerFlags arg2);
@NoException public static native int PyRun_AnyFileFlags(@Cast("FILE*") Pointer arg0, String arg1, PyCompilerFlags arg2);
@NoException public static native int PyRun_SimpleString(@Cast("const char*") BytePointer s);
@NoException public static native int PyRun_SimpleString(String s);
@NoException public static native int PyRun_SimpleFile(@Cast("FILE*") Pointer f, @Cast("const char*") BytePointer p);
@NoException public static native int PyRun_SimpleFile(@Cast("FILE*") Pointer f, String p);
@NoException public static native int PyRun_SimpleFileEx(@Cast("FILE*") Pointer f, @Cast("const char*") BytePointer p, int c);
@NoException public static native int PyRun_SimpleFileEx(@Cast("FILE*") Pointer f, String p, int c);
@NoException public static native int PyRun_InteractiveOne(@Cast("FILE*") Pointer f, @Cast("const char*") BytePointer p);
@NoException public static native int PyRun_InteractiveOne(@Cast("FILE*") Pointer f, String p);
@NoException public static native int PyRun_InteractiveLoop(@Cast("FILE*") Pointer f, @Cast("const char*") BytePointer p);
@NoException public static native int PyRun_InteractiveLoop(@Cast("FILE*") Pointer f, String p);
@NoException public static native PyObject PyRun_File(@Cast("FILE*") Pointer fp, @Cast("const char*") BytePointer p, int s, PyObject g, PyObject l);
@NoException public static native PyObject PyRun_File(@Cast("FILE*") Pointer fp, String p, int s, PyObject g, PyObject l);
@NoException public static native PyObject PyRun_FileEx(@Cast("FILE*") Pointer fp, @Cast("const char*") BytePointer p, int s, PyObject g, PyObject l, int c);
@NoException public static native PyObject PyRun_FileEx(@Cast("FILE*") Pointer fp, String p, int s, PyObject g, PyObject l, int c);
@NoException public static native PyObject PyRun_FileFlags(@Cast("FILE*") Pointer fp, @Cast("const char*") BytePointer p, int s, PyObject g, PyObject l, PyCompilerFlags flags);
@NoException public static native PyObject PyRun_FileFlags(@Cast("FILE*") Pointer fp, String p, int s, PyObject g, PyObject l, PyCompilerFlags flags);

/* Use macros for a bunch of old variants */
// #define PyRun_String(str, s, g, l) PyRun_StringFlags(str, s, g, l, NULL)
// #define PyRun_AnyFile(fp, name) PyRun_AnyFileExFlags(fp, name, 0, NULL)
// #define PyRun_AnyFileEx(fp, name, closeit)
//     PyRun_AnyFileExFlags(fp, name, closeit, NULL)
// #define PyRun_AnyFileFlags(fp, name, flags)
//     PyRun_AnyFileExFlags(fp, name, 0, flags)
// #define PyRun_SimpleString(s) PyRun_SimpleStringFlags(s, NULL)
// #define PyRun_SimpleFile(f, p) PyRun_SimpleFileExFlags(f, p, 0, NULL)
// #define PyRun_SimpleFileEx(f, p, c) PyRun_SimpleFileExFlags(f, p, c, NULL)
// #define PyRun_InteractiveOne(f, p) PyRun_InteractiveOneFlags(f, p, NULL)
// #define PyRun_InteractiveLoop(f, p) PyRun_InteractiveLoopFlags(f, p, NULL)
// #define PyRun_File(fp, p, s, g, l)
//     PyRun_FileExFlags(fp, p, s, g, l, 0, NULL)
// #define PyRun_FileEx(fp, p, s, g, l, c)
//     PyRun_FileExFlags(fp, p, s, g, l, c, NULL)
// #define PyRun_FileFlags(fp, p, s, g, l, flags)
//     PyRun_FileExFlags(fp, p, s, g, l, 0, flags)


/* Stuff with no proper home (yet) */
@NoException public static native @Cast("char*") BytePointer PyOS_Readline(@Cast("FILE*") Pointer arg0, @Cast("FILE*") Pointer arg1, @Cast("const char*") BytePointer arg2);
@NoException public static native @Cast("char*") ByteBuffer PyOS_Readline(@Cast("FILE*") Pointer arg0, @Cast("FILE*") Pointer arg1, String arg2);
public static native PyThreadState _PyOS_ReadlineTState(); public static native void _PyOS_ReadlineTState(PyThreadState setter);
// Targeting ../PyOS_ReadlineFunctionPointer_Pointer_Pointer_BytePointer.java


public static native PyOS_ReadlineFunctionPointer_Pointer_Pointer_BytePointer PyOS_ReadlineFunctionPointer(); public static native void PyOS_ReadlineFunctionPointer(PyOS_ReadlineFunctionPointer_Pointer_Pointer_BytePointer setter);


// Parsed from pylifecycle.h


/* Interfaces to configure, query, create & destroy the Python runtime */

// #ifndef Py_PYLIFECYCLE_H
// #define Py_PYLIFECYCLE_H
// #ifdef __cplusplus
// #endif


/* Initialization and finalization */
@NoException public static native void Py_Initialize();
@NoException public static native void Py_InitializeEx(int arg0);
@NoException public static native void Py_Finalize();
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
@NoException public static native int Py_FinalizeEx();
// #endif
@NoException public static native int Py_IsInitialized();

/* Subinterpreter support */
@NoException public static native PyThreadState Py_NewInterpreter();
@NoException public static native void Py_EndInterpreter(PyThreadState arg0);
// Targeting ../Func.java


@NoException public static native int Py_AtExit(Func func);

@NoException public static native void Py_Exit(int arg0);

/* Bootstrap __main__ (defined in Modules/main.c) */
@NoException public static native int Py_Main(int argc, @Cast("wchar_t**") PointerPointer argv);
@NoException public static native int Py_Main(int argc, @Cast("wchar_t**") @ByPtrPtr Pointer argv);
@NoException public static native int Py_BytesMain(int argc, @Cast("char**") PointerPointer argv);
@NoException public static native int Py_BytesMain(int argc, @Cast("char**") @ByPtrPtr BytePointer argv);
@NoException public static native int Py_BytesMain(int argc, @Cast("char**") @ByPtrPtr ByteBuffer argv);
@NoException public static native int Py_BytesMain(int argc, @Cast("char**") @ByPtrPtr byte[] argv);

/* In pathconfig.c */
@NoException public static native void Py_SetProgramName(@Cast("const wchar_t*") Pointer arg0);
@NoException public static native @Cast("wchar_t*") Pointer Py_GetProgramName();

@NoException public static native void Py_SetPythonHome(@Cast("const wchar_t*") Pointer arg0);
@NoException public static native @Cast("wchar_t*") Pointer Py_GetPythonHome();

@NoException public static native @Cast("wchar_t*") Pointer Py_GetProgramFullPath();

@NoException public static native @Cast("wchar_t*") Pointer Py_GetPrefix();
@NoException public static native @Cast("wchar_t*") Pointer Py_GetExecPrefix();
@NoException public static native @Cast("wchar_t*") Pointer Py_GetPath();
@NoException public static native void Py_SetPath(@Cast("const wchar_t*") Pointer arg0);
// #ifdef MS_WINDOWS
// #endif

/* In their own files */
@NoException public static native @Cast("const char*") BytePointer Py_GetVersion();
@NoException public static native @Cast("const char*") BytePointer Py_GetPlatform();
@NoException public static native @Cast("const char*") BytePointer Py_GetCopyright();
@NoException public static native @Cast("const char*") BytePointer Py_GetCompiler();
@NoException public static native @Cast("const char*") BytePointer Py_GetBuildInfo();
// Targeting ../PyOS_sighandler_t.java


@NoException public static native PyOS_sighandler_t PyOS_getsig(int arg0);
@NoException public static native PyOS_sighandler_t PyOS_setsig(int arg0, PyOS_sighandler_t arg1);

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_PYLIFECYCLE_H
// #  include  "cpython/pylifecycle.h"
// #  undef Py_CPYTHON_PYLIFECYCLE_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYLIFECYCLE_H */


// Parsed from cpython/pylifecycle.h

// #ifndef Py_CPYTHON_PYLIFECYCLE_H
// #  error "this header file must not be included directly"
// #endif

/* Py_FrozenMain is kept out of the Limited API until documented and present
   in all builds of Python */

/* Only used by applications that embed the interpreter and need to
 * override the standard encoding determination mechanism
 */
@NoException public static native int Py_SetStandardStreamEncoding(@Cast("const char*") BytePointer encoding,
                                             @Cast("const char*") BytePointer errors);
@NoException public static native int Py_SetStandardStreamEncoding(String encoding,
                                             String errors);

/* PEP 432 Multi-phase initialization API (Private while provisional!) */

@NoException public static native @ByVal PyStatus Py_PreInitialize(
    @Const PyPreConfig src_config);
@NoException public static native @ByVal PyStatus Py_PreInitializeFromBytesArgs(
    @Const PyPreConfig src_config,
    @Cast("Py_ssize_t") long argc,
    @Cast("char**") PointerPointer argv);
@NoException public static native @ByVal PyStatus Py_PreInitializeFromBytesArgs(
    @Const PyPreConfig src_config,
    @Cast("Py_ssize_t") long argc,
    @Cast("char**") @ByPtrPtr BytePointer argv);
@NoException public static native @ByVal PyStatus Py_PreInitializeFromBytesArgs(
    @Const PyPreConfig src_config,
    @Cast("Py_ssize_t") long argc,
    @Cast("char**") @ByPtrPtr ByteBuffer argv);
@NoException public static native @ByVal PyStatus Py_PreInitializeFromBytesArgs(
    @Const PyPreConfig src_config,
    @Cast("Py_ssize_t") long argc,
    @Cast("char**") @ByPtrPtr byte[] argv);
@NoException public static native @ByVal PyStatus Py_PreInitializeFromArgs(
    @Const PyPreConfig src_config,
    @Cast("Py_ssize_t") long argc,
    @Cast("wchar_t**") PointerPointer argv);
@NoException public static native @ByVal PyStatus Py_PreInitializeFromArgs(
    @Const PyPreConfig src_config,
    @Cast("Py_ssize_t") long argc,
    @Cast("wchar_t**") @ByPtrPtr Pointer argv);

@NoException public static native int _Py_IsCoreInitialized();


/* Initialization and finalization */

@NoException public static native @ByVal PyStatus Py_InitializeFromConfig(
    @Const PyConfig config);
@NoException public static native @ByVal PyStatus _Py_InitializeMain();

@NoException public static native int Py_RunMain();


@NoException public static native void Py_ExitStatusException(@ByVal PyStatus err);

/* Restore signals that the interpreter has called SIG_IGN on to SIG_DFL. */
@NoException public static native void _Py_RestoreSignals();

@NoException public static native int Py_FdIsInteractive(@Cast("FILE*") Pointer arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native int Py_FdIsInteractive(@Cast("FILE*") Pointer arg0, String arg1);
@NoException public static native int _Py_FdIsInteractive(@Cast("FILE*") Pointer fp, PyObject filename);

@NoException public static native void _Py_SetProgramFullPath(@Cast("const wchar_t*") Pointer arg0);

@NoException public static native @Cast("const char*") BytePointer _Py_gitidentifier();
@NoException public static native @Cast("const char*") BytePointer _Py_gitversion();

@NoException public static native int _Py_IsFinalizing();

/* Random */
@NoException public static native int _PyOS_URandom(Pointer buffer, @Cast("Py_ssize_t") long size);
@NoException public static native int _PyOS_URandomNonblock(Pointer buffer, @Cast("Py_ssize_t") long size);

/* Legacy locale support */
@NoException public static native int _Py_CoerceLegacyLocale(int warn);
@NoException public static native int _Py_LegacyLocaleDetected(int warn);
@NoException public static native @Cast("char*") BytePointer _Py_SetLocaleFromEnv(int category);

@NoException public static native PyThreadState _Py_NewInterpreter(int isolated_subinterpreter);


// Parsed from eval.h


/* Interface to execute compiled code */

// #ifndef Py_EVAL_H
// #define Py_EVAL_H
// #ifdef __cplusplus
// #endif

@NoException public static native PyObject PyEval_EvalCode(PyObject arg0, PyObject arg1, PyObject arg2);

@NoException public static native PyObject PyEval_EvalCodeEx(PyObject co,
                                         PyObject globals,
                                         PyObject locals,
                                         @Cast("PyObject*const*") PointerPointer args, int argc,
                                         @Cast("PyObject*const*") PointerPointer kwds, int kwdc,
                                         @Cast("PyObject*const*") PointerPointer defs, int defc,
                                         PyObject kwdefs, PyObject closure);
@NoException public static native PyObject PyEval_EvalCodeEx(PyObject co,
                                         PyObject globals,
                                         PyObject locals,
                                         @ByPtrPtr PyObject args, int argc,
                                         @ByPtrPtr PyObject kwds, int kwdc,
                                         @ByPtrPtr PyObject defs, int defc,
                                         PyObject kwdefs, PyObject closure);

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyEval_CallTracing(PyObject func, PyObject args);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_EVAL_H */


// Parsed from cpython/pyctype.h

// #ifndef Py_LIMITED_API
// #ifndef PYCTYPE_H
// #define PYCTYPE_H
// #ifdef __cplusplus
// #endif

public static final int PY_CTF_LOWER =  0x01;
public static final int PY_CTF_UPPER =  0x02;
public static final int PY_CTF_ALPHA =  (PY_CTF_LOWER|PY_CTF_UPPER);
public static final int PY_CTF_DIGIT =  0x04;
public static final int PY_CTF_ALNUM =  (PY_CTF_ALPHA|PY_CTF_DIGIT);
public static final int PY_CTF_SPACE =  0x08;
public static final int PY_CTF_XDIGIT = 0x10;

@MemberGetter public static native @Cast("const unsigned int") int _Py_ctype_table(int i);
@MemberGetter public static native @Cast("const unsigned int*") IntPointer _Py_ctype_table();

/* Unlike their C counterparts, the following macros are not meant to
 * handle an int with any of the values [EOF, 0-UCHAR_MAX]. The argument
 * must be a signed/unsigned char. */
// #define Py_ISLOWER(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_LOWER)
// #define Py_ISUPPER(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_UPPER)
// #define Py_ISALPHA(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_ALPHA)
// #define Py_ISDIGIT(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_DIGIT)
// #define Py_ISXDIGIT(c) (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_XDIGIT)
// #define Py_ISALNUM(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_ALNUM)
// #define Py_ISSPACE(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_SPACE)

@MemberGetter public static native @Cast("const unsigned char") byte _Py_ctype_tolower(int i);
@MemberGetter public static native @Cast("const unsigned char*") BytePointer _Py_ctype_tolower();
@MemberGetter public static native @Cast("const unsigned char") byte _Py_ctype_toupper(int i);
@MemberGetter public static native @Cast("const unsigned char*") BytePointer _Py_ctype_toupper();

// #define Py_TOLOWER(c) (_Py_ctype_tolower[Py_CHARMASK(c)])
// #define Py_TOUPPER(c) (_Py_ctype_toupper[Py_CHARMASK(c)])

// #ifdef __cplusplus
// #endif
// #endif /* !PYCTYPE_H */
// #endif /* !Py_LIMITED_API */


// Parsed from pystrtod.h

// #ifndef Py_STRTOD_H
// #define Py_STRTOD_H

// #ifdef __cplusplus
// #endif


@NoException public static native double PyOS_string_to_double(@Cast("const char*") BytePointer str,
                                         @Cast("char**") PointerPointer endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(@Cast("const char*") BytePointer str,
                                         @Cast("char**") @ByPtrPtr BytePointer endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(String str,
                                         @Cast("char**") @ByPtrPtr ByteBuffer endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(@Cast("const char*") BytePointer str,
                                         @Cast("char**") @ByPtrPtr byte[] endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(String str,
                                         @Cast("char**") @ByPtrPtr BytePointer endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(@Cast("const char*") BytePointer str,
                                         @Cast("char**") @ByPtrPtr ByteBuffer endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(String str,
                                         @Cast("char**") @ByPtrPtr byte[] endptr,
                                         PyObject overflow_exception);

/* The caller is responsible for calling PyMem_Free to free the buffer
   that's is returned. */
@NoException public static native @Cast("char*") BytePointer PyOS_double_to_string(double val,
                                         @Cast("char") byte format_code,
                                         int precision,
                                         int flags,
                                         IntPointer type);
@NoException public static native @Cast("char*") ByteBuffer PyOS_double_to_string(double val,
                                         @Cast("char") byte format_code,
                                         int precision,
                                         int flags,
                                         IntBuffer type);
@NoException public static native @Cast("char*") byte[] PyOS_double_to_string(double val,
                                         @Cast("char") byte format_code,
                                         int precision,
                                         int flags,
                                         int[] type);
// Targeting ../Innerfunc_BytePointer_long_Pointer.java


@NoException public static native PyObject _Py_string_to_number_with_underscores(
    @Cast("const char*") BytePointer str, @Cast("Py_ssize_t") long len, @Cast("const char*") BytePointer what, PyObject obj, Pointer arg,
    Innerfunc_BytePointer_long_Pointer innerfunc);
// Targeting ../Innerfunc_String_long_Pointer.java


@NoException public static native PyObject _Py_string_to_number_with_underscores(
    String str, @Cast("Py_ssize_t") long len, String what, PyObject obj, Pointer arg,
    Innerfunc_String_long_Pointer innerfunc);

@NoException public static native double _Py_parse_inf_or_nan(@Cast("const char*") BytePointer p, @Cast("char**") PointerPointer endptr);
@NoException public static native double _Py_parse_inf_or_nan(@Cast("const char*") BytePointer p, @Cast("char**") @ByPtrPtr BytePointer endptr);
@NoException public static native double _Py_parse_inf_or_nan(String p, @Cast("char**") @ByPtrPtr ByteBuffer endptr);
@NoException public static native double _Py_parse_inf_or_nan(@Cast("const char*") BytePointer p, @Cast("char**") @ByPtrPtr byte[] endptr);
@NoException public static native double _Py_parse_inf_or_nan(String p, @Cast("char**") @ByPtrPtr BytePointer endptr);
@NoException public static native double _Py_parse_inf_or_nan(@Cast("const char*") BytePointer p, @Cast("char**") @ByPtrPtr ByteBuffer endptr);
@NoException public static native double _Py_parse_inf_or_nan(String p, @Cast("char**") @ByPtrPtr byte[] endptr);
// #endif


/* PyOS_double_to_string's "flags" parameter can be set to 0 or more of: */
public static final int Py_DTSF_SIGN =      0x01; /* always add the sign */
public static final int Py_DTSF_ADD_DOT_0 = 0x02; /* if the result is an integer add ".0" */
public static final int Py_DTSF_ALT =       0x04; /* "alternate" formatting. it's format_code
                                  specific */

/* PyOS_double_to_string's "type", if non-NULL, will be set to one of: */
public static final int Py_DTST_FINITE = 0;
public static final int Py_DTST_INFINITE = 1;
public static final int Py_DTST_NAN = 2;

// #ifdef __cplusplus
// #endif

// #endif /* !Py_STRTOD_H */


// Parsed from pystrcmp.h

// #ifndef Py_STRCMP_H
// #define Py_STRCMP_H

// #ifdef __cplusplus
// #endif

@NoException public static native int PyOS_mystrnicmp(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("Py_ssize_t") long arg2);
@NoException public static native int PyOS_mystrnicmp(String arg0, String arg1, @Cast("Py_ssize_t") long arg2);
@NoException public static native int PyOS_mystricmp(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native int PyOS_mystricmp(String arg0, String arg1);

// #ifdef MS_WINDOWS
// #else
// #define PyOS_strnicmp PyOS_mystrnicmp
// #define PyOS_stricmp PyOS_mystricmp
// #endif

// #ifdef __cplusplus
// #endif

// #endif /* !Py_STRCMP_H */


// Parsed from fileutils.h

// #ifndef Py_FILEUTILS_H
// #define Py_FILEUTILS_H
// #ifdef __cplusplus
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
@NoException public static native @Cast("wchar_t*") Pointer Py_DecodeLocale(
    @Cast("const char*") BytePointer arg,
    @Cast("size_t*") SizeTPointer size);
@NoException public static native @Cast("wchar_t*") Pointer Py_DecodeLocale(
    String arg,
    @Cast("size_t*") SizeTPointer size);

@NoException public static native @Cast("char*") BytePointer Py_EncodeLocale(
    @Cast("const wchar_t*") Pointer text,
    @Cast("size_t*") SizeTPointer error_pos);
// #endif

// #ifndef Py_LIMITED_API
// #  define Py_CPYTHON_FILEUTILS_H
// #  include  "cpython/fileutils.h"
// #  undef Py_CPYTHON_FILEUTILS_H
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_FILEUTILS_H */


// Parsed from cpython/fileutils.h

// #ifndef Py_CPYTHON_FILEUTILS_H
// #  error "this header file must not be included directly"
// #endif

/** enum _Py_error_handler */
public static final int
    _Py_ERROR_UNKNOWN = 0,
    _Py_ERROR_STRICT = 1,
    _Py_ERROR_SURROGATEESCAPE = 2,
    _Py_ERROR_REPLACE = 3,
    _Py_ERROR_IGNORE = 4,
    _Py_ERROR_BACKSLASHREPLACE = 5,
    _Py_ERROR_SURROGATEPASS = 6,
    _Py_ERROR_XMLCHARREFREPLACE = 7,
    _Py_ERROR_OTHER = 8;

@NoException public static native @Cast("_Py_error_handler") int _Py_GetErrorHandler(@Cast("const char*") BytePointer errors);
@NoException public static native @Cast("_Py_error_handler") int _Py_GetErrorHandler(String errors);

@NoException public static native int _Py_DecodeLocaleEx(
    @Cast("const char*") BytePointer arg,
    @Cast("wchar_t**") PointerPointer wstr,
    @Cast("size_t*") SizeTPointer wlen,
    @Cast("const char**") PointerPointer reason,
    int current_locale,
    @Cast("_Py_error_handler") int errors);
@NoException public static native int _Py_DecodeLocaleEx(
    @Cast("const char*") BytePointer arg,
    @Cast("wchar_t**") @ByPtrPtr Pointer wstr,
    @Cast("size_t*") SizeTPointer wlen,
    @Cast("const char**") @ByPtrPtr BytePointer reason,
    int current_locale,
    @Cast("_Py_error_handler") int errors);
@NoException public static native int _Py_DecodeLocaleEx(
    String arg,
    @Cast("wchar_t**") @ByPtrPtr Pointer wstr,
    @Cast("size_t*") SizeTPointer wlen,
    @Cast("const char**") @ByPtrPtr ByteBuffer reason,
    int current_locale,
    @Cast("_Py_error_handler") int errors);
@NoException public static native int _Py_DecodeLocaleEx(
    @Cast("const char*") BytePointer arg,
    @Cast("wchar_t**") @ByPtrPtr Pointer wstr,
    @Cast("size_t*") SizeTPointer wlen,
    @Cast("const char**") @ByPtrPtr byte[] reason,
    int current_locale,
    @Cast("_Py_error_handler") int errors);
@NoException public static native int _Py_DecodeLocaleEx(
    String arg,
    @Cast("wchar_t**") @ByPtrPtr Pointer wstr,
    @Cast("size_t*") SizeTPointer wlen,
    @Cast("const char**") @ByPtrPtr BytePointer reason,
    int current_locale,
    @Cast("_Py_error_handler") int errors);
@NoException public static native int _Py_DecodeLocaleEx(
    @Cast("const char*") BytePointer arg,
    @Cast("wchar_t**") @ByPtrPtr Pointer wstr,
    @Cast("size_t*") SizeTPointer wlen,
    @Cast("const char**") @ByPtrPtr ByteBuffer reason,
    int current_locale,
    @Cast("_Py_error_handler") int errors);
@NoException public static native int _Py_DecodeLocaleEx(
    String arg,
    @Cast("wchar_t**") @ByPtrPtr Pointer wstr,
    @Cast("size_t*") SizeTPointer wlen,
    @Cast("const char**") @ByPtrPtr byte[] reason,
    int current_locale,
    @Cast("_Py_error_handler") int errors);

@NoException public static native int _Py_EncodeLocaleEx(
    @Cast("const wchar_t*") Pointer text,
    @Cast("char**") PointerPointer str,
    @Cast("size_t*") SizeTPointer error_pos,
    @Cast("const char**") PointerPointer reason,
    int current_locale,
    @Cast("_Py_error_handler") int errors);
@NoException public static native int _Py_EncodeLocaleEx(
    @Cast("const wchar_t*") Pointer text,
    @Cast("char**") @ByPtrPtr BytePointer str,
    @Cast("size_t*") SizeTPointer error_pos,
    @Cast("const char**") @ByPtrPtr BytePointer reason,
    int current_locale,
    @Cast("_Py_error_handler") int errors);
@NoException public static native int _Py_EncodeLocaleEx(
    @Cast("const wchar_t*") Pointer text,
    @Cast("char**") @ByPtrPtr ByteBuffer str,
    @Cast("size_t*") SizeTPointer error_pos,
    @Cast("const char**") @ByPtrPtr ByteBuffer reason,
    int current_locale,
    @Cast("_Py_error_handler") int errors);
@NoException public static native int _Py_EncodeLocaleEx(
    @Cast("const wchar_t*") Pointer text,
    @Cast("char**") @ByPtrPtr byte[] str,
    @Cast("size_t*") SizeTPointer error_pos,
    @Cast("const char**") @ByPtrPtr byte[] reason,
    int current_locale,
    @Cast("_Py_error_handler") int errors);

@NoException public static native @Cast("char*") BytePointer _Py_EncodeLocaleRaw(
    @Cast("const wchar_t*") Pointer text,
    @Cast("size_t*") SizeTPointer error_pos);

@NoException public static native PyObject _Py_device_encoding(int arg0);

// #if defined(MS_WINDOWS) || defined(__APPLE__)
    /* On Windows, the count parameter of read() is an int (bpo-9015, bpo-9611).
       On macOS 10.13, read() and write() with more than INT_MAX bytes
       fail with EINVAL (bpo-24658). */
public static final int _PY_READ_MAX =  INT_MAX;
public static final int _PY_WRITE_MAX = INT_MAX;
// #else
    /* write() should truncate the input to PY_SSIZE_T_MAX bytes,
       but it's safer to do it ourself to have a portable behaviour */
// #endif

// #ifdef MS_WINDOWS
// #else
// #endif

@NoException public static native int _Py_fstat(
    int fd,
    @Cast("struct _Py_stat_struct*") Pointer status);

@NoException public static native int _Py_fstat_noraise(
    int fd,
    @Cast("struct _Py_stat_struct*") Pointer status);

@NoException public static native int _Py_stat(
    PyObject path,
    @Cast("struct stat*") Pointer status);

@NoException public static native int _Py_open(
    @Cast("const char*") BytePointer pathname,
    int flags);
@NoException public static native int _Py_open(
    String pathname,
    int flags);

@NoException public static native int _Py_open_noraise(
    @Cast("const char*") BytePointer pathname,
    int flags);
@NoException public static native int _Py_open_noraise(
    String pathname,
    int flags);

@NoException public static native @Cast("FILE*") Pointer _Py_wfopen(
    @Cast("const wchar_t*") Pointer path,
    @Cast("const wchar_t*") Pointer mode);

@NoException public static native @Cast("FILE*") Pointer _Py_fopen_obj(
    PyObject path,
    @Cast("const char*") BytePointer mode);
@NoException public static native @Cast("FILE*") Pointer _Py_fopen_obj(
    PyObject path,
    String mode);

@NoException public static native @Cast("Py_ssize_t") long _Py_read(
    int fd,
    Pointer buf,
    @Cast("size_t") long count);

@NoException public static native @Cast("Py_ssize_t") long _Py_write(
    int fd,
    @Const Pointer buf,
    @Cast("size_t") long count);

@NoException public static native @Cast("Py_ssize_t") long _Py_write_noraise(
    int fd,
    @Const Pointer buf,
    @Cast("size_t") long count);

// #ifdef HAVE_READLINK

// #endif

// #ifdef HAVE_REALPATH

// #endif

// #ifndef MS_WINDOWS

// #endif

@NoException public static native int _Py_abspath(@Cast("const wchar_t*") Pointer path, @Cast("wchar_t**") PointerPointer abspath_p);
@NoException public static native int _Py_abspath(@Cast("const wchar_t*") Pointer path, @Cast("wchar_t**") @ByPtrPtr Pointer abspath_p);

@NoException public static native @Cast("wchar_t*") Pointer _Py_wgetcwd(
    @Cast("wchar_t*") Pointer buf,
    @Cast("size_t") long buflen);

@NoException public static native int _Py_get_inheritable(int fd);

@NoException public static native int _Py_set_inheritable(int fd, int inheritable,
                                    IntPointer atomic_flag_works);
@NoException public static native int _Py_set_inheritable(int fd, int inheritable,
                                    IntBuffer atomic_flag_works);
@NoException public static native int _Py_set_inheritable(int fd, int inheritable,
                                    int[] atomic_flag_works);

@NoException public static native int _Py_set_inheritable_async_safe(int fd, int inheritable,
                                               IntPointer atomic_flag_works);
@NoException public static native int _Py_set_inheritable_async_safe(int fd, int inheritable,
                                               IntBuffer atomic_flag_works);
@NoException public static native int _Py_set_inheritable_async_safe(int fd, int inheritable,
                                               int[] atomic_flag_works);

@NoException public static native int _Py_dup(int fd);

// #ifndef MS_WINDOWS



// #else   /* MS_WINDOWS */
// #endif  /* MS_WINDOWS */


// Parsed from cpython/pyfpe.h

// #ifndef Py_PYFPE_H
// #define Py_PYFPE_H
/* Header excluded from the stable API */
// #ifndef Py_LIMITED_API

/* These macros used to do something when Python was built with --with-fpectl,
 * but support for that was dropped in 3.7. We continue to define them though,
 * to avoid breaking API users.
 */

// #define PyFPE_START_PROTECT(err_string, leave_stmt)
// #define PyFPE_END_PROTECT(v)

// #endif /* !defined(Py_LIMITED_API) */
// #endif /* !Py_PYFPE_H */


// Parsed from tracemalloc.h

// #ifndef Py_TRACEMALLOC_H
// #define Py_TRACEMALLOC_H

// #ifndef Py_LIMITED_API
/* Track an allocated memory block in the tracemalloc module.
   Return 0 on success, return -1 on error (failed to allocate memory to store
   the trace).

   Return -2 if tracemalloc is disabled.

   If memory block is already tracked, update the existing trace. */
@NoException public static native int PyTraceMalloc_Track(
    @Cast("unsigned int") int domain,
    @Cast("uintptr_t") long ptr,
    @Cast("size_t") long size);

/* Untrack an allocated memory block in the tracemalloc module.
   Do nothing if the block was not tracked.

   Return -2 if tracemalloc is disabled, otherwise return 0. */
@NoException public static native int PyTraceMalloc_Untrack(
    @Cast("unsigned int") int domain,
    @Cast("uintptr_t") long ptr);

/* Get the traceback where a memory block was allocated.

   Return a tuple of (filename: str, lineno: int) tuples.

   Return None if the tracemalloc module is disabled or if the memory block
   is not tracked by tracemalloc.

   Raise an exception and return NULL on error. */
@NoException public static native PyObject _PyTraceMalloc_GetTraceback(
    @Cast("unsigned int") int domain,
    @Cast("uintptr_t") long ptr);
// #endif

// #endif /* !Py_TRACEMALLOC_H */


// Parsed from datetime.h

/*  datetime.h
 */
// #ifndef Py_LIMITED_API
// #ifndef DATETIME_H
// #define DATETIME_H
// #ifdef __cplusplus
// #endif

/* Fields are packed into successive bytes, each viewed as unsigned and
 * big-endian, unless otherwise noted:
 *
 * byte offset
 *  0           year     2 bytes, 1-9999
 *  2           month    1 byte, 1-12
 *  3           day      1 byte, 1-31
 *  4           hour     1 byte, 0-23
 *  5           minute   1 byte, 0-59
 *  6           second   1 byte, 0-59
 *  7           usecond  3 bytes, 0-999999
 * 10
 */

/* # of bytes for year, month, and day. */
public static final int _PyDateTime_DATE_DATASIZE = 4;

/* # of bytes for hour, minute, second, and usecond. */
public static final int _PyDateTime_TIME_DATASIZE = 6;

/* # of bytes for year, month, day, hour, minute, second, and usecond. */
public static final int _PyDateTime_DATETIME_DATASIZE = 10;
// Targeting ../PyDateTime_Delta.java


// Targeting ../PyDateTime_TZInfo.java




/* The datetime and time types have hashcodes, and an optional tzinfo member,
 * present if and only if hastzinfo is true.
 */
// #define _PyTZINFO_HEAD
//     PyObject_HEAD
//     Py_hash_t hashcode;
//     char hastzinfo;
// Targeting ../_PyDateTime_BaseTZInfo.java



/* All time objects are of PyDateTime_TimeType, but that can be allocated
 * in two ways, with or without a tzinfo member.  Without is the same as
 * tzinfo == None, but consumes less memory.  _PyDateTime_BaseTime is an
 * internal struct used to allocate the right amount of space for the
 * "without" case.
 */
// #define _PyDateTime_TIMEHEAD
//     _PyTZINFO_HEAD
//     unsigned char data[_PyDateTime_TIME_DATASIZE];
// Targeting ../_PyDateTime_BaseTime.java


// Targeting ../PyDateTime_Time.java


// Targeting ../PyDateTime_Date.java



// #define _PyDateTime_DATETIMEHEAD
//     _PyTZINFO_HEAD
//     unsigned char data[_PyDateTime_DATETIME_DATASIZE];
// Targeting ../_PyDateTime_BaseDateTime.java


// Targeting ../PyDateTime_DateTime.java

          /* hastzinfo true */


/* Apply for date and datetime instances. */

// o is a pointer to a time or a datetime object.
// #define _PyDateTime_HAS_TZINFO(o)  (((_PyDateTime_BaseTZInfo *)(o))->hastzinfo)

// #define PyDateTime_GET_YEAR(o)     ((((PyDateTime_Date*)o)->data[0] << 8) |
//                      ((PyDateTime_Date*)o)->data[1])
// #define PyDateTime_GET_MONTH(o)    (((PyDateTime_Date*)o)->data[2])
// #define PyDateTime_GET_DAY(o)      (((PyDateTime_Date*)o)->data[3])

// #define PyDateTime_DATE_GET_HOUR(o)        (((PyDateTime_DateTime*)o)->data[4])
// #define PyDateTime_DATE_GET_MINUTE(o)      (((PyDateTime_DateTime*)o)->data[5])
// #define PyDateTime_DATE_GET_SECOND(o)      (((PyDateTime_DateTime*)o)->data[6])
// #define PyDateTime_DATE_GET_MICROSECOND(o)
//     ((((PyDateTime_DateTime*)o)->data[7] << 16) |
//      (((PyDateTime_DateTime*)o)->data[8] << 8)  |
//       ((PyDateTime_DateTime*)o)->data[9])
// #define PyDateTime_DATE_GET_FOLD(o)        (((PyDateTime_DateTime*)o)->fold)
// #define PyDateTime_DATE_GET_TZINFO(o)      (_PyDateTime_HAS_TZINFO(o) ?
//     ((PyDateTime_DateTime *)(o))->tzinfo : Py_None)

/* Apply for time instances. */
// #define PyDateTime_TIME_GET_HOUR(o)        (((PyDateTime_Time*)o)->data[0])
// #define PyDateTime_TIME_GET_MINUTE(o)      (((PyDateTime_Time*)o)->data[1])
// #define PyDateTime_TIME_GET_SECOND(o)      (((PyDateTime_Time*)o)->data[2])
// #define PyDateTime_TIME_GET_MICROSECOND(o)
//     ((((PyDateTime_Time*)o)->data[3] << 16) |
//      (((PyDateTime_Time*)o)->data[4] << 8)  |
//       ((PyDateTime_Time*)o)->data[5])
// #define PyDateTime_TIME_GET_FOLD(o)        (((PyDateTime_Time*)o)->fold)
// #define PyDateTime_TIME_GET_TZINFO(o)      (_PyDateTime_HAS_TZINFO(o) ?
//     ((PyDateTime_Time *)(o))->tzinfo : Py_None)

/* Apply for time delta instances */
// #define PyDateTime_DELTA_GET_DAYS(o)         (((PyDateTime_Delta*)o)->days)
// #define PyDateTime_DELTA_GET_SECONDS(o)      (((PyDateTime_Delta*)o)->seconds)
// #define PyDateTime_DELTA_GET_MICROSECONDS(o)
//     (((PyDateTime_Delta*)o)->microseconds)
// Targeting ../PyDateTime_CAPI.java



public static final String PyDateTime_CAPSULE_NAME = "datetime.datetime_CAPI";


/* This block is only used as part of the public API and should not be
 * included in _datetimemodule.c, which does not use the C API capsule.
 * See bpo-35081 for more details.
 * */
// #ifndef _PY_DATETIME_IMPL
/* Define global variable for the C API and a macro for setting it. */
public static native PyDateTime_CAPI PyDateTimeAPI(); public static native void PyDateTimeAPI(PyDateTime_CAPI setter);

// #define PyDateTime_IMPORT
//     PyDateTimeAPI = (PyDateTime_CAPI *)PyCapsule_Import(PyDateTime_CAPSULE_NAME, 0)

/* Macro for access to the UTC singleton */
// #define PyDateTime_TimeZone_UTC PyDateTimeAPI->TimeZone_UTC

/* Macros for type checking when not building the Python core. */
// #define PyDate_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI->DateType)
// #define PyDate_CheckExact(op) Py_IS_TYPE(op, PyDateTimeAPI->DateType)

// #define PyDateTime_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI->DateTimeType)
// #define PyDateTime_CheckExact(op) Py_IS_TYPE(op, PyDateTimeAPI->DateTimeType)

// #define PyTime_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI->TimeType)
// #define PyTime_CheckExact(op) Py_IS_TYPE(op, PyDateTimeAPI->TimeType)

// #define PyDelta_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI->DeltaType)
// #define PyDelta_CheckExact(op) Py_IS_TYPE(op, PyDateTimeAPI->DeltaType)

// #define PyTZInfo_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI->TZInfoType)
// #define PyTZInfo_CheckExact(op) Py_IS_TYPE(op, PyDateTimeAPI->TZInfoType)


/* Macros for accessing constructors in a simplified fashion. */
// #define PyDate_FromDate(year, month, day)
//     PyDateTimeAPI->Date_FromDate(year, month, day, PyDateTimeAPI->DateType)

// #define PyDateTime_FromDateAndTime(year, month, day, hour, min, sec, usec)
//     PyDateTimeAPI->DateTime_FromDateAndTime(year, month, day, hour,
//         min, sec, usec, Py_None, PyDateTimeAPI->DateTimeType)

// #define PyDateTime_FromDateAndTimeAndFold(year, month, day, hour, min, sec, usec, fold)
//     PyDateTimeAPI->DateTime_FromDateAndTimeAndFold(year, month, day, hour,
//         min, sec, usec, Py_None, fold, PyDateTimeAPI->DateTimeType)

// #define PyTime_FromTime(hour, minute, second, usecond)
//     PyDateTimeAPI->Time_FromTime(hour, minute, second, usecond,
//         Py_None, PyDateTimeAPI->TimeType)

// #define PyTime_FromTimeAndFold(hour, minute, second, usecond, fold)
//     PyDateTimeAPI->Time_FromTimeAndFold(hour, minute, second, usecond,
//         Py_None, fold, PyDateTimeAPI->TimeType)

// #define PyDelta_FromDSU(days, seconds, useconds)
//     PyDateTimeAPI->Delta_FromDelta(days, seconds, useconds, 1,
//         PyDateTimeAPI->DeltaType)

// #define PyTimeZone_FromOffset(offset)
//     PyDateTimeAPI->TimeZone_FromTimeZone(offset, NULL)

// #define PyTimeZone_FromOffsetAndName(offset, name)
//     PyDateTimeAPI->TimeZone_FromTimeZone(offset, name)

/* Macros supporting the DB API. */
// #define PyDateTime_FromTimestamp(args)
//     PyDateTimeAPI->DateTime_FromTimestamp(
//         (PyObject*) (PyDateTimeAPI->DateTimeType), args, NULL)

// #define PyDate_FromTimestamp(args)
//     PyDateTimeAPI->Date_FromTimestamp(
//         (PyObject*) (PyDateTimeAPI->DateType), args)

// #endif   /* !defined(_PY_DATETIME_IMPL) */

// #ifdef __cplusplus
// #endif
// #endif
// #endif /* !Py_LIMITED_API */


}
