// Targeted by JavaCPP version 1.5-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.cpython.global;

import org.bytedeco.cpython.python.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class python extends org.bytedeco.cpython.presets.python {
    static { Loader.load(); }

// Parsed from Python.h

// #ifndef Py_PYTHON_H
// #define Py_PYTHON_H
/* Since this is a "meta-include" file, no #ifdef __cplusplus / extern "C" { */

/* Include nearly all Python header files */

// #include "patchlevel.h"
// #include "pyconfig.h"
// #include "pymacconfig.h"

// #include <limits.h>

// #ifndef UCHAR_MAX
// #error "Something's broken.  UCHAR_MAX should be defined in limits.h."
// #endif

// #if UCHAR_MAX != 255
// #error "Python's source code assumes C's unsigned char is an 8-bit type."
// #endif

// #if defined(__sgi) && defined(WITH_THREAD) && !defined(_SGI_MP_SOURCE)
// #define _SGI_MP_SOURCE
// #endif

// #include <stdio.h>
// #ifndef NULL
// #   error "Python.h requires that stdio.h define NULL."
// #endif

// #include <string.h>
// #ifdef HAVE_ERRNO_H
// #include <errno.h>
// #endif
// #include <stdlib.h>
// #ifdef HAVE_UNISTD_H
// #include <unistd.h>
// #endif
// #ifdef HAVE_CRYPT_H
// #include <crypt.h>
// #endif

/* For size_t? */
// #ifdef HAVE_STDDEF_H
// #include <stddef.h>
// #endif

/* CAUTION:  Build setups should ensure that NDEBUG is defined on the
 * compiler command line when building Python in release mode; else
 * assert() calls won't be removed.
 */
// #include <assert.h>

// #include "pyport.h"
// #include "pymacro.h"

// #include "pyatomic.h"

/* Debug-mode build with pymalloc implies PYMALLOC_DEBUG.
 *  PYMALLOC_DEBUG is in error if pymalloc is not in use.
 */
// #if defined(Py_DEBUG) && defined(WITH_PYMALLOC) && !defined(PYMALLOC_DEBUG)
// #define PYMALLOC_DEBUG
// #endif
// #if defined(PYMALLOC_DEBUG) && !defined(WITH_PYMALLOC)
// #error "PYMALLOC_DEBUG requires WITH_PYMALLOC"
// #endif
// #include "pymath.h"
// #include "pytime.h"
// #include "pymem.h"

// #include "object.h"
// #include "objimpl.h"
// #include "typeslots.h"
// #include "pyhash.h"

// #include "pydebug.h"

// #include "bytearrayobject.h"
// #include "bytesobject.h"
// #include "unicodeobject.h"
// #include "longobject.h"
// #include "longintrepr.h"
// #include "boolobject.h"
// #include "floatobject.h"
// #include "complexobject.h"
// #include "rangeobject.h"
// #include "memoryobject.h"
// #include "tupleobject.h"
// #include "listobject.h"
// #include "dictobject.h"
// #include "odictobject.h"
// #include "enumobject.h"
// #include "setobject.h"
// #include "methodobject.h"
// #include "moduleobject.h"
// #include "funcobject.h"
// #include "classobject.h"
// #include "fileobject.h"
// #include "pycapsule.h"
// #include "traceback.h"
// #include "sliceobject.h"
// #include "cellobject.h"
// #include "iterobject.h"
// #include "genobject.h"
// #include "descrobject.h"
// #include "warnings.h"
// #include "weakrefobject.h"
// #include "structseq.h"
// #include "namespaceobject.h"

// #include "codecs.h"
// #include "pyerrors.h"

// #include "pystate.h"

// #include "pyarena.h"
// #include "modsupport.h"
// #include "pythonrun.h"
// #include "pylifecycle.h"
// #include "ceval.h"
// #include "sysmodule.h"
// #include "osmodule.h"
// #include "intrcheck.h"
// #include "import.h"

// #include "abstract.h"
// #include "bltinmodule.h"

// #include "compile.h"
// #include "eval.h"

// #include "pyctype.h"
// #include "pystrtod.h"
// #include "pystrcmp.h"
// #include "dtoa.h"
// #include "fileutils.h"
// #include "pyfpe.h"

// #endif /* !Py_PYTHON_H */


// Parsed from patchlevel.h


/* Python version identification scheme.

   When the major or minor version changes, the VERSION variable in
   configure.ac must also be changed.

   There is also (independent) API version information in modsupport.h.
*/

/* Values for PY_RELEASE_LEVEL */
public static final int PY_RELEASE_LEVEL_ALPHA =	0xA;
public static final int PY_RELEASE_LEVEL_BETA =	0xB;
public static final int PY_RELEASE_LEVEL_GAMMA =	0xC;     /* For release candidates */
public static final int PY_RELEASE_LEVEL_FINAL =	0xF;	/* Serial should be 0 here */
					/* Higher for patch releases */

/* Version parsed out into numeric values */
/*--start constants--*/
public static final int PY_MAJOR_VERSION =	3;
public static final int PY_MINOR_VERSION =	6;
public static final int PY_MICRO_VERSION =	6;
public static final int PY_RELEASE_LEVEL =	PY_RELEASE_LEVEL_FINAL;
public static final int PY_RELEASE_SERIAL =	0;

/* Version as a string */
public static final String PY_VERSION =      	"3.6.6";
/*--end constants--*/

/* Version as a single 4-byte hex number, e.g. 0x010502B2 == 1.5.2b2.
   Use this for numeric comparisons, e.g. #if PY_VERSION_HEX >= ... */
public static final int PY_VERSION_HEX = ((PY_MAJOR_VERSION << 24) | 
			(PY_MINOR_VERSION << 16) | 
			(PY_MICRO_VERSION <<  8) | 
			(PY_RELEASE_LEVEL <<  4) | 
			(PY_RELEASE_SERIAL << 0));


// Parsed from pyconfig.h

// #include <bits/wordsize.h>

// #if __WORDSIZE == 32
// #include "pyconfig-32.h"
// #elif __WORDSIZE == 64
// #include "pyconfig-64.h"
// #else
// #error "Unknown word size"
// #endif


// Parsed from pymacconfig.h

// #ifndef PYMACCONFIG_H
// #define PYMACCONFIG_H
     /*
      * This file moves some of the autoconf magic to compile-time
      * when building on MacOSX. This is needed for building 4-way
      * universal binaries and for 64-bit universal binaries because
      * the values redefined below aren't configure-time constant but
      * only compile-time constant in these scenarios.
      */

// #if defined(__APPLE__)

// # undef SIZEOF_LONG
// # undef SIZEOF_PTHREAD_T
// # undef SIZEOF_SIZE_T
// # undef SIZEOF_TIME_T
// # undef SIZEOF_VOID_P
// # undef SIZEOF__BOOL
// # undef SIZEOF_UINTPTR_T
// # undef SIZEOF_PTHREAD_T
// # undef WORDS_BIGENDIAN
// # undef DOUBLE_IS_ARM_MIXED_ENDIAN_IEEE754
// # undef DOUBLE_IS_BIG_ENDIAN_IEEE754
// # undef DOUBLE_IS_LITTLE_ENDIAN_IEEE754
// # undef HAVE_GCC_ASM_FOR_X87

// #    undef VA_LIST_IS_ARRAY
// #    if defined(__LP64__) && defined(__x86_64__)
public static final int VA_LIST_IS_ARRAY = 1;
// #    endif

// #    undef HAVE_LARGEFILE_SUPPORT
// #    ifndef __LP64__
public static final int HAVE_LARGEFILE_SUPPORT = 1;
// #    endif

// #    undef SIZEOF_LONG
// #    ifdef __LP64__
public static final int SIZEOF__BOOL =            1;
public static final int SIZEOF_LONG =             8;
public static final int SIZEOF_PTHREAD_T =        8;
public static final int SIZEOF_SIZE_T =           8;
public static final int SIZEOF_TIME_T =           8;
public static final int SIZEOF_VOID_P =           8;
public static final int SIZEOF_UINTPTR_T =        8;
// #    else
// #        ifdef __ppc__
// #        else
// #        endif
// #    endif

// #    if defined(__LP64__)
     /* MacOSX 10.4 (the first release to support 64-bit code
      * at all) only supports 64-bit in the UNIX layer.
      * Therefore suppress the toolbox-glue in 64-bit mode.
      */

    /* In 64-bit mode setpgrp always has no arguments, in 32-bit
     * mode that depends on the compilation environment
     */
// #       undef SETPGRP_HAVE_ARG

// #    endif

// #ifdef __BIG_ENDIAN__
public static final int WORDS_BIGENDIAN = 1;
// #define DOUBLE_IS_BIG_ENDIAN_IEEE754
// #else
// #define DOUBLE_IS_LITTLE_ENDIAN_IEEE754
// #endif /* __BIG_ENDIAN */

// #ifdef __i386__
// # define HAVE_GCC_ASM_FOR_X87
// #endif

    /*
     * The definition in pyconfig.h is only valid on the OS release
     * where configure ran on and not necessarily for all systems where
     * the executable can be used on.
     *
     * Specifically: OSX 10.4 has limited supported for '%zd', while
     * 10.5 has full support for '%zd'. A binary built on 10.5 won't
     * work properly on 10.4 unless we suppress the definition
     * of PY_FORMAT_SIZE_T
     */
// #undef  PY_FORMAT_SIZE_T


// #endif /* defined(_APPLE__) */

// #endif /* PYMACCONFIG_H */


// Parsed from pyport.h

// #ifndef Py_PYPORT_H
// #define Py_PYPORT_H

// #include "pyconfig.h" /* include for defines */

// #include <inttypes.h>

/**************************************************************************
Symbols and macros to supply platform-independent interfaces to basic
C language & library operations whose spellings vary across platforms.
<p>
Please try to make documentation here as clear as possible:  by definition,
the stuff here is trying to illuminate C's darkest corners.
<p>
Config #defines referenced here:
<p>
SIGNED_RIGHT_SHIFT_ZERO_FILLS
Meaning:  To be defined iff i>>j does not extend the sign bit when i is a
          signed integral type and i < 0.
Used in:  Py_ARITHMETIC_RIGHT_SHIFT
<p>
Py_DEBUG
Meaning:  Extra checks compiled in for debug mode.
Used in:  Py_SAFE_DOWNCAST
<p>
**************************************************************************/

/* typedefs for some C9X-defined synonyms for integral types.
 *
 * The names in Python are exactly the same as the C9X names, except with a
 * Py_ prefix.  Until C9X is universally implemented, this is the only way
 * to ensure that Python gets reliable names that don't conflict with names
 * in non-Python code that are playing their own tricks to define the C9X
 * names.
 *
 * NOTE: don't go nuts here!  Python has no use for *most* of the C9X
 * integral synonyms.  Only define the ones we actually need.
 */

/* long long is required. Ensure HAVE_LONG_LONG is defined for compatibility. */
// #ifndef HAVE_LONG_LONG
public static final int HAVE_LONG_LONG = 1;
// #endif
// #ifndef PY_LONG_LONG
// #define PY_LONG_LONG long long
/* If LLONG_MAX is defined in limits.h, use that. */
public static native @MemberGetter int PY_LLONG_MIN();
public static final int PY_LLONG_MIN = PY_LLONG_MIN();
public static native @MemberGetter int PY_LLONG_MAX();
public static final int PY_LLONG_MAX = PY_LLONG_MAX();
public static native @MemberGetter int PY_ULLONG_MAX();
public static final int PY_ULLONG_MAX = PY_ULLONG_MAX();
// #endif

// #define PY_UINT32_T uint32_t
// #define PY_UINT64_T uint64_t

/* Signed variants of the above */
// #define PY_INT32_T int32_t
// #define PY_INT64_T int64_t

/* If PYLONG_BITS_IN_DIGIT is not defined then we'll use 30-bit digits if all
   the necessary integer types are available, and we're on a 64-bit platform
   (as determined by SIZEOF_VOID_P); otherwise we use 15-bit digits. */

// #ifndef PYLONG_BITS_IN_DIGIT
// #if SIZEOF_VOID_P >= 8
public static final int PYLONG_BITS_IN_DIGIT = 30;
// #else
// #endif
// #endif

/* uintptr_t is the C9X name for an unsigned integral type such that a
 * legitimate void* can be cast to uintptr_t and then back to void* again
 * without loss of information.  Similarly for intptr_t, wrt a signed
 * integral type.
 */

/* Py_ssize_t is a signed integral type such that sizeof(Py_ssize_t) ==
 * sizeof(size_t).  C99 doesn't define such a thing directly (size_t is an
 * unsigned integral type).  See PEP 353 for details.
 */
// #ifdef HAVE_SSIZE_T
// #elif SIZEOF_VOID_P == SIZEOF_SIZE_T
// #else
// #   error "Python needs a typedef for Py_ssize_t in pyport.h."
// #endif

/* Py_hash_t is the same size as a pointer. */
public static native @MemberGetter int SIZEOF_PY_HASH_T();
public static final int SIZEOF_PY_HASH_T = SIZEOF_PY_HASH_T();
/* Py_uhash_t is the unsigned equivalent needed to calculate numeric hash. */
public static native @MemberGetter int SIZEOF_PY_UHASH_T();
public static final int SIZEOF_PY_UHASH_T = SIZEOF_PY_UHASH_T();

/* Only used for compatibility with code that may not be PY_SSIZE_T_CLEAN. */
// #ifdef PY_SSIZE_T_CLEAN
// #else
// #endif

/* Largest possible value of size_t. */
public static native @MemberGetter int PY_SIZE_MAX();
public static final int PY_SIZE_MAX = PY_SIZE_MAX();

/* Largest positive value of type Py_ssize_t. */
public static native @MemberGetter int PY_SSIZE_T_MAX();
public static final int PY_SSIZE_T_MAX = PY_SSIZE_T_MAX();
/* Smallest negative value of type Py_ssize_t. */
public static native @MemberGetter int PY_SSIZE_T_MIN();
public static final int PY_SSIZE_T_MIN = PY_SSIZE_T_MIN();

/* PY_FORMAT_SIZE_T is a platform-specific modifier for use in a printf
 * format to convert an argument with the width of a size_t or Py_ssize_t.
 * C99 introduced "z" for this purpose, but not all platforms support that;
 * e.g., MS compilers use "I" instead.
 *
 * These "high level" Python format functions interpret "z" correctly on
 * all platforms (Python interprets the format string itself, and does whatever
 * the platform C requires to convert a size_t/Py_ssize_t argument):
 *
 *     PyBytes_FromFormat
 *     PyErr_Format
 *     PyBytes_FromFormatV
 *     PyUnicode_FromFormatV
 *
 * Lower-level uses require that you interpolate the correct format modifier
 * yourself (e.g., calling printf, fprintf, sprintf, PyOS_snprintf); for
 * example,
 *
 *     Py_ssize_t index;
 *     fprintf(stderr, "index %" PY_FORMAT_SIZE_T "d sucks\n", index);
 *
 * That will expand to %ld, or %Id, or to something else correct for a
 * Py_ssize_t on the platform.
 */
// #ifndef PY_FORMAT_SIZE_T
// #   if SIZEOF_SIZE_T == SIZEOF_INT && !defined(__APPLE__)
// #       define PY_FORMAT_SIZE_T ""
// #   elif SIZEOF_SIZE_T == SIZEOF_LONG
// #       define PY_FORMAT_SIZE_T "l"
// #   elif defined(MS_WINDOWS)
// #       define PY_FORMAT_SIZE_T "I"
// #   else
// #       error "This platform's pyconfig.h needs to define PY_FORMAT_SIZE_T"
// #   endif
// #endif

/* Py_LOCAL can be used instead of static to get the fastest possible calling
 * convention for functions that are local to a given module.
 *
 * Py_LOCAL_INLINE does the same thing, and also explicitly requests inlining,
 * for platforms that support that.
 *
 * If PY_LOCAL_AGGRESSIVE is defined before python.h is included, more
 * "aggressive" inlining/optimization is enabled for the entire module.  This
 * may lead to code bloat, and may slow things down for those reasons.  It may
 * also lead to errors, if the code relies on pointer aliasing.  Use with
 * care.
 *
 * NOTE: You can only use this for functions that are entirely local to a
 * module; functions that are exported via method tables, callbacks, etc,
 * should keep using static.
 */

// #if defined(_MSC_VER)
// #if defined(PY_LOCAL_AGGRESSIVE)
/* enable more aggressive optimization for visual studio */
// #pragma optimize("agtw", on)
// #endif
/* ignore warnings if the compiler decides not to inline a function */
// #pragma warning(disable: 4710)
/* fastest possible local call under MSVC */
// #define Py_LOCAL(type) static type __fastcall
// #define Py_LOCAL_INLINE(type) static __inline type __fastcall
// #elif defined(USE_INLINE)
// #define Py_LOCAL(type) static type
// #define Py_LOCAL_INLINE(type) static inline type
// #else
// #define Py_LOCAL(type) static type
// #define Py_LOCAL_INLINE(type) static type
// #endif

/* Py_MEMCPY is kept for backwards compatibility,
 * see https://bugs.python.org/issue28126 */
// #define Py_MEMCPY memcpy

// #include <stdlib.h>

// #ifdef HAVE_IEEEFP_H
// #include <ieeefp.h>  /* needed for 'finite' declaration on some platforms */
// #endif

// #include <math.h> /* Moved here from the math section, before extern "C" */

/********************************************
 * WRAPPER FOR <time.h> and/or <sys/time.h> *
 ********************************************/

// #ifdef TIME_WITH_SYS_TIME
// #include <sys/time.h>
// #include <time.h>
// #else /* !TIME_WITH_SYS_TIME */
// #ifdef HAVE_SYS_TIME_H
// #include <sys/time.h>
// #else /* !HAVE_SYS_TIME_H */
// #include <time.h>
// #endif /* !HAVE_SYS_TIME_H */
// #endif /* !TIME_WITH_SYS_TIME */


/******************************
 * WRAPPER FOR <sys/select.h> *
 ******************************/

/* NB caller must include <sys/types.h> */

// #ifdef HAVE_SYS_SELECT_H
// #include <sys/select.h>
// #endif /* !HAVE_SYS_SELECT_H */

/*******************************
 * stat() and fstat() fiddling *
 *******************************/

// #ifdef HAVE_SYS_STAT_H
// #include <sys/stat.h>
// #elif defined(HAVE_STAT_H)
// #include <stat.h>
// #endif

// #ifndef S_IFMT
/* VisualAge C/C++ Failed to Define MountType Field in sys/stat.h */
public static final int S_IFMT = 0170000;
// #endif

// #ifndef S_IFLNK
/* Windows doesn't define S_IFLNK but posixmodule.c maps
 * IO_REPARSE_TAG_SYMLINK to S_IFLNK */
public static final int S_IFLNK = 0120000;
// #endif

// #ifndef S_ISREG
// #define S_ISREG(x) (((x) & S_IFMT) == S_IFREG)
// #endif

// #ifndef S_ISDIR
// #define S_ISDIR(x) (((x) & S_IFMT) == S_IFDIR)
// #endif

// #ifndef S_ISCHR
// #define S_ISCHR(x) (((x) & S_IFMT) == S_IFCHR)
// #endif

// #ifdef __cplusplus
/* Move this down here since some C++ #include's don't like to be included
   inside an extern "C" */
// #endif


/* Py_ARITHMETIC_RIGHT_SHIFT
 * C doesn't define whether a right-shift of a signed integer sign-extends
 * or zero-fills.  Here a macro to force sign extension:
 * Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J)
 *    Return I >> J, forcing sign extension.  Arithmetically, return the
 *    floor of I/2**J.
 * Requirements:
 *    I should have signed integer type.  In the terminology of C99, this can
 *    be either one of the five standard signed integer types (signed char,
 *    short, int, long, long long) or an extended signed integer type.
 *    J is an integer >= 0 and strictly less than the number of bits in the
 *    type of I (because C doesn't define what happens for J outside that
 *    range either).
 *    TYPE used to specify the type of I, but is now ignored.  It's been left
 *    in for backwards compatibility with versions <= 2.6 or 3.0.
 * Caution:
 *    I may be evaluated more than once.
 */
// #ifdef SIGNED_RIGHT_SHIFT_ZERO_FILLS
// #define Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J)
//     ((I) < 0 ? -1-((-1-(I)) >> (J)) : (I) >> (J))
// #else
// #define Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J) ((I) >> (J))
// #endif

/* Py_FORCE_EXPANSION(X)
 * "Simply" returns its argument.  However, macro expansions within the
 * argument are evaluated.  This unfortunate trickery is needed to get
 * token-pasting to work as desired in some cases.
 */
// #define Py_FORCE_EXPANSION(X) X

/* Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW)
 * Cast VALUE to type NARROW from type WIDE.  In Py_DEBUG mode, this
 * assert-fails if any information is lost.
 * Caution:
 *    VALUE may be evaluated more than once.
 */
// #ifdef Py_DEBUG
// #else
// #define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) (NARROW)(VALUE)
// #endif

/* Py_SET_ERRNO_ON_MATH_ERROR(x)
 * If a libm function did not set errno, but it looks like the result
 * overflowed or not-a-number, set errno to ERANGE or EDOM.  Set errno
 * to 0 before calling a libm function, and invoke this macro after,
 * passing the function result.
 * Caution:
 *    This isn't reliable.  See Py_OVERFLOWED comments.
 *    X is evaluated more than once.
 */
// #if defined(__FreeBSD__) || defined(__OpenBSD__) || (defined(__hpux) && defined(__ia64))
// #define _Py_SET_EDOM_FOR_NAN(X) if (isnan(X)) errno = EDOM;
// #else
// #define _Py_SET_EDOM_FOR_NAN(X) ;
// #endif
// #define Py_SET_ERRNO_ON_MATH_ERROR(X)
//     do {
//         if (errno == 0) {
//             if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL)
//                 errno = ERANGE;
//             else _Py_SET_EDOM_FOR_NAN(X)
//         }
//     } while(0)

/* Py_SET_ERANGE_ON_OVERFLOW(x)
 * An alias of Py_SET_ERRNO_ON_MATH_ERROR for backward-compatibility.
 */
// #define Py_SET_ERANGE_IF_OVERFLOW(X) Py_SET_ERRNO_ON_MATH_ERROR(X)

/* Py_ADJUST_ERANGE1(x)
 * Py_ADJUST_ERANGE2(x, y)
 * Set errno to 0 before calling a libm function, and invoke one of these
 * macros after, passing the function result(s) (Py_ADJUST_ERANGE2 is useful
 * for functions returning complex results).  This makes two kinds of
 * adjustments to errno:  (A) If it looks like the platform libm set
 * errno=ERANGE due to underflow, clear errno. (B) If it looks like the
 * platform libm overflowed but didn't set errno, force errno to ERANGE.  In
 * effect, we're trying to force a useful implementation of C89 errno
 * behavior.
 * Caution:
 *    This isn't reliable.  See Py_OVERFLOWED comments.
 *    X and Y may be evaluated more than once.
 */
// #define Py_ADJUST_ERANGE1(X)
//     do {
//         if (errno == 0) {
//             if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL)
//                 errno = ERANGE;
//         }
//         else if (errno == ERANGE && (X) == 0.0)
//             errno = 0;
//     } while(0)

// #define Py_ADJUST_ERANGE2(X, Y)
//     do {
//         if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL ||
//             (Y) == Py_HUGE_VAL || (Y) == -Py_HUGE_VAL) {
//                         if (errno == 0)
//                                 errno = ERANGE;
//         }
//         else if (errno == ERANGE)
//             errno = 0;
//     } while(0)

/*  The functions _Py_dg_strtod and _Py_dg_dtoa in Python/dtoa.c (which are
 *  required to support the short float repr introduced in Python 3.1) require
 *  that the floating-point unit that's being used for arithmetic operations
 *  on C doubles is set to use 53-bit precision.  It also requires that the
 *  FPU rounding mode is round-half-to-even, but that's less often an issue.
 *
 *  If your FPU isn't already set to 53-bit precision/round-half-to-even, and
 *  you want to make use of _Py_dg_strtod and _Py_dg_dtoa, then you should
 *
 *     #define HAVE_PY_SET_53BIT_PRECISION 1
 *
 *  and also give appropriate definitions for the following three macros:
 *
 *    _PY_SET_53BIT_PRECISION_START : store original FPU settings, and
 *        set FPU to 53-bit precision/round-half-to-even
 *    _PY_SET_53BIT_PRECISION_END : restore original FPU settings
 *    _PY_SET_53BIT_PRECISION_HEADER : any variable declarations needed to
 *        use the two macros above.
 *
 * The macros are designed to be used within a single C function: see
 * Python/pystrtod.c for an example of their use.
 */

/* get and set x87 control word for gcc/x86 */
// #ifdef HAVE_GCC_ASM_FOR_X87
// #endif

/* get and set x87 control word for VisualStudio/x86 */
// #if defined(_MSC_VER) && !defined(_WIN64) /* x87 not supported in 64-bit */
// #endif

// #ifdef HAVE_GCC_ASM_FOR_MC68881
// #endif

/* default definitions are empty */
// #ifndef HAVE_PY_SET_53BIT_PRECISION
// #define _Py_SET_53BIT_PRECISION_HEADER
// #define _Py_SET_53BIT_PRECISION_START
// #define _Py_SET_53BIT_PRECISION_END
// #endif

/* If we can't guarantee 53-bit precision, don't use the code
   in Python/dtoa.c, but fall back to standard code.  This
   means that repr of a float will be long (17 sig digits).

   Realistically, there are two things that could go wrong:

   (1) doubles aren't IEEE 754 doubles, or
   (2) we're on x86 with the rounding precision set to 64-bits
       (extended precision), and we don't know how to change
       the rounding precision.
 */

// #if !defined(DOUBLE_IS_LITTLE_ENDIAN_IEEE754) &&
//     !defined(DOUBLE_IS_BIG_ENDIAN_IEEE754) &&
//     !defined(DOUBLE_IS_ARM_MIXED_ENDIAN_IEEE754)
// #define PY_NO_SHORT_FLOAT_REPR
// #endif

/* double rounding is symptomatic of use of extended precision on x86.  If
   we're seeing double rounding, and we don't have any mechanism available for
   changing the FPU rounding precision, then don't use Python/dtoa.c. */
// #if defined(X87_DOUBLE_ROUNDING) && !defined(HAVE_PY_SET_53BIT_PRECISION)
// #define PY_NO_SHORT_FLOAT_REPR
// #endif


/* Py_DEPRECATED(version)
 * Declare a variable, type, or function deprecated.
 * Usage:
 *    extern int old_var Py_DEPRECATED(2.3);
 *    typedef int T1 Py_DEPRECATED(2.4);
 *    extern int x() Py_DEPRECATED(2.5);
 */
// #if defined(__GNUC__) && ((__GNUC__ >= 4) ||
//               (__GNUC__ == 3) && (__GNUC_MINOR__ >= 1))
// #define Py_DEPRECATED(VERSION_UNUSED) __attribute__((__deprecated__))
// #else
// #define Py_DEPRECATED(VERSION_UNUSED)
// #endif

/**************************************************************************
Prototypes that are missing from the standard include files on some systems
(and possibly only some versions of such systems.)
<p>
Please be conservative with adding new ones, document them and enclose them
in platform-specific #ifdefs.
**************************************************************************/

// #ifdef SOLARIS
// #endif

// #ifdef HAVE__GETPTY
// #endif

/* On QNX 6, struct termio must be declared by including sys/termio.h
   if TCGETA, TCSETA, TCSETAW, or TCSETAF are used.  sys/termio.h must
   be included before termios.h or it will generate an error. */
// #if defined(HAVE_SYS_TERMIO_H) && !defined(__hpux)
// #include <sys/termio.h>
// #endif

// #if defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY)
// #endif /* defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY) */


/* On 4.4BSD-descendants, ctype functions serves the whole range of
 * wchar_t character set rather than single byte code points only.
 * This characteristic can break some operations of string object
 * including str.upper() and str.split() on UTF-8 locales.  This
 * workaround was provided by Tim Robbins of FreeBSD project.
 */

// #ifdef __FreeBSD__
// #include <osreldate.h>
// #if (__FreeBSD_version >= 500040 && __FreeBSD_version < 602113) ||
//     (__FreeBSD_version >= 700000 && __FreeBSD_version < 700054) ||
//     (__FreeBSD_version >= 800000 && __FreeBSD_version < 800001)
// # define _PY_PORT_CTYPE_UTF8_ISSUE
// #endif
// #endif


// #if defined(__APPLE__)
// # define _PY_PORT_CTYPE_UTF8_ISSUE
// #endif

// #ifdef _PY_PORT_CTYPE_UTF8_ISSUE
// #endif


/* Declarations for symbol visibility.

  PyAPI_FUNC(type): Declares a public Python API function and return type
  PyAPI_DATA(type): Declares public Python data and its type
  PyMODINIT_FUNC:   A Python module init function.  If these functions are
                    inside the Python core, they are private to the core.
                    If in an extension module, it may be declared with
                    external linkage depending on the platform.

  As a number of platforms support/require "__declspec(dllimport/dllexport)",
  we support a HAVE_DECLSPEC_DLL macro to save duplication.
*/

/*
  All windows ports, except cygwin, are handled in PC/pyconfig.h.

  Cygwin is the only other autoconf platform requiring special
  linkage handling and it uses __declspec().
*/
// #if defined(__CYGWIN__)
// #       define HAVE_DECLSPEC_DLL
// #endif

/* only get special linkage if built as shared or platform is Cygwin */
// #if defined(Py_ENABLE_SHARED) || defined(__CYGWIN__)
// #       if defined(HAVE_DECLSPEC_DLL)
// #               ifdef Py_BUILD_CORE
// #                       define PyAPI_FUNC(RTYPE) __declspec(dllexport) RTYPE
// #                       define PyAPI_DATA(RTYPE) extern __declspec(dllexport) RTYPE
        /* module init functions inside the core need no external linkage */
        /* except for Cygwin to handle embedding */
// #                       if defined(__CYGWIN__)
// #                               define PyMODINIT_FUNC __declspec(dllexport) PyObject*
// #                       else /* __CYGWIN__ */
// #                               define PyMODINIT_FUNC PyObject*
// #                       endif /* __CYGWIN__ */
// #               else /* Py_BUILD_CORE */
        /* Building an extension module, or an embedded situation */
        /* public Python functions and data are imported */
        /* Under Cygwin, auto-import functions to prevent compilation */
        /* failures similar to those described at the bottom of 4.1: */
        /* http://docs.python.org/extending/windows.html#a-cookbook-approach */
// #                       if !defined(__CYGWIN__)
// #                               define PyAPI_FUNC(RTYPE) __declspec(dllimport) RTYPE
// #                       endif /* !__CYGWIN__ */
// #                       define PyAPI_DATA(RTYPE) extern __declspec(dllimport) RTYPE
        /* module init functions outside the core must be exported */
// #                       if defined(__cplusplus)
// #                               define PyMODINIT_FUNC extern "C" __declspec(dllexport) PyObject*
// #                       else /* __cplusplus */
// #                               define PyMODINIT_FUNC __declspec(dllexport) PyObject*
// #                       endif /* __cplusplus */
// #               endif /* Py_BUILD_CORE */
// #       endif /* HAVE_DECLSPEC */
// #endif /* Py_ENABLE_SHARED */

/* If no external linkage macros defined by now, create defaults */
// #ifndef PyAPI_FUNC
// #       define PyAPI_FUNC(RTYPE) RTYPE
// #endif
// #ifndef PyAPI_DATA
// #       define PyAPI_DATA(RTYPE) extern RTYPE
// #endif
// #ifndef PyMODINIT_FUNC
// #       if defined(__cplusplus)
// #               define PyMODINIT_FUNC extern "C" PyObject*
// #       else /* __cplusplus */
// #               define PyMODINIT_FUNC PyObject*
// #       endif /* __cplusplus */
// #endif

/* limits.h constants that may be missing */

// #ifndef INT_MAX
public static final int INT_MAX = 2147483647;
// #endif

// #ifndef LONG_MAX
// #if SIZEOF_LONG == 4
public static final long LONG_MAX = 0X7FFFFFFFL;
// #elif SIZEOF_LONG == 8
// #else
// #error "could not set LONG_MAX in pyport.h"
// #endif
// #endif

// #ifndef LONG_MIN
public static final long LONG_MIN = (-LONG_MAX-1);
// #endif

// #ifndef LONG_BIT
public static native @MemberGetter int LONG_BIT();
public static final int LONG_BIT = LONG_BIT();
// #endif

// #if LONG_BIT != 8 * SIZEOF_LONG
/* 04-Oct-2000 LONG_BIT is apparently (mis)defined as 64 on some recent
 * 32-bit platforms using gcc.  We try to catch that here at compile-time
 * rather than waiting for integer multiplication to trigger bogus
 * overflows.
 */
// #error "LONG_BIT definition appears wrong for platform (bad gcc/glibc config?)."
// #endif

// #ifdef __cplusplus
// #endif

/*
 * Hide GCC attributes from compilers that don't support them.
 */
// #if (!defined(__GNUC__) || __GNUC__ < 2 ||
//      (__GNUC__ == 2 && __GNUC_MINOR__ < 7) )
// #define Py_GCC_ATTRIBUTE(x)
// #else
// #define Py_GCC_ATTRIBUTE(x) __attribute__(x)
// #endif

/*
 * Specify alignment on compilers that support it.
 */
// #if defined(__GNUC__) && __GNUC__ >= 3
// #define Py_ALIGNED(x) __attribute__((aligned(x)))
// #else
// #define Py_ALIGNED(x)
// #endif

/* Eliminate end-of-loop code not reached warnings from SunPro C
 * when using do{...}while(0) macros
 */
// #ifdef __SUNPRO_C
// #pragma error_messages (off,E_END_OF_LOOP_CODE_NOT_REACHED)
// #endif

// #ifndef Py_LL
// #define Py_LL(x) x##LL
// #endif

// #ifndef Py_ULL
// #define Py_ULL(x) Py_LL(x##U)
// #endif

// #define Py_VA_COPY va_copy

/*
 * Convenient macros to deal with endianness of the platform. WORDS_BIGENDIAN is
 * detected by configure and defined in pyconfig.h. The code in pyconfig.h
 * also takes care of Apple's universal builds.
 */

// #ifdef WORDS_BIGENDIAN
public static final int PY_BIG_ENDIAN = 1;
public static final int PY_LITTLE_ENDIAN = 0;
// #else
// #endif

// #ifdef Py_BUILD_CORE
/*
 * Macros to protect CRT calls against instant termination when passed an
 * invalid parameter (issue23524).
 */
// #if defined _MSC_VER && _MSC_VER >= 1900

// #else

// #define _Py_BEGIN_SUPPRESS_IPH
// #define _Py_END_SUPPRESS_IPH

// #endif /* _MSC_VER >= 1900 */
// #endif /* Py_BUILD_CORE */

// #ifdef __ANDROID__
// #include <android/api-evel.h>
// #endif

// #endif /* Py_PYPORT_H */


// Parsed from pymacro.h

// #ifndef Py_PYMACRO_H
// #define Py_PYMACRO_H

/* Minimum value between x and y */
// #define Py_MIN(x, y) (((x) > (y)) ? (y) : (x))

/* Maximum value between x and y */
// #define Py_MAX(x, y) (((x) > (y)) ? (x) : (y))

/* Absolute value of the number x */
// #define Py_ABS(x) ((x) < 0 ? -(x) : (x))

// #define _Py_XSTRINGIFY(x) #x

/* Convert the argument to a string. For example, Py_STRINGIFY(123) is replaced
   with "123" by the preprocessor. Defines are also replaced by their value.
   For example Py_STRINGIFY(__LINE__) is replaced by the line number, not
   by "__LINE__". */
// #define Py_STRINGIFY(x) _Py_XSTRINGIFY(x)

/* Get the size of a structure member in bytes */
// #define Py_MEMBER_SIZE(type, member) sizeof(((type *)0)->member)

/* Argument must be a char or an int in [-128, 127] or [0, 255]. */
// #define Py_CHARMASK(c) ((unsigned char)((c) & 0xff))

/* Assert a build-time dependency, as an expression.

   Your compile will fail if the condition isn't true, or can't be evaluated
   by the compiler. This can be used in an expression: its value is 0.

   Example:

   #define foo_to_char(foo)  \
       ((char *)(foo)        \
        + Py_BUILD_ASSERT_EXPR(offsetof(struct foo, string) == 0))

   Written by Rusty Russell, public domain, http://ccodearchive.net/ */
// #define Py_BUILD_ASSERT_EXPR(cond)
//     (sizeof(char [1 - 2*!(cond)]) - 1)

// #define Py_BUILD_ASSERT(cond)  do {
//         (void)Py_BUILD_ASSERT_EXPR(cond);
//     } while(0)

/* Get the number of elements in a visible array

   This does not work on pointers, or arrays declared as [], or function
   parameters. With correct compiler support, such usage will cause a build
   error (see Py_BUILD_ASSERT_EXPR).

   Written by Rusty Russell, public domain, http://ccodearchive.net/

   Requires at GCC 3.1+ */
// #if (defined(__GNUC__) && !defined(__STRICT_ANSI__) &&
//     (((__GNUC__ == 3) && (__GNU_MINOR__ >= 1)) || (__GNUC__ >= 4)))
/* Two gcc extensions.
   &a[0] degrades to a pointer: a different type from an array */
// #define Py_ARRAY_LENGTH(array)
//     (sizeof(array) / sizeof((array)[0])
//      + Py_BUILD_ASSERT_EXPR(!__builtin_types_compatible_p(typeof(array),
//                                                           typeof(&(array)[0]))))
// #else
// #define Py_ARRAY_LENGTH(array)
//     (sizeof(array) / sizeof((array)[0]))
// #endif


/* Define macros for inline documentation. */
// #define PyDoc_VAR(name) static char name[]
// #define PyDoc_STRVAR(name,str) PyDoc_VAR(name) = PyDoc_STR(str)
// #ifdef WITH_DOC_STRINGS
// #define PyDoc_STR(str) str
// #else
// #define PyDoc_STR(str) ""
// #endif

/* Below "a" is a power of 2. */
/* Round down size "n" to be a multiple of "a". */
// #define _Py_SIZE_ROUND_DOWN(n, a) ((size_t)(n) & ~(size_t)((a) - 1))
/* Round up size "n" to be a multiple of "a". */
// #define _Py_SIZE_ROUND_UP(n, a) (((size_t)(n) +
//         (size_t)((a) - 1)) & ~(size_t)((a) - 1))
/* Round pointer "p" down to the closest "a"-aligned address <= "p". */
// #define _Py_ALIGN_DOWN(p, a) ((void *)((uintptr_t)(p) & ~(uintptr_t)((a) - 1)))
/* Round pointer "p" up to the closest "a"-aligned address >= "p". */
// #define _Py_ALIGN_UP(p, a) ((void *)(((uintptr_t)(p) +
//         (uintptr_t)((a) - 1)) & ~(uintptr_t)((a) - 1)))
/* Check if pointer "p" is aligned to "a"-bytes boundary. */
// #define _Py_IS_ALIGNED(p, a) (!((uintptr_t)(p) & (uintptr_t)((a) - 1)))

// #ifdef __GNUC__
// #define Py_UNUSED(name) _unused_ ## name __attribute__((unused))
// #else
// #define Py_UNUSED(name) _unused_ ## name
// #endif

// #endif /* Py_PYMACRO_H */


// Parsed from pymath.h

// #ifndef Py_PYMATH_H
// #define Py_PYMATH_H

// #include "pyconfig.h" /* include for defines */

/**************************************************************************
Symbols and macros to supply platform-independent interfaces to mathematical
functions and constants
**************************************************************************/

/* Python provides implementations for copysign, round and hypot in
 * Python/pymath.c just in case your math library doesn't provide the
 * functions.
 *
 *Note: PC/pyconfig.h defines copysign as _copysign
 */
// #ifndef HAVE_COPYSIGN
// #endif

// #ifndef HAVE_ROUND
@NoException public static native double round(double arg0);
// #endif

// #ifndef HAVE_HYPOT
// #endif

/* extra declarations */
// #ifndef _MSC_VER
// #ifndef __STDC__
@NoException public static native double fmod(double arg0, double arg1);
@NoException public static native double frexp(double arg0, IntPointer arg1);
@NoException public static native double frexp(double arg0, IntBuffer arg1);
@NoException public static native double frexp(double arg0, int[] arg1);
@NoException public static native double ldexp(double arg0, int arg1);
@NoException public static native double modf(double arg0, DoublePointer arg1);
@NoException public static native double modf(double arg0, DoubleBuffer arg1);
@NoException public static native double modf(double arg0, double[] arg1);
@NoException public static native double pow(double arg0, double arg1);
// #endif /* __STDC__ */
// #endif /* _MSC_VER */

/* High precision definition of pi and e (Euler)
 * The values are taken from libc6's math.h.
 */
// #ifndef Py_MATH_PIl
public static final double Py_MATH_PIl = 3.1415926535897932384626433832795029;
// #endif
// #ifndef Py_MATH_PI
public static final double Py_MATH_PI = 3.14159265358979323846;
// #endif

// #ifndef Py_MATH_El
public static final double Py_MATH_El = 2.7182818284590452353602874713526625;
// #endif

// #ifndef Py_MATH_E
public static final double Py_MATH_E = 2.7182818284590452354;
// #endif

/* Tau (2pi) to 40 digits, taken from tauday.com/tau-digits. */
// #ifndef Py_MATH_TAU
public static final double Py_MATH_TAU = 6.2831853071795864769252867665590057683943;
// #endif


/* On x86, Py_FORCE_DOUBLE forces a floating-point number out of an x87 FPU
   register and into a 64-bit memory location, rounding from extended
   precision to double precision in the process.  On other platforms it does
   nothing. */

/* we take double rounding as evidence of x87 usage */
// #ifndef Py_LIMITED_API
// #ifndef Py_FORCE_DOUBLE
// #  ifdef X87_DOUBLE_ROUNDING
// #  else
// #    define Py_FORCE_DOUBLE(X) (X)
// #  endif
// #endif
// #endif

// #ifndef Py_LIMITED_API
// #ifdef HAVE_GCC_ASM_FOR_X87
// #endif
// #endif

/* Py_IS_NAN(X)
 * Return 1 if float or double arg is a NaN, else 0.
 * Caution:
 *     X is evaluated more than once.
 *     This may not work on all platforms.  Each platform has *some*
 *     way to spell this, though -- override in pyconfig.h if you have
 *     a platform where it doesn't work.
 * Note: PC/pyconfig.h defines Py_IS_NAN as _isnan
 */
// #ifndef Py_IS_NAN
// #if defined HAVE_DECL_ISNAN && HAVE_DECL_ISNAN == 1
// #define Py_IS_NAN(X) isnan(X)
// #else
// #define Py_IS_NAN(X) ((X) != (X))
// #endif
// #endif

/* Py_IS_INFINITY(X)
 * Return 1 if float or double arg is an infinity, else 0.
 * Caution:
 *    X is evaluated more than once.
 *    This implementation may set the underflow flag if |X| is very small;
 *    it really can't be implemented correctly (& easily) before C99.
 *    Override in pyconfig.h if you have a better spelling on your platform.
 *  Py_FORCE_DOUBLE is used to avoid getting false negatives from a
 *    non-infinite value v sitting in an 80-bit x87 register such that
 *    v becomes infinite when spilled from the register to 64-bit memory.
 * Note: PC/pyconfig.h defines Py_IS_INFINITY as _isinf
 */
// #ifndef Py_IS_INFINITY
// #  if defined HAVE_DECL_ISINF && HAVE_DECL_ISINF == 1
// #    define Py_IS_INFINITY(X) isinf(X)
// #  else
// #    define Py_IS_INFINITY(X) ((X) &&
//                                (Py_FORCE_DOUBLE(X)*0.5 == Py_FORCE_DOUBLE(X)))
// #  endif
// #endif

/* Py_IS_FINITE(X)
 * Return 1 if float or double arg is neither infinite nor NAN, else 0.
 * Some compilers (e.g. VisualStudio) have intrisics for this, so a special
 * macro for this particular test is useful
 * Note: PC/pyconfig.h defines Py_IS_FINITE as _finite
 */
// #ifndef Py_IS_FINITE
// #if defined HAVE_DECL_ISFINITE && HAVE_DECL_ISFINITE == 1
// #define Py_IS_FINITE(X) isfinite(X)
// #elif defined HAVE_FINITE
// #define Py_IS_FINITE(X) finite(X)
// #else
// #define Py_IS_FINITE(X) (!Py_IS_INFINITY(X) && !Py_IS_NAN(X))
// #endif
// #endif

/* HUGE_VAL is supposed to expand to a positive double infinity.  Python
 * uses Py_HUGE_VAL instead because some platforms are broken in this
 * respect.  We used to embed code in pyport.h to try to worm around that,
 * but different platforms are broken in conflicting ways.  If you're on
 * a platform where HUGE_VAL is defined incorrectly, fiddle your Python
 * config to #define Py_HUGE_VAL to something that works on your platform.
 */
// #ifndef Py_HUGE_VAL
// #define Py_HUGE_VAL HUGE_VAL
// #endif

/* Py_NAN
 * A value that evaluates to a NaN. On IEEE 754 platforms INF*0 or
 * INF/INF works. Define Py_NO_NAN in pyconfig.h if your platform
 * doesn't support NaNs.
 */
// #if !defined(Py_NAN) && !defined(Py_NO_NAN)
// #if !defined(__INTEL_COMPILER)
//     #define Py_NAN (Py_HUGE_VAL * 0.)
// #else /* __INTEL_COMPILER */
// #endif /* __INTEL_COMPILER */
// #endif

/* Py_OVERFLOWED(X)
 * Return 1 iff a libm function overflowed.  Set errno to 0 before calling
 * a libm function, and invoke this macro after, passing the function
 * result.
 * Caution:
 *    This isn't reliable.  C99 no longer requires libm to set errno under
 *        any exceptional condition, but does require +- HUGE_VAL return
 *        values on overflow.  A 754 box *probably* maps HUGE_VAL to a
 *        double infinity, and we're cool if that's so, unless the input
 *        was an infinity and an infinity is the expected result.  A C89
 *        system sets errno to ERANGE, so we check for that too.  We're
 *        out of luck if a C99 754 box doesn't map HUGE_VAL to +Inf, or
 *        if the returned result is a NaN, or if a C89 box returns HUGE_VAL
 *        in non-overflow cases.
 *    X is evaluated more than once.
 * Some platforms have better way to spell this, so expect some #ifdef'ery.
 *
 * OpenBSD uses 'isinf()' because a compiler bug on that platform causes
 * the longer macro version to be mis-compiled. This isn't optimal, and
 * should be removed once a newer compiler is available on that platform.
 * The system that had the failure was running OpenBSD 3.2 on Intel, with
 * gcc 2.95.3.
 *
 * According to Tim's checkin, the FreeBSD systems use isinf() to work
 * around a FPE bug on that platform.
 */
// #if defined(__FreeBSD__) || defined(__OpenBSD__)
// #define Py_OVERFLOWED(X) isinf(X)
// #else
// #define Py_OVERFLOWED(X) ((X) != 0.0 && (errno == ERANGE ||
//                                          (X) == Py_HUGE_VAL ||
//                                          (X) == -Py_HUGE_VAL))
// #endif

/* Return whether integral type *type* is signed or not. */
// #define _Py_IntegralTypeSigned(type) ((type)(-1) < 0)
/* Return the maximum value of integral type *type*. */
// #define _Py_IntegralTypeMax(type) ((_Py_IntegralTypeSigned(type)) ? (((((type)1 << (sizeof(type)*CHAR_BIT - 2)) - 1) << 1) + 1) : ~(type)0)
/* Return the minimum value of integral type *type*. */
// #define _Py_IntegralTypeMin(type) ((_Py_IntegralTypeSigned(type)) ? -_Py_IntegralTypeMax(type) - 1 : 0)
/* Check whether *v* is in the range of integral type *type*. This is most
 * useful if *v* is floating-point, since demoting a floating-point *v* to an
 * integral type that cannot represent *v*'s integral part is undefined
 * behavior. */
// #define _Py_InIntegralTypeRange(type, v) (_Py_IntegralTypeMin(type) <= v && v <= _Py_IntegralTypeMax(type))

// #endif /* Py_PYMATH_H */


// Parsed from pytime.h

// #ifndef Py_LIMITED_API
// #ifndef Py_PYTIME_H
// #define Py_PYTIME_H

// #include "pyconfig.h" /* include for defines */
// #include "object.h"

/**************************************************************************
Symbols and macros to supply platform-independent interfaces to time related
functions and constants
**************************************************************************/
// #ifdef __cplusplus
// #endif

/* _PyTime_t: Python timestamp with subsecond precision. It can be used to
   store a duration, and so indirectly a date (related to another date, like
   UNIX epoch). */
public static final int _PyTime_MIN = PY_LLONG_MIN;
public static final int _PyTime_MAX = PY_LLONG_MAX;

/** enum _PyTime_round_t */
public static final int
    /* Round towards minus infinity (-inf).
       For example, used to read a clock. */
    _PyTime_ROUND_FLOOR = 0,
    /* Round towards infinity (+inf).
       For example, used for timeout to wait "at least" N seconds. */
    _PyTime_ROUND_CEILING = 1,
    /* Round to nearest with ties going to nearest even integer.
       For example, used to round from a Python float. */
    _PyTime_ROUND_HALF_EVEN = 2,
    /* Round away from zero
       For example, used for timeout. _PyTime_ROUND_CEILING rounds
       -1e-9 to 0 milliseconds which causes bpo-31786 issue.
       _PyTime_ROUND_UP rounds -1e-9 to -1 millisecond which keeps
       the timeout sign as expected. select.poll(timeout) must block
       for negative values." */
    _PyTime_ROUND_UP = 3,
    /* _PyTime_ROUND_TIMEOUT (an alias for _PyTime_ROUND_UP) should be
       used for timeouts. */
    _PyTime_ROUND_TIMEOUT = _PyTime_ROUND_UP;


/* Convert a time_t to a PyLong. */
@NoException public static native PyObject _PyLong_FromTime_t(
    @ByVal @Cast("time_t*") Pointer sec);

/* Convert a PyLong to a time_t. */
@NoException public static native @ByVal @Cast("time_t*") Pointer _PyLong_AsTime_t(
    PyObject obj);

/* Convert a number of seconds, int or float, to time_t. */
@NoException public static native int _PyTime_ObjectToTime_t(
    PyObject obj,
    @Cast("time_t*") Pointer sec,
    @Cast("_PyTime_round_t") int arg2);

/* Convert a number of seconds, int or float, to a timeval structure.
   usec is in the range [0; 999999] and rounded towards zero.
   For example, -1.2 is converted to (-2, 800000). */
@NoException public static native int _PyTime_ObjectToTimeval(
    PyObject obj,
    @Cast("time_t*") Pointer sec,
    CLongPointer usec,
    @Cast("_PyTime_round_t") int arg3);

/* Convert a number of seconds, int or float, to a timespec structure.
   nsec is in the range [0; 999999999] and rounded towards zero.
   For example, -1.2 is converted to (-2, 800000000). */
@NoException public static native int _PyTime_ObjectToTimespec(
    PyObject obj,
    @Cast("time_t*") Pointer sec,
    CLongPointer nsec,
    @Cast("_PyTime_round_t") int arg3);


/* Create a timestamp from a number of seconds. */
@NoException public static native @Cast("_PyTime_t") long _PyTime_FromSeconds(int seconds);

/* Macro to create a timestamp from a number of seconds, no integer overflow.
   Only use the macro for small values, prefer _PyTime_FromSeconds(). */
// #define _PYTIME_FROMSECONDS(seconds)
//             ((_PyTime_t)(seconds) * (1000 * 1000 * 1000))

/* Create a timestamp from a number of nanoseconds. */
@NoException public static native @Cast("_PyTime_t") long _PyTime_FromNanoseconds(long ns);

/* Convert a number of seconds (Python float or int) to a timetamp.
   Raise an exception and return -1 on error, return 0 on success. */
@NoException public static native int _PyTime_FromSecondsObject(@Cast("_PyTime_t*") LongPointer t,
    PyObject obj,
    @Cast("_PyTime_round_t") int round);
@NoException public static native int _PyTime_FromSecondsObject(@Cast("_PyTime_t*") LongBuffer t,
    PyObject obj,
    @Cast("_PyTime_round_t") int round);
@NoException public static native int _PyTime_FromSecondsObject(@Cast("_PyTime_t*") long[] t,
    PyObject obj,
    @Cast("_PyTime_round_t") int round);

/* Convert a number of milliseconds (Python float or int, 10^-3) to a timetamp.
   Raise an exception and return -1 on error, return 0 on success. */
@NoException public static native int _PyTime_FromMillisecondsObject(@Cast("_PyTime_t*") LongPointer t,
    PyObject obj,
    @Cast("_PyTime_round_t") int round);
@NoException public static native int _PyTime_FromMillisecondsObject(@Cast("_PyTime_t*") LongBuffer t,
    PyObject obj,
    @Cast("_PyTime_round_t") int round);
@NoException public static native int _PyTime_FromMillisecondsObject(@Cast("_PyTime_t*") long[] t,
    PyObject obj,
    @Cast("_PyTime_round_t") int round);

/* Convert a timestamp to a number of seconds as a C double. */
@NoException public static native double _PyTime_AsSecondsDouble(@Cast("_PyTime_t") long t);

/* Convert timestamp to a number of milliseconds (10^-3 seconds). */
@NoException public static native @Cast("_PyTime_t") long _PyTime_AsMilliseconds(@Cast("_PyTime_t") long t,
    @Cast("_PyTime_round_t") int round);

/* Convert timestamp to a number of microseconds (10^-6 seconds). */
@NoException public static native @Cast("_PyTime_t") long _PyTime_AsMicroseconds(@Cast("_PyTime_t") long t,
    @Cast("_PyTime_round_t") int round);

/* Convert timestamp to a number of nanoseconds (10^-9 seconds) as a Python int
   object. */
@NoException public static native PyObject _PyTime_AsNanosecondsObject(@Cast("_PyTime_t") long t);

/* Convert a timestamp to a timeval structure (microsecond resolution).
   tv_usec is always positive.
   Raise an exception and return -1 if the conversion overflowed,
   return 0 on success. */
@NoException public static native int _PyTime_AsTimeval(@Cast("_PyTime_t") long t,
    @Cast("timeval*") Pointer tv,
    @Cast("_PyTime_round_t") int round);

/* Similar to _PyTime_AsTimeval(), but don't raise an exception on error. */
@NoException public static native int _PyTime_AsTimeval_noraise(@Cast("_PyTime_t") long t,
    @Cast("timeval*") Pointer tv,
    @Cast("_PyTime_round_t") int round);

/* Convert a timestamp to a number of seconds (secs) and microseconds (us).
   us is always positive. This function is similar to _PyTime_AsTimeval()
   except that secs is always a time_t type, whereas the timeval structure
   uses a C long for tv_sec on Windows.
   Raise an exception and return -1 if the conversion overflowed,
   return 0 on success. */
@NoException public static native int _PyTime_AsTimevalTime_t(
    @Cast("_PyTime_t") long t,
    @Cast("time_t*") Pointer secs,
    IntPointer us,
    @Cast("_PyTime_round_t") int round);
@NoException public static native int _PyTime_AsTimevalTime_t(
    @Cast("_PyTime_t") long t,
    @Cast("time_t*") Pointer secs,
    IntBuffer us,
    @Cast("_PyTime_round_t") int round);
@NoException public static native int _PyTime_AsTimevalTime_t(
    @Cast("_PyTime_t") long t,
    @Cast("time_t*") Pointer secs,
    int[] us,
    @Cast("_PyTime_round_t") int round);

// #if defined(HAVE_CLOCK_GETTIME) || defined(HAVE_KQUEUE)
// #endif

/* Get the current time from the system clock.

   The function cannot fail. _PyTime_Init() ensures that the system clock
   works. */
@NoException public static native @Cast("_PyTime_t") long _PyTime_GetSystemClock();

/* Get the time of a monotonic clock, i.e. a clock that cannot go backwards.
   The clock is not affected by system clock updates. The reference point of
   the returned value is undefined, so that only the difference between the
   results of consecutive calls is valid.

   The function cannot fail. _PyTime_Init() ensures that a monotonic clock
   is available and works. */
@NoException public static native @Cast("_PyTime_t") long _PyTime_GetMonotonicClock();
// Targeting ../python/_Py_clock_info_t.java



/* Get the current time from the system clock.
 * Fill clock information if info is not NULL.
 * Raise an exception and return -1 on error, return 0 on success.
 */
@NoException public static native int _PyTime_GetSystemClockWithInfo(
    @Cast("_PyTime_t*") LongPointer t,
    _Py_clock_info_t info);
@NoException public static native int _PyTime_GetSystemClockWithInfo(
    @Cast("_PyTime_t*") LongBuffer t,
    _Py_clock_info_t info);
@NoException public static native int _PyTime_GetSystemClockWithInfo(
    @Cast("_PyTime_t*") long[] t,
    _Py_clock_info_t info);

/* Get the time of a monotonic clock, i.e. a clock that cannot go backwards.
   The clock is not affected by system clock updates. The reference point of
   the returned value is undefined, so that only the difference between the
   results of consecutive calls is valid.

   Fill info (if set) with information of the function used to get the time.

   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyTime_GetMonotonicClockWithInfo(
    @Cast("_PyTime_t*") LongPointer t,
    _Py_clock_info_t info);
@NoException public static native int _PyTime_GetMonotonicClockWithInfo(
    @Cast("_PyTime_t*") LongBuffer t,
    _Py_clock_info_t info);
@NoException public static native int _PyTime_GetMonotonicClockWithInfo(
    @Cast("_PyTime_t*") long[] t,
    _Py_clock_info_t info);


/* Initialize time.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyTime_Init();

/* Converts a timestamp to the Gregorian time, using the local time zone.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyTime_localtime(@ByVal @Cast("time_t*") Pointer t, @Cast("tm*") Pointer tm);

/* Converts a timestamp to the Gregorian time, assuming UTC.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyTime_gmtime(@ByVal @Cast("time_t*") Pointer t, @Cast("tm*") Pointer tm);

// #ifdef __cplusplus
// #endif

// #endif /* Py_PYTIME_H */
// #endif /* Py_LIMITED_API */


// Parsed from pymem.h

/* The PyMem_ family:  low-level memory allocation interfaces.
   See objimpl.h for the PyObject_ memory family.
*/

// #ifndef Py_PYMEM_H
// #define Py_PYMEM_H

// #include "pyport.h"

// #ifdef __cplusplus
// #endif

// #ifndef Py_LIMITED_API
@NoException public static native Pointer PyMem_RawMalloc(@Cast("size_t") long size);
@NoException public static native Pointer PyMem_RawCalloc(@Cast("size_t") long nelem, @Cast("size_t") long elsize);
@NoException public static native Pointer PyMem_RawRealloc(Pointer ptr, @Cast("size_t") long new_size);
@NoException public static native void PyMem_RawFree(Pointer ptr);

/* Configure the Python memory allocators. Pass NULL to use default
   allocators. */
@NoException public static native int _PyMem_SetupAllocators(@Cast("const char*") BytePointer opt);
@NoException public static native int _PyMem_SetupAllocators(String opt);

// #ifdef WITH_PYMALLOC
@NoException public static native int _PyMem_PymallocEnabled();
// #endif

/* Identifier of an address space (domain) in tracemalloc */

/* Track an allocated memory block in the tracemalloc module.
   Return 0 on success, return -1 on error (failed to allocate memory to store
   the trace).

   Return -2 if tracemalloc is disabled.

   If memory block is already tracked, update the existing trace. */
@NoException public static native int _PyTraceMalloc_Track(
    @Cast("_PyTraceMalloc_domain_t") int domain,
    @Cast("uintptr_t") long ptr,
    @Cast("size_t") long size);

/* Untrack an allocated memory block in the tracemalloc module.
   Do nothing if the block was not tracked.

   Return -2 if tracemalloc is disabled, otherwise return 0. */
@NoException public static native int _PyTraceMalloc_Untrack(
    @Cast("_PyTraceMalloc_domain_t") int domain,
    @Cast("uintptr_t") long ptr);

/* Get the traceback where a memory block was allocated.

   Return a tuple of (filename: str, lineno: int) tuples.

   Return None if the tracemalloc module is disabled or if the memory block
   is not tracked by tracemalloc.

   Raise an exception and return NULL on error. */
@NoException public static native PyObject _PyTraceMalloc_GetTraceback(
    @Cast("_PyTraceMalloc_domain_t") int domain,
    @Cast("uintptr_t") long ptr);
// #endif   /* !Py_LIMITED_API */


/* BEWARE:

   Each interface exports both functions and macros.  Extension modules should
   use the functions, to ensure binary compatibility across Python versions.
   Because the Python implementation is free to change internal details, and
   the macros may (or may not) expose details for speed, if you do use the
   macros you must recompile your extensions with each Python release.

   Never mix calls to PyMem_ with calls to the platform malloc/realloc/
   calloc/free.  For example, on Windows different DLLs may end up using
   different heaps, and if you use PyMem_Malloc you'll get the memory from the
   heap used by the Python DLL; it could be a disaster if you free()'ed that
   directly in your own extension.  Using PyMem_Free instead ensures Python
   can return the memory to the proper heap.  As another example, in
   PYMALLOC_DEBUG mode, Python wraps all calls to all PyMem_ and PyObject_
   memory functions in special debugging wrappers that add additional
   debugging info to dynamic memory blocks.  The system routines have no idea
   what to do with that stuff, and the Python wrappers have no idea what to do
   with raw blocks obtained directly by the system routines then.

   The GIL must be held when using these APIs.
*/

/*
 * Raw memory interface
 * ====================
 */

/* Functions

   Functions supplying platform-independent semantics for malloc/realloc/
   free.  These functions make sure that allocating 0 bytes returns a distinct
   non-NULL pointer (whenever possible -- if we're flat out of memory, NULL
   may be returned), even if the platform malloc and realloc don't.
   Returned pointers must be checked for NULL explicitly.  No action is
   performed on failure (no exception is set, no warning is printed, etc).
*/

@NoException public static native Pointer PyMem_Malloc(@Cast("size_t") long size);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
@NoException public static native Pointer PyMem_Calloc(@Cast("size_t") long nelem, @Cast("size_t") long elsize);
// #endif
@NoException public static native Pointer PyMem_Realloc(Pointer ptr, @Cast("size_t") long new_size);
@NoException public static native void PyMem_Free(Pointer ptr);

// #ifndef Py_LIMITED_API
@NoException public static native @Cast("char*") BytePointer _PyMem_RawStrdup(@Cast("const char*") BytePointer str);
@NoException public static native @Cast("char*") ByteBuffer _PyMem_RawStrdup(String str);
@NoException public static native @Cast("char*") BytePointer _PyMem_Strdup(@Cast("const char*") BytePointer str);
@NoException public static native @Cast("char*") ByteBuffer _PyMem_Strdup(String str);
// #endif

/* Macros. */

/* PyMem_MALLOC(0) means malloc(1). Some systems would return NULL
   for malloc(0), which would be treated as an error. Some platforms
   would return a pointer with no memory behind it, which would break
   pymalloc. To solve these problems, allocate an extra byte. */
/* Returns NULL to indicate error if a negative size or size larger than
   Py_ssize_t can represent is supplied.  Helps prevents security holes. */
// #define PyMem_MALLOC(n)         PyMem_Malloc(n)
// #define PyMem_REALLOC(p, n)     PyMem_Realloc(p, n)
// #define PyMem_FREE(p)           PyMem_Free(p)

/*
 * Type-oriented memory interface
 * ==============================
 *
 * Allocate memory for n objects of the given type.  Returns a new pointer
 * or NULL if the request was too large or memory allocation failed.  Use
 * these macros rather than doing the multiplication yourself so that proper
 * overflow checking is always done.
 */

// #define PyMem_New(type, n)
//   ( ((size_t)(n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL :
// 	( (type *) PyMem_Malloc((n) * sizeof(type)) ) )
// #define PyMem_NEW(type, n)
//   ( ((size_t)(n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL :
// 	( (type *) PyMem_MALLOC((n) * sizeof(type)) ) )

/*
 * The value of (p) is always clobbered by this macro regardless of success.
 * The caller MUST check if (p) is NULL afterwards and deal with the memory
 * error if so.  This means the original value of (p) MUST be saved for the
 * caller's memory error handler to not lose track of it.
 */
// #define PyMem_Resize(p, type, n)
//   ( (p) = ((size_t)(n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL :
// 	(type *) PyMem_Realloc((p), (n) * sizeof(type)) )
// #define PyMem_RESIZE(p, type, n)
//   ( (p) = ((size_t)(n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL :
// 	(type *) PyMem_REALLOC((p), (n) * sizeof(type)) )

/* PyMem{Del,DEL} are left over from ancient days, and shouldn't be used
 * anymore.  They're just confusing aliases for PyMem_{Free,FREE} now.
 */
// #define PyMem_Del		PyMem_Free
// #define PyMem_DEL		PyMem_FREE

// #ifndef Py_LIMITED_API
/** enum PyMemAllocatorDomain */
public static final int
    /* PyMem_RawMalloc(), PyMem_RawRealloc() and PyMem_RawFree() */
    PYMEM_DOMAIN_RAW = 0,

    /* PyMem_Malloc(), PyMem_Realloc() and PyMem_Free() */
    PYMEM_DOMAIN_MEM = 1,

    /* PyObject_Malloc(), PyObject_Realloc() and PyObject_Free() */
    PYMEM_DOMAIN_OBJ = 2;
// Targeting ../python/PyMemAllocatorEx.java



/* Get the memory block allocator of the specified domain. */
@NoException public static native void PyMem_GetAllocator(@Cast("PyMemAllocatorDomain") int domain,
                                    PyMemAllocatorEx allocator);

/* Set the memory block allocator of the specified domain.

   The new allocator must return a distinct non-NULL pointer when requesting
   zero bytes.

   For the PYMEM_DOMAIN_RAW domain, the allocator must be thread-safe: the GIL
   is not held when the allocator is called.

   If the new allocator is not a hook (don't call the previous allocator), the
   PyMem_SetupDebugHooks() function must be called to reinstall the debug hooks
   on top on the new allocator. */
@NoException public static native void PyMem_SetAllocator(@Cast("PyMemAllocatorDomain") int domain,
                                    PyMemAllocatorEx allocator);

/* Setup hooks to detect bugs in the following Python memory allocator
   functions:

   - PyMem_RawMalloc(), PyMem_RawRealloc(), PyMem_RawFree()
   - PyMem_Malloc(), PyMem_Realloc(), PyMem_Free()
   - PyObject_Malloc(), PyObject_Realloc() and PyObject_Free()

   Newly allocated memory is filled with the byte 0xCB, freed memory is filled
   with the byte 0xDB. Additionnal checks:

   - detect API violations, ex: PyObject_Free() called on a buffer allocated
     by PyMem_Malloc()
   - detect write before the start of the buffer (buffer underflow)
   - detect write after the end of the buffer (buffer overflow)

   The function does nothing if Python is not compiled is debug mode. */
@NoException public static native void PyMem_SetupDebugHooks();
// #endif

// #ifdef __cplusplus
// #endif

// #endif /* !Py_PYMEM_H */


// Parsed from object.h

// #ifndef Py_OBJECT_H
// #define Py_OBJECT_H
// #ifdef __cplusplus
// #endif


/* Object and type object interface */

/*
Objects are structures allocated on the heap.  Special rules apply to
the use of objects to ensure they are properly garbage-collected.
Objects are never allocated statically or on the stack; they must be
accessed through special macros and functions only.  (Type objects are
exceptions to the first rule; the standard types are represented by
statically initialized type objects, although work on type/class unification
for Python 2.2 made it possible to have heap-allocated type objects too).

An object has a 'reference count' that is increased or decreased when a
pointer to the object is copied or deleted; when the reference count
reaches zero there are no references to the object left and it can be
removed from the heap.

An object has a 'type' that determines what it represents and what kind
of data it contains.  An object's type is fixed when it is created.
Types themselves are represented as objects; an object contains a
pointer to the corresponding type object.  The type itself has a type
pointer pointing to the object representing the type 'type', which
contains a pointer to itself!).

Objects do not float around in memory; once allocated an object keeps
the same size and address.  Objects that must hold variable-size data
can contain pointers to variable-size parts of the object.  Not all
objects of the same type have the same size; but the size cannot change
after allocation.  (These restrictions are made so a reference to an
object can be simply a pointer -- moving an object would require
updating all the pointers, and changing an object's size would require
moving it if there was another object right next to it.)

Objects are always accessed through pointers of the type 'PyObject *'.
The type 'PyObject' is a structure that only contains the reference count
and the type pointer.  The actual memory allocated for an object
contains other data that can only be accessed after casting the pointer
to a pointer to a longer structure type.  This longer type must start
with the reference count and type fields; the macro PyObject_HEAD should be
used for this (to accommodate for future changes).  The implementation
of a particular object type can cast the object pointer to the proper
type and back.

A standard interface exists for objects that contain an array of items
whose size is determined when the object is allocated.
*/

/* Py_DEBUG implies Py_TRACE_REFS. */
// #if defined(Py_DEBUG) && !defined(Py_TRACE_REFS)
// #define Py_TRACE_REFS
// #endif

/* Py_TRACE_REFS implies Py_REF_DEBUG. */
// #if defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG)
// #define Py_REF_DEBUG
// #endif

// #if defined(Py_LIMITED_API) && defined(Py_REF_DEBUG)
// #error Py_LIMITED_API is incompatible with Py_DEBUG, Py_TRACE_REFS, and Py_REF_DEBUG
// #endif


// #ifdef Py_TRACE_REFS

// #else
// #define _PyObject_HEAD_EXTRA
// #define _PyObject_EXTRA_INIT
// #endif

/* PyObject_HEAD defines the initial segment of every PyObject. */
// #define PyObject_HEAD                   PyObject ob_base;

// #define PyObject_HEAD_INIT(type)
//     { _PyObject_EXTRA_INIT
//     1, type },

// #define PyVarObject_HEAD_INIT(type, size)
//     { PyObject_HEAD_INIT(type) size },

/* PyObject_VAR_HEAD defines the initial segment of all variable-size
 * container objects.  These end with a declaration of an array with 1
 * element, but enough space is malloc'ed so that the array actually
 * has room for ob_size elements.  Note that ob_size is an element count,
 * not necessarily a byte count.
 */
// #define PyObject_VAR_HEAD      PyVarObject ob_base;
public static final long Py_INVALID_SIZE = (long)-1;
// Targeting ../python/PyObject.java


// Targeting ../python/PyVarObject.java



// #define Py_REFCNT(ob)           (((PyObject*)(ob))->ob_refcnt)
// #define Py_TYPE(ob)             (((PyObject*)(ob))->ob_type)
// #define Py_SIZE(ob)             (((PyVarObject*)(ob))->ob_size)
// Targeting ../python/_Py_Identifier.java



// #define _Py_static_string_init(value) { .next = NULL, .string = value, .object = NULL }
// #define _Py_static_string(varname, value)  static _Py_Identifier varname = _Py_static_string_init(value)
// #define _Py_IDENTIFIER(varname) _Py_static_string(PyId_##varname, #varname)
// Targeting ../python/unaryfunc.java


// Targeting ../python/binaryfunc.java


// Targeting ../python/ternaryfunc.java


// Targeting ../python/inquiry.java


// Targeting ../python/lenfunc.java


// Targeting ../python/ssizeargfunc.java


// Targeting ../python/ssizessizeargfunc.java


// Targeting ../python/ssizeobjargproc.java


// Targeting ../python/ssizessizeobjargproc.java


// Targeting ../python/objobjargproc.java


// Targeting ../python/Py_buffer.java


// Targeting ../python/getbufferproc.java


// Targeting ../python/releasebufferproc.java



/* Maximum number of dimensions */
public static final int PyBUF_MAX_NDIM = 64;

/* Flags for getting buffers */
public static final int PyBUF_SIMPLE = 0;
public static final int PyBUF_WRITABLE = 0x0001;
/*  we used to include an E, backwards compatible alias  */
public static final int PyBUF_WRITEABLE = PyBUF_WRITABLE;
public static final int PyBUF_FORMAT = 0x0004;
public static final int PyBUF_ND = 0x0008;
public static final int PyBUF_STRIDES = (0x0010 | PyBUF_ND);
public static final int PyBUF_C_CONTIGUOUS = (0x0020 | PyBUF_STRIDES);
public static final int PyBUF_F_CONTIGUOUS = (0x0040 | PyBUF_STRIDES);
public static final int PyBUF_ANY_CONTIGUOUS = (0x0080 | PyBUF_STRIDES);
public static final int PyBUF_INDIRECT = (0x0100 | PyBUF_STRIDES);

public static final int PyBUF_CONTIG = (PyBUF_ND | PyBUF_WRITABLE);
public static final int PyBUF_CONTIG_RO = (PyBUF_ND);

public static final int PyBUF_STRIDED = (PyBUF_STRIDES | PyBUF_WRITABLE);
public static final int PyBUF_STRIDED_RO = (PyBUF_STRIDES);

public static final int PyBUF_RECORDS = (PyBUF_STRIDES | PyBUF_WRITABLE | PyBUF_FORMAT);
public static final int PyBUF_RECORDS_RO = (PyBUF_STRIDES | PyBUF_FORMAT);

public static final int PyBUF_FULL = (PyBUF_INDIRECT | PyBUF_WRITABLE | PyBUF_FORMAT);
public static final int PyBUF_FULL_RO = (PyBUF_INDIRECT | PyBUF_FORMAT);


public static final int PyBUF_READ =  0x100;
public static final int PyBUF_WRITE = 0x200;
// Targeting ../python/objobjproc.java


// Targeting ../python/visitproc.java


// Targeting ../python/traverseproc.java


// Targeting ../python/PyNumberMethods.java


// Targeting ../python/PySequenceMethods.java


// Targeting ../python/PyMappingMethods.java


// Targeting ../python/PyAsyncMethods.java


// Targeting ../python/PyBufferProcs.java


// Targeting ../python/freefunc.java


// Targeting ../python/destructor.java


// Targeting ../python/printfunc.java


// Targeting ../python/getattrfunc.java


// Targeting ../python/getattrofunc.java


// Targeting ../python/setattrfunc.java


// Targeting ../python/setattrofunc.java


// Targeting ../python/reprfunc.java


// Targeting ../python/hashfunc.java


// Targeting ../python/richcmpfunc.java


// Targeting ../python/getiterfunc.java


// Targeting ../python/iternextfunc.java


// Targeting ../python/descrgetfunc.java


// Targeting ../python/descrsetfunc.java


// Targeting ../python/initproc.java


// Targeting ../python/newfunc.java


// Targeting ../python/allocfunc.java



// #ifdef Py_LIMITED_API
// Targeting ../python/PyTypeObject.java


// Targeting ../python/PyType_Slot.java


// Targeting ../python/PyType_Spec.java



@NoException public static native PyObject PyType_FromSpec(PyType_Spec arg0);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyType_FromSpecWithBases(PyType_Spec arg0, PyObject arg1);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
@NoException public static native Pointer PyType_GetSlot(PyTypeObject arg0, int arg1);
// Targeting ../python/PyHeapTypeObject.java



/* access macro to the members which are floating "behind" the object */
// #define PyHeapType_GET_MEMBERS(etype)
//     ((PyMemberDef *)(((char *)etype) + Py_TYPE(etype)->tp_basicsize))
// #endif

/* Generic type check */
@NoException public static native int PyType_IsSubtype(PyTypeObject arg0, PyTypeObject arg1);
// #define PyObject_TypeCheck(ob, tp)
//     (Py_TYPE(ob) == (tp) || PyType_IsSubtype(Py_TYPE(ob), (tp)))

public static native @ByRef PyTypeObject PyType_Type(); public static native void PyType_Type(PyTypeObject PyType_Type); /* built-in 'type' */
public static native @ByRef PyTypeObject PyBaseObject_Type(); public static native void PyBaseObject_Type(PyTypeObject PyBaseObject_Type); /* built-in 'object' */
public static native @ByRef PyTypeObject PySuper_Type(); public static native void PySuper_Type(PyTypeObject PySuper_Type); /* built-in 'super' */

@NoException public static native @Cast("unsigned long") long PyType_GetFlags(PyTypeObject arg0);

// #define PyType_Check(op)
//     PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS)
// #define PyType_CheckExact(op) (Py_TYPE(op) == &PyType_Type)

@NoException public static native int PyType_Ready(PyTypeObject arg0);
@NoException public static native PyObject PyType_GenericAlloc(PyTypeObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native PyObject PyType_GenericNew(PyTypeObject arg0,
                                               PyObject arg1, PyObject arg2);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyType_Lookup(PyTypeObject arg0, PyObject arg1);
@NoException public static native PyObject _PyType_LookupId(PyTypeObject arg0, _Py_Identifier arg1);
@NoException public static native PyObject _PyObject_LookupSpecial(PyObject arg0, _Py_Identifier arg1);
@NoException public static native PyTypeObject _PyType_CalculateMetaclass(PyTypeObject arg0, PyObject arg1);
// #endif
@NoException public static native @Cast("unsigned int") int PyType_ClearCache();
@NoException public static native void PyType_Modified(PyTypeObject arg0);

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyType_GetDocFromInternalDoc(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native PyObject _PyType_GetDocFromInternalDoc(String arg0, String arg1);
@NoException public static native PyObject _PyType_GetTextSignatureFromInternalDoc(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native PyObject _PyType_GetTextSignatureFromInternalDoc(String arg0, String arg1);
// #endif

/* Generic operations on objects */
// #ifndef Py_LIMITED_API
@NoException public static native int PyObject_Print(PyObject arg0, @Cast("FILE*") Pointer arg1, int arg2);
@NoException public static native void _Py_BreakPoint();
@NoException public static native void _PyObject_Dump(PyObject arg0);
// #endif
@NoException public static native PyObject PyObject_Repr(PyObject arg0);
@NoException public static native PyObject PyObject_Str(PyObject arg0);
@NoException public static native PyObject PyObject_ASCII(PyObject arg0);
@NoException public static native PyObject PyObject_Bytes(PyObject arg0);
@NoException public static native PyObject PyObject_RichCompare(PyObject arg0, PyObject arg1, int arg2);
@NoException public static native int PyObject_RichCompareBool(PyObject arg0, PyObject arg1, int arg2);
@NoException public static native PyObject PyObject_GetAttrString(PyObject arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native PyObject PyObject_GetAttrString(PyObject arg0, String arg1);
@NoException public static native int PyObject_SetAttrString(PyObject arg0, @Cast("const char*") BytePointer arg1, PyObject arg2);
@NoException public static native int PyObject_SetAttrString(PyObject arg0, String arg1, PyObject arg2);
@NoException public static native int PyObject_HasAttrString(PyObject arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native int PyObject_HasAttrString(PyObject arg0, String arg1);
@NoException public static native PyObject PyObject_GetAttr(PyObject arg0, PyObject arg1);
@NoException public static native int PyObject_SetAttr(PyObject arg0, PyObject arg1, PyObject arg2);
@NoException public static native int PyObject_HasAttr(PyObject arg0, PyObject arg1);
// #ifndef Py_LIMITED_API
@NoException public static native int _PyObject_IsAbstract(PyObject arg0);
@NoException public static native PyObject _PyObject_GetAttrId(PyObject arg0, _Py_Identifier arg1);
@NoException public static native int _PyObject_SetAttrId(PyObject arg0, _Py_Identifier arg1, PyObject arg2);
@NoException public static native int _PyObject_HasAttrId(PyObject arg0, _Py_Identifier arg1);
@NoException public static native @Cast("PyObject**") PointerPointer _PyObject_GetDictPtr(PyObject arg0);
// #endif
@NoException public static native PyObject PyObject_SelfIter(PyObject arg0);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyObject_NextNotImplemented(PyObject arg0);
// #endif
@NoException public static native PyObject PyObject_GenericGetAttr(PyObject arg0, PyObject arg1);
@NoException public static native int PyObject_GenericSetAttr(PyObject arg0,
                                              PyObject arg1, PyObject arg2);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native int PyObject_GenericSetDict(PyObject arg0, PyObject arg1, Pointer arg2);
// #endif
@NoException public static native @Cast("Py_hash_t") long PyObject_Hash(PyObject arg0);
@NoException public static native @Cast("Py_hash_t") long PyObject_HashNotImplemented(PyObject arg0);
@NoException public static native int PyObject_IsTrue(PyObject arg0);
@NoException public static native int PyObject_Not(PyObject arg0);
@NoException public static native int PyCallable_Check(PyObject arg0);

@NoException public static native void PyObject_ClearWeakRefs(PyObject arg0);
// #ifndef Py_LIMITED_API
@NoException public static native void PyObject_CallFinalizer(PyObject arg0);
@NoException public static native int PyObject_CallFinalizerFromDealloc(PyObject arg0);
// #endif

// #ifndef Py_LIMITED_API
/* Same as PyObject_Generic{Get,Set}Attr, but passing the attributes
   dict as the last parameter. */
@NoException public static native PyObject _PyObject_GenericGetAttrWithDict(PyObject arg0, PyObject arg1, PyObject arg2);
@NoException public static native int _PyObject_GenericSetAttrWithDict(PyObject arg0, PyObject arg1,
                                 PyObject arg2, PyObject arg3);
// #endif /* !Py_LIMITED_API */

/* Helper to look up a builtin object */
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyObject_GetBuiltin(@Cast("const char*") BytePointer name);
@NoException public static native PyObject _PyObject_GetBuiltin(String name);
// #endif

/* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a
   list of strings.  PyObject_Dir(NULL) is like builtins.dir(),
   returning the names of the current locals.  In this case, if there are
   no current locals, NULL is returned, and PyErr_Occurred() is false.
*/
@NoException public static native PyObject PyObject_Dir(PyObject arg0);


/* Helpers for printing recursive container types */
@NoException public static native int Py_ReprEnter(PyObject arg0);
@NoException public static native void Py_ReprLeave(PyObject arg0);

/* Flag bits for printing: */
public static final int Py_PRINT_RAW =    1;       /* No string quotes etc. */

/*
`Type flags (tp_flags)

These flags are used to extend the type structure in a backwards-compatible
fashion. Extensions can use the flags to indicate (and test) when a given
type structure contains a new feature. The Python core will use these when
introducing new functionality between major revisions (to avoid mid-version
changes in the PYTHON_API_VERSION).

Arbitration of the flag bit positions will need to be coordinated among
all extension writers who publically release their extensions (this will
be fewer than you might expect!)..

Most flags were removed as of Python 3.0 to make room for new flags.  (Some
flags are not for backwards compatibility but to indicate the presence of an
optional feature; these flags remain of course.)

Type definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.

Code can use PyType_HasFeature(type_ob, flag_value) to test whether the
given type object has a specified feature.
*/

/* Set if the type object is dynamically allocated */
public static final long Py_TPFLAGS_HEAPTYPE = (1L << 9);

/* Set if the type allows subclassing */
public static final long Py_TPFLAGS_BASETYPE = (1L << 10);

/* Set if the type is 'ready' -- fully initialized */
public static final long Py_TPFLAGS_READY = (1L << 12);

/* Set while the type is being 'readied', to prevent recursive ready calls */
public static final long Py_TPFLAGS_READYING = (1L << 13);

/* Objects support garbage collection (see objimp.h) */
public static final long Py_TPFLAGS_HAVE_GC = (1L << 14);

/* These two bits are preserved for Stackless Python, next after this is 17 */
// #ifdef STACKLESS
public static final long Py_TPFLAGS_HAVE_STACKLESS_EXTENSION = (3L << 15);
// #else
// #endif

/* Objects support type attribute cache */
public static final long Py_TPFLAGS_HAVE_VERSION_TAG =   (1L << 18);
public static final long Py_TPFLAGS_VALID_VERSION_TAG =  (1L << 19);

/* Type is abstract and cannot be instantiated */
public static final long Py_TPFLAGS_IS_ABSTRACT = (1L << 20);

/* These flags are used to determine if a type is a subclass. */
public static final long Py_TPFLAGS_LONG_SUBCLASS =        (1L << 24);
public static final long Py_TPFLAGS_LIST_SUBCLASS =        (1L << 25);
public static final long Py_TPFLAGS_TUPLE_SUBCLASS =       (1L << 26);
public static final long Py_TPFLAGS_BYTES_SUBCLASS =       (1L << 27);
public static final long Py_TPFLAGS_UNICODE_SUBCLASS =     (1L << 28);
public static final long Py_TPFLAGS_DICT_SUBCLASS =        (1L << 29);
public static final long Py_TPFLAGS_BASE_EXC_SUBCLASS =    (1L << 30);
public static final long Py_TPFLAGS_TYPE_SUBCLASS =        (1L << 31);

public static final long Py_TPFLAGS_DEFAULT =  ( 
                 Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | 
                 Py_TPFLAGS_HAVE_VERSION_TAG | 
                0);

/* NOTE: The following flags reuse lower bits (removed as part of the
 * Python 3.0 transition). */

/* Type structure has tp_finalize member (3.4) */
public static final long Py_TPFLAGS_HAVE_FINALIZE = (1L << 0);

// #ifdef Py_LIMITED_API
// #define PyType_HasFeature(t,f)  ((PyType_GetFlags(t) & (f)) != 0)
// #else
// #define PyType_HasFeature(t,f)  (((t)->tp_flags & (f)) != 0)
// #endif
// #define PyType_FastSubclass(t,f)  PyType_HasFeature(t,f)


/*
The macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement
reference counts.  Py_DECREF calls the object's deallocator function when
the refcount falls to 0; for
objects that don't contain references to other objects or heap memory
this can be the standard function free().  Both macros can be used
wherever a void expression is allowed.  The argument must not be a
NULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.
The macro _Py_NewReference(op) initialize reference counts to 1, and
in special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional
bookkeeping appropriate to the special build.

We assume that the reference count field can never overflow; this can
be proven when the size of the field is the same as the pointer size, so
we ignore the possibility.  Provided a C int is at least 32 bits (which
is implicitly assumed in many parts of this code), that's enough for
about 2**31 references to an object.

XXX The following became out of date in Python 2.2, but I'm not sure
XXX what the full truth is now.  Certainly, heap-allocated type objects
XXX can and should be deallocated.
Type objects should never be deallocated; the type pointer in an object
is not considered to be a reference to the type object, to save
complications in the deallocation function.  (This is actually a
decision that's up to the implementer of each new type so if you want,
you can count such references to the type object.)
*/

/* First define a pile of simple helper macros, one set per special
 * build symbol.  These either expand to the obvious things, or to
 * nothing at all when the special mode isn't in effect.  The main
 * macros can later be defined just once then, yet expand to different
 * things depending on which special build options are and aren't in effect.
 * Trust me <wink>:  while painful, this is 20x easier to understand than,
 * e.g, defining _Py_NewReference five different times in a maze of nested
 * #ifdefs (we used to do that -- it was impenetrable).
 */
// #ifdef Py_REF_DEBUG
// #else
// #define _Py_INC_REFTOTAL
// #define _Py_DEC_REFTOTAL
// #define _Py_REF_DEBUG_COMMA
// #define _Py_CHECK_REFCNT(OP)    /* a semicolon */;
// #define _PY_DEBUG_PRINT_TOTAL_REFS()
// #endif /* Py_REF_DEBUG */

// #ifdef COUNT_ALLOCS
// #else
// #define _Py_INC_TPALLOCS(OP)
// #define _Py_INC_TPFREES(OP)
// #define _Py_DEC_TPFREES(OP)
// #define _Py_COUNT_ALLOCS_COMMA
// #endif /* COUNT_ALLOCS */

// #ifdef Py_TRACE_REFS

// #else
/* Without Py_TRACE_REFS, there's little enough to do that we expand code
 * inline.
 */
// #define _Py_NewReference(op) (
//     _Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA
//     _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA
//     Py_REFCNT(op) = 1)

// #define _Py_ForgetReference(op) _Py_INC_TPFREES(op)

// #ifdef Py_LIMITED_API
@NoException public static native void _Py_Dealloc(PyObject arg0);
// #else
// #define _Py_Dealloc(op) (
//     _Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA
//     (*Py_TYPE(op)->tp_dealloc)((PyObject *)(op)))
// #endif
// #endif /* !Py_TRACE_REFS */

// #define Py_INCREF(op) (
//     _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA
//     ((PyObject *)(op))->ob_refcnt++)

// #define Py_DECREF(op)
//     do {
//         PyObject *_py_decref_tmp = (PyObject *)(op);
//         if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA
//         --(_py_decref_tmp)->ob_refcnt != 0)
//             _Py_CHECK_REFCNT(_py_decref_tmp)
//         else
//             _Py_Dealloc(_py_decref_tmp);
//     } while (0)

/* Safely decref `op` and set `op` to NULL, especially useful in tp_clear
 * and tp_dealloc implementations.
 *
 * Note that "the obvious" code can be deadly:
 *
 *     Py_XDECREF(op);
 *     op = NULL;
 *
 * Typically, `op` is something like self->containee, and `self` is done
 * using its `containee` member.  In the code sequence above, suppose
 * `containee` is non-NULL with a refcount of 1.  Its refcount falls to
 * 0 on the first line, which can trigger an arbitrary amount of code,
 * possibly including finalizers (like __del__ methods or weakref callbacks)
 * coded in Python, which in turn can release the GIL and allow other threads
 * to run, etc.  Such code may even invoke methods of `self` again, or cause
 * cyclic gc to trigger, but-- oops! --self->containee still points to the
 * object being torn down, and it may be in an insane state while being torn
 * down.  This has in fact been a rich historic source of miserable (rare &
 * hard-to-diagnose) segfaulting (and other) bugs.
 *
 * The safe way is:
 *
 *      Py_CLEAR(op);
 *
 * That arranges to set `op` to NULL _before_ decref'ing, so that any code
 * triggered as a side-effect of `op` getting torn down no longer believes
 * `op` points to a valid object.
 *
 * There are cases where it's safe to use the naive code, but they're brittle.
 * For example, if `op` points to a Python integer, you know that destroying
 * one of those can't cause problems -- but in part that relies on that
 * Python integers aren't currently weakly referencable.  Best practice is
 * to use Py_CLEAR() even if you can't think of a reason for why you need to.
 */
// #define Py_CLEAR(op)
//     do {
//         PyObject *_py_tmp = (PyObject *)(op);
//         if (_py_tmp != NULL) {
//             (op) = NULL;
//             Py_DECREF(_py_tmp);
//         }
//     } while (0)

/* Macros to use in case the object pointer may be NULL: */
// #define Py_XINCREF(op)
//     do {
//         PyObject *_py_xincref_tmp = (PyObject *)(op);
//         if (_py_xincref_tmp != NULL)
//             Py_INCREF(_py_xincref_tmp);
//     } while (0)

// #define Py_XDECREF(op)
//     do {
//         PyObject *_py_xdecref_tmp = (PyObject *)(op);
//         if (_py_xdecref_tmp != NULL)
//             Py_DECREF(_py_xdecref_tmp);
//     } while (0)

// #ifndef Py_LIMITED_API
/* Safely decref `op` and set `op` to `op2`.
 *
 * As in case of Py_CLEAR "the obvious" code can be deadly:
 *
 *     Py_DECREF(op);
 *     op = op2;
 *
 * The safe way is:
 *
 *      Py_SETREF(op, op2);
 *
 * That arranges to set `op` to `op2` _before_ decref'ing, so that any code
 * triggered as a side-effect of `op` getting torn down no longer believes
 * `op` points to a valid object.
 *
 * Py_XSETREF is a variant of Py_SETREF that uses Py_XDECREF instead of
 * Py_DECREF.
 */

// #define Py_SETREF(op, op2)
//     do {
//         PyObject *_py_tmp = (PyObject *)(op);
//         (op) = (op2);
//         Py_DECREF(_py_tmp);
//     } while (0)

// #define Py_XSETREF(op, op2)
//     do {
//         PyObject *_py_tmp = (PyObject *)(op);
//         (op) = (op2);
//         Py_XDECREF(_py_tmp);
//     } while (0)

// #endif /* ifndef Py_LIMITED_API */

/*
These are provided as conveniences to Python runtime embedders, so that
they can have object code that is not dependent on Python compilation flags.
*/
@NoException public static native void Py_IncRef(PyObject arg0);
@NoException public static native void Py_DecRef(PyObject arg0);

// #ifndef Py_LIMITED_API
public static native @ByRef PyTypeObject _PyNone_Type(); public static native void _PyNone_Type(PyTypeObject _PyNone_Type);
public static native @ByRef PyTypeObject _PyNotImplemented_Type(); public static native void _PyNotImplemented_Type(PyTypeObject _PyNotImplemented_Type);
// #endif /* !Py_LIMITED_API */

/*
_Py_NoneStruct is an object of undefined type which can be used in contexts
where NULL (nil) is not suitable (since NULL often means 'error').

Don't forget to apply Py_INCREF() when returning this value!!!
*/
public static native @ByRef PyObject _Py_NoneStruct(); public static native void _Py_NoneStruct(PyObject _Py_NoneStruct); /* Don't use this directly */
// #define Py_None (&_Py_NoneStruct)

/* Macro for returning Py_None from a function */
// #define Py_RETURN_NONE return Py_INCREF(Py_None), Py_None

/*
Py_NotImplemented is a singleton used to signal that an operation is
not implemented for a given type combination.
*/
public static native @ByRef PyObject _Py_NotImplementedStruct(); public static native void _Py_NotImplementedStruct(PyObject _Py_NotImplementedStruct); /* Don't use this directly */
// #define Py_NotImplemented (&_Py_NotImplementedStruct)

/* Macro for returning Py_NotImplemented from a function */
// #define Py_RETURN_NOTIMPLEMENTED
//     return Py_INCREF(Py_NotImplemented), Py_NotImplemented

/* Rich comparison opcodes */
public static final int Py_LT = 0;
public static final int Py_LE = 1;
public static final int Py_EQ = 2;
public static final int Py_NE = 3;
public static final int Py_GT = 4;
public static final int Py_GE = 5;

// #ifndef Py_LIMITED_API
/* Maps Py_LT to Py_GT, ..., Py_GE to Py_LE.
 * Defined in object.c.
 */
public static native int _Py_SwappedOp(int i); public static native void _Py_SwappedOp(int i, int _Py_SwappedOp);
@MemberGetter public static native IntPointer _Py_SwappedOp();
// #endif /* !Py_LIMITED_API */


/*
More conventions
================

Argument Checking
-----------------

Functions that take objects as arguments normally don't check for nil
arguments, but they do check the type of the argument, and return an
error if the function doesn't apply to the type.

Failure Modes
-------------

Functions may fail for a variety of reasons, including running out of
memory.  This is communicated to the caller in two ways: an error string
is set (see errors.h), and the function result differs: functions that
normally return a pointer return NULL for failure, functions returning
an integer return -1 (which could be a legal return value too!), and
other functions return 0 for success and -1 for failure.
Callers should always check for errors before using the result.  If
an error was set, the caller must either explicitly clear it, or pass
the error on to its caller.

Reference Counts
----------------

It takes a while to get used to the proper usage of reference counts.

Functions that create an object set the reference count to 1; such new
objects must be stored somewhere or destroyed again with Py_DECREF().
Some functions that 'store' objects, such as PyTuple_SetItem() and
PyList_SetItem(),
don't increment the reference count of the object, since the most
frequent use is to store a fresh object.  Functions that 'retrieve'
objects, such as PyTuple_GetItem() and PyDict_GetItemString(), also
don't increment
the reference count, since most frequently the object is only looked at
quickly.  Thus, to retrieve an object and store it again, the caller
must call Py_INCREF() explicitly.

NOTE: functions that 'consume' a reference count, like
PyList_SetItem(), consume the reference even if the object wasn't
successfully stored, to simplify error handling.

It seems attractive to make other functions that take an object as
argument consume a reference count; however, this may quickly get
confusing (even the current practice is already confusing).  Consider
it carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at
times.
*/


/* Trashcan mechanism, thanks to Christian Tismer.

When deallocating a container object, it's possible to trigger an unbounded
chain of deallocations, as each Py_DECREF in turn drops the refcount on "the
next" object in the chain to 0.  This can easily lead to stack faults, and
especially in threads (which typically have less stack space to work with).

A container object that participates in cyclic gc can avoid this by
bracketing the body of its tp_dealloc function with a pair of macros:

static void
mytype_dealloc(mytype *p)
{
    ... declarations go here ...

    PyObject_GC_UnTrack(p);        // must untrack first
    Py_TRASHCAN_SAFE_BEGIN(p)
    ... The body of the deallocator goes here, including all calls ...
    ... to Py_DECREF on contained objects.                         ...
    Py_TRASHCAN_SAFE_END(p)
}

CAUTION:  Never return from the middle of the body!  If the body needs to
"get out early", put a label immediately before the Py_TRASHCAN_SAFE_END
call, and goto it.  Else the call-depth counter (see below) will stay
above 0 forever, and the trashcan will never get emptied.

How it works:  The BEGIN macro increments a call-depth counter.  So long
as this counter is small, the body of the deallocator is run directly without
further ado.  But if the counter gets large, it instead adds p to a list of
objects to be deallocated later, skips the body of the deallocator, and
resumes execution after the END macro.  The tp_dealloc routine then returns
without deallocating anything (and so unbounded call-stack depth is avoided).

When the call stack finishes unwinding again, code generated by the END macro
notices this, and calls another routine to deallocate all the objects that
may have been added to the list of deferred deallocations.  In effect, a
chain of N deallocations is broken into N / PyTrash_UNWIND_LEVEL pieces,
with the call stack never exceeding a depth of PyTrash_UNWIND_LEVEL.
*/

// #ifndef Py_LIMITED_API
/* This is the old private API, invoked by the macros before 3.2.4.
   Kept for binary compatibility of extensions using the stable ABI. */
@NoException public static native void _PyTrash_deposit_object(PyObject arg0);
@NoException public static native void _PyTrash_destroy_chain();
public static native int _PyTrash_delete_nesting(); public static native void _PyTrash_delete_nesting(int _PyTrash_delete_nesting);
public static native PyObject _PyTrash_delete_later(); public static native void _PyTrash_delete_later(PyObject _PyTrash_delete_later);
// #endif /* !Py_LIMITED_API */

/* The new thread-safe private API, invoked by the macros below. */
@NoException public static native void _PyTrash_thread_deposit_object(PyObject arg0);
@NoException public static native void _PyTrash_thread_destroy_chain();

public static final int PyTrash_UNWIND_LEVEL = 50;

// #define Py_TRASHCAN_SAFE_BEGIN(op)
//     do {
//         PyThreadState *_tstate = PyThreadState_GET();
//         if (_tstate->trash_delete_nesting < PyTrash_UNWIND_LEVEL) {
//             ++_tstate->trash_delete_nesting;
            /* The body of the deallocator is here. */
// #define Py_TRASHCAN_SAFE_END(op)
//             --_tstate->trash_delete_nesting;
//             if (_tstate->trash_delete_later && _tstate->trash_delete_nesting <= 0)
//                 _PyTrash_thread_destroy_chain();
//         }
//         else
//             _PyTrash_thread_deposit_object((PyObject*)op);
//     } while (0);

// #ifndef Py_LIMITED_API
@NoException public static native void _PyDebugAllocatorStats(@Cast("FILE*") Pointer out, @Cast("const char*") BytePointer block_name, int num_blocks,
                       @Cast("size_t") long sizeof_block);
@NoException public static native void _PyDebugAllocatorStats(@Cast("FILE*") Pointer out, String block_name, int num_blocks,
                       @Cast("size_t") long sizeof_block);
@NoException public static native void _PyObject_DebugTypeStats(@Cast("FILE*") Pointer out);
// #endif /* ifndef Py_LIMITED_API */

/* 
   Define a pair of assertion macros.

   These work like the regular C assert(), in that they will abort the
   process with a message on stderr if the given condition fails to hold,
   but compile away to nothing if NDEBUG is defined.

   However, before aborting, Python will also try to call _PyObject_Dump() on
   the given object.  This may be of use when investigating bugs in which a
   particular object is corrupt (e.g. buggy a tp_visit method in an extension
   module breaking the garbage collector), to help locate the broken objects.

   The WITH_MSG variant allows you to supply an additional message that Python
   will attempt to print to stderr, after the object dump.
*/
// #ifdef NDEBUG
/* No debugging: compile away the assertions: */
// #define PyObject_ASSERT_WITH_MSG(obj, expr, msg) ((void)0)
// #else
/* With debugging: generate checks: */
// #define PyObject_ASSERT_WITH_MSG(obj, expr, msg)
//   ((expr)
//    ? (void)(0)
//    : _PyObject_AssertFailed((obj),
//                             (msg),
//                             (__STRING(expr)),
//                             (__FILE__),
//                             (__LINE__),
//                             (__PRETTY_FUNCTION__)))
// #endif

// #define PyObject_ASSERT(obj, expr)
//   PyObject_ASSERT_WITH_MSG(obj, expr, NULL)

/* 
   Declare and define the entrypoint even when NDEBUG is defined, to avoid
   causing compiler/linker errors when building extensions without NDEBUG
   against a Python built with NDEBUG defined
*/
@NoException public static native void _PyObject_AssertFailed(PyObject arg0,  @Cast("const char*") BytePointer arg1,
                                        @Cast("const char*") BytePointer arg2, @Cast("const char*") BytePointer arg3, int arg4,
                                        @Cast("const char*") BytePointer arg5);
@NoException public static native void _PyObject_AssertFailed(PyObject arg0,  String arg1,
                                        String arg2, String arg3, int arg4,
                                        String arg5);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_OBJECT_H */


// Parsed from objimpl.h

/* The PyObject_ memory family:  high-level object memory interfaces.
   See pymem.h for the low-level PyMem_ family.
*/

// #ifndef Py_OBJIMPL_H
// #define Py_OBJIMPL_H

// #include "pymem.h"

// #ifdef __cplusplus
// #endif

/* BEWARE:

   Each interface exports both functions and macros.  Extension modules should
   use the functions, to ensure binary compatibility across Python versions.
   Because the Python implementation is free to change internal details, and
   the macros may (or may not) expose details for speed, if you do use the
   macros you must recompile your extensions with each Python release.

   Never mix calls to PyObject_ memory functions with calls to the platform
   malloc/realloc/ calloc/free, or with calls to PyMem_.
*/

/*
Functions and macros for modules that implement new object types.

 - PyObject_New(type, typeobj) allocates memory for a new object of the given
   type, and initializes part of it.  'type' must be the C structure type used
   to represent the object, and 'typeobj' the address of the corresponding
   type object.  Reference count and type pointer are filled in; the rest of
   the bytes of the object are *undefined*!  The resulting expression type is
   'type *'.  The size of the object is determined by the tp_basicsize field
   of the type object.

 - PyObject_NewVar(type, typeobj, n) is similar but allocates a variable-size
   object with room for n items.  In addition to the refcount and type pointer
   fields, this also fills in the ob_size field.

 - PyObject_Del(op) releases the memory allocated for an object.  It does not
   run a destructor -- it only frees the memory.  PyObject_Free is identical.

 - PyObject_Init(op, typeobj) and PyObject_InitVar(op, typeobj, n) don't
   allocate memory.  Instead of a 'type' parameter, they take a pointer to a
   new object (allocated by an arbitrary allocator), and initialize its object
   header fields.

Note that objects created with PyObject_{New, NewVar} are allocated using the
specialized Python allocator (implemented in obmalloc.c), if WITH_PYMALLOC is
enabled.  In addition, a special debugging allocator is used if PYMALLOC_DEBUG
is also #defined.

In case a specific form of memory management is needed (for example, if you
must use the platform malloc heap(s), or shared memory, or C++ local storage or
operator new), you must first allocate the object with your custom allocator,
then pass its pointer to PyObject_{Init, InitVar} for filling in its Python-
specific fields:  reference count, type pointer, possibly others.  You should
be aware that Python has no control over these objects because they don't
cooperate with the Python memory manager.  Such objects may not be eligible
for automatic garbage collection and you have to make sure that they are
released accordingly whenever their destructor gets called (cf. the specific
form of memory management you're using).

Unless you have specific memory management requirements, use
PyObject_{New, NewVar, Del}.
*/

/*
 * Raw object memory interface
 * ===========================
 */

/* Functions to call the same malloc/realloc/free as used by Python's
   object allocator.  If WITH_PYMALLOC is enabled, these may differ from
   the platform malloc/realloc/free.  The Python object allocator is
   designed for fast, cache-conscious allocation of many "small" objects,
   and with low hidden memory overhead.

   PyObject_Malloc(0) returns a unique non-NULL pointer if possible.

   PyObject_Realloc(NULL, n) acts like PyObject_Malloc(n).
   PyObject_Realloc(p != NULL, 0) does not return  NULL, or free the memory
   at p.

   Returned pointers must be checked for NULL explicitly; no action is
   performed on failure other than to return NULL (no warning it printed, no
   exception is set, etc).

   For allocating objects, use PyObject_{New, NewVar} instead whenever
   possible.  The PyObject_{Malloc, Realloc, Free} family is exposed
   so that you can exploit Python's small-block allocator for non-object
   uses.  If you must use these routines to allocate object memory, make sure
   the object gets initialized via PyObject_{Init, InitVar} after obtaining
   the raw memory.
*/
@NoException public static native Pointer PyObject_Malloc(@Cast("size_t") long size);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
@NoException public static native Pointer PyObject_Calloc(@Cast("size_t") long nelem, @Cast("size_t") long elsize);
// #endif
@NoException public static native Pointer PyObject_Realloc(Pointer ptr, @Cast("size_t") long new_size);
@NoException public static native void PyObject_Free(Pointer ptr);

// #ifndef Py_LIMITED_API
/* This function returns the number of allocated memory blocks, regardless of size */
@NoException public static native @Cast("Py_ssize_t") long _Py_GetAllocatedBlocks();
// #endif /* !Py_LIMITED_API */

/* Macros */
// #ifdef WITH_PYMALLOC
// #ifndef Py_LIMITED_API
@NoException public static native void _PyObject_DebugMallocStats(@Cast("FILE*") Pointer out);
// #endif /* #ifndef Py_LIMITED_API */
// #endif

/* Macros */
// #define PyObject_MALLOC         PyObject_Malloc
// #define PyObject_REALLOC        PyObject_Realloc
// #define PyObject_FREE           PyObject_Free
// #define PyObject_Del            PyObject_Free
// #define PyObject_DEL            PyObject_Free


/*
 * Generic object allocator interface
 * ==================================
 */

/* Functions */
@NoException public static native PyObject PyObject_Init(PyObject arg0, PyTypeObject arg1);
@NoException public static native PyVarObject PyObject_InitVar(PyVarObject arg0,
                                                 PyTypeObject arg1, @Cast("Py_ssize_t") long arg2);
@NoException public static native PyObject _PyObject_New(PyTypeObject arg0);
@NoException public static native PyVarObject _PyObject_NewVar(PyTypeObject arg0, @Cast("Py_ssize_t") long arg1);

// #define PyObject_New(type, typeobj)
//                 ( (type *) _PyObject_New(typeobj) )
// #define PyObject_NewVar(type, typeobj, n)
//                 ( (type *) _PyObject_NewVar((typeobj), (n)) )

/* Macros trading binary compatibility for speed. See also pymem.h.
   Note that these macros expect non-NULL object pointers.*/
// #define PyObject_INIT(op, typeobj)
//     ( Py_TYPE(op) = (typeobj), _Py_NewReference((PyObject *)(op)), (op) )
// #define PyObject_INIT_VAR(op, typeobj, size)
//     ( Py_SIZE(op) = (size), PyObject_INIT((op), (typeobj)) )

// #define _PyObject_SIZE(typeobj) ( (typeobj)->tp_basicsize )

/* _PyObject_VAR_SIZE returns the number of bytes (as size_t) allocated for a
   vrbl-size object with nitems items, exclusive of gc overhead (if any).  The
   value is rounded up to the closest multiple of sizeof(void *), in order to
   ensure that pointer fields at the end of the object are correctly aligned
   for the platform (this is of special importance for subclasses of, e.g.,
   str or int, so that pointers can be stored after the embedded data).

   Note that there's no memory wastage in doing this, as malloc has to
   return (at worst) pointer-aligned memory anyway.
*/
// #if ((SIZEOF_VOID_P - 1) & SIZEOF_VOID_P) != 0
// #   error "_PyObject_VAR_SIZE requires SIZEOF_VOID_P be a power of 2"
// #endif

// #define _PyObject_VAR_SIZE(typeobj, nitems)
//     _Py_SIZE_ROUND_UP((typeobj)->tp_basicsize +
//         (nitems)*(typeobj)->tp_itemsize,
//         SIZEOF_VOID_P)

// #define PyObject_NEW(type, typeobj)
// ( (type *) PyObject_Init(
//     (PyObject *) PyObject_MALLOC( _PyObject_SIZE(typeobj) ), (typeobj)) )

// #define PyObject_NEW_VAR(type, typeobj, n)
// ( (type *) PyObject_InitVar(
//       (PyVarObject *) PyObject_MALLOC(_PyObject_VAR_SIZE((typeobj),(n)) ),
//       (typeobj), (n)) )
// Targeting ../python/PyObjectArenaAllocator.java



/* Get the arena allocator. */
@NoException public static native void PyObject_GetArenaAllocator(PyObjectArenaAllocator allocator);

/* Set the arena allocator. */
@NoException public static native void PyObject_SetArenaAllocator(PyObjectArenaAllocator allocator);
// #endif


/*
 * Garbage Collection Support
 * ==========================
 */

/* C equivalent of gc.collect() which ignores the state of gc.enabled. */
@NoException public static native @Cast("Py_ssize_t") long PyGC_Collect();

// #ifndef Py_LIMITED_API
@NoException public static native @Cast("Py_ssize_t") long _PyGC_CollectNoFail();
@NoException public static native @Cast("Py_ssize_t") long _PyGC_CollectIfEnabled();
// #endif

/* Test if a type has a GC head */
// #define PyType_IS_GC(t) PyType_HasFeature((t), Py_TPFLAGS_HAVE_GC)

/* Test if an object has a GC head */
// #define PyObject_IS_GC(o) (PyType_IS_GC(Py_TYPE(o)) &&
//     (Py_TYPE(o)->tp_is_gc == NULL || Py_TYPE(o)->tp_is_gc(o)))

@NoException public static native PyVarObject _PyObject_GC_Resize(PyVarObject arg0, @Cast("Py_ssize_t") long arg1);
// #define PyObject_GC_Resize(type, op, n)
//                 ( (type *) _PyObject_GC_Resize((PyVarObject *)(op), (n)) )
// Targeting ../python/PyGC_Head.java





// #define _Py_AS_GC(o) ((PyGC_Head *)(o)-1)

/* Bit 0 is set when tp_finalize is called */
public static final int _PyGC_REFS_MASK_FINALIZED =  (1 << 0);
/* The (N-1) most significant bits contain the gc state / refcount */
public static final int _PyGC_REFS_SHIFT =           (1);
public static final long _PyGC_REFS_MASK =            (((long) -1) << _PyGC_REFS_SHIFT);

// #define _PyGCHead_REFS(g) ((g)->gc.gc_refs >> _PyGC_REFS_SHIFT)
// #define _PyGCHead_SET_REFS(g, v) do {
//     (g)->gc.gc_refs = ((g)->gc.gc_refs & ~_PyGC_REFS_MASK)
//         | (((size_t)(v)) << _PyGC_REFS_SHIFT);
//     } while (0)
// #define _PyGCHead_DECREF(g) ((g)->gc.gc_refs -= 1 << _PyGC_REFS_SHIFT)

// #define _PyGCHead_FINALIZED(g) (((g)->gc.gc_refs & _PyGC_REFS_MASK_FINALIZED) != 0)
// #define _PyGCHead_SET_FINALIZED(g, v) do {
//     (g)->gc.gc_refs = ((g)->gc.gc_refs & ~_PyGC_REFS_MASK_FINALIZED)
//         | (v != 0);
//     } while (0)

// #define _PyGC_FINALIZED(o) _PyGCHead_FINALIZED(_Py_AS_GC(o))
// #define _PyGC_SET_FINALIZED(o, v) _PyGCHead_SET_FINALIZED(_Py_AS_GC(o), v)

// #define _PyGC_REFS(o) _PyGCHead_REFS(_Py_AS_GC(o))

public static final int _PyGC_REFS_UNTRACKED =                    (-2);
public static final int _PyGC_REFS_REACHABLE =                    (-3);
public static final int _PyGC_REFS_TENTATIVELY_UNREACHABLE =      (-4);

/* Tell the GC to track this object.  NB: While the object is tracked the
 * collector it must be safe to call the ob_traverse method. */
// #define _PyObject_GC_TRACK(o) do {
//     PyGC_Head *g = _Py_AS_GC(o);
//     if (_PyGCHead_REFS(g) != _PyGC_REFS_UNTRACKED)
//         Py_FatalError("GC object already tracked");
//     _PyGCHead_SET_REFS(g, _PyGC_REFS_REACHABLE);
//     g->gc.gc_next = _PyGC_generation0;
//     g->gc.gc_prev = _PyGC_generation0->gc.gc_prev;
//     g->gc.gc_prev->gc.gc_next = g;
//     _PyGC_generation0->gc.gc_prev = g;
//     } while (0);

/* Tell the GC to stop tracking this object.
 * gc_next doesn't need to be set to NULL, but doing so is a good
 * way to provoke memory errors if calling code is confused.
 */
// #define _PyObject_GC_UNTRACK(o) do {
//     PyGC_Head *g = _Py_AS_GC(o);
//     assert(_PyGCHead_REFS(g) != _PyGC_REFS_UNTRACKED);
//     _PyGCHead_SET_REFS(g, _PyGC_REFS_UNTRACKED);
//     g->gc.gc_prev->gc.gc_next = g->gc.gc_next;
//     g->gc.gc_next->gc.gc_prev = g->gc.gc_prev;
//     g->gc.gc_next = NULL;
//     } while (0);

/* True if the object is currently tracked by the GC. */
// #define _PyObject_GC_IS_TRACKED(o)
//     (_PyGC_REFS(o) != _PyGC_REFS_UNTRACKED)

/* True if the object may be tracked by the GC in the future, or already is.
   This can be useful to implement some optimizations. */
// #define _PyObject_GC_MAY_BE_TRACKED(obj)
//     (PyObject_IS_GC(obj) &&
//         (!PyTuple_CheckExact(obj) || _PyObject_GC_IS_TRACKED(obj)))
// #endif /* Py_LIMITED_API */

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyObject_GC_Malloc(@Cast("size_t") long size);
@NoException public static native PyObject _PyObject_GC_Calloc(@Cast("size_t") long size);
// #endif /* !Py_LIMITED_API */
@NoException public static native PyObject _PyObject_GC_New(PyTypeObject arg0);
@NoException public static native PyVarObject _PyObject_GC_NewVar(PyTypeObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native void PyObject_GC_Track(Pointer arg0);
@NoException public static native void PyObject_GC_UnTrack(Pointer arg0);
@NoException public static native void PyObject_GC_Del(Pointer arg0);

// #define PyObject_GC_New(type, typeobj)
//                 ( (type *) _PyObject_GC_New(typeobj) )
// #define PyObject_GC_NewVar(type, typeobj, n)
//                 ( (type *) _PyObject_GC_NewVar((typeobj), (n)) )


/* Utility macro to help write tp_traverse functions.
 * To use this macro, the tp_traverse function must name its arguments
 * "visit" and "arg".  This is intended to keep tp_traverse functions
 * looking as much alike as possible.
 */
// #define Py_VISIT(op)
//     do {
//         if (op) {
//             int vret = visit((PyObject *)(op), arg);
//             if (vret)
//                 return vret;
//         }
//     } while (0)


/* Test if a type supports weak references */
// #define PyType_SUPPORTS_WEAKREFS(t) ((t)->tp_weaklistoffset > 0)

// #define PyObject_GET_WEAKREFS_LISTPTR(o)
//     ((PyObject **) (((char *) (o)) + Py_TYPE(o)->tp_weaklistoffset))

// #ifdef __cplusplus
// #endif
// #endif /* !Py_OBJIMPL_H */


// Parsed from typeslots.h

/* Do not renumber the file; these numbers are part of the stable ABI. */
/* Disabled, see #10181 */
// #undef Py_bf_getbuffer
// #undef Py_bf_releasebuffer
public static final int Py_mp_ass_subscript = 3;
public static final int Py_mp_length = 4;
public static final int Py_mp_subscript = 5;
public static final int Py_nb_absolute = 6;
public static final int Py_nb_add = 7;
public static final int Py_nb_and = 8;
public static final int Py_nb_bool = 9;
public static final int Py_nb_divmod = 10;
public static final int Py_nb_float = 11;
public static final int Py_nb_floor_divide = 12;
public static final int Py_nb_index = 13;
public static final int Py_nb_inplace_add = 14;
public static final int Py_nb_inplace_and = 15;
public static final int Py_nb_inplace_floor_divide = 16;
public static final int Py_nb_inplace_lshift = 17;
public static final int Py_nb_inplace_multiply = 18;
public static final int Py_nb_inplace_or = 19;
public static final int Py_nb_inplace_power = 20;
public static final int Py_nb_inplace_remainder = 21;
public static final int Py_nb_inplace_rshift = 22;
public static final int Py_nb_inplace_subtract = 23;
public static final int Py_nb_inplace_true_divide = 24;
public static final int Py_nb_inplace_xor = 25;
public static final int Py_nb_int = 26;
public static final int Py_nb_invert = 27;
public static final int Py_nb_lshift = 28;
public static final int Py_nb_multiply = 29;
public static final int Py_nb_negative = 30;
public static final int Py_nb_or = 31;
public static final int Py_nb_positive = 32;
public static final int Py_nb_power = 33;
public static final int Py_nb_remainder = 34;
public static final int Py_nb_rshift = 35;
public static final int Py_nb_subtract = 36;
public static final int Py_nb_true_divide = 37;
public static final int Py_nb_xor = 38;
public static final int Py_sq_ass_item = 39;
public static final int Py_sq_concat = 40;
public static final int Py_sq_contains = 41;
public static final int Py_sq_inplace_concat = 42;
public static final int Py_sq_inplace_repeat = 43;
public static final int Py_sq_item = 44;
public static final int Py_sq_length = 45;
public static final int Py_sq_repeat = 46;
public static final int Py_tp_alloc = 47;
public static final int Py_tp_base = 48;
public static final int Py_tp_bases = 49;
public static final int Py_tp_call = 50;
public static final int Py_tp_clear = 51;
public static final int Py_tp_dealloc = 52;
public static final int Py_tp_del = 53;
public static final int Py_tp_descr_get = 54;
public static final int Py_tp_descr_set = 55;
public static final int Py_tp_doc = 56;
public static final int Py_tp_getattr = 57;
public static final int Py_tp_getattro = 58;
public static final int Py_tp_hash = 59;
public static final int Py_tp_init = 60;
public static final int Py_tp_is_gc = 61;
public static final int Py_tp_iter = 62;
public static final int Py_tp_iternext = 63;
public static final int Py_tp_methods = 64;
public static final int Py_tp_new = 65;
public static final int Py_tp_repr = 66;
public static final int Py_tp_richcompare = 67;
public static final int Py_tp_setattr = 68;
public static final int Py_tp_setattro = 69;
public static final int Py_tp_str = 70;
public static final int Py_tp_traverse = 71;
public static final int Py_tp_members = 72;
public static final int Py_tp_getset = 73;
public static final int Py_tp_free = 74;
public static final int Py_nb_matrix_multiply = 75;
public static final int Py_nb_inplace_matrix_multiply = 76;
public static final int Py_am_await = 77;
public static final int Py_am_aiter = 78;
public static final int Py_am_anext = 79;
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* New in 3.5 */
public static final int Py_tp_finalize = 80;
// #endif


// Parsed from pyhash.h

// #ifndef Py_HASH_H

// #define Py_HASH_H
// #ifdef __cplusplus
// #endif

/* Helpers for hash functions */
// #ifndef Py_LIMITED_API
@NoException public static native @Cast("Py_hash_t") long _Py_HashDouble(double arg0);
@NoException public static native @Cast("Py_hash_t") long _Py_HashPointer(Pointer arg0);
@NoException public static native @Cast("Py_hash_t") long _Py_HashBytes(@Const Pointer arg0, @Cast("Py_ssize_t") long arg1);
// #endif

/* Prime multiplier used in string and various other hashes. */
public static final long _PyHASH_MULTIPLIER = 1000003L;  /* 0xf4243 */

/* Parameters used for the numeric hash implementation.  See notes for
   _Py_HashDouble in Python/pyhash.c.  Numeric hashes are based on
   reduction modulo the prime 2**_PyHASH_BITS - 1. */

// #if SIZEOF_VOID_P >= 8
public static final int _PyHASH_BITS = 61;
// #else
// #endif

public static final long _PyHASH_MODULUS = (((long)1 << _PyHASH_BITS) - 1);
public static final int _PyHASH_INF = 314159;
public static final int _PyHASH_NAN = 0;
public static final long _PyHASH_IMAG = _PyHASH_MULTIPLIER;
// Targeting ../python/_Py_HashSecret_t.java


public static native @ByRef _Py_HashSecret_t _Py_HashSecret(); public static native void _Py_HashSecret(_Py_HashSecret_t _Py_HashSecret);
// Targeting ../python/PyHash_FuncDef.java



@NoException public static native PyHash_FuncDef PyHash_GetFuncDef();
// #endif


/* cutoff for small string DJBX33A optimization in range [1, cutoff).
 *
 * About 50% of the strings in a typical Python application are smaller than
 * 6 to 7 chars. However DJBX33A is vulnerable to hash collision attacks.
 * NEVER use DJBX33A for long strings!
 *
 * A Py_HASH_CUTOFF of 0 disables small string optimization. 32 bit platforms
 * should use a smaller cutoff because it is easier to create colliding
 * strings. A cutoff of 7 on 64bit platforms and 5 on 32bit platforms should
 * provide a decent safety margin.
 */
// #ifndef Py_HASH_CUTOFF
public static final int Py_HASH_CUTOFF = 0;
// #elif (Py_HASH_CUTOFF > 7 || Py_HASH_CUTOFF < 0)
// #  error Py_HASH_CUTOFF must in range 0...7.
// #endif /* Py_HASH_CUTOFF */


/* hash algorithm selection
 *
 * The values for Py_HASH_SIPHASH24 and Py_HASH_FNV are hard-coded in the
 * configure script.
 *
 * - FNV is available on all platforms and architectures.
 * - SIPHASH24 only works on plaforms that don't require aligned memory for integers.
 * - With EXTERNAL embedders can provide an alternative implementation with::
 *
 *     PyHash_FuncDef PyHash_Func = {...};
 *
 * XXX: Figure out __declspec() for extern PyHash_FuncDef.
 */
public static final int Py_HASH_EXTERNAL = 0;
public static final int Py_HASH_SIPHASH24 = 1;
public static final int Py_HASH_FNV = 2;

// #ifndef Py_HASH_ALGORITHM
// #  ifndef HAVE_ALIGNED_REQUIRED
public static final int Py_HASH_ALGORITHM = Py_HASH_SIPHASH24;
// #  else
// #  endif /* uint64_t && uint32_t && aligned */
// #endif /* Py_HASH_ALGORITHM */

// #ifdef __cplusplus
// #endif

// #endif /* !Py_HASH_H */


// Parsed from pydebug.h

// #ifndef Py_LIMITED_API
// #ifndef Py_PYDEBUG_H
// #define Py_PYDEBUG_H
// #ifdef __cplusplus
// #endif

/* These global variable are defined in pylifecycle.c */
/* XXX (ncoghlan): move these declarations to pylifecycle.h? */
public static native int Py_DebugFlag(); public static native void Py_DebugFlag(int Py_DebugFlag);
public static native int Py_VerboseFlag(); public static native void Py_VerboseFlag(int Py_VerboseFlag);
public static native int Py_QuietFlag(); public static native void Py_QuietFlag(int Py_QuietFlag);
public static native int Py_InteractiveFlag(); public static native void Py_InteractiveFlag(int Py_InteractiveFlag);
public static native int Py_InspectFlag(); public static native void Py_InspectFlag(int Py_InspectFlag);
public static native int Py_OptimizeFlag(); public static native void Py_OptimizeFlag(int Py_OptimizeFlag);
public static native int Py_NoSiteFlag(); public static native void Py_NoSiteFlag(int Py_NoSiteFlag);
public static native int Py_BytesWarningFlag(); public static native void Py_BytesWarningFlag(int Py_BytesWarningFlag);
public static native int Py_UseClassExceptionsFlag(); public static native void Py_UseClassExceptionsFlag(int Py_UseClassExceptionsFlag);
public static native int Py_FrozenFlag(); public static native void Py_FrozenFlag(int Py_FrozenFlag);
public static native int Py_IgnoreEnvironmentFlag(); public static native void Py_IgnoreEnvironmentFlag(int Py_IgnoreEnvironmentFlag);
public static native int Py_DontWriteBytecodeFlag(); public static native void Py_DontWriteBytecodeFlag(int Py_DontWriteBytecodeFlag);
public static native int Py_NoUserSiteDirectory(); public static native void Py_NoUserSiteDirectory(int Py_NoUserSiteDirectory);
public static native int Py_UnbufferedStdioFlag(); public static native void Py_UnbufferedStdioFlag(int Py_UnbufferedStdioFlag);
public static native int Py_HashRandomizationFlag(); public static native void Py_HashRandomizationFlag(int Py_HashRandomizationFlag);
public static native int Py_IsolatedFlag(); public static native void Py_IsolatedFlag(int Py_IsolatedFlag);

// #ifdef MS_WINDOWS
// #endif

/* this is a wrapper around getenv() that pays attention to
   Py_IgnoreEnvironmentFlag.  It should be used for getting variables like
   PYTHONPATH and PYTHONHOME from the environment */
// #define Py_GETENV(s) (Py_IgnoreEnvironmentFlag ? NULL : getenv(s))

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYDEBUG_H */
// #endif /* Py_LIMITED_API */


// Parsed from descrobject.h

/* Descriptors */
// #ifndef Py_DESCROBJECT_H
// #define Py_DESCROBJECT_H
// #ifdef __cplusplus
// Targeting ../python/getter.java


// Targeting ../python/setter.java


// Targeting ../python/PyGetSetDef.java


// Targeting ../python/wrapperfunc.java


// Targeting ../python/wrapperfunc_kwds.java


// Targeting ../python/wrapperbase.java



/* Flags for above struct */
public static final int PyWrapperFlag_KEYWORDS = 1;
// Targeting ../python/PyDescrObject.java



// #define PyDescr_COMMON PyDescrObject d_common

// #define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
// #define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
// Targeting ../python/PyMethodDescrObject.java


// Targeting ../python/PyMemberDescrObject.java


// Targeting ../python/PyGetSetDescrObject.java


// Targeting ../python/PyWrapperDescrObject.java


// #endif /* Py_LIMITED_API */

public static native @ByRef PyTypeObject PyClassMethodDescr_Type(); public static native void PyClassMethodDescr_Type(PyTypeObject PyClassMethodDescr_Type);
public static native @ByRef PyTypeObject PyGetSetDescr_Type(); public static native void PyGetSetDescr_Type(PyTypeObject PyGetSetDescr_Type);
public static native @ByRef PyTypeObject PyMemberDescr_Type(); public static native void PyMemberDescr_Type(PyTypeObject PyMemberDescr_Type);
public static native @ByRef PyTypeObject PyMethodDescr_Type(); public static native void PyMethodDescr_Type(PyTypeObject PyMethodDescr_Type);
public static native @ByRef PyTypeObject PyWrapperDescr_Type(); public static native void PyWrapperDescr_Type(PyTypeObject PyWrapperDescr_Type);
public static native @ByRef PyTypeObject PyDictProxy_Type(); public static native void PyDictProxy_Type(PyTypeObject PyDictProxy_Type);
// #ifndef Py_LIMITED_API
public static native @ByRef PyTypeObject _PyMethodWrapper_Type(); public static native void _PyMethodWrapper_Type(PyTypeObject _PyMethodWrapper_Type);
// #endif /* Py_LIMITED_API */

@NoException public static native PyObject PyDescr_NewMethod(PyTypeObject arg0, PyMethodDef arg1);
@NoException public static native PyObject PyDescr_NewClassMethod(PyTypeObject arg0, PyMethodDef arg1); /* forward declaration for following prototype */
@NoException public static native PyObject PyDescr_NewMember(PyTypeObject arg0,
                                               PyMemberDef arg1);
@NoException public static native PyObject PyDescr_NewGetSet(PyTypeObject arg0,
                                               PyGetSetDef arg1);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyDescr_NewWrapper(PyTypeObject arg0,
                                                wrapperbase arg1, Pointer arg2);
// #define PyDescr_IsData(d) (Py_TYPE(d)->tp_descr_set != NULL)
// #endif

@NoException public static native PyObject PyDictProxy_New(PyObject arg0);
@NoException public static native PyObject PyWrapper_New(PyObject arg0, PyObject arg1);


public static native @ByRef PyTypeObject PyProperty_Type(); public static native void PyProperty_Type(PyTypeObject PyProperty_Type);
// #ifdef __cplusplus
// #endif
// #endif /* !Py_DESCROBJECT_H */



// Parsed from bytearrayobject.h

/* ByteArray object interface */

// #ifndef Py_BYTEARRAYOBJECT_H
// #define Py_BYTEARRAYOBJECT_H
// #ifdef __cplusplus
// #endif

// #include <stdarg.h>
// Targeting ../python/PyByteArrayObject.java


// #endif

/* Type object */
public static native @ByRef PyTypeObject PyByteArray_Type(); public static native void PyByteArray_Type(PyTypeObject PyByteArray_Type);
public static native @ByRef PyTypeObject PyByteArrayIter_Type(); public static native void PyByteArrayIter_Type(PyTypeObject PyByteArrayIter_Type);

/* Type check macros */
// #define PyByteArray_Check(self) PyObject_TypeCheck(self, &PyByteArray_Type)
// #define PyByteArray_CheckExact(self) (Py_TYPE(self) == &PyByteArray_Type)

/* Direct API functions */
@NoException public static native PyObject PyByteArray_FromObject(PyObject arg0);
@NoException public static native PyObject PyByteArray_Concat(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyByteArray_FromStringAndSize(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native PyObject PyByteArray_FromStringAndSize(String arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native @Cast("Py_ssize_t") long PyByteArray_Size(PyObject arg0);
@NoException public static native @Cast("char*") BytePointer PyByteArray_AsString(PyObject arg0);
@NoException public static native int PyByteArray_Resize(PyObject arg0, @Cast("Py_ssize_t") long arg1);

/* Macros, trading safety for speed */
// #ifndef Py_LIMITED_API
// #define PyByteArray_AS_STRING(self)
//     (assert(PyByteArray_Check(self)),
//      Py_SIZE(self) ? ((PyByteArrayObject *)(self))->ob_start : _PyByteArray_empty_string)
// #define PyByteArray_GET_SIZE(self) (assert(PyByteArray_Check(self)), Py_SIZE(self))

public static native @Cast("char") byte _PyByteArray_empty_string(int i); public static native void _PyByteArray_empty_string(int i, byte _PyByteArray_empty_string);
@MemberGetter public static native @Cast("char*") BytePointer _PyByteArray_empty_string();
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_BYTEARRAYOBJECT_H */


// Parsed from bytesobject.h


/* Bytes (String) object interface */

// #ifndef Py_BYTESOBJECT_H
// #define Py_BYTESOBJECT_H
// #ifdef __cplusplus
// #endif

// #include <stdarg.h>
// Targeting ../python/PyBytesObject.java


// #endif

public static native @ByRef PyTypeObject PyBytes_Type(); public static native void PyBytes_Type(PyTypeObject PyBytes_Type);
public static native @ByRef PyTypeObject PyBytesIter_Type(); public static native void PyBytesIter_Type(PyTypeObject PyBytesIter_Type);

// #define PyBytes_Check(op)
//                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_BYTES_SUBCLASS)
// #define PyBytes_CheckExact(op) (Py_TYPE(op) == &PyBytes_Type)

@NoException public static native PyObject PyBytes_FromStringAndSize(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native PyObject PyBytes_FromStringAndSize(String arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native PyObject PyBytes_FromString(@Cast("const char*") BytePointer arg0);
@NoException public static native PyObject PyBytes_FromString(String arg0);
@NoException public static native PyObject PyBytes_FromObject(PyObject arg0);
@NoException public static native PyObject PyBytes_FromFormatV(@Cast("const char*") BytePointer arg0, @ByVal @Cast("va_list*") Pointer arg1);
@NoException public static native PyObject PyBytes_FromFormatV(String arg0, @ByVal @Cast("va_list*") Pointer arg1);
@NoException public static native PyObject PyBytes_FromFormat(@Cast("const char*") BytePointer arg0);
@NoException public static native PyObject PyBytes_FromFormat(String arg0);
@NoException public static native @Cast("Py_ssize_t") long PyBytes_Size(PyObject arg0);
@NoException public static native @Cast("char*") BytePointer PyBytes_AsString(PyObject arg0);
@NoException public static native PyObject PyBytes_Repr(PyObject arg0, int arg1);
@NoException public static native void PyBytes_Concat(@Cast("PyObject**") PointerPointer arg0, PyObject arg1);
@NoException public static native void PyBytes_Concat(@ByPtrPtr PyObject arg0, PyObject arg1);
@NoException public static native void PyBytes_ConcatAndDel(@Cast("PyObject**") PointerPointer arg0, PyObject arg1);
@NoException public static native void PyBytes_ConcatAndDel(@ByPtrPtr PyObject arg0, PyObject arg1);
// #ifndef Py_LIMITED_API
@NoException public static native int _PyBytes_Resize(@Cast("PyObject**") PointerPointer arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int _PyBytes_Resize(@ByPtrPtr PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native PyObject _PyBytes_FormatEx(
    @Cast("const char*") BytePointer format,
    @Cast("Py_ssize_t") long format_len,
    PyObject args,
    int use_bytearray);
@NoException public static native PyObject _PyBytes_FormatEx(
    String format,
    @Cast("Py_ssize_t") long format_len,
    PyObject args,
    int use_bytearray);
@NoException public static native PyObject _PyBytes_FromHex(
    PyObject string,
    int use_bytearray);
// #endif
@NoException public static native PyObject PyBytes_DecodeEscape(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1,
						   @Cast("const char*") BytePointer arg2, @Cast("Py_ssize_t") long arg3,
						   @Cast("const char*") BytePointer arg4);
@NoException public static native PyObject PyBytes_DecodeEscape(String arg0, @Cast("Py_ssize_t") long arg1,
						   String arg2, @Cast("Py_ssize_t") long arg3,
						   String arg4);
// #ifndef Py_LIMITED_API
/* Helper for PyBytes_DecodeEscape that detects invalid escape chars. */
@NoException public static native PyObject _PyBytes_DecodeEscape(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1,
                                             @Cast("const char*") BytePointer arg2, @Cast("Py_ssize_t") long arg3,
                                             @Cast("const char*") BytePointer arg4,
                                             @Cast("const char**") PointerPointer arg5);
@NoException public static native PyObject _PyBytes_DecodeEscape(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1,
                                             @Cast("const char*") BytePointer arg2, @Cast("Py_ssize_t") long arg3,
                                             @Cast("const char*") BytePointer arg4,
                                             @Cast("const char**") @ByPtrPtr BytePointer arg5);
@NoException public static native PyObject _PyBytes_DecodeEscape(String arg0, @Cast("Py_ssize_t") long arg1,
                                             String arg2, @Cast("Py_ssize_t") long arg3,
                                             String arg4,
                                             @Cast("const char**") @ByPtrPtr ByteBuffer arg5);
@NoException public static native PyObject _PyBytes_DecodeEscape(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1,
                                             @Cast("const char*") BytePointer arg2, @Cast("Py_ssize_t") long arg3,
                                             @Cast("const char*") BytePointer arg4,
                                             @Cast("const char**") @ByPtrPtr byte[] arg5);
@NoException public static native PyObject _PyBytes_DecodeEscape(String arg0, @Cast("Py_ssize_t") long arg1,
                                             String arg2, @Cast("Py_ssize_t") long arg3,
                                             String arg4,
                                             @Cast("const char**") @ByPtrPtr BytePointer arg5);
@NoException public static native PyObject _PyBytes_DecodeEscape(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1,
                                             @Cast("const char*") BytePointer arg2, @Cast("Py_ssize_t") long arg3,
                                             @Cast("const char*") BytePointer arg4,
                                             @Cast("const char**") @ByPtrPtr ByteBuffer arg5);
@NoException public static native PyObject _PyBytes_DecodeEscape(String arg0, @Cast("Py_ssize_t") long arg1,
                                             String arg2, @Cast("Py_ssize_t") long arg3,
                                             String arg4,
                                             @Cast("const char**") @ByPtrPtr byte[] arg5);
// #endif

/* Macro, trading safety for speed */
// #ifndef Py_LIMITED_API
// #define PyBytes_AS_STRING(op) (assert(PyBytes_Check(op)),
//                                 (((PyBytesObject *)(op))->ob_sval))
// #define PyBytes_GET_SIZE(op)  (assert(PyBytes_Check(op)),Py_SIZE(op))
// #endif

/* _PyBytes_Join(sep, x) is like sep.join(x).  sep must be PyBytesObject*,
   x must be an iterable object. */
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyBytes_Join(PyObject sep, PyObject x);
// #endif

/* Provides access to the internal data buffer and size of a string
   object or the default encoded version of a Unicode object. Passing
   NULL as *len parameter will force the string buffer to be
   0-terminated (passing a string with embedded NULL characters will
   cause an exception).  */
@NoException public static native int PyBytes_AsStringAndSize(
    PyObject obj,
    @Cast("char**") PointerPointer s,
    @Cast("Py_ssize_t*") SizeTPointer len
    );
@NoException public static native int PyBytes_AsStringAndSize(
    PyObject obj,
    @Cast("char**") @ByPtrPtr BytePointer s,
    @Cast("Py_ssize_t*") SizeTPointer len
    );
@NoException public static native int PyBytes_AsStringAndSize(
    PyObject obj,
    @Cast("char**") @ByPtrPtr ByteBuffer s,
    @Cast("Py_ssize_t*") SizeTPointer len
    );
@NoException public static native int PyBytes_AsStringAndSize(
    PyObject obj,
    @Cast("char**") @ByPtrPtr byte[] s,
    @Cast("Py_ssize_t*") SizeTPointer len
    );

/* Using the current locale, insert the thousands grouping
   into the string pointed to by buffer.  For the argument descriptions,
   see Objects/stringlib/localeutil.h */
// #ifndef Py_LIMITED_API


/* Using explicit passed-in values, insert the thousands grouping
   into the string pointed to by buffer.  For the argument descriptions,
   see Objects/stringlib/localeutil.h */

// #endif

/* Flags used by string formatting */
public static final int F_LJUST = (1<<0);
public static final int F_SIGN =	(1<<1);
public static final int F_BLANK = (1<<2);
public static final int F_ALT =	(1<<3);
public static final int F_ZERO =	(1<<4);
// Targeting ../python/_PyBytesWriter.java



/* Initialize a bytes writer

   By default, the overallocation is disabled. Set the overallocate attribute
   to control the allocation of the buffer. */
@NoException public static native void _PyBytesWriter_Init(_PyBytesWriter writer);

/* Get the buffer content and reset the writer.
   Return a bytes object, or a bytearray object if use_bytearray is non-zero.
   Raise an exception and return NULL on error. */
@NoException public static native PyObject _PyBytesWriter_Finish(_PyBytesWriter writer,
    Pointer str);

/* Deallocate memory of a writer (clear its internal buffer). */
@NoException public static native void _PyBytesWriter_Dealloc(_PyBytesWriter writer);

/* Allocate the buffer to write size bytes.
   Return the pointer to the beginning of buffer data.
   Raise an exception and return NULL on error. */
@NoException public static native Pointer _PyBytesWriter_Alloc(_PyBytesWriter writer,
    @Cast("Py_ssize_t") long size);

/* Ensure that the buffer is large enough to write *size* bytes.
   Add size to the writer minimum size (min_size attribute).

   str is the current pointer inside the buffer.
   Return the updated current pointer inside the buffer.
   Raise an exception and return NULL on error. */
@NoException public static native Pointer _PyBytesWriter_Prepare(_PyBytesWriter writer,
    Pointer str,
    @Cast("Py_ssize_t") long size);

/* Resize the buffer to make it larger.
   The new buffer may be larger than size bytes because of overallocation.
   Return the updated current pointer inside the buffer.
   Raise an exception and return NULL on error.

   Note: size must be greater than the number of allocated bytes in the writer.

   This function doesn't use the writer minimum size (min_size attribute).

   See also _PyBytesWriter_Prepare().
   */
@NoException public static native Pointer _PyBytesWriter_Resize(_PyBytesWriter writer,
    Pointer str,
    @Cast("Py_ssize_t") long size);

/* Write bytes.
   Raise an exception and return NULL on error. */
@NoException public static native Pointer _PyBytesWriter_WriteBytes(_PyBytesWriter writer,
    Pointer str,
    @Const Pointer bytes,
    @Cast("Py_ssize_t") long size);
// #endif   /* Py_LIMITED_API */

// #ifdef __cplusplus
// #endif
// #endif /* !Py_BYTESOBJECT_H */


// Parsed from unicodeobject.h

// #ifndef Py_UNICODEOBJECT_H
// #define Py_UNICODEOBJECT_H

// #include <stdarg.h>

/*

Unicode implementation based on original code by Fredrik Lundh,
modified by Marc-Andre Lemburg (mal@lemburg.com) according to the
Unicode Integration Proposal. (See
http://www.egenix.com/files/python/unicode-proposal.txt).

Copyright (c) Corporation for National Research Initiatives.


 Original header:
 --------------------------------------------------------------------

 * Yet another Unicode string type for Python.  This type supports the
 * 16-bit Basic Multilingual Plane (BMP) only.
 *
 * Written by Fredrik Lundh, January 1999.
 *
 * Copyright (c) 1999 by Secret Labs AB.
 * Copyright (c) 1999 by Fredrik Lundh.
 *
 * fredrik@pythonware.com
 * http://www.pythonware.com
 *
 * --------------------------------------------------------------------
 * This Unicode String Type is
 *
 * Copyright (c) 1999 by Secret Labs AB
 * Copyright (c) 1999 by Fredrik Lundh
 *
 * By obtaining, using, and/or copying this software and/or its
 * associated documentation, you agree that you have read, understood,
 * and will comply with the following terms and conditions:
 *
 * Permission to use, copy, modify, and distribute this software and its
 * associated documentation for any purpose and without fee is hereby
 * granted, provided that the above copyright notice appears in all
 * copies, and that both that copyright notice and this permission notice
 * appear in supporting documentation, and that the name of Secret Labs
 * AB or the author not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior
 * permission.
 *
 * SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO
 * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * -------------------------------------------------------------------- */

// #include <ctype.h>

/* === Internal API ======================================================= */

/* --- Internal Unicode Format -------------------------------------------- */

/* Python 3.x requires unicode */
// #define Py_USING_UNICODE

// #ifndef SIZEOF_WCHAR_T
// #error Must define SIZEOF_WCHAR_T
// #endif

public static native @MemberGetter int Py_UNICODE_SIZE();
public static final int Py_UNICODE_SIZE = Py_UNICODE_SIZE();

/* If wchar_t can be used for UCS-4 storage, set Py_UNICODE_WIDE.
   Otherwise, Unicode strings are stored as UCS-2 (with limited support
   for UTF-16) */

// #if Py_UNICODE_SIZE >= 4
// #define Py_UNICODE_WIDE
// #endif

/* Set these flags if the platform has "wchar.h" and the
   wchar_t type is a 16-bit unsigned type */
/* #define HAVE_WCHAR_H */
/* #define HAVE_USABLE_WCHAR_T */

/* Py_UNICODE was the native Unicode storage format (code unit) used by
   Python and represents a single Unicode element in the Unicode type.
   With PEP 393, Py_UNICODE is deprecated and replaced with a
   typedef to wchar_t. */

// #ifndef Py_LIMITED_API
// #define PY_UNICODE_TYPE wchar_t
// #endif

/* If the compiler provides a wchar_t type we try to support it
   through the interface functions PyUnicode_FromWideChar(),
   PyUnicode_AsWideChar() and PyUnicode_AsWideCharString(). */

// #ifdef HAVE_USABLE_WCHAR_T
// # ifndef HAVE_WCHAR_H
// #  define HAVE_WCHAR_H
// # endif
// #endif

// #ifdef HAVE_WCHAR_H
// #endif

/* Py_UCS4 and Py_UCS2 are typedefs for the respective
   unicode representations. */

/* --- Internal Unicode Operations ---------------------------------------- */

/* Since splitting on whitespace is an important use case, and
   whitespace in most situations is solely ASCII whitespace, we
   optimize for the common case by using a quick look-up table
   _Py_ascii_whitespace (see below) with an inlined check.

 */
// #ifndef Py_LIMITED_API
// #define Py_UNICODE_ISSPACE(ch)
//     ((ch) < 128L ? _Py_ascii_whitespace[(ch)] : _PyUnicode_IsWhitespace(ch))

// #define Py_UNICODE_ISLOWER(ch) _PyUnicode_IsLowercase(ch)
// #define Py_UNICODE_ISUPPER(ch) _PyUnicode_IsUppercase(ch)
// #define Py_UNICODE_ISTITLE(ch) _PyUnicode_IsTitlecase(ch)
// #define Py_UNICODE_ISLINEBREAK(ch) _PyUnicode_IsLinebreak(ch)

// #define Py_UNICODE_TOLOWER(ch) _PyUnicode_ToLowercase(ch)
// #define Py_UNICODE_TOUPPER(ch) _PyUnicode_ToUppercase(ch)
// #define Py_UNICODE_TOTITLE(ch) _PyUnicode_ToTitlecase(ch)

// #define Py_UNICODE_ISDECIMAL(ch) _PyUnicode_IsDecimalDigit(ch)
// #define Py_UNICODE_ISDIGIT(ch) _PyUnicode_IsDigit(ch)
// #define Py_UNICODE_ISNUMERIC(ch) _PyUnicode_IsNumeric(ch)
// #define Py_UNICODE_ISPRINTABLE(ch) _PyUnicode_IsPrintable(ch)

// #define Py_UNICODE_TODECIMAL(ch) _PyUnicode_ToDecimalDigit(ch)
// #define Py_UNICODE_TODIGIT(ch) _PyUnicode_ToDigit(ch)
// #define Py_UNICODE_TONUMERIC(ch) _PyUnicode_ToNumeric(ch)

// #define Py_UNICODE_ISALPHA(ch) _PyUnicode_IsAlpha(ch)

// #define Py_UNICODE_ISALNUM(ch)
//        (Py_UNICODE_ISALPHA(ch) ||
//     Py_UNICODE_ISDECIMAL(ch) ||
//     Py_UNICODE_ISDIGIT(ch) ||
//     Py_UNICODE_ISNUMERIC(ch))

// #define Py_UNICODE_COPY(target, source, length)
//     memcpy((target), (source), (length)*sizeof(Py_UNICODE))

// #define Py_UNICODE_FILL(target, value, length)
//     do {Py_ssize_t i_; Py_UNICODE *t_ = (target); Py_UNICODE v_ = (value);
//         for (i_ = 0; i_ < (length); i_++) t_[i_] = v_;
//     } while (0)

/* macros to work with surrogates */
// #define Py_UNICODE_IS_SURROGATE(ch) (0xD800 <= (ch) && (ch) <= 0xDFFF)
// #define Py_UNICODE_IS_HIGH_SURROGATE(ch) (0xD800 <= (ch) && (ch) <= 0xDBFF)
// #define Py_UNICODE_IS_LOW_SURROGATE(ch) (0xDC00 <= (ch) && (ch) <= 0xDFFF)
/* Join two surrogate characters and return a single Py_UCS4 value. */
// #define Py_UNICODE_JOIN_SURROGATES(high, low)
//     (((((Py_UCS4)(high) & 0x03FF) << 10) |
//       ((Py_UCS4)(low) & 0x03FF)) + 0x10000)
/* high surrogate = top 10 bits added to D800 */
// #define Py_UNICODE_HIGH_SURROGATE(ch) (0xD800 - (0x10000 >> 10) + ((ch) >> 10))
/* low surrogate = bottom 10 bits added to DC00 */
// #define Py_UNICODE_LOW_SURROGATE(ch) (0xDC00 + ((ch) & 0x3FF))

/* Check if substring matches at given offset.  The offset must be
   valid, and the substring must not be empty. */

// #define Py_UNICODE_MATCH(string, offset, substring)
//     ((*((string)->wstr + (offset)) == *((substring)->wstr)) &&
//      ((*((string)->wstr + (offset) + (substring)->wstr_length-1) == *((substring)->wstr + (substring)->wstr_length-1))) &&
//      !memcmp((string)->wstr + (offset), (substring)->wstr, (substring)->wstr_length*sizeof(Py_UNICODE)))

// #endif /* Py_LIMITED_API */

// #ifdef __cplusplus
// Targeting ../python/PyASCIIObject.java


// Targeting ../python/PyCompactUnicodeObject.java


// Targeting ../python/PyUnicodeObject.java


// #endif

public static native @ByRef PyTypeObject PyUnicode_Type(); public static native void PyUnicode_Type(PyTypeObject PyUnicode_Type);
public static native @ByRef PyTypeObject PyUnicodeIter_Type(); public static native void PyUnicodeIter_Type(PyTypeObject PyUnicodeIter_Type);

// #define PyUnicode_Check(op)
//                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_UNICODE_SUBCLASS)
// #define PyUnicode_CheckExact(op) (Py_TYPE(op) == &PyUnicode_Type)

/* Fast access macros */
// #ifndef Py_LIMITED_API

// #define PyUnicode_WSTR_LENGTH(op)
//     (PyUnicode_IS_COMPACT_ASCII(op) ?
//      ((PyASCIIObject*)op)->length :
//      ((PyCompactUnicodeObject*)op)->wstr_length)

/* Returns the deprecated Py_UNICODE representation's size in code units
   (this includes surrogate pairs as 2 units).
   If the Py_UNICODE representation is not available, it will be computed
   on request.  Use PyUnicode_GET_LENGTH() for the length in code points. */

// #define PyUnicode_GET_SIZE(op)
//     (assert(PyUnicode_Check(op)),
//      (((PyASCIIObject *)(op))->wstr) ?
//       PyUnicode_WSTR_LENGTH(op) :
//       ((void)PyUnicode_AsUnicode((PyObject *)(op)),
//        assert(((PyASCIIObject *)(op))->wstr),
//        PyUnicode_WSTR_LENGTH(op)))

// #define PyUnicode_GET_DATA_SIZE(op)
//     (PyUnicode_GET_SIZE(op) * Py_UNICODE_SIZE)

/* Alias for PyUnicode_AsUnicode().  This will create a wchar_t/Py_UNICODE
   representation on demand.  Using this macro is very inefficient now,
   try to port your code to use the new PyUnicode_*BYTE_DATA() macros or
   use PyUnicode_WRITE() and PyUnicode_READ(). */

// #define PyUnicode_AS_UNICODE(op)
//     (assert(PyUnicode_Check(op)),
//      (((PyASCIIObject *)(op))->wstr) ? (((PyASCIIObject *)(op))->wstr) :
//       PyUnicode_AsUnicode((PyObject *)(op)))

// #define PyUnicode_AS_DATA(op)
//     ((const char *)(PyUnicode_AS_UNICODE(op)))


/* --- Flexible String Representation Helper Macros (PEP 393) -------------- */

/* Values for PyASCIIObject.state: */

/* Interning state. */
public static final int SSTATE_NOT_INTERNED = 0;
public static final int SSTATE_INTERNED_MORTAL = 1;
public static final int SSTATE_INTERNED_IMMORTAL = 2;

/* Return true if the string contains only ASCII characters, or 0 if not. The
   string may be compact (PyUnicode_IS_COMPACT_ASCII) or not, but must be
   ready. */
// #define PyUnicode_IS_ASCII(op)
//     (assert(PyUnicode_Check(op)),
//      assert(PyUnicode_IS_READY(op)),
//      ((PyASCIIObject*)op)->state.ascii)

/* Return true if the string is compact or 0 if not.
   No type checks or Ready calls are performed. */
// #define PyUnicode_IS_COMPACT(op)
//     (((PyASCIIObject*)(op))->state.compact)

/* Return true if the string is a compact ASCII string (use PyASCIIObject
   structure), or 0 if not.  No type checks or Ready calls are performed. */
// #define PyUnicode_IS_COMPACT_ASCII(op)
//     (((PyASCIIObject*)op)->state.ascii && PyUnicode_IS_COMPACT(op))

/** enum PyUnicode_Kind */
public static final int
/* String contains only wstr byte characters.  This is only possible
   when the string was created with a legacy API and _PyUnicode_Ready()
   has not been called yet.  */
    PyUnicode_WCHAR_KIND = 0,
/* Return values of the PyUnicode_KIND() macro: */
    PyUnicode_1BYTE_KIND = 1,
    PyUnicode_2BYTE_KIND = 2,
    PyUnicode_4BYTE_KIND = 4;

/* Return pointers to the canonical representation cast to unsigned char,
   Py_UCS2, or Py_UCS4 for direct character access.
   No checks are performed, use PyUnicode_KIND() before to ensure
   these will work correctly. */

// #define PyUnicode_1BYTE_DATA(op) ((Py_UCS1*)PyUnicode_DATA(op))
// #define PyUnicode_2BYTE_DATA(op) ((Py_UCS2*)PyUnicode_DATA(op))
// #define PyUnicode_4BYTE_DATA(op) ((Py_UCS4*)PyUnicode_DATA(op))

/* Return one of the PyUnicode_*_KIND values defined above. */
// #define PyUnicode_KIND(op)
//     (assert(PyUnicode_Check(op)),
//      assert(PyUnicode_IS_READY(op)),
//      ((PyASCIIObject *)(op))->state.kind)

/* Return a void pointer to the raw unicode buffer. */
// #define _PyUnicode_COMPACT_DATA(op)
//     (PyUnicode_IS_ASCII(op) ?
//      ((void*)((PyASCIIObject*)(op) + 1)) :
//      ((void*)((PyCompactUnicodeObject*)(op) + 1)))

// #define _PyUnicode_NONCOMPACT_DATA(op)
//     (assert(((PyUnicodeObject*)(op))->data.any),
//      ((((PyUnicodeObject *)(op))->data.any)))

// #define PyUnicode_DATA(op)
//     (assert(PyUnicode_Check(op)),
//      PyUnicode_IS_COMPACT(op) ? _PyUnicode_COMPACT_DATA(op) :
//      _PyUnicode_NONCOMPACT_DATA(op))

/* In the access macros below, "kind" may be evaluated more than once.
   All other macro parameters are evaluated exactly once, so it is safe
   to put side effects into them (such as increasing the index). */

/* Write into the canonical representation, this macro does not do any sanity
   checks and is intended for usage in loops.  The caller should cache the
   kind and data pointers obtained from other macro calls.
   index is the index in the string (starts at 0) and value is the new
   code point value which should be written to that location. */
// #define PyUnicode_WRITE(kind, data, index, value)
//     do {
//         switch ((kind)) {
//         case PyUnicode_1BYTE_KIND: {
//             ((Py_UCS1 *)(data))[(index)] = (Py_UCS1)(value);
//             break;
//         }
//         case PyUnicode_2BYTE_KIND: {
//             ((Py_UCS2 *)(data))[(index)] = (Py_UCS2)(value);
//             break;
//         }
//         default: {
//             assert((kind) == PyUnicode_4BYTE_KIND);
//             ((Py_UCS4 *)(data))[(index)] = (Py_UCS4)(value);
//         }
//         }
//     } while (0)

/* Read a code point from the string's canonical representation.  No checks
   or ready calls are performed. */
// #define PyUnicode_READ(kind, data, index)
//     ((Py_UCS4)
//     ((kind) == PyUnicode_1BYTE_KIND ?
//         ((const Py_UCS1 *)(data))[(index)] :
//         ((kind) == PyUnicode_2BYTE_KIND ?
//             ((const Py_UCS2 *)(data))[(index)] :
//             ((const Py_UCS4 *)(data))[(index)]
//         )
//     ))

/* PyUnicode_READ_CHAR() is less efficient than PyUnicode_READ() because it
   calls PyUnicode_KIND() and might call it twice.  For single reads, use
   PyUnicode_READ_CHAR, for multiple consecutive reads callers should
   cache kind and use PyUnicode_READ instead. */
// #define PyUnicode_READ_CHAR(unicode, index)
//     (assert(PyUnicode_Check(unicode)),
//      assert(PyUnicode_IS_READY(unicode)),
//      (Py_UCS4)
//         (PyUnicode_KIND((unicode)) == PyUnicode_1BYTE_KIND ?
//             ((const Py_UCS1 *)(PyUnicode_DATA((unicode))))[(index)] :
//             (PyUnicode_KIND((unicode)) == PyUnicode_2BYTE_KIND ?
//                 ((const Py_UCS2 *)(PyUnicode_DATA((unicode))))[(index)] :
//                 ((const Py_UCS4 *)(PyUnicode_DATA((unicode))))[(index)]
//             )
//         ))

/* Returns the length of the unicode string. The caller has to make sure that
   the string has it's canonical representation set before calling
   this macro.  Call PyUnicode_(FAST_)Ready to ensure that. */
// #define PyUnicode_GET_LENGTH(op)
//     (assert(PyUnicode_Check(op)),
//      assert(PyUnicode_IS_READY(op)),
//      ((PyASCIIObject *)(op))->length)


/* Fast check to determine whether an object is ready. Equivalent to
   PyUnicode_IS_COMPACT(op) || ((PyUnicodeObject*)(op))->data.any) */

// #define PyUnicode_IS_READY(op) (((PyASCIIObject*)op)->state.ready)

/* PyUnicode_READY() does less work than _PyUnicode_Ready() in the best
   case.  If the canonical representation is not yet set, it will still call
   _PyUnicode_Ready().
   Returns 0 on success and -1 on errors. */
// #define PyUnicode_READY(op)
//     (assert(PyUnicode_Check(op)),
//      (PyUnicode_IS_READY(op) ?
//       0 : _PyUnicode_Ready((PyObject *)(op))))

/* Return a maximum character value which is suitable for creating another
   string based on op.  This is always an approximation but more efficient
   than iterating over the string. */
// #define PyUnicode_MAX_CHAR_VALUE(op)
//     (assert(PyUnicode_IS_READY(op)),
//      (PyUnicode_IS_ASCII(op) ?
//       (0x7f) :
//       (PyUnicode_KIND(op) == PyUnicode_1BYTE_KIND ?
//        (0xff) :
//        (PyUnicode_KIND(op) == PyUnicode_2BYTE_KIND ?
//         (0xffff) :
//         (0x10ffff)))))

// #endif

/* --- Constants ---------------------------------------------------------- */

/* This Unicode character will be used as replacement character during
   decoding if the errors argument is set to "replace". Note: the
   Unicode character U+FFFD is the official REPLACEMENT CHARACTER in
   Unicode 3.0. */

public static final int Py_UNICODE_REPLACEMENT_CHARACTER = ((int) 0xFFFD);

/* === Public API ========================================================= */

/* --- Plain Py_UNICODE --------------------------------------------------- */

/* With PEP 393, this is the recommended way to allocate a new unicode object.
   This function will allocate the object and its buffer in a single memory
   block.  Objects created using this function are not resizable. */
// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyUnicode_New(
    @Cast("Py_ssize_t") long size,
    @Cast("Py_UCS4") int maxchar
    );
// #endif

/* Initializes the canonical string representation from the deprecated
   wstr/Py_UNICODE representation. This function is used to convert Unicode
   objects which were created using the old API to the new flexible format
   introduced with PEP 393.

   Don't call this function directly, use the public PyUnicode_READY() macro
   instead. */
// #ifndef Py_LIMITED_API
@NoException public static native int _PyUnicode_Ready(
    PyObject unicode
    );
// #endif

/* Get a copy of a Unicode string. */
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyUnicode_Copy(
    PyObject unicode
    );
// #endif

/* Copy character from one unicode object into another, this function performs
   character conversion when necessary and falls back to memcpy() if possible.

   Fail if to is too small (smaller than *how_many* or smaller than
   len(from)-from_start), or if kind(from[from_start:from_start+how_many]) >
   kind(to), or if *to* has more than 1 reference.

   Return the number of written character, or return -1 and raise an exception
   on error.

   Pseudo-code:

       how_many = min(how_many, len(from) - from_start)
       to[to_start:to_start+how_many] = from[from_start:from_start+how_many]
       return how_many

   Note: The function doesn't write a terminating null character.
   */
// #ifndef Py_LIMITED_API
@NoException public static native @Cast("Py_ssize_t") long PyUnicode_CopyCharacters(
    PyObject to,
    @Cast("Py_ssize_t") long to_start,
    PyObject from,
    @Cast("Py_ssize_t") long from_start,
    @Cast("Py_ssize_t") long how_many
    );

/* Unsafe version of PyUnicode_CopyCharacters(): don't check arguments and so
   may crash if parameters are invalid (e.g. if the output string
   is too short). */
@NoException public static native void _PyUnicode_FastCopyCharacters(
    PyObject to,
    @Cast("Py_ssize_t") long to_start,
    PyObject from,
    @Cast("Py_ssize_t") long from_start,
    @Cast("Py_ssize_t") long how_many
    );
// #endif

// #ifndef Py_LIMITED_API
/* Fill a string with a character: write fill_char into
   unicode[start:start+length].

   Fail if fill_char is bigger than the string maximum character, or if the
   string has more than 1 reference.

   Return the number of written character, or return -1 and raise an exception
   on error. */
@NoException public static native @Cast("Py_ssize_t") long PyUnicode_Fill(
    PyObject unicode,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_UCS4") int fill_char
    );

/* Unsafe version of PyUnicode_Fill(): don't check arguments and so may crash
   if parameters are invalid (e.g. if length is longer than the string). */
@NoException public static native void _PyUnicode_FastFill(
    PyObject unicode,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_UCS4") int fill_char
    );
// #endif

/* Create a Unicode Object from the Py_UNICODE buffer u of the given
   size.

   u may be NULL which causes the contents to be undefined. It is the
   user's responsibility to fill in the needed data afterwards. Note
   that modifying the Unicode object contents after construction is
   only allowed if u was set to NULL.

   The buffer is copied into the new object. */

// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyUnicode_FromUnicode(
    @Cast("const Py_UNICODE*") Pointer u,
    @Cast("Py_ssize_t") long size
    );
// #endif

/* Similar to PyUnicode_FromUnicode(), but u points to UTF-8 encoded bytes */
@NoException public static native PyObject PyUnicode_FromStringAndSize(
    @Cast("const char*") BytePointer u,
    @Cast("Py_ssize_t") long size
    );
@NoException public static native PyObject PyUnicode_FromStringAndSize(
    String u,
    @Cast("Py_ssize_t") long size
    );

/* Similar to PyUnicode_FromUnicode(), but u points to null-terminated
   UTF-8 encoded bytes.  The size is determined with strlen(). */
@NoException public static native PyObject PyUnicode_FromString(
    @Cast("const char*") BytePointer u
    );
@NoException public static native PyObject PyUnicode_FromString(
    String u
    );

// #ifndef Py_LIMITED_API
/* Create a new string from a buffer of Py_UCS1, Py_UCS2 or Py_UCS4 characters.
   Scan the string to find the maximum character. */
@NoException public static native PyObject PyUnicode_FromKindAndData(
    int kind,
    @Const Pointer buffer,
    @Cast("Py_ssize_t") long size);

/* Create a new string from a buffer of ASCII characters.
   WARNING: Don't check if the string contains any non-ASCII character. */
@NoException public static native PyObject _PyUnicode_FromASCII(
    @Cast("const char*") BytePointer buffer,
    @Cast("Py_ssize_t") long size);
@NoException public static native PyObject _PyUnicode_FromASCII(
    String buffer,
    @Cast("Py_ssize_t") long size);
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyUnicode_Substring(
    PyObject str,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end);
// #endif

// #ifndef Py_LIMITED_API
/* Compute the maximum character of the substring unicode[start:end].
   Return 127 for an empty string. */
@NoException public static native @Cast("Py_UCS4") int _PyUnicode_FindMaxChar(
    PyObject unicode,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end);
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
/* Copy the string into a UCS4 buffer including the null character if copy_null
   is set. Return NULL and raise an exception on error. Raise a SystemError if
   the buffer is smaller than the string. Return buffer on success.

   buflen is the length of the buffer in (Py_UCS4) characters. */
@NoException public static native @Cast("Py_UCS4*") IntPointer PyUnicode_AsUCS4(
    PyObject unicode,
    @Cast("Py_UCS4*") IntPointer buffer,
    @Cast("Py_ssize_t") long buflen,
    int copy_null);
@NoException public static native @Cast("Py_UCS4*") IntBuffer PyUnicode_AsUCS4(
    PyObject unicode,
    @Cast("Py_UCS4*") IntBuffer buffer,
    @Cast("Py_ssize_t") long buflen,
    int copy_null);
@NoException public static native @Cast("Py_UCS4*") int[] PyUnicode_AsUCS4(
    PyObject unicode,
    @Cast("Py_UCS4*") int[] buffer,
    @Cast("Py_ssize_t") long buflen,
    int copy_null);

/* Copy the string into a UCS4 buffer. A new buffer is allocated using
 * PyMem_Malloc; if this fails, NULL is returned with a memory error
   exception set. */
@NoException public static native @Cast("Py_UCS4*") IntPointer PyUnicode_AsUCS4Copy(PyObject unicode);
// #endif

// #ifndef Py_LIMITED_API
/* Return a read-only pointer to the Unicode object's internal
   Py_UNICODE buffer.
   If the wchar_t/Py_UNICODE representation is not yet available, this
   function will calculate it. */

@NoException public static native @Cast("Py_UNICODE*") Pointer PyUnicode_AsUnicode(
    PyObject unicode
    );

/* Similar to PyUnicode_AsUnicode(), but raises a ValueError if the string
   contains null characters. */
@NoException public static native @Cast("const Py_UNICODE*") Pointer _PyUnicode_AsUnicode(
    PyObject unicode
    );

/* Return a read-only pointer to the Unicode object's internal
   Py_UNICODE buffer and save the length at size.
   If the wchar_t/Py_UNICODE representation is not yet available, this
   function will calculate it. */

@NoException public static native @Cast("Py_UNICODE*") Pointer PyUnicode_AsUnicodeAndSize(
    PyObject unicode,
    @Cast("Py_ssize_t*") SizeTPointer size
    );
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
/* Get the length of the Unicode object. */

@NoException public static native @Cast("Py_ssize_t") long PyUnicode_GetLength(
    PyObject unicode
);
// #endif

/* Get the number of Py_UNICODE units in the
   string representation. */

@NoException public static native @Cast("Py_ssize_t") long PyUnicode_GetSize(
    PyObject unicode
    );

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
/* Read a character from the string. */

@NoException public static native @Cast("Py_UCS4") int PyUnicode_ReadChar(
    PyObject unicode,
    @Cast("Py_ssize_t") long index
    );

/* Write a character to the string. The string must have been created through
   PyUnicode_New, must not be shared, and must not have been hashed yet.

   Return 0 on success, -1 on error. */

@NoException public static native int PyUnicode_WriteChar(
    PyObject unicode,
    @Cast("Py_ssize_t") long index,
    @Cast("Py_UCS4") int character
    );
// #endif

// #ifndef Py_LIMITED_API
/* Get the maximum ordinal for a Unicode character. */
@NoException public static native @Cast("Py_UNICODE") char PyUnicode_GetMax();
// #endif

/* Resize a Unicode object. The length is the number of characters, except
   if the kind of the string is PyUnicode_WCHAR_KIND: in this case, the length
   is the number of Py_UNICODE characters.

   *unicode is modified to point to the new (resized) object and 0
   returned on success.

   Try to resize the string in place (which is usually faster than allocating
   a new string and copy characters), or create a new string.

   Error handling is implemented as follows: an exception is set, -1
   is returned and *unicode left untouched.

   WARNING: The function doesn't check string content, the result may not be a
            string in canonical representation. */

@NoException public static native int PyUnicode_Resize(
    @Cast("PyObject**") PointerPointer unicode,
    @Cast("Py_ssize_t") long length
    );
@NoException public static native int PyUnicode_Resize(
    @ByPtrPtr PyObject unicode,
    @Cast("Py_ssize_t") long length
    );

/* Decode obj to a Unicode object.

   bytes, bytearray and other bytes-like objects are decoded according to the
   given encoding and error handler. The encoding and error handler can be
   NULL to have the interface use UTF-8 and "strict".

   All other objects (including Unicode objects) raise an exception.

   The API returns NULL in case of an error. The caller is responsible
   for decref'ing the returned objects.

*/

@NoException public static native PyObject PyUnicode_FromEncodedObject(
    PyObject obj,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_FromEncodedObject(
    PyObject obj,
    String encoding,
    String errors
    );

/* Copy an instance of a Unicode subtype to a new true Unicode object if
   necessary. If obj is already a true Unicode object (not a subtype), return
   the reference with *incremented* refcount.

   The API returns NULL in case of an error. The caller is responsible
   for decref'ing the returned objects.

*/

@NoException public static native PyObject PyUnicode_FromObject(
    PyObject obj
    );

@NoException public static native PyObject PyUnicode_FromFormatV(
    @Cast("const char*") BytePointer format,
    @ByVal @Cast("va_list*") Pointer vargs
    );
@NoException public static native PyObject PyUnicode_FromFormatV(
    String format,
    @ByVal @Cast("va_list*") Pointer vargs
    );
@NoException public static native PyObject PyUnicode_FromFormat(
    @Cast("const char*") BytePointer format
    );
@NoException public static native PyObject PyUnicode_FromFormat(
    String format
    );
// Targeting ../python/_PyUnicodeWriter.java



/* Initialize a Unicode writer.
 *
 * By default, the minimum buffer size is 0 character and overallocation is
 * disabled. Set min_length, min_char and overallocate attributes to control
 * the allocation of the buffer. */
@NoException public static native void _PyUnicodeWriter_Init(_PyUnicodeWriter writer);

/* Prepare the buffer to write 'length' characters
   with the specified maximum character.

   Return 0 on success, raise an exception and return -1 on error. */
// #define _PyUnicodeWriter_Prepare(WRITER, LENGTH, MAXCHAR)
//     (((MAXCHAR) <= (WRITER)->maxchar
//       && (LENGTH) <= (WRITER)->size - (WRITER)->pos)
//      ? 0
//      : (((LENGTH) == 0)
//         ? 0
//         : _PyUnicodeWriter_PrepareInternal((WRITER), (LENGTH), (MAXCHAR))))

/* Don't call this function directly, use the _PyUnicodeWriter_Prepare() macro
   instead. */
@NoException public static native int _PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter writer,
                                 @Cast("Py_ssize_t") long length, @Cast("Py_UCS4") int maxchar);

/* Prepare the buffer to have at least the kind KIND.
   For example, kind=PyUnicode_2BYTE_KIND ensures that the writer will
   support characters in range U+000-U+FFFF.

   Return 0 on success, raise an exception and return -1 on error. */
// #define _PyUnicodeWriter_PrepareKind(WRITER, KIND)
//     (assert((KIND) != PyUnicode_WCHAR_KIND),
//      (KIND) <= (WRITER)->kind
//      ? 0
//      : _PyUnicodeWriter_PrepareKindInternal((WRITER), (KIND)))

/* Don't call this function directly, use the _PyUnicodeWriter_PrepareKind()
   macro instead. */
@NoException public static native int _PyUnicodeWriter_PrepareKindInternal(_PyUnicodeWriter writer,
                                     @Cast("PyUnicode_Kind") int kind);

/* Append a Unicode character.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyUnicodeWriter_WriteChar(_PyUnicodeWriter writer,
    @Cast("Py_UCS4") int ch
    );

/* Append a Unicode string.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyUnicodeWriter_WriteStr(_PyUnicodeWriter writer,
    PyObject str
    );

/* Append a substring of a Unicode string.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyUnicodeWriter_WriteSubstring(_PyUnicodeWriter writer,
    PyObject str,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end
    );

/* Append an ASCII-encoded byte string.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyUnicodeWriter_WriteASCIIString(_PyUnicodeWriter writer,
    @Cast("const char*") BytePointer str,
    @Cast("Py_ssize_t") long len
    );
@NoException public static native int _PyUnicodeWriter_WriteASCIIString(_PyUnicodeWriter writer,
    String str,
    @Cast("Py_ssize_t") long len
    );

/* Append a latin1-encoded byte string.
   Return 0 on success, raise an exception and return -1 on error. */
@NoException public static native int _PyUnicodeWriter_WriteLatin1String(_PyUnicodeWriter writer,
    @Cast("const char*") BytePointer str,
    @Cast("Py_ssize_t") long len
    );
@NoException public static native int _PyUnicodeWriter_WriteLatin1String(_PyUnicodeWriter writer,
    String str,
    @Cast("Py_ssize_t") long len
    );

/* Get the value of the writer as a Unicode string. Clear the
   buffer of the writer. Raise an exception and return NULL
   on error. */
@NoException public static native PyObject _PyUnicodeWriter_Finish(_PyUnicodeWriter writer);

/* Deallocate memory of a writer (clear its internal buffer). */
@NoException public static native void _PyUnicodeWriter_Dealloc(_PyUnicodeWriter writer);
// #endif

// #ifndef Py_LIMITED_API
/* Format the object based on the format_spec, as defined in PEP 3101
   (Advanced String Formatting). */
@NoException public static native int _PyUnicode_FormatAdvancedWriter(
    _PyUnicodeWriter writer,
    PyObject obj,
    PyObject format_spec,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end);
// #endif

@NoException public static native void PyUnicode_InternInPlace(@Cast("PyObject**") PointerPointer arg0);
@NoException public static native void PyUnicode_InternInPlace(@ByPtrPtr PyObject arg0);
@NoException public static native void PyUnicode_InternImmortal(@Cast("PyObject**") PointerPointer arg0);
@NoException public static native void PyUnicode_InternImmortal(@ByPtrPtr PyObject arg0);
@NoException public static native PyObject PyUnicode_InternFromString(
    @Cast("const char*") BytePointer u
    );
@NoException public static native PyObject PyUnicode_InternFromString(
    String u
    );
// #ifndef Py_LIMITED_API
@NoException public static native void _Py_ReleaseInternedUnicodeStrings();
// #endif

/* Use only if you know it's a string */
// #define PyUnicode_CHECK_INTERNED(op)
//     (((PyASCIIObject *)(op))->state.interned)

/* --- wchar_t support for platforms which support it --------------------- */

// #ifdef HAVE_WCHAR_H

// #endif

/* --- Unicode ordinals --------------------------------------------------- */

/* Create a Unicode Object from the given Unicode code point ordinal.

   The ordinal must be in range(0x110000). A ValueError is
   raised in case it is not.

*/

@NoException public static native PyObject PyUnicode_FromOrdinal(int ordinal);

/* --- Free-list management ----------------------------------------------- */

/* Clear the free list used by the Unicode implementation.

   This can be used to release memory used for objects on the free
   list back to the Python memory allocator.

*/

@NoException public static native int PyUnicode_ClearFreeList();

/* === Builtin Codecs =====================================================

   Many of these APIs take two arguments encoding and errors. These
   parameters encoding and errors have the same semantics as the ones
   of the builtin str() API.

   Setting encoding to NULL causes the default encoding (UTF-8) to be used.

   Error handling is set by errors which may also be set to NULL
   meaning to use the default handling defined for the codec. Default
   error handling for all builtin codecs is "strict" (ValueErrors are
   raised).

   The codecs all use a similar interface. Only deviation from the
   generic ones are documented.

*/

/* --- Manage the default encoding ---------------------------------------- */

/* Returns a pointer to the default encoding (UTF-8) of the
   Unicode object unicode and the size of the encoded representation
   in bytes stored in *size.

   In case of an error, no *size is set.

   This function caches the UTF-8 encoded string in the unicodeobject
   and subsequent calls will return the same string.  The memory is released
   when the unicodeobject is deallocated.

   _PyUnicode_AsStringAndSize is a #define for PyUnicode_AsUTF8AndSize to
   support the previous internal function with the same behaviour.

   *** This API is for interpreter INTERNAL USE ONLY and will likely
   *** be removed or changed in the future.

   *** If you need to access the Unicode object as UTF-8 bytes string,
   *** please use PyUnicode_AsUTF8String() instead.
*/

// #ifndef Py_LIMITED_API
@NoException public static native @Cast("char*") BytePointer PyUnicode_AsUTF8AndSize(
    PyObject unicode,
    @Cast("Py_ssize_t*") SizeTPointer size);
// #define _PyUnicode_AsStringAndSize PyUnicode_AsUTF8AndSize
// #endif

/* Returns a pointer to the default encoding (UTF-8) of the
   Unicode object unicode.

   Like PyUnicode_AsUTF8AndSize(), this also caches the UTF-8 representation
   in the unicodeobject.

   _PyUnicode_AsString is a #define for PyUnicode_AsUTF8 to
   support the previous internal function with the same behaviour.

   Use of this API is DEPRECATED since no size information can be
   extracted from the returned data.

   *** This API is for interpreter INTERNAL USE ONLY and will likely
   *** be removed or changed for Python 3.1.

   *** If you need to access the Unicode object as UTF-8 bytes string,
   *** please use PyUnicode_AsUTF8String() instead.

*/

// #ifndef Py_LIMITED_API
@NoException public static native @Cast("char*") BytePointer PyUnicode_AsUTF8(PyObject unicode);
// #define _PyUnicode_AsString PyUnicode_AsUTF8
// #endif

/* Returns "utf-8".  */

@NoException public static native @Cast("const char*") BytePointer PyUnicode_GetDefaultEncoding();

/* --- Generic Codecs ----------------------------------------------------- */

/* Create a Unicode object by decoding the encoded string s of the
   given size. */

@NoException public static native PyObject PyUnicode_Decode(
    @Cast("const char*") BytePointer s,
    @Cast("Py_ssize_t") long size,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_Decode(
    String s,
    @Cast("Py_ssize_t") long size,
    String encoding,
    String errors
    );

/* Decode a Unicode object unicode and return the result as Python
   object.

   This API is DEPRECATED. The only supported standard encoding is rot13.
   Use PyCodec_Decode() to decode with rot13 and non-standard codecs
   that decode from str. */

@NoException public static native PyObject PyUnicode_AsDecodedObject(
    PyObject unicode,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_AsDecodedObject(
    PyObject unicode,
    String encoding,
    String errors
    );

/* Decode a Unicode object unicode and return the result as Unicode
   object.

   This API is DEPRECATED. The only supported standard encoding is rot13.
   Use PyCodec_Decode() to decode with rot13 and non-standard codecs
   that decode from str to str. */

@NoException public static native PyObject PyUnicode_AsDecodedUnicode(
    PyObject unicode,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_AsDecodedUnicode(
    PyObject unicode,
    String encoding,
    String errors
    );

/* Encodes a Py_UNICODE buffer of the given size and returns a
   Python string object. */

// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyUnicode_Encode(
    @Cast("const Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long size,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_Encode(
    @Cast("const Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long size,
    String encoding,
    String errors
    );
// #endif

/* Encodes a Unicode object and returns the result as Python
   object.

   This API is DEPRECATED.  It is superceeded by PyUnicode_AsEncodedString()
   since all standard encodings (except rot13) encode str to bytes.
   Use PyCodec_Encode() for encoding with rot13 and non-standard codecs
   that encode form str to non-bytes. */

@NoException public static native PyObject PyUnicode_AsEncodedObject(
    PyObject unicode,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_AsEncodedObject(
    PyObject unicode,
    String encoding,
    String errors
    );

/* Encodes a Unicode object and returns the result as Python string
   object. */

@NoException public static native PyObject PyUnicode_AsEncodedString(
    PyObject unicode,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_AsEncodedString(
    PyObject unicode,
    String encoding,
    String errors
    );

/* Encodes a Unicode object and returns the result as Unicode
   object.

   This API is DEPRECATED.  The only supported standard encodings is rot13.
   Use PyCodec_Encode() to encode with rot13 and non-standard codecs
   that encode from str to str. */

@NoException public static native PyObject PyUnicode_AsEncodedUnicode(
    PyObject unicode,
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_AsEncodedUnicode(
    PyObject unicode,
    String encoding,
    String errors
    );

/* Build an encoding map. */

@NoException public static native PyObject PyUnicode_BuildEncodingMap(
    PyObject string
   );

/* --- UTF-7 Codecs ------------------------------------------------------- */

@NoException public static native PyObject PyUnicode_DecodeUTF7(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeUTF7(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

@NoException public static native PyObject PyUnicode_DecodeUTF7Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF7Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );

// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyUnicode_EncodeUTF7(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    int base64SetO,
    int base64WhiteSpace,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_EncodeUTF7(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    int base64SetO,
    int base64WhiteSpace,
    String errors
    );
@NoException public static native PyObject _PyUnicode_EncodeUTF7(
    PyObject unicode,
    int base64SetO,
    int base64WhiteSpace,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject _PyUnicode_EncodeUTF7(
    PyObject unicode,
    int base64SetO,
    int base64WhiteSpace,
    String errors
    );
// #endif

/* --- UTF-8 Codecs ------------------------------------------------------- */

@NoException public static native PyObject PyUnicode_DecodeUTF8(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeUTF8(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

@NoException public static native PyObject PyUnicode_DecodeUTF8Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF8Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );

@NoException public static native PyObject PyUnicode_AsUTF8String(
    PyObject unicode
    );

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyUnicode_AsUTF8String(
    PyObject unicode,
    @Cast("const char*") BytePointer errors);
@NoException public static native PyObject _PyUnicode_AsUTF8String(
    PyObject unicode,
    String errors);

@NoException public static native PyObject PyUnicode_EncodeUTF8(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_EncodeUTF8(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    String errors
    );
// #endif

/* --- UTF-32 Codecs ------------------------------------------------------ */

/* Decodes length bytes from a UTF-32 encoded buffer string and returns
   the corresponding Unicode object.

   errors (if non-NULL) defines the error handling. It defaults
   to "strict".

   If byteorder is non-NULL, the decoder starts decoding using the
   given byte order:

    *byteorder == -1: little endian
    *byteorder == 0:  native order
    *byteorder == 1:  big endian

   In native mode, the first four bytes of the stream are checked for a
   BOM mark. If found, the BOM mark is analysed, the byte order
   adjusted and the BOM skipped.  In the other modes, no BOM mark
   interpretation is done. After completion, *byteorder is set to the
   current byte order at the end of input data.

   If byteorder is NULL, the codec starts in native order mode.

*/

@NoException public static native PyObject PyUnicode_DecodeUTF32(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntPointer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntBuffer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    int[] byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntPointer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntBuffer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    int[] byteorder
    );

@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntPointer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntBuffer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    int[] byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntPointer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntBuffer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF32Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    int[] byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );

/* Returns a Python string using the UTF-32 encoding in native byte
   order. The string always starts with a BOM mark.  */

@NoException public static native PyObject PyUnicode_AsUTF32String(
    PyObject unicode
    );

/* Returns a Python string object holding the UTF-32 encoded value of
   the Unicode data.

   If byteorder is not 0, output is written according to the following
   byte order:

   byteorder == -1: little endian
   byteorder == 0:  native byte order (writes a BOM mark)
   byteorder == 1:  big endian

   If byteorder is 0, the output string will always start with the
   Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is
   prepended.

*/

// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyUnicode_EncodeUTF32(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    int byteorder
    );
@NoException public static native PyObject PyUnicode_EncodeUTF32(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    String errors,
    int byteorder
    );
@NoException public static native PyObject _PyUnicode_EncodeUTF32(
    PyObject object,
    @Cast("const char*") BytePointer errors,
    int byteorder
    );
@NoException public static native PyObject _PyUnicode_EncodeUTF32(
    PyObject object,
    String errors,
    int byteorder
    );
// #endif

/* --- UTF-16 Codecs ------------------------------------------------------ */

/* Decodes length bytes from a UTF-16 encoded buffer string and returns
   the corresponding Unicode object.

   errors (if non-NULL) defines the error handling. It defaults
   to "strict".

   If byteorder is non-NULL, the decoder starts decoding using the
   given byte order:

    *byteorder == -1: little endian
    *byteorder == 0:  native order
    *byteorder == 1:  big endian

   In native mode, the first two bytes of the stream are checked for a
   BOM mark. If found, the BOM mark is analysed, the byte order
   adjusted and the BOM skipped.  In the other modes, no BOM mark
   interpretation is done. After completion, *byteorder is set to the
   current byte order at the end of input data.

   If byteorder is NULL, the codec starts in native order mode.

*/

@NoException public static native PyObject PyUnicode_DecodeUTF16(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntPointer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntBuffer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    int[] byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntPointer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntBuffer byteorder
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    int[] byteorder
    );

@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntPointer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntBuffer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    int[] byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    IntPointer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    IntBuffer byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );
@NoException public static native PyObject PyUnicode_DecodeUTF16Stateful(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors,
    int[] byteorder,
    @Cast("Py_ssize_t*") SizeTPointer consumed
    );

/* Returns a Python string using the UTF-16 encoding in native byte
   order. The string always starts with a BOM mark.  */

@NoException public static native PyObject PyUnicode_AsUTF16String(
    PyObject unicode
    );

/* Returns a Python string object holding the UTF-16 encoded value of
   the Unicode data.

   If byteorder is not 0, output is written according to the following
   byte order:

   byteorder == -1: little endian
   byteorder == 0:  native byte order (writes a BOM mark)
   byteorder == 1:  big endian

   If byteorder is 0, the output string will always start with the
   Unicode BOM mark (U+FEFF). In the other two modes, no BOM mark is
   prepended.

   Note that Py_UNICODE data is being interpreted as UTF-16 reduced to
   UCS-2. This trick makes it possible to add full UTF-16 capabilities
   at a later point without compromising the APIs.

*/

// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyUnicode_EncodeUTF16(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors,
    int byteorder
    );
@NoException public static native PyObject PyUnicode_EncodeUTF16(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    String errors,
    int byteorder
    );
@NoException public static native PyObject _PyUnicode_EncodeUTF16(
    PyObject unicode,
    @Cast("const char*") BytePointer errors,
    int byteorder
    );
@NoException public static native PyObject _PyUnicode_EncodeUTF16(
    PyObject unicode,
    String errors,
    int byteorder
    );
// #endif

/* --- Unicode-Escape Codecs ---------------------------------------------- */

@NoException public static native PyObject PyUnicode_DecodeUnicodeEscape(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeUnicodeEscape(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

// #ifndef Py_LIMITED_API
/* Helper for PyUnicode_DecodeUnicodeEscape that detects invalid escape
   chars. */
@NoException public static native PyObject _PyUnicode_DecodeUnicodeEscape(
        @Cast("const char*") BytePointer string,
        @Cast("Py_ssize_t") long length,
        @Cast("const char*") BytePointer errors,
        @Cast("const char**") PointerPointer first_invalid_escape
);
@NoException public static native PyObject _PyUnicode_DecodeUnicodeEscape(
        @Cast("const char*") BytePointer string,
        @Cast("Py_ssize_t") long length,
        @Cast("const char*") BytePointer errors,
        @Cast("const char**") @ByPtrPtr BytePointer first_invalid_escape
);
@NoException public static native PyObject _PyUnicode_DecodeUnicodeEscape(
        String string,
        @Cast("Py_ssize_t") long length,
        String errors,
        @Cast("const char**") @ByPtrPtr ByteBuffer first_invalid_escape
);
@NoException public static native PyObject _PyUnicode_DecodeUnicodeEscape(
        @Cast("const char*") BytePointer string,
        @Cast("Py_ssize_t") long length,
        @Cast("const char*") BytePointer errors,
        @Cast("const char**") @ByPtrPtr byte[] first_invalid_escape
);
@NoException public static native PyObject _PyUnicode_DecodeUnicodeEscape(
        String string,
        @Cast("Py_ssize_t") long length,
        String errors,
        @Cast("const char**") @ByPtrPtr BytePointer first_invalid_escape
);
@NoException public static native PyObject _PyUnicode_DecodeUnicodeEscape(
        @Cast("const char*") BytePointer string,
        @Cast("Py_ssize_t") long length,
        @Cast("const char*") BytePointer errors,
        @Cast("const char**") @ByPtrPtr ByteBuffer first_invalid_escape
);
@NoException public static native PyObject _PyUnicode_DecodeUnicodeEscape(
        String string,
        @Cast("Py_ssize_t") long length,
        String errors,
        @Cast("const char**") @ByPtrPtr byte[] first_invalid_escape
);
// #endif

@NoException public static native PyObject PyUnicode_AsUnicodeEscapeString(
    PyObject unicode
    );

// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyUnicode_EncodeUnicodeEscape(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length
    );
// #endif

/* --- Raw-Unicode-Escape Codecs ------------------------------------------ */

@NoException public static native PyObject PyUnicode_DecodeRawUnicodeEscape(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeRawUnicodeEscape(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

@NoException public static native PyObject PyUnicode_AsRawUnicodeEscapeString(
    PyObject unicode
    );

// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyUnicode_EncodeRawUnicodeEscape(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length
    );
// #endif

/* --- Unicode Internal Codec ---------------------------------------------

    Only for internal use in _codecsmodule.c */

// #ifndef Py_LIMITED_API

// #endif

/* --- Latin-1 Codecs -----------------------------------------------------

   Note: Latin-1 corresponds to the first 256 Unicode ordinals.

*/

@NoException public static native PyObject PyUnicode_DecodeLatin1(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeLatin1(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

@NoException public static native PyObject PyUnicode_AsLatin1String(
    PyObject unicode
    );

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyUnicode_AsLatin1String(
    PyObject unicode,
    @Cast("const char*") BytePointer errors);
@NoException public static native PyObject _PyUnicode_AsLatin1String(
    PyObject unicode,
    String errors);

@NoException public static native PyObject PyUnicode_EncodeLatin1(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_EncodeLatin1(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    String errors
    );
// #endif

/* --- ASCII Codecs -------------------------------------------------------

   Only 7-bit ASCII data is excepted. All other codes generate errors.

*/

@NoException public static native PyObject PyUnicode_DecodeASCII(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeASCII(
    String string,
    @Cast("Py_ssize_t") long length,
    String errors
    );

@NoException public static native PyObject PyUnicode_AsASCIIString(
    PyObject unicode
    );

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyUnicode_AsASCIIString(
    PyObject unicode,
    @Cast("const char*") BytePointer errors);
@NoException public static native PyObject _PyUnicode_AsASCIIString(
    PyObject unicode,
    String errors);

@NoException public static native PyObject PyUnicode_EncodeASCII(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_EncodeASCII(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    String errors
    );
// #endif

/* --- Character Map Codecs -----------------------------------------------

   This codec uses mappings to encode and decode characters.

   Decoding mappings must map byte ordinals (integers in the range from 0 to
   255) to Unicode strings, integers (which are then interpreted as Unicode
   ordinals) or None.  Unmapped data bytes (ones which cause a LookupError)
   as well as mapped to None, 0xFFFE or '\u005Cufffe' are treated as "undefined
   mapping" and cause an error.

   Encoding mappings must map Unicode ordinal integers to bytes objects,
   integers in the range from 0 to 255 or None.  Unmapped character
   ordinals (ones which cause a LookupError) as well as mapped to
   None are treated as "undefined mapping" and cause an error.

*/

@NoException public static native PyObject PyUnicode_DecodeCharmap(
    @Cast("const char*") BytePointer string,
    @Cast("Py_ssize_t") long length,
    PyObject mapping,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_DecodeCharmap(
    String string,
    @Cast("Py_ssize_t") long length,
    PyObject mapping,
    String errors
    );

@NoException public static native PyObject PyUnicode_AsCharmapString(
    PyObject unicode,
    PyObject mapping
    );

// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyUnicode_EncodeCharmap(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    PyObject mapping,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_EncodeCharmap(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    PyObject mapping,
    String errors
    );
@NoException public static native PyObject _PyUnicode_EncodeCharmap(
    PyObject unicode,
    PyObject mapping,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject _PyUnicode_EncodeCharmap(
    PyObject unicode,
    PyObject mapping,
    String errors
    );
// #endif

/* Translate a Py_UNICODE buffer of the given length by applying a
   character mapping table to it and return the resulting Unicode
   object.

   The mapping table must map Unicode ordinal integers to Unicode strings,
   Unicode ordinal integers or None (causing deletion of the character).

   Mapping tables may be dictionaries or sequences. Unmapped character
   ordinals (ones which cause a LookupError) are left untouched and
   are copied as-is.

*/

// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyUnicode_TranslateCharmap(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    PyObject table,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_TranslateCharmap(
    @Cast("const Py_UNICODE*") Pointer data,
    @Cast("Py_ssize_t") long length,
    PyObject table,
    String errors
    );
// #endif

// #ifdef MS_WINDOWS

// #endif /* MS_WINDOWS */

/* --- Decimal Encoder ---------------------------------------------------- */

/* Takes a Unicode string holding a decimal value and writes it into
   an output buffer using standard ASCII digit codes.

   The output buffer has to provide at least length+1 bytes of storage
   area. The output string is 0-terminated.

   The encoder converts whitespace to ' ', decimal characters to their
   corresponding ASCII digit and all other Latin-1 characters except
   \0 as-is. Characters outside this range (Unicode ordinals 1-256)
   are treated as errors. This includes embedded NULL bytes.

   Error handling is defined by the errors argument:

      NULL or "strict": raise a ValueError
      "ignore": ignore the wrong characters (these are not copied to the
                output buffer)
      "replace": replaces illegal characters with '?'

   Returns 0 on success, -1 on failure.

*/

// #ifndef Py_LIMITED_API
@NoException public static native int PyUnicode_EncodeDecimal(
    @Cast("Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long length,
    @Cast("char*") BytePointer output,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native int PyUnicode_EncodeDecimal(
    @Cast("Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long length,
    @Cast("char*") ByteBuffer output,
    String errors
    );
@NoException public static native int PyUnicode_EncodeDecimal(
    @Cast("Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long length,
    @Cast("char*") byte[] output,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native int PyUnicode_EncodeDecimal(
    @Cast("Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long length,
    @Cast("char*") BytePointer output,
    String errors
    );
@NoException public static native int PyUnicode_EncodeDecimal(
    @Cast("Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long length,
    @Cast("char*") ByteBuffer output,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native int PyUnicode_EncodeDecimal(
    @Cast("Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long length,
    @Cast("char*") byte[] output,
    String errors
    );
// #endif

/* Transforms code points that have decimal digit property to the
   corresponding ASCII digit code points.

   Returns a new Unicode string on success, NULL on failure.
*/

// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyUnicode_TransformDecimalToASCII(
    @Cast("Py_UNICODE*") Pointer s,
    @Cast("Py_ssize_t") long length
    );
// #endif

/* Similar to PyUnicode_TransformDecimalToASCII(), but takes a PyObject
   as argument instead of a raw buffer and length.  This function additionally
   transforms spaces to ASCII because this is what the callers in longobject,
   floatobject, and complexobject did anyways. */

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyUnicode_TransformDecimalAndSpaceToASCII(
    PyObject unicode
    );
// #endif

/* --- Locale encoding --------------------------------------------------- */

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
/* Decode a string from the current locale encoding. The decoder is strict if
   *surrogateescape* is equal to zero, otherwise it uses the 'surrogateescape'
   error handler (PEP 383) to escape undecodable bytes. If a byte sequence can
   be decoded as a surrogate character and *surrogateescape* is not equal to
   zero, the byte sequence is escaped using the 'surrogateescape' error handler
   instead of being decoded. *str* must end with a null character but cannot
   contain embedded null characters. */

@NoException public static native PyObject PyUnicode_DecodeLocaleAndSize(
    @Cast("const char*") BytePointer str,
    @Cast("Py_ssize_t") long len,
    @Cast("const char*") BytePointer errors);
@NoException public static native PyObject PyUnicode_DecodeLocaleAndSize(
    String str,
    @Cast("Py_ssize_t") long len,
    String errors);

/* Similar to PyUnicode_DecodeLocaleAndSize(), but compute the string
   length using strlen(). */

@NoException public static native PyObject PyUnicode_DecodeLocale(
    @Cast("const char*") BytePointer str,
    @Cast("const char*") BytePointer errors);
@NoException public static native PyObject PyUnicode_DecodeLocale(
    String str,
    String errors);

/* Encode a Unicode object to the current locale encoding. The encoder is
   strict is *surrogateescape* is equal to zero, otherwise the
   "surrogateescape" error handler is used. Return a bytes object. The string
   cannot contain embedded null characters. */

@NoException public static native PyObject PyUnicode_EncodeLocale(
    PyObject unicode,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_EncodeLocale(
    PyObject unicode,
    String errors
    );
// #endif

/* --- File system encoding ---------------------------------------------- */

/* ParseTuple converter: encode str objects to bytes using
   PyUnicode_EncodeFSDefault(); bytes objects are output as-is. */

@NoException public static native int PyUnicode_FSConverter(PyObject arg0, Pointer arg1);

/* ParseTuple converter: decode bytes objects to unicode using
   PyUnicode_DecodeFSDefaultAndSize(); str objects are output as-is. */

@NoException public static native int PyUnicode_FSDecoder(PyObject arg0, Pointer arg1);

/* Decode a null-terminated string using Py_FileSystemDefaultEncoding
   and the "surrogateescape" error handler.

   If Py_FileSystemDefaultEncoding is not set, fall back to the locale
   encoding.

   Use PyUnicode_DecodeFSDefaultAndSize() if the string length is known.
*/

@NoException public static native PyObject PyUnicode_DecodeFSDefault(
    @Cast("const char*") BytePointer s
    );
@NoException public static native PyObject PyUnicode_DecodeFSDefault(
    String s
    );

/* Decode a string using Py_FileSystemDefaultEncoding
   and the "surrogateescape" error handler.

   If Py_FileSystemDefaultEncoding is not set, fall back to the locale
   encoding.
*/

@NoException public static native PyObject PyUnicode_DecodeFSDefaultAndSize(
    @Cast("const char*") BytePointer s,
    @Cast("Py_ssize_t") long size
    );
@NoException public static native PyObject PyUnicode_DecodeFSDefaultAndSize(
    String s,
    @Cast("Py_ssize_t") long size
    );

/* Encode a Unicode object to Py_FileSystemDefaultEncoding with the
   "surrogateescape" error handler, and return bytes.

   If Py_FileSystemDefaultEncoding is not set, fall back to the locale
   encoding.
*/

@NoException public static native PyObject PyUnicode_EncodeFSDefault(
    PyObject unicode
    );

/* --- Methods & Slots ----------------------------------------------------

   These are capable of handling Unicode objects and strings on input
   (we refer to them as strings in the descriptions) and return
   Unicode objects or integers as appropriate. */

/* Concat two strings giving a new Unicode string. */

@NoException public static native PyObject PyUnicode_Concat(
    PyObject left,
    PyObject right
    );

/* Concat two strings and put the result in *pleft
   (sets *pleft to NULL on error) */

@NoException public static native void PyUnicode_Append(
    @Cast("PyObject**") PointerPointer pleft,
    PyObject right
    );
@NoException public static native void PyUnicode_Append(
    @ByPtrPtr PyObject pleft,
    PyObject right
    );

/* Concat two strings, put the result in *pleft and drop the right object
   (sets *pleft to NULL on error) */

@NoException public static native void PyUnicode_AppendAndDel(
    @Cast("PyObject**") PointerPointer pleft,
    PyObject right
    );
@NoException public static native void PyUnicode_AppendAndDel(
    @ByPtrPtr PyObject pleft,
    PyObject right
    );

/* Split a string giving a list of Unicode strings.

   If sep is NULL, splitting will be done at all whitespace
   substrings. Otherwise, splits occur at the given separator.

   At most maxsplit splits will be done. If negative, no limit is set.

   Separators are not included in the resulting list.

*/

@NoException public static native PyObject PyUnicode_Split(
    PyObject s,
    PyObject sep,
    @Cast("Py_ssize_t") long maxsplit
    );

/* Dito, but split at line breaks.

   CRLF is considered to be one line break. Line breaks are not
   included in the resulting list. */

@NoException public static native PyObject PyUnicode_Splitlines(
    PyObject s,
    int keepends
    );

/* Partition a string using a given separator. */

@NoException public static native PyObject PyUnicode_Partition(
    PyObject s,
    PyObject sep
    );

/* Partition a string using a given separator, searching from the end of the
   string. */

@NoException public static native PyObject PyUnicode_RPartition(
    PyObject s,
    PyObject sep
    );

/* Split a string giving a list of Unicode strings.

   If sep is NULL, splitting will be done at all whitespace
   substrings. Otherwise, splits occur at the given separator.

   At most maxsplit splits will be done. But unlike PyUnicode_Split
   PyUnicode_RSplit splits from the end of the string. If negative,
   no limit is set.

   Separators are not included in the resulting list.

*/

@NoException public static native PyObject PyUnicode_RSplit(
    PyObject s,
    PyObject sep,
    @Cast("Py_ssize_t") long maxsplit
    );

/* Translate a string by applying a character mapping table to it and
   return the resulting Unicode object.

   The mapping table must map Unicode ordinal integers to Unicode strings,
   Unicode ordinal integers or None (causing deletion of the character).

   Mapping tables may be dictionaries or sequences. Unmapped character
   ordinals (ones which cause a LookupError) are left untouched and
   are copied as-is.

*/

@NoException public static native PyObject PyUnicode_Translate(
    PyObject str,
    PyObject table,
    @Cast("const char*") BytePointer errors
    );
@NoException public static native PyObject PyUnicode_Translate(
    PyObject str,
    PyObject table,
    String errors
    );

/* Join a sequence of strings using the given separator and return
   the resulting Unicode string. */

@NoException public static native PyObject PyUnicode_Join(
    PyObject separator,
    PyObject seq
    );

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyUnicode_JoinArray(
    PyObject separator,
    @Cast("PyObject**") PointerPointer items,
    @Cast("Py_ssize_t") long seqlen
    );
@NoException public static native PyObject _PyUnicode_JoinArray(
    PyObject separator,
    @ByPtrPtr PyObject items,
    @Cast("Py_ssize_t") long seqlen
    );
// #endif /* Py_LIMITED_API */

/* Return 1 if substr matches str[start:end] at the given tail end, 0
   otherwise. */

@NoException public static native @Cast("Py_ssize_t") long PyUnicode_Tailmatch(
    PyObject str,
    PyObject substr,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    int direction
    );

/* Return the first position of substr in str[start:end] using the
   given search direction or -1 if not found. -2 is returned in case
   an error occurred and an exception is set. */

@NoException public static native @Cast("Py_ssize_t") long PyUnicode_Find(
    PyObject str,
    PyObject substr,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    int direction
    );

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
/* Like PyUnicode_Find, but search for single character only. */
@NoException public static native @Cast("Py_ssize_t") long PyUnicode_FindChar(
    PyObject str,
    @Cast("Py_UCS4") int ch,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    int direction
    );
// #endif

/* Count the number of occurrences of substr in str[start:end]. */

@NoException public static native @Cast("Py_ssize_t") long PyUnicode_Count(
    PyObject str,
    PyObject substr,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end
    );

/* Replace at most maxcount occurrences of substr in str with replstr
   and return the resulting Unicode object. */

@NoException public static native PyObject PyUnicode_Replace(
    PyObject str,
    PyObject substr,
    PyObject replstr,
    @Cast("Py_ssize_t") long maxcount
    );

/* Compare two strings and return -1, 0, 1 for less than, equal,
   greater than resp.
   Raise an exception and return -1 on error. */

@NoException public static native int PyUnicode_Compare(
    PyObject left,
    PyObject right
    );

// #ifndef Py_LIMITED_API
/* Test whether a unicode is equal to ASCII identifier.  Return 1 if true,
   0 otherwise.  The right argument must be ASCII identifier.
   Any error occurs inside will be cleared before return. */

@NoException public static native int _PyUnicode_EqualToASCIIId(
    PyObject left,
    _Py_Identifier right
    );
// #endif

/* Compare a Unicode object with C string and return -1, 0, 1 for less than,
   equal, and greater than, respectively.  It is best to pass only
   ASCII-encoded strings, but the function interprets the input string as
   ISO-8859-1 if it contains non-ASCII characters.
   This function does not raise exceptions. */

@NoException public static native int PyUnicode_CompareWithASCIIString(
    PyObject left,
    @Cast("const char*") BytePointer right
    );
@NoException public static native int PyUnicode_CompareWithASCIIString(
    PyObject left,
    String right
    );

// #ifndef Py_LIMITED_API
/* Test whether a unicode is equal to ASCII string.  Return 1 if true,
   0 otherwise.  The right argument must be ASCII-encoded string.
   Any error occurs inside will be cleared before return. */

@NoException public static native int _PyUnicode_EqualToASCIIString(
    PyObject left,
    @Cast("const char*") BytePointer right
    );
@NoException public static native int _PyUnicode_EqualToASCIIString(
    PyObject left,
    String right
    );
// #endif

/* Rich compare two strings and return one of the following:

   - NULL in case an exception was raised
   - Py_True or Py_False for successful comparisons
   - Py_NotImplemented in case the type combination is unknown

   Possible values for op:

     Py_GT, Py_GE, Py_EQ, Py_NE, Py_LT, Py_LE

*/

@NoException public static native PyObject PyUnicode_RichCompare(
    PyObject left,
    PyObject right,
    int op
    );

/* Apply an argument tuple or dictionary to a format string and return
   the resulting Unicode string. */

@NoException public static native PyObject PyUnicode_Format(
    PyObject format,
    PyObject args
    );

/* Checks whether element is contained in container and return 1/0
   accordingly.

   element has to coerce to a one element Unicode string. -1 is
   returned in case of an error. */

@NoException public static native int PyUnicode_Contains(
    PyObject container,
    PyObject element
    );

/* Checks whether argument is a valid identifier. */

@NoException public static native int PyUnicode_IsIdentifier(PyObject s);

// #ifndef Py_LIMITED_API
/* Externally visible for str.strip(unicode) */
@NoException public static native PyObject _PyUnicode_XStrip(
    PyObject self,
    int striptype,
    PyObject sepobj
    );
// #endif

/* Using explicit passed-in values, insert the thousands grouping
   into the string pointed to by buffer.  For the argument descriptions,
   see Objects/stringlib/localeutil.h */
// #ifndef Py_LIMITED_API
@NoException public static native @Cast("Py_ssize_t") long _PyUnicode_InsertThousandsGrouping(
    PyObject unicode,
    @Cast("Py_ssize_t") long index,
    @Cast("Py_ssize_t") long n_buffer,
    Pointer digits,
    @Cast("Py_ssize_t") long n_digits,
    @Cast("Py_ssize_t") long min_width,
    @Cast("const char*") BytePointer grouping,
    PyObject thousands_sep,
    @Cast("Py_UCS4*") IntPointer maxchar);
@NoException public static native @Cast("Py_ssize_t") long _PyUnicode_InsertThousandsGrouping(
    PyObject unicode,
    @Cast("Py_ssize_t") long index,
    @Cast("Py_ssize_t") long n_buffer,
    Pointer digits,
    @Cast("Py_ssize_t") long n_digits,
    @Cast("Py_ssize_t") long min_width,
    String grouping,
    PyObject thousands_sep,
    @Cast("Py_UCS4*") IntBuffer maxchar);
@NoException public static native @Cast("Py_ssize_t") long _PyUnicode_InsertThousandsGrouping(
    PyObject unicode,
    @Cast("Py_ssize_t") long index,
    @Cast("Py_ssize_t") long n_buffer,
    Pointer digits,
    @Cast("Py_ssize_t") long n_digits,
    @Cast("Py_ssize_t") long min_width,
    @Cast("const char*") BytePointer grouping,
    PyObject thousands_sep,
    @Cast("Py_UCS4*") int[] maxchar);
@NoException public static native @Cast("Py_ssize_t") long _PyUnicode_InsertThousandsGrouping(
    PyObject unicode,
    @Cast("Py_ssize_t") long index,
    @Cast("Py_ssize_t") long n_buffer,
    Pointer digits,
    @Cast("Py_ssize_t") long n_digits,
    @Cast("Py_ssize_t") long min_width,
    String grouping,
    PyObject thousands_sep,
    @Cast("Py_UCS4*") IntPointer maxchar);
@NoException public static native @Cast("Py_ssize_t") long _PyUnicode_InsertThousandsGrouping(
    PyObject unicode,
    @Cast("Py_ssize_t") long index,
    @Cast("Py_ssize_t") long n_buffer,
    Pointer digits,
    @Cast("Py_ssize_t") long n_digits,
    @Cast("Py_ssize_t") long min_width,
    @Cast("const char*") BytePointer grouping,
    PyObject thousands_sep,
    @Cast("Py_UCS4*") IntBuffer maxchar);
@NoException public static native @Cast("Py_ssize_t") long _PyUnicode_InsertThousandsGrouping(
    PyObject unicode,
    @Cast("Py_ssize_t") long index,
    @Cast("Py_ssize_t") long n_buffer,
    Pointer digits,
    @Cast("Py_ssize_t") long n_digits,
    @Cast("Py_ssize_t") long min_width,
    String grouping,
    PyObject thousands_sep,
    @Cast("Py_UCS4*") int[] maxchar);
// #endif
/* === Characters Type APIs =============================================== */

/* Helper array used by Py_UNICODE_ISSPACE(). */

// #ifndef Py_LIMITED_API
@MemberGetter public static native @Cast("const unsigned char") byte _Py_ascii_whitespace(int i);
@MemberGetter public static native @Cast("const unsigned char*") BytePointer _Py_ascii_whitespace();

/* These should not be used directly. Use the Py_UNICODE_IS* and
   Py_UNICODE_TO* macros instead.

   These APIs are implemented in Objects/unicodectype.c.

*/

@NoException public static native int _PyUnicode_IsLowercase(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsUppercase(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsTitlecase(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsXidStart(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsXidContinue(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsWhitespace(
    @Cast("const Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsLinebreak(
    @Cast("const Py_UCS4") int ch
    );

@NoException public static native @Cast("Py_UCS4") int _PyUnicode_ToLowercase(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native @Cast("Py_UCS4") int _PyUnicode_ToUppercase(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native @Cast("Py_UCS4") int _PyUnicode_ToTitlecase(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_ToLowerFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") IntPointer res
    );
@NoException public static native int _PyUnicode_ToLowerFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") IntBuffer res
    );
@NoException public static native int _PyUnicode_ToLowerFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") int[] res
    );

@NoException public static native int _PyUnicode_ToTitleFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") IntPointer res
    );
@NoException public static native int _PyUnicode_ToTitleFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") IntBuffer res
    );
@NoException public static native int _PyUnicode_ToTitleFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") int[] res
    );

@NoException public static native int _PyUnicode_ToUpperFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") IntPointer res
    );
@NoException public static native int _PyUnicode_ToUpperFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") IntBuffer res
    );
@NoException public static native int _PyUnicode_ToUpperFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") int[] res
    );

@NoException public static native int _PyUnicode_ToFoldedFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") IntPointer res
    );
@NoException public static native int _PyUnicode_ToFoldedFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") IntBuffer res
    );
@NoException public static native int _PyUnicode_ToFoldedFull(
    @Cast("Py_UCS4") int ch,
    @Cast("Py_UCS4*") int[] res
    );

@NoException public static native int _PyUnicode_IsCaseIgnorable(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsCased(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_ToDecimalDigit(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_ToDigit(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native double _PyUnicode_ToNumeric(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsDecimalDigit(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsDigit(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsNumeric(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsPrintable(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native int _PyUnicode_IsAlpha(
    @Cast("Py_UCS4") int ch
    );

@NoException public static native @Cast("size_t") long Py_UNICODE_strlen(
    @Cast("const Py_UNICODE*") Pointer u
    );

@NoException public static native @Cast("Py_UNICODE*") Pointer Py_UNICODE_strcpy(
    @Cast("Py_UNICODE*") Pointer s1,
    @Cast("const Py_UNICODE*") Pointer s2);

@NoException public static native @Cast("Py_UNICODE*") Pointer Py_UNICODE_strcat(
    @Cast("Py_UNICODE*") Pointer s1, @Cast("const Py_UNICODE*") Pointer s2);

@NoException public static native @Cast("Py_UNICODE*") Pointer Py_UNICODE_strncpy(
    @Cast("Py_UNICODE*") Pointer s1,
    @Cast("const Py_UNICODE*") Pointer s2,
    @Cast("size_t") long n);

@NoException public static native int Py_UNICODE_strcmp(
    @Cast("const Py_UNICODE*") Pointer s1,
    @Cast("const Py_UNICODE*") Pointer s2
    );

@NoException public static native int Py_UNICODE_strncmp(
    @Cast("const Py_UNICODE*") Pointer s1,
    @Cast("const Py_UNICODE*") Pointer s2,
    @Cast("size_t") long n
    );

@NoException public static native @Cast("Py_UNICODE*") Pointer Py_UNICODE_strchr(
    @Cast("const Py_UNICODE*") Pointer s,
    @Cast("Py_UNICODE") char c
    );
@NoException public static native @Cast("Py_UNICODE*") Pointer Py_UNICODE_strchr(
    @Cast("const Py_UNICODE*") Pointer s,
    @Cast("Py_UNICODE") int c
    );

@NoException public static native @Cast("Py_UNICODE*") Pointer Py_UNICODE_strrchr(
    @Cast("const Py_UNICODE*") Pointer s,
    @Cast("Py_UNICODE") char c
    );
@NoException public static native @Cast("Py_UNICODE*") Pointer Py_UNICODE_strrchr(
    @Cast("const Py_UNICODE*") Pointer s,
    @Cast("Py_UNICODE") int c
    );

@NoException public static native PyObject _PyUnicode_FormatLong(PyObject arg0, int arg1, int arg2, int arg3);

/* Create a copy of a unicode string ending with a nul character. Return NULL
   and raise a MemoryError exception on memory allocation failure, otherwise
   return a new allocated buffer (use PyMem_Free() to free the buffer). */

@NoException public static native @Cast("Py_UNICODE*") Pointer PyUnicode_AsUnicodeCopy(
    PyObject unicode
    );
// #endif /* Py_LIMITED_API */

// #if defined(Py_DEBUG) && !defined(Py_LIMITED_API)
@NoException public static native int _PyUnicode_CheckConsistency(
    PyObject op,
    int check_content);
// #elif !defined(NDEBUG)
/* For asserts that call _PyUnicode_CheckConsistency(), which would
 * otherwise be a problem when building with asserts but without Py_DEBUG. */
// #define _PyUnicode_CheckConsistency(op, check_content) PyUnicode_Check(op)
// #endif

// #ifndef Py_LIMITED_API
/* Return an interned Unicode object for an Identifier; may fail if there is no memory.*/
@NoException public static native PyObject _PyUnicode_FromId(_Py_Identifier arg0);
/* Clear all static strings. */
@NoException public static native void _PyUnicode_ClearStaticStrings();

/* Fast equality check when the inputs are known to be exact unicode types
   and where the hash values are equal (i.e. a very probable match) */
@NoException public static native int _PyUnicode_EQ(PyObject arg0, PyObject arg1);
// #endif /* !Py_LIMITED_API */

// #ifdef __cplusplus
// #endif
// #endif /* !Py_UNICODEOBJECT_H */


// Parsed from longobject.h

// #ifndef Py_LONGOBJECT_H
// #define Py_LONGOBJECT_H
// #ifdef __cplusplus
// Targeting ../python/PyLongObject.java

 /* Revealed in longintrepr.h */

public static native @ByRef PyTypeObject PyLong_Type(); public static native void PyLong_Type(PyTypeObject PyLong_Type);

// #define PyLong_Check(op)
//         PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_LONG_SUBCLASS)
// #define PyLong_CheckExact(op) (Py_TYPE(op) == &PyLong_Type)

@NoException public static native PyObject PyLong_FromLong(long arg0);
@NoException public static native PyObject PyLong_FromUnsignedLong(@Cast("unsigned long") long arg0);
@NoException public static native PyObject PyLong_FromSize_t(@Cast("size_t") long arg0);
@NoException public static native PyObject PyLong_FromSsize_t(@Cast("Py_ssize_t") long arg0);
@NoException public static native PyObject PyLong_FromDouble(double arg0);
@NoException public static native long PyLong_AsLongAndOverflow(PyObject arg0, IntPointer arg1);
@NoException public static native long PyLong_AsLongAndOverflow(PyObject arg0, IntBuffer arg1);
@NoException public static native long PyLong_AsLongAndOverflow(PyObject arg0, int[] arg1);
@NoException public static native @Cast("Py_ssize_t") long PyLong_AsSsize_t(PyObject arg0);
@NoException public static native @Cast("size_t") long PyLong_AsSize_t(PyObject arg0);
@NoException public static native @Cast("unsigned long") long PyLong_AsUnsignedLong(PyObject arg0);
@NoException public static native @Cast("unsigned long") long PyLong_AsUnsignedLongMask(PyObject arg0);
// #ifndef Py_LIMITED_API
@NoException public static native int _PyLong_AsInt(PyObject arg0);
// #endif
@NoException public static native PyObject PyLong_GetInfo();

/* It may be useful in the future. I've added it in the PyInt -> PyLong
   cleanup to keep the extra information. [CH] */
// #define PyLong_AS_LONG(op) PyLong_AsLong(op)

/* Issue #1983: pid_t can be longer than a C long on some systems */
// #if !defined(SIZEOF_PID_T) || SIZEOF_PID_T == SIZEOF_INT
public static final String _Py_PARSE_PID = "i";
// #define PyLong_FromPid PyLong_FromLong
// #define PyLong_AsPid PyLong_AsLong
// #elif SIZEOF_PID_T == SIZEOF_LONG
// #define PyLong_FromPid PyLong_FromLong
// #define PyLong_AsPid PyLong_AsLong
// #elif defined(SIZEOF_LONG_LONG) && SIZEOF_PID_T == SIZEOF_LONG_LONG
// #define PyLong_FromPid PyLong_FromLongLong
// #define PyLong_AsPid PyLong_AsLongLong
// #else
// #error "sizeof(pid_t) is neither sizeof(int), sizeof(long) or sizeof(long long)"
// #endif /* SIZEOF_PID_T */

// #if SIZEOF_VOID_P == SIZEOF_INT
public static final String _Py_PARSE_INTPTR = "i";
public static final String _Py_PARSE_UINTPTR = "I";
// #elif SIZEOF_VOID_P == SIZEOF_LONG
// #elif defined(SIZEOF_LONG_LONG) && SIZEOF_VOID_P == SIZEOF_LONG_LONG
// #else
// #  error "void* different in size from int, long and long long"
// #endif /* SIZEOF_VOID_P */

/* Used by Python/mystrtoul.c, _PyBytes_FromHex(),
   _PyBytes_DecodeEscapeRecode(), etc. */
// #ifndef Py_LIMITED_API
public static native @Cast("unsigned char") byte _PyLong_DigitValue(int i); public static native void _PyLong_DigitValue(int i, byte _PyLong_DigitValue);
@MemberGetter public static native @Cast("unsigned char*") BytePointer _PyLong_DigitValue();
// #endif

/* _PyLong_Frexp returns a double x and an exponent e such that the
   true value is approximately equal to x * 2**e.  e is >= 0.  x is
   0.0 if and only if the input is 0 (in which case, e and x are both
   zeroes); otherwise, 0.5 <= abs(x) < 1.0.  On overflow, which is
   possible if the number of bits doesn't fit into a Py_ssize_t, sets
   OverflowError and returns -1.0 for x, 0 for e. */
// #ifndef Py_LIMITED_API
@NoException public static native double _PyLong_Frexp(PyLongObject a, @Cast("Py_ssize_t*") SizeTPointer e);
// #endif

@NoException public static native double PyLong_AsDouble(PyObject arg0);
@NoException public static native PyObject PyLong_FromVoidPtr(Pointer arg0);
@NoException public static native Pointer PyLong_AsVoidPtr(PyObject arg0);

@NoException public static native PyObject PyLong_FromLongLong(long arg0);
@NoException public static native PyObject PyLong_FromUnsignedLongLong(@Cast("unsigned long long") long arg0);
@NoException public static native long PyLong_AsLongLong(PyObject arg0);
@NoException public static native @Cast("unsigned long long") long PyLong_AsUnsignedLongLong(PyObject arg0);
@NoException public static native @Cast("unsigned long long") long PyLong_AsUnsignedLongLongMask(PyObject arg0);
@NoException public static native long PyLong_AsLongLongAndOverflow(PyObject arg0, IntPointer arg1);
@NoException public static native long PyLong_AsLongLongAndOverflow(PyObject arg0, IntBuffer arg1);
@NoException public static native long PyLong_AsLongLongAndOverflow(PyObject arg0, int[] arg1);

@NoException public static native PyObject PyLong_FromString(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native PyObject PyLong_FromString(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyLong_FromUnicode(@Cast("Py_UNICODE*") Pointer arg0, @Cast("Py_ssize_t") long arg1, int arg2);
@NoException public static native PyObject PyLong_FromUnicodeObject(PyObject u, int base);
@NoException public static native PyObject _PyLong_FromBytes(@Cast("const char*") BytePointer arg0, @Cast("Py_ssize_t") long arg1, int arg2);
@NoException public static native PyObject _PyLong_FromBytes(String arg0, @Cast("Py_ssize_t") long arg1, int arg2);
// #endif

// #ifndef Py_LIMITED_API
/* _PyLong_Sign.  Return 0 if v is 0, -1 if v < 0, +1 if v > 0.
   v must not be NULL, and must be a normalized long.
   There are no error cases.
*/
@NoException public static native int _PyLong_Sign(PyObject v);


/* _PyLong_NumBits.  Return the number of bits needed to represent the
   absolute value of a long.  For example, this returns 1 for 1 and -1, 2
   for 2 and -2, and 2 for 3 and -3.  It returns 0 for 0.
   v must not be NULL, and must be a normalized long.
   (size_t)-1 is returned and OverflowError set if the true result doesn't
   fit in a size_t.
*/
@NoException public static native @Cast("size_t") long _PyLong_NumBits(PyObject v);

/* _PyLong_DivmodNear.  Given integers a and b, compute the nearest
   integer q to the exact quotient a / b, rounding to the nearest even integer
   in the case of a tie.  Return (q, r), where r = a - q*b.  The remainder r
   will satisfy abs(r) <= abs(b)/2, with equality possible only if q is
   even.
*/
@NoException public static native PyObject _PyLong_DivmodNear(PyObject arg0, PyObject arg1);

/* _PyLong_FromByteArray:  View the n unsigned bytes as a binary integer in
   base 256, and return a Python int with the same numeric value.
   If n is 0, the integer is 0.  Else:
   If little_endian is 1/true, bytes[n-1] is the MSB and bytes[0] the LSB;
   else (little_endian is 0/false) bytes[0] is the MSB and bytes[n-1] the
   LSB.
   If is_signed is 0/false, view the bytes as a non-negative integer.
   If is_signed is 1/true, view the bytes as a 2's-complement integer,
   non-negative if bit 0x80 of the MSB is clear, negative if set.
   Error returns:
   + Return NULL with the appropriate exception set if there's not
     enough memory to create the Python int.
*/
@NoException public static native PyObject _PyLong_FromByteArray(
    @Cast("const unsigned char*") BytePointer bytes, @Cast("size_t") long n,
    int little_endian, int is_signed);
@NoException public static native PyObject _PyLong_FromByteArray(
    @Cast("const unsigned char*") ByteBuffer bytes, @Cast("size_t") long n,
    int little_endian, int is_signed);
@NoException public static native PyObject _PyLong_FromByteArray(
    @Cast("const unsigned char*") byte[] bytes, @Cast("size_t") long n,
    int little_endian, int is_signed);

/* _PyLong_AsByteArray: Convert the least-significant 8*n bits of long
   v to a base-256 integer, stored in array bytes.  Normally return 0,
   return -1 on error.
   If little_endian is 1/true, store the MSB at bytes[n-1] and the LSB at
   bytes[0]; else (little_endian is 0/false) store the MSB at bytes[0] and
   the LSB at bytes[n-1].
   If is_signed is 0/false, it's an error if v < 0; else (v >= 0) n bytes
   are filled and there's nothing special about bit 0x80 of the MSB.
   If is_signed is 1/true, bytes is filled with the 2's-complement
   representation of v's value.  Bit 0x80 of the MSB is the sign bit.
   Error returns (-1):
   + is_signed is 0 and v < 0.  TypeError is set in this case, and bytes
     isn't altered.
   + n isn't big enough to hold the full mathematical value of v.  For
     example, if is_signed is 0 and there are more digits in the v than
     fit in n; or if is_signed is 1, v < 0, and n is just 1 bit shy of
     being large enough to hold a sign bit.  OverflowError is set in this
     case, but bytes holds the least-significant n bytes of the true value.
*/
@NoException public static native int _PyLong_AsByteArray(PyLongObject v,
    @Cast("unsigned char*") BytePointer bytes, @Cast("size_t") long n,
    int little_endian, int is_signed);
@NoException public static native int _PyLong_AsByteArray(PyLongObject v,
    @Cast("unsigned char*") ByteBuffer bytes, @Cast("size_t") long n,
    int little_endian, int is_signed);
@NoException public static native int _PyLong_AsByteArray(PyLongObject v,
    @Cast("unsigned char*") byte[] bytes, @Cast("size_t") long n,
    int little_endian, int is_signed);

/* _PyLong_FromNbInt: Convert the given object to a PyLongObject
   using the nb_int slot, if available.  Raise TypeError if either the
   nb_int slot is not available or the result of the call to nb_int
   returns something not of type int.
*/
@NoException public static native PyLongObject _PyLong_FromNbInt(PyObject arg0);

/* _PyLong_Format: Convert the long to a string object with given base,
   appending a base prefix of 0[box] if base is 2, 8 or 16. */
@NoException public static native PyObject _PyLong_Format(PyObject obj, int base);

@NoException public static native int _PyLong_FormatWriter(
    _PyUnicodeWriter writer,
    PyObject obj,
    int base,
    int alternate);

@NoException public static native @Cast("char*") BytePointer _PyLong_FormatBytesWriter(
    _PyBytesWriter writer,
    @Cast("char*") BytePointer str,
    PyObject obj,
    int base,
    int alternate);
@NoException public static native @Cast("char*") ByteBuffer _PyLong_FormatBytesWriter(
    _PyBytesWriter writer,
    @Cast("char*") ByteBuffer str,
    PyObject obj,
    int base,
    int alternate);
@NoException public static native @Cast("char*") byte[] _PyLong_FormatBytesWriter(
    _PyBytesWriter writer,
    @Cast("char*") byte[] str,
    PyObject obj,
    int base,
    int alternate);

/* Format the object based on the format_spec, as defined in PEP 3101
   (Advanced String Formatting). */
@NoException public static native int _PyLong_FormatAdvancedWriter(
    _PyUnicodeWriter writer,
    PyObject obj,
    PyObject format_spec,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end);
// #endif /* Py_LIMITED_API */

/* These aren't really part of the int object, but they're handy. The
   functions are in Python/mystrtoul.c.
 */
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native @Cast("unsigned long") long PyOS_strtoul(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
@NoException public static native long PyOS_strtol(@Cast("const char*") BytePointer arg0, @Cast("char**") PointerPointer arg1, int arg2);
@NoException public static native long PyOS_strtol(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native long PyOS_strtol(String arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native long PyOS_strtol(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);
@NoException public static native long PyOS_strtol(String arg0, @Cast("char**") @ByPtrPtr BytePointer arg1, int arg2);
@NoException public static native long PyOS_strtol(@Cast("const char*") BytePointer arg0, @Cast("char**") @ByPtrPtr ByteBuffer arg1, int arg2);
@NoException public static native long PyOS_strtol(String arg0, @Cast("char**") @ByPtrPtr byte[] arg1, int arg2);

// #ifndef Py_LIMITED_API
/* For use by the gcd function in mathmodule.c */
@NoException public static native PyObject _PyLong_GCD(PyObject arg0, PyObject arg1);
// #endif /* !Py_LIMITED_API */

// #ifdef __cplusplus
// #endif
// #endif /* !Py_LONGOBJECT_H */


// Parsed from longintrepr.h

// #ifndef Py_LIMITED_API
// #ifndef Py_LONGINTREPR_H
// #define Py_LONGINTREPR_H
// #ifdef __cplusplus
// #endif


/* This is published for the benefit of "friends" marshal.c and _decimal.c. */

/* Parameters of the integer representation.  There are two different
   sets of parameters: one set for 30-bit digits, stored in an unsigned 32-bit
   integer type, and one set for 15-bit digits with each digit stored in an
   unsigned short.  The value of PYLONG_BITS_IN_DIGIT, defined either at
   configure time or in pyport.h, is used to decide which digit size to use.

   Type 'digit' should be able to hold 2*PyLong_BASE-1, and type 'twodigits'
   should be an unsigned integer type able to hold all integers up to
   PyLong_BASE*PyLong_BASE-1.  x_sub assumes that 'digit' is an unsigned type,
   and that overflow is handled by taking the result modulo 2**N for some N >
   PyLong_SHIFT.  The majority of the code doesn't care about the precise
   value of PyLong_SHIFT, but there are some notable exceptions:

   - long_pow() requires that PyLong_SHIFT be divisible by 5

   - PyLong_{As,From}ByteArray require that PyLong_SHIFT be at least 8

   - long_hash() requires that PyLong_SHIFT is *strictly* less than the number
     of bits in an unsigned long, as do the PyLong <-> long (or unsigned long)
     conversion functions

   - the Python int <-> size_t/Py_ssize_t conversion functions expect that
     PyLong_SHIFT is strictly less than the number of bits in a size_t

   - the marshal code currently expects that PyLong_SHIFT is a multiple of 15

   - NSMALLNEGINTS and NSMALLPOSINTS should be small enough to fit in a single
     digit; with the current values this forces PyLong_SHIFT >= 9

  The values 15 and 30 should fit all of the above requirements, on any
  platform.
*/

// #if PYLONG_BITS_IN_DIGIT == 30 /* signed variant of digit */ /* signed variant of twodigits */
public static final int PyLong_SHIFT =	30;
public static final int _PyLong_DECIMAL_SHIFT =	9; /* max(e such that 10**e fits in a digit) */
public static final int _PyLong_DECIMAL_BASE =	((int)1000000000); /* 10 ** DECIMAL_SHIFT */
// #elif PYLONG_BITS_IN_DIGIT == 15 /* signed variant of digit */ /* signed variant of twodigits */ /* max(e such that 10**e fits in a digit) */ /* 10 ** DECIMAL_SHIFT */
// #else
// #error "PYLONG_BITS_IN_DIGIT should be 15 or 30"
// #endif
public static native @MemberGetter int PyLong_BASE();
public static final int PyLong_BASE = PyLong_BASE();
public static native @MemberGetter int PyLong_MASK();
public static final int PyLong_MASK = PyLong_MASK();

// #if PyLong_SHIFT % 5 != 0
// #error "longobject.c requires that PyLong_SHIFT be divisible by 5"
// Targeting ../python/_longobject.java



@NoException public static native PyLongObject _PyLong_New(@Cast("Py_ssize_t") long arg0);

/* Return a copy of src. */
@NoException public static native PyObject _PyLong_Copy(PyLongObject src);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_LONGINTREPR_H */
// #endif /* Py_LIMITED_API */


// Parsed from boolobject.h

/* Boolean object interface */

// #ifndef Py_BOOLOBJECT_H
// #define Py_BOOLOBJECT_H
// #ifdef __cplusplus
// #endif


public static native @ByRef PyTypeObject PyBool_Type(); public static native void PyBool_Type(PyTypeObject PyBool_Type);

// #define PyBool_Check(x) (Py_TYPE(x) == &PyBool_Type)

/* Py_False and Py_True are the only two bools in existence.
Don't forget to apply Py_INCREF() when returning either!!! */

/* Don't use these directly */
public static native @ByRef _longobject _Py_FalseStruct(); public static native void _Py_FalseStruct(_longobject _Py_FalseStruct);
public static native @ByRef _longobject _Py_TrueStruct(); public static native void _Py_TrueStruct(_longobject _Py_TrueStruct);

/* Use these macros */
// #define Py_False ((PyObject *) &_Py_FalseStruct)
// #define Py_True ((PyObject *) &_Py_TrueStruct)

/* Macros for returning Py_True or Py_False, respectively */
// #define Py_RETURN_TRUE return Py_INCREF(Py_True), Py_True
// #define Py_RETURN_FALSE return Py_INCREF(Py_False), Py_False

/* Function to return a bool from a C long */
@NoException public static native PyObject PyBool_FromLong(long arg0);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_BOOLOBJECT_H */


// Parsed from floatobject.h


/* Float object interface */

/*
PyFloatObject represents a (double precision) floating point number.
*/

// #ifndef Py_FLOATOBJECT_H
// #define Py_FLOATOBJECT_H
// #ifdef __cplusplus
// Targeting ../python/PyFloatObject.java


// #endif

public static native @ByRef PyTypeObject PyFloat_Type(); public static native void PyFloat_Type(PyTypeObject PyFloat_Type);

// #define PyFloat_Check(op) PyObject_TypeCheck(op, &PyFloat_Type)
// #define PyFloat_CheckExact(op) (Py_TYPE(op) == &PyFloat_Type)

// #ifdef Py_NAN
// #endif

// #define Py_RETURN_INF(sign) do
//     if (copysign(1., sign) == 1.) {
//         return PyFloat_FromDouble(Py_HUGE_VAL);
//     } else {
//         return PyFloat_FromDouble(-Py_HUGE_VAL);
//     } while(0)

@NoException public static native double PyFloat_GetMax();
@NoException public static native double PyFloat_GetMin();
@NoException public static native PyObject PyFloat_GetInfo();

/* Return Python float from string PyObject. */
@NoException public static native PyObject PyFloat_FromString(PyObject arg0);

/* Return Python float from C double. */
@NoException public static native PyObject PyFloat_FromDouble(double arg0);

/* Extract C double from Python float.  The macro version trades safety for
   speed. */
@NoException public static native double PyFloat_AsDouble(PyObject arg0);
// #ifndef Py_LIMITED_API
// #define PyFloat_AS_DOUBLE(op) (((PyFloatObject *)(op))->ob_fval)
// #endif

// #ifndef Py_LIMITED_API
/* _PyFloat_{Pack,Unpack}{4,8}
 *
 * The struct and pickle (at least) modules need an efficient platform-
 * independent way to store floating-point values as byte strings.
 * The Pack routines produce a string from a C double, and the Unpack
 * routines produce a C double from such a string.  The suffix (4 or 8)
 * specifies the number of bytes in the string.
 *
 * On platforms that appear to use (see _PyFloat_Init()) IEEE-754 formats
 * these functions work by copying bits.  On other platforms, the formats the
 * 4- byte format is identical to the IEEE-754 single precision format, and
 * the 8-byte format to the IEEE-754 double precision format, although the
 * packing of INFs and NaNs (if such things exist on the platform) isn't
 * handled correctly, and attempting to unpack a string containing an IEEE
 * INF or NaN will raise an exception.
 *
 * On non-IEEE platforms with more precision, or larger dynamic range, than
 * 754 supports, not all values can be packed; on non-IEEE platforms with less
 * precision, or smaller dynamic range, not all values can be unpacked.  What
 * happens in such cases is partly accidental (alas).
 */

/* The pack routines write 2, 4 or 8 bytes, starting at p.  le is a bool
 * argument, true if you want the string in little-endian format (exponent
 * last, at p+1, p+3 or p+7), false if you want big-endian format (exponent
 * first, at p).
 * Return value:  0 if all is OK, -1 if error (and an exception is
 * set, most likely OverflowError).
 * There are two problems on non-IEEE platforms:
 * 1):  What this does is undefined if x is a NaN or infinity.
 * 2):  -0.0 and +0.0 produce the same string.
 */
@NoException public static native int _PyFloat_Pack2(double x, @Cast("unsigned char*") BytePointer p, int le);
@NoException public static native int _PyFloat_Pack2(double x, @Cast("unsigned char*") ByteBuffer p, int le);
@NoException public static native int _PyFloat_Pack2(double x, @Cast("unsigned char*") byte[] p, int le);
@NoException public static native int _PyFloat_Pack4(double x, @Cast("unsigned char*") BytePointer p, int le);
@NoException public static native int _PyFloat_Pack4(double x, @Cast("unsigned char*") ByteBuffer p, int le);
@NoException public static native int _PyFloat_Pack4(double x, @Cast("unsigned char*") byte[] p, int le);
@NoException public static native int _PyFloat_Pack8(double x, @Cast("unsigned char*") BytePointer p, int le);
@NoException public static native int _PyFloat_Pack8(double x, @Cast("unsigned char*") ByteBuffer p, int le);
@NoException public static native int _PyFloat_Pack8(double x, @Cast("unsigned char*") byte[] p, int le);

/* Needed for the old way for marshal to store a floating point number.
   Returns the string length copied into p, -1 on error.
 */


/* Used to get the important decimal digits of a double */



/* The unpack routines read 2, 4 or 8 bytes, starting at p.  le is a bool
 * argument, true if the string is in little-endian format (exponent
 * last, at p+1, p+3 or p+7), false if big-endian (exponent first, at p).
 * Return value:  The unpacked double.  On error, this is -1.0 and
 * PyErr_Occurred() is true (and an exception is set, most likely
 * OverflowError).  Note that on a non-IEEE platform this will refuse
 * to unpack a string that represents a NaN or infinity.
 */
@NoException public static native double _PyFloat_Unpack2(@Cast("const unsigned char*") BytePointer p, int le);
@NoException public static native double _PyFloat_Unpack2(@Cast("const unsigned char*") ByteBuffer p, int le);
@NoException public static native double _PyFloat_Unpack2(@Cast("const unsigned char*") byte[] p, int le);
@NoException public static native double _PyFloat_Unpack4(@Cast("const unsigned char*") BytePointer p, int le);
@NoException public static native double _PyFloat_Unpack4(@Cast("const unsigned char*") ByteBuffer p, int le);
@NoException public static native double _PyFloat_Unpack4(@Cast("const unsigned char*") byte[] p, int le);
@NoException public static native double _PyFloat_Unpack8(@Cast("const unsigned char*") BytePointer p, int le);
@NoException public static native double _PyFloat_Unpack8(@Cast("const unsigned char*") ByteBuffer p, int le);
@NoException public static native double _PyFloat_Unpack8(@Cast("const unsigned char*") byte[] p, int le);

/* free list api */
@NoException public static native int PyFloat_ClearFreeList();

@NoException public static native void _PyFloat_DebugMallocStats(@Cast("FILE*") Pointer out);

/* Format the object based on the format_spec, as defined in PEP 3101
   (Advanced String Formatting). */
@NoException public static native int _PyFloat_FormatAdvancedWriter(
    _PyUnicodeWriter writer,
    PyObject obj,
    PyObject format_spec,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end);
// #endif /* Py_LIMITED_API */

// #ifdef __cplusplus
// #endif
// #endif /* !Py_FLOATOBJECT_H */


// Parsed from complexobject.h

/* Complex number structure */

// #ifndef Py_COMPLEXOBJECT_H
// #define Py_COMPLEXOBJECT_H
// #ifdef __cplusplus
// Targeting ../python/Py_complex.java



/* Operations on complex numbers from complexmodule.c */

@NoException public static native @ByVal Py_complex _Py_c_sum(@ByVal Py_complex arg0, @ByVal Py_complex arg1);
@NoException public static native @ByVal Py_complex _Py_c_diff(@ByVal Py_complex arg0, @ByVal Py_complex arg1);
@NoException public static native @ByVal Py_complex _Py_c_neg(@ByVal Py_complex arg0);
@NoException public static native @ByVal Py_complex _Py_c_prod(@ByVal Py_complex arg0, @ByVal Py_complex arg1);
@NoException public static native @ByVal Py_complex _Py_c_quot(@ByVal Py_complex arg0, @ByVal Py_complex arg1);
@NoException public static native @ByVal Py_complex _Py_c_pow(@ByVal Py_complex arg0, @ByVal Py_complex arg1);
@NoException public static native double _Py_c_abs(@ByVal Py_complex arg0);
// Targeting ../python/PyComplexObject.java


// #endif

public static native @ByRef PyTypeObject PyComplex_Type(); public static native void PyComplex_Type(PyTypeObject PyComplex_Type);

// #define PyComplex_Check(op) PyObject_TypeCheck(op, &PyComplex_Type)
// #define PyComplex_CheckExact(op) (Py_TYPE(op) == &PyComplex_Type)

// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyComplex_FromCComplex(@ByVal Py_complex arg0);
// #endif
@NoException public static native PyObject PyComplex_FromDoubles(double real, double imag);

@NoException public static native double PyComplex_RealAsDouble(PyObject op);
@NoException public static native double PyComplex_ImagAsDouble(PyObject op);
// #ifndef Py_LIMITED_API
@NoException public static native @ByVal Py_complex PyComplex_AsCComplex(PyObject op);
// #endif

/* Format the object based on the format_spec, as defined in PEP 3101
   (Advanced String Formatting). */
// #ifndef Py_LIMITED_API
@NoException public static native int _PyComplex_FormatAdvancedWriter(
    _PyUnicodeWriter writer,
    PyObject obj,
    PyObject format_spec,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_COMPLEXOBJECT_H */


// Parsed from rangeobject.h


/* Range object interface */

// #ifndef Py_RANGEOBJECT_H
// #define Py_RANGEOBJECT_H
// #ifdef __cplusplus
// #endif

/*
A range object represents an integer range.  This is an immutable object;
a range cannot change its value after creation.

Range objects behave like the corresponding tuple objects except that
they are represented by a start, stop, and step datamembers.
*/

public static native @ByRef PyTypeObject PyRange_Type(); public static native void PyRange_Type(PyTypeObject PyRange_Type);
public static native @ByRef PyTypeObject PyRangeIter_Type(); public static native void PyRangeIter_Type(PyTypeObject PyRangeIter_Type);
public static native @ByRef PyTypeObject PyLongRangeIter_Type(); public static native void PyLongRangeIter_Type(PyTypeObject PyLongRangeIter_Type);

// #define PyRange_Check(op) (Py_TYPE(op) == &PyRange_Type)

// #ifdef __cplusplus
// #endif
// #endif /* !Py_RANGEOBJECT_H */


// Parsed from memoryobject.h

/* Memory view object. In Python this is available as "memoryview". */

// #ifndef Py_MEMORYOBJECT_H
// #define Py_MEMORYOBJECT_H
// #ifdef __cplusplus
// #endif

// #ifndef Py_LIMITED_API
public static native @ByRef PyTypeObject _PyManagedBuffer_Type(); public static native void _PyManagedBuffer_Type(PyTypeObject _PyManagedBuffer_Type);
// #endif
public static native @ByRef PyTypeObject PyMemoryView_Type(); public static native void PyMemoryView_Type(PyTypeObject PyMemoryView_Type);

// #define PyMemoryView_Check(op) (Py_TYPE(op) == &PyMemoryView_Type)

// #ifndef Py_LIMITED_API
/* Get a pointer to the memoryview's private copy of the exporter's buffer. */
// #define PyMemoryView_GET_BUFFER(op) (&((PyMemoryViewObject *)(op))->view)
/* Get a pointer to the exporting object (this may be NULL!). */
// #define PyMemoryView_GET_BASE(op) (((PyMemoryViewObject *)(op))->view.obj)
// #endif

@NoException public static native PyObject PyMemoryView_FromObject(PyObject base);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyMemoryView_FromMemory(@Cast("char*") BytePointer mem, @Cast("Py_ssize_t") long size,
                                               int flags);
@NoException public static native PyObject PyMemoryView_FromMemory(@Cast("char*") ByteBuffer mem, @Cast("Py_ssize_t") long size,
                                               int flags);
@NoException public static native PyObject PyMemoryView_FromMemory(@Cast("char*") byte[] mem, @Cast("Py_ssize_t") long size,
                                               int flags);
// #endif
// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyMemoryView_FromBuffer(Py_buffer info);
// #endif
@NoException public static native PyObject PyMemoryView_GetContiguous(PyObject base,
                                                  int buffertype,
                                                  @Cast("char") byte order);


/* The structs are declared here so that macros can work, but they shouldn't
   be considered public. Don't access their fields directly, use the macros
   and functions instead! */
// #ifndef Py_LIMITED_API
public static final int _Py_MANAGED_BUFFER_RELEASED =    0x001;  /* access to exporter blocked */
public static final int _Py_MANAGED_BUFFER_FREE_FORMAT = 0x002;
// Targeting ../python/_PyManagedBufferObject.java




/* memoryview state flags */
public static final int _Py_MEMORYVIEW_RELEASED =    0x001;  /* access to master buffer blocked */
public static final int _Py_MEMORYVIEW_C =           0x002;  /* C-contiguous layout */
public static final int _Py_MEMORYVIEW_FORTRAN =     0x004;  /* Fortran contiguous layout */
public static final int _Py_MEMORYVIEW_SCALAR =      0x008;  /* scalar: ndim = 0 */
public static final int _Py_MEMORYVIEW_PIL =         0x010;
// Targeting ../python/PyMemoryViewObject.java


// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_MEMORYOBJECT_H */


// Parsed from tupleobject.h


/* Tuple object interface */

// #ifndef Py_TUPLEOBJECT_H
// #define Py_TUPLEOBJECT_H
// #ifdef __cplusplus
// Targeting ../python/PyTupleObject.java


// #endif

public static native @ByRef PyTypeObject PyTuple_Type(); public static native void PyTuple_Type(PyTypeObject PyTuple_Type);
public static native @ByRef PyTypeObject PyTupleIter_Type(); public static native void PyTupleIter_Type(PyTypeObject PyTupleIter_Type);

// #define PyTuple_Check(op)
//                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TUPLE_SUBCLASS)
// #define PyTuple_CheckExact(op) (Py_TYPE(op) == &PyTuple_Type)

@NoException public static native PyObject PyTuple_New(@Cast("Py_ssize_t") long size);
@NoException public static native @Cast("Py_ssize_t") long PyTuple_Size(PyObject arg0);
@NoException public static native PyObject PyTuple_GetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int PyTuple_SetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1, PyObject arg2);
@NoException public static native PyObject PyTuple_GetSlice(PyObject arg0, @Cast("Py_ssize_t") long arg1, @Cast("Py_ssize_t") long arg2);
// #ifndef Py_LIMITED_API
@NoException public static native int _PyTuple_Resize(@Cast("PyObject**") PointerPointer arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int _PyTuple_Resize(@ByPtrPtr PyObject arg0, @Cast("Py_ssize_t") long arg1);
// #endif
@NoException public static native PyObject PyTuple_Pack(@Cast("Py_ssize_t") long arg0);
// #ifndef Py_LIMITED_API
@NoException public static native void _PyTuple_MaybeUntrack(PyObject arg0);
// #endif

/* Macro, trading safety for speed */
// #ifndef Py_LIMITED_API
// #define PyTuple_GET_ITEM(op, i) (((PyTupleObject *)(op))->ob_item[i])
// #define PyTuple_GET_SIZE(op)    Py_SIZE(op)

/* Macro, *only* to be used to fill in brand new tuples */
// #define PyTuple_SET_ITEM(op, i, v) (((PyTupleObject *)(op))->ob_item[i] = v)
// #endif

@NoException public static native int PyTuple_ClearFreeList();
// #ifndef Py_LIMITED_API
@NoException public static native void _PyTuple_DebugMallocStats(@Cast("FILE*") Pointer out);
// #endif /* Py_LIMITED_API */

// #ifdef __cplusplus
// #endif
// #endif /* !Py_TUPLEOBJECT_H */


// Parsed from listobject.h


/* List object interface */

/*
Another generally useful object type is a list of object pointers.
This is a mutable type: the list items can be changed, and items can be
added or removed.  Out-of-range indices or non-list objects are ignored.

*** WARNING *** PyList_SetItem does not increment the new item's reference
count, but does decrement the reference count of the item it replaces,
if not nil.  It does *decrement* the reference count if it is *not*
inserted in the list.  Similarly, PyList_GetItem does not increment the
returned item's reference count.
*/

// #ifndef Py_LISTOBJECT_H
// #define Py_LISTOBJECT_H
// #ifdef __cplusplus
// Targeting ../python/PyListObject.java


// #endif

public static native @ByRef PyTypeObject PyList_Type(); public static native void PyList_Type(PyTypeObject PyList_Type);
public static native @ByRef PyTypeObject PyListIter_Type(); public static native void PyListIter_Type(PyTypeObject PyListIter_Type);
public static native @ByRef PyTypeObject PyListRevIter_Type(); public static native void PyListRevIter_Type(PyTypeObject PyListRevIter_Type);


// #define PyList_Check(op)
//     PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_LIST_SUBCLASS)
// #define PyList_CheckExact(op) (Py_TYPE(op) == &PyList_Type)

@NoException public static native PyObject PyList_New(@Cast("Py_ssize_t") long size);
@NoException public static native @Cast("Py_ssize_t") long PyList_Size(PyObject arg0);
@NoException public static native PyObject PyList_GetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int PyList_SetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1, PyObject arg2);
@NoException public static native int PyList_Insert(PyObject arg0, @Cast("Py_ssize_t") long arg1, PyObject arg2);
@NoException public static native int PyList_Append(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyList_GetSlice(PyObject arg0, @Cast("Py_ssize_t") long arg1, @Cast("Py_ssize_t") long arg2);
@NoException public static native int PyList_SetSlice(PyObject arg0, @Cast("Py_ssize_t") long arg1, @Cast("Py_ssize_t") long arg2, PyObject arg3);
@NoException public static native int PyList_Sort(PyObject arg0);
@NoException public static native int PyList_Reverse(PyObject arg0);
@NoException public static native PyObject PyList_AsTuple(PyObject arg0);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyList_Extend(PyListObject arg0, PyObject arg1);

@NoException public static native int PyList_ClearFreeList();
@NoException public static native void _PyList_DebugMallocStats(@Cast("FILE*") Pointer out);
// #endif

/* Macro, trading safety for speed */
// #ifndef Py_LIMITED_API
// #define PyList_GET_ITEM(op, i) (((PyListObject *)(op))->ob_item[i])
// #define PyList_SET_ITEM(op, i, v) (((PyListObject *)(op))->ob_item[i] = (v))
// #define PyList_GET_SIZE(op)    Py_SIZE(op)
// #define _PyList_ITEMS(op)      (((PyListObject *)(op))->ob_item)
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_LISTOBJECT_H */


// Parsed from dictobject.h

// #ifndef Py_DICTOBJECT_H
// #define Py_DICTOBJECT_H
// #ifdef __cplusplus
// Targeting ../python/PyDictKeysObject.java


// Targeting ../python/PyDictObject.java


// Targeting ../python/_PyDictViewObject.java



// #endif /* Py_LIMITED_API */

public static native @ByRef PyTypeObject PyDict_Type(); public static native void PyDict_Type(PyTypeObject PyDict_Type);
public static native @ByRef PyTypeObject PyDictIterKey_Type(); public static native void PyDictIterKey_Type(PyTypeObject PyDictIterKey_Type);
public static native @ByRef PyTypeObject PyDictIterValue_Type(); public static native void PyDictIterValue_Type(PyTypeObject PyDictIterValue_Type);
public static native @ByRef PyTypeObject PyDictIterItem_Type(); public static native void PyDictIterItem_Type(PyTypeObject PyDictIterItem_Type);
public static native @ByRef PyTypeObject PyDictKeys_Type(); public static native void PyDictKeys_Type(PyTypeObject PyDictKeys_Type);
public static native @ByRef PyTypeObject PyDictItems_Type(); public static native void PyDictItems_Type(PyTypeObject PyDictItems_Type);
public static native @ByRef PyTypeObject PyDictValues_Type(); public static native void PyDictValues_Type(PyTypeObject PyDictValues_Type);

// #define PyDict_Check(op)
//                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_DICT_SUBCLASS)
// #define PyDict_CheckExact(op) (Py_TYPE(op) == &PyDict_Type)
// #define PyDictKeys_Check(op) PyObject_TypeCheck(op, &PyDictKeys_Type)
// #define PyDictItems_Check(op) PyObject_TypeCheck(op, &PyDictItems_Type)
// #define PyDictValues_Check(op) PyObject_TypeCheck(op, &PyDictValues_Type)
/* This excludes Values, since they are not sets. */
// # define PyDictViewSet_Check(op)
//     (PyDictKeys_Check(op) || PyDictItems_Check(op))


@NoException public static native PyObject PyDict_New();
@NoException public static native PyObject PyDict_GetItem(PyObject mp, PyObject key);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyDict_GetItem_KnownHash(PyObject mp, PyObject key,
                                       @Cast("Py_hash_t") long hash);
// #endif
@NoException public static native PyObject PyDict_GetItemWithError(PyObject mp, PyObject key);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyDict_GetItemIdWithError(PyObject dp,
                                                  _Py_Identifier key);
@NoException public static native PyObject PyDict_SetDefault(
    PyObject mp, PyObject key, PyObject defaultobj);
// #endif
@NoException public static native int PyDict_SetItem(PyObject mp, PyObject key, PyObject item);
// #ifndef Py_LIMITED_API
@NoException public static native int _PyDict_SetItem_KnownHash(PyObject mp, PyObject key,
                                          PyObject item, @Cast("Py_hash_t") long hash);
// #endif
@NoException public static native int PyDict_DelItem(PyObject mp, PyObject key);
// #ifndef Py_LIMITED_API
@NoException public static native int _PyDict_DelItem_KnownHash(PyObject mp, PyObject key,
                                          @Cast("Py_hash_t") long hash);
// Targeting ../python/Predicate_PyObject.java


@NoException public static native int _PyDict_DelItemIf(PyObject mp, PyObject key,
                                  Predicate_PyObject predicate);
// #endif
@NoException public static native void PyDict_Clear(PyObject mp);
@NoException public static native int PyDict_Next(
    PyObject mp, @Cast("Py_ssize_t*") SizeTPointer pos, @Cast("PyObject**") PointerPointer key, @Cast("PyObject**") PointerPointer value);
@NoException public static native int PyDict_Next(
    PyObject mp, @Cast("Py_ssize_t*") SizeTPointer pos, @ByPtrPtr PyObject key, @ByPtrPtr PyObject value);
// #ifndef Py_LIMITED_API

@NoException public static native PyObject PyObject_GenericGetDict(PyObject arg0, Pointer arg1);
@NoException public static native int _PyDict_Next(
    PyObject mp, @Cast("Py_ssize_t*") SizeTPointer pos, @Cast("PyObject**") PointerPointer key, @Cast("PyObject**") PointerPointer value, @Cast("Py_hash_t*") SizeTPointer hash);
@NoException public static native int _PyDict_Next(
    PyObject mp, @Cast("Py_ssize_t*") SizeTPointer pos, @ByPtrPtr PyObject key, @ByPtrPtr PyObject value, @Cast("Py_hash_t*") SizeTPointer hash);

// #endif
@NoException public static native PyObject PyDict_Keys(PyObject mp);
@NoException public static native PyObject PyDict_Values(PyObject mp);
@NoException public static native PyObject PyDict_Items(PyObject mp);
@NoException public static native @Cast("Py_ssize_t") long PyDict_Size(PyObject mp);
@NoException public static native PyObject PyDict_Copy(PyObject mp);
@NoException public static native int PyDict_Contains(PyObject mp, PyObject key);
// #ifndef Py_LIMITED_API
@NoException public static native int _PyDict_Contains(PyObject mp, PyObject key, @Cast("Py_hash_t") long hash);
@NoException public static native PyObject _PyDict_NewPresized(@Cast("Py_ssize_t") long minused);
@NoException public static native void _PyDict_MaybeUntrack(PyObject mp);
@NoException public static native int _PyDict_HasOnlyStringKeys(PyObject mp);


@NoException public static native PyObject _PyDict_Pop(PyObject arg0, PyObject arg1, PyObject arg2);


// #define _PyDict_HasSplitTable(d) ((d)->ma_values != NULL)

@NoException public static native int PyDict_ClearFreeList();
// #endif

/* PyDict_Update(mp, other) is equivalent to PyDict_Merge(mp, other, 1). */
@NoException public static native int PyDict_Update(PyObject mp, PyObject other);

/* PyDict_Merge updates/merges from a mapping object (an object that
   supports PyMapping_Keys() and PyObject_GetItem()).  If override is true,
   the last occurrence of a key wins, else the first.  The Python
   dict.update(other) is equivalent to PyDict_Merge(dict, other, 1).
*/
@NoException public static native int PyDict_Merge(PyObject mp,
                                   PyObject other,
                                   int override);

// #ifndef Py_LIMITED_API
/* Like PyDict_Merge, but override can be 0, 1 or 2.  If override is 0,
   the first occurrence of a key wins, if override is 1, the last occurrence
   of a key wins, if override is 2, a KeyError with conflicting key as
   argument is raised.
*/
@NoException public static native int _PyDict_MergeEx(PyObject mp, PyObject other, int override);
@NoException public static native PyObject _PyDictView_Intersect(PyObject self, PyObject other);
// #endif

/* PyDict_MergeFromSeq2 updates/merges from an iterable object producing
   iterable objects of length 2.  If override is true, the last occurrence
   of a key wins, else the first.  The Python dict constructor dict(seq2)
   is equivalent to dict={}; PyDict_MergeFromSeq(dict, seq2, 1).
*/
@NoException public static native int PyDict_MergeFromSeq2(PyObject d,
                                           PyObject seq2,
                                           int override);

@NoException public static native PyObject PyDict_GetItemString(PyObject dp, @Cast("const char*") BytePointer key);
@NoException public static native PyObject PyDict_GetItemString(PyObject dp, String key);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyDict_GetItemId(PyObject dp, _Py_Identifier key);
// #endif /* !Py_LIMITED_API */
@NoException public static native int PyDict_SetItemString(PyObject dp, @Cast("const char*") BytePointer key, PyObject item);
@NoException public static native int PyDict_SetItemString(PyObject dp, String key, PyObject item);
// #ifndef Py_LIMITED_API
@NoException public static native int _PyDict_SetItemId(PyObject dp, _Py_Identifier key, PyObject item);
// #endif /* !Py_LIMITED_API */
@NoException public static native int PyDict_DelItemString(PyObject dp, @Cast("const char*") BytePointer key);
@NoException public static native int PyDict_DelItemString(PyObject dp, String key);

// #ifndef Py_LIMITED_API
@NoException public static native int _PyDict_DelItemId(PyObject mp, _Py_Identifier key);
@NoException public static native void _PyDict_DebugMallocStats(@Cast("FILE*") Pointer out);



// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_DICTOBJECT_H */


// Parsed from structmember.h

// #ifndef Py_STRUCTMEMBER_H
// #define Py_STRUCTMEMBER_H
// #ifdef __cplusplus
// #endif


/* Interface to map C struct members to Python object attributes */

// #include <stddef.h>
// Targeting ../python/PyMemberDef.java



/* Types */
public static final int T_SHORT =     0;
public static final int T_INT =       1;
public static final int T_LONG =      2;
public static final int T_FLOAT =     3;
public static final int T_DOUBLE =    4;
public static final int T_STRING =    5;
public static final int T_OBJECT =    6;
/* XXX the ordering here is weird for binary compatibility */
public static final int T_CHAR =      7;   /* 1-character string */
public static final int T_BYTE =      8;   /* 8-bit signed int */
/* unsigned variants: */
public static final int T_UBYTE =     9;
public static final int T_USHORT =    10;
public static final int T_UINT =      11;
public static final int T_ULONG =     12;

/* Added by Jack: strings contained in the structure */
public static final int T_STRING_INPLACE =    13;

/* Added by Lillo: bools contained in the structure (assumed char) */
public static final int T_BOOL =      14;

public static final int T_OBJECT_EX = 16;  /* Like T_OBJECT, but raises AttributeError
                           when the value is NULL, instead of
                           converting to None. */
public static final int T_LONGLONG =      17;
public static final int T_ULONGLONG =     18;

public static final int T_PYSSIZET =      19;      /* Py_ssize_t */
public static final int T_NONE =          20;      /* Value is always None */


/* Flags */
public static final int READONLY =            1;
public static final int READ_RESTRICTED =     2;
public static final int PY_WRITE_RESTRICTED = 4;
public static final int RESTRICTED =          (READ_RESTRICTED | PY_WRITE_RESTRICTED);


/* Current API, use this */
@NoException public static native PyObject PyMember_GetOne(@Cast("const char*") BytePointer arg0, PyMemberDef arg1);
@NoException public static native PyObject PyMember_GetOne(String arg0, PyMemberDef arg1);
@NoException public static native int PyMember_SetOne(@Cast("char*") BytePointer arg0, PyMemberDef arg1, PyObject arg2);
@NoException public static native int PyMember_SetOne(@Cast("char*") ByteBuffer arg0, PyMemberDef arg1, PyObject arg2);
@NoException public static native int PyMember_SetOne(@Cast("char*") byte[] arg0, PyMemberDef arg1, PyObject arg2);


// #ifdef __cplusplus
// #endif
// #endif /* !Py_STRUCTMEMBER_H */


// Parsed from odictobject.h

// #ifndef Py_ODICTOBJECT_H
// #define Py_ODICTOBJECT_H
// #ifdef __cplusplus
// Targeting ../python/PyODictObject.java



public static native @ByRef PyTypeObject PyODict_Type(); public static native void PyODict_Type(PyTypeObject PyODict_Type);
public static native @ByRef PyTypeObject PyODictIter_Type(); public static native void PyODictIter_Type(PyTypeObject PyODictIter_Type);
public static native @ByRef PyTypeObject PyODictKeys_Type(); public static native void PyODictKeys_Type(PyTypeObject PyODictKeys_Type);
public static native @ByRef PyTypeObject PyODictItems_Type(); public static native void PyODictItems_Type(PyTypeObject PyODictItems_Type);
public static native @ByRef PyTypeObject PyODictValues_Type(); public static native void PyODictValues_Type(PyTypeObject PyODictValues_Type);

// #define PyODict_Check(op) PyObject_TypeCheck(op, &PyODict_Type)
// #define PyODict_CheckExact(op) (Py_TYPE(op) == &PyODict_Type)
// #define PyODict_SIZE(op) ((PyDictObject *)op)->ma_used

@NoException public static native PyObject PyODict_New();
@NoException public static native int PyODict_SetItem(PyObject od, PyObject key, PyObject item);
@NoException public static native int PyODict_DelItem(PyObject od, PyObject key);

/* wrappers around PyDict* functions */
// #define PyODict_GetItem(od, key) PyDict_GetItem((PyObject *)od, key)
// #define PyODict_GetItemWithError(od, key)
//     PyDict_GetItemWithError((PyObject *)od, key)
// #define PyODict_Contains(od, key) PyDict_Contains((PyObject *)od, key)
// #define PyODict_Size(od) PyDict_Size((PyObject *)od)
// #define PyODict_GetItemString(od, key)
//     PyDict_GetItemString((PyObject *)od, key)

// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_ODICTOBJECT_H */


// Parsed from enumobject.h

// #ifndef Py_ENUMOBJECT_H
// #define Py_ENUMOBJECT_H

/* Enumerate Object */

// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyEnum_Type(); public static native void PyEnum_Type(PyTypeObject PyEnum_Type);
public static native @ByRef PyTypeObject PyReversed_Type(); public static native void PyReversed_Type(PyTypeObject PyReversed_Type);

// #ifdef __cplusplus
// #endif

// #endif /* !Py_ENUMOBJECT_H */


// Parsed from setobject.h

/* Set object interface */

// #ifndef Py_SETOBJECT_H
// #define Py_SETOBJECT_H
// #ifdef __cplusplus
// #endif

// #ifndef Py_LIMITED_API

/* There are three kinds of entries in the table:

1. Unused:  key == NULL and hash == 0
2. Dummy:   key == dummy and hash == -1
3. Active:  key != NULL and key != dummy and hash != -1

The hash field of Unused slots is always zero.

The hash field of Dummy slots are set to -1
meaning that dummy entries can be detected by
either entry->key==dummy or by entry->hash==-1.
*/

public static final int PySet_MINSIZE = 8;
// Targeting ../python/setentry.java


// Targeting ../python/PySetObject.java



// #define PySet_GET_SIZE(so) (((PySetObject *)(so))->used)

public static native PyObject _PySet_Dummy(); public static native void _PySet_Dummy(PyObject _PySet_Dummy);

@NoException public static native int _PySet_NextEntry(PyObject set, @Cast("Py_ssize_t*") SizeTPointer pos, @Cast("PyObject**") PointerPointer key, @Cast("Py_hash_t*") SizeTPointer hash);
@NoException public static native int _PySet_NextEntry(PyObject set, @Cast("Py_ssize_t*") SizeTPointer pos, @ByPtrPtr PyObject key, @Cast("Py_hash_t*") SizeTPointer hash);
@NoException public static native int _PySet_Update(PyObject set, PyObject iterable);
@NoException public static native int PySet_ClearFreeList();

// #endif /* Section excluded by Py_LIMITED_API */

public static native @ByRef PyTypeObject PySet_Type(); public static native void PySet_Type(PyTypeObject PySet_Type);
public static native @ByRef PyTypeObject PyFrozenSet_Type(); public static native void PyFrozenSet_Type(PyTypeObject PyFrozenSet_Type);
public static native @ByRef PyTypeObject PySetIter_Type(); public static native void PySetIter_Type(PyTypeObject PySetIter_Type);

@NoException public static native PyObject PySet_New(PyObject arg0);
@NoException public static native PyObject PyFrozenSet_New(PyObject arg0);

@NoException public static native int PySet_Add(PyObject set, PyObject key);
@NoException public static native int PySet_Clear(PyObject set);
@NoException public static native int PySet_Contains(PyObject anyset, PyObject key);
@NoException public static native int PySet_Discard(PyObject set, PyObject key);
@NoException public static native PyObject PySet_Pop(PyObject set);
@NoException public static native @Cast("Py_ssize_t") long PySet_Size(PyObject anyset);

// #define PyFrozenSet_CheckExact(ob) (Py_TYPE(ob) == &PyFrozenSet_Type)
// #define PyAnySet_CheckExact(ob)
//     (Py_TYPE(ob) == &PySet_Type || Py_TYPE(ob) == &PyFrozenSet_Type)
// #define PyAnySet_Check(ob)
//     (Py_TYPE(ob) == &PySet_Type || Py_TYPE(ob) == &PyFrozenSet_Type ||
//       PyType_IsSubtype(Py_TYPE(ob), &PySet_Type) ||
//       PyType_IsSubtype(Py_TYPE(ob), &PyFrozenSet_Type))
// #define PySet_Check(ob)
//     (Py_TYPE(ob) == &PySet_Type ||
//     PyType_IsSubtype(Py_TYPE(ob), &PySet_Type))
// #define   PyFrozenSet_Check(ob)
//     (Py_TYPE(ob) == &PyFrozenSet_Type ||
//       PyType_IsSubtype(Py_TYPE(ob), &PyFrozenSet_Type))

// #ifdef __cplusplus
// #endif
// #endif /* !Py_SETOBJECT_H */


// Parsed from methodobject.h


/* Method object interface */

// #ifndef Py_METHODOBJECT_H
// #define Py_METHODOBJECT_H
// #ifdef __cplusplus
// #endif

/* This is about the type 'builtin_function_or_method',
   not Python methods in user-defined classes.  See classobject.h
   for the latter. */

public static native @ByRef PyTypeObject PyCFunction_Type(); public static native void PyCFunction_Type(PyTypeObject PyCFunction_Type);

// #define PyCFunction_Check(op) (Py_TYPE(op) == &PyCFunction_Type)
// Targeting ../python/PyCFunction.java


// Targeting ../python/_PyCFunctionFast.java


// Targeting ../python/PyCFunctionWithKeywords.java


// Targeting ../python/PyNoArgsFunction.java



@NoException public static native PyCFunction PyCFunction_GetFunction(PyObject arg0);
@NoException public static native PyObject PyCFunction_GetSelf(PyObject arg0);
@NoException public static native int PyCFunction_GetFlags(PyObject arg0);

/* Macros for direct access to these values. Type checks are *not*
   done, so use with care. */
// #ifndef Py_LIMITED_API
// #define PyCFunction_GET_FUNCTION(func)
//         (((PyCFunctionObject *)func) -> m_ml -> ml_meth)
// #define PyCFunction_GET_SELF(func)
//         (((PyCFunctionObject *)func) -> m_ml -> ml_flags & METH_STATIC ?
//          NULL : ((PyCFunctionObject *)func) -> m_self)
// #define PyCFunction_GET_FLAGS(func)
//         (((PyCFunctionObject *)func) -> m_ml -> ml_flags)
// #endif
@NoException public static native PyObject PyCFunction_Call(PyObject arg0, PyObject arg1, PyObject arg2);

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyCFunction_FastCallDict(PyObject func,
    @Cast("PyObject**") PointerPointer args,
    @Cast("Py_ssize_t") long nargs,
    PyObject kwargs);
@NoException public static native PyObject _PyCFunction_FastCallDict(PyObject func,
    @ByPtrPtr PyObject args,
    @Cast("Py_ssize_t") long nargs,
    PyObject kwargs);

@NoException public static native PyObject _PyCFunction_FastCallKeywords(PyObject func,
    @Cast("PyObject**") PointerPointer stack,
    @Cast("Py_ssize_t") long nargs,
    PyObject kwnames);
@NoException public static native PyObject _PyCFunction_FastCallKeywords(PyObject func,
    @ByPtrPtr PyObject stack,
    @Cast("Py_ssize_t") long nargs,
    PyObject kwnames);
// Targeting ../python/PyMethodDef.java



// #define PyCFunction_New(ML, SELF) PyCFunction_NewEx((ML), (SELF), NULL)
@NoException public static native PyObject PyCFunction_NewEx(PyMethodDef arg0, PyObject arg1,
                                         PyObject arg2);

/* Flag passed to newmethodobject */
/* #define METH_OLDARGS  0x0000   -- unsupported now */
public static final int METH_VARARGS =  0x0001;
public static final int METH_KEYWORDS = 0x0002;
/* METH_NOARGS and METH_O must not be combined with the flags above. */
public static final int METH_NOARGS =   0x0004;
public static final int METH_O =        0x0008;

/* METH_CLASS and METH_STATIC are a little different; these control
   the construction of methods for a class.  These cannot be used for
   functions in modules. */
public static final int METH_CLASS =    0x0010;
public static final int METH_STATIC =   0x0020;

/* METH_COEXIST allows a method to be entered even though a slot has
   already filled the entry.  When defined, the flag allows a separate
   method, "__contains__" for example, to coexist with a defined
   slot like sq_contains. */

public static final int METH_COEXIST =   0x0040;

// #ifndef Py_LIMITED_API
public static final int METH_FASTCALL =  0x0080;
// Targeting ../python/PyCFunctionObject.java


// #endif

@NoException public static native int PyCFunction_ClearFreeList();

// #ifndef Py_LIMITED_API
@NoException public static native void _PyCFunction_DebugMallocStats(@Cast("FILE*") Pointer out);
@NoException public static native void _PyMethod_DebugMallocStats(@Cast("FILE*") Pointer out);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_METHODOBJECT_H */


// Parsed from moduleobject.h


/* Module object interface */

// #ifndef Py_MODULEOBJECT_H
// #define Py_MODULEOBJECT_H
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyModule_Type(); public static native void PyModule_Type(PyTypeObject PyModule_Type);

// #define PyModule_Check(op) PyObject_TypeCheck(op, &PyModule_Type)
// #define PyModule_CheckExact(op) (Py_TYPE(op) == &PyModule_Type)

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyModule_NewObject(
    PyObject name
    );
// #endif
@NoException public static native PyObject PyModule_New(
    @Cast("const char*") BytePointer name
    );
@NoException public static native PyObject PyModule_New(
    String name
    );
@NoException public static native PyObject PyModule_GetDict(PyObject arg0);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyModule_GetNameObject(PyObject arg0);
// #endif
@NoException public static native @Cast("const char*") BytePointer PyModule_GetName(PyObject arg0);
@NoException public static native @Cast("const char*") BytePointer PyModule_GetFilename(PyObject arg0);
@NoException public static native PyObject PyModule_GetFilenameObject(PyObject arg0);
// #ifndef Py_LIMITED_API
@NoException public static native void _PyModule_Clear(PyObject arg0);
@NoException public static native void _PyModule_ClearDict(PyObject arg0);
// #endif
@NoException public static native PyModuleDef PyModule_GetDef(PyObject arg0);
@NoException public static native Pointer PyModule_GetState(PyObject arg0);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* New in 3.5 */
@NoException public static native PyObject PyModuleDef_Init(PyModuleDef arg0);
public static native @ByRef PyTypeObject PyModuleDef_Type(); public static native void PyModuleDef_Type(PyTypeObject PyModuleDef_Type);
// Targeting ../python/PyModuleDef_Base.java



// #define PyModuleDef_HEAD_INIT {
//     PyObject_HEAD_INIT(NULL)
//     NULL, /* m_init */
//     0,    /* m_index */
//     NULL, /* m_copy */
//   }
// Targeting ../python/PyModuleDef_Slot.java



public static final int Py_mod_create = 1;
public static final int Py_mod_exec = 2;

// #ifndef Py_LIMITED_API
public static final int _Py_mod_LAST_SLOT = 2;
// Targeting ../python/PyModuleDef.java



// #ifdef __cplusplus
// #endif
// #endif /* !Py_MODULEOBJECT_H */


// Parsed from funcobject.h


/* Function object interface */
// #ifndef Py_LIMITED_API
// #ifndef Py_FUNCOBJECT_H
// #define Py_FUNCOBJECT_H
// #ifdef __cplusplus
// Targeting ../python/PyFunctionObject.java



public static native @ByRef PyTypeObject PyFunction_Type(); public static native void PyFunction_Type(PyTypeObject PyFunction_Type);

// #define PyFunction_Check(op) (Py_TYPE(op) == &PyFunction_Type)

@NoException public static native PyObject PyFunction_New(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyFunction_NewWithQualName(PyObject arg0, PyObject arg1, PyObject arg2);
@NoException public static native PyObject PyFunction_GetCode(PyObject arg0);
@NoException public static native PyObject PyFunction_GetGlobals(PyObject arg0);
@NoException public static native PyObject PyFunction_GetModule(PyObject arg0);
@NoException public static native PyObject PyFunction_GetDefaults(PyObject arg0);
@NoException public static native int PyFunction_SetDefaults(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyFunction_GetKwDefaults(PyObject arg0);
@NoException public static native int PyFunction_SetKwDefaults(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyFunction_GetClosure(PyObject arg0);
@NoException public static native int PyFunction_SetClosure(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyFunction_GetAnnotations(PyObject arg0);
@NoException public static native int PyFunction_SetAnnotations(PyObject arg0, PyObject arg1);

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyFunction_FastCallDict(
    PyObject func,
    @Cast("PyObject**") PointerPointer args,
    @Cast("Py_ssize_t") long nargs,
    PyObject kwargs);
@NoException public static native PyObject _PyFunction_FastCallDict(
    PyObject func,
    @ByPtrPtr PyObject args,
    @Cast("Py_ssize_t") long nargs,
    PyObject kwargs);

@NoException public static native PyObject _PyFunction_FastCallKeywords(
    PyObject func,
    @Cast("PyObject**") PointerPointer stack,
    @Cast("Py_ssize_t") long nargs,
    PyObject kwnames);
@NoException public static native PyObject _PyFunction_FastCallKeywords(
    PyObject func,
    @ByPtrPtr PyObject stack,
    @Cast("Py_ssize_t") long nargs,
    PyObject kwnames);
// #endif

/* Macros for direct access to these values. Type checks are *not*
   done, so use with care. */
// #define PyFunction_GET_CODE(func)
//         (((PyFunctionObject *)func) -> func_code)
// #define PyFunction_GET_GLOBALS(func)
// 	(((PyFunctionObject *)func) -> func_globals)
// #define PyFunction_GET_MODULE(func)
// 	(((PyFunctionObject *)func) -> func_module)
// #define PyFunction_GET_DEFAULTS(func)
// 	(((PyFunctionObject *)func) -> func_defaults)
// #define PyFunction_GET_KW_DEFAULTS(func)
// 	(((PyFunctionObject *)func) -> func_kwdefaults)
// #define PyFunction_GET_CLOSURE(func)
// 	(((PyFunctionObject *)func) -> func_closure)
// #define PyFunction_GET_ANNOTATIONS(func)
// 	(((PyFunctionObject *)func) -> func_annotations)

/* The classmethod and staticmethod types lives here, too */
public static native @ByRef PyTypeObject PyClassMethod_Type(); public static native void PyClassMethod_Type(PyTypeObject PyClassMethod_Type);
public static native @ByRef PyTypeObject PyStaticMethod_Type(); public static native void PyStaticMethod_Type(PyTypeObject PyStaticMethod_Type);

@NoException public static native PyObject PyClassMethod_New(PyObject arg0);
@NoException public static native PyObject PyStaticMethod_New(PyObject arg0);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_FUNCOBJECT_H */
// #endif /* Py_LIMITED_API */


// Parsed from classobject.h

/* Former class object interface -- now only bound methods are here  */

/* Revealing some structures (not for general use) */

// #ifndef Py_LIMITED_API
// #ifndef Py_CLASSOBJECT_H
// #define Py_CLASSOBJECT_H
// #ifdef __cplusplus
// Targeting ../python/PyMethodObject.java



public static native @ByRef PyTypeObject PyMethod_Type(); public static native void PyMethod_Type(PyTypeObject PyMethod_Type);

// #define PyMethod_Check(op) ((op)->ob_type == &PyMethod_Type)

@NoException public static native PyObject PyMethod_New(PyObject arg0, PyObject arg1);

@NoException public static native PyObject PyMethod_Function(PyObject arg0);
@NoException public static native PyObject PyMethod_Self(PyObject arg0);

/* Macros for direct access to these values. Type checks are *not*
   done, so use with care. */
// #define PyMethod_GET_FUNCTION(meth)
//         (((PyMethodObject *)meth) -> im_func)
// #define PyMethod_GET_SELF(meth)
// 	(((PyMethodObject *)meth) -> im_self)

@NoException public static native int PyMethod_ClearFreeList();
// Targeting ../python/PyInstanceMethodObject.java



public static native @ByRef PyTypeObject PyInstanceMethod_Type(); public static native void PyInstanceMethod_Type(PyTypeObject PyInstanceMethod_Type);

// #define PyInstanceMethod_Check(op) ((op)->ob_type == &PyInstanceMethod_Type)

@NoException public static native PyObject PyInstanceMethod_New(PyObject arg0);
@NoException public static native PyObject PyInstanceMethod_Function(PyObject arg0);

/* Macros for direct access to these values. Type checks are *not*
   done, so use with care. */
// #define PyInstanceMethod_GET_FUNCTION(meth)
//         (((PyInstanceMethodObject *)meth) -> func)

// #ifdef __cplusplus
// #endif
// #endif /* !Py_CLASSOBJECT_H */
// #endif /* Py_LIMITED_API */


// Parsed from fileobject.h

/* File object interface (what's left of it -- see io.py) */

// #ifndef Py_FILEOBJECT_H
// #define Py_FILEOBJECT_H
// #ifdef __cplusplus
// #endif

public static final String PY_STDIOTEXTMODE = "b";

@NoException public static native PyObject PyFile_FromFd(int arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2, int arg3,
                                     @Cast("const char*") BytePointer arg4, @Cast("const char*") BytePointer arg5,
                                     @Cast("const char*") BytePointer arg6, int arg7);
@NoException public static native PyObject PyFile_FromFd(int arg0, String arg1, String arg2, int arg3,
                                     String arg4, String arg5,
                                     String arg6, int arg7);
@NoException public static native PyObject PyFile_GetLine(PyObject arg0, int arg1);
@NoException public static native int PyFile_WriteObject(PyObject arg0, PyObject arg1, int arg2);
@NoException public static native int PyFile_WriteString(@Cast("const char*") BytePointer arg0, PyObject arg1);
@NoException public static native int PyFile_WriteString(String arg0, PyObject arg1);
@NoException public static native int PyObject_AsFileDescriptor(PyObject arg0);
// #ifndef Py_LIMITED_API
@NoException public static native @Cast("char*") BytePointer Py_UniversalNewlineFgets(@Cast("char*") BytePointer arg0, int arg1, @Cast("FILE*") Pointer arg2, PyObject arg3);
@NoException public static native @Cast("char*") ByteBuffer Py_UniversalNewlineFgets(@Cast("char*") ByteBuffer arg0, int arg1, @Cast("FILE*") Pointer arg2, PyObject arg3);
@NoException public static native @Cast("char*") byte[] Py_UniversalNewlineFgets(@Cast("char*") byte[] arg0, int arg1, @Cast("FILE*") Pointer arg2, PyObject arg3);
// #endif

/* The default encoding used by the platform file system APIs
   If non-NULL, this is different than the default encoding for strings
*/
@MemberGetter public static native @Cast("const char*") BytePointer Py_FileSystemDefaultEncoding();
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
@MemberGetter public static native @Cast("const char*") BytePointer Py_FileSystemDefaultEncodeErrors();
// #endif
public static native int Py_HasFileSystemDefaultEncoding(); public static native void Py_HasFileSystemDefaultEncoding(int Py_HasFileSystemDefaultEncoding);

/* Internal API

   The std printer acts as a preliminary sys.stderr until the new io
   infrastructure is in place. */
// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyFile_NewStdPrinter(int arg0);
public static native @ByRef PyTypeObject PyStdPrinter_Type(); public static native void PyStdPrinter_Type(PyTypeObject PyStdPrinter_Type);
// #endif /* Py_LIMITED_API */

/* A routine to check if a file descriptor can be select()-ed. */
// #ifdef HAVE_SELECT
//  #define _PyIsSelectable_fd(FD) ((unsigned int)(FD) < (unsigned int)FD_SETSIZE)
// #else
//  #define _PyIsSelectable_fd(FD) (1)
// #endif /* HAVE_SELECT */

// #ifdef __cplusplus
// #endif
// #endif /* !Py_FILEOBJECT_H */


// Parsed from pycapsule.h


/* Capsule objects let you wrap a C "void *" pointer in a Python
   object.  They're a way of passing data through the Python interpreter
   without creating your own custom type.

   Capsules are used for communication between extension modules.
   They provide a way for an extension module to export a C interface
   to other extension modules, so that extension modules can use the
   Python import mechanism to link to one another.

   For more information, please see "c-api/capsule.html" in the
   documentation.
*/

// #ifndef Py_CAPSULE_H
// #define Py_CAPSULE_H
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyCapsule_Type(); public static native void PyCapsule_Type(PyTypeObject PyCapsule_Type);
// Targeting ../python/PyCapsule_Destructor.java



// #define PyCapsule_CheckExact(op) (Py_TYPE(op) == &PyCapsule_Type)


@NoException public static native PyObject PyCapsule_New(
    Pointer pointer,
    @Cast("const char*") BytePointer name,
    PyCapsule_Destructor destructor);
@NoException public static native PyObject PyCapsule_New(
    Pointer pointer,
    String name,
    PyCapsule_Destructor destructor);

@NoException public static native Pointer PyCapsule_GetPointer(PyObject capsule, @Cast("const char*") BytePointer name);
@NoException public static native Pointer PyCapsule_GetPointer(PyObject capsule, String name);

@NoException public static native PyCapsule_Destructor PyCapsule_GetDestructor(PyObject capsule);

@NoException public static native @Cast("const char*") BytePointer PyCapsule_GetName(PyObject capsule);

@NoException public static native Pointer PyCapsule_GetContext(PyObject capsule);

@NoException public static native int PyCapsule_IsValid(PyObject capsule, @Cast("const char*") BytePointer name);
@NoException public static native int PyCapsule_IsValid(PyObject capsule, String name);

@NoException public static native int PyCapsule_SetPointer(PyObject capsule, Pointer pointer);

@NoException public static native int PyCapsule_SetDestructor(PyObject capsule, PyCapsule_Destructor destructor);

@NoException public static native int PyCapsule_SetName(PyObject capsule, @Cast("const char*") BytePointer name);
@NoException public static native int PyCapsule_SetName(PyObject capsule, String name);

@NoException public static native int PyCapsule_SetContext(PyObject capsule, Pointer context);

@NoException public static native Pointer PyCapsule_Import(
    @Cast("const char*") BytePointer name,
    int no_block);
@NoException public static native Pointer PyCapsule_Import(
    String name,
    int no_block);


// #ifdef __cplusplus
// #endif
// #endif /* !Py_CAPSULE_H */


// Parsed from traceback.h


// #ifndef Py_TRACEBACK_H
// #define Py_TRACEBACK_H
// #ifdef __cplusplus
// #endif

// #include "pystate.h"
// Targeting ../python/_frame.java


// Targeting ../python/PyTracebackObject.java


// #endif

@NoException public static native int PyTraceBack_Here(_frame arg0);
@NoException public static native int PyTraceBack_Print(PyObject arg0, PyObject arg1);
// #ifndef Py_LIMITED_API
@NoException public static native int _Py_DisplaySourceLine(PyObject arg0, PyObject arg1, int arg2, int arg3);
@NoException public static native void _PyTraceback_Add(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, int arg2);
@NoException public static native void _PyTraceback_Add(String arg0, String arg1, int arg2);
// #endif

/* Reveal traceback type so we can typecheck traceback objects */
public static native @ByRef PyTypeObject PyTraceBack_Type(); public static native void PyTraceBack_Type(PyTypeObject PyTraceBack_Type);
// #define PyTraceBack_Check(v) (Py_TYPE(v) == &PyTraceBack_Type)

// #ifndef Py_LIMITED_API
/* Write the Python traceback into the file 'fd'. For example:

       Traceback (most recent call first):
         File "xxx", line xxx in <xxx>
         File "xxx", line xxx in <xxx>
         ...
         File "xxx", line xxx in <xxx>

   This function is written for debug purpose only, to dump the traceback in
   the worst case: after a segmentation fault, at fatal error, etc. That's why,
   it is very limited. Strings are truncated to 100 characters and encoded to
   ASCII with backslashreplace. It doesn't write the source code, only the
   function name, filename and line number of each frame. Write only the first
   100 frames: if the traceback is truncated, write the line " ...".

   This function is signal safe. */

@NoException public static native void _Py_DumpTraceback(
    int fd,
    PyThreadState tstate);

/* Write the traceback of all threads into the file 'fd'. current_thread can be
   NULL.

   Return NULL on success, or an error message on error.

   This function is written for debug purpose only. It calls
   _Py_DumpTraceback() for each thread, and so has the same limitations. It
   only write the traceback of the first 100 threads: write "..." if there are
   more threads.

   If current_tstate is NULL, the function tries to get the Python thread state
   of the current thread. It is not an error if the function is unable to get
   the current Python thread state.

   If interp is NULL, the function tries to get the interpreter state from
   the current Python thread state, or from
   _PyGILState_GetInterpreterStateUnsafe() in last resort.

   It is better to pass NULL to interp and current_tstate, the function tries
   different options to retrieve these informations.

   This function is signal safe. */

@NoException public static native @Cast("const char*") BytePointer _Py_DumpTracebackThreads(
    int fd,
    PyInterpreterState interp,
    PyThreadState current_tstate);
// #endif /* !Py_LIMITED_API */

// #ifndef Py_LIMITED_API

/* Write a Unicode object into the file descriptor fd. Encode the string to
   ASCII using the backslashreplace error handler.

   Do nothing if text is not a Unicode object. The function accepts Unicode
   string which is not ready (PyUnicode_WCHAR_KIND).

   This function is signal safe. */
@NoException public static native void _Py_DumpASCII(int fd, PyObject text);

/* Format an integer as decimal into the file descriptor fd.

   This function is signal safe. */
@NoException public static native void _Py_DumpDecimal(
    int fd,
    @Cast("unsigned long") long value);

/* Format an integer as hexadecimal into the file descriptor fd with at least
   width digits.

   The maximum width is sizeof(unsigned long)*2 digits.

   This function is signal safe. */
@NoException public static native void _Py_DumpHexadecimal(
    int fd,
    @Cast("unsigned long") long value,
    @Cast("Py_ssize_t") long width);

// #endif   /* !Py_LIMITED_API */

// #ifdef __cplusplus
// #endif
// #endif /* !Py_TRACEBACK_H */


// Parsed from sliceobject.h

// #ifndef Py_SLICEOBJECT_H
// #define Py_SLICEOBJECT_H
// #ifdef __cplusplus
// #endif

/* The unique ellipsis object "..." */

public static native @ByRef PyObject _Py_EllipsisObject(); public static native void _Py_EllipsisObject(PyObject _Py_EllipsisObject); /* Don't use this directly */

// #define Py_Ellipsis (&_Py_EllipsisObject)
// Targeting ../python/PySliceObject.java


// #endif

public static native @ByRef PyTypeObject PySlice_Type(); public static native void PySlice_Type(PyTypeObject PySlice_Type);
public static native @ByRef PyTypeObject PyEllipsis_Type(); public static native void PyEllipsis_Type(PyTypeObject PyEllipsis_Type);

// #define PySlice_Check(op) (Py_TYPE(op) == &PySlice_Type)

@NoException public static native PyObject PySlice_New(PyObject start, PyObject stop,
                                  PyObject step);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PySlice_FromIndices(@Cast("Py_ssize_t") long start, @Cast("Py_ssize_t") long stop);
@NoException public static native int _PySlice_GetLongIndices(PySliceObject self, PyObject length,
                                 @Cast("PyObject**") PointerPointer start_ptr, @Cast("PyObject**") PointerPointer stop_ptr,
                                 @Cast("PyObject**") PointerPointer step_ptr);
@NoException public static native int _PySlice_GetLongIndices(PySliceObject self, PyObject length,
                                 @ByPtrPtr PyObject start_ptr, @ByPtrPtr PyObject stop_ptr,
                                 @ByPtrPtr PyObject step_ptr);
// #endif
@NoException public static native int PySlice_GetIndices(PyObject r, @Cast("Py_ssize_t") long length,
                                  @Cast("Py_ssize_t*") SizeTPointer start, @Cast("Py_ssize_t*") SizeTPointer stop, @Cast("Py_ssize_t*") SizeTPointer step);
@NoException public static native int PySlice_GetIndicesEx(PyObject r, @Cast("Py_ssize_t") long length,
                                     @Cast("Py_ssize_t*") SizeTPointer start, @Cast("Py_ssize_t*") SizeTPointer stop,
                                     @Cast("Py_ssize_t*") SizeTPointer step, @Cast("Py_ssize_t*") SizeTPointer slicelength);

// #if !defined(Py_LIMITED_API) || (Py_LIMITED_API+0 >= 0x03050400 && Py_LIMITED_API+0 < 0x03060000) || Py_LIMITED_API+0 >= 0x03060100
// #ifdef Py_LIMITED_API
// #define PySlice_GetIndicesEx(slice, length, start, stop, step, slicelen) (
//     PySlice_Unpack((slice), (start), (stop), (step)) < 0 ?
//     ((*(slicelen) = 0), -1) :
//     ((*(slicelen) = PySlice_AdjustIndices((length), (start), (stop), *(step))),
//      0))
// #endif
@NoException public static native int PySlice_Unpack(PyObject slice,
                               @Cast("Py_ssize_t*") SizeTPointer start, @Cast("Py_ssize_t*") SizeTPointer stop, @Cast("Py_ssize_t*") SizeTPointer step);
@NoException public static native @Cast("Py_ssize_t") long PySlice_AdjustIndices(@Cast("Py_ssize_t") long length,
                                             @Cast("Py_ssize_t*") SizeTPointer start, @Cast("Py_ssize_t*") SizeTPointer stop,
                                             @Cast("Py_ssize_t") long step);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_SLICEOBJECT_H */


// Parsed from cellobject.h

/* Cell object interface */
// #ifndef Py_LIMITED_API
// #ifndef Py_CELLOBJECT_H
// #define Py_CELLOBJECT_H
// #ifdef __cplusplus
// Targeting ../python/PyCellObject.java



public static native @ByRef PyTypeObject PyCell_Type(); public static native void PyCell_Type(PyTypeObject PyCell_Type);

// #define PyCell_Check(op) (Py_TYPE(op) == &PyCell_Type)

@NoException public static native PyObject PyCell_New(PyObject arg0);
@NoException public static native PyObject PyCell_Get(PyObject arg0);
@NoException public static native int PyCell_Set(PyObject arg0, PyObject arg1);

// #define PyCell_GET(op) (((PyCellObject *)(op))->ob_ref)
// #define PyCell_SET(op, v) (((PyCellObject *)(op))->ob_ref = v)

// #ifdef __cplusplus
// #endif
// #endif /* !Py_TUPLEOBJECT_H */
// #endif /* Py_LIMITED_API */


// Parsed from iterobject.h

// #ifndef Py_ITEROBJECT_H
// #define Py_ITEROBJECT_H
/* Iterators (the basic kind, over a sequence) */
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PySeqIter_Type(); public static native void PySeqIter_Type(PyTypeObject PySeqIter_Type);
public static native @ByRef PyTypeObject PyCallIter_Type(); public static native void PyCallIter_Type(PyTypeObject PyCallIter_Type);


// #define PySeqIter_Check(op) (Py_TYPE(op) == &PySeqIter_Type)

@NoException public static native PyObject PySeqIter_New(PyObject arg0);


// #define PyCallIter_Check(op) (Py_TYPE(op) == &PyCallIter_Type)

@NoException public static native PyObject PyCallIter_New(PyObject arg0, PyObject arg1);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_ITEROBJECT_H */



// Parsed from genobject.h


/* Generator object interface */

// #ifndef Py_LIMITED_API
// #ifndef Py_GENOBJECT_H
// #define Py_GENOBJECT_H
// #ifdef __cplusplus
// #endif /* Avoid including frameobject.h */

/* _PyGenObject_HEAD defines the initial segment of generator
   and coroutine objects. */
// #define _PyGenObject_HEAD(prefix)
//     PyObject_HEAD
//     /* Note: gi_frame can be NULL if the generator is "finished" */
//     struct _frame *prefix##_frame;
//     /* True if generator is being executed. */
//     char prefix##_running;
//     /* The code object backing the generator */
//     PyObject *prefix##_code;
//     /* List of weak reference. */
//     PyObject *prefix##_weakreflist;
//     /* Name of the generator. */
//     PyObject *prefix##_name;
//     /* Qualified name of the generator. */
//     PyObject *prefix##_qualname;
// Targeting ../python/PyGenObject.java



public static native @ByRef PyTypeObject PyGen_Type(); public static native void PyGen_Type(PyTypeObject PyGen_Type);

// #define PyGen_Check(op) PyObject_TypeCheck(op, &PyGen_Type)
// #define PyGen_CheckExact(op) (Py_TYPE(op) == &PyGen_Type)

@NoException public static native PyObject PyGen_New(_frame arg0);
@NoException public static native PyObject PyGen_NewWithQualName(_frame arg0,
    PyObject name, PyObject qualname);
@NoException public static native int PyGen_NeedsFinalizing(PyGenObject arg0);
@NoException public static native int _PyGen_SetStopIterationValue(PyObject arg0);
@NoException public static native int _PyGen_FetchStopIterationValue(@Cast("PyObject**") PointerPointer arg0);
@NoException public static native int _PyGen_FetchStopIterationValue(@ByPtrPtr PyObject arg0);
@NoException public static native PyObject _PyGen_Send(PyGenObject arg0, PyObject arg1);

@NoException public static native void _PyGen_Finalize(PyObject self);
// Targeting ../python/PyCoroObject.java



public static native @ByRef PyTypeObject PyCoro_Type(); public static native void PyCoro_Type(PyTypeObject PyCoro_Type);
public static native @ByRef PyTypeObject _PyCoroWrapper_Type(); public static native void _PyCoroWrapper_Type(PyTypeObject _PyCoroWrapper_Type);

public static native @ByRef PyTypeObject _PyAIterWrapper_Type(); public static native void _PyAIterWrapper_Type(PyTypeObject _PyAIterWrapper_Type);


// #define PyCoro_CheckExact(op) (Py_TYPE(op) == &PyCoro_Type)

@NoException public static native PyObject PyCoro_New(_frame arg0,
    PyObject name, PyObject qualname);
// Targeting ../python/PyAsyncGenObject.java



public static native @ByRef PyTypeObject PyAsyncGen_Type(); public static native void PyAsyncGen_Type(PyTypeObject PyAsyncGen_Type);
public static native @ByRef PyTypeObject _PyAsyncGenASend_Type(); public static native void _PyAsyncGenASend_Type(PyTypeObject _PyAsyncGenASend_Type);
public static native @ByRef PyTypeObject _PyAsyncGenWrappedValue_Type(); public static native void _PyAsyncGenWrappedValue_Type(PyTypeObject _PyAsyncGenWrappedValue_Type);
public static native @ByRef PyTypeObject _PyAsyncGenAThrow_Type(); public static native void _PyAsyncGenAThrow_Type(PyTypeObject _PyAsyncGenAThrow_Type);

@NoException public static native PyObject PyAsyncGen_New(_frame arg0,
    PyObject name, PyObject qualname);

// #define PyAsyncGen_CheckExact(op) (Py_TYPE(op) == &PyAsyncGen_Type)





// #endif

// #undef _PyGenObject_HEAD

// #ifdef __cplusplus
// #endif
// #endif /* !Py_GENOBJECT_H */
// #endif /* Py_LIMITED_API */


// Parsed from warnings.h

// #ifndef Py_WARNINGS_H
// #define Py_WARNINGS_H
// #ifdef __cplusplus
// #endif

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyWarnings_Init();
// #endif

@NoException public static native int PyErr_WarnEx(
    PyObject category,
    @Cast("const char*") BytePointer message,
    @Cast("Py_ssize_t") long stack_level);
@NoException public static native int PyErr_WarnEx(
    PyObject category,
    String message,
    @Cast("Py_ssize_t") long stack_level);
@NoException public static native int PyErr_WarnFormat(
    PyObject category,
    @Cast("Py_ssize_t") long stack_level,
    @Cast("const char*") BytePointer format);
@NoException public static native int PyErr_WarnFormat(
    PyObject category,
    @Cast("Py_ssize_t") long stack_level,
    String format);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
/* Emit a ResourceWarning warning */
@NoException public static native int PyErr_ResourceWarning(
    PyObject source,
    @Cast("Py_ssize_t") long stack_level,
    @Cast("const char*") BytePointer format);
@NoException public static native int PyErr_ResourceWarning(
    PyObject source,
    @Cast("Py_ssize_t") long stack_level,
    String format);
// #endif
// #ifndef Py_LIMITED_API
@NoException public static native int PyErr_WarnExplicitObject(
    PyObject category,
    PyObject message,
    PyObject filename,
    int lineno,
    PyObject module,
    PyObject registry);
// #endif
@NoException public static native int PyErr_WarnExplicit(
    PyObject category,
    @Cast("const char*") BytePointer message,
    @Cast("const char*") BytePointer filename,
    int lineno,
    @Cast("const char*") BytePointer module,
    PyObject registry);
@NoException public static native int PyErr_WarnExplicit(
    PyObject category,
    String message,
    String filename,
    int lineno,
    String module,
    PyObject registry);

// #ifndef Py_LIMITED_API
@NoException public static native int PyErr_WarnExplicitFormat(PyObject category,
                         @Cast("const char*") BytePointer filename, int lineno,
                         @Cast("const char*") BytePointer module, PyObject registry,
                         @Cast("const char*") BytePointer format);
@NoException public static native int PyErr_WarnExplicitFormat(PyObject category,
                         String filename, int lineno,
                         String module, PyObject registry,
                         String format);
// #endif

/* DEPRECATED: Use PyErr_WarnEx() instead. */
// #ifndef Py_LIMITED_API
// #define PyErr_Warn(category, msg) PyErr_WarnEx(category, msg, 1)
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_WARNINGS_H */



// Parsed from weakrefobject.h

/* Weak references objects for Python. */

// #ifndef Py_WEAKREFOBJECT_H
// #define Py_WEAKREFOBJECT_H
// #ifdef __cplusplus
// Targeting ../python/PyWeakReference.java


// Targeting ../python/_PyWeakReference.java


// #endif

public static native @ByRef PyTypeObject _PyWeakref_RefType(); public static native void _PyWeakref_RefType(PyTypeObject _PyWeakref_RefType);
public static native @ByRef PyTypeObject _PyWeakref_ProxyType(); public static native void _PyWeakref_ProxyType(PyTypeObject _PyWeakref_ProxyType);
public static native @ByRef PyTypeObject _PyWeakref_CallableProxyType(); public static native void _PyWeakref_CallableProxyType(PyTypeObject _PyWeakref_CallableProxyType);

// #define PyWeakref_CheckRef(op) PyObject_TypeCheck(op, &_PyWeakref_RefType)
// #define PyWeakref_CheckRefExact(op)
//         (Py_TYPE(op) == &_PyWeakref_RefType)
// #define PyWeakref_CheckProxy(op)
//         ((Py_TYPE(op) == &_PyWeakref_ProxyType) ||
//          (Py_TYPE(op) == &_PyWeakref_CallableProxyType))

// #define PyWeakref_Check(op)
//         (PyWeakref_CheckRef(op) || PyWeakref_CheckProxy(op))


@NoException public static native PyObject PyWeakref_NewRef(PyObject ob,
                                              PyObject callback);
@NoException public static native PyObject PyWeakref_NewProxy(PyObject ob,
                                                PyObject callback);
@NoException public static native PyObject PyWeakref_GetObject(PyObject ref);

// #ifndef Py_LIMITED_API
@NoException public static native @Cast("Py_ssize_t") long _PyWeakref_GetWeakrefCount(PyWeakReference head);

@NoException public static native void _PyWeakref_ClearRef(PyWeakReference self);
// #endif

/* Explanation for the Py_REFCNT() check: when a weakref's target is part
   of a long chain of deallocations which triggers the trashcan mechanism,
   clearing the weakrefs can be delayed long after the target's refcount
   has dropped to zero.  In the meantime, code accessing the weakref will
   be able to "see" the target object even though it is supposed to be
   unreachable.  See issue #16602. */

// #define PyWeakref_GET_OBJECT(ref)
//     (Py_REFCNT(((PyWeakReference *)(ref))->wr_object) > 0
//      ? ((PyWeakReference *)(ref))->wr_object
//      : Py_None)


// #ifdef __cplusplus
// #endif
// #endif /* !Py_WEAKREFOBJECT_H */


// Parsed from structseq.h


/* Named tuple object interface */

// #ifndef Py_STRUCTSEQ_H
// #define Py_STRUCTSEQ_H
// #ifdef __cplusplus
// Targeting ../python/PyStructSequence_Field.java


// Targeting ../python/PyStructSequence_Desc.java





// #ifndef Py_LIMITED_API
@NoException public static native void PyStructSequence_InitType(PyTypeObject type,
                                           PyStructSequence_Desc desc);
@NoException public static native int PyStructSequence_InitType2(PyTypeObject type,
                                           PyStructSequence_Desc desc);
// #endif
@NoException public static native PyTypeObject PyStructSequence_NewType(PyStructSequence_Desc desc);

@NoException public static native PyObject PyStructSequence_New(PyTypeObject type);

// #ifndef Py_LIMITED_API

/* Macro, *only* to be used to fill in brand new objects */
// #define PyStructSequence_SET_ITEM(op, i, v) PyTuple_SET_ITEM(op, i, v)

// #define PyStructSequence_GET_ITEM(op, i) PyTuple_GET_ITEM(op, i)
// #endif

@NoException public static native void PyStructSequence_SetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1, PyObject arg2);
@NoException public static native PyObject PyStructSequence_GetItem(PyObject arg0, @Cast("Py_ssize_t") long arg1);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_STRUCTSEQ_H */


// Parsed from namespaceobject.h


/* simple namespace object interface */

// #ifndef NAMESPACEOBJECT_H
// #define NAMESPACEOBJECT_H
// #ifdef __cplusplus
// #endif

// #ifndef Py_LIMITED_API
public static native @ByRef PyTypeObject _PyNamespace_Type(); public static native void _PyNamespace_Type(PyTypeObject _PyNamespace_Type);

@NoException public static native PyObject _PyNamespace_New(PyObject kwds);
// #endif /* !Py_LIMITED_API */

// #ifdef __cplusplus
// #endif
// #endif /* !NAMESPACEOBJECT_H */


// Parsed from codecs.h

// #ifndef Py_CODECREGISTRY_H
// #define Py_CODECREGISTRY_H
// #ifdef __cplusplus
// #endif

/* ------------------------------------------------------------------------

   Python Codec Registry and support functions


Written by Marc-Andre Lemburg (mal@lemburg.com).

Copyright (c) Corporation for National Research Initiatives.

   ------------------------------------------------------------------------ */

/* Register a new codec search function.

   As side effect, this tries to load the encodings package, if not
   yet done, to make sure that it is always first in the list of
   search functions.

   The search_function's refcount is incremented by this function. */

@NoException public static native int PyCodec_Register(
       PyObject search_function
       );

/* Codec registry lookup API.

   Looks up the given encoding and returns a CodecInfo object with
   function attributes which implement the different aspects of
   processing the encoding.

   The encoding string is looked up converted to all lower-case
   characters. This makes encodings looked up through this mechanism
   effectively case-insensitive.

   If no codec is found, a KeyError is set and NULL returned.

   As side effect, this tries to load the encodings package, if not
   yet done. This is part of the lazy load strategy for the encodings
   package.

 */

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyCodec_Lookup(
       @Cast("const char*") BytePointer encoding
       );
@NoException public static native PyObject _PyCodec_Lookup(
       String encoding
       );

@NoException public static native int _PyCodec_Forget(
       @Cast("const char*") BytePointer encoding
       );
@NoException public static native int _PyCodec_Forget(
       String encoding
       );
// #endif

/* Codec registry encoding check API.

   Returns 1/0 depending on whether there is a registered codec for
   the given encoding.

*/

@NoException public static native int PyCodec_KnownEncoding(
       @Cast("const char*") BytePointer encoding
       );
@NoException public static native int PyCodec_KnownEncoding(
       String encoding
       );

/* Generic codec based encoding API.

   object is passed through the encoder function found for the given
   encoding using the error handling method defined by errors. errors
   may be NULL to use the default method defined for the codec.

   Raises a LookupError in case no encoder can be found.

 */

@NoException public static native PyObject PyCodec_Encode(
       PyObject object,
       @Cast("const char*") BytePointer encoding,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject PyCodec_Encode(
       PyObject object,
       String encoding,
       String errors
       );

/* Generic codec based decoding API.

   object is passed through the decoder function found for the given
   encoding using the error handling method defined by errors. errors
   may be NULL to use the default method defined for the codec.

   Raises a LookupError in case no encoder can be found.

 */

@NoException public static native PyObject PyCodec_Decode(
       PyObject object,
       @Cast("const char*") BytePointer encoding,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject PyCodec_Decode(
       PyObject object,
       String encoding,
       String errors
       );

// #ifndef Py_LIMITED_API
/* Text codec specific encoding and decoding API.

   Checks the encoding against a list of codecs which do not
   implement a str<->bytes encoding before attempting the
   operation.

   Please note that these APIs are internal and should not
   be used in Python C extensions.

   XXX (ncoghlan): should we make these, or something like them, public
   in Python 3.5+?

 */
@NoException public static native PyObject _PyCodec_LookupTextEncoding(
       @Cast("const char*") BytePointer encoding,
       @Cast("const char*") BytePointer alternate_command
       );
@NoException public static native PyObject _PyCodec_LookupTextEncoding(
       String encoding,
       String alternate_command
       );

@NoException public static native PyObject _PyCodec_EncodeText(
       PyObject object,
       @Cast("const char*") BytePointer encoding,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject _PyCodec_EncodeText(
       PyObject object,
       String encoding,
       String errors
       );

@NoException public static native PyObject _PyCodec_DecodeText(
       PyObject object,
       @Cast("const char*") BytePointer encoding,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject _PyCodec_DecodeText(
       PyObject object,
       String encoding,
       String errors
       );

/* These two aren't actually text encoding specific, but _io.TextIOWrapper
 * is the only current API consumer.
 */
@NoException public static native PyObject _PyCodecInfo_GetIncrementalDecoder(
       PyObject codec_info,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject _PyCodecInfo_GetIncrementalDecoder(
       PyObject codec_info,
       String errors
       );

@NoException public static native PyObject _PyCodecInfo_GetIncrementalEncoder(
       PyObject codec_info,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject _PyCodecInfo_GetIncrementalEncoder(
       PyObject codec_info,
       String errors
       );
// #endif



/* --- Codec Lookup APIs --------------------------------------------------

   All APIs return a codec object with incremented refcount and are
   based on _PyCodec_Lookup().  The same comments w/r to the encoding
   name also apply to these APIs.

*/

/* Get an encoder function for the given encoding. */

@NoException public static native PyObject PyCodec_Encoder(
       @Cast("const char*") BytePointer encoding
       );
@NoException public static native PyObject PyCodec_Encoder(
       String encoding
       );

/* Get a decoder function for the given encoding. */

@NoException public static native PyObject PyCodec_Decoder(
       @Cast("const char*") BytePointer encoding
       );
@NoException public static native PyObject PyCodec_Decoder(
       String encoding
       );

/* Get an IncrementalEncoder object for the given encoding. */

@NoException public static native PyObject PyCodec_IncrementalEncoder(
       @Cast("const char*") BytePointer encoding,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject PyCodec_IncrementalEncoder(
       String encoding,
       String errors
       );

/* Get an IncrementalDecoder object function for the given encoding. */

@NoException public static native PyObject PyCodec_IncrementalDecoder(
       @Cast("const char*") BytePointer encoding,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject PyCodec_IncrementalDecoder(
       String encoding,
       String errors
       );

/* Get a StreamReader factory function for the given encoding. */

@NoException public static native PyObject PyCodec_StreamReader(
       @Cast("const char*") BytePointer encoding,
       PyObject stream,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject PyCodec_StreamReader(
       String encoding,
       PyObject stream,
       String errors
       );

/* Get a StreamWriter factory function for the given encoding. */

@NoException public static native PyObject PyCodec_StreamWriter(
       @Cast("const char*") BytePointer encoding,
       PyObject stream,
       @Cast("const char*") BytePointer errors
       );
@NoException public static native PyObject PyCodec_StreamWriter(
       String encoding,
       PyObject stream,
       String errors
       );

/* Unicode encoding error handling callback registry API */

/* Register the error handling callback function error under the given
   name. This function will be called by the codec when it encounters
   unencodable characters/undecodable bytes and doesn't know the
   callback name, when name is specified as the error parameter
   in the call to the encode/decode function.
   Return 0 on success, -1 on error */
@NoException public static native int PyCodec_RegisterError(@Cast("const char*") BytePointer name, PyObject error);
@NoException public static native int PyCodec_RegisterError(String name, PyObject error);

/* Lookup the error handling callback function registered under the given
   name. As a special case NULL can be passed, in which case
   the error handling callback for "strict" will be returned. */
@NoException public static native PyObject PyCodec_LookupError(@Cast("const char*") BytePointer name);
@NoException public static native PyObject PyCodec_LookupError(String name);

/* raise exc as an exception */
@NoException public static native PyObject PyCodec_StrictErrors(PyObject exc);

/* ignore the unicode error, skipping the faulty input */
@NoException public static native PyObject PyCodec_IgnoreErrors(PyObject exc);

/* replace the unicode encode error with ? or U+FFFD */
@NoException public static native PyObject PyCodec_ReplaceErrors(PyObject exc);

/* replace the unicode encode error with XML character references */
@NoException public static native PyObject PyCodec_XMLCharRefReplaceErrors(PyObject exc);

/* replace the unicode encode error with backslash escapes (\x, \u005Cu and \U) */
@NoException public static native PyObject PyCodec_BackslashReplaceErrors(PyObject exc);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* replace the unicode encode error with backslash escapes (\N, \x, \u005Cu and \U) */
@NoException public static native PyObject PyCodec_NameReplaceErrors(PyObject exc);
// #endif

// #ifndef Py_LIMITED_API
@MemberGetter public static native @Cast("const char*") BytePointer Py_hexdigits();
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_CODECREGISTRY_H */


// Parsed from pyerrors.h

// #ifndef Py_ERRORS_H
// #define Py_ERRORS_H
// #ifdef __cplusplus
// #endif

/* Error objects */

// #ifndef Py_LIMITED_API
/* PyException_HEAD defines the initial segment of every exception class. */
// #define PyException_HEAD PyObject_HEAD PyObject *dict;
//              PyObject *args; PyObject *traceback;
//              PyObject *context; PyObject *cause;
//              char suppress_context;
// Targeting ../python/PyBaseExceptionObject.java


// Targeting ../python/PySyntaxErrorObject.java


// Targeting ../python/PyImportErrorObject.java


// Targeting ../python/PyUnicodeErrorObject.java


// Targeting ../python/PySystemExitObject.java


// Targeting ../python/PyOSErrorObject.java


// Targeting ../python/PyStopIterationObject.java



/* Compatibility typedefs */
// #ifdef MS_WINDOWS
// #endif
// #endif /* !Py_LIMITED_API */

/* Error handling definitions */

@NoException public static native void PyErr_SetNone(PyObject arg0);
@NoException public static native void PyErr_SetObject(PyObject arg0, PyObject arg1);
// #ifndef Py_LIMITED_API
@NoException public static native void _PyErr_SetKeyError(PyObject arg0);
// #endif
@NoException public static native void PyErr_SetString(
    PyObject exception,
    @Cast("const char*") BytePointer string
    );
@NoException public static native void PyErr_SetString(
    PyObject exception,
    String string
    );
@NoException public static native PyObject PyErr_Occurred();
@NoException public static native void PyErr_Clear();
@NoException public static native void PyErr_Fetch(@Cast("PyObject**") PointerPointer arg0, @Cast("PyObject**") PointerPointer arg1, @Cast("PyObject**") PointerPointer arg2);
@NoException public static native void PyErr_Fetch(@ByPtrPtr PyObject arg0, @ByPtrPtr PyObject arg1, @ByPtrPtr PyObject arg2);
@NoException public static native void PyErr_Restore(PyObject arg0, PyObject arg1, PyObject arg2);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native void PyErr_GetExcInfo(@Cast("PyObject**") PointerPointer arg0, @Cast("PyObject**") PointerPointer arg1, @Cast("PyObject**") PointerPointer arg2);
@NoException public static native void PyErr_GetExcInfo(@ByPtrPtr PyObject arg0, @ByPtrPtr PyObject arg1, @ByPtrPtr PyObject arg2);
@NoException public static native void PyErr_SetExcInfo(PyObject arg0, PyObject arg1, PyObject arg2);
// #endif

// #if defined(__clang__) ||
//     (defined(__GNUC_MAJOR__) &&
//      ((__GNUC_MAJOR__ >= 3) ||
//       (__GNUC_MAJOR__ == 2) && (__GNUC_MINOR__ >= 5)))
// #define _Py_NO_RETURN __attribute__((__noreturn__))
// #else
// #define _Py_NO_RETURN
// #endif

/* Defined in Python/pylifecycle.c */
@NoException public static native void Py_FatalError(@Cast("const char*") BytePointer message);
@NoException public static native void Py_FatalError(String message);

// #if defined(Py_DEBUG) || defined(Py_LIMITED_API)
// #define _PyErr_OCCURRED() PyErr_Occurred()
// #else
// #define _PyErr_OCCURRED() (PyThreadState_GET()->curexc_type)
// #endif

/* Error testing and normalization */
@NoException public static native int PyErr_GivenExceptionMatches(PyObject arg0, PyObject arg1);
@NoException public static native int PyErr_ExceptionMatches(PyObject arg0);
@NoException public static native void PyErr_NormalizeException(@Cast("PyObject**") PointerPointer arg0, @Cast("PyObject**") PointerPointer arg1, @Cast("PyObject**") PointerPointer arg2);
@NoException public static native void PyErr_NormalizeException(@ByPtrPtr PyObject arg0, @ByPtrPtr PyObject arg1, @ByPtrPtr PyObject arg2);

/* Traceback manipulation (PEP 3134) */
@NoException public static native int PyException_SetTraceback(PyObject arg0, PyObject arg1);
@NoException public static native PyObject PyException_GetTraceback(PyObject arg0);

/* Cause manipulation (PEP 3134) */
@NoException public static native PyObject PyException_GetCause(PyObject arg0);
@NoException public static native void PyException_SetCause(PyObject arg0, PyObject arg1);

/* Context manipulation (PEP 3134) */
@NoException public static native PyObject PyException_GetContext(PyObject arg0);
@NoException public static native void PyException_SetContext(PyObject arg0, PyObject arg1);
// #ifndef Py_LIMITED_API
@NoException public static native void _PyErr_ChainExceptions(PyObject arg0, PyObject arg1, PyObject arg2);
// #endif

/* */

// #define PyExceptionClass_Check(x)
//     (PyType_Check((x)) &&
//      PyType_FastSubclass((PyTypeObject*)(x), Py_TPFLAGS_BASE_EXC_SUBCLASS))

// #define PyExceptionInstance_Check(x)
//     PyType_FastSubclass((x)->ob_type, Py_TPFLAGS_BASE_EXC_SUBCLASS)

// #define PyExceptionClass_Name(x)
//      ((char *)(((PyTypeObject*)(x))->tp_name))

// #define PyExceptionInstance_Class(x) ((PyObject*)((x)->ob_type))


/* Predefined exceptions */

public static native PyObject PyExc_BaseException(); public static native void PyExc_BaseException(PyObject PyExc_BaseException);
public static native PyObject PyExc_Exception(); public static native void PyExc_Exception(PyObject PyExc_Exception);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
public static native PyObject PyExc_StopAsyncIteration(); public static native void PyExc_StopAsyncIteration(PyObject PyExc_StopAsyncIteration);
// #endif
public static native PyObject PyExc_StopIteration(); public static native void PyExc_StopIteration(PyObject PyExc_StopIteration);
public static native PyObject PyExc_GeneratorExit(); public static native void PyExc_GeneratorExit(PyObject PyExc_GeneratorExit);
public static native PyObject PyExc_ArithmeticError(); public static native void PyExc_ArithmeticError(PyObject PyExc_ArithmeticError);
public static native PyObject PyExc_LookupError(); public static native void PyExc_LookupError(PyObject PyExc_LookupError);

public static native PyObject PyExc_AssertionError(); public static native void PyExc_AssertionError(PyObject PyExc_AssertionError);
public static native PyObject PyExc_AttributeError(); public static native void PyExc_AttributeError(PyObject PyExc_AttributeError);
public static native PyObject PyExc_BufferError(); public static native void PyExc_BufferError(PyObject PyExc_BufferError);
public static native PyObject PyExc_EOFError(); public static native void PyExc_EOFError(PyObject PyExc_EOFError);
public static native PyObject PyExc_FloatingPointError(); public static native void PyExc_FloatingPointError(PyObject PyExc_FloatingPointError);
public static native PyObject PyExc_OSError(); public static native void PyExc_OSError(PyObject PyExc_OSError);
public static native PyObject PyExc_ImportError(); public static native void PyExc_ImportError(PyObject PyExc_ImportError);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
public static native PyObject PyExc_ModuleNotFoundError(); public static native void PyExc_ModuleNotFoundError(PyObject PyExc_ModuleNotFoundError);
// #endif
public static native PyObject PyExc_IndexError(); public static native void PyExc_IndexError(PyObject PyExc_IndexError);
public static native PyObject PyExc_KeyError(); public static native void PyExc_KeyError(PyObject PyExc_KeyError);
public static native PyObject PyExc_KeyboardInterrupt(); public static native void PyExc_KeyboardInterrupt(PyObject PyExc_KeyboardInterrupt);
public static native PyObject PyExc_MemoryError(); public static native void PyExc_MemoryError(PyObject PyExc_MemoryError);
public static native PyObject PyExc_NameError(); public static native void PyExc_NameError(PyObject PyExc_NameError);
public static native PyObject PyExc_OverflowError(); public static native void PyExc_OverflowError(PyObject PyExc_OverflowError);
public static native PyObject PyExc_RuntimeError(); public static native void PyExc_RuntimeError(PyObject PyExc_RuntimeError);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
public static native PyObject PyExc_RecursionError(); public static native void PyExc_RecursionError(PyObject PyExc_RecursionError);
// #endif
public static native PyObject PyExc_NotImplementedError(); public static native void PyExc_NotImplementedError(PyObject PyExc_NotImplementedError);
public static native PyObject PyExc_SyntaxError(); public static native void PyExc_SyntaxError(PyObject PyExc_SyntaxError);
public static native PyObject PyExc_IndentationError(); public static native void PyExc_IndentationError(PyObject PyExc_IndentationError);
public static native PyObject PyExc_TabError(); public static native void PyExc_TabError(PyObject PyExc_TabError);
public static native PyObject PyExc_ReferenceError(); public static native void PyExc_ReferenceError(PyObject PyExc_ReferenceError);
public static native PyObject PyExc_SystemError(); public static native void PyExc_SystemError(PyObject PyExc_SystemError);
public static native PyObject PyExc_SystemExit(); public static native void PyExc_SystemExit(PyObject PyExc_SystemExit);
public static native PyObject PyExc_TypeError(); public static native void PyExc_TypeError(PyObject PyExc_TypeError);
public static native PyObject PyExc_UnboundLocalError(); public static native void PyExc_UnboundLocalError(PyObject PyExc_UnboundLocalError);
public static native PyObject PyExc_UnicodeError(); public static native void PyExc_UnicodeError(PyObject PyExc_UnicodeError);
public static native PyObject PyExc_UnicodeEncodeError(); public static native void PyExc_UnicodeEncodeError(PyObject PyExc_UnicodeEncodeError);
public static native PyObject PyExc_UnicodeDecodeError(); public static native void PyExc_UnicodeDecodeError(PyObject PyExc_UnicodeDecodeError);
public static native PyObject PyExc_UnicodeTranslateError(); public static native void PyExc_UnicodeTranslateError(PyObject PyExc_UnicodeTranslateError);
public static native PyObject PyExc_ValueError(); public static native void PyExc_ValueError(PyObject PyExc_ValueError);
public static native PyObject PyExc_ZeroDivisionError(); public static native void PyExc_ZeroDivisionError(PyObject PyExc_ZeroDivisionError);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
public static native PyObject PyExc_BlockingIOError(); public static native void PyExc_BlockingIOError(PyObject PyExc_BlockingIOError);
public static native PyObject PyExc_BrokenPipeError(); public static native void PyExc_BrokenPipeError(PyObject PyExc_BrokenPipeError);
public static native PyObject PyExc_ChildProcessError(); public static native void PyExc_ChildProcessError(PyObject PyExc_ChildProcessError);
public static native PyObject PyExc_ConnectionError(); public static native void PyExc_ConnectionError(PyObject PyExc_ConnectionError);
public static native PyObject PyExc_ConnectionAbortedError(); public static native void PyExc_ConnectionAbortedError(PyObject PyExc_ConnectionAbortedError);
public static native PyObject PyExc_ConnectionRefusedError(); public static native void PyExc_ConnectionRefusedError(PyObject PyExc_ConnectionRefusedError);
public static native PyObject PyExc_ConnectionResetError(); public static native void PyExc_ConnectionResetError(PyObject PyExc_ConnectionResetError);
public static native PyObject PyExc_FileExistsError(); public static native void PyExc_FileExistsError(PyObject PyExc_FileExistsError);
public static native PyObject PyExc_FileNotFoundError(); public static native void PyExc_FileNotFoundError(PyObject PyExc_FileNotFoundError);
public static native PyObject PyExc_InterruptedError(); public static native void PyExc_InterruptedError(PyObject PyExc_InterruptedError);
public static native PyObject PyExc_IsADirectoryError(); public static native void PyExc_IsADirectoryError(PyObject PyExc_IsADirectoryError);
public static native PyObject PyExc_NotADirectoryError(); public static native void PyExc_NotADirectoryError(PyObject PyExc_NotADirectoryError);
public static native PyObject PyExc_PermissionError(); public static native void PyExc_PermissionError(PyObject PyExc_PermissionError);
public static native PyObject PyExc_ProcessLookupError(); public static native void PyExc_ProcessLookupError(PyObject PyExc_ProcessLookupError);
public static native PyObject PyExc_TimeoutError(); public static native void PyExc_TimeoutError(PyObject PyExc_TimeoutError);
// #endif


/* Compatibility aliases */
public static native PyObject PyExc_EnvironmentError(); public static native void PyExc_EnvironmentError(PyObject PyExc_EnvironmentError);
public static native PyObject PyExc_IOError(); public static native void PyExc_IOError(PyObject PyExc_IOError);
// #ifdef MS_WINDOWS
// #endif

public static native PyObject PyExc_RecursionErrorInst(); public static native void PyExc_RecursionErrorInst(PyObject PyExc_RecursionErrorInst);

/* Predefined warning categories */
public static native PyObject PyExc_Warning(); public static native void PyExc_Warning(PyObject PyExc_Warning);
public static native PyObject PyExc_UserWarning(); public static native void PyExc_UserWarning(PyObject PyExc_UserWarning);
public static native PyObject PyExc_DeprecationWarning(); public static native void PyExc_DeprecationWarning(PyObject PyExc_DeprecationWarning);
public static native PyObject PyExc_PendingDeprecationWarning(); public static native void PyExc_PendingDeprecationWarning(PyObject PyExc_PendingDeprecationWarning);
public static native PyObject PyExc_SyntaxWarning(); public static native void PyExc_SyntaxWarning(PyObject PyExc_SyntaxWarning);
public static native PyObject PyExc_RuntimeWarning(); public static native void PyExc_RuntimeWarning(PyObject PyExc_RuntimeWarning);
public static native PyObject PyExc_FutureWarning(); public static native void PyExc_FutureWarning(PyObject PyExc_FutureWarning);
public static native PyObject PyExc_ImportWarning(); public static native void PyExc_ImportWarning(PyObject PyExc_ImportWarning);
public static native PyObject PyExc_UnicodeWarning(); public static native void PyExc_UnicodeWarning(PyObject PyExc_UnicodeWarning);
public static native PyObject PyExc_BytesWarning(); public static native void PyExc_BytesWarning(PyObject PyExc_BytesWarning);
public static native PyObject PyExc_ResourceWarning(); public static native void PyExc_ResourceWarning(PyObject PyExc_ResourceWarning);


/* Convenience functions */

@NoException public static native int PyErr_BadArgument();
@NoException public static native PyObject PyErr_NoMemory();
@NoException public static native PyObject PyErr_SetFromErrno(PyObject arg0);
@NoException public static native PyObject PyErr_SetFromErrnoWithFilenameObject(
    PyObject arg0, PyObject arg1);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
@NoException public static native PyObject PyErr_SetFromErrnoWithFilenameObjects(
    PyObject arg0, PyObject arg1, PyObject arg2);
// #endif
@NoException public static native PyObject PyErr_SetFromErrnoWithFilename(
    PyObject exc,
    @Cast("const char*") BytePointer filename
    );
@NoException public static native PyObject PyErr_SetFromErrnoWithFilename(
    PyObject exc,
    String filename
    );
// #if defined(MS_WINDOWS) && !defined(Py_LIMITED_API)
// #endif /* MS_WINDOWS */

@NoException public static native PyObject PyErr_Format(
    PyObject exception,
    @Cast("const char*") BytePointer format
    );
@NoException public static native PyObject PyErr_Format(
    PyObject exception,
    String format
    );
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
@NoException public static native PyObject PyErr_FormatV(
    PyObject exception,
    @Cast("const char*") BytePointer format,
    @ByVal @Cast("va_list*") Pointer vargs);
@NoException public static native PyObject PyErr_FormatV(
    PyObject exception,
    String format,
    @ByVal @Cast("va_list*") Pointer vargs);
// #endif

// #ifndef Py_LIMITED_API
/* Like PyErr_Format(), but saves current exception as __context__ and
   __cause__.
 */
@NoException public static native PyObject _PyErr_FormatFromCause(
    PyObject exception,
    @Cast("const char*") BytePointer format
    );
@NoException public static native PyObject _PyErr_FormatFromCause(
    PyObject exception,
    String format
    );
// #endif

// #ifdef MS_WINDOWS
// #endif /* MS_WINDOWS */

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
@NoException public static native PyObject PyErr_SetImportErrorSubclass(PyObject arg0, PyObject arg1,
    PyObject arg2, PyObject arg3);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyErr_SetImportError(PyObject arg0, PyObject arg1,
    PyObject arg2);
// #endif

/* Export the old function so that the existing API remains available: */
@NoException public static native void PyErr_BadInternalCall();
@NoException public static native void _PyErr_BadInternalCall(@Cast("const char*") BytePointer filename, int lineno);
@NoException public static native void _PyErr_BadInternalCall(String filename, int lineno);
/* Mask the old API with a call to the new API for code compiled under
   Python 2.0: */
// #define PyErr_BadInternalCall() _PyErr_BadInternalCall(__FILE__, __LINE__)

/* Function to create a new exception */
@NoException public static native PyObject PyErr_NewException(
    @Cast("const char*") BytePointer name, PyObject base, PyObject dict);
@NoException public static native PyObject PyErr_NewException(
    String name, PyObject base, PyObject dict);
@NoException public static native PyObject PyErr_NewExceptionWithDoc(
    @Cast("const char*") BytePointer name, @Cast("const char*") BytePointer doc, PyObject base, PyObject dict);
@NoException public static native PyObject PyErr_NewExceptionWithDoc(
    String name, String doc, PyObject base, PyObject dict);
@NoException public static native void PyErr_WriteUnraisable(PyObject arg0);

/* In exceptions.c */
// #ifndef Py_LIMITED_API
/* Helper that attempts to replace the current exception with one of the
 * same type but with a prefix added to the exception text. The resulting
 * exception description looks like:
 *
 *     prefix (exc_type: original_exc_str)
 *
 * Only some exceptions can be safely replaced. If the function determines
 * it isn't safe to perform the replacement, it will leave the original
 * unmodified exception in place.
 *
 * Returns a borrowed reference to the new exception (if any), NULL if the
 * existing exception was left in place.
 */
@NoException public static native PyObject _PyErr_TrySetFromCause(
    @Cast("const char*") BytePointer prefix_format
    );
@NoException public static native PyObject _PyErr_TrySetFromCause(
    String prefix_format
    );
// #endif


/* In sigcheck.c or signalmodule.c */
@NoException public static native int PyErr_CheckSignals();
@NoException public static native void PyErr_SetInterrupt();

/* In signalmodule.c */
// #ifndef Py_LIMITED_API

// #endif

/* Support for adding program text to SyntaxErrors */
@NoException public static native void PyErr_SyntaxLocation(
    @Cast("const char*") BytePointer filename,
    int lineno);
@NoException public static native void PyErr_SyntaxLocation(
    String filename,
    int lineno);
@NoException public static native void PyErr_SyntaxLocationEx(
    @Cast("const char*") BytePointer filename,
    int lineno,
    int col_offset);
@NoException public static native void PyErr_SyntaxLocationEx(
    String filename,
    int lineno,
    int col_offset);
// #ifndef Py_LIMITED_API
@NoException public static native void PyErr_SyntaxLocationObject(
    PyObject filename,
    int lineno,
    int col_offset);
// #endif
@NoException public static native PyObject PyErr_ProgramText(
    @Cast("const char*") BytePointer filename,
    int lineno);
@NoException public static native PyObject PyErr_ProgramText(
    String filename,
    int lineno);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyErr_ProgramTextObject(
    PyObject filename,
    int lineno);
// #endif

/* The following functions are used to create and modify unicode
   exceptions from C */

/* create a UnicodeDecodeError object */
@NoException public static native PyObject PyUnicodeDecodeError_Create(
    @Cast("const char*") BytePointer encoding,
    @Cast("const char*") BytePointer object,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native PyObject PyUnicodeDecodeError_Create(
    String encoding,
    String object,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    String reason
    );

/* create a UnicodeEncodeError object */
// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyUnicodeEncodeError_Create(
    @Cast("const char*") BytePointer encoding,
    @Cast("const Py_UNICODE*") Pointer object,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native PyObject PyUnicodeEncodeError_Create(
    String encoding,
    @Cast("const Py_UNICODE*") Pointer object,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    String reason
    );
// #endif

/* create a UnicodeTranslateError object */
// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyUnicodeTranslateError_Create(
    @Cast("const Py_UNICODE*") Pointer object,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native PyObject PyUnicodeTranslateError_Create(
    @Cast("const Py_UNICODE*") Pointer object,
    @Cast("Py_ssize_t") long length,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    String reason
    );
@NoException public static native PyObject _PyUnicodeTranslateError_Create(
    PyObject object,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native PyObject _PyUnicodeTranslateError_Create(
    PyObject object,
    @Cast("Py_ssize_t") long start,
    @Cast("Py_ssize_t") long end,
    String reason
    );
// #endif

/* get the encoding attribute */
@NoException public static native PyObject PyUnicodeEncodeError_GetEncoding(PyObject arg0);
@NoException public static native PyObject PyUnicodeDecodeError_GetEncoding(PyObject arg0);

/* get the object attribute */
@NoException public static native PyObject PyUnicodeEncodeError_GetObject(PyObject arg0);
@NoException public static native PyObject PyUnicodeDecodeError_GetObject(PyObject arg0);
@NoException public static native PyObject PyUnicodeTranslateError_GetObject(PyObject arg0);

/* get the value of the start attribute (the int * may not be NULL)
   return 0 on success, -1 on failure */
@NoException public static native int PyUnicodeEncodeError_GetStart(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);
@NoException public static native int PyUnicodeDecodeError_GetStart(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);
@NoException public static native int PyUnicodeTranslateError_GetStart(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);

/* assign a new value to the start attribute
   return 0 on success, -1 on failure */
@NoException public static native int PyUnicodeEncodeError_SetStart(PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int PyUnicodeDecodeError_SetStart(PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int PyUnicodeTranslateError_SetStart(PyObject arg0, @Cast("Py_ssize_t") long arg1);

/* get the value of the end attribute (the int *may not be NULL)
 return 0 on success, -1 on failure */
@NoException public static native int PyUnicodeEncodeError_GetEnd(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);
@NoException public static native int PyUnicodeDecodeError_GetEnd(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);
@NoException public static native int PyUnicodeTranslateError_GetEnd(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);

/* assign a new value to the end attribute
   return 0 on success, -1 on failure */
@NoException public static native int PyUnicodeEncodeError_SetEnd(PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int PyUnicodeDecodeError_SetEnd(PyObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native int PyUnicodeTranslateError_SetEnd(PyObject arg0, @Cast("Py_ssize_t") long arg1);

/* get the value of the reason attribute */
@NoException public static native PyObject PyUnicodeEncodeError_GetReason(PyObject arg0);
@NoException public static native PyObject PyUnicodeDecodeError_GetReason(PyObject arg0);
@NoException public static native PyObject PyUnicodeTranslateError_GetReason(PyObject arg0);

/* assign a new value to the reason attribute
   return 0 on success, -1 on failure */
@NoException public static native int PyUnicodeEncodeError_SetReason(
    PyObject exc,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native int PyUnicodeEncodeError_SetReason(
    PyObject exc,
    String reason
    );
@NoException public static native int PyUnicodeDecodeError_SetReason(
    PyObject exc,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native int PyUnicodeDecodeError_SetReason(
    PyObject exc,
    String reason
    );
@NoException public static native int PyUnicodeTranslateError_SetReason(
    PyObject exc,
    @Cast("const char*") BytePointer reason
    );
@NoException public static native int PyUnicodeTranslateError_SetReason(
    PyObject exc,
    String reason
    );

/* These APIs aren't really part of the error implementation, but
   often needed to format error messages; the native C lib APIs are
   not available on all platforms, which is why we provide emulations
   for those platforms in Python/mysnprintf.c,
   WARNING:  The return value of snprintf varies across platforms; do
   not rely on any particular behavior; eventually the C99 defn may
   be reliable.
*/
// #if defined(MS_WIN32) && !defined(HAVE_SNPRINTF)
// #endif

// #include <stdarg.h>
@NoException public static native int PyOS_snprintf(@Cast("char*") BytePointer str, @Cast("size_t") long size, @Cast("const char*") BytePointer format);
@NoException public static native int PyOS_snprintf(@Cast("char*") ByteBuffer str, @Cast("size_t") long size, String format);
@NoException public static native int PyOS_snprintf(@Cast("char*") byte[] str, @Cast("size_t") long size, @Cast("const char*") BytePointer format);
@NoException public static native int PyOS_snprintf(@Cast("char*") BytePointer str, @Cast("size_t") long size, String format);
@NoException public static native int PyOS_snprintf(@Cast("char*") ByteBuffer str, @Cast("size_t") long size, @Cast("const char*") BytePointer format);
@NoException public static native int PyOS_snprintf(@Cast("char*") byte[] str, @Cast("size_t") long size, String format);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") BytePointer str, @Cast("size_t") long size, @Cast("const char*") BytePointer format, @ByVal @Cast("va_list*") Pointer va);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") ByteBuffer str, @Cast("size_t") long size, String format, @ByVal @Cast("va_list*") Pointer va);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") byte[] str, @Cast("size_t") long size, @Cast("const char*") BytePointer format, @ByVal @Cast("va_list*") Pointer va);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") BytePointer str, @Cast("size_t") long size, String format, @ByVal @Cast("va_list*") Pointer va);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") ByteBuffer str, @Cast("size_t") long size, @Cast("const char*") BytePointer format, @ByVal @Cast("va_list*") Pointer va);
@NoException public static native int PyOS_vsnprintf(@Cast("char*") byte[] str, @Cast("size_t") long size, String format, @ByVal @Cast("va_list*") Pointer va);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_ERRORS_H */


// Parsed from pyarena.h

/* An arena-like memory interface for the compiler.
 */

// #ifndef Py_LIMITED_API
// #ifndef Py_PYARENA_H
// #define Py_PYARENA_H

// #ifdef __cplusplus
// Targeting ../python/PyArena.java



  /* PyArena_New() and PyArena_Free() create a new arena and free it,
     respectively.  Once an arena has been created, it can be used
     to allocate memory via PyArena_Malloc().  Pointers to PyObject can
     also be registered with the arena via PyArena_AddPyObject(), and the
     arena will ensure that the PyObjects stay alive at least until
     PyArena_Free() is called.  When an arena is freed, all the memory it
     allocated is freed, the arena releases internal references to registered
     PyObject*, and none of its pointers are valid.
     XXX (tim) What does "none of its pointers are valid" mean?  Does it
     XXX mean that pointers previously obtained via PyArena_Malloc() are
     XXX no longer valid?  (That's clearly true, but not sure that's what
     XXX the text is trying to say.)

     PyArena_New() returns an arena pointer.  On error, it
     returns a negative number and sets an exception.
     XXX (tim):  Not true.  On error, PyArena_New() actually returns NULL,
     XXX and looks like it may or may not set an exception (e.g., if the
     XXX internal PyList_New(0) returns NULL, PyArena_New() passes that on
     XXX and an exception is set; OTOH, if the internal
     XXX block_new(DEFAULT_BLOCK_SIZE) returns NULL, that's passed on but
     XXX an exception is not set in that case).
  */
  @NoException public static native PyArena PyArena_New();
  @NoException public static native void PyArena_Free(PyArena arg0);

  /* Mostly like malloc(), return the address of a block of memory spanning
   * `size` bytes, or return NULL (without setting an exception) if enough
   * new memory can't be obtained.  Unlike malloc(0), PyArena_Malloc() with
   * size=0 does not guarantee to return a unique pointer (the pointer
   * returned may equal one or more other pointers obtained from
   * PyArena_Malloc()).
   * Note that pointers obtained via PyArena_Malloc() must never be passed to
   * the system free() or realloc(), or to any of Python's similar memory-
   * management functions.  PyArena_Malloc()-obtained pointers remain valid
   * until PyArena_Free(ar) is called, at which point all pointers obtained
   * from the arena `ar` become invalid simultaneously.
   */
  @NoException public static native Pointer PyArena_Malloc(PyArena arg0, @Cast("size_t") long size);

  /* This routine isn't a proper arena allocation routine.  It takes
   * a PyObject* and records it so that it can be DECREFed when the
   * arena is freed.
   */
  @NoException public static native int PyArena_AddPyObject(PyArena arg0, PyObject arg1);

// #ifdef __cplusplus
// #endif

// #endif /* !Py_PYARENA_H */
// #endif /* Py_LIMITED_API */


// Parsed from pystate.h


/* Thread and interpreter state structures and their interfaces */


// #ifndef Py_PYSTATE_H
// #define Py_PYSTATE_H
// #ifdef __cplusplus
// #endif

/* This limitation is for performance and simplicity. If needed it can be
removed (with effort). */
public static final int MAX_CO_EXTRA_USERS = 255;
// Targeting ../python/_ts.java


// Targeting ../python/_is.java

 /* Forward */ /* Forward declaration for PyFrameObject. */

// #ifdef Py_LIMITED_API
// Targeting ../python/_PyFrameEvalFunction.java


// Targeting ../python/PyInterpreterState.java


// Targeting ../python/__PyCodeExtraState.java



/* This is temporary for backwards compat in 3.6 and will be removed in 3.7 */

// Targeting ../python/Py_tracefunc.java



/* The following values are used for 'what' for tracefunc functions: */
public static final int PyTrace_CALL = 0;
public static final int PyTrace_EXCEPTION = 1;
public static final int PyTrace_LINE = 2;
public static final int PyTrace_RETURN = 3;
public static final int PyTrace_C_CALL = 4;
public static final int PyTrace_C_EXCEPTION = 5;
public static final int PyTrace_C_RETURN = 6;
// #endif

// #ifdef Py_LIMITED_API
// Targeting ../python/PyThreadState.java


// #endif


@NoException public static native PyInterpreterState PyInterpreterState_New();
@NoException public static native void PyInterpreterState_Clear(PyInterpreterState arg0);
@NoException public static native void PyInterpreterState_Delete(PyInterpreterState arg0);
// #ifndef Py_LIMITED_API
@NoException public static native int _PyState_AddModule(PyObject arg0, PyModuleDef arg1);
// #endif /* !Py_LIMITED_API */
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
/* New in 3.3 */
@NoException public static native int PyState_AddModule(PyObject arg0, PyModuleDef arg1);
@NoException public static native int PyState_RemoveModule(PyModuleDef arg0);
// #endif
@NoException public static native PyObject PyState_FindModule(PyModuleDef arg0);
// #ifndef Py_LIMITED_API
@NoException public static native void _PyState_ClearModules();
// #endif

@NoException public static native PyThreadState PyThreadState_New(PyInterpreterState arg0);
// #ifndef Py_LIMITED_API
@NoException public static native PyThreadState _PyThreadState_Prealloc(PyInterpreterState arg0);
@NoException public static native void _PyThreadState_Init(PyThreadState arg0);
// #endif /* !Py_LIMITED_API */
@NoException public static native void PyThreadState_Clear(PyThreadState arg0);
@NoException public static native void PyThreadState_Delete(PyThreadState arg0);
// #ifndef Py_LIMITED_API
@NoException public static native void _PyThreadState_DeleteExcept(PyThreadState tstate);
// #endif /* !Py_LIMITED_API */
// #ifdef WITH_THREAD
@NoException public static native void PyThreadState_DeleteCurrent();
// #ifndef Py_LIMITED_API
@NoException public static native void _PyGILState_Reinit();
// #endif /* !Py_LIMITED_API */
// #endif

/* Return the current thread state. The global interpreter lock must be held.
 * When the current thread state is NULL, this issues a fatal error (so that
 * the caller needn't check for NULL). */
@NoException public static native PyThreadState PyThreadState_Get();

// #ifndef Py_LIMITED_API
/* Similar to PyThreadState_Get(), but don't issue a fatal error
 * if it is NULL. */
@NoException public static native PyThreadState _PyThreadState_UncheckedGet();
// #endif /* !Py_LIMITED_API */

@NoException public static native PyThreadState PyThreadState_Swap(PyThreadState arg0);
@NoException public static native PyObject PyThreadState_GetDict();
@NoException public static native int PyThreadState_SetAsyncExc(long arg0, PyObject arg1);


/* Variable and macro for in-line access to current thread state */

/* Assuming the current thread holds the GIL, this is the
   PyThreadState for the current thread. */
// #ifdef Py_BUILD_CORE
// #  define PyThreadState_GET()
//              ((PyThreadState*)_Py_atomic_load_relaxed(&_PyThreadState_Current))
// #else
// #  define PyThreadState_GET() PyThreadState_Get()
// #endif

/** enum PyGILState_STATE */
public static final int PyGILState_LOCKED = 0, PyGILState_UNLOCKED = 1;

// #ifdef WITH_THREAD

/* Ensure that the current thread is ready to call the Python
   C API, regardless of the current state of Python, or of its
   thread lock.  This may be called as many times as desired
   by a thread so long as each call is matched with a call to
   PyGILState_Release().  In general, other thread-state APIs may
   be used between _Ensure() and _Release() calls, so long as the
   thread-state is restored to its previous state before the Release().
   For example, normal use of the Py_BEGIN_ALLOW_THREADS/
   Py_END_ALLOW_THREADS macros are acceptable.

   The return value is an opaque "handle" to the thread state when
   PyGILState_Ensure() was called, and must be passed to
   PyGILState_Release() to ensure Python is left in the same state. Even
   though recursive calls are allowed, these handles can *not* be shared -
   each unique call to PyGILState_Ensure must save the handle for its
   call to PyGILState_Release.

   When the function returns, the current thread will hold the GIL.

   Failure is a fatal error.
*/
@NoException public static native @Cast("PyGILState_STATE") int PyGILState_Ensure();

/* Release any resources previously acquired.  After this call, Python's
   state will be the same as it was prior to the corresponding
   PyGILState_Ensure() call (but generally this state will be unknown to
   the caller, hence the use of the GILState API.)

   Every call to PyGILState_Ensure must be matched by a call to
   PyGILState_Release on the same thread.
*/
@NoException public static native void PyGILState_Release(@Cast("PyGILState_STATE") int arg0);

/* Helper/diagnostic function - get the current thread state for
   this thread.  May return NULL if no GILState API has been used
   on the current thread.  Note that the main thread always has such a
   thread-state, even if no auto-thread-state call has been made
   on the main thread.
*/
@NoException public static native PyThreadState PyGILState_GetThisThreadState();

// #ifndef Py_LIMITED_API
/* Issue #26558: Flag to disable PyGILState_Check().
   If set to non-zero, PyGILState_Check() always return 1. */
public static native int _PyGILState_check_enabled(); public static native void _PyGILState_check_enabled(int _PyGILState_check_enabled);

/* Helper/diagnostic function - return 1 if the current thread
   currently holds the GIL, 0 otherwise.

   The function returns 1 if _PyGILState_check_enabled is non-zero. */
@NoException public static native int PyGILState_Check();

/* Unsafe function to get the single PyInterpreterState used by this process'
   GILState implementation.

   Return NULL before _PyGILState_Init() is called and after _PyGILState_Fini()
   is called. */
@NoException public static native PyInterpreterState _PyGILState_GetInterpreterStateUnsafe();
// #endif

// #endif   /* #ifdef WITH_THREAD */

/* The implementation of sys._current_frames()  Returns a dict mapping
   thread id to that thread's current frame.
*/
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyThread_CurrentFrames();
// #endif

/* Routines for advanced debuggers, requested by David Beazley.
   Don't use unless you know what you are doing! */
// #ifndef Py_LIMITED_API
@NoException public static native PyInterpreterState PyInterpreterState_Head();
@NoException public static native PyInterpreterState PyInterpreterState_Next(PyInterpreterState arg0);
@NoException public static native PyThreadState PyInterpreterState_ThreadHead(PyInterpreterState arg0);
@NoException public static native PyThreadState PyThreadState_Next(PyThreadState arg0);
// #endif

/* hook for PyEval_GetFrame(), requested for Psyco */
// #ifndef Py_LIMITED_API
public static native @ByRef @Cast("PyThreadFrameGetter*") Pointer _PyThreadState_GetFrame(); public static native void _PyThreadState_GetFrame(Pointer _PyThreadState_GetFrame);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYSTATE_H */


// Parsed from modsupport.h


// #ifndef Py_MODSUPPORT_H
// #define Py_MODSUPPORT_H
// #ifdef __cplusplus
// #endif

/* Module support interface */

// #include <stdarg.h>

/* If PY_SSIZE_T_CLEAN is defined, each functions treats #-specifier
   to mean Py_ssize_t */
// #ifdef PY_SSIZE_T_CLEAN
// #else
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _Py_VaBuildValue_SizeT(@Cast("const char*") BytePointer arg0, @ByVal @Cast("va_list*") Pointer arg1);
@NoException public static native PyObject _Py_VaBuildValue_SizeT(String arg0, @ByVal @Cast("va_list*") Pointer arg1);
// #endif /* !Py_LIMITED_API */
// #endif

/* Due to a glitch in 3.2, the _SizeT versions weren't exported from the DLL. */
// #if !defined(PY_SSIZE_T_CLEAN) || !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
// #endif
@NoException public static native int PyArg_ValidateKeywordArguments(PyObject arg0);
@NoException public static native int PyArg_UnpackTuple(PyObject arg0, @Cast("const char*") BytePointer arg1, @Cast("Py_ssize_t") long arg2, @Cast("Py_ssize_t") long arg3);
@NoException public static native int PyArg_UnpackTuple(PyObject arg0, String arg1, @Cast("Py_ssize_t") long arg2, @Cast("Py_ssize_t") long arg3);
@NoException public static native PyObject Py_BuildValue(@Cast("const char*") BytePointer arg0);
@NoException public static native PyObject Py_BuildValue(String arg0);
@NoException public static native PyObject _Py_BuildValue_SizeT(@Cast("const char*") BytePointer arg0);
@NoException public static native PyObject _Py_BuildValue_SizeT(String arg0);

// #ifndef Py_LIMITED_API
@NoException public static native int _PyArg_NoKeywords(@Cast("const char*") BytePointer funcname, PyObject kw);
@NoException public static native int _PyArg_NoKeywords(String funcname, PyObject kw);
@NoException public static native int _PyArg_NoPositional(@Cast("const char*") BytePointer funcname, PyObject args);
@NoException public static native int _PyArg_NoPositional(String funcname, PyObject args);
// #endif
@NoException public static native PyObject Py_VaBuildValue(@Cast("const char*") BytePointer arg0, @ByVal @Cast("va_list*") Pointer arg1);
@NoException public static native PyObject Py_VaBuildValue(String arg0, @ByVal @Cast("va_list*") Pointer arg1);
// Targeting ../python/_PyArg_Parser.java


// #ifdef PY_SSIZE_T_CLEAN
// #endif
@NoException public static native int _PyArg_ParseTupleAndKeywordsFast(PyObject arg0, PyObject arg1,
                                                 _PyArg_Parser arg2);
@NoException public static native int _PyArg_ParseStack(@Cast("PyObject**") PointerPointer args, @Cast("Py_ssize_t") long nargs, PyObject kwnames,
                                  _PyArg_Parser arg3);
@NoException public static native int _PyArg_ParseStack(@ByPtrPtr PyObject args, @Cast("Py_ssize_t") long nargs, PyObject kwnames,
                                  _PyArg_Parser arg3);
@NoException public static native int _PyArg_VaParseTupleAndKeywordsFast(PyObject arg0, PyObject arg1,
                                                   _PyArg_Parser arg2, @ByVal @Cast("va_list*") Pointer arg3);

// #endif

@NoException public static native int PyModule_AddObject(PyObject arg0, @Cast("const char*") BytePointer arg1, PyObject arg2);
@NoException public static native int PyModule_AddObject(PyObject arg0, String arg1, PyObject arg2);
@NoException public static native int PyModule_AddIntConstant(PyObject arg0, @Cast("const char*") BytePointer arg1, long arg2);
@NoException public static native int PyModule_AddIntConstant(PyObject arg0, String arg1, long arg2);
@NoException public static native int PyModule_AddStringConstant(PyObject arg0, @Cast("const char*") BytePointer arg1, @Cast("const char*") BytePointer arg2);
@NoException public static native int PyModule_AddStringConstant(PyObject arg0, String arg1, String arg2);
// #define PyModule_AddIntMacro(m, c) PyModule_AddIntConstant(m, #c, c)
// #define PyModule_AddStringMacro(m, c) PyModule_AddStringConstant(m, #c, c)

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* New in 3.5 */
@NoException public static native int PyModule_SetDocString(PyObject arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native int PyModule_SetDocString(PyObject arg0, String arg1);
@NoException public static native int PyModule_AddFunctions(PyObject arg0, PyMethodDef arg1);
@NoException public static native int PyModule_ExecDef(PyObject module, PyModuleDef def);
// #endif

public static final int Py_CLEANUP_SUPPORTED = 0x20000;

public static final int PYTHON_API_VERSION = 1013;
public static final String PYTHON_API_STRING = "1013";
/* The API version is maintained (independently from the Python version)
   so we can detect mismatches between the interpreter and dynamically
   loaded modules.  These are diagnosed by an error message but
   the module is still loaded (because the mismatch can only be tested
   after loading the module).  The error message is intended to
   explain the core dump a few seconds later.

   The symbol PYTHON_API_STRING defines the same value as a string
   literal.  *** PLEASE MAKE SURE THE DEFINITIONS MATCH. ***

   Please add a line or two to the top of this log for each API
   version change:

   22-Feb-2006  MvL     1013    PEP 353 - long indices for sequence lengths

   19-Aug-2002  GvR     1012    Changes to string object struct for
                                interning changes, saving 3 bytes.

   17-Jul-2001  GvR     1011    Descr-branch, just to be on the safe side

   25-Jan-2001  FLD     1010    Parameters added to PyCode_New() and
                                PyFrame_New(); Python 2.1a2

   14-Mar-2000  GvR     1009    Unicode API added

   3-Jan-1999   GvR     1007    Decided to change back!  (Don't reuse 1008!)

   3-Dec-1998   GvR     1008    Python 1.5.2b1

   18-Jan-1997  GvR     1007    string interning and other speedups

   11-Oct-1996  GvR     renamed Py_Ellipses to Py_Ellipsis :-(

   30-Jul-1996  GvR     Slice and ellipses syntax added

   23-Jul-1996  GvR     For 1.4 -- better safe than sorry this time :-)

   7-Nov-1995   GvR     Keyword arguments (should've been done at 1.3 :-( )

   10-Jan-1995  GvR     Renamed globals to new naming scheme

   9-Jan-1995   GvR     Initial version (incompatible with older API)
*/

/* The PYTHON_ABI_VERSION is introduced in PEP 384. For the lifetime of
   Python 3, it will stay at the value of 3; changes to the limited API
   must be performed in a strictly backwards-compatible manner. */
public static final int PYTHON_ABI_VERSION = 3;
public static final String PYTHON_ABI_STRING = "3";

// #ifdef Py_TRACE_REFS
// #endif

@NoException public static native PyObject PyModule_Create2(PyModuleDef arg0,
                                     int apiver);

// #ifdef Py_LIMITED_API
// #define PyModule_Create(module)
//         PyModule_Create2(module, PYTHON_ABI_VERSION)
// #else
// #define PyModule_Create(module)
//         PyModule_Create2(module, PYTHON_API_VERSION)
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* New in 3.5 */
@NoException public static native PyObject PyModule_FromDefAndSpec2(PyModuleDef def,
                                                PyObject spec,
                                                int module_api_version);

// #ifdef Py_LIMITED_API
// #define PyModule_FromDefAndSpec(module, spec)
//     PyModule_FromDefAndSpec2(module, spec, PYTHON_ABI_VERSION)
// #else
// #define PyModule_FromDefAndSpec(module, spec)
//     PyModule_FromDefAndSpec2(module, spec, PYTHON_API_VERSION)
// #endif /* Py_LIMITED_API */
// #endif /* New in 3.5 */

// #ifndef Py_LIMITED_API
public static native @Cast("char*") BytePointer _Py_PackageContext(); public static native void _Py_PackageContext(BytePointer _Py_PackageContext);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_MODSUPPORT_H */


// Parsed from ceval.h

// #ifndef Py_CEVAL_H
// #define Py_CEVAL_H
// #ifdef __cplusplus
// #endif


/* Interface to random parts in ceval.c */

@NoException public static native PyObject PyEval_CallObjectWithKeywords(
    PyObject func, PyObject args, PyObject kwargs);

/* Inline this */
// #define PyEval_CallObject(func,arg)
//     PyEval_CallObjectWithKeywords(func, arg, (PyObject *)NULL)

@NoException public static native PyObject PyEval_CallFunction(PyObject obj,
                                           @Cast("const char*") BytePointer format);
@NoException public static native PyObject PyEval_CallFunction(PyObject obj,
                                           String format);
@NoException public static native PyObject PyEval_CallMethod(PyObject obj,
                                         @Cast("const char*") BytePointer methodname,
                                         @Cast("const char*") BytePointer format);
@NoException public static native PyObject PyEval_CallMethod(PyObject obj,
                                         String methodname,
                                         String format);

// #ifndef Py_LIMITED_API
@NoException public static native void PyEval_SetProfile(Py_tracefunc arg0, PyObject arg1);
@NoException public static native void PyEval_SetTrace(Py_tracefunc arg0, PyObject arg1);
@NoException public static native void _PyEval_SetCoroutineWrapper(PyObject arg0);
@NoException public static native PyObject _PyEval_GetCoroutineWrapper();
@NoException public static native void _PyEval_SetAsyncGenFirstiter(PyObject arg0);
@NoException public static native PyObject _PyEval_GetAsyncGenFirstiter();
@NoException public static native void _PyEval_SetAsyncGenFinalizer(PyObject arg0);
@NoException public static native PyObject _PyEval_GetAsyncGenFinalizer();
// #endif /* Avoid including frameobject.h */

@NoException public static native PyObject PyEval_GetBuiltins();
@NoException public static native PyObject PyEval_GetGlobals();
@NoException public static native PyObject PyEval_GetLocals();
@NoException public static native _frame PyEval_GetFrame();

/* Look at the current frame's (if any) code's co_flags, and turn on
   the corresponding compiler flags in cf->cf_flags.  Return 1 if any
   flag was set, else return 0. */
// #ifndef Py_LIMITED_API
@NoException public static native int PyEval_MergeCompilerFlags(PyCompilerFlags cf);
// Targeting ../python/Func_Pointer.java


@NoException public static native int Py_AddPendingCall(Func_Pointer func, Pointer arg);
@NoException public static native void _PyEval_SignalReceived();
@NoException public static native int Py_MakePendingCalls();

/* Protection against deeply nested recursive calls

   In Python 3.0, this protection has two levels:
   * normal anti-recursion protection is triggered when the recursion level
     exceeds the current recursion limit. It raises a RecursionError, and sets
     the "overflowed" flag in the thread state structure. This flag
     temporarily *disables* the normal protection; this allows cleanup code
     to potentially outgrow the recursion limit while processing the
     RecursionError.
   * "last chance" anti-recursion protection is triggered when the recursion
     level exceeds "current recursion limit + 50". By construction, this
     protection can only be triggered when the "overflowed" flag is set. It
     means the cleanup code has itself gone into an infinite loop, or the
     RecursionError has been mistakingly ignored. When this protection is
     triggered, the interpreter aborts with a Fatal Error.

   In addition, the "overflowed" flag is automatically reset when the
   recursion level drops below "current recursion limit - 50". This heuristic
   is meant to ensure that the normal anti-recursion protection doesn't get
   disabled too long.

   Please note: this scheme has its own limitations. See:
   http://mail.python.org/pipermail/python-dev/2008-August/082106.html
   for some observations.
*/
@NoException public static native void Py_SetRecursionLimit(int arg0);
@NoException public static native int Py_GetRecursionLimit();

// #define Py_EnterRecursiveCall(where)
//             (_Py_MakeRecCheck(PyThreadState_GET()->recursion_depth) &&
//              _Py_CheckRecursiveCall(where))
// #define Py_LeaveRecursiveCall()
//     do{ if(_Py_MakeEndRecCheck(PyThreadState_GET()->recursion_depth))
//       PyThreadState_GET()->overflowed = 0;
//     } while(0)
@NoException public static native int _Py_CheckRecursiveCall(@Cast("const char*") BytePointer where);
@NoException public static native int _Py_CheckRecursiveCall(String where);
public static native int _Py_CheckRecursionLimit(); public static native void _Py_CheckRecursionLimit(int _Py_CheckRecursionLimit);

// #ifdef USE_STACKCHECK
/* With USE_STACKCHECK, we artificially decrement the recursion limit in order
   to trigger regular stack checks in _Py_CheckRecursiveCall(), except if
   the "overflowed" flag is set, in which case we need the true value
   of _Py_CheckRecursionLimit for _Py_MakeEndRecCheck() to function properly.
*/
// #  define _Py_MakeRecCheck(x)
//     (++(x) > (_Py_CheckRecursionLimit += PyThreadState_GET()->overflowed - 1))
// #else
// #  define _Py_MakeRecCheck(x)  (++(x) > _Py_CheckRecursionLimit)
// #endif

/* Compute the "lower-water mark" for a recursion limit. When
 * Py_LeaveRecursiveCall() is called with a recursion depth below this mark,
 * the overflowed flag is reset to 0. */
// #define _Py_RecursionLimitLowerWaterMark(limit)
//     (((limit) > 200)
//         ? ((limit) - 50)
//         : (3 * ((limit) >> 2)))

// #define _Py_MakeEndRecCheck(x)
//     (--(x) < _Py_RecursionLimitLowerWaterMark(_Py_CheckRecursionLimit))

// #define Py_ALLOW_RECURSION
//   do { unsigned char _old = PyThreadState_GET()->recursion_critical;
//     PyThreadState_GET()->recursion_critical = 1;

// #define Py_END_ALLOW_RECURSION
//     PyThreadState_GET()->recursion_critical = _old;
//   } while(0);

@NoException public static native @Cast("const char*") BytePointer PyEval_GetFuncName(PyObject arg0);
@NoException public static native @Cast("const char*") BytePointer PyEval_GetFuncDesc(PyObject arg0);

@NoException public static native PyObject PyEval_GetCallStats(PyObject arg0);
@NoException public static native PyObject PyEval_EvalFrame(_frame arg0);
@NoException public static native PyObject PyEval_EvalFrameEx(_frame f, int exc);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyEval_EvalFrameDefault(_frame f, int exc);
// #endif

/* Interface for threads.

   A module that plans to do a blocking system call (or something else
   that lasts a long time and doesn't touch Python data) can allow other
   threads to run as follows:

    ...preparations here...
    Py_BEGIN_ALLOW_THREADS
    ...blocking system call here...
    Py_END_ALLOW_THREADS
    ...interpret result here...

   The Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS pair expands to a
   {}-surrounded block.
   To leave the block in the middle (e.g., with return), you must insert
   a line containing Py_BLOCK_THREADS before the return, e.g.

    if (...premature_exit...) {
        Py_BLOCK_THREADS
        PyErr_SetFromErrno(PyExc_IOError);
        return NULL;
    }

   An alternative is:

    Py_BLOCK_THREADS
    if (...premature_exit...) {
        PyErr_SetFromErrno(PyExc_IOError);
        return NULL;
    }
    Py_UNBLOCK_THREADS

   For convenience, that the value of 'errno' is restored across
   Py_END_ALLOW_THREADS and Py_BLOCK_THREADS.

   WARNING: NEVER NEST CALLS TO Py_BEGIN_ALLOW_THREADS AND
   Py_END_ALLOW_THREADS!!!

   The function PyEval_InitThreads() should be called only from
   init_thread() in "_threadmodule.c".

   Note that not yet all candidates have been converted to use this
   mechanism!
*/

@NoException public static native PyThreadState PyEval_SaveThread();
@NoException public static native void PyEval_RestoreThread(PyThreadState arg0);

// #ifdef WITH_THREAD

@NoException public static native int PyEval_ThreadsInitialized();
@NoException public static native void PyEval_InitThreads();
// #ifndef Py_LIMITED_API
@NoException public static native void _PyEval_FiniThreads();
// #endif /* !Py_LIMITED_API */
@NoException public static native void PyEval_AcquireLock();
@NoException public static native void PyEval_ReleaseLock();
@NoException public static native void PyEval_AcquireThread(PyThreadState tstate);
@NoException public static native void PyEval_ReleaseThread(PyThreadState tstate);
@NoException public static native void PyEval_ReInitThreads();

// #ifndef Py_LIMITED_API
@NoException public static native void _PyEval_SetSwitchInterval(@Cast("unsigned long") long microseconds);
@NoException public static native @Cast("unsigned long") long _PyEval_GetSwitchInterval();
// #endif

// #ifndef Py_LIMITED_API
@NoException public static native @Cast("Py_ssize_t") long _PyEval_RequestCodeExtraIndex(freefunc arg0);
// #endif

// #define Py_BEGIN_ALLOW_THREADS {
//                         PyThreadState *_save;
//                         _save = PyEval_SaveThread();
// #define Py_BLOCK_THREADS        PyEval_RestoreThread(_save);
// #define Py_UNBLOCK_THREADS      _save = PyEval_SaveThread();
// #define Py_END_ALLOW_THREADS    PyEval_RestoreThread(_save);
//                  }

// #else /* !WITH_THREAD */

// #define Py_BEGIN_ALLOW_THREADS {
// #define Py_BLOCK_THREADS
// #define Py_UNBLOCK_THREADS
// #define Py_END_ALLOW_THREADS }

// #endif /* !WITH_THREAD */

// #ifndef Py_LIMITED_API
@NoException public static native int _PyEval_SliceIndex(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);
@NoException public static native int _PyEval_SliceIndexNotNone(PyObject arg0, @Cast("Py_ssize_t*") SizeTPointer arg1);
@NoException public static native void _PyEval_SignalAsyncExc();
// #endif

/* Masks and values used by FORMAT_VALUE opcode. */
public static final int FVC_MASK =      0x3;
public static final int FVC_NONE =      0x0;
public static final int FVC_STR =       0x1;
public static final int FVC_REPR =      0x2;
public static final int FVC_ASCII =     0x3;
public static final int FVS_MASK =      0x4;
public static final int FVS_HAVE_SPEC = 0x4;

// #ifdef __cplusplus
// #endif
// #endif /* !Py_CEVAL_H */


// Parsed from sysmodule.h


/* System module interface */

// #ifndef Py_SYSMODULE_H
// #define Py_SYSMODULE_H
// #ifdef __cplusplus
// #endif

@NoException public static native PyObject PySys_GetObject(@Cast("const char*") BytePointer arg0);
@NoException public static native PyObject PySys_GetObject(String arg0);
@NoException public static native int PySys_SetObject(@Cast("const char*") BytePointer arg0, PyObject arg1);
@NoException public static native int PySys_SetObject(String arg0, PyObject arg1);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PySys_GetObjectId(_Py_Identifier key);
@NoException public static native int _PySys_SetObjectId(_Py_Identifier key, PyObject arg1);
// #endif

@NoException public static native void PySys_SetArgv(int arg0, @Cast("wchar_t**") PointerPointer arg1);
@NoException public static native void PySys_SetArgv(int arg0, @Cast("wchar_t**") @ByPtrPtr Pointer arg1);
@NoException public static native void PySys_SetArgvEx(int arg0, @Cast("wchar_t**") PointerPointer arg1, int arg2);
@NoException public static native void PySys_SetArgvEx(int arg0, @Cast("wchar_t**") @ByPtrPtr Pointer arg1, int arg2);
@NoException public static native void PySys_SetPath(@Cast("const wchar_t*") Pointer arg0);

@NoException public static native void PySys_WriteStdout(@Cast("const char*") BytePointer format);
@NoException public static native void PySys_WriteStdout(String format);
@NoException public static native void PySys_WriteStderr(@Cast("const char*") BytePointer format);
@NoException public static native void PySys_WriteStderr(String format);
@NoException public static native void PySys_FormatStdout(@Cast("const char*") BytePointer format);
@NoException public static native void PySys_FormatStdout(String format);
@NoException public static native void PySys_FormatStderr(@Cast("const char*") BytePointer format);
@NoException public static native void PySys_FormatStderr(String format);

@NoException public static native void PySys_ResetWarnOptions();
@NoException public static native void PySys_AddWarnOption(@Cast("const wchar_t*") Pointer arg0);
@NoException public static native void PySys_AddWarnOptionUnicode(PyObject arg0);
@NoException public static native int PySys_HasWarnOptions();

@NoException public static native void PySys_AddXOption(@Cast("const wchar_t*") Pointer arg0);
@NoException public static native PyObject PySys_GetXOptions();

// #ifndef Py_LIMITED_API
@NoException public static native @Cast("size_t") long _PySys_GetSizeOf(PyObject arg0);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_SYSMODULE_H */


// Parsed from osmodule.h


/* os module interface */

// #ifndef Py_OSMODULE_H
// #define Py_OSMODULE_H
// #ifdef __cplusplus
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03060000
@NoException public static native PyObject PyOS_FSPath(PyObject path);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_OSMODULE_H */


// Parsed from intrcheck.h


// #ifndef Py_INTRCHECK_H
// #define Py_INTRCHECK_H
// #ifdef __cplusplus
// #endif

@NoException public static native int PyOS_InterruptOccurred();
@NoException public static native void PyOS_InitInterrupts();
@NoException public static native void PyOS_AfterFork();

// #ifndef Py_LIMITED_API
@NoException public static native int _PyOS_IsMainThread();

// #ifdef MS_WINDOWS
// #endif
// #endif /* !Py_LIMITED_API */

// #ifdef __cplusplus
// #endif
// #endif /* !Py_INTRCHECK_H */


// Parsed from import.h


/* Module definition and import interface */

// #ifndef Py_IMPORT_H
// #define Py_IMPORT_H
// #ifdef __cplusplus
// #endif

// #ifndef Py_LIMITED_API
@NoException public static native void _PyImportZip_Init();


// #endif /* !Py_LIMITED_API */
@NoException public static native long PyImport_GetMagicNumber();
@NoException public static native @Cast("const char*") BytePointer PyImport_GetMagicTag();
@NoException public static native PyObject PyImport_ExecCodeModule(
    @Cast("const char*") BytePointer name,
    PyObject co
    );
@NoException public static native PyObject PyImport_ExecCodeModule(
    String name,
    PyObject co
    );
@NoException public static native PyObject PyImport_ExecCodeModuleEx(
    @Cast("const char*") BytePointer name,
    PyObject co,
    @Cast("const char*") BytePointer pathname
    );
@NoException public static native PyObject PyImport_ExecCodeModuleEx(
    String name,
    PyObject co,
    String pathname
    );
@NoException public static native PyObject PyImport_ExecCodeModuleWithPathnames(
    @Cast("const char*") BytePointer name,
    PyObject co,
    @Cast("const char*") BytePointer pathname,
    @Cast("const char*") BytePointer cpathname
    );
@NoException public static native PyObject PyImport_ExecCodeModuleWithPathnames(
    String name,
    PyObject co,
    String pathname,
    String cpathname
    );
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyImport_ExecCodeModuleObject(
    PyObject name,
    PyObject co,
    PyObject pathname,
    PyObject cpathname
    );
// #endif
@NoException public static native PyObject PyImport_GetModuleDict();
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyImport_AddModuleObject(
    PyObject name
    );
// #endif
@NoException public static native PyObject PyImport_AddModule(
    @Cast("const char*") BytePointer name
    );
@NoException public static native PyObject PyImport_AddModule(
    String name
    );
@NoException public static native PyObject PyImport_ImportModule(
    @Cast("const char*") BytePointer name
    );
@NoException public static native PyObject PyImport_ImportModule(
    String name
    );
@NoException public static native PyObject PyImport_ImportModuleNoBlock(
    @Cast("const char*") BytePointer name
    );
@NoException public static native PyObject PyImport_ImportModuleNoBlock(
    String name
    );
@NoException public static native PyObject PyImport_ImportModuleLevel(
    @Cast("const char*") BytePointer name,
    PyObject globals,
    PyObject locals,
    PyObject fromlist,
    int level
    );
@NoException public static native PyObject PyImport_ImportModuleLevel(
    String name,
    PyObject globals,
    PyObject locals,
    PyObject fromlist,
    int level
    );
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
@NoException public static native PyObject PyImport_ImportModuleLevelObject(
    PyObject name,
    PyObject globals,
    PyObject locals,
    PyObject fromlist,
    int level
    );
// #endif

// #define PyImport_ImportModuleEx(n, g, l, f)
//     PyImport_ImportModuleLevel(n, g, l, f, 0)

@NoException public static native PyObject PyImport_GetImporter(PyObject path);
@NoException public static native PyObject PyImport_Import(PyObject name);
@NoException public static native PyObject PyImport_ReloadModule(PyObject m);
@NoException public static native void PyImport_Cleanup();
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native int PyImport_ImportFrozenModuleObject(
    PyObject name
    );
// #endif
@NoException public static native int PyImport_ImportFrozenModule(
    @Cast("const char*") BytePointer name
    );
@NoException public static native int PyImport_ImportFrozenModule(
    String name
    );

// #ifndef Py_LIMITED_API
// #ifdef WITH_THREAD
@NoException public static native void _PyImport_AcquireLock();
@NoException public static native int _PyImport_ReleaseLock();
// #else
// #define _PyImport_AcquireLock()
// #define _PyImport_ReleaseLock() 1
// #endif

@NoException public static native void _PyImport_ReInitLock();

@NoException public static native PyObject _PyImport_FindBuiltin(
    @Cast("const char*") BytePointer name
    );
@NoException public static native PyObject _PyImport_FindBuiltin(
    String name
    );
@NoException public static native PyObject _PyImport_FindExtensionObject(PyObject arg0, PyObject arg1);
@NoException public static native int _PyImport_FixupBuiltin(
    PyObject mod,
    @Cast("const char*") BytePointer name
    );
@NoException public static native int _PyImport_FixupBuiltin(
    PyObject mod,
    String name
    );
@NoException public static native int _PyImport_FixupExtensionObject(PyObject arg0, PyObject arg1, PyObject arg2);
// Targeting ../python/_inittab.java


public static native _inittab PyImport_Inittab(); public static native void PyImport_Inittab(_inittab PyImport_Inittab);
@NoException public static native int PyImport_ExtendInittab(_inittab newtab);
// #endif /* Py_LIMITED_API */


// Targeting ../python/PyObject_Initfunc.java


@NoException public static native int PyImport_AppendInittab(
    @Cast("const char*") BytePointer name,
    PyObject_Initfunc initfunc
    );
@NoException public static native int PyImport_AppendInittab(
    String name,
    PyObject_Initfunc initfunc
    );
// Targeting ../python/_frozen.java



/* Embedding apps may change this pointer to point to their favorite
   collection of frozen modules: */

@MemberGetter public static native @Const _frozen PyImport_FrozenModules();
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_IMPORT_H */


// Parsed from abstract.h

// #ifndef Py_ABSTRACTOBJECT_H
// #define Py_ABSTRACTOBJECT_H
// #ifdef __cplusplus
// #endif

// #ifdef PY_SSIZE_T_CLEAN
// #endif

/* Abstract Object Interface (many thanks to Jim Fulton) */

/*
   PROPOSAL: A Generic Python Object Interface for Python C Modules

Problem

  Python modules written in C that must access Python objects must do
  so through routines whose interfaces are described by a set of
  include files.  Unfortunately, these routines vary according to the
  object accessed.  To use these routines, the C programmer must check
  the type of the object being used and must call a routine based on
  the object type.  For example, to access an element of a sequence,
  the programmer must determine whether the sequence is a list or a
  tuple:

    if(is_tupleobject(o))
      e=gettupleitem(o,i)
    else if(is_listitem(o))
      e=getlistitem(o,i)

  If the programmer wants to get an item from another type of object
  that provides sequence behavior, there is no clear way to do it
  correctly.

  The persistent programmer may peruse object.h and find that the
  _typeobject structure provides a means of invoking up to (currently
  about) 41 special operators.  So, for example, a routine can get an
  item from any object that provides sequence behavior. However, to
  use this mechanism, the programmer must make their code dependent on
  the current Python implementation.

  Also, certain semantics, especially memory management semantics, may
  differ by the type of object being used.  Unfortunately, these
  semantics are not clearly described in the current include files.
  An abstract interface providing more consistent semantics is needed.

Proposal

  I propose the creation of a standard interface (with an associated
  library of routines and/or macros) for generically obtaining the
  services of Python objects.  This proposal can be viewed as one
  components of a Python C interface consisting of several components.

  From the viewpoint of C access to Python services, we have (as
  suggested by Guido in off-line discussions):

  - "Very high level layer": two or three functions that let you exec or
    eval arbitrary Python code given as a string in a module whose name is
    given, passing C values in and getting C values out using
    mkvalue/getargs style format strings.  This does not require the user
    to declare any variables of type "PyObject *".  This should be enough
    to write a simple application that gets Python code from the user,
    execs it, and returns the output or errors.  (Error handling must also
    be part of this API.)

  - "Abstract objects layer": which is the subject of this proposal.
    It has many functions operating on objects, and lest you do many
    things from C that you can also write in Python, without going
    through the Python parser.

  - "Concrete objects layer": This is the public type-dependent
    interface provided by the standard built-in types, such as floats,
    strings, and lists.  This interface exists and is currently
    documented by the collection of include files provided with the
    Python distributions.

  From the point of view of Python accessing services provided by C
  modules:

  - "Python module interface": this interface consist of the basic
    routines used to define modules and their members.  Most of the
    current extensions-writing guide deals with this interface.

  - "Built-in object interface": this is the interface that a new
    built-in type must provide and the mechanisms and rules that a
    developer of a new built-in type must use and follow.

  This proposal is a "first-cut" that is intended to spur
  discussion. See especially the lists of notes.

  The Python C object interface will provide four protocols: object,
  numeric, sequence, and mapping.  Each protocol consists of a
  collection of related operations.  If an operation that is not
  provided by a particular type is invoked, then a standard exception,
  NotImplementedError is raised with an operation name as an argument.
  In addition, for convenience this interface defines a set of
  constructors for building objects of built-in types.  This is needed
  so new objects can be returned from C functions that otherwise treat
  objects generically.

Memory Management

  For all of the functions described in this proposal, if a function
  retains a reference to a Python object passed as an argument, then the
  function will increase the reference count of the object.  It is
  unnecessary for the caller to increase the reference count of an
  argument in anticipation of the object's retention.

  All Python objects returned from functions should be treated as new
  objects.  Functions that return objects assume that the caller will
  retain a reference and the reference count of the object has already
  been incremented to account for this fact.  A caller that does not
  retain a reference to an object that is returned from a function
  must decrement the reference count of the object (using
  DECREF(object)) to prevent memory leaks.

  Note that the behavior mentioned here is different from the current
  behavior for some objects (e.g. lists and tuples) when certain
  type-specific routines are called directly (e.g. setlistitem).  The
  proposed abstraction layer will provide a consistent memory
  management interface, correcting for inconsistent behavior for some
  built-in types.

Protocols

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx*/

/*  Object Protocol: */

     /* Implemented elsewhere:

     int PyObject_Print(PyObject *o, FILE *fp, int flags);

     Print an object, o, on file, fp.  Returns -1 on
     error.  The flags argument is used to enable certain printing
     options. The only option currently supported is Py_Print_RAW.

     (What should be said about Py_Print_RAW?)

       */

     /* Implemented elsewhere:

     int PyObject_HasAttrString(PyObject *o, const char *attr_name);

     Returns 1 if o has the attribute attr_name, and 0 otherwise.
     This is equivalent to the Python expression:
     hasattr(o,attr_name).

     This function always succeeds.

       */

     /* Implemented elsewhere:

     PyObject* PyObject_GetAttrString(PyObject *o, const char *attr_name);

     Retrieve an attributed named attr_name form object o.
     Returns the attribute value on success, or NULL on failure.
     This is the equivalent of the Python expression: o.attr_name.

       */

     /* Implemented elsewhere:

     int PyObject_HasAttr(PyObject *o, PyObject *attr_name);

     Returns 1 if o has the attribute attr_name, and 0 otherwise.
     This is equivalent to the Python expression:
     hasattr(o,attr_name).

     This function always succeeds.

       */

     /* Implemented elsewhere:

     PyObject* PyObject_GetAttr(PyObject *o, PyObject *attr_name);

     Retrieve an attributed named attr_name form object o.
     Returns the attribute value on success, or NULL on failure.
     This is the equivalent of the Python expression: o.attr_name.

       */


     /* Implemented elsewhere:

     int PyObject_SetAttrString(PyObject *o, const char *attr_name, PyObject *v);

     Set the value of the attribute named attr_name, for object o,
     to the value v. Raise an exception and return -1 on failure; return 0 on
     success.  This is the equivalent of the Python statement o.attr_name=v.

       */

     /* Implemented elsewhere:

     int PyObject_SetAttr(PyObject *o, PyObject *attr_name, PyObject *v);

     Set the value of the attribute named attr_name, for object o,
     to the value v. Raise an exception and return -1 on failure; return 0 on
     success.  This is the equivalent of the Python statement o.attr_name=v.

       */

     /* implemented as a macro:

     int PyObject_DelAttrString(PyObject *o, const char *attr_name);

     Delete attribute named attr_name, for object o. Returns
     -1 on failure.  This is the equivalent of the Python
     statement: del o.attr_name.

       */
// #define  PyObject_DelAttrString(O,A) PyObject_SetAttrString((O),(A),NULL)

     /* implemented as a macro:

     int PyObject_DelAttr(PyObject *o, PyObject *attr_name);

     Delete attribute named attr_name, for object o. Returns -1
     on failure.  This is the equivalent of the Python
     statement: del o.attr_name.

       */
// #define  PyObject_DelAttr(O,A) PyObject_SetAttr((O),(A),NULL)

     /* Implemented elsewhere:

     PyObject *PyObject_Repr(PyObject *o);

     Compute the string representation of object, o.  Returns the
     string representation on success, NULL on failure.  This is
     the equivalent of the Python expression: repr(o).

     Called by the repr() built-in function.

       */

     /* Implemented elsewhere:

     PyObject *PyObject_Str(PyObject *o);

     Compute the string representation of object, o.  Returns the
     string representation on success, NULL on failure.  This is
     the equivalent of the Python expression: str(o).)

     Called by the str() and print() built-in functions.

       */

       /* Declared elsewhere

     PyAPI_FUNC(int) PyCallable_Check(PyObject *o);

     Determine if the object, o, is callable.  Return 1 if the
     object is callable and 0 otherwise.

     This function always succeeds.
       */

     @NoException public static native PyObject PyObject_Call(PyObject callable_object,
                                               PyObject args, PyObject kwargs);

       /*
     Call a callable Python object, callable_object, with
     arguments and keywords arguments.  The 'args' argument can not be
     NULL.
       */

// #ifndef Py_LIMITED_API
    @NoException public static native PyObject _PyStack_AsTuple(
            @Cast("PyObject**") PointerPointer stack,
            @Cast("Py_ssize_t") long nargs);
    @NoException public static native PyObject _PyStack_AsTuple(
            @ByPtrPtr PyObject stack,
            @Cast("Py_ssize_t") long nargs);

    /* Convert keyword arguments from the (stack, kwnames) format to a Python
       dictionary.

       kwnames must only contains str strings, no subclass, and all keys must
       be unique. kwnames is not checked, usually these checks are done before or later
       calling _PyStack_AsDict(). For example, _PyArg_ParseStack() raises an
       error if a key is not a string. */
    @NoException public static native PyObject _PyStack_AsDict(
            @Cast("PyObject**") PointerPointer values,
            PyObject kwnames);
    @NoException public static native PyObject _PyStack_AsDict(
            @ByPtrPtr PyObject values,
            PyObject kwnames);

    /* Convert (args, nargs, kwargs: dict) into (stack, nargs, kwnames: tuple).

       Return 0 on success, raise an exception and return -1 on error.

       Write the new stack into *p_stack. If *p_stack is differen than args, it
       must be released by PyMem_Free().

       The stack uses borrowed references.

       The type of keyword keys is not checked, these checks should be done
       later (ex: _PyArg_ParseStackAndKeywords). */
    @NoException public static native int _PyStack_UnpackDict(
            @Cast("PyObject**") PointerPointer args,
            @Cast("Py_ssize_t") long nargs,
            PyObject kwargs,
            @Cast("PyObject***") @ByPtrPtr PointerPointer p_stack,
            @Cast("PyObject**") PointerPointer p_kwnames);
    @NoException public static native int _PyStack_UnpackDict(
            @ByPtrPtr PyObject args,
            @Cast("Py_ssize_t") long nargs,
            PyObject kwargs,
            @Cast("PyObject***") @ByPtrPtr PointerPointer p_stack,
            @ByPtrPtr PyObject p_kwnames);

    /* Call the callable object func with the "fast call" calling convention:
       args is a C array for positional arguments (nargs is the number of
       positional arguments), kwargs is a dictionary for keyword arguments.

       If nargs is equal to zero, args can be NULL. kwargs can be NULL.
       nargs must be greater or equal to zero.

       Return the result on success. Raise an exception on return NULL on
       error. */
    @NoException public static native PyObject _PyObject_FastCallDict(PyObject func,
                                                      @Cast("PyObject**") PointerPointer args, @Cast("Py_ssize_t") long nargs,
                                                      PyObject kwargs);
    @NoException public static native PyObject _PyObject_FastCallDict(PyObject func,
                                                      @ByPtrPtr PyObject args, @Cast("Py_ssize_t") long nargs,
                                                      PyObject kwargs);

    /* Call the callable object func with the "fast call" calling convention:
       args is a C array for positional arguments followed by values of
       keyword arguments. Keys of keyword arguments are stored as a tuple
       of strings in kwnames. nargs is the number of positional parameters at
       the beginning of stack. The size of kwnames gives the number of keyword
       values in the stack after positional arguments.

       kwnames must only contains str strings, no subclass, and all keys must
       be unique.

       If nargs is equal to zero and there is no keyword argument (kwnames is
       NULL or its size is zero), args can be NULL.

       Return the result on success. Raise an exception and return NULL on
       error. */
    @NoException public static native PyObject _PyObject_FastCallKeywords(PyObject func,
            @Cast("PyObject**") PointerPointer args,
            @Cast("Py_ssize_t") long nargs,
            PyObject kwnames);
    @NoException public static native PyObject _PyObject_FastCallKeywords(PyObject func,
            @ByPtrPtr PyObject args,
            @Cast("Py_ssize_t") long nargs,
            PyObject kwnames);

// #define _PyObject_FastCall(func, args, nargs)
//     _PyObject_FastCallDict((func), (args), (nargs), NULL)

// #define _PyObject_CallNoArg(func)
//     _PyObject_FastCall((func), NULL, 0)

// #define _PyObject_CallArg1(func, arg)
//     _PyObject_FastCall((func), &(arg), 1)

    @NoException public static native PyObject _PyObject_Call_Prepend(PyObject func,
                                                      PyObject obj, PyObject args,
                                                      PyObject kwargs);

     @NoException public static native PyObject _Py_CheckFunctionResult(PyObject func,
                                                         PyObject result,
                                                         @Cast("const char*") BytePointer where);
     @NoException public static native PyObject _Py_CheckFunctionResult(PyObject func,
                                                         PyObject result,
                                                         String where);
// #endif   /* Py_LIMITED_API */

     @NoException public static native PyObject PyObject_CallObject(PyObject callable_object,
                                                     PyObject args);

       /*
     Call a callable Python object, callable_object, with
     arguments given by the tuple, args.  If no arguments are
     needed, then args may be NULL.  Returns the result of the
     call on success, or NULL on failure.  This is the equivalent
     of the Python expression: o(*args).
       */

     @NoException public static native PyObject PyObject_CallFunction(PyObject callable_object,
                                                       @Cast("const char*") BytePointer format);
     @NoException public static native PyObject PyObject_CallFunction(PyObject callable_object,
                                                       String format);

       /*
     Call a callable Python object, callable_object, with a
     variable number of C arguments. The C arguments are described
     using a mkvalue-style format string. The format may be NULL,
     indicating that no arguments are provided.  Returns the
     result of the call on success, or NULL on failure.  This is
     the equivalent of the Python expression: o(*args).
       */


     @NoException public static native PyObject PyObject_CallMethod(PyObject o,
                                                     @Cast("const char*") BytePointer method,
                                                     @Cast("const char*") BytePointer format);
     @NoException public static native PyObject PyObject_CallMethod(PyObject o,
                                                     String method,
                                                     String format);

       /*
     Call the method named m of object o with a variable number of
     C arguments.  The C arguments are described by a mkvalue
     format string.  The format may be NULL, indicating that no
     arguments are provided. Returns the result of the call on
     success, or NULL on failure.  This is the equivalent of the
     Python expression: o.method(args).
       */

// #ifndef Py_LIMITED_API
     @NoException public static native PyObject _PyObject_CallMethodId(PyObject o,
                                                        _Py_Identifier method,
                                                        @Cast("const char*") BytePointer format);
     @NoException public static native PyObject _PyObject_CallMethodId(PyObject o,
                                                        _Py_Identifier method,
                                                        String format);

       /*
         Like PyObject_CallMethod, but expect a _Py_Identifier* as the
         method name.
       */
// #endif /* !Py_LIMITED_API */

     @NoException public static native PyObject _PyObject_CallFunction_SizeT(PyObject callable,
                                                              @Cast("const char*") BytePointer format);
     @NoException public static native PyObject _PyObject_CallFunction_SizeT(PyObject callable,
                                                              String format);
     @NoException public static native PyObject _PyObject_CallMethod_SizeT(PyObject o,
                                                            @Cast("const char*") BytePointer name,
                                                            @Cast("const char*") BytePointer format);
     @NoException public static native PyObject _PyObject_CallMethod_SizeT(PyObject o,
                                                            String name,
                                                            String format);
// #ifndef Py_LIMITED_API
     @NoException public static native PyObject _PyObject_CallMethodId_SizeT(PyObject o,
                                                            _Py_Identifier name,
                                                            @Cast("const char*") BytePointer format);
     @NoException public static native PyObject _PyObject_CallMethodId_SizeT(PyObject o,
                                                            _Py_Identifier name,
                                                            String format);
// #endif /* !Py_LIMITED_API */

     @NoException public static native PyObject PyObject_CallFunctionObjArgs(PyObject callable);

       /*
     Call a callable Python object, callable_object, with a
     variable number of C arguments.  The C arguments are provided
     as PyObject * values, terminated by a NULL.  Returns the
     result of the call on success, or NULL on failure.  This is
     the equivalent of the Python expression: o(*args).
       */


     @NoException public static native PyObject PyObject_CallMethodObjArgs(PyObject o,
                                                            PyObject method);
// #ifndef Py_LIMITED_API
     @NoException public static native PyObject _PyObject_CallMethodIdObjArgs(PyObject o,
                                                    _Py_Identifier method);
// #endif /* !Py_LIMITED_API */

       /*
     Call the method named m of object o with a variable number of
     C arguments.  The C arguments are provided as PyObject *
     values, terminated by NULL.  Returns the result of the call
     on success, or NULL on failure.  This is the equivalent of
     the Python expression: o.method(args).
       */


     /* Implemented elsewhere:

     long PyObject_Hash(PyObject *o);

     Compute and return the hash, hash_value, of an object, o.  On
     failure, return -1.  This is the equivalent of the Python
     expression: hash(o).
       */


     /* Implemented elsewhere:

     int PyObject_IsTrue(PyObject *o);

     Returns 1 if the object, o, is considered to be true, 0 if o is
     considered to be false and -1 on failure. This is equivalent to the
     Python expression: not not o
       */

     /* Implemented elsewhere:

     int PyObject_Not(PyObject *o);

     Returns 0 if the object, o, is considered to be true, 1 if o is
     considered to be false and -1 on failure. This is equivalent to the
     Python expression: not o
       */

     @NoException public static native PyObject PyObject_Type(PyObject o);

       /*
     On success, returns a type object corresponding to the object
     type of object o. On failure, returns NULL.  This is
     equivalent to the Python expression: type(o).
       */

     @NoException public static native @Cast("Py_ssize_t") long PyObject_Size(PyObject o);

       /*
     Return the size of object o.  If the object, o, provides
     both sequence and mapping protocols, the sequence size is
     returned. On error, -1 is returned.  This is the equivalent
     to the Python expression: len(o).
       */

       /* For DLL compatibility */
// #undef PyObject_Length
// #define PyObject_Length PyObject_Size

// #ifndef Py_LIMITED_API
     @NoException public static native int _PyObject_HasLen(PyObject o);
     @NoException public static native @Cast("Py_ssize_t") long PyObject_LengthHint(PyObject o, @Cast("Py_ssize_t") long arg1);
// #endif

       /*
     Guess the size of object o using len(o) or o.__length_hint__().
     If neither of those return a non-negative value, then return the
     default value.  If one of the calls fails, this function returns -1.
       */

     @NoException public static native PyObject PyObject_GetItem(PyObject o, PyObject key);

       /*
     Return element of o corresponding to the object, key, or NULL
     on failure. This is the equivalent of the Python expression:
     o[key].
       */

     @NoException public static native int PyObject_SetItem(PyObject o, PyObject key, PyObject v);

       /*
     Map the object key to the value v.  Raise an exception and return -1
     on failure; return 0 on success.  This is the equivalent of the Python
     statement o[key]=v.
       */

     @NoException public static native int PyObject_DelItemString(PyObject o, @Cast("const char*") BytePointer key);
     @NoException public static native int PyObject_DelItemString(PyObject o, String key);

       /*
     Remove the mapping for object, key, from the object *o.
     Returns -1 on failure.  This is equivalent to
     the Python statement: del o[key].
       */

     @NoException public static native int PyObject_DelItem(PyObject o, PyObject key);

       /*
     Delete the mapping for key from *o.  Returns -1 on failure.
     This is the equivalent of the Python statement: del o[key].
       */

    /* old buffer API
       FIXME:  usage of these should all be replaced in Python itself
       but for backwards compatibility we will implement them.
       Their usage without a corresponding "unlock" mechanism
       may create issues (but they would already be there). */

     @NoException public static native int PyObject_AsCharBuffer(PyObject obj,
                                                @Cast("const char**") PointerPointer buffer,
                                                @Cast("Py_ssize_t*") SizeTPointer buffer_len);
     @NoException public static native int PyObject_AsCharBuffer(PyObject obj,
                                                @Cast("const char**") @ByPtrPtr BytePointer buffer,
                                                @Cast("Py_ssize_t*") SizeTPointer buffer_len);
     @NoException public static native int PyObject_AsCharBuffer(PyObject obj,
                                                @Cast("const char**") @ByPtrPtr ByteBuffer buffer,
                                                @Cast("Py_ssize_t*") SizeTPointer buffer_len);
     @NoException public static native int PyObject_AsCharBuffer(PyObject obj,
                                                @Cast("const char**") @ByPtrPtr byte[] buffer,
                                                @Cast("Py_ssize_t*") SizeTPointer buffer_len);

       /*
      Takes an arbitrary object which must support the (character,
      single segment) buffer interface and returns a pointer to a
      read-only memory location useable as character based input
      for subsequent processing.

      0 is returned on success.  buffer and buffer_len are only
      set in case no error occurs. Otherwise, -1 is returned and
      an exception set.
       */

     @NoException public static native int PyObject_CheckReadBuffer(PyObject obj);

      /*
      Checks whether an arbitrary object supports the (character,
      single segment) buffer interface.  Returns 1 on success, 0
      on failure.
      */

     @NoException public static native int PyObject_AsReadBuffer(PyObject obj,
                                                @Cast("const void**") PointerPointer buffer,
                                                @Cast("Py_ssize_t*") SizeTPointer buffer_len);
     @NoException public static native int PyObject_AsReadBuffer(PyObject obj,
                                                @Cast("const void**") @ByPtrPtr Pointer buffer,
                                                @Cast("Py_ssize_t*") SizeTPointer buffer_len);

       /*
      Same as PyObject_AsCharBuffer() except that this API expects
      (readable, single segment) buffer interface and returns a
      pointer to a read-only memory location which can contain
      arbitrary data.

      0 is returned on success.  buffer and buffer_len are only
      set in case no error occurs.  Otherwise, -1 is returned and
      an exception set.
       */

     @NoException public static native int PyObject_AsWriteBuffer(PyObject obj,
                                                 @Cast("void**") PointerPointer buffer,
                                                 @Cast("Py_ssize_t*") SizeTPointer buffer_len);
     @NoException public static native int PyObject_AsWriteBuffer(PyObject obj,
                                                 @Cast("void**") @ByPtrPtr Pointer buffer,
                                                 @Cast("Py_ssize_t*") SizeTPointer buffer_len);

       /*
      Takes an arbitrary object which must support the (writable,
      single segment) buffer interface and returns a pointer to a
      writable memory location in buffer of size buffer_len.

      0 is returned on success.  buffer and buffer_len are only
      set in case no error occurs. Otherwise, -1 is returned and
      an exception set.
       */

    /* new buffer API */

// #ifndef Py_LIMITED_API
// #define PyObject_CheckBuffer(obj)
//     (((obj)->ob_type->tp_as_buffer != NULL) &&
//      ((obj)->ob_type->tp_as_buffer->bf_getbuffer != NULL))

    /* Return 1 if the getbuffer function is available, otherwise
       return 0 */

     @NoException public static native int PyObject_GetBuffer(PyObject obj, Py_buffer view,
                                             int flags);

    /* This is a C-API version of the getbuffer function call.  It checks
       to make sure object has the required function pointer and issues the
       call.  Returns -1 and raises an error on failure and returns 0 on
       success
    */


     @NoException public static native Pointer PyBuffer_GetPointer(Py_buffer view, @Cast("Py_ssize_t*") SizeTPointer indices);

    /* Get the memory area pointed to by the indices for the buffer given.
       Note that view->ndim is the assumed size of indices
    */

     

    /* Return the implied itemsize of the data-format area from a
       struct-style description */



     /* Implementation in memoryobject.c */
     @NoException public static native int PyBuffer_ToContiguous(Pointer buf, Py_buffer view,
                                                @Cast("Py_ssize_t") long len, @Cast("char") byte order);

     @NoException public static native int PyBuffer_FromContiguous(Py_buffer view, Pointer buf,
                                                  @Cast("Py_ssize_t") long len, @Cast("char") byte order);


    /* Copy len bytes of data from the contiguous chunk of memory
       pointed to by buf into the buffer exported by obj.  Return
       0 on success and return -1 and raise a PyBuffer_Error on
       error (i.e. the object does not have a buffer interface or
       it is not working).

       If fort is 'F', then if the object is multi-dimensional,
       then the data will be copied into the array in
       Fortran-style (first dimension varies the fastest).  If
       fort is 'C', then the data will be copied into the array
       in C-style (last dimension varies the fastest).  If fort
       is 'A', then it does not matter and the copy will be made
       in whatever way is more efficient.

    */

     @NoException public static native int PyObject_CopyData(PyObject dest, PyObject src);

    /* Copy the data from the src buffer to the buffer of destination
     */

     @NoException public static native int PyBuffer_IsContiguous(@Const Py_buffer view, @Cast("char") byte fort);


     @NoException public static native void PyBuffer_FillContiguousStrides(int ndims,
                                                         @Cast("Py_ssize_t*") SizeTPointer shape,
                                                         @Cast("Py_ssize_t*") SizeTPointer strides,
                                                         int itemsize,
                                                         @Cast("char") byte fort);

    /*  Fill the strides array with byte-strides of a contiguous
        (Fortran-style if fort is 'F' or C-style otherwise)
        array of the given shape with the given number of bytes
        per element.
    */

     @NoException public static native int PyBuffer_FillInfo(Py_buffer view, PyObject o, Pointer buf,
                                            @Cast("Py_ssize_t") long len, int readonly,
                                            int flags);

    /* Fills in a buffer-info structure correctly for an exporter
       that can only share a contiguous chunk of memory of
       "unsigned bytes" of the given length. Returns 0 on success
       and -1 (with raising an error) on error.
     */

     @NoException public static native void PyBuffer_Release(Py_buffer view);

       /* Releases a Py_buffer obtained from getbuffer ParseTuple's s*.
    */
// #endif /* Py_LIMITED_API */

     @NoException public static native PyObject PyObject_Format(PyObject obj,
                                                 PyObject format_spec);
       /*
     Takes an arbitrary object and returns the result of
     calling obj.__format__(format_spec).
       */

/* Iterators */

     @NoException public static native PyObject PyObject_GetIter(PyObject arg0);
     /* Takes an object and returns an iterator for it.
    This is typically a new iterator but if the argument
    is an iterator, this returns itself. */

// #define PyIter_Check(obj)
//     ((obj)->ob_type->tp_iternext != NULL &&
//      (obj)->ob_type->tp_iternext != &_PyObject_NextNotImplemented)

     @NoException public static native PyObject PyIter_Next(PyObject arg0);
     /* Takes an iterator object and calls its tp_iternext slot,
    returning the next value.  If the iterator is exhausted,
    this returns NULL without setting an exception.
    NULL with an exception means an error occurred. */

/*  Number Protocol:*/

     @NoException public static native int PyNumber_Check(PyObject o);

       /*
     Returns 1 if the object, o, provides numeric protocols, and
     false otherwise.

     This function always succeeds.
       */

     @NoException public static native PyObject PyNumber_Add(PyObject o1, PyObject o2);

       /*
     Returns the result of adding o1 and o2, or null on failure.
     This is the equivalent of the Python expression: o1+o2.
       */

     @NoException public static native PyObject PyNumber_Subtract(PyObject o1, PyObject o2);

       /*
     Returns the result of subtracting o2 from o1, or null on
     failure.  This is the equivalent of the Python expression:
     o1-o2.
       */

     @NoException public static native PyObject PyNumber_Multiply(PyObject o1, PyObject o2);

       /*
     Returns the result of multiplying o1 and o2, or null on
     failure.  This is the equivalent of the Python expression:
     o1*o2.
       */

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
     @NoException public static native PyObject PyNumber_MatrixMultiply(PyObject o1, PyObject o2);

       /*
     This is the equivalent of the Python expression: o1 @ o2.
       */
// #endif

     @NoException public static native PyObject PyNumber_FloorDivide(PyObject o1, PyObject o2);

       /*
     Returns the result of dividing o1 by o2 giving an integral result,
     or null on failure.
     This is the equivalent of the Python expression: o1//o2.
       */

     @NoException public static native PyObject PyNumber_TrueDivide(PyObject o1, PyObject o2);

       /*
     Returns the result of dividing o1 by o2 giving a float result,
     or null on failure.
     This is the equivalent of the Python expression: o1/o2.
       */

     @NoException public static native PyObject PyNumber_Remainder(PyObject o1, PyObject o2);

       /*
     Returns the remainder of dividing o1 by o2, or null on
     failure.  This is the equivalent of the Python expression:
     o1%o2.
       */

     @NoException public static native PyObject PyNumber_Divmod(PyObject o1, PyObject o2);

       /*
     See the built-in function divmod.  Returns NULL on failure.
     This is the equivalent of the Python expression:
     divmod(o1,o2).
       */

     @NoException public static native PyObject PyNumber_Power(PyObject o1, PyObject o2,
                                                PyObject o3);

       /*
     See the built-in function pow.  Returns NULL on failure.
     This is the equivalent of the Python expression:
     pow(o1,o2,o3), where o3 is optional.
       */

     @NoException public static native PyObject PyNumber_Negative(PyObject o);

       /*
     Returns the negation of o on success, or null on failure.
     This is the equivalent of the Python expression: -o.
       */

     @NoException public static native PyObject PyNumber_Positive(PyObject o);

       /*
     Returns the (what?) of o on success, or NULL on failure.
     This is the equivalent of the Python expression: +o.
       */

     @NoException public static native PyObject PyNumber_Absolute(PyObject o);

       /*
     Returns the absolute value of o, or null on failure.  This is
     the equivalent of the Python expression: abs(o).
       */

     @NoException public static native PyObject PyNumber_Invert(PyObject o);

       /*
     Returns the bitwise negation of o on success, or NULL on
     failure.  This is the equivalent of the Python expression:
     ~o.
       */

     @NoException public static native PyObject PyNumber_Lshift(PyObject o1, PyObject o2);

       /*
     Returns the result of left shifting o1 by o2 on success, or
     NULL on failure.  This is the equivalent of the Python
     expression: o1 << o2.
       */

     @NoException public static native PyObject PyNumber_Rshift(PyObject o1, PyObject o2);

       /*
     Returns the result of right shifting o1 by o2 on success, or
     NULL on failure.  This is the equivalent of the Python
     expression: o1 >> o2.
       */

     @NoException public static native PyObject PyNumber_And(PyObject o1, PyObject o2);

       /*
     Returns the result of bitwise and of o1 and o2 on success, or
     NULL on failure. This is the equivalent of the Python
     expression: o1&o2.

       */

     @NoException public static native PyObject PyNumber_Xor(PyObject o1, PyObject o2);

       /*
     Returns the bitwise exclusive or of o1 by o2 on success, or
     NULL on failure.  This is the equivalent of the Python
     expression: o1^o2.
       */

     @NoException public static native PyObject PyNumber_Or(PyObject o1, PyObject o2);

       /*
     Returns the result of bitwise or on o1 and o2 on success, or
     NULL on failure.  This is the equivalent of the Python
     expression: o1|o2.
       */

// #define PyIndex_Check(obj)
//    ((obj)->ob_type->tp_as_number != NULL &&
//     (obj)->ob_type->tp_as_number->nb_index != NULL)

     @NoException public static native PyObject PyNumber_Index(PyObject o);

       /*
     Returns the object converted to a Python int
     or NULL with an error raised on failure.
       */

     @NoException public static native @Cast("Py_ssize_t") long PyNumber_AsSsize_t(PyObject o, PyObject exc);

       /*
    Returns the object converted to Py_ssize_t by going through
    PyNumber_Index first.  If an overflow error occurs while
    converting the int to Py_ssize_t, then the second argument
    is the error-type to return.  If it is NULL, then the overflow error
    is cleared and the value is clipped.
       */

     @NoException public static native PyObject PyNumber_Long(PyObject o);

       /*
     Returns the o converted to an integer object on success, or
     NULL on failure.  This is the equivalent of the Python
     expression: int(o).
       */

     @NoException public static native PyObject PyNumber_Float(PyObject o);

       /*
     Returns the o converted to a float object on success, or NULL
     on failure.  This is the equivalent of the Python expression:
     float(o).
       */

/*  In-place variants of (some of) the above number protocol functions */

     @NoException public static native PyObject PyNumber_InPlaceAdd(PyObject o1, PyObject o2);

       /*
     Returns the result of adding o2 to o1, possibly in-place, or null
     on failure.  This is the equivalent of the Python expression:
     o1 += o2.
       */

     @NoException public static native PyObject PyNumber_InPlaceSubtract(PyObject o1, PyObject o2);

       /*
     Returns the result of subtracting o2 from o1, possibly in-place or
     null on failure.  This is the equivalent of the Python expression:
     o1 -= o2.
       */

     @NoException public static native PyObject PyNumber_InPlaceMultiply(PyObject o1, PyObject o2);

       /*
     Returns the result of multiplying o1 by o2, possibly in-place, or
     null on failure.  This is the equivalent of the Python expression:
     o1 *= o2.
       */

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
     @NoException public static native PyObject PyNumber_InPlaceMatrixMultiply(PyObject o1, PyObject o2);

       /*
     This is the equivalent of the Python expression: o1 @= o2.
       */
// #endif

     @NoException public static native PyObject PyNumber_InPlaceFloorDivide(PyObject o1,
                                                             PyObject o2);

       /*
     Returns the result of dividing o1 by o2 giving an integral result,
     possibly in-place, or null on failure.
     This is the equivalent of the Python expression:
     o1 /= o2.
       */

     @NoException public static native PyObject PyNumber_InPlaceTrueDivide(PyObject o1,
                                                            PyObject o2);

       /*
     Returns the result of dividing o1 by o2 giving a float result,
     possibly in-place, or null on failure.
     This is the equivalent of the Python expression:
     o1 /= o2.
       */

     @NoException public static native PyObject PyNumber_InPlaceRemainder(PyObject o1, PyObject o2);

       /*
     Returns the remainder of dividing o1 by o2, possibly in-place, or
     null on failure.  This is the equivalent of the Python expression:
     o1 %= o2.
       */

     @NoException public static native PyObject PyNumber_InPlacePower(PyObject o1, PyObject o2,
                                                       PyObject o3);

       /*
     Returns the result of raising o1 to the power of o2, possibly
     in-place, or null on failure.  This is the equivalent of the Python
     expression: o1 **= o2, or pow(o1, o2, o3) if o3 is present.
       */

     @NoException public static native PyObject PyNumber_InPlaceLshift(PyObject o1, PyObject o2);

       /*
     Returns the result of left shifting o1 by o2, possibly in-place, or
     null on failure.  This is the equivalent of the Python expression:
     o1 <<= o2.
       */

     @NoException public static native PyObject PyNumber_InPlaceRshift(PyObject o1, PyObject o2);

       /*
     Returns the result of right shifting o1 by o2, possibly in-place or
     null on failure.  This is the equivalent of the Python expression:
     o1 >>= o2.
       */

     @NoException public static native PyObject PyNumber_InPlaceAnd(PyObject o1, PyObject o2);

       /*
     Returns the result of bitwise and of o1 and o2, possibly in-place,
     or null on failure. This is the equivalent of the Python
     expression: o1 &= o2.
       */

     @NoException public static native PyObject PyNumber_InPlaceXor(PyObject o1, PyObject o2);

       /*
     Returns the bitwise exclusive or of o1 by o2, possibly in-place, or
     null on failure.  This is the equivalent of the Python expression:
     o1 ^= o2.
       */

     @NoException public static native PyObject PyNumber_InPlaceOr(PyObject o1, PyObject o2);

       /*
     Returns the result of bitwise or of o1 and o2, possibly in-place,
     or null on failure.  This is the equivalent of the Python
     expression: o1 |= o2.
       */

     @NoException public static native PyObject PyNumber_ToBase(PyObject n, int base);

       /*
     Returns the integer n converted to a string with a base, with a base
     marker of 0b, 0o or 0x prefixed if applicable.
     If n is not an int object, it is converted with PyNumber_Index first.
       */


/*  Sequence protocol:*/

     @NoException public static native int PySequence_Check(PyObject o);

       /*
     Return 1 if the object provides sequence protocol, and zero
     otherwise.

     This function always succeeds.
       */

     @NoException public static native @Cast("Py_ssize_t") long PySequence_Size(PyObject o);

       /*
     Return the size of sequence object o, or -1 on failure.
       */

       /* For DLL compatibility */
// #undef PySequence_Length
// #define PySequence_Length PySequence_Size


     @NoException public static native PyObject PySequence_Concat(PyObject o1, PyObject o2);

       /*
     Return the concatenation of o1 and o2 on success, and NULL on
     failure.   This is the equivalent of the Python
     expression: o1+o2.
       */

     @NoException public static native PyObject PySequence_Repeat(PyObject o, @Cast("Py_ssize_t") long count);

       /*
     Return the result of repeating sequence object o count times,
     or NULL on failure.  This is the equivalent of the Python
     expression: o1*count.
       */

     @NoException public static native PyObject PySequence_GetItem(PyObject o, @Cast("Py_ssize_t") long i);

       /*
     Return the ith element of o, or NULL on failure. This is the
     equivalent of the Python expression: o[i].
       */

     @NoException public static native PyObject PySequence_GetSlice(PyObject o, @Cast("Py_ssize_t") long i1, @Cast("Py_ssize_t") long i2);

       /*
     Return the slice of sequence object o between i1 and i2, or
     NULL on failure. This is the equivalent of the Python
     expression: o[i1:i2].
       */

     @NoException public static native int PySequence_SetItem(PyObject o, @Cast("Py_ssize_t") long i, PyObject v);

       /*
     Assign object v to the ith element of o.  Raise an exception and return
     -1 on failure; return 0 on success.  This is the equivalent of the
     Python statement o[i]=v.
       */

     @NoException public static native int PySequence_DelItem(PyObject o, @Cast("Py_ssize_t") long i);

       /*
     Delete the ith element of object v.  Returns
     -1 on failure.  This is the equivalent of the Python
     statement: del o[i].
       */

     @NoException public static native int PySequence_SetSlice(PyObject o, @Cast("Py_ssize_t") long i1, @Cast("Py_ssize_t") long i2,
                                              PyObject v);

       /*
     Assign the sequence object, v, to the slice in sequence
     object, o, from i1 to i2.  Returns -1 on failure. This is the
     equivalent of the Python statement: o[i1:i2]=v.
       */

     @NoException public static native int PySequence_DelSlice(PyObject o, @Cast("Py_ssize_t") long i1, @Cast("Py_ssize_t") long i2);

       /*
     Delete the slice in sequence object, o, from i1 to i2.
     Returns -1 on failure. This is the equivalent of the Python
     statement: del o[i1:i2].
       */

     @NoException public static native PyObject PySequence_Tuple(PyObject o);

       /*
     Returns the sequence, o, as a tuple on success, and NULL on failure.
     This is equivalent to the Python expression: tuple(o)
       */


     @NoException public static native PyObject PySequence_List(PyObject o);
       /*
     Returns the sequence, o, as a list on success, and NULL on failure.
     This is equivalent to the Python expression: list(o)
       */

     @NoException public static native PyObject PySequence_Fast(PyObject o, @Cast("const char*") BytePointer m);
     @NoException public static native PyObject PySequence_Fast(PyObject o, String m);
       /*
     Return the sequence, o, as a list, unless it's already a
     tuple or list.  Use PySequence_Fast_GET_ITEM to access the
     members of this list, and PySequence_Fast_GET_SIZE to get its length.

     Returns NULL on failure.  If the object does not support iteration,
     raises a TypeError exception with m as the message text.
       */

// #define PySequence_Fast_GET_SIZE(o)
//     (PyList_Check(o) ? PyList_GET_SIZE(o) : PyTuple_GET_SIZE(o))
       /*
     Return the size of o, assuming that o was returned by
     PySequence_Fast and is not NULL.
       */

// #define PySequence_Fast_GET_ITEM(o, i)
//      (PyList_Check(o) ? PyList_GET_ITEM(o, i) : PyTuple_GET_ITEM(o, i))
       /*
     Return the ith element of o, assuming that o was returned by
     PySequence_Fast, and that i is within bounds.
       */

// #define PySequence_ITEM(o, i)
//     ( Py_TYPE(o)->tp_as_sequence->sq_item(o, i) )
       /* Assume tp_as_sequence and sq_item exist and that i does not
      need to be corrected for a negative index
       */

// #define PySequence_Fast_ITEMS(sf)
//     (PyList_Check(sf) ? ((PyListObject *)(sf))->ob_item
//                       : ((PyTupleObject *)(sf))->ob_item)
    /* Return a pointer to the underlying item array for
       an object retured by PySequence_Fast */

     @NoException public static native @Cast("Py_ssize_t") long PySequence_Count(PyObject o, PyObject value);

       /*
     Return the number of occurrences on value on o, that is,
     return the number of keys for which o[key]==value.  On
     failure, return -1.  This is equivalent to the Python
     expression: o.count(value).
       */

     @NoException public static native int PySequence_Contains(PyObject seq, PyObject ob);
       /*
     Return -1 if error; 1 if ob in seq; 0 if ob not in seq.
     Use __contains__ if possible, else _PySequence_IterSearch().
       */

// #ifndef Py_LIMITED_API
public static final int PY_ITERSEARCH_COUNT =    1;
public static final int PY_ITERSEARCH_INDEX =    2;
public static final int PY_ITERSEARCH_CONTAINS = 3;
     @NoException public static native @Cast("Py_ssize_t") long _PySequence_IterSearch(PyObject seq,
                                             PyObject obj, int operation);
// #endif
    /*
      Iterate over seq.  Result depends on the operation:
      PY_ITERSEARCH_COUNT:  return # of times obj appears in seq; -1 if
        error.
      PY_ITERSEARCH_INDEX:  return 0-based index of first occurrence of
        obj in seq; set ValueError and return -1 if none found;
        also return -1 on error.
      PY_ITERSEARCH_CONTAINS:  return 1 if obj in seq, else 0; -1 on
        error.
    */

/* For DLL-level backwards compatibility */
// #undef PySequence_In

/* For source-level backwards compatibility */
// #define PySequence_In PySequence_Contains

       /*
     Determine if o contains value.  If an item in o is equal to
     X, return 1, otherwise return 0.  On error, return -1.  This
     is equivalent to the Python expression: value in o.
       */

     @NoException public static native @Cast("Py_ssize_t") long PySequence_Index(PyObject o, PyObject value);

       /*
     Return the first index for which o[i]=value.  On error,
     return -1.    This is equivalent to the Python
     expression: o.index(value).
       */

/* In-place versions of some of the above Sequence functions. */

     @NoException public static native PyObject PySequence_InPlaceConcat(PyObject o1, PyObject o2);

       /*
     Append o2 to o1, in-place when possible. Return the resulting
     object, which could be o1, or NULL on failure.  This is the
     equivalent of the Python expression: o1 += o2.

       */

     @NoException public static native PyObject PySequence_InPlaceRepeat(PyObject o, @Cast("Py_ssize_t") long count);

       /*
     Repeat o1 by count, in-place when possible. Return the resulting
     object, which could be o1, or NULL on failure.  This is the
     equivalent of the Python expression: o1 *= count.

       */

/*  Mapping protocol:*/

     @NoException public static native int PyMapping_Check(PyObject o);

       /*
     Return 1 if the object provides mapping protocol, and zero
     otherwise.

     This function always succeeds.
       */

     @NoException public static native @Cast("Py_ssize_t") long PyMapping_Size(PyObject o);

       /*
     Returns the number of keys in object o on success, and -1 on
     failure.  For objects that do not provide sequence protocol,
     this is equivalent to the Python expression: len(o).
       */

       /* For DLL compatibility */
// #undef PyMapping_Length
// #define PyMapping_Length PyMapping_Size


     /* implemented as a macro:

     int PyMapping_DelItemString(PyObject *o, const char *key);

     Remove the mapping for object, key, from the object *o.
     Returns -1 on failure.  This is equivalent to
     the Python statement: del o[key].
       */
// #define PyMapping_DelItemString(O,K) PyObject_DelItemString((O),(K))

     /* implemented as a macro:

     int PyMapping_DelItem(PyObject *o, PyObject *key);

     Remove the mapping for object, key, from the object *o.
     Returns -1 on failure.  This is equivalent to
     the Python statement: del o[key].
       */
// #define PyMapping_DelItem(O,K) PyObject_DelItem((O),(K))

     @NoException public static native int PyMapping_HasKeyString(PyObject o, @Cast("const char*") BytePointer key);
     @NoException public static native int PyMapping_HasKeyString(PyObject o, String key);

       /*
     On success, return 1 if the mapping object has the key, key,
     and 0 otherwise.  This is equivalent to the Python expression:
     key in o.

     This function always succeeds.
       */

     @NoException public static native int PyMapping_HasKey(PyObject o, PyObject key);

       /*
     Return 1 if the mapping object has the key, key,
     and 0 otherwise.  This is equivalent to the Python expression:
     key in o.

     This function always succeeds.

       */

     @NoException public static native PyObject PyMapping_Keys(PyObject o);

       /*
     On success, return a list or tuple of the keys in object o.
     On failure, return NULL.
       */

     @NoException public static native PyObject PyMapping_Values(PyObject o);

       /*
     On success, return a list or tuple of the values in object o.
     On failure, return NULL.
       */

     @NoException public static native PyObject PyMapping_Items(PyObject o);

       /*
     On success, return a list or tuple of the items in object o,
     where each item is a tuple containing a key-value pair.
     On failure, return NULL.

       */

     @NoException public static native PyObject PyMapping_GetItemString(PyObject o,
                                                         @Cast("const char*") BytePointer key);
     @NoException public static native PyObject PyMapping_GetItemString(PyObject o,
                                                         String key);

       /*
     Return element of o corresponding to the object, key, or NULL
     on failure. This is the equivalent of the Python expression:
     o[key].
       */

     @NoException public static native int PyMapping_SetItemString(PyObject o, @Cast("const char*") BytePointer key,
                                                 PyObject value);
     @NoException public static native int PyMapping_SetItemString(PyObject o, String key,
                                                 PyObject value);

       /*
     Map the object, key, to the value, v.  Returns
     -1 on failure.  This is the equivalent of the Python
     statement: o[key]=v.
      */


@NoException public static native int PyObject_IsInstance(PyObject object, PyObject typeorclass);
      /* isinstance(object, typeorclass) */

@NoException public static native int PyObject_IsSubclass(PyObject object, PyObject typeorclass);
      /* issubclass(object, typeorclass) */


// #ifndef Py_LIMITED_API
@NoException public static native int _PyObject_RealIsInstance(PyObject inst, PyObject cls);

@NoException public static native int _PyObject_RealIsSubclass(PyObject derived, PyObject cls);

@NoException public static native @Cast("char*const*") PointerPointer _PySequence_BytesToCharpArray(PyObject self);

@NoException public static native void _Py_FreeCharPArray(@Cast("char*const*") PointerPointer array);
@NoException public static native void _Py_FreeCharPArray(@Cast("char*const*") @ByPtrPtr BytePointer array);
@NoException public static native void _Py_FreeCharPArray(@Cast("char*const*") @ByPtrPtr ByteBuffer array);
@NoException public static native void _Py_FreeCharPArray(@Cast("char*const*") @ByPtrPtr byte[] array);

/* For internal use by buffer API functions */
@NoException public static native void _Py_add_one_to_index_F(int nd, @Cast("Py_ssize_t*") SizeTPointer index,
                                        @Cast("const Py_ssize_t*") SizeTPointer shape);
@NoException public static native void _Py_add_one_to_index_C(int nd, @Cast("Py_ssize_t*") SizeTPointer index,
                                        @Cast("const Py_ssize_t*") SizeTPointer shape);
// #endif /* !Py_LIMITED_API */


// #ifdef __cplusplus
// #endif
// #endif /* Py_ABSTRACTOBJECT_H */


// Parsed from bltinmodule.h

// #ifndef Py_BLTINMODULE_H
// #define Py_BLTINMODULE_H
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyFilter_Type(); public static native void PyFilter_Type(PyTypeObject PyFilter_Type);
public static native @ByRef PyTypeObject PyMap_Type(); public static native void PyMap_Type(PyTypeObject PyMap_Type);
public static native @ByRef PyTypeObject PyZip_Type(); public static native void PyZip_Type(PyTypeObject PyZip_Type);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_BLTINMODULE_H */


// Parsed from asdl.h

// #ifndef Py_ASDL_H
// #define Py_ASDL_H
// Targeting ../python/asdl_seq.java


// Targeting ../python/asdl_int_seq.java






// #define asdl_seq_GET(S, I) (S)->elements[(I)]
// #define asdl_seq_LEN(S) ((S) == NULL ? 0 : (S)->size)
// #ifdef Py_DEBUG
// #else
// #define asdl_seq_SET(S, I, V) (S)->elements[I] = (V)
// #endif

// #endif /* !Py_ASDL_H */


// Parsed from Python-ast.h

/* File automatically generated by Parser/asdl_c.py. */

// #include "asdl.h"

/** enum _expr_context */
public static final int Load = 1, Store = 2, Del = 3, AugLoad = 4, AugStore = 5,
                             Param = 6;

/** enum _boolop */
public static final int And = 1, Or = 2;

/** enum _operator */
public static final int Add = 1, Sub = 2, Mult = 3, MatMult = 4, Div = 5, Mod = 6, Pow = 7,
                         LShift = 8, RShift = 9, BitOr = 10, BitXor = 11, BitAnd = 12,
                         FloorDiv = 13;

/** enum _unaryop */
public static final int Invert = 1, Not = 2, UAdd = 3, USub = 4;

/** enum _cmpop */
public static final int Eq = 1, NotEq = 2, Lt = 3, LtE = 4, Gt = 5, GtE = 6, Is = 7, IsNot = 8,
                      In = 9, NotIn = 10;


/** enum _mod_kind */
public static final int Module_kind = 1, Interactive_kind = 2, Expression_kind = 3,
                 Suite_kind = 4;
// Targeting ../python/_mod.java



/** enum _stmt_kind */
public static final int FunctionDef_kind = 1, AsyncFunctionDef_kind = 2, ClassDef_kind = 3,
                  Return_kind = 4, Delete_kind = 5, Assign_kind = 6,
                  AugAssign_kind = 7, AnnAssign_kind = 8, For_kind = 9,
                  AsyncFor_kind = 10, While_kind = 11, If_kind = 12, With_kind = 13,
                  AsyncWith_kind = 14, Raise_kind = 15, Try_kind = 16,
                  Assert_kind = 17, Import_kind = 18, ImportFrom_kind = 19,
                  Global_kind = 20, Nonlocal_kind = 21, Expr_kind = 22, Pass_kind = 23,
                  Break_kind = 24, Continue_kind = 25;
// Targeting ../python/_stmt.java



/** enum _expr_kind */
public static final int BoolOp_kind = 1, BinOp_kind = 2, UnaryOp_kind = 3, Lambda_kind = 4,
                  IfExp_kind = 5, Dict_kind = 6, Set_kind = 7, ListComp_kind = 8,
                  SetComp_kind = 9, DictComp_kind = 10, GeneratorExp_kind = 11,
                  Await_kind = 12, Yield_kind = 13, YieldFrom_kind = 14,
                  Compare_kind = 15, Call_kind = 16, Num_kind = 17, Str_kind = 18,
                  FormattedValue_kind = 19, JoinedStr_kind = 20, Bytes_kind = 21,
                  NameConstant_kind = 22, Ellipsis_kind = 23, Constant_kind = 24,
                  Attribute_kind = 25, Subscript_kind = 26, Starred_kind = 27,
                  Name_kind = 28, List_kind = 29, Tuple_kind = 30;
// Targeting ../python/_expr.java



/** enum _slice_kind */
public static final int Slice_kind = 1, ExtSlice_kind = 2, Index_kind = 3;
// Targeting ../python/_slice.java


// Targeting ../python/_comprehension.java



/** enum _excepthandler_kind */
public static final int ExceptHandler_kind = 1;
// Targeting ../python/_excepthandler.java


// Targeting ../python/_arguments.java


// Targeting ../python/_arg.java


// Targeting ../python/_keyword.java


// Targeting ../python/_alias.java


// Targeting ../python/_withitem.java






// Parsed from node.h


/* Parse tree node interface */

// #ifndef Py_NODE_H
// #define Py_NODE_H
// #ifdef __cplusplus
// Targeting ../python/node.java



@NoException public static native node PyNode_New(int type);
@NoException public static native int PyNode_AddChild(node n, int type,
                                      @Cast("char*") BytePointer str, int lineno, int col_offset);
@NoException public static native int PyNode_AddChild(node n, int type,
                                      @Cast("char*") ByteBuffer str, int lineno, int col_offset);
@NoException public static native int PyNode_AddChild(node n, int type,
                                      @Cast("char*") byte[] str, int lineno, int col_offset);
@NoException public static native void PyNode_Free(node n);
// #ifndef Py_LIMITED_API
@NoException public static native @Cast("Py_ssize_t") long _PyNode_SizeOf(node n);
// #endif

/* Node access functions */
// #define NCH(n)		((n)->n_nchildren)

// #define CHILD(n, i)	(&(n)->n_child[i])
// #define RCHILD(n, i)	(CHILD(n, NCH(n) + i))
// #define TYPE(n)		((n)->n_type)
// #define STR(n)		((n)->n_str)
// #define LINENO(n)       ((n)->n_lineno)

/* Assert that the type of a node is what we expect */
// #define REQ(n, type) assert(TYPE(n) == (type))

@NoException public static native void PyNode_ListTree(node arg0);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_NODE_H */


// Parsed from code.h

/* Definitions for bytecode */

// #ifndef Py_LIMITED_API
// #ifndef Py_CODE_H
// #define Py_CODE_H
// #ifdef __cplusplus
// #endif

// #ifdef WORDS_BIGENDIAN
// #  define _Py_OPCODE(word) ((word) >> 8)
// #  define _Py_OPARG(word) ((word) & 255)
// Targeting ../python/PyCodeObject.java



/* Masks for co_flags above */
public static final int CO_OPTIMIZED =	0x0001;
public static final int CO_NEWLOCALS =	0x0002;
public static final int CO_VARARGS =	0x0004;
public static final int CO_VARKEYWORDS =	0x0008;
public static final int CO_NESTED =       0x0010;
public static final int CO_GENERATOR =    0x0020;
/* The CO_NOFREE flag is set if there are no free or cell variables.
   This information is redundant, but it allows a single flag test
   to determine whether there is any extra work to be done when the
   call frame it setup.
*/
public static final int CO_NOFREE =       0x0040;

/* The CO_COROUTINE flag is set for coroutine functions (defined with
   ``async def`` keywords) */
public static final int CO_COROUTINE =            0x0080;
public static final int CO_ITERABLE_COROUTINE =   0x0100;
public static final int CO_ASYNC_GENERATOR =      0x0200;

/* These are no longer used. */
// #if 0
// #endif
public static final int CO_FUTURE_DIVISION =    	0x2000;
public static final int CO_FUTURE_ABSOLUTE_IMPORT = 0x4000; /* do absolute imports by default */
public static final int CO_FUTURE_WITH_STATEMENT =  0x8000;
public static final int CO_FUTURE_PRINT_FUNCTION =  0x10000;
public static final int CO_FUTURE_UNICODE_LITERALS = 0x20000;

public static final int CO_FUTURE_BARRY_AS_BDFL =  0x40000;
public static final int CO_FUTURE_GENERATOR_STOP =  0x80000;

/* This value is found in the co_cell2arg array when the associated cell
   variable does not correspond to an argument. The maximum number of
   arguments is 255 (indexed up to 254), so 255 work as a special flag.*/
public static final int CO_CELL_NOT_AN_ARG = 255;

/* This should be defined if a future statement modifies the syntax.
   For example, when a keyword is added.
*/
// #define PY_PARSER_REQUIRES_FUTURE_KEYWORD

public static final int CO_MAXBLOCKS = 20; /* Max static block nesting within a function */

public static native @ByRef PyTypeObject PyCode_Type(); public static native void PyCode_Type(PyTypeObject PyCode_Type);

// #define PyCode_Check(op) (Py_TYPE(op) == &PyCode_Type)
// #define PyCode_GetNumFree(op) (PyTuple_GET_SIZE((op)->co_freevars))

/* Public interface */
@NoException public static native PyCodeObject PyCode_New(
	int arg0, int arg1, int arg2, int arg3, int arg4, PyObject arg5, PyObject arg6,
	PyObject arg7, PyObject arg8, PyObject arg9, PyObject arg10,
	PyObject arg11, PyObject arg12, int arg13, PyObject arg14);
        /* same as struct above */

/* Creates a new empty code object with the specified source location. */
@NoException public static native PyCodeObject PyCode_NewEmpty(@Cast("const char*") BytePointer filename, @Cast("const char*") BytePointer funcname, int firstlineno);
@NoException public static native PyCodeObject PyCode_NewEmpty(String filename, String funcname, int firstlineno);

/* Return the line number associated with the specified bytecode index
   in this code object.  If you just need the line number of a frame,
   use PyFrame_GetLineNumber() instead. */
@NoException public static native int PyCode_Addr2Line(PyCodeObject arg0, int arg1);
// Targeting ../python/PyAddrPair.java



// #ifndef Py_LIMITED_API
/* Update *bounds to describe the first and one-past-the-last instructions in the
   same line as lasti.  Return the number of that line.
*/
@NoException public static native int _PyCode_CheckLineNumber(PyCodeObject co,
                                        int lasti, PyAddrPair bounds);

/* Create a comparable key used to compare constants taking in account the
 * object type. It is used to make sure types are not coerced (e.g., float and
 * complex) _and_ to distinguish 0.0 from -0.0 e.g. on IEEE platforms
 *
 * Return (type(obj), obj, ...): a tuple with variable size (at least 2 items)
 * depending on the type and the value. The type is the first item to not
 * compare bytes and str which can raise a BytesWarning exception. */
@NoException public static native PyObject _PyCode_ConstantKey(PyObject obj);
// #endif

@NoException public static native PyObject PyCode_Optimize(PyObject code, PyObject consts,
                                      PyObject names, PyObject lnotab);


// #ifndef Py_LIMITED_API
@NoException public static native int _PyCode_GetExtra(PyObject code, @Cast("Py_ssize_t") long index,
                                 @Cast("void**") PointerPointer extra);
@NoException public static native int _PyCode_GetExtra(PyObject code, @Cast("Py_ssize_t") long index,
                                 @Cast("void**") @ByPtrPtr Pointer extra);
@NoException public static native int _PyCode_SetExtra(PyObject code, @Cast("Py_ssize_t") long index,
                                 Pointer extra);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_CODE_H */
// #endif /* Py_LIMITED_API */


// Parsed from compile.h

// #ifndef Py_COMPILE_H
// #define Py_COMPILE_H

// #ifndef Py_LIMITED_API
// #include "code.h"

// #ifdef __cplusplus
// #endif

/* Public interface */ /* Declare the existence of this type */
@NoException public static native PyCodeObject PyNode_Compile(@Cast("_node*") node arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native PyCodeObject PyNode_Compile(@Cast("_node*") node arg0, String arg1);
// Targeting ../python/PyFutureFeatures.java



public static final String FUTURE_NESTED_SCOPES = "nested_scopes";
public static final String FUTURE_GENERATORS = "generators";
public static final String FUTURE_DIVISION = "division";
public static final String FUTURE_ABSOLUTE_IMPORT = "absolute_import";
public static final String FUTURE_WITH_STATEMENT = "with_statement";
public static final String FUTURE_PRINT_FUNCTION = "print_function";
public static final String FUTURE_UNICODE_LITERALS = "unicode_literals";
public static final String FUTURE_BARRY_AS_BDFL = "barry_as_FLUFL";
public static final String FUTURE_GENERATOR_STOP = "generator_stop"; /* Declare the existence of this type */
// #define PyAST_Compile(mod, s, f, ar) PyAST_CompileEx(mod, s, f, -1, ar)
@NoException public static native PyCodeObject PyAST_CompileEx(
    _mod mod,
    @Cast("const char*") BytePointer filename,
    PyCompilerFlags flags,
    int optimize,
    PyArena arena);
@NoException public static native PyCodeObject PyAST_CompileEx(
    _mod mod,
    String filename,
    PyCompilerFlags flags,
    int optimize,
    PyArena arena);
@NoException public static native PyCodeObject PyAST_CompileObject(
    _mod mod,
    PyObject filename,
    PyCompilerFlags flags,
    int optimize,
    PyArena arena);
@NoException public static native PyFutureFeatures PyFuture_FromAST(
    _mod mod,
    @Cast("const char*") BytePointer filename
    );
@NoException public static native PyFutureFeatures PyFuture_FromAST(
    _mod mod,
    String filename
    );
@NoException public static native PyFutureFeatures PyFuture_FromASTObject(
    _mod mod,
    PyObject filename
    );

/* _Py_Mangle is defined in compile.c */
@NoException public static native PyObject _Py_Mangle(PyObject p, PyObject name);

public static final int PY_INVALID_STACK_EFFECT = INT_MAX;
@NoException public static native int PyCompile_OpcodeStackEffect(int opcode, int oparg);

// #ifdef __cplusplus
// #endif

// #endif /* !Py_LIMITED_API */

/* These definitions must match corresponding definitions in graminit.h.
   There's code in compile.c that checks that they are the same. */
public static final int Py_single_input = 256;
public static final int Py_file_input = 257;
public static final int Py_eval_input = 258;

// #endif /* !Py_COMPILE_H */


// Parsed from symtable.h

// #ifndef Py_LIMITED_API
// #ifndef Py_SYMTABLE_H
// #define Py_SYMTABLE_H

// #ifdef __cplusplus
// #endif

/* XXX(ncoghlan): This is a weird mix of public names and interpreter internal
 *                names.
 */

/** enum _block_type */
public static final int FunctionBlock = 0, ClassBlock = 1, ModuleBlock = 2;
// Targeting ../python/_symtable_entry.java


// Targeting ../python/symtable.java


// Targeting ../python/PySTEntryObject.java



public static native @ByRef PyTypeObject PySTEntry_Type(); public static native void PySTEntry_Type(PyTypeObject PySTEntry_Type);

// #define PySTEntry_Check(op) (Py_TYPE(op) == &PySTEntry_Type)

@NoException public static native int PyST_GetScope(PySTEntryObject arg0, PyObject arg1);

@NoException public static native symtable PySymtable_Build(
    _mod mod,
    @Cast("const char*") BytePointer filename,
    PyFutureFeatures future);
@NoException public static native symtable PySymtable_Build(
    _mod mod,
    String filename,
    PyFutureFeatures future);
@NoException public static native symtable PySymtable_BuildObject(
    _mod mod,
    PyObject filename,
    PyFutureFeatures future);
@NoException public static native PySTEntryObject PySymtable_Lookup(symtable arg0, Pointer arg1);

@NoException public static native void PySymtable_Free(symtable arg0);

/* Flags for def-use information */

public static final int DEF_GLOBAL = 1;           /* global stmt */
public static final int DEF_LOCAL = 2;            /* assignment in code block */
public static final int DEF_PARAM = 2<<1;         /* formal parameter */
public static final int DEF_NONLOCAL = 2<<2;      /* nonlocal stmt */
public static final int USE = 2<<3;               /* name is used */
public static final int DEF_FREE = 2<<4;          /* name used but not defined in nested block */
public static final int DEF_FREE_CLASS = 2<<5;    /* free variable from class's method */
public static final int DEF_IMPORT = 2<<6;        /* assignment occurred via import */
public static final int DEF_ANNOT = 2<<7;         /* this name is annotated */

public static final int DEF_BOUND = (DEF_LOCAL | DEF_PARAM | DEF_IMPORT);

/* GLOBAL_EXPLICIT and GLOBAL_IMPLICIT are used internally by the symbol
   table.  GLOBAL is returned from PyST_GetScope() for either of them.
   It is stored in ste_symbols at bits 12-15.
*/
public static final int SCOPE_OFFSET = 11;
public static final int SCOPE_MASK = (DEF_GLOBAL | DEF_LOCAL | DEF_PARAM | DEF_NONLOCAL);

public static final int LOCAL = 1;
public static final int GLOBAL_EXPLICIT = 2;
public static final int GLOBAL_IMPLICIT = 3;
public static final int FREE = 4;
public static final int CELL = 5;

public static final int GENERATOR = 1;
public static final int GENERATOR_EXPRESSION = 2;

// #ifdef __cplusplus
// #endif
// #endif /* !Py_SYMTABLE_H */
// #endif /* Py_LIMITED_API */


// Parsed from pythonrun.h


/* Interfaces to parse and execute pieces of python code */

// #ifndef Py_PYTHONRUN_H
// #define Py_PYTHONRUN_H
// #ifdef __cplusplus
// #endif

public static final int PyCF_MASK = (CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | 
                   CO_FUTURE_WITH_STATEMENT | CO_FUTURE_PRINT_FUNCTION | 
                   CO_FUTURE_UNICODE_LITERALS | CO_FUTURE_BARRY_AS_BDFL | 
                   CO_FUTURE_GENERATOR_STOP);
public static final int PyCF_MASK_OBSOLETE = (CO_NESTED);
public static final int PyCF_SOURCE_IS_UTF8 =  0x0100;
public static final int PyCF_DONT_IMPLY_DEDENT = 0x0200;
public static final int PyCF_ONLY_AST = 0x0400;
public static final int PyCF_IGNORE_COOKIE = 0x0800;
// Targeting ../python/PyCompilerFlags.java


// #endif

// #ifndef Py_LIMITED_API
@NoException public static native int PyRun_SimpleStringFlags(@Cast("const char*") BytePointer arg0, PyCompilerFlags arg1);
@NoException public static native int PyRun_SimpleStringFlags(String arg0, PyCompilerFlags arg1);
@NoException public static native int PyRun_AnyFileFlags(@Cast("FILE*") Pointer arg0, @Cast("const char*") BytePointer arg1, PyCompilerFlags arg2);
@NoException public static native int PyRun_AnyFileFlags(@Cast("FILE*") Pointer arg0, String arg1, PyCompilerFlags arg2);
@NoException public static native int PyRun_AnyFileExFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int PyRun_AnyFileExFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int PyRun_SimpleFileExFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int PyRun_SimpleFileExFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveOneFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveOneFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveOneObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveLoopFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveLoopFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    PyCompilerFlags flags);

@NoException public static native _mod PyParser_ASTFromString(
    @Cast("const char*") BytePointer s,
    @Cast("const char*") BytePointer filename,
    int start,
    PyCompilerFlags flags,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromString(
    String s,
    String filename,
    int start,
    PyCompilerFlags flags,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromStringObject(
    @Cast("const char*") BytePointer s,
    PyObject filename,
    int start,
    PyCompilerFlags flags,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromStringObject(
    String s,
    PyObject filename,
    int start,
    PyCompilerFlags flags,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFile(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    @Cast("const char*") BytePointer enc,
    int start,
    @Cast("const char*") BytePointer ps1,
    @Cast("const char*") BytePointer ps2,
    PyCompilerFlags flags,
    IntPointer errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFile(
    @Cast("FILE*") Pointer fp,
    String filename,
    String enc,
    int start,
    String ps1,
    String ps2,
    PyCompilerFlags flags,
    IntBuffer errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFile(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    @Cast("const char*") BytePointer enc,
    int start,
    @Cast("const char*") BytePointer ps1,
    @Cast("const char*") BytePointer ps2,
    PyCompilerFlags flags,
    int[] errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFile(
    @Cast("FILE*") Pointer fp,
    String filename,
    String enc,
    int start,
    String ps1,
    String ps2,
    PyCompilerFlags flags,
    IntPointer errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFile(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    @Cast("const char*") BytePointer enc,
    int start,
    @Cast("const char*") BytePointer ps1,
    @Cast("const char*") BytePointer ps2,
    PyCompilerFlags flags,
    IntBuffer errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFile(
    @Cast("FILE*") Pointer fp,
    String filename,
    String enc,
    int start,
    String ps1,
    String ps2,
    PyCompilerFlags flags,
    int[] errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFileObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    @Cast("const char*") BytePointer enc,
    int start,
    @Cast("const char*") BytePointer ps1,
    @Cast("const char*") BytePointer ps2,
    PyCompilerFlags flags,
    IntPointer errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFileObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    String enc,
    int start,
    String ps1,
    String ps2,
    PyCompilerFlags flags,
    IntBuffer errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFileObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    @Cast("const char*") BytePointer enc,
    int start,
    @Cast("const char*") BytePointer ps1,
    @Cast("const char*") BytePointer ps2,
    PyCompilerFlags flags,
    int[] errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFileObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    String enc,
    int start,
    String ps1,
    String ps2,
    PyCompilerFlags flags,
    IntPointer errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFileObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    @Cast("const char*") BytePointer enc,
    int start,
    @Cast("const char*") BytePointer ps1,
    @Cast("const char*") BytePointer ps2,
    PyCompilerFlags flags,
    IntBuffer errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFileObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    String enc,
    int start,
    String ps1,
    String ps2,
    PyCompilerFlags flags,
    int[] errcode,
    PyArena arena);
// #endif

// #ifndef PyParser_SimpleParseString
// #define PyParser_SimpleParseString(S, B)
//     PyParser_SimpleParseStringFlags(S, B, 0)
// #define PyParser_SimpleParseFile(FP, S, B)
//     PyParser_SimpleParseFileFlags(FP, S, B, 0)
// #endif
@NoException public static native @Cast("_node*") node PyParser_SimpleParseStringFlags(@Cast("const char*") BytePointer arg0, int arg1,
                                                           int arg2);
@NoException public static native @Cast("_node*") node PyParser_SimpleParseStringFlags(String arg0, int arg1,
                                                           int arg2);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native @Cast("_node*") node PyParser_SimpleParseStringFlagsFilename(@Cast("const char*") BytePointer arg0,
                                                                   @Cast("const char*") BytePointer arg1,
                                                                   int arg2, int arg3);
@NoException public static native @Cast("_node*") node PyParser_SimpleParseStringFlagsFilename(String arg0,
                                                                   String arg1,
                                                                   int arg2, int arg3);
// #endif
@NoException public static native @Cast("_node*") node PyParser_SimpleParseFileFlags(@Cast("FILE*") Pointer arg0, @Cast("const char*") BytePointer arg1,
                                                         int arg2, int arg3);
@NoException public static native @Cast("_node*") node PyParser_SimpleParseFileFlags(@Cast("FILE*") Pointer arg0, String arg1,
                                                         int arg2, int arg3);

// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyRun_StringFlags(@Cast("const char*") BytePointer arg0, int arg1, PyObject arg2,
                                         PyObject arg3, PyCompilerFlags arg4);
@NoException public static native PyObject PyRun_StringFlags(String arg0, int arg1, PyObject arg2,
                                         PyObject arg3, PyCompilerFlags arg4);

@NoException public static native PyObject PyRun_FileExFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    int start,
    PyObject globals,
    PyObject locals,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native PyObject PyRun_FileExFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    int start,
    PyObject globals,
    PyObject locals,
    int closeit,
    PyCompilerFlags flags);
// #endif

// #ifdef Py_LIMITED_API
@NoException public static native PyObject Py_CompileString(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, int arg2);
@NoException public static native PyObject Py_CompileString(String arg0, String arg1, int arg2);
// #else
// #define Py_CompileString(str, p, s) Py_CompileStringExFlags(str, p, s, NULL, -1)
// #define Py_CompileStringFlags(str, p, s, f) Py_CompileStringExFlags(str, p, s, f, -1)
@NoException public static native PyObject Py_CompileStringExFlags(
    @Cast("const char*") BytePointer str,
    @Cast("const char*") BytePointer filename,
    int start,
    PyCompilerFlags flags,
    int optimize);
@NoException public static native PyObject Py_CompileStringExFlags(
    String str,
    String filename,
    int start,
    PyCompilerFlags flags,
    int optimize);
@NoException public static native PyObject Py_CompileStringObject(
    @Cast("const char*") BytePointer str,
    PyObject filename, int start,
    PyCompilerFlags flags,
    int optimize);
@NoException public static native PyObject Py_CompileStringObject(
    String str,
    PyObject filename, int start,
    PyCompilerFlags flags,
    int optimize);
// #endif
@NoException public static native symtable Py_SymtableString(
    @Cast("const char*") BytePointer str,
    @Cast("const char*") BytePointer filename,
    int start);
@NoException public static native symtable Py_SymtableString(
    String str,
    String filename,
    int start);
// #ifndef Py_LIMITED_API
@NoException public static native symtable Py_SymtableStringObject(
    @Cast("const char*") BytePointer str,
    PyObject filename,
    int start);
@NoException public static native symtable Py_SymtableStringObject(
    String str,
    PyObject filename,
    int start);
// #endif

@NoException public static native void PyErr_Print();
@NoException public static native void PyErr_PrintEx(int arg0);
@NoException public static native void PyErr_Display(PyObject arg0, PyObject arg1, PyObject arg2);

// #ifndef Py_LIMITED_API
/* Use macros for a bunch of old variants */
// #define PyRun_String(str, s, g, l) PyRun_StringFlags(str, s, g, l, NULL)
// #define PyRun_AnyFile(fp, name) PyRun_AnyFileExFlags(fp, name, 0, NULL)
// #define PyRun_AnyFileEx(fp, name, closeit)
//     PyRun_AnyFileExFlags(fp, name, closeit, NULL)
// #define PyRun_AnyFileFlags(fp, name, flags)
//     PyRun_AnyFileExFlags(fp, name, 0, flags)
// #define PyRun_SimpleString(s) PyRun_SimpleStringFlags(s, NULL)
// #define PyRun_SimpleFile(f, p) PyRun_SimpleFileExFlags(f, p, 0, NULL)
// #define PyRun_SimpleFileEx(f, p, c) PyRun_SimpleFileExFlags(f, p, c, NULL)
// #define PyRun_InteractiveOne(f, p) PyRun_InteractiveOneFlags(f, p, NULL)
// #define PyRun_InteractiveLoop(f, p) PyRun_InteractiveLoopFlags(f, p, NULL)
// #define PyRun_File(fp, p, s, g, l)
//     PyRun_FileExFlags(fp, p, s, g, l, 0, NULL)
// #define PyRun_FileEx(fp, p, s, g, l, c)
//     PyRun_FileExFlags(fp, p, s, g, l, c, NULL)
// #define PyRun_FileFlags(fp, p, s, g, l, flags)
//     PyRun_FileExFlags(fp, p, s, g, l, 0, flags)
// #endif

/* Stuff with no proper home (yet) */
// #ifndef Py_LIMITED_API
@NoException public static native @Cast("char*") BytePointer PyOS_Readline(@Cast("FILE*") Pointer arg0, @Cast("FILE*") Pointer arg1, @Cast("const char*") BytePointer arg2);
@NoException public static native @Cast("char*") ByteBuffer PyOS_Readline(@Cast("FILE*") Pointer arg0, @Cast("FILE*") Pointer arg1, String arg2);
// Targeting ../python/Int_PyOS_InputHook.java


public static native Int_PyOS_InputHook PyOS_InputHook(); public static native void PyOS_InputHook(Int_PyOS_InputHook PyOS_InputHook);
// Targeting ../python/PyOS_ReadlineFunctionPointer_Pointer_Pointer_BytePointer.java


public static native PyOS_ReadlineFunctionPointer_Pointer_Pointer_BytePointer PyOS_ReadlineFunctionPointer(); public static native void PyOS_ReadlineFunctionPointer(PyOS_ReadlineFunctionPointer_Pointer_Pointer_BytePointer PyOS_ReadlineFunctionPointer);
// #ifndef Py_LIMITED_API
public static native PyThreadState _PyOS_ReadlineTState(); public static native void _PyOS_ReadlineTState(PyThreadState _PyOS_ReadlineTState);
// #endif

/* Stack size, in "pointers" (so we get extra safety margins
   on 64-bit platforms).  On a 32-bit platform, this translates
   to an 8k margin. */
public static final int PYOS_STACK_MARGIN = 2048;

// #if defined(WIN32) && !defined(MS_WIN64) && defined(_MSC_VER) && _MSC_VER >= 1300
/* Enable stack checking under Microsoft C */
// #define USE_STACKCHECK
// #endif

// #ifdef USE_STACKCHECK
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYTHONRUN_H */


// Parsed from pylifecycle.h


/* Interfaces to configure, query, create & destroy the Python runtime */

// #ifndef Py_PYLIFECYCLE_H
// #define Py_PYLIFECYCLE_H
// #ifdef __cplusplus
// #endif

@NoException public static native void Py_SetProgramName(@Cast("wchar_t*") Pointer arg0);
@NoException public static native @Cast("wchar_t*") Pointer Py_GetProgramName();

@NoException public static native void Py_SetPythonHome(@Cast("wchar_t*") Pointer arg0);
@NoException public static native @Cast("wchar_t*") Pointer Py_GetPythonHome();

// #ifndef Py_LIMITED_API
/* Only used by applications that embed the interpreter and need to
 * override the standard encoding determination mechanism
 */
@NoException public static native int Py_SetStandardStreamEncoding(@Cast("const char*") BytePointer encoding,
                                             @Cast("const char*") BytePointer errors);
@NoException public static native int Py_SetStandardStreamEncoding(String encoding,
                                             String errors);
// #endif

@NoException public static native void Py_Initialize();
@NoException public static native void Py_InitializeEx(int arg0);
// #ifndef Py_LIMITED_API
@NoException public static native void _Py_InitializeEx_Private(int arg0, int arg1);
// #endif
@NoException public static native void Py_Finalize();
@NoException public static native int Py_FinalizeEx();
@NoException public static native int Py_IsInitialized();
@NoException public static native PyThreadState Py_NewInterpreter();
@NoException public static native void Py_EndInterpreter(PyThreadState arg0);
// Targeting ../python/Func.java


@NoException public static native void _Py_PyAtExit(Func func);
// #endif
@NoException public static native int Py_AtExit(Func func);

@NoException public static native void Py_Exit(int arg0);

/* Restore signals that the interpreter has called SIG_IGN on to SIG_DFL. */
// #ifndef Py_LIMITED_API
@NoException public static native void _Py_RestoreSignals();

@NoException public static native int Py_FdIsInteractive(@Cast("FILE*") Pointer arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native int Py_FdIsInteractive(@Cast("FILE*") Pointer arg0, String arg1);
// #endif

/* Bootstrap __main__ (defined in Modules/main.c) */
@NoException public static native int Py_Main(int argc, @Cast("wchar_t**") PointerPointer argv);
@NoException public static native int Py_Main(int argc, @Cast("wchar_t**") @ByPtrPtr Pointer argv);

/* In getpath.c */
@NoException public static native @Cast("wchar_t*") Pointer Py_GetProgramFullPath();
@NoException public static native @Cast("wchar_t*") Pointer Py_GetPrefix();
@NoException public static native @Cast("wchar_t*") Pointer Py_GetExecPrefix();
@NoException public static native @Cast("wchar_t*") Pointer Py_GetPath();
@NoException public static native void Py_SetPath(@Cast("const wchar_t*") Pointer arg0);
// #ifdef MS_WINDOWS
// #endif

/* In their own files */
@NoException public static native @Cast("const char*") BytePointer Py_GetVersion();
@NoException public static native @Cast("const char*") BytePointer Py_GetPlatform();
@NoException public static native @Cast("const char*") BytePointer Py_GetCopyright();
@NoException public static native @Cast("const char*") BytePointer Py_GetCompiler();
@NoException public static native @Cast("const char*") BytePointer Py_GetBuildInfo();
// #ifndef Py_LIMITED_API
@NoException public static native @Cast("const char*") BytePointer _Py_gitidentifier();
@NoException public static native @Cast("const char*") BytePointer _Py_gitversion();
// #endif

/* Internal -- various one-time initializations */
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyBuiltin_Init();
@NoException public static native PyObject _PySys_Init();
@NoException public static native void _PyImport_Init();
@NoException public static native void _PyExc_Init(PyObject bltinmod);
@NoException public static native void _PyImportHooks_Init();
@NoException public static native int _PyFrame_Init();
@NoException public static native int _PyFloat_Init();
@NoException public static native int PyByteArray_Init();
@NoException public static native void _PyRandom_Init();
// #endif

/* Various internal finalizers */
// #ifndef Py_LIMITED_API
@NoException public static native void _PyExc_Fini();
@NoException public static native void _PyImport_Fini();
@NoException public static native void PyMethod_Fini();
@NoException public static native void PyFrame_Fini();
@NoException public static native void PyCFunction_Fini();
@NoException public static native void PyDict_Fini();
@NoException public static native void PyTuple_Fini();
@NoException public static native void PyList_Fini();
@NoException public static native void PySet_Fini();
@NoException public static native void PyBytes_Fini();
@NoException public static native void PyByteArray_Fini();
@NoException public static native void PyFloat_Fini();
@NoException public static native void PyOS_FiniInterrupts();
@NoException public static native void _PyGC_DumpShutdownStats();
@NoException public static native void _PyGC_Fini();
@NoException public static native void PySlice_Fini();
@NoException public static native void _PyType_Fini();
@NoException public static native void _PyRandom_Fini();
@NoException public static native void PyAsyncGen_Fini();

public static native PyThreadState _Py_Finalizing(); public static native void _Py_Finalizing(PyThreadState _Py_Finalizing);
// Targeting ../python/PyOS_sighandler_t.java


@NoException public static native PyOS_sighandler_t PyOS_getsig(int arg0);
@NoException public static native PyOS_sighandler_t PyOS_setsig(int arg0, PyOS_sighandler_t arg1);

// #ifndef Py_LIMITED_API
/* Random */
@NoException public static native int _PyOS_URandom(Pointer buffer, @Cast("Py_ssize_t") long size);
@NoException public static native int _PyOS_URandomNonblock(Pointer buffer, @Cast("Py_ssize_t") long size);
// #endif /* !Py_LIMITED_API */

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYLIFECYCLE_H */


// Parsed from eval.h


/* Interface to execute compiled code */

// #ifndef Py_EVAL_H
// #define Py_EVAL_H
// #ifdef __cplusplus
// #endif

@NoException public static native PyObject PyEval_EvalCode(PyObject arg0, PyObject arg1, PyObject arg2);

@NoException public static native PyObject PyEval_EvalCodeEx(PyObject co,
					PyObject globals,
					PyObject locals,
					@Cast("PyObject**") PointerPointer args, int argc,
					@Cast("PyObject**") PointerPointer kwds, int kwdc,
					@Cast("PyObject**") PointerPointer defs, int defc,
					PyObject kwdefs, PyObject closure);
@NoException public static native PyObject PyEval_EvalCodeEx(PyObject co,
					PyObject globals,
					PyObject locals,
					@ByPtrPtr PyObject args, int argc,
					@ByPtrPtr PyObject kwds, int kwdc,
					@ByPtrPtr PyObject defs, int defc,
					PyObject kwdefs, PyObject closure);

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyEval_CallTracing(PyObject func, PyObject args);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_EVAL_H */


// Parsed from pyctype.h

// #ifndef Py_LIMITED_API
// #ifndef PYCTYPE_H
// #define PYCTYPE_H

public static final int PY_CTF_LOWER =  0x01;
public static final int PY_CTF_UPPER =  0x02;
public static final int PY_CTF_ALPHA =  (PY_CTF_LOWER|PY_CTF_UPPER);
public static final int PY_CTF_DIGIT =  0x04;
public static final int PY_CTF_ALNUM =  (PY_CTF_ALPHA|PY_CTF_DIGIT);
public static final int PY_CTF_SPACE =  0x08;
public static final int PY_CTF_XDIGIT = 0x10;

@MemberGetter public static native @Cast("const unsigned int") int _Py_ctype_table(int i);
@MemberGetter public static native @Cast("const unsigned int*") IntPointer _Py_ctype_table();

/* Unlike their C counterparts, the following macros are not meant to
 * handle an int with any of the values [EOF, 0-UCHAR_MAX]. The argument
 * must be a signed/unsigned char. */
// #define Py_ISLOWER(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_LOWER)
// #define Py_ISUPPER(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_UPPER)
// #define Py_ISALPHA(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_ALPHA)
// #define Py_ISDIGIT(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_DIGIT)
// #define Py_ISXDIGIT(c) (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_XDIGIT)
// #define Py_ISALNUM(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_ALNUM)
// #define Py_ISSPACE(c)  (_Py_ctype_table[Py_CHARMASK(c)] & PY_CTF_SPACE)

@MemberGetter public static native @Cast("const unsigned char") byte _Py_ctype_tolower(int i);
@MemberGetter public static native @Cast("const unsigned char*") BytePointer _Py_ctype_tolower();
@MemberGetter public static native @Cast("const unsigned char") byte _Py_ctype_toupper(int i);
@MemberGetter public static native @Cast("const unsigned char*") BytePointer _Py_ctype_toupper();

// #define Py_TOLOWER(c) (_Py_ctype_tolower[Py_CHARMASK(c)])
// #define Py_TOUPPER(c) (_Py_ctype_toupper[Py_CHARMASK(c)])

// #endif /* !PYCTYPE_H */
// #endif /* !Py_LIMITED_API */


// Parsed from pystrtod.h

// #ifndef Py_STRTOD_H
// #define Py_STRTOD_H

// #ifdef __cplusplus
// #endif


@NoException public static native double PyOS_string_to_double(@Cast("const char*") BytePointer str,
                                         @Cast("char**") PointerPointer endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(@Cast("const char*") BytePointer str,
                                         @Cast("char**") @ByPtrPtr BytePointer endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(String str,
                                         @Cast("char**") @ByPtrPtr ByteBuffer endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(@Cast("const char*") BytePointer str,
                                         @Cast("char**") @ByPtrPtr byte[] endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(String str,
                                         @Cast("char**") @ByPtrPtr BytePointer endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(@Cast("const char*") BytePointer str,
                                         @Cast("char**") @ByPtrPtr ByteBuffer endptr,
                                         PyObject overflow_exception);
@NoException public static native double PyOS_string_to_double(String str,
                                         @Cast("char**") @ByPtrPtr byte[] endptr,
                                         PyObject overflow_exception);

/* The caller is responsible for calling PyMem_Free to free the buffer
   that's is returned. */
@NoException public static native @Cast("char*") BytePointer PyOS_double_to_string(double val,
                                         @Cast("char") byte format_code,
                                         int precision,
                                         int flags,
                                         IntPointer type);
@NoException public static native @Cast("char*") ByteBuffer PyOS_double_to_string(double val,
                                         @Cast("char") byte format_code,
                                         int precision,
                                         int flags,
                                         IntBuffer type);
@NoException public static native @Cast("char*") byte[] PyOS_double_to_string(double val,
                                         @Cast("char") byte format_code,
                                         int precision,
                                         int flags,
                                         int[] type);
// Targeting ../python/Innerfunc_BytePointer_long_Pointer.java


@NoException public static native PyObject _Py_string_to_number_with_underscores(
    @Cast("const char*") BytePointer str, @Cast("Py_ssize_t") long len, @Cast("const char*") BytePointer what, PyObject obj, Pointer arg,
    Innerfunc_BytePointer_long_Pointer innerfunc);
// Targeting ../python/Innerfunc_String_long_Pointer.java


@NoException public static native PyObject _Py_string_to_number_with_underscores(
    String str, @Cast("Py_ssize_t") long len, String what, PyObject obj, Pointer arg,
    Innerfunc_String_long_Pointer innerfunc);

@NoException public static native double _Py_parse_inf_or_nan(@Cast("const char*") BytePointer p, @Cast("char**") PointerPointer endptr);
@NoException public static native double _Py_parse_inf_or_nan(@Cast("const char*") BytePointer p, @Cast("char**") @ByPtrPtr BytePointer endptr);
@NoException public static native double _Py_parse_inf_or_nan(String p, @Cast("char**") @ByPtrPtr ByteBuffer endptr);
@NoException public static native double _Py_parse_inf_or_nan(@Cast("const char*") BytePointer p, @Cast("char**") @ByPtrPtr byte[] endptr);
@NoException public static native double _Py_parse_inf_or_nan(String p, @Cast("char**") @ByPtrPtr BytePointer endptr);
@NoException public static native double _Py_parse_inf_or_nan(@Cast("const char*") BytePointer p, @Cast("char**") @ByPtrPtr ByteBuffer endptr);
@NoException public static native double _Py_parse_inf_or_nan(String p, @Cast("char**") @ByPtrPtr byte[] endptr);
// #endif


/* PyOS_double_to_string's "flags" parameter can be set to 0 or more of: */
public static final int Py_DTSF_SIGN =      0x01; /* always add the sign */
public static final int Py_DTSF_ADD_DOT_0 = 0x02; /* if the result is an integer add ".0" */
public static final int Py_DTSF_ALT =       0x04; /* "alternate" formatting. it's format_code
                                  specific */

/* PyOS_double_to_string's "type", if non-NULL, will be set to one of: */
public static final int Py_DTST_FINITE = 0;
public static final int Py_DTST_INFINITE = 1;
public static final int Py_DTST_NAN = 2;

// #ifdef __cplusplus
// #endif

// #endif /* !Py_STRTOD_H */


// Parsed from pystrcmp.h

// #ifndef Py_STRCMP_H
// #define Py_STRCMP_H

// #ifdef __cplusplus
// #endif

@NoException public static native int PyOS_mystrnicmp(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, @Cast("Py_ssize_t") long arg2);
@NoException public static native int PyOS_mystrnicmp(String arg0, String arg1, @Cast("Py_ssize_t") long arg2);
@NoException public static native int PyOS_mystricmp(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native int PyOS_mystricmp(String arg0, String arg1);

// #ifdef MS_WINDOWS
// #else
// #define PyOS_strnicmp PyOS_mystrnicmp
// #define PyOS_stricmp PyOS_mystricmp
// #endif

// #ifdef __cplusplus
// #endif

// #endif /* !Py_STRCMP_H */


// Parsed from dtoa.h

// #ifndef Py_LIMITED_API
// #ifndef PY_NO_SHORT_FLOAT_REPR
// #ifdef __cplusplus
// #endif

@NoException public static native double _Py_dg_strtod(@Cast("const char*") BytePointer str, @Cast("char**") PointerPointer ptr);
@NoException public static native double _Py_dg_strtod(@Cast("const char*") BytePointer str, @Cast("char**") @ByPtrPtr BytePointer ptr);
@NoException public static native double _Py_dg_strtod(String str, @Cast("char**") @ByPtrPtr ByteBuffer ptr);
@NoException public static native double _Py_dg_strtod(@Cast("const char*") BytePointer str, @Cast("char**") @ByPtrPtr byte[] ptr);
@NoException public static native double _Py_dg_strtod(String str, @Cast("char**") @ByPtrPtr BytePointer ptr);
@NoException public static native double _Py_dg_strtod(@Cast("const char*") BytePointer str, @Cast("char**") @ByPtrPtr ByteBuffer ptr);
@NoException public static native double _Py_dg_strtod(String str, @Cast("char**") @ByPtrPtr byte[] ptr);
@NoException public static native @Cast("char*") BytePointer _Py_dg_dtoa(double d, int mode, int ndigits,
                        IntPointer decpt, IntPointer sign, @Cast("char**") PointerPointer rve);
@NoException public static native @Cast("char*") BytePointer _Py_dg_dtoa(double d, int mode, int ndigits,
                        IntPointer decpt, IntPointer sign, @Cast("char**") @ByPtrPtr BytePointer rve);
@NoException public static native @Cast("char*") ByteBuffer _Py_dg_dtoa(double d, int mode, int ndigits,
                        IntBuffer decpt, IntBuffer sign, @Cast("char**") @ByPtrPtr ByteBuffer rve);
@NoException public static native @Cast("char*") byte[] _Py_dg_dtoa(double d, int mode, int ndigits,
                        int[] decpt, int[] sign, @Cast("char**") @ByPtrPtr byte[] rve);
@NoException public static native void _Py_dg_freedtoa(@Cast("char*") BytePointer s);
@NoException public static native void _Py_dg_freedtoa(@Cast("char*") ByteBuffer s);
@NoException public static native void _Py_dg_freedtoa(@Cast("char*") byte[] s);
@NoException public static native double _Py_dg_stdnan(int sign);
@NoException public static native double _Py_dg_infinity(int sign);


// #ifdef __cplusplus
// #endif
// #endif
// #endif


// Parsed from fileutils.h

// #ifndef Py_FILEUTILS_H
// #define Py_FILEUTILS_H

// #ifdef __cplusplus
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
@NoException public static native @Cast("wchar_t*") Pointer Py_DecodeLocale(
    @Cast("const char*") BytePointer arg,
    @Cast("size_t*") SizeTPointer size);
@NoException public static native @Cast("wchar_t*") Pointer Py_DecodeLocale(
    String arg,
    @Cast("size_t*") SizeTPointer size);

@NoException public static native @Cast("char*") BytePointer Py_EncodeLocale(
    @Cast("const wchar_t*") Pointer text,
    @Cast("size_t*") SizeTPointer error_pos);
// #endif

// #ifndef Py_LIMITED_API

@NoException public static native @Cast("wchar_t*") Pointer _Py_DecodeLocaleEx(
    @Cast("const char*") BytePointer arg,
    @Cast("size_t*") SizeTPointer size,
    int current_locale);
@NoException public static native @Cast("wchar_t*") Pointer _Py_DecodeLocaleEx(
    String arg,
    @Cast("size_t*") SizeTPointer size,
    int current_locale);

@NoException public static native @Cast("char*") BytePointer _Py_EncodeLocaleEx(
    @Cast("const wchar_t*") Pointer text,
    @Cast("size_t*") SizeTPointer error_pos,
    int current_locale);

@NoException public static native PyObject _Py_device_encoding(int arg0);

// #ifdef MS_WINDOWS
// #else
// #endif

@NoException public static native int _Py_fstat(
    int fd,
    @Cast("struct _Py_stat_struct*") Pointer status);

@NoException public static native int _Py_fstat_noraise(
    int fd,
    @Cast("struct _Py_stat_struct*") Pointer status);

@NoException public static native int _Py_stat(
    PyObject path,
    @Cast("struct stat*") Pointer status);

@NoException public static native int _Py_open(
    @Cast("const char*") BytePointer pathname,
    int flags);
@NoException public static native int _Py_open(
    String pathname,
    int flags);

@NoException public static native int _Py_open_noraise(
    @Cast("const char*") BytePointer pathname,
    int flags);
@NoException public static native int _Py_open_noraise(
    String pathname,
    int flags);

@NoException public static native @Cast("FILE*") Pointer _Py_wfopen(
    @Cast("const wchar_t*") Pointer path,
    @Cast("const wchar_t*") Pointer mode);

@NoException public static native @Cast("FILE*") Pointer _Py_fopen(
    @Cast("const char*") BytePointer pathname,
    @Cast("const char*") BytePointer mode);
@NoException public static native @Cast("FILE*") Pointer _Py_fopen(
    String pathname,
    String mode);

@NoException public static native @Cast("FILE*") Pointer _Py_fopen_obj(
    PyObject path,
    @Cast("const char*") BytePointer mode);
@NoException public static native @Cast("FILE*") Pointer _Py_fopen_obj(
    PyObject path,
    String mode);

@NoException public static native @Cast("Py_ssize_t") long _Py_read(
    int fd,
    Pointer buf,
    @Cast("size_t") long count);

@NoException public static native @Cast("Py_ssize_t") long _Py_write(
    int fd,
    @Const Pointer buf,
    @Cast("size_t") long count);

@NoException public static native @Cast("Py_ssize_t") long _Py_write_noraise(
    int fd,
    @Const Pointer buf,
    @Cast("size_t") long count);

// #ifdef HAVE_READLINK

// #endif

// #ifdef HAVE_REALPATH

// #endif

@NoException public static native @Cast("wchar_t*") Pointer _Py_wgetcwd(
    @Cast("wchar_t*") Pointer buf,
    @Cast("size_t") long size);

@NoException public static native int _Py_get_inheritable(int fd);

@NoException public static native int _Py_set_inheritable(int fd, int inheritable,
                                    IntPointer atomic_flag_works);
@NoException public static native int _Py_set_inheritable(int fd, int inheritable,
                                    IntBuffer atomic_flag_works);
@NoException public static native int _Py_set_inheritable(int fd, int inheritable,
                                    int[] atomic_flag_works);

@NoException public static native int _Py_set_inheritable_async_safe(int fd, int inheritable,
                                               IntPointer atomic_flag_works);
@NoException public static native int _Py_set_inheritable_async_safe(int fd, int inheritable,
                                               IntBuffer atomic_flag_works);
@NoException public static native int _Py_set_inheritable_async_safe(int fd, int inheritable,
                                               int[] atomic_flag_works);

@NoException public static native int _Py_dup(int fd);

// #ifndef MS_WINDOWS



// #endif   /* !MS_WINDOWS */

@NoException public static native int _Py_GetLocaleconvNumeric(
    @Cast("PyObject**") PointerPointer decimal_point,
    @Cast("PyObject**") PointerPointer thousands_sep,
    @Cast("const char**") PointerPointer grouping);
@NoException public static native int _Py_GetLocaleconvNumeric(
    @ByPtrPtr PyObject decimal_point,
    @ByPtrPtr PyObject thousands_sep,
    @Cast("const char**") @ByPtrPtr BytePointer grouping);
@NoException public static native int _Py_GetLocaleconvNumeric(
    @ByPtrPtr PyObject decimal_point,
    @ByPtrPtr PyObject thousands_sep,
    @Cast("const char**") @ByPtrPtr ByteBuffer grouping);
@NoException public static native int _Py_GetLocaleconvNumeric(
    @ByPtrPtr PyObject decimal_point,
    @ByPtrPtr PyObject thousands_sep,
    @Cast("const char**") @ByPtrPtr byte[] grouping);

// #endif   /* Py_LIMITED_API */

// #ifdef __cplusplus
// #endif

// #endif /* !Py_FILEUTILS_H */


}
