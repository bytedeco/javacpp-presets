// Targeted by JavaCPP version 1.5.10: DO NOT EDIT THIS FILE

package org.bytedeco.cpython;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

import static org.bytedeco.cpython.global.python.*;


@Name("_ts") @Properties(inherit = org.bytedeco.cpython.presets.python.class)
public class PyThreadState extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyThreadState() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyThreadState(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyThreadState(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyThreadState position(long position) {
        return (PyThreadState)super.position(position);
    }
    @Override public PyThreadState getPointer(long i) {
        return new PyThreadState((Pointer)this).offsetAddress(i);
    }

    /* See Python/ceval.c for comments explaining most fields */

    public native PyThreadState prev(); public native PyThreadState prev(PyThreadState setter);
    public native PyThreadState next(); public native PyThreadState next(PyThreadState setter);
    public native PyInterpreterState interp(); public native PyThreadState interp(PyInterpreterState setter);

        /* Has been initialized to a safe state.

           In order to be effective, this must be set to 0 during or right
           after allocation. */
        @Name("_status.initialized") public native @Cast("unsigned int") @NoOffset int _status_initialized(); public native PyThreadState _status_initialized(int setter);

        /* Has been bound to an OS thread. */
        @Name("_status.bound") public native @Cast("unsigned int") @NoOffset int _status_bound(); public native PyThreadState _status_bound(int setter);
        /* Has been unbound from its OS thread. */
        @Name("_status.unbound") public native @Cast("unsigned int") @NoOffset int _status_unbound(); public native PyThreadState _status_unbound(int setter);
        /* Has been bound aa current for the GILState API. */
        @Name("_status.bound_gilstate") public native @Cast("unsigned int") @NoOffset int _status_bound_gilstate(); public native PyThreadState _status_bound_gilstate(int setter);
        /* Currently in use (maybe holds the GIL). */
        @Name("_status.active") public native @Cast("unsigned int") @NoOffset int _status_active(); public native PyThreadState _status_active(int setter);

        /* various stages of finalization */
        @Name("_status.finalizing") public native @Cast("unsigned int") @NoOffset int _status_finalizing(); public native PyThreadState _status_finalizing(int setter);
        @Name("_status.cleared") public native @Cast("unsigned int") @NoOffset int _status_cleared(); public native PyThreadState _status_cleared(int setter);
        @Name("_status.finalized") public native @Cast("unsigned int") @NoOffset int _status_finalized(); public native PyThreadState _status_finalized(int setter);

        /* padding to align to 4 bytes */
        

    public native int py_recursion_remaining(); public native PyThreadState py_recursion_remaining(int setter);
    public native int py_recursion_limit(); public native PyThreadState py_recursion_limit(int setter);

    public native int c_recursion_remaining(); public native PyThreadState c_recursion_remaining(int setter);
    public native int recursion_headroom(); public native PyThreadState recursion_headroom(int setter); /* Allow 50 more calls to handle any errors. */

    /* 'tracing' keeps track of the execution depth when tracing/profiling.
       This is to prevent the actual trace/profile code from being recorded in
       the trace/profile. */
    public native int tracing(); public native PyThreadState tracing(int setter);
    public native int what_event(); public native PyThreadState what_event(int setter); /* The event currently being monitored, if any. */

    /* Pointer to current _PyCFrame in the C stack frame of the currently,
     * or most recently, executing _PyEval_EvalFrameDefault. */
    public native _PyCFrame cframe(); public native PyThreadState cframe(_PyCFrame setter);

    public native Py_tracefunc c_profilefunc(); public native PyThreadState c_profilefunc(Py_tracefunc setter);
    public native Py_tracefunc c_tracefunc(); public native PyThreadState c_tracefunc(Py_tracefunc setter);
    public native PyObject c_profileobj(); public native PyThreadState c_profileobj(PyObject setter);
    public native PyObject c_traceobj(); public native PyThreadState c_traceobj(PyObject setter);

    /* The exception currently being raised */
    public native PyObject current_exception(); public native PyThreadState current_exception(PyObject setter);

    /* Pointer to the top of the exception stack for the exceptions
     * we may be currently handling.  (See _PyErr_StackItem above.)
     * This is never NULL. */
    public native _PyErr_StackItem exc_info(); public native PyThreadState exc_info(_PyErr_StackItem setter);

    public native PyObject dict(); public native PyThreadState dict(PyObject setter);  /* Stores per-thread state */

    public native int gilstate_counter(); public native PyThreadState gilstate_counter(int setter);

    public native PyObject async_exc(); public native PyThreadState async_exc(PyObject setter); /* Asynchronous exception to raise */
    public native @Cast("unsigned long") long thread_id(); public native PyThreadState thread_id(long setter); /* Thread id where this tstate was created */

    /* Native thread id where this tstate was created. This will be 0 except on
     * those platforms that have the notion of native thread id, for which the
     * macro PY_HAVE_THREAD_NATIVE_ID is then defined.
     */
    public native @Cast("unsigned long") long native_thread_id(); public native PyThreadState native_thread_id(long setter);

    public native @ByRef _py_trashcan trash(); public native PyThreadState trash(_py_trashcan setter);

    /* Called when a thread state is deleted normally, but not when it
     * is destroyed after fork().
     * Pain:  to prevent rare but fatal shutdown errors (issue 18808),
     * Thread.join() must wait for the join'ed thread's tstate to be unlinked
     * from the tstate chain.  That happens at the end of a thread's life,
     * in pystate.c.
     * The obvious way doesn't quite work:  create a lock which the tstate
     * unlinking code releases, and have Thread.join() wait to acquire that
     * lock.  The problem is that we _are_ at the end of the thread's life:
     * if the thread holds the last reference to the lock, decref'ing the
     * lock will delete the lock, and that may trigger arbitrary Python code
     * if there's a weakref, with a callback, to the lock.  But by this time
     * _PyRuntime.gilstate.tstate_current is already NULL, so only the simplest
     * of C code can be allowed to run (in particular it must not be possible to
     * release the GIL).
     * So instead of holding the lock directly, the tstate holds a weakref to
     * the lock:  that's the value of on_delete_data below.  Decref'ing a
     * weakref is harmless.
     * on_delete points to _threadmodule.c's static release_sentinel() function.
     * After the tstate is unlinked, release_sentinel is called with the
     * weakref-to-lock (on_delete_data) argument, and release_sentinel releases
     * the indirectly held lock.
     */
    public static class On_delete_Pointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    On_delete_Pointer(Pointer p) { super(p); }
        protected On_delete_Pointer() { allocate(); }
        private native void allocate();
        public native void call(Pointer arg0);
    }
    public native On_delete_Pointer on_delete(); public native PyThreadState on_delete(On_delete_Pointer setter);
    public native Pointer on_delete_data(); public native PyThreadState on_delete_data(Pointer setter);

    public native int coroutine_origin_tracking_depth(); public native PyThreadState coroutine_origin_tracking_depth(int setter);

    public native PyObject async_gen_firstiter(); public native PyThreadState async_gen_firstiter(PyObject setter);
    public native PyObject async_gen_finalizer(); public native PyThreadState async_gen_finalizer(PyObject setter);

    public native PyObject context(); public native PyThreadState context(PyObject setter);
    public native @Cast("uint64_t") long context_ver(); public native PyThreadState context_ver(long setter);

    /* Unique thread state id. */
    public native @Cast("uint64_t") long id(); public native PyThreadState id(long setter);

    public native _PyStackChunk datastack_chunk(); public native PyThreadState datastack_chunk(_PyStackChunk setter);
    public native PyObject datastack_top(int i); public native PyThreadState datastack_top(int i, PyObject setter);
    public native @Cast("PyObject**") PointerPointer datastack_top(); public native PyThreadState datastack_top(PointerPointer setter);
    public native PyObject datastack_limit(int i); public native PyThreadState datastack_limit(int i, PyObject setter);
    public native @Cast("PyObject**") PointerPointer datastack_limit(); public native PyThreadState datastack_limit(PointerPointer setter);
    /* XXX signal handlers should also be here */

    /* The following fields are here to avoid allocation during init.
       The data is exposed through PyThreadState pointer fields.
       These fields should not be accessed directly outside of init.
       This is indicated by an underscore prefix on the field names.

       All other PyInterpreterState pointer fields are populated when
       needed and default to NULL.
       */
       // Note some fields do not have a leading underscore for backward
       // compatibility.  See https://bugs.python.org/issue45953#msg412046.

    /* The thread's exception stack entry.  (Always the last entry.) */
    public native @ByRef _PyErr_StackItem exc_state(); public native PyThreadState exc_state(_PyErr_StackItem setter);

    /* The bottom-most frame on the stack. */
    public native @ByRef _PyCFrame root_cframe(); public native PyThreadState root_cframe(_PyCFrame setter);
}
