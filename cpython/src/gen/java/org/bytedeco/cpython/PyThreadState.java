// Targeted by JavaCPP version 1.5.13-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.cpython;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

import static org.bytedeco.cpython.global.python.*;

@Name("_ts") @Properties(inherit = org.bytedeco.cpython.presets.python.class)
public class PyThreadState extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyThreadState() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyThreadState(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyThreadState(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyThreadState position(long position) {
        return (PyThreadState)super.position(position);
    }
    @Override public PyThreadState getPointer(long i) {
        return new PyThreadState((Pointer)this).offsetAddress(i);
    }

    /* See Python/ceval.c for comments explaining most fields */

    public native PyThreadState prev(); public native PyThreadState prev(PyThreadState setter);
    public native PyThreadState next(); public native PyThreadState next(PyThreadState setter);
    public native PyInterpreterState interp(); public native PyThreadState interp(PyInterpreterState setter);

    /* The global instrumentation version in high bits, plus flags indicating
       when to break out of the interpreter loop in lower bits. See details in
       pycore_ceval.h. */
    public native @Cast("uintptr_t") long eval_breaker(); public native PyThreadState eval_breaker(long setter);

        /* Has been initialized to a safe state.

           In order to be effective, this must be set to 0 during or right
           after allocation. */
        @Name("_status.initialized") public native @Cast("unsigned int") @NoOffset int _status_initialized(); public native PyThreadState _status_initialized(int setter);

        /* Has been bound to an OS thread. */
        @Name("_status.bound") public native @Cast("unsigned int") @NoOffset int _status_bound(); public native PyThreadState _status_bound(int setter);
        /* Has been unbound from its OS thread. */
        @Name("_status.unbound") public native @Cast("unsigned int") @NoOffset int _status_unbound(); public native PyThreadState _status_unbound(int setter);
        /* Has been bound aa current for the GILState API. */
        @Name("_status.bound_gilstate") public native @Cast("unsigned int") @NoOffset int _status_bound_gilstate(); public native PyThreadState _status_bound_gilstate(int setter);
        /* Currently in use (maybe holds the GIL). */
        @Name("_status.active") public native @Cast("unsigned int") @NoOffset int _status_active(); public native PyThreadState _status_active(int setter);

        /* various stages of finalization */
        @Name("_status.finalizing") public native @Cast("unsigned int") @NoOffset int _status_finalizing(); public native PyThreadState _status_finalizing(int setter);
        @Name("_status.cleared") public native @Cast("unsigned int") @NoOffset int _status_cleared(); public native PyThreadState _status_cleared(int setter);
        @Name("_status.finalized") public native @Cast("unsigned int") @NoOffset int _status_finalized(); public native PyThreadState _status_finalized(int setter);

        /* padding to align to 4 bytes */
        
// #ifdef Py_BUILD_CORE
// #endif

    /* Currently holds the GIL. Must be its own field to avoid data races */
    public native int holds_gil(); public native PyThreadState holds_gil(int setter);

    public native int _whence(); public native PyThreadState _whence(int setter);

    /* Thread state (_Py_THREAD_ATTACHED, _Py_THREAD_DETACHED, _Py_THREAD_SUSPENDED).
       See Include/internal/pycore_pystate.h for more details. */
    public native int state(); public native PyThreadState state(int setter);

    public native int py_recursion_remaining(); public native PyThreadState py_recursion_remaining(int setter);
    public native int py_recursion_limit(); public native PyThreadState py_recursion_limit(int setter);
    public native int recursion_headroom(); public native PyThreadState recursion_headroom(int setter); /* Allow 50 more calls to handle any errors. */

    /* 'tracing' keeps track of the execution depth when tracing/profiling.
       This is to prevent the actual trace/profile code from being recorded in
       the trace/profile. */
    public native int tracing(); public native PyThreadState tracing(int setter);
    public native int what_event(); public native PyThreadState what_event(int setter); /* The event currently being monitored, if any. */

    /* Pointer to currently executing frame. */
    public native @Cast("_PyInterpreterFrame*") Pointer current_frame(); public native PyThreadState current_frame(Pointer setter);

    public native Py_tracefunc c_profilefunc(); public native PyThreadState c_profilefunc(Py_tracefunc setter);
    public native Py_tracefunc c_tracefunc(); public native PyThreadState c_tracefunc(Py_tracefunc setter);
    public native PyObject c_profileobj(); public native PyThreadState c_profileobj(PyObject setter);
    public native PyObject c_traceobj(); public native PyThreadState c_traceobj(PyObject setter);

    /* The exception currently being raised */
    public native PyObject current_exception(); public native PyThreadState current_exception(PyObject setter);

    /* Pointer to the top of the exception stack for the exceptions
     * we may be currently handling.  (See _PyErr_StackItem above.)
     * This is never NULL. */
    public native _PyErr_StackItem exc_info(); public native PyThreadState exc_info(_PyErr_StackItem setter);

    public native PyObject dict(); public native PyThreadState dict(PyObject setter);  /* Stores per-thread state */

    public native int gilstate_counter(); public native PyThreadState gilstate_counter(int setter);

    public native PyObject async_exc(); public native PyThreadState async_exc(PyObject setter); /* Asynchronous exception to raise */
    public native @Cast("unsigned long") long thread_id(); public native PyThreadState thread_id(long setter); /* Thread id where this tstate was created */

    /* Native thread id where this tstate was created. This will be 0 except on
     * those platforms that have the notion of native thread id, for which the
     * macro PY_HAVE_THREAD_NATIVE_ID is then defined.
     */
    public native @Cast("unsigned long") long native_thread_id(); public native PyThreadState native_thread_id(long setter);

    public native PyObject delete_later(); public native PyThreadState delete_later(PyObject setter);

    /* Tagged pointer to top-most critical section, or zero if there is no
     * active critical section. Critical sections are only used in
     * `--disable-gil` builds (i.e., when Py_GIL_DISABLED is defined to 1). In the
     * default build, this field is always zero.
     */
    public native @Cast("uintptr_t") long critical_section(); public native PyThreadState critical_section(long setter);

    public native int coroutine_origin_tracking_depth(); public native PyThreadState coroutine_origin_tracking_depth(int setter);

    public native PyObject async_gen_firstiter(); public native PyThreadState async_gen_firstiter(PyObject setter);
    public native PyObject async_gen_finalizer(); public native PyThreadState async_gen_finalizer(PyObject setter);

    public native PyObject context(); public native PyThreadState context(PyObject setter);
    public native @Cast("uint64_t") long context_ver(); public native PyThreadState context_ver(long setter);

    /* Unique thread state id. */
    public native @Cast("uint64_t") long id(); public native PyThreadState id(long setter);

    public native _PyStackChunk datastack_chunk(); public native PyThreadState datastack_chunk(_PyStackChunk setter);
    public native PyObject datastack_top(int i); public native PyThreadState datastack_top(int i, PyObject setter);
    public native @Cast("PyObject**") PointerPointer datastack_top(); public native PyThreadState datastack_top(PointerPointer setter);
    public native PyObject datastack_limit(int i); public native PyThreadState datastack_limit(int i, PyObject setter);
    public native @Cast("PyObject**") PointerPointer datastack_limit(); public native PyThreadState datastack_limit(PointerPointer setter);
    /* XXX signal handlers should also be here */

    /* The following fields are here to avoid allocation during init.
       The data is exposed through PyThreadState pointer fields.
       These fields should not be accessed directly outside of init.
       This is indicated by an underscore prefix on the field names.

       All other PyInterpreterState pointer fields are populated when
       needed and default to NULL.
       */
       // Note some fields do not have a leading underscore for backward
       // compatibility.  See https://bugs.python.org/issue45953#msg412046.

    /* The thread's exception stack entry.  (Always the last entry.) */
    public native @ByRef _PyErr_StackItem exc_state(); public native PyThreadState exc_state(_PyErr_StackItem setter);

    public native PyObject current_executor(); public native PyThreadState current_executor(PyObject setter);

    public native @Cast("uint64_t") long dict_global_version(); public native PyThreadState dict_global_version(long setter);

    /* Used to store/retrieve `threading.local` keys/values for this thread */
    public native PyObject threading_local_key(); public native PyThreadState threading_local_key(PyObject setter);

    /* Used by `threading.local`s to be remove keys/values for dying threads.
       The PyThreadObject must hold the only reference to this value.
    */
    public native PyObject threading_local_sentinel(); public native PyThreadState threading_local_sentinel(PyObject setter);
    public native @ByRef _PyRemoteDebuggerSupport remote_debugger_support(); public native PyThreadState remote_debugger_support(_PyRemoteDebuggerSupport setter);
}
