// Targeted by JavaCPP version 1.4.3: DO NOT EDIT THIS FILE

package org.bytedeco.javacpp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class python extends org.bytedeco.javacpp.presets.python {
    static { Loader.load(); }

// Parsed from Python.h

// #ifndef Py_PYTHON_H
// #define Py_PYTHON_H
/* Since this is a "meta-include" file, no #ifdef __cplusplus / extern "C" { */

/* Include nearly all Python header files */

// #include "patchlevel.h"
// #include "pyconfig.h"
// #include "pymacconfig.h"

// #include <limits.h>

// #ifndef UCHAR_MAX
// #error "Something's broken.  UCHAR_MAX should be defined in limits.h."
// #endif

// #if UCHAR_MAX != 255
// #error "Python's source code assumes C's unsigned char is an 8-bit type."
// #endif

// #if defined(__sgi) && defined(WITH_THREAD) && !defined(_SGI_MP_SOURCE)
// #define _SGI_MP_SOURCE
// #endif

// #include <stdio.h>
// #ifndef NULL
// #   error "Python.h requires that stdio.h define NULL."
// #endif

// #include <string.h>
// #ifdef HAVE_ERRNO_H
// #include <errno.h>
// #endif
// #include <stdlib.h>
// #ifdef HAVE_UNISTD_H
// #include <unistd.h>
// #endif
// #ifdef HAVE_CRYPT_H
// #include <crypt.h>
// #endif

/* For size_t? */
// #ifdef HAVE_STDDEF_H
// #include <stddef.h>
// #endif

/* CAUTION:  Build setups should ensure that NDEBUG is defined on the
 * compiler command line when building Python in release mode; else
 * assert() calls won't be removed.
 */
// #include <assert.h>

// #include "pyport.h"
// #include "pymacro.h"

// #include "pyatomic.h"

/* Debug-mode build with pymalloc implies PYMALLOC_DEBUG.
 *  PYMALLOC_DEBUG is in error if pymalloc is not in use.
 */
// #if defined(Py_DEBUG) && defined(WITH_PYMALLOC) && !defined(PYMALLOC_DEBUG)
// #define PYMALLOC_DEBUG
// #endif
// #if defined(PYMALLOC_DEBUG) && !defined(WITH_PYMALLOC)
// #error "PYMALLOC_DEBUG requires WITH_PYMALLOC"
// #endif
// #include "pymath.h"
// #include "pytime.h"
// #include "pymem.h"

// #include "object.h"
// #include "objimpl.h"
// #include "typeslots.h"
// #include "pyhash.h"

// #include "pydebug.h"

// #include "bytearrayobject.h"
// #include "bytesobject.h"
// #include "unicodeobject.h"
// #include "longobject.h"
// #include "longintrepr.h"
// #include "boolobject.h"
// #include "floatobject.h"
// #include "complexobject.h"
// #include "rangeobject.h"
// #include "memoryobject.h"
// #include "tupleobject.h"
// #include "listobject.h"
// #include "dictobject.h"
// #include "odictobject.h"
// #include "enumobject.h"
// #include "setobject.h"
// #include "methodobject.h"
// #include "moduleobject.h"
// #include "funcobject.h"
// #include "classobject.h"
// #include "fileobject.h"
// #include "pycapsule.h"
// #include "traceback.h"
// #include "sliceobject.h"
// #include "cellobject.h"
// #include "iterobject.h"
// #include "genobject.h"
// #include "descrobject.h"
// #include "warnings.h"
// #include "weakrefobject.h"
// #include "structseq.h"
// #include "namespaceobject.h"

// #include "codecs.h"
// #include "pyerrors.h"

// #include "pystate.h"

// #include "pyarena.h"
// #include "modsupport.h"
// #include "pythonrun.h"
// #include "pylifecycle.h"
// #include "ceval.h"
// #include "sysmodule.h"
// #include "osmodule.h"
// #include "intrcheck.h"
// #include "import.h"

// #include "abstract.h"
// #include "bltinmodule.h"

// #include "compile.h"
// #include "eval.h"

// #include "pyctype.h"
// #include "pystrtod.h"
// #include "pystrcmp.h"
// #include "dtoa.h"
// #include "fileutils.h"
// #include "pyfpe.h"

// #endif /* !Py_PYTHON_H */


// Parsed from pyport.h

// #ifndef Py_PYPORT_H
// #define Py_PYPORT_H

// #include "pyconfig.h" /* include for defines */

// #include <inttypes.h>

/**************************************************************************
Symbols and macros to supply platform-independent interfaces to basic
C language & library operations whose spellings vary across platforms.
<p>
Please try to make documentation here as clear as possible:  by definition,
the stuff here is trying to illuminate C's darkest corners.
<p>
Config #defines referenced here:
<p>
SIGNED_RIGHT_SHIFT_ZERO_FILLS
Meaning:  To be defined iff i>>j does not extend the sign bit when i is a
          signed integral type and i < 0.
Used in:  Py_ARITHMETIC_RIGHT_SHIFT
<p>
Py_DEBUG
Meaning:  Extra checks compiled in for debug mode.
Used in:  Py_SAFE_DOWNCAST
<p>
**************************************************************************/

/* typedefs for some C9X-defined synonyms for integral types.
 *
 * The names in Python are exactly the same as the C9X names, except with a
 * Py_ prefix.  Until C9X is universally implemented, this is the only way
 * to ensure that Python gets reliable names that don't conflict with names
 * in non-Python code that are playing their own tricks to define the C9X
 * names.
 *
 * NOTE: don't go nuts here!  Python has no use for *most* of the C9X
 * integral synonyms.  Only define the ones we actually need.
 */

/* long long is required. Ensure HAVE_LONG_LONG is defined for compatibility. */
// #ifndef HAVE_LONG_LONG
public static final int HAVE_LONG_LONG = 1;
// #endif
// #ifndef PY_LONG_LONG
// #define PY_LONG_LONG long long
/* If LLONG_MAX is defined in limits.h, use that. */
public static native @MemberGetter int PY_LLONG_MIN();
public static final int PY_LLONG_MIN = PY_LLONG_MIN();
public static native @MemberGetter int PY_LLONG_MAX();
public static final int PY_LLONG_MAX = PY_LLONG_MAX();
public static native @MemberGetter int PY_ULLONG_MAX();
public static final int PY_ULLONG_MAX = PY_ULLONG_MAX();
// #endif

// #define PY_UINT32_T uint32_t
// #define PY_UINT64_T uint64_t

/* Signed variants of the above */
// #define PY_INT32_T int32_t
// #define PY_INT64_T int64_t

/* If PYLONG_BITS_IN_DIGIT is not defined then we'll use 30-bit digits if all
   the necessary integer types are available, and we're on a 64-bit platform
   (as determined by SIZEOF_VOID_P); otherwise we use 15-bit digits. */

// #ifndef PYLONG_BITS_IN_DIGIT
// #if SIZEOF_VOID_P >= 8
public static final int PYLONG_BITS_IN_DIGIT = 30;
// #else
// #endif
// #endif

/* uintptr_t is the C9X name for an unsigned integral type such that a
 * legitimate void* can be cast to uintptr_t and then back to void* again
 * without loss of information.  Similarly for intptr_t, wrt a signed
 * integral type.
 */

/* Py_ssize_t is a signed integral type such that sizeof(Py_ssize_t) ==
 * sizeof(size_t).  C99 doesn't define such a thing directly (size_t is an
 * unsigned integral type).  See PEP 353 for details.
 */
// #ifdef HAVE_SSIZE_T
// #elif SIZEOF_VOID_P == SIZEOF_SIZE_T
// #else
// #   error "Python needs a typedef for Py_ssize_t in pyport.h."
// #endif

/* Py_hash_t is the same size as a pointer. */
public static native @MemberGetter int SIZEOF_PY_HASH_T();
public static final int SIZEOF_PY_HASH_T = SIZEOF_PY_HASH_T();
/* Py_uhash_t is the unsigned equivalent needed to calculate numeric hash. */
public static native @MemberGetter int SIZEOF_PY_UHASH_T();
public static final int SIZEOF_PY_UHASH_T = SIZEOF_PY_UHASH_T();

/* Only used for compatibility with code that may not be PY_SSIZE_T_CLEAN. */
// #ifdef PY_SSIZE_T_CLEAN
// #else
// #endif

/* Largest possible value of size_t. */
public static native @MemberGetter int PY_SIZE_MAX();
public static final int PY_SIZE_MAX = PY_SIZE_MAX();

/* Largest positive value of type Py_ssize_t. */
public static native @MemberGetter int PY_SSIZE_T_MAX();
public static final int PY_SSIZE_T_MAX = PY_SSIZE_T_MAX();
/* Smallest negative value of type Py_ssize_t. */
public static native @MemberGetter int PY_SSIZE_T_MIN();
public static final int PY_SSIZE_T_MIN = PY_SSIZE_T_MIN();

/* PY_FORMAT_SIZE_T is a platform-specific modifier for use in a printf
 * format to convert an argument with the width of a size_t or Py_ssize_t.
 * C99 introduced "z" for this purpose, but not all platforms support that;
 * e.g., MS compilers use "I" instead.
 *
 * These "high level" Python format functions interpret "z" correctly on
 * all platforms (Python interprets the format string itself, and does whatever
 * the platform C requires to convert a size_t/Py_ssize_t argument):
 *
 *     PyBytes_FromFormat
 *     PyErr_Format
 *     PyBytes_FromFormatV
 *     PyUnicode_FromFormatV
 *
 * Lower-level uses require that you interpolate the correct format modifier
 * yourself (e.g., calling printf, fprintf, sprintf, PyOS_snprintf); for
 * example,
 *
 *     Py_ssize_t index;
 *     fprintf(stderr, "index %" PY_FORMAT_SIZE_T "d sucks\n", index);
 *
 * That will expand to %ld, or %Id, or to something else correct for a
 * Py_ssize_t on the platform.
 */
// #ifndef PY_FORMAT_SIZE_T
// #   if SIZEOF_SIZE_T == SIZEOF_INT && !defined(__APPLE__)
// #       define PY_FORMAT_SIZE_T ""
// #   elif SIZEOF_SIZE_T == SIZEOF_LONG
// #       define PY_FORMAT_SIZE_T "l"
// #   elif defined(MS_WINDOWS)
// #       define PY_FORMAT_SIZE_T "I"
// #   else
// #       error "This platform's pyconfig.h needs to define PY_FORMAT_SIZE_T"
// #   endif
// #endif

/* Py_LOCAL can be used instead of static to get the fastest possible calling
 * convention for functions that are local to a given module.
 *
 * Py_LOCAL_INLINE does the same thing, and also explicitly requests inlining,
 * for platforms that support that.
 *
 * If PY_LOCAL_AGGRESSIVE is defined before python.h is included, more
 * "aggressive" inlining/optimization is enabled for the entire module.  This
 * may lead to code bloat, and may slow things down for those reasons.  It may
 * also lead to errors, if the code relies on pointer aliasing.  Use with
 * care.
 *
 * NOTE: You can only use this for functions that are entirely local to a
 * module; functions that are exported via method tables, callbacks, etc,
 * should keep using static.
 */

// #if defined(_MSC_VER)
// #if defined(PY_LOCAL_AGGRESSIVE)
/* enable more aggressive optimization for visual studio */
// #pragma optimize("agtw", on)
// #endif
/* ignore warnings if the compiler decides not to inline a function */
// #pragma warning(disable: 4710)
/* fastest possible local call under MSVC */
// #define Py_LOCAL(type) static type __fastcall
// #define Py_LOCAL_INLINE(type) static __inline type __fastcall
// #elif defined(USE_INLINE)
// #define Py_LOCAL(type) static type
// #define Py_LOCAL_INLINE(type) static inline type
// #else
// #define Py_LOCAL(type) static type
// #define Py_LOCAL_INLINE(type) static type
// #endif

/* Py_MEMCPY is kept for backwards compatibility,
 * see https://bugs.python.org/issue28126 */
// #define Py_MEMCPY memcpy

// #include <stdlib.h>

// #ifdef HAVE_IEEEFP_H
// #include <ieeefp.h>  /* needed for 'finite' declaration on some platforms */
// #endif

// #include <math.h> /* Moved here from the math section, before extern "C" */

/********************************************
 * WRAPPER FOR <time.h> and/or <sys/time.h> *
 ********************************************/

// #ifdef TIME_WITH_SYS_TIME
// #include <sys/time.h>
// #include <time.h>
// #else /* !TIME_WITH_SYS_TIME */
// #ifdef HAVE_SYS_TIME_H
// #include <sys/time.h>
// #else /* !HAVE_SYS_TIME_H */
// #include <time.h>
// #endif /* !HAVE_SYS_TIME_H */
// #endif /* !TIME_WITH_SYS_TIME */


/******************************
 * WRAPPER FOR <sys/select.h> *
 ******************************/

/* NB caller must include <sys/types.h> */

// #ifdef HAVE_SYS_SELECT_H
// #include <sys/select.h>
// #endif /* !HAVE_SYS_SELECT_H */

/*******************************
 * stat() and fstat() fiddling *
 *******************************/

// #ifdef HAVE_SYS_STAT_H
// #include <sys/stat.h>
// #elif defined(HAVE_STAT_H)
// #include <stat.h>
// #endif

// #ifndef S_IFMT
/* VisualAge C/C++ Failed to Define MountType Field in sys/stat.h */
public static final int S_IFMT = 0170000;
// #endif

// #ifndef S_IFLNK
/* Windows doesn't define S_IFLNK but posixmodule.c maps
 * IO_REPARSE_TAG_SYMLINK to S_IFLNK */
public static final int S_IFLNK = 0120000;
// #endif

// #ifndef S_ISREG
// #define S_ISREG(x) (((x) & S_IFMT) == S_IFREG)
// #endif

// #ifndef S_ISDIR
// #define S_ISDIR(x) (((x) & S_IFMT) == S_IFDIR)
// #endif

// #ifndef S_ISCHR
// #define S_ISCHR(x) (((x) & S_IFMT) == S_IFCHR)
// #endif

// #ifdef __cplusplus
/* Move this down here since some C++ #include's don't like to be included
   inside an extern "C" */
// #endif


/* Py_ARITHMETIC_RIGHT_SHIFT
 * C doesn't define whether a right-shift of a signed integer sign-extends
 * or zero-fills.  Here a macro to force sign extension:
 * Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J)
 *    Return I >> J, forcing sign extension.  Arithmetically, return the
 *    floor of I/2**J.
 * Requirements:
 *    I should have signed integer type.  In the terminology of C99, this can
 *    be either one of the five standard signed integer types (signed char,
 *    short, int, long, long long) or an extended signed integer type.
 *    J is an integer >= 0 and strictly less than the number of bits in the
 *    type of I (because C doesn't define what happens for J outside that
 *    range either).
 *    TYPE used to specify the type of I, but is now ignored.  It's been left
 *    in for backwards compatibility with versions <= 2.6 or 3.0.
 * Caution:
 *    I may be evaluated more than once.
 */
// #ifdef SIGNED_RIGHT_SHIFT_ZERO_FILLS
// #define Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J)
//     ((I) < 0 ? -1-((-1-(I)) >> (J)) : (I) >> (J))
// #else
// #define Py_ARITHMETIC_RIGHT_SHIFT(TYPE, I, J) ((I) >> (J))
// #endif

/* Py_FORCE_EXPANSION(X)
 * "Simply" returns its argument.  However, macro expansions within the
 * argument are evaluated.  This unfortunate trickery is needed to get
 * token-pasting to work as desired in some cases.
 */
// #define Py_FORCE_EXPANSION(X) X

/* Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW)
 * Cast VALUE to type NARROW from type WIDE.  In Py_DEBUG mode, this
 * assert-fails if any information is lost.
 * Caution:
 *    VALUE may be evaluated more than once.
 */
// #ifdef Py_DEBUG
// #define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW)
//     (assert((WIDE)(NARROW)(VALUE) == (VALUE)), (NARROW)(VALUE))
// #else
// #define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) (NARROW)(VALUE)
// #endif

/* Py_SET_ERRNO_ON_MATH_ERROR(x)
 * If a libm function did not set errno, but it looks like the result
 * overflowed or not-a-number, set errno to ERANGE or EDOM.  Set errno
 * to 0 before calling a libm function, and invoke this macro after,
 * passing the function result.
 * Caution:
 *    This isn't reliable.  See Py_OVERFLOWED comments.
 *    X is evaluated more than once.
 */
// #if defined(__FreeBSD__) || defined(__OpenBSD__) || (defined(__hpux) && defined(__ia64))
// #define _Py_SET_EDOM_FOR_NAN(X) if (isnan(X)) errno = EDOM;
// #else
// #define _Py_SET_EDOM_FOR_NAN(X) ;
// #endif
// #define Py_SET_ERRNO_ON_MATH_ERROR(X)
//     do {
//         if (errno == 0) {
//             if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL)
//                 errno = ERANGE;
//             else _Py_SET_EDOM_FOR_NAN(X)
//         }
//     } while(0)

/* Py_SET_ERANGE_ON_OVERFLOW(x)
 * An alias of Py_SET_ERRNO_ON_MATH_ERROR for backward-compatibility.
 */
// #define Py_SET_ERANGE_IF_OVERFLOW(X) Py_SET_ERRNO_ON_MATH_ERROR(X)

/* Py_ADJUST_ERANGE1(x)
 * Py_ADJUST_ERANGE2(x, y)
 * Set errno to 0 before calling a libm function, and invoke one of these
 * macros after, passing the function result(s) (Py_ADJUST_ERANGE2 is useful
 * for functions returning complex results).  This makes two kinds of
 * adjustments to errno:  (A) If it looks like the platform libm set
 * errno=ERANGE due to underflow, clear errno. (B) If it looks like the
 * platform libm overflowed but didn't set errno, force errno to ERANGE.  In
 * effect, we're trying to force a useful implementation of C89 errno
 * behavior.
 * Caution:
 *    This isn't reliable.  See Py_OVERFLOWED comments.
 *    X and Y may be evaluated more than once.
 */
// #define Py_ADJUST_ERANGE1(X)
//     do {
//         if (errno == 0) {
//             if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL)
//                 errno = ERANGE;
//         }
//         else if (errno == ERANGE && (X) == 0.0)
//             errno = 0;
//     } while(0)

// #define Py_ADJUST_ERANGE2(X, Y)
//     do {
//         if ((X) == Py_HUGE_VAL || (X) == -Py_HUGE_VAL ||
//             (Y) == Py_HUGE_VAL || (Y) == -Py_HUGE_VAL) {
//                         if (errno == 0)
//                                 errno = ERANGE;
//         }
//         else if (errno == ERANGE)
//             errno = 0;
//     } while(0)

/*  The functions _Py_dg_strtod and _Py_dg_dtoa in Python/dtoa.c (which are
 *  required to support the short float repr introduced in Python 3.1) require
 *  that the floating-point unit that's being used for arithmetic operations
 *  on C doubles is set to use 53-bit precision.  It also requires that the
 *  FPU rounding mode is round-half-to-even, but that's less often an issue.
 *
 *  If your FPU isn't already set to 53-bit precision/round-half-to-even, and
 *  you want to make use of _Py_dg_strtod and _Py_dg_dtoa, then you should
 *
 *     #define HAVE_PY_SET_53BIT_PRECISION 1
 *
 *  and also give appropriate definitions for the following three macros:
 *
 *    _PY_SET_53BIT_PRECISION_START : store original FPU settings, and
 *        set FPU to 53-bit precision/round-half-to-even
 *    _PY_SET_53BIT_PRECISION_END : restore original FPU settings
 *    _PY_SET_53BIT_PRECISION_HEADER : any variable declarations needed to
 *        use the two macros above.
 *
 * The macros are designed to be used within a single C function: see
 * Python/pystrtod.c for an example of their use.
 */

/* get and set x87 control word for gcc/x86 */
// #ifdef HAVE_GCC_ASM_FOR_X87
// #endif

/* get and set x87 control word for VisualStudio/x86 */
// #if defined(_MSC_VER) && !defined(_WIN64) /* x87 not supported in 64-bit */
// #endif

// #ifdef HAVE_GCC_ASM_FOR_MC68881
// #endif

/* default definitions are empty */
// #ifndef HAVE_PY_SET_53BIT_PRECISION
// #define _Py_SET_53BIT_PRECISION_HEADER
// #define _Py_SET_53BIT_PRECISION_START
// #define _Py_SET_53BIT_PRECISION_END
// #endif

/* If we can't guarantee 53-bit precision, don't use the code
   in Python/dtoa.c, but fall back to standard code.  This
   means that repr of a float will be long (17 sig digits).

   Realistically, there are two things that could go wrong:

   (1) doubles aren't IEEE 754 doubles, or
   (2) we're on x86 with the rounding precision set to 64-bits
       (extended precision), and we don't know how to change
       the rounding precision.
 */

// #if !defined(DOUBLE_IS_LITTLE_ENDIAN_IEEE754) &&
//     !defined(DOUBLE_IS_BIG_ENDIAN_IEEE754) &&
//     !defined(DOUBLE_IS_ARM_MIXED_ENDIAN_IEEE754)
// #define PY_NO_SHORT_FLOAT_REPR
// #endif

/* double rounding is symptomatic of use of extended precision on x86.  If
   we're seeing double rounding, and we don't have any mechanism available for
   changing the FPU rounding precision, then don't use Python/dtoa.c. */
// #if defined(X87_DOUBLE_ROUNDING) && !defined(HAVE_PY_SET_53BIT_PRECISION)
// #define PY_NO_SHORT_FLOAT_REPR
// #endif


/* Py_DEPRECATED(version)
 * Declare a variable, type, or function deprecated.
 * Usage:
 *    extern int old_var Py_DEPRECATED(2.3);
 *    typedef int T1 Py_DEPRECATED(2.4);
 *    extern int x() Py_DEPRECATED(2.5);
 */
// #if defined(__GNUC__) && ((__GNUC__ >= 4) ||
//               (__GNUC__ == 3) && (__GNUC_MINOR__ >= 1))
// #define Py_DEPRECATED(VERSION_UNUSED) __attribute__((__deprecated__))
// #else
// #define Py_DEPRECATED(VERSION_UNUSED)
// #endif

/**************************************************************************
Prototypes that are missing from the standard include files on some systems
(and possibly only some versions of such systems.)
<p>
Please be conservative with adding new ones, document them and enclose them
in platform-specific #ifdefs.
**************************************************************************/

// #ifdef SOLARIS
// #endif

// #ifdef HAVE__GETPTY
// #endif

/* On QNX 6, struct termio must be declared by including sys/termio.h
   if TCGETA, TCSETA, TCSETAW, or TCSETAF are used.  sys/termio.h must
   be included before termios.h or it will generate an error. */
// #if defined(HAVE_SYS_TERMIO_H) && !defined(__hpux)
// #include <sys/termio.h>
// #endif

// #if defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY)
// #endif /* defined(HAVE_OPENPTY) || defined(HAVE_FORKPTY) */


/* On 4.4BSD-descendants, ctype functions serves the whole range of
 * wchar_t character set rather than single byte code points only.
 * This characteristic can break some operations of string object
 * including str.upper() and str.split() on UTF-8 locales.  This
 * workaround was provided by Tim Robbins of FreeBSD project.
 */

// #ifdef __FreeBSD__
// #include <osreldate.h>
// #if (__FreeBSD_version >= 500040 && __FreeBSD_version < 602113) ||
//     (__FreeBSD_version >= 700000 && __FreeBSD_version < 700054) ||
//     (__FreeBSD_version >= 800000 && __FreeBSD_version < 800001)
// # define _PY_PORT_CTYPE_UTF8_ISSUE
// #endif
// #endif


// #if defined(__APPLE__)
// # define _PY_PORT_CTYPE_UTF8_ISSUE
// #endif

// #ifdef _PY_PORT_CTYPE_UTF8_ISSUE
// #endif


/* Declarations for symbol visibility.

  PyAPI_FUNC(type): Declares a public Python API function and return type
  PyAPI_DATA(type): Declares public Python data and its type
  PyMODINIT_FUNC:   A Python module init function.  If these functions are
                    inside the Python core, they are private to the core.
                    If in an extension module, it may be declared with
                    external linkage depending on the platform.

  As a number of platforms support/require "__declspec(dllimport/dllexport)",
  we support a HAVE_DECLSPEC_DLL macro to save duplication.
*/

/*
  All windows ports, except cygwin, are handled in PC/pyconfig.h.

  Cygwin is the only other autoconf platform requiring special
  linkage handling and it uses __declspec().
*/
// #if defined(__CYGWIN__)
// #       define HAVE_DECLSPEC_DLL
// #endif

/* only get special linkage if built as shared or platform is Cygwin */
// #if defined(Py_ENABLE_SHARED) || defined(__CYGWIN__)
// #       if defined(HAVE_DECLSPEC_DLL)
// #               ifdef Py_BUILD_CORE
// #                       define PyAPI_FUNC(RTYPE) __declspec(dllexport) RTYPE
// #                       define PyAPI_DATA(RTYPE) extern __declspec(dllexport) RTYPE
        /* module init functions inside the core need no external linkage */
        /* except for Cygwin to handle embedding */
// #                       if defined(__CYGWIN__)
// #                               define PyMODINIT_FUNC __declspec(dllexport) PyObject*
// #                       else /* __CYGWIN__ */
// #                               define PyMODINIT_FUNC PyObject*
// #                       endif /* __CYGWIN__ */
// #               else /* Py_BUILD_CORE */
        /* Building an extension module, or an embedded situation */
        /* public Python functions and data are imported */
        /* Under Cygwin, auto-import functions to prevent compilation */
        /* failures similar to those described at the bottom of 4.1: */
        /* http://docs.python.org/extending/windows.html#a-cookbook-approach */
// #                       if !defined(__CYGWIN__)
// #                               define PyAPI_FUNC(RTYPE) __declspec(dllimport) RTYPE
// #                       endif /* !__CYGWIN__ */
// #                       define PyAPI_DATA(RTYPE) extern __declspec(dllimport) RTYPE
        /* module init functions outside the core must be exported */
// #                       if defined(__cplusplus)
// #                               define PyMODINIT_FUNC extern "C" __declspec(dllexport) PyObject*
// #                       else /* __cplusplus */
// #                               define PyMODINIT_FUNC __declspec(dllexport) PyObject*
// #                       endif /* __cplusplus */
// #               endif /* Py_BUILD_CORE */
// #       endif /* HAVE_DECLSPEC */
// #endif /* Py_ENABLE_SHARED */

/* If no external linkage macros defined by now, create defaults */
// #ifndef PyAPI_FUNC
// #       define PyAPI_FUNC(RTYPE) RTYPE
// #endif
// #ifndef PyAPI_DATA
// #       define PyAPI_DATA(RTYPE) extern RTYPE
// #endif
// #ifndef PyMODINIT_FUNC
// #       if defined(__cplusplus)
// #               define PyMODINIT_FUNC extern "C" PyObject*
// #       else /* __cplusplus */
// #               define PyMODINIT_FUNC PyObject*
// #       endif /* __cplusplus */
// #endif

/* limits.h constants that may be missing */

// #ifndef INT_MAX
public static final int INT_MAX = 2147483647;
// #endif

// #ifndef LONG_MAX
// #if SIZEOF_LONG == 4
public static final long LONG_MAX = 0X7FFFFFFFL;
// #elif SIZEOF_LONG == 8
// #else
// #error "could not set LONG_MAX in pyport.h"
// #endif
// #endif

// #ifndef LONG_MIN
public static final long LONG_MIN = (-LONG_MAX-1);
// #endif

// #ifndef LONG_BIT
public static native @MemberGetter int LONG_BIT();
public static final int LONG_BIT = LONG_BIT();
// #endif

// #if LONG_BIT != 8 * SIZEOF_LONG
/* 04-Oct-2000 LONG_BIT is apparently (mis)defined as 64 on some recent
 * 32-bit platforms using gcc.  We try to catch that here at compile-time
 * rather than waiting for integer multiplication to trigger bogus
 * overflows.
 */
// #error "LONG_BIT definition appears wrong for platform (bad gcc/glibc config?)."
// #endif

// #ifdef __cplusplus
// #endif

/*
 * Hide GCC attributes from compilers that don't support them.
 */
// #if (!defined(__GNUC__) || __GNUC__ < 2 ||
//      (__GNUC__ == 2 && __GNUC_MINOR__ < 7) )
// #define Py_GCC_ATTRIBUTE(x)
// #else
// #define Py_GCC_ATTRIBUTE(x) __attribute__(x)
// #endif

/*
 * Specify alignment on compilers that support it.
 */
// #if defined(__GNUC__) && __GNUC__ >= 3
// #define Py_ALIGNED(x) __attribute__((aligned(x)))
// #else
// #define Py_ALIGNED(x)
// #endif

/* Eliminate end-of-loop code not reached warnings from SunPro C
 * when using do{...}while(0) macros
 */
// #ifdef __SUNPRO_C
// #pragma error_messages (off,E_END_OF_LOOP_CODE_NOT_REACHED)
// #endif

// #ifndef Py_LL
// #define Py_LL(x) x##LL
// #endif

// #ifndef Py_ULL
// #define Py_ULL(x) Py_LL(x##U)
// #endif

// #define Py_VA_COPY va_copy

/*
 * Convenient macros to deal with endianness of the platform. WORDS_BIGENDIAN is
 * detected by configure and defined in pyconfig.h. The code in pyconfig.h
 * also takes care of Apple's universal builds.
 */

// #ifdef WORDS_BIGENDIAN
public static final int PY_BIG_ENDIAN = 1;
public static final int PY_LITTLE_ENDIAN = 0;
// #else
// #endif

// #ifdef Py_BUILD_CORE
/*
 * Macros to protect CRT calls against instant termination when passed an
 * invalid parameter (issue23524).
 */
// #if defined _MSC_VER && _MSC_VER >= 1900

// #else

// #define _Py_BEGIN_SUPPRESS_IPH
// #define _Py_END_SUPPRESS_IPH

// #endif /* _MSC_VER >= 1900 */
// #endif /* Py_BUILD_CORE */

// #ifdef __ANDROID__
// #include <android/api-evel.h>
// #endif

// #endif /* Py_PYPORT_H */


// Parsed from pymem.h

/* The PyMem_ family:  low-level memory allocation interfaces.
   See objimpl.h for the PyObject_ memory family.
*/

// #ifndef Py_PYMEM_H
// #define Py_PYMEM_H

// #include "pyport.h"

// #ifdef __cplusplus
// #endif

// #ifndef Py_LIMITED_API
@NoException public static native Pointer PyMem_RawMalloc(@Cast("size_t") long size);
@NoException public static native Pointer PyMem_RawCalloc(@Cast("size_t") long nelem, @Cast("size_t") long elsize);
@NoException public static native Pointer PyMem_RawRealloc(Pointer ptr, @Cast("size_t") long new_size);
@NoException public static native void PyMem_RawFree(Pointer ptr);

/* Configure the Python memory allocators. Pass NULL to use default
   allocators. */
@NoException public static native int _PyMem_SetupAllocators(@Cast("const char*") BytePointer opt);
@NoException public static native int _PyMem_SetupAllocators(String opt);

// #ifdef WITH_PYMALLOC
@NoException public static native int _PyMem_PymallocEnabled();
// #endif

/* Identifier of an address space (domain) in tracemalloc */

/* Track an allocated memory block in the tracemalloc module.
   Return 0 on success, return -1 on error (failed to allocate memory to store
   the trace).

   Return -2 if tracemalloc is disabled.

   If memory block is already tracked, update the existing trace. */
@NoException public static native int _PyTraceMalloc_Track(
    @Cast("_PyTraceMalloc_domain_t") int domain,
    @Cast("uintptr_t") long ptr,
    @Cast("size_t") long size);

/* Untrack an allocated memory block in the tracemalloc module.
   Do nothing if the block was not tracked.

   Return -2 if tracemalloc is disabled, otherwise return 0. */
@NoException public static native int _PyTraceMalloc_Untrack(
    @Cast("_PyTraceMalloc_domain_t") int domain,
    @Cast("uintptr_t") long ptr);

/* Get the traceback where a memory block was allocated.

   Return a tuple of (filename: str, lineno: int) tuples.

   Return None if the tracemalloc module is disabled or if the memory block
   is not tracked by tracemalloc.

   Raise an exception and return NULL on error. */
@NoException public static native PyObject _PyTraceMalloc_GetTraceback(
    @Cast("_PyTraceMalloc_domain_t") int domain,
    @Cast("uintptr_t") long ptr);
// #endif   /* !Py_LIMITED_API */


/* BEWARE:

   Each interface exports both functions and macros.  Extension modules should
   use the functions, to ensure binary compatibility across Python versions.
   Because the Python implementation is free to change internal details, and
   the macros may (or may not) expose details for speed, if you do use the
   macros you must recompile your extensions with each Python release.

   Never mix calls to PyMem_ with calls to the platform malloc/realloc/
   calloc/free.  For example, on Windows different DLLs may end up using
   different heaps, and if you use PyMem_Malloc you'll get the memory from the
   heap used by the Python DLL; it could be a disaster if you free()'ed that
   directly in your own extension.  Using PyMem_Free instead ensures Python
   can return the memory to the proper heap.  As another example, in
   PYMALLOC_DEBUG mode, Python wraps all calls to all PyMem_ and PyObject_
   memory functions in special debugging wrappers that add additional
   debugging info to dynamic memory blocks.  The system routines have no idea
   what to do with that stuff, and the Python wrappers have no idea what to do
   with raw blocks obtained directly by the system routines then.

   The GIL must be held when using these APIs.
*/

/*
 * Raw memory interface
 * ====================
 */

/* Functions

   Functions supplying platform-independent semantics for malloc/realloc/
   free.  These functions make sure that allocating 0 bytes returns a distinct
   non-NULL pointer (whenever possible -- if we're flat out of memory, NULL
   may be returned), even if the platform malloc and realloc don't.
   Returned pointers must be checked for NULL explicitly.  No action is
   performed on failure (no exception is set, no warning is printed, etc).
*/

@NoException public static native Pointer PyMem_Malloc(@Cast("size_t") long size);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
@NoException public static native Pointer PyMem_Calloc(@Cast("size_t") long nelem, @Cast("size_t") long elsize);
// #endif
@NoException public static native Pointer PyMem_Realloc(Pointer ptr, @Cast("size_t") long new_size);
@NoException public static native void PyMem_Free(Pointer ptr);

// #ifndef Py_LIMITED_API
@NoException public static native @Cast("char*") BytePointer _PyMem_RawStrdup(@Cast("const char*") BytePointer str);
@NoException public static native @Cast("char*") ByteBuffer _PyMem_RawStrdup(String str);
@NoException public static native @Cast("char*") BytePointer _PyMem_Strdup(@Cast("const char*") BytePointer str);
@NoException public static native @Cast("char*") ByteBuffer _PyMem_Strdup(String str);
// #endif

/* Macros. */

/* PyMem_MALLOC(0) means malloc(1). Some systems would return NULL
   for malloc(0), which would be treated as an error. Some platforms
   would return a pointer with no memory behind it, which would break
   pymalloc. To solve these problems, allocate an extra byte. */
/* Returns NULL to indicate error if a negative size or size larger than
   Py_ssize_t can represent is supplied.  Helps prevents security holes. */
// #define PyMem_MALLOC(n)         PyMem_Malloc(n)
// #define PyMem_REALLOC(p, n)     PyMem_Realloc(p, n)
// #define PyMem_FREE(p)           PyMem_Free(p)

/*
 * Type-oriented memory interface
 * ==============================
 *
 * Allocate memory for n objects of the given type.  Returns a new pointer
 * or NULL if the request was too large or memory allocation failed.  Use
 * these macros rather than doing the multiplication yourself so that proper
 * overflow checking is always done.
 */

// #define PyMem_New(type, n)
//   ( ((size_t)(n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL :
// 	( (type *) PyMem_Malloc((n) * sizeof(type)) ) )
// #define PyMem_NEW(type, n)
//   ( ((size_t)(n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL :
// 	( (type *) PyMem_MALLOC((n) * sizeof(type)) ) )

/*
 * The value of (p) is always clobbered by this macro regardless of success.
 * The caller MUST check if (p) is NULL afterwards and deal with the memory
 * error if so.  This means the original value of (p) MUST be saved for the
 * caller's memory error handler to not lose track of it.
 */
// #define PyMem_Resize(p, type, n)
//   ( (p) = ((size_t)(n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL :
// 	(type *) PyMem_Realloc((p), (n) * sizeof(type)) )
// #define PyMem_RESIZE(p, type, n)
//   ( (p) = ((size_t)(n) > PY_SSIZE_T_MAX / sizeof(type)) ? NULL :
// 	(type *) PyMem_REALLOC((p), (n) * sizeof(type)) )

/* PyMem{Del,DEL} are left over from ancient days, and shouldn't be used
 * anymore.  They're just confusing aliases for PyMem_{Free,FREE} now.
 */
// #define PyMem_Del		PyMem_Free
// #define PyMem_DEL		PyMem_FREE

// #ifndef Py_LIMITED_API
/** enum PyMemAllocatorDomain */
public static final int
    /* PyMem_RawMalloc(), PyMem_RawRealloc() and PyMem_RawFree() */
    PYMEM_DOMAIN_RAW = 0,

    /* PyMem_Malloc(), PyMem_Realloc() and PyMem_Free() */
    PYMEM_DOMAIN_MEM = 1,

    /* PyObject_Malloc(), PyObject_Realloc() and PyObject_Free() */
    PYMEM_DOMAIN_OBJ = 2;

public static class PyMemAllocatorEx extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyMemAllocatorEx() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyMemAllocatorEx(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyMemAllocatorEx(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyMemAllocatorEx position(long position) {
        return (PyMemAllocatorEx)super.position(position);
    }

    /* user context passed as the first argument to the 4 functions */
    public native Pointer ctx(); public native PyMemAllocatorEx ctx(Pointer ctx);

    /* allocate a memory block */
    public static class Malloc_Pointer_long extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Malloc_Pointer_long(Pointer p) { super(p); }
        protected Malloc_Pointer_long() { allocate(); }
        private native void allocate();
        public native Pointer call(Pointer ctx, @Cast("size_t") long size);
    }
    public native Malloc_Pointer_long malloc(); public native PyMemAllocatorEx malloc(Malloc_Pointer_long malloc);

    /* allocate a memory block initialized by zeros */
    public static class Calloc_Pointer_long_long extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Calloc_Pointer_long_long(Pointer p) { super(p); }
        protected Calloc_Pointer_long_long() { allocate(); }
        private native void allocate();
        public native Pointer call(Pointer ctx, @Cast("size_t") long nelem, @Cast("size_t") long elsize);
    }
    public native Calloc_Pointer_long_long calloc(); public native PyMemAllocatorEx calloc(Calloc_Pointer_long_long calloc);

    /* allocate or resize a memory block */
    public static class Realloc_Pointer_Pointer_long extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Realloc_Pointer_Pointer_long(Pointer p) { super(p); }
        protected Realloc_Pointer_Pointer_long() { allocate(); }
        private native void allocate();
        public native Pointer call(Pointer ctx, Pointer ptr, @Cast("size_t") long new_size);
    }
    public native Realloc_Pointer_Pointer_long realloc(); public native PyMemAllocatorEx realloc(Realloc_Pointer_Pointer_long realloc);

    /* release a memory block */
    public static class Free_Pointer_Pointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    Free_Pointer_Pointer(Pointer p) { super(p); }
        protected Free_Pointer_Pointer() { allocate(); }
        private native void allocate();
        public native void call(Pointer ctx, Pointer ptr);
    }
    public native Free_Pointer_Pointer free(); public native PyMemAllocatorEx free(Free_Pointer_Pointer free);
}

/* Get the memory block allocator of the specified domain. */
@NoException public static native void PyMem_GetAllocator(@Cast("PyMemAllocatorDomain") int domain,
                                    PyMemAllocatorEx allocator);

/* Set the memory block allocator of the specified domain.

   The new allocator must return a distinct non-NULL pointer when requesting
   zero bytes.

   For the PYMEM_DOMAIN_RAW domain, the allocator must be thread-safe: the GIL
   is not held when the allocator is called.

   If the new allocator is not a hook (don't call the previous allocator), the
   PyMem_SetupDebugHooks() function must be called to reinstall the debug hooks
   on top on the new allocator. */
@NoException public static native void PyMem_SetAllocator(@Cast("PyMemAllocatorDomain") int domain,
                                    PyMemAllocatorEx allocator);

/* Setup hooks to detect bugs in the following Python memory allocator
   functions:

   - PyMem_RawMalloc(), PyMem_RawRealloc(), PyMem_RawFree()
   - PyMem_Malloc(), PyMem_Realloc(), PyMem_Free()
   - PyObject_Malloc(), PyObject_Realloc() and PyObject_Free()

   Newly allocated memory is filled with the byte 0xCB, freed memory is filled
   with the byte 0xDB. Additionnal checks:

   - detect API violations, ex: PyObject_Free() called on a buffer allocated
     by PyMem_Malloc()
   - detect write before the start of the buffer (buffer underflow)
   - detect write after the end of the buffer (buffer overflow)

   The function does nothing if Python is not compiled is debug mode. */
@NoException public static native void PyMem_SetupDebugHooks();
// #endif

// #ifdef __cplusplus
// #endif

// #endif /* !Py_PYMEM_H */


// Parsed from descrobject.h

/* Descriptors */
// #ifndef Py_DESCROBJECT_H
// #define Py_DESCROBJECT_H
// #ifdef __cplusplus
// #endif

public static class getter extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    getter(Pointer p) { super(p); }
    protected getter() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject arg0, Pointer arg1);
}
public static class setter extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    setter(Pointer p) { super(p); }
    protected setter() { allocate(); }
    private native void allocate();
    public native int call(PyObject arg0, PyObject arg1, Pointer arg2);
}

public static class PyGetSetDef extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyGetSetDef() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyGetSetDef(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyGetSetDef(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyGetSetDef position(long position) {
        return (PyGetSetDef)super.position(position);
    }

    public native @Cast("char*") BytePointer name(); public native PyGetSetDef name(BytePointer name);
    public native getter get(); public native PyGetSetDef get(getter get);
    public native setter set(); public native PyGetSetDef set(setter set);
    public native @Cast("char*") BytePointer doc(); public native PyGetSetDef doc(BytePointer doc);
    public native Pointer closure(); public native PyGetSetDef closure(Pointer closure);
}

// #ifndef Py_LIMITED_API
public static class wrapperfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    wrapperfunc(Pointer p) { super(p); }
    protected wrapperfunc() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject self, PyObject args,
                                 Pointer wrapped);
}

public static class wrapperfunc_kwds extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    wrapperfunc_kwds(Pointer p) { super(p); }
    protected wrapperfunc_kwds() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject self, PyObject args,
                                      Pointer wrapped, PyObject kwds);
}

public static class wrapperbase extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public wrapperbase() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public wrapperbase(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public wrapperbase(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public wrapperbase position(long position) {
        return (wrapperbase)super.position(position);
    }

    public native @Cast("char*") BytePointer name(); public native wrapperbase name(BytePointer name);
    public native int offset(); public native wrapperbase offset(int offset);
    public native Pointer function(); public native wrapperbase function(Pointer function);
    public native wrapperfunc wrapper(); public native wrapperbase wrapper(wrapperfunc wrapper);
    public native @Cast("char*") BytePointer doc(); public native wrapperbase doc(BytePointer doc);
    public native int flags(); public native wrapperbase flags(int flags);
    public native PyObject name_strobj(); public native wrapperbase name_strobj(PyObject name_strobj);
}

/* Flags for above struct */
public static final int PyWrapperFlag_KEYWORDS = 1; /* wrapper function takes keyword args */

/* Various kinds of descriptor objects */

public static class PyDescrObject extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyDescrObject() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyDescrObject(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyDescrObject(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyDescrObject position(long position) {
        return (PyDescrObject)super.position(position);
    }

    public native PyTypeObject d_type(); public native PyDescrObject d_type(PyTypeObject d_type);
    public native PyObject d_name(); public native PyDescrObject d_name(PyObject d_name);
    public native PyObject d_qualname(); public native PyDescrObject d_qualname(PyObject d_qualname);
}

// #define PyDescr_COMMON PyDescrObject d_common

// #define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
// #define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)

public static class PyMethodDescrObject extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyMethodDescrObject() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyMethodDescrObject(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyMethodDescrObject(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyMethodDescrObject position(long position) {
        return (PyMethodDescrObject)super.position(position);
    }

    public native @ByRef PyDescrObject d_common(); public native PyMethodDescrObject d_common(PyDescrObject d_common);
    public native PyMethodDef d_method(); public native PyMethodDescrObject d_method(PyMethodDef d_method);
}

public static class PyMemberDescrObject extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyMemberDescrObject() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyMemberDescrObject(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyMemberDescrObject(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyMemberDescrObject position(long position) {
        return (PyMemberDescrObject)super.position(position);
    }

    public native @ByRef PyDescrObject d_common(); public native PyMemberDescrObject d_common(PyDescrObject d_common);
    public native PyMemberDef d_member(); public native PyMemberDescrObject d_member(PyMemberDef d_member);
}

public static class PyGetSetDescrObject extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyGetSetDescrObject() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyGetSetDescrObject(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyGetSetDescrObject(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyGetSetDescrObject position(long position) {
        return (PyGetSetDescrObject)super.position(position);
    }

    public native @ByRef PyDescrObject d_common(); public native PyGetSetDescrObject d_common(PyDescrObject d_common);
    public native PyGetSetDef d_getset(); public native PyGetSetDescrObject d_getset(PyGetSetDef d_getset);
}

public static class PyWrapperDescrObject extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyWrapperDescrObject() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyWrapperDescrObject(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyWrapperDescrObject(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyWrapperDescrObject position(long position) {
        return (PyWrapperDescrObject)super.position(position);
    }

    public native @ByRef PyDescrObject d_common(); public native PyWrapperDescrObject d_common(PyDescrObject d_common);
    public native wrapperbase d_base(); public native PyWrapperDescrObject d_base(wrapperbase d_base);
    public native Pointer d_wrapped(); public native PyWrapperDescrObject d_wrapped(Pointer d_wrapped); /* This can be any function pointer */
}
// #endif /* Py_LIMITED_API */

public static native @ByRef PyTypeObject PyClassMethodDescr_Type(); public static native void PyClassMethodDescr_Type(PyTypeObject PyClassMethodDescr_Type);
public static native @ByRef PyTypeObject PyGetSetDescr_Type(); public static native void PyGetSetDescr_Type(PyTypeObject PyGetSetDescr_Type);
public static native @ByRef PyTypeObject PyMemberDescr_Type(); public static native void PyMemberDescr_Type(PyTypeObject PyMemberDescr_Type);
public static native @ByRef PyTypeObject PyMethodDescr_Type(); public static native void PyMethodDescr_Type(PyTypeObject PyMethodDescr_Type);
public static native @ByRef PyTypeObject PyWrapperDescr_Type(); public static native void PyWrapperDescr_Type(PyTypeObject PyWrapperDescr_Type);
public static native @ByRef PyTypeObject PyDictProxy_Type(); public static native void PyDictProxy_Type(PyTypeObject PyDictProxy_Type);
// #ifndef Py_LIMITED_API
public static native @ByRef PyTypeObject _PyMethodWrapper_Type(); public static native void _PyMethodWrapper_Type(PyTypeObject _PyMethodWrapper_Type);
// #endif /* Py_LIMITED_API */

@NoException public static native PyObject PyDescr_NewMethod(PyTypeObject arg0, PyMethodDef arg1);
@NoException public static native PyObject PyDescr_NewClassMethod(PyTypeObject arg0, PyMethodDef arg1); /* forward declaration for following prototype */
@NoException public static native PyObject PyDescr_NewMember(PyTypeObject arg0,
                                               PyMemberDef arg1);
@NoException public static native PyObject PyDescr_NewGetSet(PyTypeObject arg0,
                                               PyGetSetDef arg1);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyDescr_NewWrapper(PyTypeObject arg0,
                                                wrapperbase arg1, Pointer arg2);
// #define PyDescr_IsData(d) (Py_TYPE(d)->tp_descr_set != NULL)
// #endif

@NoException public static native PyObject PyDictProxy_New(PyObject arg0);
@NoException public static native PyObject PyWrapper_New(PyObject arg0, PyObject arg1);


public static native @ByRef PyTypeObject PyProperty_Type(); public static native void PyProperty_Type(PyTypeObject PyProperty_Type);
// #ifdef __cplusplus
// #endif
// #endif /* !Py_DESCROBJECT_H */



// Parsed from dictobject.h

// #ifndef Py_DICTOBJECT_H
// #define Py_DICTOBJECT_H
// #ifdef __cplusplus
// #endif


/* Dictionary object type -- mapping from hashable object to object */

/* The distribution includes a separate file, Objects/dictnotes.txt,
   describing explorations into dictionary design and optimization.
   It covers typical dictionary use patterns, the parameters for
   tuning dictionaries, and several ideas for possible optimizations.
*/

// #ifndef Py_LIMITED_API

@Opaque public static class PyDictKeysObject extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public PyDictKeysObject() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyDictKeysObject(Pointer p) { super(p); }
}

/* The ma_values pointer is NULL for a combined table
 * or points to an array of PyObject* for a split table
 */
public static class PyDictObject extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyDictObject() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyDictObject(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyDictObject(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyDictObject position(long position) {
        return (PyDictObject)super.position(position);
    }

    public native @Cast("Py_ssize_t") long ma_used(); public native PyDictObject ma_used(long ma_used);

    /* Dictionary version: globally unique, value change each time
       the dictionary is modified */
    public native @Cast("uint64_t") long ma_version_tag(); public native PyDictObject ma_version_tag(long ma_version_tag);

    public native PyDictKeysObject ma_keys(); public native PyDictObject ma_keys(PyDictKeysObject ma_keys);

    /* If ma_values is NULL, the table is "combined": keys and values
       are stored in ma_keys.

       If ma_values is not NULL, the table is splitted:
       keys are stored in ma_keys and values are stored in ma_values */
    public native PyObject ma_values(int i); public native PyDictObject ma_values(int i, PyObject ma_values);
    public native @Cast("PyObject**") PointerPointer ma_values(); public native PyDictObject ma_values(PointerPointer ma_values);
}

public static class _PyDictViewObject extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _PyDictViewObject() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _PyDictViewObject(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _PyDictViewObject(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _PyDictViewObject position(long position) {
        return (_PyDictViewObject)super.position(position);
    }

    public native PyDictObject dv_dict(); public native _PyDictViewObject dv_dict(PyDictObject dv_dict);
}

// #endif /* Py_LIMITED_API */

public static native @ByRef PyTypeObject PyDict_Type(); public static native void PyDict_Type(PyTypeObject PyDict_Type);
public static native @ByRef PyTypeObject PyDictIterKey_Type(); public static native void PyDictIterKey_Type(PyTypeObject PyDictIterKey_Type);
public static native @ByRef PyTypeObject PyDictIterValue_Type(); public static native void PyDictIterValue_Type(PyTypeObject PyDictIterValue_Type);
public static native @ByRef PyTypeObject PyDictIterItem_Type(); public static native void PyDictIterItem_Type(PyTypeObject PyDictIterItem_Type);
public static native @ByRef PyTypeObject PyDictKeys_Type(); public static native void PyDictKeys_Type(PyTypeObject PyDictKeys_Type);
public static native @ByRef PyTypeObject PyDictItems_Type(); public static native void PyDictItems_Type(PyTypeObject PyDictItems_Type);
public static native @ByRef PyTypeObject PyDictValues_Type(); public static native void PyDictValues_Type(PyTypeObject PyDictValues_Type);

// #define PyDict_Check(op)
//                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_DICT_SUBCLASS)
// #define PyDict_CheckExact(op) (Py_TYPE(op) == &PyDict_Type)
// #define PyDictKeys_Check(op) PyObject_TypeCheck(op, &PyDictKeys_Type)
// #define PyDictItems_Check(op) PyObject_TypeCheck(op, &PyDictItems_Type)
// #define PyDictValues_Check(op) PyObject_TypeCheck(op, &PyDictValues_Type)
/* This excludes Values, since they are not sets. */
// # define PyDictViewSet_Check(op)
//     (PyDictKeys_Check(op) || PyDictItems_Check(op))


@NoException public static native PyObject PyDict_New();
@NoException public static native PyObject PyDict_GetItem(PyObject mp, PyObject key);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyDict_GetItem_KnownHash(PyObject mp, PyObject key,
                                       @Cast("Py_hash_t") long hash);
// #endif
@NoException public static native PyObject PyDict_GetItemWithError(PyObject mp, PyObject key);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyDict_GetItemIdWithError(PyObject dp,
                                                  _Py_Identifier key);
@NoException public static native PyObject PyDict_SetDefault(
    PyObject mp, PyObject key, PyObject defaultobj);
// #endif
@NoException public static native int PyDict_SetItem(PyObject mp, PyObject key, PyObject item);
// #ifndef Py_LIMITED_API
@NoException public static native int _PyDict_SetItem_KnownHash(PyObject mp, PyObject key,
                                          PyObject item, @Cast("Py_hash_t") long hash);
// #endif
@NoException public static native int PyDict_DelItem(PyObject mp, PyObject key);
// #ifndef Py_LIMITED_API
@NoException public static native int _PyDict_DelItem_KnownHash(PyObject mp, PyObject key,
                                          @Cast("Py_hash_t") long hash);
public static class Predicate_PyObject extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Predicate_PyObject(Pointer p) { super(p); }
    protected Predicate_PyObject() { allocate(); }
    private native void allocate();
    public native int call(PyObject value);
}
@NoException public static native int _PyDict_DelItemIf(PyObject mp, PyObject key,
                                  Predicate_PyObject predicate);
// #endif
@NoException public static native void PyDict_Clear(PyObject mp);
@NoException public static native int PyDict_Next(
    PyObject mp, @Cast("Py_ssize_t*") SizeTPointer pos, @Cast("PyObject**") PointerPointer key, @Cast("PyObject**") PointerPointer value);
@NoException public static native int PyDict_Next(
    PyObject mp, @Cast("Py_ssize_t*") SizeTPointer pos, @ByPtrPtr PyObject key, @ByPtrPtr PyObject value);
// #ifndef Py_LIMITED_API

@NoException public static native PyObject PyObject_GenericGetDict(PyObject arg0, Pointer arg1);
@NoException public static native int _PyDict_Next(
    PyObject mp, @Cast("Py_ssize_t*") SizeTPointer pos, @Cast("PyObject**") PointerPointer key, @Cast("PyObject**") PointerPointer value, @Cast("Py_hash_t*") SizeTPointer hash);
@NoException public static native int _PyDict_Next(
    PyObject mp, @Cast("Py_ssize_t*") SizeTPointer pos, @ByPtrPtr PyObject key, @ByPtrPtr PyObject value, @Cast("Py_hash_t*") SizeTPointer hash);

// #endif
@NoException public static native PyObject PyDict_Keys(PyObject mp);
@NoException public static native PyObject PyDict_Values(PyObject mp);
@NoException public static native PyObject PyDict_Items(PyObject mp);
@NoException public static native @Cast("Py_ssize_t") long PyDict_Size(PyObject mp);
@NoException public static native PyObject PyDict_Copy(PyObject mp);
@NoException public static native int PyDict_Contains(PyObject mp, PyObject key);
// #ifndef Py_LIMITED_API
@NoException public static native int _PyDict_Contains(PyObject mp, PyObject key, @Cast("Py_hash_t") long hash);
@NoException public static native PyObject _PyDict_NewPresized(@Cast("Py_ssize_t") long minused);
@NoException public static native void _PyDict_MaybeUntrack(PyObject mp);
@NoException public static native int _PyDict_HasOnlyStringKeys(PyObject mp);


@NoException public static native PyObject _PyDict_Pop(PyObject arg0, PyObject arg1, PyObject arg2);


// #define _PyDict_HasSplitTable(d) ((d)->ma_values != NULL)

@NoException public static native int PyDict_ClearFreeList();
// #endif

/* PyDict_Update(mp, other) is equivalent to PyDict_Merge(mp, other, 1). */
@NoException public static native int PyDict_Update(PyObject mp, PyObject other);

/* PyDict_Merge updates/merges from a mapping object (an object that
   supports PyMapping_Keys() and PyObject_GetItem()).  If override is true,
   the last occurrence of a key wins, else the first.  The Python
   dict.update(other) is equivalent to PyDict_Merge(dict, other, 1).
*/
@NoException public static native int PyDict_Merge(PyObject mp,
                                   PyObject other,
                                   int override);

// #ifndef Py_LIMITED_API
/* Like PyDict_Merge, but override can be 0, 1 or 2.  If override is 0,
   the first occurrence of a key wins, if override is 1, the last occurrence
   of a key wins, if override is 2, a KeyError with conflicting key as
   argument is raised.
*/
@NoException public static native int _PyDict_MergeEx(PyObject mp, PyObject other, int override);
@NoException public static native PyObject _PyDictView_Intersect(PyObject self, PyObject other);
// #endif

/* PyDict_MergeFromSeq2 updates/merges from an iterable object producing
   iterable objects of length 2.  If override is true, the last occurrence
   of a key wins, else the first.  The Python dict constructor dict(seq2)
   is equivalent to dict={}; PyDict_MergeFromSeq(dict, seq2, 1).
*/
@NoException public static native int PyDict_MergeFromSeq2(PyObject d,
                                           PyObject seq2,
                                           int override);

@NoException public static native PyObject PyDict_GetItemString(PyObject dp, @Cast("const char*") BytePointer key);
@NoException public static native PyObject PyDict_GetItemString(PyObject dp, String key);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyDict_GetItemId(PyObject dp, _Py_Identifier key);
// #endif /* !Py_LIMITED_API */
@NoException public static native int PyDict_SetItemString(PyObject dp, @Cast("const char*") BytePointer key, PyObject item);
@NoException public static native int PyDict_SetItemString(PyObject dp, String key, PyObject item);
// #ifndef Py_LIMITED_API
@NoException public static native int _PyDict_SetItemId(PyObject dp, _Py_Identifier key, PyObject item);
// #endif /* !Py_LIMITED_API */
@NoException public static native int PyDict_DelItemString(PyObject dp, @Cast("const char*") BytePointer key);
@NoException public static native int PyDict_DelItemString(PyObject dp, String key);

// #ifndef Py_LIMITED_API
@NoException public static native int _PyDict_DelItemId(PyObject mp, _Py_Identifier key);
@NoException public static native void _PyDict_DebugMallocStats(@Cast("FILE*") Pointer out);



// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_DICTOBJECT_H */


// Parsed from structmember.h

// #ifndef Py_STRUCTMEMBER_H
// #define Py_STRUCTMEMBER_H
// #ifdef __cplusplus
// #endif


/* Interface to map C struct members to Python object attributes */

// #include <stddef.h> /* For offsetof */

/* An array of PyMemberDef structures defines the name, type and offset
   of selected members of a C structure.  These can be read by
   PyMember_GetOne() and set by PyMember_SetOne() (except if their READONLY
   flag is set).  The array must be terminated with an entry whose name
   pointer is NULL. */

public static class PyMemberDef extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyMemberDef() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyMemberDef(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyMemberDef(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyMemberDef position(long position) {
        return (PyMemberDef)super.position(position);
    }

    public native @Cast("char*") BytePointer name(); public native PyMemberDef name(BytePointer name);
    public native int type(); public native PyMemberDef type(int type);
    public native @Cast("Py_ssize_t") long offset(); public native PyMemberDef offset(long offset);
    public native int flags(); public native PyMemberDef flags(int flags);
    public native @Cast("char*") BytePointer doc(); public native PyMemberDef doc(BytePointer doc);
}

/* Types */
public static final int T_SHORT =     0;
public static final int T_INT =       1;
public static final int T_LONG =      2;
public static final int T_FLOAT =     3;
public static final int T_DOUBLE =    4;
public static final int T_STRING =    5;
public static final int T_OBJECT =    6;
/* XXX the ordering here is weird for binary compatibility */
public static final int T_CHAR =      7;   /* 1-character string */
public static final int T_BYTE =      8;   /* 8-bit signed int */
/* unsigned variants: */
public static final int T_UBYTE =     9;
public static final int T_USHORT =    10;
public static final int T_UINT =      11;
public static final int T_ULONG =     12;

/* Added by Jack: strings contained in the structure */
public static final int T_STRING_INPLACE =    13;

/* Added by Lillo: bools contained in the structure (assumed char) */
public static final int T_BOOL =      14;

public static final int T_OBJECT_EX = 16;  /* Like T_OBJECT, but raises AttributeError
                           when the value is NULL, instead of
                           converting to None. */
public static final int T_LONGLONG =      17;
public static final int T_ULONGLONG =     18;

public static final int T_PYSSIZET =      19;      /* Py_ssize_t */
public static final int T_NONE =          20;      /* Value is always None */


/* Flags */
public static final int READONLY =            1;
public static final int READ_RESTRICTED =     2;
public static final int PY_WRITE_RESTRICTED = 4;
public static final int RESTRICTED =          (READ_RESTRICTED | PY_WRITE_RESTRICTED);


/* Current API, use this */
@NoException public static native PyObject PyMember_GetOne(@Cast("const char*") BytePointer arg0, PyMemberDef arg1);
@NoException public static native PyObject PyMember_GetOne(String arg0, PyMemberDef arg1);
@NoException public static native int PyMember_SetOne(@Cast("char*") BytePointer arg0, PyMemberDef arg1, PyObject arg2);
@NoException public static native int PyMember_SetOne(@Cast("char*") ByteBuffer arg0, PyMemberDef arg1, PyObject arg2);
@NoException public static native int PyMember_SetOne(@Cast("char*") byte[] arg0, PyMemberDef arg1, PyObject arg2);


// #ifdef __cplusplus
// #endif
// #endif /* !Py_STRUCTMEMBER_H */


// Parsed from object.h

// #ifndef Py_OBJECT_H
// #define Py_OBJECT_H
// #ifdef __cplusplus
// #endif


/* Object and type object interface */

/*
Objects are structures allocated on the heap.  Special rules apply to
the use of objects to ensure they are properly garbage-collected.
Objects are never allocated statically or on the stack; they must be
accessed through special macros and functions only.  (Type objects are
exceptions to the first rule; the standard types are represented by
statically initialized type objects, although work on type/class unification
for Python 2.2 made it possible to have heap-allocated type objects too).

An object has a 'reference count' that is increased or decreased when a
pointer to the object is copied or deleted; when the reference count
reaches zero there are no references to the object left and it can be
removed from the heap.

An object has a 'type' that determines what it represents and what kind
of data it contains.  An object's type is fixed when it is created.
Types themselves are represented as objects; an object contains a
pointer to the corresponding type object.  The type itself has a type
pointer pointing to the object representing the type 'type', which
contains a pointer to itself!).

Objects do not float around in memory; once allocated an object keeps
the same size and address.  Objects that must hold variable-size data
can contain pointers to variable-size parts of the object.  Not all
objects of the same type have the same size; but the size cannot change
after allocation.  (These restrictions are made so a reference to an
object can be simply a pointer -- moving an object would require
updating all the pointers, and changing an object's size would require
moving it if there was another object right next to it.)

Objects are always accessed through pointers of the type 'PyObject *'.
The type 'PyObject' is a structure that only contains the reference count
and the type pointer.  The actual memory allocated for an object
contains other data that can only be accessed after casting the pointer
to a pointer to a longer structure type.  This longer type must start
with the reference count and type fields; the macro PyObject_HEAD should be
used for this (to accommodate for future changes).  The implementation
of a particular object type can cast the object pointer to the proper
type and back.

A standard interface exists for objects that contain an array of items
whose size is determined when the object is allocated.
*/

/* Py_DEBUG implies Py_TRACE_REFS. */
// #if defined(Py_DEBUG) && !defined(Py_TRACE_REFS)
// #define Py_TRACE_REFS
// #endif

/* Py_TRACE_REFS implies Py_REF_DEBUG. */
// #if defined(Py_TRACE_REFS) && !defined(Py_REF_DEBUG)
// #define Py_REF_DEBUG
// #endif

// #if defined(Py_LIMITED_API) && defined(Py_REF_DEBUG)
// #error Py_LIMITED_API is incompatible with Py_DEBUG, Py_TRACE_REFS, and Py_REF_DEBUG
// #endif


// #ifdef Py_TRACE_REFS

// #else
// #define _PyObject_HEAD_EXTRA
// #define _PyObject_EXTRA_INIT
// #endif

/* PyObject_HEAD defines the initial segment of every PyObject. */
// #define PyObject_HEAD                   PyObject ob_base;

// #define PyObject_HEAD_INIT(type)
//     { _PyObject_EXTRA_INIT
//     1, type },

// #define PyVarObject_HEAD_INIT(type, size)
//     { PyObject_HEAD_INIT(type) size },

/* PyObject_VAR_HEAD defines the initial segment of all variable-size
 * container objects.  These end with a declaration of an array with 1
 * element, but enough space is malloc'ed so that the array actually
 * has room for ob_size elements.  Note that ob_size is an element count,
 * not necessarily a byte count.
 */
// #define PyObject_VAR_HEAD      PyVarObject ob_base;
public static final long Py_INVALID_SIZE = (long)-1;

/* Nothing is actually declared to be a PyObject, but every pointer to
 * a Python object can be cast to a PyObject*.  This is inheritance built
 * by hand.  Similarly every pointer to a variable-size Python object can,
 * in addition, be cast to PyVarObject*.
 */
public static class PyObject extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyObject() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyObject(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyObject(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyObject position(long position) {
        return (PyObject)super.position(position);
    }

    public native @Cast("Py_ssize_t") long ob_refcnt(); public native PyObject ob_refcnt(long ob_refcnt);
    public native @Cast("_typeobject*") PyTypeObject ob_type(); public native PyObject ob_type(PyTypeObject ob_type);
}

public static class PyVarObject extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyVarObject() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyVarObject(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyVarObject(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyVarObject position(long position) {
        return (PyVarObject)super.position(position);
    }

    public native @ByRef PyObject ob_base(); public native PyVarObject ob_base(PyObject ob_base);
    public native @Cast("Py_ssize_t") long ob_size(); public native PyVarObject ob_size(long ob_size); /* Number of items in variable part */
}

// #define Py_REFCNT(ob)           (((PyObject*)(ob))->ob_refcnt)
// #define Py_TYPE(ob)             (((PyObject*)(ob))->ob_type)
// #define Py_SIZE(ob)             (((PyVarObject*)(ob))->ob_size)

// #ifndef Py_LIMITED_API
/********************* String Literals ****************************************/
/* This structure helps managing static strings. The basic usage goes like this:
   Instead of doing

       r = PyObject_CallMethod(o, "foo", "args", ...);

   do

       _Py_IDENTIFIER(foo);
       ...
       r = _PyObject_CallMethodId(o, &PyId_foo, "args", ...);

   PyId_foo is a static variable, either on block level or file level. On first
   usage, the string "foo" is interned, and the structures are linked. On interpreter
   shutdown, all strings are released (through _PyUnicode_ClearStaticStrings).

   Alternatively, _Py_static_string allows choosing the variable name.
   _PyUnicode_FromId returns a borrowed reference to the interned string.
   _PyObject_{Get,Set,Has}AttrId are __getattr__ versions using _Py_Identifier*.
*/
public static class _Py_Identifier extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _Py_Identifier() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _Py_Identifier(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _Py_Identifier(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _Py_Identifier position(long position) {
        return (_Py_Identifier)super.position(position);
    }

    public native _Py_Identifier next(); public native _Py_Identifier next(_Py_Identifier next);
    @MemberGetter public native @Cast("const char*") BytePointer string();
    public native PyObject object(); public native _Py_Identifier object(PyObject object);
}

// #define _Py_static_string_init(value) { .next = NULL, .string = value, .object = NULL }
// #define _Py_static_string(varname, value)  static _Py_Identifier varname = _Py_static_string_init(value)
// #define _Py_IDENTIFIER(varname) _Py_static_string(PyId_##varname, #varname)

// #endif /* !Py_LIMITED_API */

/*
Type objects contain a string containing the type name (to help somewhat
in debugging), the allocation parameters (see PyObject_New() and
PyObject_NewVar()),
and methods for accessing objects of the type.  Methods are optional, a
nil pointer meaning that particular kind of access is not available for
this type.  The Py_DECREF() macro uses the tp_dealloc method without
checking for a nil pointer; it should always be implemented except if
the implementation can guarantee that the reference count will never
reach zero (e.g., for statically allocated type objects).

NB: the methods for certain type groups are now contained in separate
method blocks.
*/

public static class unaryfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    unaryfunc(Pointer p) { super(p); }
    protected unaryfunc() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject arg0);
}
public static class binaryfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    binaryfunc(Pointer p) { super(p); }
    protected binaryfunc() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject arg0, PyObject arg1);
}
public static class ternaryfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    ternaryfunc(Pointer p) { super(p); }
    protected ternaryfunc() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject arg0, PyObject arg1, PyObject arg2);
}
public static class inquiry extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    inquiry(Pointer p) { super(p); }
    protected inquiry() { allocate(); }
    private native void allocate();
    public native int call(PyObject arg0);
}
public static class lenfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    lenfunc(Pointer p) { super(p); }
    protected lenfunc() { allocate(); }
    private native void allocate();
    public native @Cast("Py_ssize_t") long call(PyObject arg0);
}
public static class ssizeargfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    ssizeargfunc(Pointer p) { super(p); }
    protected ssizeargfunc() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject arg0, @Cast("Py_ssize_t") long arg1);
}
public static class ssizessizeargfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    ssizessizeargfunc(Pointer p) { super(p); }
    protected ssizessizeargfunc() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject arg0, @Cast("Py_ssize_t") long arg1, @Cast("Py_ssize_t") long arg2);
}
public static class ssizeobjargproc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    ssizeobjargproc(Pointer p) { super(p); }
    protected ssizeobjargproc() { allocate(); }
    private native void allocate();
    public native int call(PyObject arg0, @Cast("Py_ssize_t") long arg1, PyObject arg2);
}
public static class ssizessizeobjargproc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    ssizessizeobjargproc(Pointer p) { super(p); }
    protected ssizessizeobjargproc() { allocate(); }
    private native void allocate();
    public native int call(PyObject arg0, @Cast("Py_ssize_t") long arg1, @Cast("Py_ssize_t") long arg2, PyObject arg3);
}
public static class objobjargproc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    objobjargproc(Pointer p) { super(p); }
    protected objobjargproc() { allocate(); }
    private native void allocate();
    public native int call(PyObject arg0, PyObject arg1, PyObject arg2);
}

// #ifndef Py_LIMITED_API
/* buffer interface */
public static class Py_buffer extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public Py_buffer() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public Py_buffer(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public Py_buffer(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public Py_buffer position(long position) {
        return (Py_buffer)super.position(position);
    }

    public native Pointer buf(); public native Py_buffer buf(Pointer buf);
    public native PyObject obj(); public native Py_buffer obj(PyObject obj);        /* owned reference */
    public native @Cast("Py_ssize_t") long len(); public native Py_buffer len(long len);
    public native @Cast("Py_ssize_t") long itemsize(); public native Py_buffer itemsize(long itemsize);  /* This is Py_ssize_t so it can be
                             pointed to by strides in simple case.*/
    public native int readonly(); public native Py_buffer readonly(int readonly);
    public native int ndim(); public native Py_buffer ndim(int ndim);
    public native @Cast("char*") BytePointer format(); public native Py_buffer format(BytePointer format);
    public native @Cast("Py_ssize_t*") SizeTPointer shape(); public native Py_buffer shape(SizeTPointer shape);
    public native @Cast("Py_ssize_t*") SizeTPointer strides(); public native Py_buffer strides(SizeTPointer strides);
    public native @Cast("Py_ssize_t*") SizeTPointer suboffsets(); public native Py_buffer suboffsets(SizeTPointer suboffsets);
    public native Pointer internal(); public native Py_buffer internal(Pointer internal);
}

public static class getbufferproc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    getbufferproc(Pointer p) { super(p); }
    protected getbufferproc() { allocate(); }
    private native void allocate();
    public native int call(PyObject arg0, Py_buffer arg1, int arg2);
}
public static class releasebufferproc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    releasebufferproc(Pointer p) { super(p); }
    protected releasebufferproc() { allocate(); }
    private native void allocate();
    public native void call(PyObject arg0, Py_buffer arg1);
}

/* Maximum number of dimensions */
public static final int PyBUF_MAX_NDIM = 64;

/* Flags for getting buffers */
public static final int PyBUF_SIMPLE = 0;
public static final int PyBUF_WRITABLE = 0x0001;
/*  we used to include an E, backwards compatible alias  */
public static final int PyBUF_WRITEABLE = PyBUF_WRITABLE;
public static final int PyBUF_FORMAT = 0x0004;
public static final int PyBUF_ND = 0x0008;
public static final int PyBUF_STRIDES = (0x0010 | PyBUF_ND);
public static final int PyBUF_C_CONTIGUOUS = (0x0020 | PyBUF_STRIDES);
public static final int PyBUF_F_CONTIGUOUS = (0x0040 | PyBUF_STRIDES);
public static final int PyBUF_ANY_CONTIGUOUS = (0x0080 | PyBUF_STRIDES);
public static final int PyBUF_INDIRECT = (0x0100 | PyBUF_STRIDES);

public static final int PyBUF_CONTIG = (PyBUF_ND | PyBUF_WRITABLE);
public static final int PyBUF_CONTIG_RO = (PyBUF_ND);

public static final int PyBUF_STRIDED = (PyBUF_STRIDES | PyBUF_WRITABLE);
public static final int PyBUF_STRIDED_RO = (PyBUF_STRIDES);

public static final int PyBUF_RECORDS = (PyBUF_STRIDES | PyBUF_WRITABLE | PyBUF_FORMAT);
public static final int PyBUF_RECORDS_RO = (PyBUF_STRIDES | PyBUF_FORMAT);

public static final int PyBUF_FULL = (PyBUF_INDIRECT | PyBUF_WRITABLE | PyBUF_FORMAT);
public static final int PyBUF_FULL_RO = (PyBUF_INDIRECT | PyBUF_FORMAT);


public static final int PyBUF_READ =  0x100;
public static final int PyBUF_WRITE = 0x200;

/* End buffer interface */
// #endif /* Py_LIMITED_API */

public static class objobjproc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    objobjproc(Pointer p) { super(p); }
    protected objobjproc() { allocate(); }
    private native void allocate();
    public native int call(PyObject arg0, PyObject arg1);
}
public static class visitproc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    visitproc(Pointer p) { super(p); }
    protected visitproc() { allocate(); }
    private native void allocate();
    public native int call(PyObject arg0, Pointer arg1);
}
public static class traverseproc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    traverseproc(Pointer p) { super(p); }
    protected traverseproc() { allocate(); }
    private native void allocate();
    public native int call(PyObject arg0, visitproc arg1, Pointer arg2);
}

// #ifndef Py_LIMITED_API
public static class PyNumberMethods extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyNumberMethods() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyNumberMethods(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyNumberMethods(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyNumberMethods position(long position) {
        return (PyNumberMethods)super.position(position);
    }

    /* Number implementations must check *both*
       arguments for proper type and implement the necessary conversions
       in the slot functions themselves. */

    public native binaryfunc nb_add(); public native PyNumberMethods nb_add(binaryfunc nb_add);
    public native binaryfunc nb_subtract(); public native PyNumberMethods nb_subtract(binaryfunc nb_subtract);
    public native binaryfunc nb_multiply(); public native PyNumberMethods nb_multiply(binaryfunc nb_multiply);
    public native binaryfunc nb_remainder(); public native PyNumberMethods nb_remainder(binaryfunc nb_remainder);
    public native binaryfunc nb_divmod(); public native PyNumberMethods nb_divmod(binaryfunc nb_divmod);
    public native ternaryfunc nb_power(); public native PyNumberMethods nb_power(ternaryfunc nb_power);
    public native unaryfunc nb_negative(); public native PyNumberMethods nb_negative(unaryfunc nb_negative);
    public native unaryfunc nb_positive(); public native PyNumberMethods nb_positive(unaryfunc nb_positive);
    public native unaryfunc nb_absolute(); public native PyNumberMethods nb_absolute(unaryfunc nb_absolute);
    public native inquiry nb_bool(); public native PyNumberMethods nb_bool(inquiry nb_bool);
    public native unaryfunc nb_invert(); public native PyNumberMethods nb_invert(unaryfunc nb_invert);
    public native binaryfunc nb_lshift(); public native PyNumberMethods nb_lshift(binaryfunc nb_lshift);
    public native binaryfunc nb_rshift(); public native PyNumberMethods nb_rshift(binaryfunc nb_rshift);
    public native binaryfunc nb_and(); public native PyNumberMethods nb_and(binaryfunc nb_and);
    public native binaryfunc nb_xor(); public native PyNumberMethods nb_xor(binaryfunc nb_xor);
    public native binaryfunc nb_or(); public native PyNumberMethods nb_or(binaryfunc nb_or);
    public native unaryfunc nb_int(); public native PyNumberMethods nb_int(unaryfunc nb_int);
    public native Pointer nb_reserved(); public native PyNumberMethods nb_reserved(Pointer nb_reserved);  /* the slot formerly known as nb_long */
    public native unaryfunc nb_float(); public native PyNumberMethods nb_float(unaryfunc nb_float);

    public native binaryfunc nb_inplace_add(); public native PyNumberMethods nb_inplace_add(binaryfunc nb_inplace_add);
    public native binaryfunc nb_inplace_subtract(); public native PyNumberMethods nb_inplace_subtract(binaryfunc nb_inplace_subtract);
    public native binaryfunc nb_inplace_multiply(); public native PyNumberMethods nb_inplace_multiply(binaryfunc nb_inplace_multiply);
    public native binaryfunc nb_inplace_remainder(); public native PyNumberMethods nb_inplace_remainder(binaryfunc nb_inplace_remainder);
    public native ternaryfunc nb_inplace_power(); public native PyNumberMethods nb_inplace_power(ternaryfunc nb_inplace_power);
    public native binaryfunc nb_inplace_lshift(); public native PyNumberMethods nb_inplace_lshift(binaryfunc nb_inplace_lshift);
    public native binaryfunc nb_inplace_rshift(); public native PyNumberMethods nb_inplace_rshift(binaryfunc nb_inplace_rshift);
    public native binaryfunc nb_inplace_and(); public native PyNumberMethods nb_inplace_and(binaryfunc nb_inplace_and);
    public native binaryfunc nb_inplace_xor(); public native PyNumberMethods nb_inplace_xor(binaryfunc nb_inplace_xor);
    public native binaryfunc nb_inplace_or(); public native PyNumberMethods nb_inplace_or(binaryfunc nb_inplace_or);

    public native binaryfunc nb_floor_divide(); public native PyNumberMethods nb_floor_divide(binaryfunc nb_floor_divide);
    public native binaryfunc nb_true_divide(); public native PyNumberMethods nb_true_divide(binaryfunc nb_true_divide);
    public native binaryfunc nb_inplace_floor_divide(); public native PyNumberMethods nb_inplace_floor_divide(binaryfunc nb_inplace_floor_divide);
    public native binaryfunc nb_inplace_true_divide(); public native PyNumberMethods nb_inplace_true_divide(binaryfunc nb_inplace_true_divide);

    public native unaryfunc nb_index(); public native PyNumberMethods nb_index(unaryfunc nb_index);

    public native binaryfunc nb_matrix_multiply(); public native PyNumberMethods nb_matrix_multiply(binaryfunc nb_matrix_multiply);
    public native binaryfunc nb_inplace_matrix_multiply(); public native PyNumberMethods nb_inplace_matrix_multiply(binaryfunc nb_inplace_matrix_multiply);
}

public static class PySequenceMethods extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PySequenceMethods() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PySequenceMethods(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PySequenceMethods(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PySequenceMethods position(long position) {
        return (PySequenceMethods)super.position(position);
    }

    public native lenfunc sq_length(); public native PySequenceMethods sq_length(lenfunc sq_length);
    public native binaryfunc sq_concat(); public native PySequenceMethods sq_concat(binaryfunc sq_concat);
    public native ssizeargfunc sq_repeat(); public native PySequenceMethods sq_repeat(ssizeargfunc sq_repeat);
    public native ssizeargfunc sq_item(); public native PySequenceMethods sq_item(ssizeargfunc sq_item);
    public native Pointer was_sq_slice(); public native PySequenceMethods was_sq_slice(Pointer was_sq_slice);
    public native ssizeobjargproc sq_ass_item(); public native PySequenceMethods sq_ass_item(ssizeobjargproc sq_ass_item);
    public native Pointer was_sq_ass_slice(); public native PySequenceMethods was_sq_ass_slice(Pointer was_sq_ass_slice);
    public native objobjproc sq_contains(); public native PySequenceMethods sq_contains(objobjproc sq_contains);

    public native binaryfunc sq_inplace_concat(); public native PySequenceMethods sq_inplace_concat(binaryfunc sq_inplace_concat);
    public native ssizeargfunc sq_inplace_repeat(); public native PySequenceMethods sq_inplace_repeat(ssizeargfunc sq_inplace_repeat);
}

public static class PyMappingMethods extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyMappingMethods() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyMappingMethods(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyMappingMethods(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyMappingMethods position(long position) {
        return (PyMappingMethods)super.position(position);
    }

    public native lenfunc mp_length(); public native PyMappingMethods mp_length(lenfunc mp_length);
    public native binaryfunc mp_subscript(); public native PyMappingMethods mp_subscript(binaryfunc mp_subscript);
    public native objobjargproc mp_ass_subscript(); public native PyMappingMethods mp_ass_subscript(objobjargproc mp_ass_subscript);
}

public static class PyAsyncMethods extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyAsyncMethods() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyAsyncMethods(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyAsyncMethods(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyAsyncMethods position(long position) {
        return (PyAsyncMethods)super.position(position);
    }

    public native unaryfunc am_await(); public native PyAsyncMethods am_await(unaryfunc am_await);
    public native unaryfunc am_aiter(); public native PyAsyncMethods am_aiter(unaryfunc am_aiter);
    public native unaryfunc am_anext(); public native PyAsyncMethods am_anext(unaryfunc am_anext);
}

public static class PyBufferProcs extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyBufferProcs() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyBufferProcs(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyBufferProcs(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyBufferProcs position(long position) {
        return (PyBufferProcs)super.position(position);
    }

     public native getbufferproc bf_getbuffer(); public native PyBufferProcs bf_getbuffer(getbufferproc bf_getbuffer);
     public native releasebufferproc bf_releasebuffer(); public native PyBufferProcs bf_releasebuffer(releasebufferproc bf_releasebuffer);
}
// #endif /* Py_LIMITED_API */

public static class freefunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    freefunc(Pointer p) { super(p); }
    protected freefunc() { allocate(); }
    private native void allocate();
    public native void call(Pointer arg0);
}
public static class destructor extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    destructor(Pointer p) { super(p); }
    protected destructor() { allocate(); }
    private native void allocate();
    public native void call(PyObject arg0);
}
// #ifndef Py_LIMITED_API
/* We can't provide a full compile-time check that limited-API
   users won't implement tp_print. However, not defining printfunc
   and making tp_print of a different function pointer type
   should at least cause a warning in most cases. */
public static class printfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    printfunc(Pointer p) { super(p); }
    protected printfunc() { allocate(); }
    private native void allocate();
    public native int call(PyObject arg0, @Cast("FILE*") Pointer arg1, int arg2);
}
// #endif
public static class getattrfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    getattrfunc(Pointer p) { super(p); }
    protected getattrfunc() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject arg0, @Cast("char*") BytePointer arg1);
}
public static class getattrofunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    getattrofunc(Pointer p) { super(p); }
    protected getattrofunc() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject arg0, PyObject arg1);
}
public static class setattrfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    setattrfunc(Pointer p) { super(p); }
    protected setattrfunc() { allocate(); }
    private native void allocate();
    public native int call(PyObject arg0, @Cast("char*") BytePointer arg1, PyObject arg2);
}
public static class setattrofunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    setattrofunc(Pointer p) { super(p); }
    protected setattrofunc() { allocate(); }
    private native void allocate();
    public native int call(PyObject arg0, PyObject arg1, PyObject arg2);
}
public static class reprfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    reprfunc(Pointer p) { super(p); }
    protected reprfunc() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject arg0);
}
public static class hashfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    hashfunc(Pointer p) { super(p); }
    protected hashfunc() { allocate(); }
    private native void allocate();
    public native @Cast("Py_hash_t") long call(PyObject arg0);
}
public static class richcmpfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    richcmpfunc(Pointer p) { super(p); }
    protected richcmpfunc() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject arg0, PyObject arg1, int arg2);
}
public static class getiterfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    getiterfunc(Pointer p) { super(p); }
    protected getiterfunc() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject arg0);
}
public static class iternextfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    iternextfunc(Pointer p) { super(p); }
    protected iternextfunc() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject arg0);
}
public static class descrgetfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    descrgetfunc(Pointer p) { super(p); }
    protected descrgetfunc() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject arg0, PyObject arg1, PyObject arg2);
}
public static class descrsetfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    descrsetfunc(Pointer p) { super(p); }
    protected descrsetfunc() { allocate(); }
    private native void allocate();
    public native int call(PyObject arg0, PyObject arg1, PyObject arg2);
}
public static class initproc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    initproc(Pointer p) { super(p); }
    protected initproc() { allocate(); }
    private native void allocate();
    public native int call(PyObject arg0, PyObject arg1, PyObject arg2);
}
public static class newfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    newfunc(Pointer p) { super(p); }
    protected newfunc() { allocate(); }
    private native void allocate();
    public native PyObject call(@Cast("_typeobject*") PyTypeObject arg0, PyObject arg1, PyObject arg2);
}
public static class allocfunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    allocfunc(Pointer p) { super(p); }
    protected allocfunc() { allocate(); }
    private native void allocate();
    public native PyObject call(@Cast("_typeobject*") PyTypeObject arg0, @Cast("Py_ssize_t") long arg1);
}

// #ifdef Py_LIMITED_API /* opaque */
// #else
public static class PyTypeObject extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyTypeObject() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyTypeObject(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyTypeObject(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyTypeObject position(long position) {
        return (PyTypeObject)super.position(position);
    }

    public native @ByRef PyVarObject ob_base(); public native PyTypeObject ob_base(PyVarObject ob_base);
    @MemberGetter public native @Cast("const char*") BytePointer tp_name(); /* For printing, in format "<module>.<name>" */
    public native @Cast("Py_ssize_t") long tp_basicsize(); public native PyTypeObject tp_basicsize(long tp_basicsize);
    public native @Cast("Py_ssize_t") long tp_itemsize(); public native PyTypeObject tp_itemsize(long tp_itemsize); /* For allocation */

    /* Methods to implement standard operations */

    public native destructor tp_dealloc(); public native PyTypeObject tp_dealloc(destructor tp_dealloc);
    public native printfunc tp_print(); public native PyTypeObject tp_print(printfunc tp_print);
    public native getattrfunc tp_getattr(); public native PyTypeObject tp_getattr(getattrfunc tp_getattr);
    public native setattrfunc tp_setattr(); public native PyTypeObject tp_setattr(setattrfunc tp_setattr);
    public native PyAsyncMethods tp_as_async(); public native PyTypeObject tp_as_async(PyAsyncMethods tp_as_async); /* formerly known as tp_compare (Python 2)
                                    or tp_reserved (Python 3) */
    public native reprfunc tp_repr(); public native PyTypeObject tp_repr(reprfunc tp_repr);

    /* Method suites for standard classes */

    public native PyNumberMethods tp_as_number(); public native PyTypeObject tp_as_number(PyNumberMethods tp_as_number);
    public native PySequenceMethods tp_as_sequence(); public native PyTypeObject tp_as_sequence(PySequenceMethods tp_as_sequence);
    public native PyMappingMethods tp_as_mapping(); public native PyTypeObject tp_as_mapping(PyMappingMethods tp_as_mapping);

    /* More standard operations (here for binary compatibility) */

    public native hashfunc tp_hash(); public native PyTypeObject tp_hash(hashfunc tp_hash);
    public native ternaryfunc tp_call(); public native PyTypeObject tp_call(ternaryfunc tp_call);
    public native reprfunc tp_str(); public native PyTypeObject tp_str(reprfunc tp_str);
    public native getattrofunc tp_getattro(); public native PyTypeObject tp_getattro(getattrofunc tp_getattro);
    public native setattrofunc tp_setattro(); public native PyTypeObject tp_setattro(setattrofunc tp_setattro);

    /* Functions to access object as input/output buffer */
    public native PyBufferProcs tp_as_buffer(); public native PyTypeObject tp_as_buffer(PyBufferProcs tp_as_buffer);

    /* Flags to define presence of optional/expanded features */
    public native @Cast("unsigned long") long tp_flags(); public native PyTypeObject tp_flags(long tp_flags);

    @MemberGetter public native @Cast("const char*") BytePointer tp_doc(); /* Documentation string */

    /* Assigned meaning in release 2.0 */
    /* call function for all accessible objects */
    public native traverseproc tp_traverse(); public native PyTypeObject tp_traverse(traverseproc tp_traverse);

    /* delete references to contained objects */
    public native inquiry tp_clear(); public native PyTypeObject tp_clear(inquiry tp_clear);

    /* Assigned meaning in release 2.1 */
    /* rich comparisons */
    public native richcmpfunc tp_richcompare(); public native PyTypeObject tp_richcompare(richcmpfunc tp_richcompare);

    /* weak reference enabler */
    public native @Cast("Py_ssize_t") long tp_weaklistoffset(); public native PyTypeObject tp_weaklistoffset(long tp_weaklistoffset);

    /* Iterators */
    public native getiterfunc tp_iter(); public native PyTypeObject tp_iter(getiterfunc tp_iter);
    public native iternextfunc tp_iternext(); public native PyTypeObject tp_iternext(iternextfunc tp_iternext);

    /* Attribute descriptor and subclassing stuff */
    public native PyMethodDef tp_methods(); public native PyTypeObject tp_methods(PyMethodDef tp_methods);
    public native PyMemberDef tp_members(); public native PyTypeObject tp_members(PyMemberDef tp_members);
    public native PyGetSetDef tp_getset(); public native PyTypeObject tp_getset(PyGetSetDef tp_getset);
    public native @Cast("_typeobject*") PyTypeObject tp_base(); public native PyTypeObject tp_base(PyTypeObject tp_base);
    public native PyObject tp_dict(); public native PyTypeObject tp_dict(PyObject tp_dict);
    public native descrgetfunc tp_descr_get(); public native PyTypeObject tp_descr_get(descrgetfunc tp_descr_get);
    public native descrsetfunc tp_descr_set(); public native PyTypeObject tp_descr_set(descrsetfunc tp_descr_set);
    public native @Cast("Py_ssize_t") long tp_dictoffset(); public native PyTypeObject tp_dictoffset(long tp_dictoffset);
    public native initproc tp_init(); public native PyTypeObject tp_init(initproc tp_init);
    public native allocfunc tp_alloc(); public native PyTypeObject tp_alloc(allocfunc tp_alloc);
    public native newfunc tp_new(); public native PyTypeObject tp_new(newfunc tp_new);
    public native freefunc tp_free(); public native PyTypeObject tp_free(freefunc tp_free); /* Low-level free-memory routine */
    public native inquiry tp_is_gc(); public native PyTypeObject tp_is_gc(inquiry tp_is_gc); /* For PyObject_IS_GC */
    public native PyObject tp_bases(); public native PyTypeObject tp_bases(PyObject tp_bases);
    public native PyObject tp_mro(); public native PyTypeObject tp_mro(PyObject tp_mro); /* method resolution order */
    public native PyObject tp_cache(); public native PyTypeObject tp_cache(PyObject tp_cache);
    public native PyObject tp_subclasses(); public native PyTypeObject tp_subclasses(PyObject tp_subclasses);
    public native PyObject tp_weaklist(); public native PyTypeObject tp_weaklist(PyObject tp_weaklist);
    public native destructor tp_del(); public native PyTypeObject tp_del(destructor tp_del);

    /* Type attribute cache version tag. Added in version 2.6 */
    public native @Cast("unsigned int") int tp_version_tag(); public native PyTypeObject tp_version_tag(int tp_version_tag);

    public native destructor tp_finalize(); public native PyTypeObject tp_finalize(destructor tp_finalize);

// #ifdef COUNT_ALLOCS
// #endif
}
// #endif

public static class PyType_Slot extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyType_Slot() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyType_Slot(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyType_Slot(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyType_Slot position(long position) {
        return (PyType_Slot)super.position(position);
    }

    public native int slot(); public native PyType_Slot slot(int slot);    /* slot id, see below */
    public native Pointer pfunc(); public native PyType_Slot pfunc(Pointer pfunc); /* function pointer */
}

public static class PyType_Spec extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyType_Spec() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyType_Spec(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyType_Spec(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyType_Spec position(long position) {
        return (PyType_Spec)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer name();
    public native int basicsize(); public native PyType_Spec basicsize(int basicsize);
    public native int itemsize(); public native PyType_Spec itemsize(int itemsize);
    public native @Cast("unsigned int") int flags(); public native PyType_Spec flags(int flags);
    public native PyType_Slot slots(); public native PyType_Spec slots(PyType_Slot slots); /* terminated by slot==0. */
}

@NoException public static native PyObject PyType_FromSpec(PyType_Spec arg0);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyType_FromSpecWithBases(PyType_Spec arg0, PyObject arg1);
// #endif
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03040000
@NoException public static native Pointer PyType_GetSlot(PyTypeObject arg0, int arg1);
// #endif

// #ifndef Py_LIMITED_API
/* The *real* layout of a type object when allocated on the heap */
public static class PyHeapTypeObject extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyHeapTypeObject() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyHeapTypeObject(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyHeapTypeObject(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyHeapTypeObject position(long position) {
        return (PyHeapTypeObject)super.position(position);
    }

    /* Note: there's a dependency on the order of these members
       in slotptr() in typeobject.c . */
    public native @ByRef PyTypeObject ht_type(); public native PyHeapTypeObject ht_type(PyTypeObject ht_type);
    public native @ByRef PyAsyncMethods as_async(); public native PyHeapTypeObject as_async(PyAsyncMethods as_async);
    public native @ByRef PyNumberMethods as_number(); public native PyHeapTypeObject as_number(PyNumberMethods as_number);
    public native @ByRef PyMappingMethods as_mapping(); public native PyHeapTypeObject as_mapping(PyMappingMethods as_mapping);
    public native @ByRef PySequenceMethods as_sequence(); public native PyHeapTypeObject as_sequence(PySequenceMethods as_sequence); /* as_sequence comes after as_mapping,
                                      so that the mapping wins when both
                                      the mapping and the sequence define
                                      a given operator (e.g. __getitem__).
                                      see add_operators() in typeobject.c . */
    public native @ByRef PyBufferProcs as_buffer(); public native PyHeapTypeObject as_buffer(PyBufferProcs as_buffer);
    public native PyObject ht_name(); public native PyHeapTypeObject ht_name(PyObject ht_name);
    public native PyObject ht_slots(); public native PyHeapTypeObject ht_slots(PyObject ht_slots);
    public native PyObject ht_qualname(); public native PyHeapTypeObject ht_qualname(PyObject ht_qualname);
    public native @Cast("_dictkeysobject*") PyDictKeysObject ht_cached_keys(); public native PyHeapTypeObject ht_cached_keys(PyDictKeysObject ht_cached_keys);
    /* here are optional user slots, followed by the members. */
}

/* access macro to the members which are floating "behind" the object */
// #define PyHeapType_GET_MEMBERS(etype)
//     ((PyMemberDef *)(((char *)etype) + Py_TYPE(etype)->tp_basicsize))
// #endif

/* Generic type check */
@NoException public static native int PyType_IsSubtype(PyTypeObject arg0, PyTypeObject arg1);
// #define PyObject_TypeCheck(ob, tp)
//     (Py_TYPE(ob) == (tp) || PyType_IsSubtype(Py_TYPE(ob), (tp)))

public static native @ByRef PyTypeObject PyType_Type(); public static native void PyType_Type(PyTypeObject PyType_Type); /* built-in 'type' */
public static native @ByRef PyTypeObject PyBaseObject_Type(); public static native void PyBaseObject_Type(PyTypeObject PyBaseObject_Type); /* built-in 'object' */
public static native @ByRef PyTypeObject PySuper_Type(); public static native void PySuper_Type(PyTypeObject PySuper_Type); /* built-in 'super' */

@NoException public static native @Cast("unsigned long") long PyType_GetFlags(PyTypeObject arg0);

// #define PyType_Check(op)
//     PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_TYPE_SUBCLASS)
// #define PyType_CheckExact(op) (Py_TYPE(op) == &PyType_Type)

@NoException public static native int PyType_Ready(PyTypeObject arg0);
@NoException public static native PyObject PyType_GenericAlloc(PyTypeObject arg0, @Cast("Py_ssize_t") long arg1);
@NoException public static native PyObject PyType_GenericNew(PyTypeObject arg0,
                                               PyObject arg1, PyObject arg2);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyType_Lookup(PyTypeObject arg0, PyObject arg1);
@NoException public static native PyObject _PyType_LookupId(PyTypeObject arg0, _Py_Identifier arg1);
@NoException public static native PyObject _PyObject_LookupSpecial(PyObject arg0, _Py_Identifier arg1);
@NoException public static native PyTypeObject _PyType_CalculateMetaclass(PyTypeObject arg0, PyObject arg1);
// #endif
@NoException public static native @Cast("unsigned int") int PyType_ClearCache();
@NoException public static native void PyType_Modified(PyTypeObject arg0);

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyType_GetDocFromInternalDoc(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native PyObject _PyType_GetDocFromInternalDoc(String arg0, String arg1);
@NoException public static native PyObject _PyType_GetTextSignatureFromInternalDoc(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native PyObject _PyType_GetTextSignatureFromInternalDoc(String arg0, String arg1);
// #endif

/* Generic operations on objects */
// #ifndef Py_LIMITED_API
@NoException public static native int PyObject_Print(PyObject arg0, @Cast("FILE*") Pointer arg1, int arg2);
@NoException public static native void _Py_BreakPoint();
@NoException public static native void _PyObject_Dump(PyObject arg0);
// #endif
@NoException public static native PyObject PyObject_Repr(PyObject arg0);
@NoException public static native PyObject PyObject_Str(PyObject arg0);
@NoException public static native PyObject PyObject_ASCII(PyObject arg0);
@NoException public static native PyObject PyObject_Bytes(PyObject arg0);
@NoException public static native PyObject PyObject_RichCompare(PyObject arg0, PyObject arg1, int arg2);
@NoException public static native int PyObject_RichCompareBool(PyObject arg0, PyObject arg1, int arg2);
@NoException public static native PyObject PyObject_GetAttrString(PyObject arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native PyObject PyObject_GetAttrString(PyObject arg0, String arg1);
@NoException public static native int PyObject_SetAttrString(PyObject arg0, @Cast("const char*") BytePointer arg1, PyObject arg2);
@NoException public static native int PyObject_SetAttrString(PyObject arg0, String arg1, PyObject arg2);
@NoException public static native int PyObject_HasAttrString(PyObject arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native int PyObject_HasAttrString(PyObject arg0, String arg1);
@NoException public static native PyObject PyObject_GetAttr(PyObject arg0, PyObject arg1);
@NoException public static native int PyObject_SetAttr(PyObject arg0, PyObject arg1, PyObject arg2);
@NoException public static native int PyObject_HasAttr(PyObject arg0, PyObject arg1);
// #ifndef Py_LIMITED_API
@NoException public static native int _PyObject_IsAbstract(PyObject arg0);
@NoException public static native PyObject _PyObject_GetAttrId(PyObject arg0, _Py_Identifier arg1);
@NoException public static native int _PyObject_SetAttrId(PyObject arg0, _Py_Identifier arg1, PyObject arg2);
@NoException public static native int _PyObject_HasAttrId(PyObject arg0, _Py_Identifier arg1);
@NoException public static native @Cast("PyObject**") PointerPointer _PyObject_GetDictPtr(PyObject arg0);
// #endif
@NoException public static native PyObject PyObject_SelfIter(PyObject arg0);
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyObject_NextNotImplemented(PyObject arg0);
// #endif
@NoException public static native PyObject PyObject_GenericGetAttr(PyObject arg0, PyObject arg1);
@NoException public static native int PyObject_GenericSetAttr(PyObject arg0,
                                              PyObject arg1, PyObject arg2);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native int PyObject_GenericSetDict(PyObject arg0, PyObject arg1, Pointer arg2);
// #endif
@NoException public static native @Cast("Py_hash_t") long PyObject_Hash(PyObject arg0);
@NoException public static native @Cast("Py_hash_t") long PyObject_HashNotImplemented(PyObject arg0);
@NoException public static native int PyObject_IsTrue(PyObject arg0);
@NoException public static native int PyObject_Not(PyObject arg0);
@NoException public static native int PyCallable_Check(PyObject arg0);

@NoException public static native void PyObject_ClearWeakRefs(PyObject arg0);
// #ifndef Py_LIMITED_API
@NoException public static native void PyObject_CallFinalizer(PyObject arg0);
@NoException public static native int PyObject_CallFinalizerFromDealloc(PyObject arg0);
// #endif

// #ifndef Py_LIMITED_API
/* Same as PyObject_Generic{Get,Set}Attr, but passing the attributes
   dict as the last parameter. */
@NoException public static native PyObject _PyObject_GenericGetAttrWithDict(PyObject arg0, PyObject arg1, PyObject arg2);
@NoException public static native int _PyObject_GenericSetAttrWithDict(PyObject arg0, PyObject arg1,
                                 PyObject arg2, PyObject arg3);
// #endif /* !Py_LIMITED_API */

/* Helper to look up a builtin object */
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyObject_GetBuiltin(@Cast("const char*") BytePointer name);
@NoException public static native PyObject _PyObject_GetBuiltin(String name);
// #endif

/* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a
   list of strings.  PyObject_Dir(NULL) is like builtins.dir(),
   returning the names of the current locals.  In this case, if there are
   no current locals, NULL is returned, and PyErr_Occurred() is false.
*/
@NoException public static native PyObject PyObject_Dir(PyObject arg0);


/* Helpers for printing recursive container types */
@NoException public static native int Py_ReprEnter(PyObject arg0);
@NoException public static native void Py_ReprLeave(PyObject arg0);

/* Flag bits for printing: */
public static final int Py_PRINT_RAW =    1;       /* No string quotes etc. */

/*
`Type flags (tp_flags)

These flags are used to extend the type structure in a backwards-compatible
fashion. Extensions can use the flags to indicate (and test) when a given
type structure contains a new feature. The Python core will use these when
introducing new functionality between major revisions (to avoid mid-version
changes in the PYTHON_API_VERSION).

Arbitration of the flag bit positions will need to be coordinated among
all extension writers who publically release their extensions (this will
be fewer than you might expect!)..

Most flags were removed as of Python 3.0 to make room for new flags.  (Some
flags are not for backwards compatibility but to indicate the presence of an
optional feature; these flags remain of course.)

Type definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.

Code can use PyType_HasFeature(type_ob, flag_value) to test whether the
given type object has a specified feature.
*/

/* Set if the type object is dynamically allocated */
public static final long Py_TPFLAGS_HEAPTYPE = (1L << 9);

/* Set if the type allows subclassing */
public static final long Py_TPFLAGS_BASETYPE = (1L << 10);

/* Set if the type is 'ready' -- fully initialized */
public static final long Py_TPFLAGS_READY = (1L << 12);

/* Set while the type is being 'readied', to prevent recursive ready calls */
public static final long Py_TPFLAGS_READYING = (1L << 13);

/* Objects support garbage collection (see objimp.h) */
public static final long Py_TPFLAGS_HAVE_GC = (1L << 14);

/* These two bits are preserved for Stackless Python, next after this is 17 */
// #ifdef STACKLESS
public static final long Py_TPFLAGS_HAVE_STACKLESS_EXTENSION = (3L << 15);
// #else
// #endif

/* Objects support type attribute cache */
public static final long Py_TPFLAGS_HAVE_VERSION_TAG =   (1L << 18);
public static final long Py_TPFLAGS_VALID_VERSION_TAG =  (1L << 19);

/* Type is abstract and cannot be instantiated */
public static final long Py_TPFLAGS_IS_ABSTRACT = (1L << 20);

/* These flags are used to determine if a type is a subclass. */
public static final long Py_TPFLAGS_LONG_SUBCLASS =        (1L << 24);
public static final long Py_TPFLAGS_LIST_SUBCLASS =        (1L << 25);
public static final long Py_TPFLAGS_TUPLE_SUBCLASS =       (1L << 26);
public static final long Py_TPFLAGS_BYTES_SUBCLASS =       (1L << 27);
public static final long Py_TPFLAGS_UNICODE_SUBCLASS =     (1L << 28);
public static final long Py_TPFLAGS_DICT_SUBCLASS =        (1L << 29);
public static final long Py_TPFLAGS_BASE_EXC_SUBCLASS =    (1L << 30);
public static final long Py_TPFLAGS_TYPE_SUBCLASS =        (1L << 31);

public static final long Py_TPFLAGS_DEFAULT =  ( 
                 Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | 
                 Py_TPFLAGS_HAVE_VERSION_TAG | 
                0);

/* NOTE: The following flags reuse lower bits (removed as part of the
 * Python 3.0 transition). */

/* Type structure has tp_finalize member (3.4) */
public static final long Py_TPFLAGS_HAVE_FINALIZE = (1L << 0);

// #ifdef Py_LIMITED_API
// #define PyType_HasFeature(t,f)  ((PyType_GetFlags(t) & (f)) != 0)
// #else
// #define PyType_HasFeature(t,f)  (((t)->tp_flags & (f)) != 0)
// #endif
// #define PyType_FastSubclass(t,f)  PyType_HasFeature(t,f)


/*
The macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement
reference counts.  Py_DECREF calls the object's deallocator function when
the refcount falls to 0; for
objects that don't contain references to other objects or heap memory
this can be the standard function free().  Both macros can be used
wherever a void expression is allowed.  The argument must not be a
NULL pointer.  If it may be NULL, use Py_XINCREF/Py_XDECREF instead.
The macro _Py_NewReference(op) initialize reference counts to 1, and
in special builds (Py_REF_DEBUG, Py_TRACE_REFS) performs additional
bookkeeping appropriate to the special build.

We assume that the reference count field can never overflow; this can
be proven when the size of the field is the same as the pointer size, so
we ignore the possibility.  Provided a C int is at least 32 bits (which
is implicitly assumed in many parts of this code), that's enough for
about 2**31 references to an object.

XXX The following became out of date in Python 2.2, but I'm not sure
XXX what the full truth is now.  Certainly, heap-allocated type objects
XXX can and should be deallocated.
Type objects should never be deallocated; the type pointer in an object
is not considered to be a reference to the type object, to save
complications in the deallocation function.  (This is actually a
decision that's up to the implementer of each new type so if you want,
you can count such references to the type object.)
*/

/* First define a pile of simple helper macros, one set per special
 * build symbol.  These either expand to the obvious things, or to
 * nothing at all when the special mode isn't in effect.  The main
 * macros can later be defined just once then, yet expand to different
 * things depending on which special build options are and aren't in effect.
 * Trust me <wink>:  while painful, this is 20x easier to understand than,
 * e.g, defining _Py_NewReference five different times in a maze of nested
 * #ifdefs (we used to do that -- it was impenetrable).
 */
// #ifdef Py_REF_DEBUG
// #else
// #define _Py_INC_REFTOTAL
// #define _Py_DEC_REFTOTAL
// #define _Py_REF_DEBUG_COMMA
// #define _Py_CHECK_REFCNT(OP)    /* a semicolon */;
// #define _PY_DEBUG_PRINT_TOTAL_REFS()
// #endif /* Py_REF_DEBUG */

// #ifdef COUNT_ALLOCS
// #else
// #define _Py_INC_TPALLOCS(OP)
// #define _Py_INC_TPFREES(OP)
// #define _Py_DEC_TPFREES(OP)
// #define _Py_COUNT_ALLOCS_COMMA
// #endif /* COUNT_ALLOCS */

// #ifdef Py_TRACE_REFS

// #else
/* Without Py_TRACE_REFS, there's little enough to do that we expand code
 * inline.
 */
// #define _Py_NewReference(op) (
//     _Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA
//     _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA
//     Py_REFCNT(op) = 1)

// #define _Py_ForgetReference(op) _Py_INC_TPFREES(op)

// #ifdef Py_LIMITED_API
@NoException public static native void _Py_Dealloc(PyObject arg0);
// #else
// #define _Py_Dealloc(op) (
//     _Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA
//     (*Py_TYPE(op)->tp_dealloc)((PyObject *)(op)))
// #endif
// #endif /* !Py_TRACE_REFS */

// #define Py_INCREF(op) (
//     _Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA
//     ((PyObject *)(op))->ob_refcnt++)

// #define Py_DECREF(op)
//     do {
//         PyObject *_py_decref_tmp = (PyObject *)(op);
//         if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA
//         --(_py_decref_tmp)->ob_refcnt != 0)
//             _Py_CHECK_REFCNT(_py_decref_tmp)
//         else
//             _Py_Dealloc(_py_decref_tmp);
//     } while (0)

/* Safely decref `op` and set `op` to NULL, especially useful in tp_clear
 * and tp_dealloc implementations.
 *
 * Note that "the obvious" code can be deadly:
 *
 *     Py_XDECREF(op);
 *     op = NULL;
 *
 * Typically, `op` is something like self->containee, and `self` is done
 * using its `containee` member.  In the code sequence above, suppose
 * `containee` is non-NULL with a refcount of 1.  Its refcount falls to
 * 0 on the first line, which can trigger an arbitrary amount of code,
 * possibly including finalizers (like __del__ methods or weakref callbacks)
 * coded in Python, which in turn can release the GIL and allow other threads
 * to run, etc.  Such code may even invoke methods of `self` again, or cause
 * cyclic gc to trigger, but-- oops! --self->containee still points to the
 * object being torn down, and it may be in an insane state while being torn
 * down.  This has in fact been a rich historic source of miserable (rare &
 * hard-to-diagnose) segfaulting (and other) bugs.
 *
 * The safe way is:
 *
 *      Py_CLEAR(op);
 *
 * That arranges to set `op` to NULL _before_ decref'ing, so that any code
 * triggered as a side-effect of `op` getting torn down no longer believes
 * `op` points to a valid object.
 *
 * There are cases where it's safe to use the naive code, but they're brittle.
 * For example, if `op` points to a Python integer, you know that destroying
 * one of those can't cause problems -- but in part that relies on that
 * Python integers aren't currently weakly referencable.  Best practice is
 * to use Py_CLEAR() even if you can't think of a reason for why you need to.
 */
// #define Py_CLEAR(op)
//     do {
//         PyObject *_py_tmp = (PyObject *)(op);
//         if (_py_tmp != NULL) {
//             (op) = NULL;
//             Py_DECREF(_py_tmp);
//         }
//     } while (0)

/* Macros to use in case the object pointer may be NULL: */
// #define Py_XINCREF(op)
//     do {
//         PyObject *_py_xincref_tmp = (PyObject *)(op);
//         if (_py_xincref_tmp != NULL)
//             Py_INCREF(_py_xincref_tmp);
//     } while (0)

// #define Py_XDECREF(op)
//     do {
//         PyObject *_py_xdecref_tmp = (PyObject *)(op);
//         if (_py_xdecref_tmp != NULL)
//             Py_DECREF(_py_xdecref_tmp);
//     } while (0)

// #ifndef Py_LIMITED_API
/* Safely decref `op` and set `op` to `op2`.
 *
 * As in case of Py_CLEAR "the obvious" code can be deadly:
 *
 *     Py_DECREF(op);
 *     op = op2;
 *
 * The safe way is:
 *
 *      Py_SETREF(op, op2);
 *
 * That arranges to set `op` to `op2` _before_ decref'ing, so that any code
 * triggered as a side-effect of `op` getting torn down no longer believes
 * `op` points to a valid object.
 *
 * Py_XSETREF is a variant of Py_SETREF that uses Py_XDECREF instead of
 * Py_DECREF.
 */

// #define Py_SETREF(op, op2)
//     do {
//         PyObject *_py_tmp = (PyObject *)(op);
//         (op) = (op2);
//         Py_DECREF(_py_tmp);
//     } while (0)

// #define Py_XSETREF(op, op2)
//     do {
//         PyObject *_py_tmp = (PyObject *)(op);
//         (op) = (op2);
//         Py_XDECREF(_py_tmp);
//     } while (0)

// #endif /* ifndef Py_LIMITED_API */

/*
These are provided as conveniences to Python runtime embedders, so that
they can have object code that is not dependent on Python compilation flags.
*/
@NoException public static native void Py_IncRef(PyObject arg0);
@NoException public static native void Py_DecRef(PyObject arg0);

// #ifndef Py_LIMITED_API
public static native @ByRef PyTypeObject _PyNone_Type(); public static native void _PyNone_Type(PyTypeObject _PyNone_Type);
public static native @ByRef PyTypeObject _PyNotImplemented_Type(); public static native void _PyNotImplemented_Type(PyTypeObject _PyNotImplemented_Type);
// #endif /* !Py_LIMITED_API */

/*
_Py_NoneStruct is an object of undefined type which can be used in contexts
where NULL (nil) is not suitable (since NULL often means 'error').

Don't forget to apply Py_INCREF() when returning this value!!!
*/
public static native @ByRef PyObject _Py_NoneStruct(); public static native void _Py_NoneStruct(PyObject _Py_NoneStruct); /* Don't use this directly */
// #define Py_None (&_Py_NoneStruct)

/* Macro for returning Py_None from a function */
// #define Py_RETURN_NONE return Py_INCREF(Py_None), Py_None

/*
Py_NotImplemented is a singleton used to signal that an operation is
not implemented for a given type combination.
*/
public static native @ByRef PyObject _Py_NotImplementedStruct(); public static native void _Py_NotImplementedStruct(PyObject _Py_NotImplementedStruct); /* Don't use this directly */
// #define Py_NotImplemented (&_Py_NotImplementedStruct)

/* Macro for returning Py_NotImplemented from a function */
// #define Py_RETURN_NOTIMPLEMENTED
//     return Py_INCREF(Py_NotImplemented), Py_NotImplemented

/* Rich comparison opcodes */
public static final int Py_LT = 0;
public static final int Py_LE = 1;
public static final int Py_EQ = 2;
public static final int Py_NE = 3;
public static final int Py_GT = 4;
public static final int Py_GE = 5;

// #ifndef Py_LIMITED_API
/* Maps Py_LT to Py_GT, ..., Py_GE to Py_LE.
 * Defined in object.c.
 */
public static native int _Py_SwappedOp(int i); public static native void _Py_SwappedOp(int i, int _Py_SwappedOp);
@MemberGetter public static native IntPointer _Py_SwappedOp();
// #endif /* !Py_LIMITED_API */


/*
More conventions
================

Argument Checking
-----------------

Functions that take objects as arguments normally don't check for nil
arguments, but they do check the type of the argument, and return an
error if the function doesn't apply to the type.

Failure Modes
-------------

Functions may fail for a variety of reasons, including running out of
memory.  This is communicated to the caller in two ways: an error string
is set (see errors.h), and the function result differs: functions that
normally return a pointer return NULL for failure, functions returning
an integer return -1 (which could be a legal return value too!), and
other functions return 0 for success and -1 for failure.
Callers should always check for errors before using the result.  If
an error was set, the caller must either explicitly clear it, or pass
the error on to its caller.

Reference Counts
----------------

It takes a while to get used to the proper usage of reference counts.

Functions that create an object set the reference count to 1; such new
objects must be stored somewhere or destroyed again with Py_DECREF().
Some functions that 'store' objects, such as PyTuple_SetItem() and
PyList_SetItem(),
don't increment the reference count of the object, since the most
frequent use is to store a fresh object.  Functions that 'retrieve'
objects, such as PyTuple_GetItem() and PyDict_GetItemString(), also
don't increment
the reference count, since most frequently the object is only looked at
quickly.  Thus, to retrieve an object and store it again, the caller
must call Py_INCREF() explicitly.

NOTE: functions that 'consume' a reference count, like
PyList_SetItem(), consume the reference even if the object wasn't
successfully stored, to simplify error handling.

It seems attractive to make other functions that take an object as
argument consume a reference count; however, this may quickly get
confusing (even the current practice is already confusing).  Consider
it carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at
times.
*/


/* Trashcan mechanism, thanks to Christian Tismer.

When deallocating a container object, it's possible to trigger an unbounded
chain of deallocations, as each Py_DECREF in turn drops the refcount on "the
next" object in the chain to 0.  This can easily lead to stack faults, and
especially in threads (which typically have less stack space to work with).

A container object that participates in cyclic gc can avoid this by
bracketing the body of its tp_dealloc function with a pair of macros:

static void
mytype_dealloc(mytype *p)
{
    ... declarations go here ...

    PyObject_GC_UnTrack(p);        // must untrack first
    Py_TRASHCAN_SAFE_BEGIN(p)
    ... The body of the deallocator goes here, including all calls ...
    ... to Py_DECREF on contained objects.                         ...
    Py_TRASHCAN_SAFE_END(p)
}

CAUTION:  Never return from the middle of the body!  If the body needs to
"get out early", put a label immediately before the Py_TRASHCAN_SAFE_END
call, and goto it.  Else the call-depth counter (see below) will stay
above 0 forever, and the trashcan will never get emptied.

How it works:  The BEGIN macro increments a call-depth counter.  So long
as this counter is small, the body of the deallocator is run directly without
further ado.  But if the counter gets large, it instead adds p to a list of
objects to be deallocated later, skips the body of the deallocator, and
resumes execution after the END macro.  The tp_dealloc routine then returns
without deallocating anything (and so unbounded call-stack depth is avoided).

When the call stack finishes unwinding again, code generated by the END macro
notices this, and calls another routine to deallocate all the objects that
may have been added to the list of deferred deallocations.  In effect, a
chain of N deallocations is broken into N / PyTrash_UNWIND_LEVEL pieces,
with the call stack never exceeding a depth of PyTrash_UNWIND_LEVEL.
*/

// #ifndef Py_LIMITED_API
/* This is the old private API, invoked by the macros before 3.2.4.
   Kept for binary compatibility of extensions using the stable ABI. */
@NoException public static native void _PyTrash_deposit_object(PyObject arg0);
@NoException public static native void _PyTrash_destroy_chain();
public static native int _PyTrash_delete_nesting(); public static native void _PyTrash_delete_nesting(int _PyTrash_delete_nesting);
public static native PyObject _PyTrash_delete_later(); public static native void _PyTrash_delete_later(PyObject _PyTrash_delete_later);
// #endif /* !Py_LIMITED_API */

/* The new thread-safe private API, invoked by the macros below. */
@NoException public static native void _PyTrash_thread_deposit_object(PyObject arg0);
@NoException public static native void _PyTrash_thread_destroy_chain();

public static final int PyTrash_UNWIND_LEVEL = 50;

// #define Py_TRASHCAN_SAFE_BEGIN(op)
//     do {
//         PyThreadState *_tstate = PyThreadState_GET();
//         if (_tstate->trash_delete_nesting < PyTrash_UNWIND_LEVEL) {
//             ++_tstate->trash_delete_nesting;
            /* The body of the deallocator is here. */
// #define Py_TRASHCAN_SAFE_END(op)
//             --_tstate->trash_delete_nesting;
//             if (_tstate->trash_delete_later && _tstate->trash_delete_nesting <= 0)
//                 _PyTrash_thread_destroy_chain();
//         }
//         else
//             _PyTrash_thread_deposit_object((PyObject*)op);
//     } while (0);

// #ifndef Py_LIMITED_API
@NoException public static native void _PyDebugAllocatorStats(@Cast("FILE*") Pointer out, @Cast("const char*") BytePointer block_name, int num_blocks,
                       @Cast("size_t") long sizeof_block);
@NoException public static native void _PyDebugAllocatorStats(@Cast("FILE*") Pointer out, String block_name, int num_blocks,
                       @Cast("size_t") long sizeof_block);
@NoException public static native void _PyObject_DebugTypeStats(@Cast("FILE*") Pointer out);
// #endif /* ifndef Py_LIMITED_API */

/* 
   Define a pair of assertion macros.

   These work like the regular C assert(), in that they will abort the
   process with a message on stderr if the given condition fails to hold,
   but compile away to nothing if NDEBUG is defined.

   However, before aborting, Python will also try to call _PyObject_Dump() on
   the given object.  This may be of use when investigating bugs in which a
   particular object is corrupt (e.g. buggy a tp_visit method in an extension
   module breaking the garbage collector), to help locate the broken objects.

   The WITH_MSG variant allows you to supply an additional message that Python
   will attempt to print to stderr, after the object dump.
*/
// #ifdef NDEBUG
/* No debugging: compile away the assertions: */
// #define PyObject_ASSERT_WITH_MSG(obj, expr, msg) ((void)0)
// #else
/* With debugging: generate checks: */
// #define PyObject_ASSERT_WITH_MSG(obj, expr, msg)
//   ((expr)
//    ? (void)(0)
//    : _PyObject_AssertFailed((obj),
//                             (msg),
//                             (__STRING(expr)),
//                             (__FILE__),
//                             (__LINE__),
//                             (__PRETTY_FUNCTION__)))
// #endif

// #define PyObject_ASSERT(obj, expr)
//   PyObject_ASSERT_WITH_MSG(obj, expr, NULL)

/* 
   Declare and define the entrypoint even when NDEBUG is defined, to avoid
   causing compiler/linker errors when building extensions without NDEBUG
   against a Python built with NDEBUG defined
*/
@NoException public static native void _PyObject_AssertFailed(PyObject arg0,  @Cast("const char*") BytePointer arg1,
                                        @Cast("const char*") BytePointer arg2, @Cast("const char*") BytePointer arg3, int arg4,
                                        @Cast("const char*") BytePointer arg5);
@NoException public static native void _PyObject_AssertFailed(PyObject arg0,  String arg1,
                                        String arg2, String arg3, int arg4,
                                        String arg5);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_OBJECT_H */


// Parsed from methodobject.h


/* Method object interface */

// #ifndef Py_METHODOBJECT_H
// #define Py_METHODOBJECT_H
// #ifdef __cplusplus
// #endif

/* This is about the type 'builtin_function_or_method',
   not Python methods in user-defined classes.  See classobject.h
   for the latter. */

public static native @ByRef PyTypeObject PyCFunction_Type(); public static native void PyCFunction_Type(PyTypeObject PyCFunction_Type);

// #define PyCFunction_Check(op) (Py_TYPE(op) == &PyCFunction_Type)

public static class PyCFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    PyCFunction(Pointer p) { super(p); }
    protected PyCFunction() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject arg0, PyObject arg1);
}
public static class _PyCFunctionFast extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    _PyCFunctionFast(Pointer p) { super(p); }
    protected _PyCFunctionFast() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject self, @ByPtrPtr PyObject args,
                                       @Cast("Py_ssize_t") long nargs, PyObject kwnames);
}
public static class PyCFunctionWithKeywords extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    PyCFunctionWithKeywords(Pointer p) { super(p); }
    protected PyCFunctionWithKeywords() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject arg0, PyObject arg1,
                                             PyObject arg2);
}
public static class PyNoArgsFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    PyNoArgsFunction(Pointer p) { super(p); }
    protected PyNoArgsFunction() { allocate(); }
    private native void allocate();
    public native PyObject call(PyObject arg0);
}

@NoException public static native PyCFunction PyCFunction_GetFunction(PyObject arg0);
@NoException public static native PyObject PyCFunction_GetSelf(PyObject arg0);
@NoException public static native int PyCFunction_GetFlags(PyObject arg0);

/* Macros for direct access to these values. Type checks are *not*
   done, so use with care. */
// #ifndef Py_LIMITED_API
// #define PyCFunction_GET_FUNCTION(func)
//         (((PyCFunctionObject *)func) -> m_ml -> ml_meth)
// #define PyCFunction_GET_SELF(func)
//         (((PyCFunctionObject *)func) -> m_ml -> ml_flags & METH_STATIC ?
//          NULL : ((PyCFunctionObject *)func) -> m_self)
// #define PyCFunction_GET_FLAGS(func)
//         (((PyCFunctionObject *)func) -> m_ml -> ml_flags)
// #endif
@NoException public static native PyObject PyCFunction_Call(PyObject arg0, PyObject arg1, PyObject arg2);

// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyCFunction_FastCallDict(PyObject func,
    @Cast("PyObject**") PointerPointer args,
    @Cast("Py_ssize_t") long nargs,
    PyObject kwargs);
@NoException public static native PyObject _PyCFunction_FastCallDict(PyObject func,
    @ByPtrPtr PyObject args,
    @Cast("Py_ssize_t") long nargs,
    PyObject kwargs);

@NoException public static native PyObject _PyCFunction_FastCallKeywords(PyObject func,
    @Cast("PyObject**") PointerPointer stack,
    @Cast("Py_ssize_t") long nargs,
    PyObject kwnames);
@NoException public static native PyObject _PyCFunction_FastCallKeywords(PyObject func,
    @ByPtrPtr PyObject stack,
    @Cast("Py_ssize_t") long nargs,
    PyObject kwnames);
// #endif

public static class PyMethodDef extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyMethodDef() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyMethodDef(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyMethodDef(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyMethodDef position(long position) {
        return (PyMethodDef)super.position(position);
    }

    @MemberGetter public native @Cast("const char*") BytePointer ml_name();   /* The name of the built-in function/method */
    public native PyCFunction ml_meth(); public native PyMethodDef ml_meth(PyCFunction ml_meth);    /* The C function that implements it */
    public native int ml_flags(); public native PyMethodDef ml_flags(int ml_flags);   /* Combination of METH_xxx flags, which mostly
                               describe the args expected by the C func */
    @MemberGetter public native @Cast("const char*") BytePointer ml_doc();    /* The __doc__ attribute, or NULL */
}

// #define PyCFunction_New(ML, SELF) PyCFunction_NewEx((ML), (SELF), NULL)
@NoException public static native PyObject PyCFunction_NewEx(PyMethodDef arg0, PyObject arg1,
                                         PyObject arg2);

/* Flag passed to newmethodobject */
/* #define METH_OLDARGS  0x0000   -- unsupported now */
public static final int METH_VARARGS =  0x0001;
public static final int METH_KEYWORDS = 0x0002;
/* METH_NOARGS and METH_O must not be combined with the flags above. */
public static final int METH_NOARGS =   0x0004;
public static final int METH_O =        0x0008;

/* METH_CLASS and METH_STATIC are a little different; these control
   the construction of methods for a class.  These cannot be used for
   functions in modules. */
public static final int METH_CLASS =    0x0010;
public static final int METH_STATIC =   0x0020;

/* METH_COEXIST allows a method to be entered even though a slot has
   already filled the entry.  When defined, the flag allows a separate
   method, "__contains__" for example, to coexist with a defined
   slot like sq_contains. */

public static final int METH_COEXIST =   0x0040;

// #ifndef Py_LIMITED_API
public static final int METH_FASTCALL =  0x0080;

public static class PyCFunctionObject extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyCFunctionObject() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyCFunctionObject(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyCFunctionObject(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyCFunctionObject position(long position) {
        return (PyCFunctionObject)super.position(position);
    }

    public native @ByRef PyObject ob_base(); public native PyCFunctionObject ob_base(PyObject ob_base);
    public native PyMethodDef m_ml(); public native PyCFunctionObject m_ml(PyMethodDef m_ml); /* Description of the C function to call */
    public native PyObject m_self(); public native PyCFunctionObject m_self(PyObject m_self); /* Passed as 'self' arg to the C func, can be NULL */
    public native PyObject m_module(); public native PyCFunctionObject m_module(PyObject m_module); /* The __module__ attribute, can be anything */
    public native PyObject m_weakreflist(); public native PyCFunctionObject m_weakreflist(PyObject m_weakreflist); /* List of weak references */
}
// #endif

@NoException public static native int PyCFunction_ClearFreeList();

// #ifndef Py_LIMITED_API
@NoException public static native void _PyCFunction_DebugMallocStats(@Cast("FILE*") Pointer out);
@NoException public static native void _PyMethod_DebugMallocStats(@Cast("FILE*") Pointer out);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_METHODOBJECT_H */


// Parsed from moduleobject.h


/* Module object interface */

// #ifndef Py_MODULEOBJECT_H
// #define Py_MODULEOBJECT_H
// #ifdef __cplusplus
// #endif

public static native @ByRef PyTypeObject PyModule_Type(); public static native void PyModule_Type(PyTypeObject PyModule_Type);

// #define PyModule_Check(op) PyObject_TypeCheck(op, &PyModule_Type)
// #define PyModule_CheckExact(op) (Py_TYPE(op) == &PyModule_Type)

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyModule_NewObject(
    PyObject name
    );
// #endif
@NoException public static native PyObject PyModule_New(
    @Cast("const char*") BytePointer name
    );
@NoException public static native PyObject PyModule_New(
    String name
    );
@NoException public static native PyObject PyModule_GetDict(PyObject arg0);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native PyObject PyModule_GetNameObject(PyObject arg0);
// #endif
@NoException public static native @Cast("const char*") BytePointer PyModule_GetName(PyObject arg0);
@NoException public static native @Cast("const char*") BytePointer PyModule_GetFilename(PyObject arg0);
@NoException public static native PyObject PyModule_GetFilenameObject(PyObject arg0);
// #ifndef Py_LIMITED_API
@NoException public static native void _PyModule_Clear(PyObject arg0);
@NoException public static native void _PyModule_ClearDict(PyObject arg0);
// #endif
@NoException public static native PyModuleDef PyModule_GetDef(PyObject arg0);
@NoException public static native Pointer PyModule_GetState(PyObject arg0);

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* New in 3.5 */
@NoException public static native PyObject PyModuleDef_Init(PyModuleDef arg0);
public static native @ByRef PyTypeObject PyModuleDef_Type(); public static native void PyModuleDef_Type(PyTypeObject PyModuleDef_Type);
// #endif

public static class PyModuleDef_Base extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyModuleDef_Base() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyModuleDef_Base(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyModuleDef_Base(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyModuleDef_Base position(long position) {
        return (PyModuleDef_Base)super.position(position);
    }

  public native @ByRef PyObject ob_base(); public native PyModuleDef_Base ob_base(PyObject ob_base);
  public static class PyObject_M_init extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    PyObject_M_init(Pointer p) { super(p); }
      protected PyObject_M_init() { allocate(); }
      private native void allocate();
      public native PyObject call();
  }
  public native PyObject_M_init m_init(); public native PyModuleDef_Base m_init(PyObject_M_init m_init);
  public native @Cast("Py_ssize_t") long m_index(); public native PyModuleDef_Base m_index(long m_index);
  public native PyObject m_copy(); public native PyModuleDef_Base m_copy(PyObject m_copy);
}

// #define PyModuleDef_HEAD_INIT {
//     PyObject_HEAD_INIT(NULL)
//     NULL, /* m_init */
//     0,    /* m_index */
//     NULL, /* m_copy */
//   }
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
/* New in 3.5 */
public static class PyModuleDef_Slot extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyModuleDef_Slot() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyModuleDef_Slot(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyModuleDef_Slot(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyModuleDef_Slot position(long position) {
        return (PyModuleDef_Slot)super.position(position);
    }

    public native int slot(); public native PyModuleDef_Slot slot(int slot);
    public native Pointer value(); public native PyModuleDef_Slot value(Pointer value);
}

public static final int Py_mod_create = 1;
public static final int Py_mod_exec = 2;

// #ifndef Py_LIMITED_API
public static final int _Py_mod_LAST_SLOT = 2;
// #endif

// #endif /* New in 3.5 */

public static class PyModuleDef extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyModuleDef() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyModuleDef(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyModuleDef(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyModuleDef position(long position) {
        return (PyModuleDef)super.position(position);
    }

  public native @ByRef PyModuleDef_Base m_base(); public native PyModuleDef m_base(PyModuleDef_Base m_base);
  @MemberGetter public native @Cast("const char*") BytePointer m_name();
  @MemberGetter public native @Cast("const char*") BytePointer m_doc();
  public native @Cast("Py_ssize_t") long m_size(); public native PyModuleDef m_size(long m_size);
  public native PyMethodDef m_methods(); public native PyModuleDef m_methods(PyMethodDef m_methods);
  public native PyModuleDef_Slot m_slots(); public native PyModuleDef m_slots(PyModuleDef_Slot m_slots);
  public native traverseproc m_traverse(); public native PyModuleDef m_traverse(traverseproc m_traverse);
  public native inquiry m_clear(); public native PyModuleDef m_clear(inquiry m_clear);
  public native freefunc m_free(); public native PyModuleDef m_free(freefunc m_free);
}

// #ifdef __cplusplus
// #endif
// #endif /* !Py_MODULEOBJECT_H */


// Parsed from pyarena.h

/* An arena-like memory interface for the compiler.
 */

// #ifndef Py_LIMITED_API
// #ifndef Py_PYARENA_H
// #define Py_PYARENA_H

// #ifdef __cplusplus
// #endif

  @Opaque public static class PyArena extends Pointer {
      /** Empty constructor. Calls {@code super((Pointer)null)}. */
      public PyArena() { super((Pointer)null); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public PyArena(Pointer p) { super(p); }
  }

  /* PyArena_New() and PyArena_Free() create a new arena and free it,
     respectively.  Once an arena has been created, it can be used
     to allocate memory via PyArena_Malloc().  Pointers to PyObject can
     also be registered with the arena via PyArena_AddPyObject(), and the
     arena will ensure that the PyObjects stay alive at least until
     PyArena_Free() is called.  When an arena is freed, all the memory it
     allocated is freed, the arena releases internal references to registered
     PyObject*, and none of its pointers are valid.
     XXX (tim) What does "none of its pointers are valid" mean?  Does it
     XXX mean that pointers previously obtained via PyArena_Malloc() are
     XXX no longer valid?  (That's clearly true, but not sure that's what
     XXX the text is trying to say.)

     PyArena_New() returns an arena pointer.  On error, it
     returns a negative number and sets an exception.
     XXX (tim):  Not true.  On error, PyArena_New() actually returns NULL,
     XXX and looks like it may or may not set an exception (e.g., if the
     XXX internal PyList_New(0) returns NULL, PyArena_New() passes that on
     XXX and an exception is set; OTOH, if the internal
     XXX block_new(DEFAULT_BLOCK_SIZE) returns NULL, that's passed on but
     XXX an exception is not set in that case).
  */
  @NoException public static native PyArena PyArena_New();
  @NoException public static native void PyArena_Free(PyArena arg0);

  /* Mostly like malloc(), return the address of a block of memory spanning
   * `size` bytes, or return NULL (without setting an exception) if enough
   * new memory can't be obtained.  Unlike malloc(0), PyArena_Malloc() with
   * size=0 does not guarantee to return a unique pointer (the pointer
   * returned may equal one or more other pointers obtained from
   * PyArena_Malloc()).
   * Note that pointers obtained via PyArena_Malloc() must never be passed to
   * the system free() or realloc(), or to any of Python's similar memory-
   * management functions.  PyArena_Malloc()-obtained pointers remain valid
   * until PyArena_Free(ar) is called, at which point all pointers obtained
   * from the arena `ar` become invalid simultaneously.
   */
  @NoException public static native Pointer PyArena_Malloc(PyArena arg0, @Cast("size_t") long size);

  /* This routine isn't a proper arena allocation routine.  It takes
   * a PyObject* and records it so that it can be DECREFed when the
   * arena is freed.
   */
  @NoException public static native int PyArena_AddPyObject(PyArena arg0, PyObject arg1);

// #ifdef __cplusplus
// #endif

// #endif /* !Py_PYARENA_H */
// #endif /* Py_LIMITED_API */


// Parsed from pystate.h


/* Thread and interpreter state structures and their interfaces */


// #ifndef Py_PYSTATE_H
// #define Py_PYSTATE_H
// #ifdef __cplusplus
// #endif

/* This limitation is for performance and simplicity. If needed it can be
removed (with effort). */
public static final int MAX_CO_EXTRA_USERS = 255;

/* State shared between threads */

@Opaque public static class _ts extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public _ts() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _ts(Pointer p) { super(p); }
} /* Forward */
@Opaque public static class _is extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public _is() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _is(Pointer p) { super(p); }
} /* Forward */
@Opaque public static class _frame extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public _frame() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _frame(Pointer p) { super(p); }
} /* Forward declaration for PyFrameObject. */

// #ifdef Py_LIMITED_API
// #else
public static class _PyFrameEvalFunction extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    _PyFrameEvalFunction(Pointer p) { super(p); }
    protected _PyFrameEvalFunction() { allocate(); }
    private native void allocate();
    public native PyObject call(_frame arg0, int arg1);
}

public static class PyInterpreterState extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyInterpreterState() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyInterpreterState(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyInterpreterState(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyInterpreterState position(long position) {
        return (PyInterpreterState)super.position(position);
    }


    public native _is next(); public native PyInterpreterState next(_is next);
    public native _ts tstate_head(); public native PyInterpreterState tstate_head(_ts tstate_head);

    public native PyObject modules(); public native PyInterpreterState modules(PyObject modules);
    public native PyObject modules_by_index(); public native PyInterpreterState modules_by_index(PyObject modules_by_index);
    public native PyObject sysdict(); public native PyInterpreterState sysdict(PyObject sysdict);
    public native PyObject builtins(); public native PyInterpreterState builtins(PyObject builtins);
    public native PyObject importlib(); public native PyInterpreterState importlib(PyObject importlib);

    public native PyObject codec_search_path(); public native PyInterpreterState codec_search_path(PyObject codec_search_path);
    public native PyObject codec_search_cache(); public native PyInterpreterState codec_search_cache(PyObject codec_search_cache);
    public native PyObject codec_error_registry(); public native PyInterpreterState codec_error_registry(PyObject codec_error_registry);
    public native int codecs_initialized(); public native PyInterpreterState codecs_initialized(int codecs_initialized);
    public native int fscodec_initialized(); public native PyInterpreterState fscodec_initialized(int fscodec_initialized);

// #ifdef HAVE_DLOPEN
// #endif

    public native PyObject builtins_copy(); public native PyInterpreterState builtins_copy(PyObject builtins_copy);
    public native PyObject import_func(); public native PyInterpreterState import_func(PyObject import_func);
    /* Initialized to PyEval_EvalFrameDefault(). */
    public native _PyFrameEvalFunction eval_frame(); public native PyInterpreterState eval_frame(_PyFrameEvalFunction eval_frame);
}
// #endif

public static class __PyCodeExtraState extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public __PyCodeExtraState() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public __PyCodeExtraState(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public __PyCodeExtraState(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public __PyCodeExtraState position(long position) {
        return (__PyCodeExtraState)super.position(position);
    }

    public native @Cast("_co_extra_state*") __PyCodeExtraState next(); public native __PyCodeExtraState next(__PyCodeExtraState next);
    public native PyInterpreterState interp(); public native __PyCodeExtraState interp(PyInterpreterState interp);

    public native @Cast("Py_ssize_t") long co_extra_user_count(); public native __PyCodeExtraState co_extra_user_count(long co_extra_user_count);
    
}

/* This is temporary for backwards compat in 3.6 and will be removed in 3.7 */


/* State unique per thread */

// #ifndef Py_LIMITED_API
/* Py_tracefunc return -1 when raising an exception, or 0 for success. */
public static class Py_tracefunc extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Py_tracefunc(Pointer p) { super(p); }
    protected Py_tracefunc() { allocate(); }
    private native void allocate();
    public native int call(PyObject arg0, _frame arg1, int arg2, PyObject arg3);
}

/* The following values are used for 'what' for tracefunc functions: */
public static final int PyTrace_CALL = 0;
public static final int PyTrace_EXCEPTION = 1;
public static final int PyTrace_LINE = 2;
public static final int PyTrace_RETURN = 3;
public static final int PyTrace_C_CALL = 4;
public static final int PyTrace_C_EXCEPTION = 5;
public static final int PyTrace_C_RETURN = 6;
// #endif

// #ifdef Py_LIMITED_API
// #else
public static class PyThreadState extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyThreadState() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyThreadState(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyThreadState(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyThreadState position(long position) {
        return (PyThreadState)super.position(position);
    }

    /* See Python/ceval.c for comments explaining most fields */

    public native _ts prev(); public native PyThreadState prev(_ts prev);
    public native _ts next(); public native PyThreadState next(_ts next);
    public native PyInterpreterState interp(); public native PyThreadState interp(PyInterpreterState interp);

    public native _frame frame(); public native PyThreadState frame(_frame frame);
    public native int recursion_depth(); public native PyThreadState recursion_depth(int recursion_depth);
    public native @Cast("char") byte overflowed(); public native PyThreadState overflowed(byte overflowed); /* The stack has overflowed. Allow 50 more calls
                        to handle the runtime error. */
    public native @Cast("char") byte recursion_critical(); public native PyThreadState recursion_critical(byte recursion_critical); /* The current calls must not cause
                                a stack overflow. */
    /* 'tracing' keeps track of the execution depth when tracing/profiling.
       This is to prevent the actual trace/profile code from being recorded in
       the trace/profile. */
    public native int tracing(); public native PyThreadState tracing(int tracing);
    public native int use_tracing(); public native PyThreadState use_tracing(int use_tracing);

    public native Py_tracefunc c_profilefunc(); public native PyThreadState c_profilefunc(Py_tracefunc c_profilefunc);
    public native Py_tracefunc c_tracefunc(); public native PyThreadState c_tracefunc(Py_tracefunc c_tracefunc);
    public native PyObject c_profileobj(); public native PyThreadState c_profileobj(PyObject c_profileobj);
    public native PyObject c_traceobj(); public native PyThreadState c_traceobj(PyObject c_traceobj);

    public native PyObject curexc_type(); public native PyThreadState curexc_type(PyObject curexc_type);
    public native PyObject curexc_value(); public native PyThreadState curexc_value(PyObject curexc_value);
    public native PyObject curexc_traceback(); public native PyThreadState curexc_traceback(PyObject curexc_traceback);

    public native PyObject exc_type(); public native PyThreadState exc_type(PyObject exc_type);
    public native PyObject exc_value(); public native PyThreadState exc_value(PyObject exc_value);
    public native PyObject exc_traceback(); public native PyThreadState exc_traceback(PyObject exc_traceback);

    public native PyObject dict(); public native PyThreadState dict(PyObject dict);  /* Stores per-thread state */

    public native int gilstate_counter(); public native PyThreadState gilstate_counter(int gilstate_counter);

    public native PyObject async_exc(); public native PyThreadState async_exc(PyObject async_exc); /* Asynchronous exception to raise */
    public native long thread_id(); public native PyThreadState thread_id(long thread_id); /* Thread id where this tstate was created */

    public native int trash_delete_nesting(); public native PyThreadState trash_delete_nesting(int trash_delete_nesting);
    public native PyObject trash_delete_later(); public native PyThreadState trash_delete_later(PyObject trash_delete_later);

    /* Called when a thread state is deleted normally, but not when it
     * is destroyed after fork().
     * Pain:  to prevent rare but fatal shutdown errors (issue 18808),
     * Thread.join() must wait for the join'ed thread's tstate to be unlinked
     * from the tstate chain.  That happens at the end of a thread's life,
     * in pystate.c.
     * The obvious way doesn't quite work:  create a lock which the tstate
     * unlinking code releases, and have Thread.join() wait to acquire that
     * lock.  The problem is that we _are_ at the end of the thread's life:
     * if the thread holds the last reference to the lock, decref'ing the
     * lock will delete the lock, and that may trigger arbitrary Python code
     * if there's a weakref, with a callback, to the lock.  But by this time
     * _PyThreadState_Current is already NULL, so only the simplest of C code
     * can be allowed to run (in particular it must not be possible to
     * release the GIL).
     * So instead of holding the lock directly, the tstate holds a weakref to
     * the lock:  that's the value of on_delete_data below.  Decref'ing a
     * weakref is harmless.
     * on_delete points to _threadmodule.c's static release_sentinel() function.
     * After the tstate is unlinked, release_sentinel is called with the
     * weakref-to-lock (on_delete_data) argument, and release_sentinel releases
     * the indirectly held lock.
     */
    public static class On_delete_Pointer extends FunctionPointer {
        static { Loader.load(); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public    On_delete_Pointer(Pointer p) { super(p); }
        protected On_delete_Pointer() { allocate(); }
        private native void allocate();
        public native void call(Pointer arg0);
    }
    public native On_delete_Pointer on_delete(); public native PyThreadState on_delete(On_delete_Pointer on_delete);
    public native Pointer on_delete_data(); public native PyThreadState on_delete_data(Pointer on_delete_data);

    public native PyObject coroutine_wrapper(); public native PyThreadState coroutine_wrapper(PyObject coroutine_wrapper);
    public native int in_coroutine_wrapper(); public native PyThreadState in_coroutine_wrapper(int in_coroutine_wrapper);

    /* Now used from PyInterpreterState, kept here for ABI
       compatibility with PyThreadState */
    
    

    public native PyObject async_gen_firstiter(); public native PyThreadState async_gen_firstiter(PyObject async_gen_firstiter);
    public native PyObject async_gen_finalizer(); public native PyThreadState async_gen_finalizer(PyObject async_gen_finalizer);

    /* XXX signal handlers should also be here */

}
// #endif


@NoException public static native PyInterpreterState PyInterpreterState_New();
@NoException public static native void PyInterpreterState_Clear(PyInterpreterState arg0);
@NoException public static native void PyInterpreterState_Delete(PyInterpreterState arg0);
// #ifndef Py_LIMITED_API
@NoException public static native int _PyState_AddModule(PyObject arg0, PyModuleDef arg1);
// #endif /* !Py_LIMITED_API */
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
/* New in 3.3 */
@NoException public static native int PyState_AddModule(PyObject arg0, PyModuleDef arg1);
@NoException public static native int PyState_RemoveModule(PyModuleDef arg0);
// #endif
@NoException public static native PyObject PyState_FindModule(PyModuleDef arg0);
// #ifndef Py_LIMITED_API
@NoException public static native void _PyState_ClearModules();
// #endif

@NoException public static native PyThreadState PyThreadState_New(PyInterpreterState arg0);
// #ifndef Py_LIMITED_API
@NoException public static native PyThreadState _PyThreadState_Prealloc(PyInterpreterState arg0);
@NoException public static native void _PyThreadState_Init(PyThreadState arg0);
// #endif /* !Py_LIMITED_API */
@NoException public static native void PyThreadState_Clear(PyThreadState arg0);
@NoException public static native void PyThreadState_Delete(PyThreadState arg0);
// #ifndef Py_LIMITED_API
@NoException public static native void _PyThreadState_DeleteExcept(PyThreadState tstate);
// #endif /* !Py_LIMITED_API */
// #ifdef WITH_THREAD
@NoException public static native void PyThreadState_DeleteCurrent();
// #ifndef Py_LIMITED_API
@NoException public static native void _PyGILState_Reinit();
// #endif /* !Py_LIMITED_API */
// #endif

/* Return the current thread state. The global interpreter lock must be held.
 * When the current thread state is NULL, this issues a fatal error (so that
 * the caller needn't check for NULL). */
@NoException public static native PyThreadState PyThreadState_Get();

// #ifndef Py_LIMITED_API
/* Similar to PyThreadState_Get(), but don't issue a fatal error
 * if it is NULL. */
@NoException public static native PyThreadState _PyThreadState_UncheckedGet();
// #endif /* !Py_LIMITED_API */

@NoException public static native PyThreadState PyThreadState_Swap(PyThreadState arg0);
@NoException public static native PyObject PyThreadState_GetDict();
@NoException public static native int PyThreadState_SetAsyncExc(long arg0, PyObject arg1);


/* Variable and macro for in-line access to current thread state */

/* Assuming the current thread holds the GIL, this is the
   PyThreadState for the current thread. */
// #ifdef Py_BUILD_CORE
// #  define PyThreadState_GET()
//              ((PyThreadState*)_Py_atomic_load_relaxed(&_PyThreadState_Current))
// #else
// #  define PyThreadState_GET() PyThreadState_Get()
// #endif

/** enum PyGILState_STATE */
public static final int PyGILState_LOCKED = 0, PyGILState_UNLOCKED = 1;

// #ifdef WITH_THREAD

/* Ensure that the current thread is ready to call the Python
   C API, regardless of the current state of Python, or of its
   thread lock.  This may be called as many times as desired
   by a thread so long as each call is matched with a call to
   PyGILState_Release().  In general, other thread-state APIs may
   be used between _Ensure() and _Release() calls, so long as the
   thread-state is restored to its previous state before the Release().
   For example, normal use of the Py_BEGIN_ALLOW_THREADS/
   Py_END_ALLOW_THREADS macros are acceptable.

   The return value is an opaque "handle" to the thread state when
   PyGILState_Ensure() was called, and must be passed to
   PyGILState_Release() to ensure Python is left in the same state. Even
   though recursive calls are allowed, these handles can *not* be shared -
   each unique call to PyGILState_Ensure must save the handle for its
   call to PyGILState_Release.

   When the function returns, the current thread will hold the GIL.

   Failure is a fatal error.
*/
@NoException public static native @Cast("PyGILState_STATE") int PyGILState_Ensure();

/* Release any resources previously acquired.  After this call, Python's
   state will be the same as it was prior to the corresponding
   PyGILState_Ensure() call (but generally this state will be unknown to
   the caller, hence the use of the GILState API.)

   Every call to PyGILState_Ensure must be matched by a call to
   PyGILState_Release on the same thread.
*/
@NoException public static native void PyGILState_Release(@Cast("PyGILState_STATE") int arg0);

/* Helper/diagnostic function - get the current thread state for
   this thread.  May return NULL if no GILState API has been used
   on the current thread.  Note that the main thread always has such a
   thread-state, even if no auto-thread-state call has been made
   on the main thread.
*/
@NoException public static native PyThreadState PyGILState_GetThisThreadState();

// #ifndef Py_LIMITED_API
/* Issue #26558: Flag to disable PyGILState_Check().
   If set to non-zero, PyGILState_Check() always return 1. */
public static native int _PyGILState_check_enabled(); public static native void _PyGILState_check_enabled(int _PyGILState_check_enabled);

/* Helper/diagnostic function - return 1 if the current thread
   currently holds the GIL, 0 otherwise.

   The function returns 1 if _PyGILState_check_enabled is non-zero. */
@NoException public static native int PyGILState_Check();

/* Unsafe function to get the single PyInterpreterState used by this process'
   GILState implementation.

   Return NULL before _PyGILState_Init() is called and after _PyGILState_Fini()
   is called. */
@NoException public static native PyInterpreterState _PyGILState_GetInterpreterStateUnsafe();
// #endif

// #endif   /* #ifdef WITH_THREAD */

/* The implementation of sys._current_frames()  Returns a dict mapping
   thread id to that thread's current frame.
*/
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyThread_CurrentFrames();
// #endif

/* Routines for advanced debuggers, requested by David Beazley.
   Don't use unless you know what you are doing! */
// #ifndef Py_LIMITED_API
@NoException public static native PyInterpreterState PyInterpreterState_Head();
@NoException public static native PyInterpreterState PyInterpreterState_Next(PyInterpreterState arg0);
@NoException public static native PyThreadState PyInterpreterState_ThreadHead(PyInterpreterState arg0);
@NoException public static native PyThreadState PyThreadState_Next(PyThreadState arg0);
// #endif

/* hook for PyEval_GetFrame(), requested for Psyco */
// #ifndef Py_LIMITED_API
public static native @ByRef @Cast("PyThreadFrameGetter*") Pointer _PyThreadState_GetFrame(); public static native void _PyThreadState_GetFrame(Pointer _PyThreadState_GetFrame);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYSTATE_H */


// Parsed from asdl.h

// #ifndef Py_ASDL_H
// #define Py_ASDL_H

/* It would be nice if the code generated by asdl_c.py was completely
   independent of Python, but it is a goal the requires too much work
   at this stage.  So, for example, I'll represent identifiers as
   interned Python strings.
*/

/* XXX A sequence should be typed so that its use can be typechecked. */

public static class asdl_seq extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public asdl_seq() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public asdl_seq(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public asdl_seq(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public asdl_seq position(long position) {
        return (asdl_seq)super.position(position);
    }

    public native @Cast("Py_ssize_t") long size(); public native asdl_seq size(long size);
    public native Pointer elements(int i); public native asdl_seq elements(int i, Pointer elements);
    @MemberGetter public native @Cast("void**") PointerPointer elements();
}

public static class asdl_int_seq extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public asdl_int_seq() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public asdl_int_seq(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public asdl_int_seq(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public asdl_int_seq position(long position) {
        return (asdl_int_seq)super.position(position);
    }

    public native @Cast("Py_ssize_t") long size(); public native asdl_int_seq size(long size);
    public native int elements(int i); public native asdl_int_seq elements(int i, int elements);
    @MemberGetter public native IntPointer elements();
}




// #define asdl_seq_GET(S, I) (S)->elements[(I)]
// #define asdl_seq_LEN(S) ((S) == NULL ? 0 : (S)->size)
// #ifdef Py_DEBUG
// #define asdl_seq_SET(S, I, V)
//     do {
//         Py_ssize_t _asdl_i = (I);
//         assert((S) != NULL);
//         assert(_asdl_i < (S)->size);
//         (S)->elements[_asdl_i] = (V);
//     } while (0)
// #else
// #define asdl_seq_SET(S, I, V) (S)->elements[I] = (V)
// #endif

// #endif /* !Py_ASDL_H */


// Parsed from Python-ast.h

/* File automatically generated by Parser/asdl_c.py. */

// #include "asdl.h"

/** enum _expr_context */
public static final int Load = 1, Store = 2, Del = 3, AugLoad = 4, AugStore = 5,
                             Param = 6;

/** enum _boolop */
public static final int And = 1, Or = 2;

/** enum _operator */
public static final int Add = 1, Sub = 2, Mult = 3, MatMult = 4, Div = 5, Mod = 6, Pow = 7,
                         LShift = 8, RShift = 9, BitOr = 10, BitXor = 11, BitAnd = 12,
                         FloorDiv = 13;

/** enum _unaryop */
public static final int Invert = 1, Not = 2, UAdd = 3, USub = 4;

/** enum _cmpop */
public static final int Eq = 1, NotEq = 2, Lt = 3, LtE = 4, Gt = 5, GtE = 6, Is = 7, IsNot = 8,
                      In = 9, NotIn = 10;


/** enum _mod_kind */
public static final int Module_kind = 1, Interactive_kind = 2, Expression_kind = 3,
                 Suite_kind = 4;
public static class _mod extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _mod() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _mod(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _mod(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _mod position(long position) {
        return (_mod)super.position(position);
    }

    public native @Cast("_mod_kind") int kind(); public native _mod kind(int kind);
            @Name("v.Module.body") public native asdl_seq v_Module_body(); public native _mod v_Module_body(asdl_seq v_Module_body);
        
            @Name("v.Interactive.body") public native asdl_seq v_Interactive_body(); public native _mod v_Interactive_body(asdl_seq v_Interactive_body);
        
            @Name("v.Expression.body") public native _expr v_Expression_body(); public native _mod v_Expression_body(_expr v_Expression_body);
        
            @Name("v.Suite.body") public native asdl_seq v_Suite_body(); public native _mod v_Suite_body(asdl_seq v_Suite_body);
}

/** enum _stmt_kind */
public static final int FunctionDef_kind = 1, AsyncFunctionDef_kind = 2, ClassDef_kind = 3,
                  Return_kind = 4, Delete_kind = 5, Assign_kind = 6,
                  AugAssign_kind = 7, AnnAssign_kind = 8, For_kind = 9,
                  AsyncFor_kind = 10, While_kind = 11, If_kind = 12, With_kind = 13,
                  AsyncWith_kind = 14, Raise_kind = 15, Try_kind = 16,
                  Assert_kind = 17, Import_kind = 18, ImportFrom_kind = 19,
                  Global_kind = 20, Nonlocal_kind = 21, Expr_kind = 22, Pass_kind = 23,
                  Break_kind = 24, Continue_kind = 25;
public static class _stmt extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _stmt() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _stmt(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _stmt(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _stmt position(long position) {
        return (_stmt)super.position(position);
    }

    public native @Cast("_stmt_kind") int kind(); public native _stmt kind(int kind);
            @Name("v.FunctionDef.name") public native @Cast("identifier") PyObject v_FunctionDef_name(); public native _stmt v_FunctionDef_name(PyObject v_FunctionDef_name);
            @Name("v.FunctionDef.args") public native _arguments v_FunctionDef_args(); public native _stmt v_FunctionDef_args(_arguments v_FunctionDef_args);
            @Name("v.FunctionDef.body") public native asdl_seq v_FunctionDef_body(); public native _stmt v_FunctionDef_body(asdl_seq v_FunctionDef_body);
            @Name("v.FunctionDef.decorator_list") public native asdl_seq v_FunctionDef_decorator_list(); public native _stmt v_FunctionDef_decorator_list(asdl_seq v_FunctionDef_decorator_list);
            @Name("v.FunctionDef.returns") public native _expr v_FunctionDef_returns(); public native _stmt v_FunctionDef_returns(_expr v_FunctionDef_returns);
        
            @Name("v.AsyncFunctionDef.name") public native @Cast("identifier") PyObject v_AsyncFunctionDef_name(); public native _stmt v_AsyncFunctionDef_name(PyObject v_AsyncFunctionDef_name);
            @Name("v.AsyncFunctionDef.args") public native _arguments v_AsyncFunctionDef_args(); public native _stmt v_AsyncFunctionDef_args(_arguments v_AsyncFunctionDef_args);
            @Name("v.AsyncFunctionDef.body") public native asdl_seq v_AsyncFunctionDef_body(); public native _stmt v_AsyncFunctionDef_body(asdl_seq v_AsyncFunctionDef_body);
            @Name("v.AsyncFunctionDef.decorator_list") public native asdl_seq v_AsyncFunctionDef_decorator_list(); public native _stmt v_AsyncFunctionDef_decorator_list(asdl_seq v_AsyncFunctionDef_decorator_list);
            @Name("v.AsyncFunctionDef.returns") public native _expr v_AsyncFunctionDef_returns(); public native _stmt v_AsyncFunctionDef_returns(_expr v_AsyncFunctionDef_returns);
        
            @Name("v.ClassDef.name") public native @Cast("identifier") PyObject v_ClassDef_name(); public native _stmt v_ClassDef_name(PyObject v_ClassDef_name);
            @Name("v.ClassDef.bases") public native asdl_seq v_ClassDef_bases(); public native _stmt v_ClassDef_bases(asdl_seq v_ClassDef_bases);
            @Name("v.ClassDef.keywords") public native asdl_seq v_ClassDef_keywords(); public native _stmt v_ClassDef_keywords(asdl_seq v_ClassDef_keywords);
            @Name("v.ClassDef.body") public native asdl_seq v_ClassDef_body(); public native _stmt v_ClassDef_body(asdl_seq v_ClassDef_body);
            @Name("v.ClassDef.decorator_list") public native asdl_seq v_ClassDef_decorator_list(); public native _stmt v_ClassDef_decorator_list(asdl_seq v_ClassDef_decorator_list);
        
            @Name("v.Return.value") public native _expr v_Return_value(); public native _stmt v_Return_value(_expr v_Return_value);
        
            @Name("v.Delete.targets") public native asdl_seq v_Delete_targets(); public native _stmt v_Delete_targets(asdl_seq v_Delete_targets);
        
            @Name("v.Assign.targets") public native asdl_seq v_Assign_targets(); public native _stmt v_Assign_targets(asdl_seq v_Assign_targets);
            @Name("v.Assign.value") public native _expr v_Assign_value(); public native _stmt v_Assign_value(_expr v_Assign_value);
        
            @Name("v.AugAssign.target") public native _expr v_AugAssign_target(); public native _stmt v_AugAssign_target(_expr v_AugAssign_target);
            @Name("v.AugAssign.op") public native @Cast("operator_ty") int v_AugAssign_op(); public native _stmt v_AugAssign_op(int v_AugAssign_op);
            @Name("v.AugAssign.value") public native _expr v_AugAssign_value(); public native _stmt v_AugAssign_value(_expr v_AugAssign_value);
        
            @Name("v.AnnAssign.target") public native _expr v_AnnAssign_target(); public native _stmt v_AnnAssign_target(_expr v_AnnAssign_target);
            @Name("v.AnnAssign.annotation") public native _expr v_AnnAssign_annotation(); public native _stmt v_AnnAssign_annotation(_expr v_AnnAssign_annotation);
            @Name("v.AnnAssign.value") public native _expr v_AnnAssign_value(); public native _stmt v_AnnAssign_value(_expr v_AnnAssign_value);
            @Name("v.AnnAssign.simple") public native int v_AnnAssign_simple(); public native _stmt v_AnnAssign_simple(int v_AnnAssign_simple);
        
            @Name("v.For.target") public native _expr v_For_target(); public native _stmt v_For_target(_expr v_For_target);
            @Name("v.For.iter") public native _expr v_For_iter(); public native _stmt v_For_iter(_expr v_For_iter);
            @Name("v.For.body") public native asdl_seq v_For_body(); public native _stmt v_For_body(asdl_seq v_For_body);
            @Name("v.For.orelse") public native asdl_seq v_For_orelse(); public native _stmt v_For_orelse(asdl_seq v_For_orelse);
        
            @Name("v.AsyncFor.target") public native _expr v_AsyncFor_target(); public native _stmt v_AsyncFor_target(_expr v_AsyncFor_target);
            @Name("v.AsyncFor.iter") public native _expr v_AsyncFor_iter(); public native _stmt v_AsyncFor_iter(_expr v_AsyncFor_iter);
            @Name("v.AsyncFor.body") public native asdl_seq v_AsyncFor_body(); public native _stmt v_AsyncFor_body(asdl_seq v_AsyncFor_body);
            @Name("v.AsyncFor.orelse") public native asdl_seq v_AsyncFor_orelse(); public native _stmt v_AsyncFor_orelse(asdl_seq v_AsyncFor_orelse);
        
            @Name("v.While.test") public native _expr v_While_test(); public native _stmt v_While_test(_expr v_While_test);
            @Name("v.While.body") public native asdl_seq v_While_body(); public native _stmt v_While_body(asdl_seq v_While_body);
            @Name("v.While.orelse") public native asdl_seq v_While_orelse(); public native _stmt v_While_orelse(asdl_seq v_While_orelse);
        
            @Name("v.If.test") public native _expr v_If_test(); public native _stmt v_If_test(_expr v_If_test);
            @Name("v.If.body") public native asdl_seq v_If_body(); public native _stmt v_If_body(asdl_seq v_If_body);
            @Name("v.If.orelse") public native asdl_seq v_If_orelse(); public native _stmt v_If_orelse(asdl_seq v_If_orelse);
        
            @Name("v.With.items") public native asdl_seq v_With_items(); public native _stmt v_With_items(asdl_seq v_With_items);
            @Name("v.With.body") public native asdl_seq v_With_body(); public native _stmt v_With_body(asdl_seq v_With_body);
        
            @Name("v.AsyncWith.items") public native asdl_seq v_AsyncWith_items(); public native _stmt v_AsyncWith_items(asdl_seq v_AsyncWith_items);
            @Name("v.AsyncWith.body") public native asdl_seq v_AsyncWith_body(); public native _stmt v_AsyncWith_body(asdl_seq v_AsyncWith_body);
        
            @Name("v.Raise.exc") public native _expr v_Raise_exc(); public native _stmt v_Raise_exc(_expr v_Raise_exc);
            @Name("v.Raise.cause") public native _expr v_Raise_cause(); public native _stmt v_Raise_cause(_expr v_Raise_cause);
        
            @Name("v.Try.body") public native asdl_seq v_Try_body(); public native _stmt v_Try_body(asdl_seq v_Try_body);
            @Name("v.Try.handlers") public native asdl_seq v_Try_handlers(); public native _stmt v_Try_handlers(asdl_seq v_Try_handlers);
            @Name("v.Try.orelse") public native asdl_seq v_Try_orelse(); public native _stmt v_Try_orelse(asdl_seq v_Try_orelse);
            @Name("v.Try.finalbody") public native asdl_seq v_Try_finalbody(); public native _stmt v_Try_finalbody(asdl_seq v_Try_finalbody);
        
            @Name("v.Assert.test") public native _expr v_Assert_test(); public native _stmt v_Assert_test(_expr v_Assert_test);
            @Name("v.Assert.msg") public native _expr v_Assert_msg(); public native _stmt v_Assert_msg(_expr v_Assert_msg);
        
            @Name("v.Import.names") public native asdl_seq v_Import_names(); public native _stmt v_Import_names(asdl_seq v_Import_names);
        
            @Name("v.ImportFrom.module") public native @Cast("identifier") PyObject v_ImportFrom_module(); public native _stmt v_ImportFrom_module(PyObject v_ImportFrom_module);
            @Name("v.ImportFrom.names") public native asdl_seq v_ImportFrom_names(); public native _stmt v_ImportFrom_names(asdl_seq v_ImportFrom_names);
            @Name("v.ImportFrom.level") public native int v_ImportFrom_level(); public native _stmt v_ImportFrom_level(int v_ImportFrom_level);
        
            @Name("v.Global.names") public native asdl_seq v_Global_names(); public native _stmt v_Global_names(asdl_seq v_Global_names);
        
            @Name("v.Nonlocal.names") public native asdl_seq v_Nonlocal_names(); public native _stmt v_Nonlocal_names(asdl_seq v_Nonlocal_names);
        
            @Name("v.Expr.value") public native _expr v_Expr_value(); public native _stmt v_Expr_value(_expr v_Expr_value);
    public native int lineno(); public native _stmt lineno(int lineno);
    public native int col_offset(); public native _stmt col_offset(int col_offset);
}

/** enum _expr_kind */
public static final int BoolOp_kind = 1, BinOp_kind = 2, UnaryOp_kind = 3, Lambda_kind = 4,
                  IfExp_kind = 5, Dict_kind = 6, Set_kind = 7, ListComp_kind = 8,
                  SetComp_kind = 9, DictComp_kind = 10, GeneratorExp_kind = 11,
                  Await_kind = 12, Yield_kind = 13, YieldFrom_kind = 14,
                  Compare_kind = 15, Call_kind = 16, Num_kind = 17, Str_kind = 18,
                  FormattedValue_kind = 19, JoinedStr_kind = 20, Bytes_kind = 21,
                  NameConstant_kind = 22, Ellipsis_kind = 23, Constant_kind = 24,
                  Attribute_kind = 25, Subscript_kind = 26, Starred_kind = 27,
                  Name_kind = 28, List_kind = 29, Tuple_kind = 30;
public static class _expr extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _expr() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _expr(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _expr(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _expr position(long position) {
        return (_expr)super.position(position);
    }

    public native @Cast("_expr_kind") int kind(); public native _expr kind(int kind);
            @Name("v.BoolOp.op") public native @Cast("boolop_ty") int v_BoolOp_op(); public native _expr v_BoolOp_op(int v_BoolOp_op);
            @Name("v.BoolOp.values") public native asdl_seq v_BoolOp_values(); public native _expr v_BoolOp_values(asdl_seq v_BoolOp_values);
        
            @Name("v.BinOp.left") public native _expr v_BinOp_left(); public native _expr v_BinOp_left(_expr v_BinOp_left);
            @Name("v.BinOp.op") public native @Cast("operator_ty") int v_BinOp_op(); public native _expr v_BinOp_op(int v_BinOp_op);
            @Name("v.BinOp.right") public native _expr v_BinOp_right(); public native _expr v_BinOp_right(_expr v_BinOp_right);
        
            @Name("v.UnaryOp.op") public native @Cast("unaryop_ty") int v_UnaryOp_op(); public native _expr v_UnaryOp_op(int v_UnaryOp_op);
            @Name("v.UnaryOp.operand") public native _expr v_UnaryOp_operand(); public native _expr v_UnaryOp_operand(_expr v_UnaryOp_operand);
        
            @Name("v.Lambda.args") public native _arguments v_Lambda_args(); public native _expr v_Lambda_args(_arguments v_Lambda_args);
            @Name("v.Lambda.body") public native _expr v_Lambda_body(); public native _expr v_Lambda_body(_expr v_Lambda_body);
        
            @Name("v.IfExp.test") public native _expr v_IfExp_test(); public native _expr v_IfExp_test(_expr v_IfExp_test);
            @Name("v.IfExp.body") public native _expr v_IfExp_body(); public native _expr v_IfExp_body(_expr v_IfExp_body);
            @Name("v.IfExp.orelse") public native _expr v_IfExp_orelse(); public native _expr v_IfExp_orelse(_expr v_IfExp_orelse);
        
            @Name("v.Dict.keys") public native asdl_seq v_Dict_keys(); public native _expr v_Dict_keys(asdl_seq v_Dict_keys);
            @Name("v.Dict.values") public native asdl_seq v_Dict_values(); public native _expr v_Dict_values(asdl_seq v_Dict_values);
        
            @Name("v.Set.elts") public native asdl_seq v_Set_elts(); public native _expr v_Set_elts(asdl_seq v_Set_elts);
        
            @Name("v.ListComp.elt") public native _expr v_ListComp_elt(); public native _expr v_ListComp_elt(_expr v_ListComp_elt);
            @Name("v.ListComp.generators") public native asdl_seq v_ListComp_generators(); public native _expr v_ListComp_generators(asdl_seq v_ListComp_generators);
        
            @Name("v.SetComp.elt") public native _expr v_SetComp_elt(); public native _expr v_SetComp_elt(_expr v_SetComp_elt);
            @Name("v.SetComp.generators") public native asdl_seq v_SetComp_generators(); public native _expr v_SetComp_generators(asdl_seq v_SetComp_generators);
        
            @Name("v.DictComp.key") public native _expr v_DictComp_key(); public native _expr v_DictComp_key(_expr v_DictComp_key);
            @Name("v.DictComp.value") public native _expr v_DictComp_value(); public native _expr v_DictComp_value(_expr v_DictComp_value);
            @Name("v.DictComp.generators") public native asdl_seq v_DictComp_generators(); public native _expr v_DictComp_generators(asdl_seq v_DictComp_generators);
        
            @Name("v.GeneratorExp.elt") public native _expr v_GeneratorExp_elt(); public native _expr v_GeneratorExp_elt(_expr v_GeneratorExp_elt);
            @Name("v.GeneratorExp.generators") public native asdl_seq v_GeneratorExp_generators(); public native _expr v_GeneratorExp_generators(asdl_seq v_GeneratorExp_generators);
        
            @Name("v.Await.value") public native _expr v_Await_value(); public native _expr v_Await_value(_expr v_Await_value);
        
            @Name("v.Yield.value") public native _expr v_Yield_value(); public native _expr v_Yield_value(_expr v_Yield_value);
        
            @Name("v.YieldFrom.value") public native _expr v_YieldFrom_value(); public native _expr v_YieldFrom_value(_expr v_YieldFrom_value);
        
            @Name("v.Compare.left") public native _expr v_Compare_left(); public native _expr v_Compare_left(_expr v_Compare_left);
            @Name("v.Compare.ops") public native asdl_int_seq v_Compare_ops(); public native _expr v_Compare_ops(asdl_int_seq v_Compare_ops);
            @Name("v.Compare.comparators") public native asdl_seq v_Compare_comparators(); public native _expr v_Compare_comparators(asdl_seq v_Compare_comparators);
        
            @Name("v.Call.func") public native _expr v_Call_func(); public native _expr v_Call_func(_expr v_Call_func);
            @Name("v.Call.args") public native asdl_seq v_Call_args(); public native _expr v_Call_args(asdl_seq v_Call_args);
            @Name("v.Call.keywords") public native asdl_seq v_Call_keywords(); public native _expr v_Call_keywords(asdl_seq v_Call_keywords);
        
            @Name("v.Num.n") public native @Cast("object") PyObject v_Num_n(); public native _expr v_Num_n(PyObject v_Num_n);
        
            @Name("v.Str.s") public native @Cast("string") PyObject v_Str_s(); public native _expr v_Str_s(PyObject v_Str_s);
        
            @Name("v.FormattedValue.value") public native _expr v_FormattedValue_value(); public native _expr v_FormattedValue_value(_expr v_FormattedValue_value);
            @Name("v.FormattedValue.conversion") public native int v_FormattedValue_conversion(); public native _expr v_FormattedValue_conversion(int v_FormattedValue_conversion);
            @Name("v.FormattedValue.format_spec") public native _expr v_FormattedValue_format_spec(); public native _expr v_FormattedValue_format_spec(_expr v_FormattedValue_format_spec);
        
            @Name("v.JoinedStr.values") public native asdl_seq v_JoinedStr_values(); public native _expr v_JoinedStr_values(asdl_seq v_JoinedStr_values);
        
            @Name("v.Bytes.s") public native @Cast("bytes") PyObject v_Bytes_s(); public native _expr v_Bytes_s(PyObject v_Bytes_s);
        
            @Name("v.NameConstant.value") public native @Cast("singleton") PyObject v_NameConstant_value(); public native _expr v_NameConstant_value(PyObject v_NameConstant_value);
        
            @Name("v.Constant.value") public native @Cast("constant") PyObject v_Constant_value(); public native _expr v_Constant_value(PyObject v_Constant_value);
        
            @Name("v.Attribute.value") public native _expr v_Attribute_value(); public native _expr v_Attribute_value(_expr v_Attribute_value);
            @Name("v.Attribute.attr") public native @Cast("identifier") PyObject v_Attribute_attr(); public native _expr v_Attribute_attr(PyObject v_Attribute_attr);
            @Name("v.Attribute.ctx") public native @Cast("expr_context_ty") int v_Attribute_ctx(); public native _expr v_Attribute_ctx(int v_Attribute_ctx);
        
            @Name("v.Subscript.value") public native _expr v_Subscript_value(); public native _expr v_Subscript_value(_expr v_Subscript_value);
            @Name("v.Subscript.slice") public native _slice v_Subscript_slice(); public native _expr v_Subscript_slice(_slice v_Subscript_slice);
            @Name("v.Subscript.ctx") public native @Cast("expr_context_ty") int v_Subscript_ctx(); public native _expr v_Subscript_ctx(int v_Subscript_ctx);
        
            @Name("v.Starred.value") public native _expr v_Starred_value(); public native _expr v_Starred_value(_expr v_Starred_value);
            @Name("v.Starred.ctx") public native @Cast("expr_context_ty") int v_Starred_ctx(); public native _expr v_Starred_ctx(int v_Starred_ctx);
        
            @Name("v.Name.id") public native @Cast("identifier") PyObject v_Name_id(); public native _expr v_Name_id(PyObject v_Name_id);
            @Name("v.Name.ctx") public native @Cast("expr_context_ty") int v_Name_ctx(); public native _expr v_Name_ctx(int v_Name_ctx);
        
            @Name("v.List.elts") public native asdl_seq v_List_elts(); public native _expr v_List_elts(asdl_seq v_List_elts);
            @Name("v.List.ctx") public native @Cast("expr_context_ty") int v_List_ctx(); public native _expr v_List_ctx(int v_List_ctx);
        
            @Name("v.Tuple.elts") public native asdl_seq v_Tuple_elts(); public native _expr v_Tuple_elts(asdl_seq v_Tuple_elts);
            @Name("v.Tuple.ctx") public native @Cast("expr_context_ty") int v_Tuple_ctx(); public native _expr v_Tuple_ctx(int v_Tuple_ctx);
    public native int lineno(); public native _expr lineno(int lineno);
    public native int col_offset(); public native _expr col_offset(int col_offset);
}

/** enum _slice_kind */
public static final int Slice_kind = 1, ExtSlice_kind = 2, Index_kind = 3;
public static class _slice extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _slice() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _slice(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _slice(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _slice position(long position) {
        return (_slice)super.position(position);
    }

    public native @Cast("_slice_kind") int kind(); public native _slice kind(int kind);
            @Name("v.Slice.lower") public native _expr v_Slice_lower(); public native _slice v_Slice_lower(_expr v_Slice_lower);
            @Name("v.Slice.upper") public native _expr v_Slice_upper(); public native _slice v_Slice_upper(_expr v_Slice_upper);
            @Name("v.Slice.step") public native _expr v_Slice_step(); public native _slice v_Slice_step(_expr v_Slice_step);
        
            @Name("v.ExtSlice.dims") public native asdl_seq v_ExtSlice_dims(); public native _slice v_ExtSlice_dims(asdl_seq v_ExtSlice_dims);
        
            @Name("v.Index.value") public native _expr v_Index_value(); public native _slice v_Index_value(_expr v_Index_value);
}

public static class _comprehension extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _comprehension() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _comprehension(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _comprehension(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _comprehension position(long position) {
        return (_comprehension)super.position(position);
    }

    public native _expr target(); public native _comprehension target(_expr target);
    public native _expr iter(); public native _comprehension iter(_expr iter);
    public native asdl_seq ifs(); public native _comprehension ifs(asdl_seq ifs);
    public native int is_async(); public native _comprehension is_async(int is_async);
}

/** enum _excepthandler_kind */
public static final int ExceptHandler_kind = 1;
public static class _excepthandler extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _excepthandler() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _excepthandler(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _excepthandler(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _excepthandler position(long position) {
        return (_excepthandler)super.position(position);
    }

    public native @Cast("_excepthandler_kind") int kind(); public native _excepthandler kind(int kind);
            @Name("v.ExceptHandler.type") public native _expr v_ExceptHandler_type(); public native _excepthandler v_ExceptHandler_type(_expr v_ExceptHandler_type);
            @Name("v.ExceptHandler.name") public native @Cast("identifier") PyObject v_ExceptHandler_name(); public native _excepthandler v_ExceptHandler_name(PyObject v_ExceptHandler_name);
            @Name("v.ExceptHandler.body") public native asdl_seq v_ExceptHandler_body(); public native _excepthandler v_ExceptHandler_body(asdl_seq v_ExceptHandler_body);
    public native int lineno(); public native _excepthandler lineno(int lineno);
    public native int col_offset(); public native _excepthandler col_offset(int col_offset);
}

public static class _arguments extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _arguments() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _arguments(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _arguments(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _arguments position(long position) {
        return (_arguments)super.position(position);
    }

    public native asdl_seq args(); public native _arguments args(asdl_seq args);
    public native _arg vararg(); public native _arguments vararg(_arg vararg);
    public native asdl_seq kwonlyargs(); public native _arguments kwonlyargs(asdl_seq kwonlyargs);
    public native asdl_seq kw_defaults(); public native _arguments kw_defaults(asdl_seq kw_defaults);
    public native _arg kwarg(); public native _arguments kwarg(_arg kwarg);
    public native asdl_seq defaults(); public native _arguments defaults(asdl_seq defaults);
}

public static class _arg extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _arg() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _arg(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _arg(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _arg position(long position) {
        return (_arg)super.position(position);
    }

    public native @Cast("identifier") PyObject arg(); public native _arg arg(PyObject arg);
    public native _expr annotation(); public native _arg annotation(_expr annotation);
    public native int lineno(); public native _arg lineno(int lineno);
    public native int col_offset(); public native _arg col_offset(int col_offset);
}

public static class _keyword extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _keyword() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _keyword(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _keyword(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _keyword position(long position) {
        return (_keyword)super.position(position);
    }

    public native @Cast("identifier") PyObject arg(); public native _keyword arg(PyObject arg);
    public native _expr value(); public native _keyword value(_expr value);
}

public static class _alias extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _alias() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _alias(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _alias(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _alias position(long position) {
        return (_alias)super.position(position);
    }

    public native @Cast("identifier") PyObject name(); public native _alias name(PyObject name);
    public native @Cast("identifier") PyObject asname(); public native _alias asname(PyObject asname);
}

public static class _withitem extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public _withitem() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public _withitem(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _withitem(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public _withitem position(long position) {
        return (_withitem)super.position(position);
    }

    public native _expr context_expr(); public native _withitem context_expr(_expr context_expr);
    public native _expr optional_vars(); public native _withitem optional_vars(_expr optional_vars);
}




// Parsed from node.h


/* Parse tree node interface */

// #ifndef Py_NODE_H
// #define Py_NODE_H
// #ifdef __cplusplus
// #endif

public static class node extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public node() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public node(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public node(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public node position(long position) {
        return (node)super.position(position);
    }

    public native short n_type(); public native node n_type(short n_type);
    public native @Cast("char*") BytePointer n_str(); public native node n_str(BytePointer n_str);
    public native int n_lineno(); public native node n_lineno(int n_lineno);
    public native int n_col_offset(); public native node n_col_offset(int n_col_offset);
    public native int n_nchildren(); public native node n_nchildren(int n_nchildren);
    public native @Cast("_node*") node n_child(); public native node n_child(node n_child);
}

@NoException public static native node PyNode_New(int type);
@NoException public static native int PyNode_AddChild(node n, int type,
                                      @Cast("char*") BytePointer str, int lineno, int col_offset);
@NoException public static native int PyNode_AddChild(node n, int type,
                                      @Cast("char*") ByteBuffer str, int lineno, int col_offset);
@NoException public static native int PyNode_AddChild(node n, int type,
                                      @Cast("char*") byte[] str, int lineno, int col_offset);
@NoException public static native void PyNode_Free(node n);
// #ifndef Py_LIMITED_API
@NoException public static native @Cast("Py_ssize_t") long _PyNode_SizeOf(node n);
// #endif

/* Node access functions */
// #define NCH(n)		((n)->n_nchildren)

// #define CHILD(n, i)	(&(n)->n_child[i])
// #define RCHILD(n, i)	(CHILD(n, NCH(n) + i))
// #define TYPE(n)		((n)->n_type)
// #define STR(n)		((n)->n_str)
// #define LINENO(n)       ((n)->n_lineno)

/* Assert that the type of a node is what we expect */
// #define REQ(n, type) assert(TYPE(n) == (type))

@NoException public static native void PyNode_ListTree(node arg0);

// #ifdef __cplusplus
// #endif
// #endif /* !Py_NODE_H */


// Parsed from code.h

/* Definitions for bytecode */

// #ifndef Py_LIMITED_API
// #ifndef Py_CODE_H
// #define Py_CODE_H
// #ifdef __cplusplus
// #endif

// #ifdef WORDS_BIGENDIAN
// #  define _Py_OPCODE(word) ((word) >> 8)
// #  define _Py_OPARG(word) ((word) & 255)
// #else
// #  define _Py_OPCODE(word) ((word) & 255)
// #  define _Py_OPARG(word) ((word) >> 8)
// #endif

/* Bytecode object */
public static class PyCodeObject extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyCodeObject() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyCodeObject(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyCodeObject(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyCodeObject position(long position) {
        return (PyCodeObject)super.position(position);
    }

    public native @ByRef PyObject ob_base(); public native PyCodeObject ob_base(PyObject ob_base);
    public native int co_argcount(); public native PyCodeObject co_argcount(int co_argcount);		/* #arguments, except *args */
    public native int co_kwonlyargcount(); public native PyCodeObject co_kwonlyargcount(int co_kwonlyargcount);	/* #keyword only arguments */
    public native int co_nlocals(); public native PyCodeObject co_nlocals(int co_nlocals);		/* #local variables */
    public native int co_stacksize(); public native PyCodeObject co_stacksize(int co_stacksize);		/* #entries needed for evaluation stack */
    public native int co_flags(); public native PyCodeObject co_flags(int co_flags);		/* CO_..., see below */
    public native int co_firstlineno(); public native PyCodeObject co_firstlineno(int co_firstlineno);   /* first source line number */
    public native PyObject co_code(); public native PyCodeObject co_code(PyObject co_code);		/* instruction opcodes */
    public native PyObject co_consts(); public native PyCodeObject co_consts(PyObject co_consts);	/* list (constants used) */
    public native PyObject co_names(); public native PyCodeObject co_names(PyObject co_names);		/* list of strings (names used) */
    public native PyObject co_varnames(); public native PyCodeObject co_varnames(PyObject co_varnames);	/* tuple of strings (local variable names) */
    public native PyObject co_freevars(); public native PyCodeObject co_freevars(PyObject co_freevars);	/* tuple of strings (free variable names) */
    public native PyObject co_cellvars(); public native PyCodeObject co_cellvars(PyObject co_cellvars);      /* tuple of strings (cell variable names) */
    /* The rest aren't used in either hash or comparisons, except for co_name,
       used in both. This is done to preserve the name and line number
       for tracebacks and debuggers; otherwise, constant de-duplication
       would collapse identical functions/lambdas defined on different lines.
    */
    public native @Cast("unsigned char*") BytePointer co_cell2arg(); public native PyCodeObject co_cell2arg(BytePointer co_cell2arg); /* Maps cell vars which are arguments. */
    public native PyObject co_filename(); public native PyCodeObject co_filename(PyObject co_filename);	/* unicode (where it was loaded from) */
    public native PyObject co_name(); public native PyCodeObject co_name(PyObject co_name);		/* unicode (name, for reference) */
    public native PyObject co_lnotab(); public native PyCodeObject co_lnotab(PyObject co_lnotab);	/* string (encoding addr<->lineno mapping) See
				   Objects/lnotab_notes.txt for details. */
    public native Pointer co_zombieframe(); public native PyCodeObject co_zombieframe(Pointer co_zombieframe);     /* for optimization only (see frameobject.c) */
    public native PyObject co_weakreflist(); public native PyCodeObject co_weakreflist(PyObject co_weakreflist);   /* to support weakrefs to code objects */
    /* Scratch space for extra data relating to the code object.
       Type is a void* to keep the format private in codeobject.c to force
       people to go through the proper APIs. */
    public native Pointer co_extra(); public native PyCodeObject co_extra(Pointer co_extra);
}

/* Masks for co_flags above */
public static final int CO_OPTIMIZED =	0x0001;
public static final int CO_NEWLOCALS =	0x0002;
public static final int CO_VARARGS =	0x0004;
public static final int CO_VARKEYWORDS =	0x0008;
public static final int CO_NESTED =       0x0010;
public static final int CO_GENERATOR =    0x0020;
/* The CO_NOFREE flag is set if there are no free or cell variables.
   This information is redundant, but it allows a single flag test
   to determine whether there is any extra work to be done when the
   call frame it setup.
*/
public static final int CO_NOFREE =       0x0040;

/* The CO_COROUTINE flag is set for coroutine functions (defined with
   ``async def`` keywords) */
public static final int CO_COROUTINE =            0x0080;
public static final int CO_ITERABLE_COROUTINE =   0x0100;
public static final int CO_ASYNC_GENERATOR =      0x0200;

/* These are no longer used. */
// #if 0
// #endif
public static final int CO_FUTURE_DIVISION =    	0x2000;
public static final int CO_FUTURE_ABSOLUTE_IMPORT = 0x4000; /* do absolute imports by default */
public static final int CO_FUTURE_WITH_STATEMENT =  0x8000;
public static final int CO_FUTURE_PRINT_FUNCTION =  0x10000;
public static final int CO_FUTURE_UNICODE_LITERALS = 0x20000;

public static final int CO_FUTURE_BARRY_AS_BDFL =  0x40000;
public static final int CO_FUTURE_GENERATOR_STOP =  0x80000;

/* This value is found in the co_cell2arg array when the associated cell
   variable does not correspond to an argument. The maximum number of
   arguments is 255 (indexed up to 254), so 255 work as a special flag.*/
public static final int CO_CELL_NOT_AN_ARG = 255;

/* This should be defined if a future statement modifies the syntax.
   For example, when a keyword is added.
*/
// #define PY_PARSER_REQUIRES_FUTURE_KEYWORD

public static final int CO_MAXBLOCKS = 20; /* Max static block nesting within a function */

public static native @ByRef PyTypeObject PyCode_Type(); public static native void PyCode_Type(PyTypeObject PyCode_Type);

// #define PyCode_Check(op) (Py_TYPE(op) == &PyCode_Type)
// #define PyCode_GetNumFree(op) (PyTuple_GET_SIZE((op)->co_freevars))

/* Public interface */
@NoException public static native PyCodeObject PyCode_New(
	int arg0, int arg1, int arg2, int arg3, int arg4, PyObject arg5, PyObject arg6,
	PyObject arg7, PyObject arg8, PyObject arg9, PyObject arg10,
	PyObject arg11, PyObject arg12, int arg13, PyObject arg14);
        /* same as struct above */

/* Creates a new empty code object with the specified source location. */
@NoException public static native PyCodeObject PyCode_NewEmpty(@Cast("const char*") BytePointer filename, @Cast("const char*") BytePointer funcname, int firstlineno);
@NoException public static native PyCodeObject PyCode_NewEmpty(String filename, String funcname, int firstlineno);

/* Return the line number associated with the specified bytecode index
   in this code object.  If you just need the line number of a frame,
   use PyFrame_GetLineNumber() instead. */
@NoException public static native int PyCode_Addr2Line(PyCodeObject arg0, int arg1);

/* for internal use only */
public static class PyAddrPair extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyAddrPair() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyAddrPair(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyAddrPair(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyAddrPair position(long position) {
        return (PyAddrPair)super.position(position);
    }

        public native int ap_lower(); public native PyAddrPair ap_lower(int ap_lower);
        public native int ap_upper(); public native PyAddrPair ap_upper(int ap_upper);
}

// #ifndef Py_LIMITED_API
/* Update *bounds to describe the first and one-past-the-last instructions in the
   same line as lasti.  Return the number of that line.
*/
@NoException public static native int _PyCode_CheckLineNumber(PyCodeObject co,
                                        int lasti, PyAddrPair bounds);

/* Create a comparable key used to compare constants taking in account the
 * object type. It is used to make sure types are not coerced (e.g., float and
 * complex) _and_ to distinguish 0.0 from -0.0 e.g. on IEEE platforms
 *
 * Return (type(obj), obj, ...): a tuple with variable size (at least 2 items)
 * depending on the type and the value. The type is the first item to not
 * compare bytes and str which can raise a BytesWarning exception. */
@NoException public static native PyObject _PyCode_ConstantKey(PyObject obj);
// #endif

@NoException public static native PyObject PyCode_Optimize(PyObject code, PyObject consts,
                                      PyObject names, PyObject lnotab);


// #ifndef Py_LIMITED_API
@NoException public static native int _PyCode_GetExtra(PyObject code, @Cast("Py_ssize_t") long index,
                                 @Cast("void**") PointerPointer extra);
@NoException public static native int _PyCode_GetExtra(PyObject code, @Cast("Py_ssize_t") long index,
                                 @Cast("void**") @ByPtrPtr Pointer extra);
@NoException public static native int _PyCode_SetExtra(PyObject code, @Cast("Py_ssize_t") long index,
                                 Pointer extra);
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_CODE_H */
// #endif /* Py_LIMITED_API */


// Parsed from compile.h

// #ifndef Py_COMPILE_H
// #define Py_COMPILE_H

// #ifndef Py_LIMITED_API
// #include "code.h"

// #ifdef __cplusplus
// #endif

/* Public interface */ /* Declare the existence of this type */
@NoException public static native PyCodeObject PyNode_Compile(@Cast("_node*") node arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native PyCodeObject PyNode_Compile(@Cast("_node*") node arg0, String arg1);

/* Future feature support */

public static class PyFutureFeatures extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyFutureFeatures() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyFutureFeatures(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyFutureFeatures(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyFutureFeatures position(long position) {
        return (PyFutureFeatures)super.position(position);
    }

    public native int ff_features(); public native PyFutureFeatures ff_features(int ff_features);      /* flags set by future statements */
    public native int ff_lineno(); public native PyFutureFeatures ff_lineno(int ff_lineno);        /* line number of last future statement */
}

public static final String FUTURE_NESTED_SCOPES = "nested_scopes";
public static final String FUTURE_GENERATORS = "generators";
public static final String FUTURE_DIVISION = "division";
public static final String FUTURE_ABSOLUTE_IMPORT = "absolute_import";
public static final String FUTURE_WITH_STATEMENT = "with_statement";
public static final String FUTURE_PRINT_FUNCTION = "print_function";
public static final String FUTURE_UNICODE_LITERALS = "unicode_literals";
public static final String FUTURE_BARRY_AS_BDFL = "barry_as_FLUFL";
public static final String FUTURE_GENERATOR_STOP = "generator_stop"; /* Declare the existence of this type */
// #define PyAST_Compile(mod, s, f, ar) PyAST_CompileEx(mod, s, f, -1, ar)
@NoException public static native PyCodeObject PyAST_CompileEx(
    _mod mod,
    @Cast("const char*") BytePointer filename,
    PyCompilerFlags flags,
    int optimize,
    PyArena arena);
@NoException public static native PyCodeObject PyAST_CompileEx(
    _mod mod,
    String filename,
    PyCompilerFlags flags,
    int optimize,
    PyArena arena);
@NoException public static native PyCodeObject PyAST_CompileObject(
    _mod mod,
    PyObject filename,
    PyCompilerFlags flags,
    int optimize,
    PyArena arena);
@NoException public static native PyFutureFeatures PyFuture_FromAST(
    _mod mod,
    @Cast("const char*") BytePointer filename
    );
@NoException public static native PyFutureFeatures PyFuture_FromAST(
    _mod mod,
    String filename
    );
@NoException public static native PyFutureFeatures PyFuture_FromASTObject(
    _mod mod,
    PyObject filename
    );

/* _Py_Mangle is defined in compile.c */
@NoException public static native PyObject _Py_Mangle(PyObject p, PyObject name);

public static final int PY_INVALID_STACK_EFFECT = INT_MAX;
@NoException public static native int PyCompile_OpcodeStackEffect(int opcode, int oparg);

// #ifdef __cplusplus
// #endif

// #endif /* !Py_LIMITED_API */

/* These definitions must match corresponding definitions in graminit.h.
   There's code in compile.c that checks that they are the same. */
public static final int Py_single_input = 256;
public static final int Py_file_input = 257;
public static final int Py_eval_input = 258;

// #endif /* !Py_COMPILE_H */


// Parsed from symtable.h

// #ifndef Py_LIMITED_API
// #ifndef Py_SYMTABLE_H
// #define Py_SYMTABLE_H

// #ifdef __cplusplus
// #endif

/* XXX(ncoghlan): This is a weird mix of public names and interpreter internal
 *                names.
 */

/** enum _block_type */
public static final int FunctionBlock = 0, ClassBlock = 1, ModuleBlock = 2;

@Opaque public static class _symtable_entry extends Pointer {
    /** Empty constructor. Calls {@code super((Pointer)null)}. */
    public _symtable_entry() { super((Pointer)null); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public _symtable_entry(Pointer p) { super(p); }
}

public static class symtable extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public symtable() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public symtable(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public symtable(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public symtable position(long position) {
        return (symtable)super.position(position);
    }

    public native PyObject st_filename(); public native symtable st_filename(PyObject st_filename);          /* name of file being compiled,
                                       decoded from the filesystem encoding */
    public native _symtable_entry st_cur(); public native symtable st_cur(_symtable_entry st_cur); /* current symbol table entry */
    public native _symtable_entry st_top(); public native symtable st_top(_symtable_entry st_top); /* symbol table entry for module */
    public native PyObject st_blocks(); public native symtable st_blocks(PyObject st_blocks);            /* dict: map AST node addresses
                                     *       to symbol table entries */
    public native PyObject st_stack(); public native symtable st_stack(PyObject st_stack);             /* list: stack of namespace info */
    public native PyObject st_global(); public native symtable st_global(PyObject st_global);            /* borrowed ref to st_top->ste_symbols */
    public native int st_nblocks(); public native symtable st_nblocks(int st_nblocks);                 /* number of blocks used. kept for
                                       consistency with the corresponding
                                       compiler structure */
    public native PyObject st_private(); public native symtable st_private(PyObject st_private);           /* name of current class or NULL */
    public native PyFutureFeatures st_future(); public native symtable st_future(PyFutureFeatures st_future);    /* module's future features that affect
                                       the symbol table */
    public native int recursion_depth(); public native symtable recursion_depth(int recursion_depth);            /* current recursion depth */
    public native int recursion_limit(); public native symtable recursion_limit(int recursion_limit);            /* recursion limit */
}

public static class PySTEntryObject extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PySTEntryObject() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PySTEntryObject(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PySTEntryObject(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PySTEntryObject position(long position) {
        return (PySTEntryObject)super.position(position);
    }

    public native @ByRef PyObject ob_base(); public native PySTEntryObject ob_base(PyObject ob_base);
    public native PyObject ste_id(); public native PySTEntryObject ste_id(PyObject ste_id);        /* int: key in ste_table->st_blocks */
    public native PyObject ste_symbols(); public native PySTEntryObject ste_symbols(PyObject ste_symbols);   /* dict: variable names to flags */
    public native PyObject ste_name(); public native PySTEntryObject ste_name(PyObject ste_name);      /* string: name of current block */
    public native PyObject ste_varnames(); public native PySTEntryObject ste_varnames(PyObject ste_varnames);  /* list of function parameters */
    public native PyObject ste_children(); public native PySTEntryObject ste_children(PyObject ste_children);  /* list of child blocks */
    public native PyObject ste_directives(); public native PySTEntryObject ste_directives(PyObject ste_directives);/* locations of global and nonlocal statements */
    public native @Cast("_Py_block_ty") int ste_type(); public native PySTEntryObject ste_type(int ste_type);   /* module, class, or function */
    public native int ste_nested(); public native PySTEntryObject ste_nested(int ste_nested);      /* true if block is nested */
    public native @Cast("unsigned") @NoOffset int ste_free(); public native PySTEntryObject ste_free(int ste_free);        /* true if block has free variables */
    public native @Cast("unsigned") @NoOffset int ste_child_free(); public native PySTEntryObject ste_child_free(int ste_child_free);  /* true if a child block has free vars,
                                     including free refs to globals */
    public native @Cast("unsigned") @NoOffset int ste_generator(); public native PySTEntryObject ste_generator(int ste_generator);   /* true if namespace is a generator */
    public native @Cast("unsigned") @NoOffset int ste_coroutine(); public native PySTEntryObject ste_coroutine(int ste_coroutine);   /* true if namespace is a coroutine */
    public native @Cast("unsigned") @NoOffset int ste_varargs(); public native PySTEntryObject ste_varargs(int ste_varargs);     /* true if block has varargs */
    public native @Cast("unsigned") @NoOffset int ste_varkeywords(); public native PySTEntryObject ste_varkeywords(int ste_varkeywords); /* true if block has varkeywords */
    public native @Cast("unsigned") @NoOffset int ste_returns_value(); public native PySTEntryObject ste_returns_value(int ste_returns_value);  /* true if namespace uses return with
                                        an argument */
    public native @Cast("unsigned") @NoOffset int ste_needs_class_closure(); public native PySTEntryObject ste_needs_class_closure(int ste_needs_class_closure); /* for class scopes, true if a
                                             closure over __class__
                                             should be created */
    public native int ste_lineno(); public native PySTEntryObject ste_lineno(int ste_lineno);          /* first line of block */
    public native int ste_col_offset(); public native PySTEntryObject ste_col_offset(int ste_col_offset);      /* offset of first line of block */
    public native int ste_opt_lineno(); public native PySTEntryObject ste_opt_lineno(int ste_opt_lineno);      /* lineno of last exec or import * */
    public native int ste_opt_col_offset(); public native PySTEntryObject ste_opt_col_offset(int ste_opt_col_offset);  /* offset of last exec or import * */
    public native int ste_tmpname(); public native PySTEntryObject ste_tmpname(int ste_tmpname);         /* counter for listcomp temp vars */
    public native symtable ste_table(); public native PySTEntryObject ste_table(symtable ste_table);
}

public static native @ByRef PyTypeObject PySTEntry_Type(); public static native void PySTEntry_Type(PyTypeObject PySTEntry_Type);

// #define PySTEntry_Check(op) (Py_TYPE(op) == &PySTEntry_Type)

@NoException public static native int PyST_GetScope(PySTEntryObject arg0, PyObject arg1);

@NoException public static native symtable PySymtable_Build(
    _mod mod,
    @Cast("const char*") BytePointer filename,
    PyFutureFeatures future);
@NoException public static native symtable PySymtable_Build(
    _mod mod,
    String filename,
    PyFutureFeatures future);
@NoException public static native symtable PySymtable_BuildObject(
    _mod mod,
    PyObject filename,
    PyFutureFeatures future);
@NoException public static native PySTEntryObject PySymtable_Lookup(symtable arg0, Pointer arg1);

@NoException public static native void PySymtable_Free(symtable arg0);

/* Flags for def-use information */

public static final int DEF_GLOBAL = 1;           /* global stmt */
public static final int DEF_LOCAL = 2;            /* assignment in code block */
public static final int DEF_PARAM = 2<<1;         /* formal parameter */
public static final int DEF_NONLOCAL = 2<<2;      /* nonlocal stmt */
public static final int USE = 2<<3;               /* name is used */
public static final int DEF_FREE = 2<<4;          /* name used but not defined in nested block */
public static final int DEF_FREE_CLASS = 2<<5;    /* free variable from class's method */
public static final int DEF_IMPORT = 2<<6;        /* assignment occurred via import */
public static final int DEF_ANNOT = 2<<7;         /* this name is annotated */

public static final int DEF_BOUND = (DEF_LOCAL | DEF_PARAM | DEF_IMPORT);

/* GLOBAL_EXPLICIT and GLOBAL_IMPLICIT are used internally by the symbol
   table.  GLOBAL is returned from PyST_GetScope() for either of them.
   It is stored in ste_symbols at bits 12-15.
*/
public static final int SCOPE_OFFSET = 11;
public static final int SCOPE_MASK = (DEF_GLOBAL | DEF_LOCAL | DEF_PARAM | DEF_NONLOCAL);

public static final int LOCAL = 1;
public static final int GLOBAL_EXPLICIT = 2;
public static final int GLOBAL_IMPLICIT = 3;
public static final int FREE = 4;
public static final int CELL = 5;

public static final int GENERATOR = 1;
public static final int GENERATOR_EXPRESSION = 2;

// #ifdef __cplusplus
// #endif
// #endif /* !Py_SYMTABLE_H */
// #endif /* Py_LIMITED_API */


// Parsed from pythonrun.h


/* Interfaces to parse and execute pieces of python code */

// #ifndef Py_PYTHONRUN_H
// #define Py_PYTHONRUN_H
// #ifdef __cplusplus
// #endif

public static final int PyCF_MASK = (CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | 
                   CO_FUTURE_WITH_STATEMENT | CO_FUTURE_PRINT_FUNCTION | 
                   CO_FUTURE_UNICODE_LITERALS | CO_FUTURE_BARRY_AS_BDFL | 
                   CO_FUTURE_GENERATOR_STOP);
public static final int PyCF_MASK_OBSOLETE = (CO_NESTED);
public static final int PyCF_SOURCE_IS_UTF8 =  0x0100;
public static final int PyCF_DONT_IMPLY_DEDENT = 0x0200;
public static final int PyCF_ONLY_AST = 0x0400;
public static final int PyCF_IGNORE_COOKIE = 0x0800;

// #ifndef Py_LIMITED_API
public static class PyCompilerFlags extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public PyCompilerFlags() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public PyCompilerFlags(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public PyCompilerFlags(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public PyCompilerFlags position(long position) {
        return (PyCompilerFlags)super.position(position);
    }

    public native int cf_flags(); public native PyCompilerFlags cf_flags(int cf_flags);  /* bitmask of CO_xxx flags relevant to future */
}
// #endif

// #ifndef Py_LIMITED_API
@NoException public static native int PyRun_SimpleStringFlags(@Cast("const char*") BytePointer arg0, PyCompilerFlags arg1);
@NoException public static native int PyRun_SimpleStringFlags(String arg0, PyCompilerFlags arg1);
@NoException public static native int PyRun_AnyFileFlags(@Cast("FILE*") Pointer arg0, @Cast("const char*") BytePointer arg1, PyCompilerFlags arg2);
@NoException public static native int PyRun_AnyFileFlags(@Cast("FILE*") Pointer arg0, String arg1, PyCompilerFlags arg2);
@NoException public static native int PyRun_AnyFileExFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int PyRun_AnyFileExFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int PyRun_SimpleFileExFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int PyRun_SimpleFileExFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveOneFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveOneFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveOneObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveLoopFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    PyCompilerFlags flags);
@NoException public static native int PyRun_InteractiveLoopFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    PyCompilerFlags flags);

@NoException public static native _mod PyParser_ASTFromString(
    @Cast("const char*") BytePointer s,
    @Cast("const char*") BytePointer filename,
    int start,
    PyCompilerFlags flags,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromString(
    String s,
    String filename,
    int start,
    PyCompilerFlags flags,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromStringObject(
    @Cast("const char*") BytePointer s,
    PyObject filename,
    int start,
    PyCompilerFlags flags,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromStringObject(
    String s,
    PyObject filename,
    int start,
    PyCompilerFlags flags,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFile(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    @Cast("const char*") BytePointer enc,
    int start,
    @Cast("const char*") BytePointer ps1,
    @Cast("const char*") BytePointer ps2,
    PyCompilerFlags flags,
    IntPointer errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFile(
    @Cast("FILE*") Pointer fp,
    String filename,
    String enc,
    int start,
    String ps1,
    String ps2,
    PyCompilerFlags flags,
    IntBuffer errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFile(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    @Cast("const char*") BytePointer enc,
    int start,
    @Cast("const char*") BytePointer ps1,
    @Cast("const char*") BytePointer ps2,
    PyCompilerFlags flags,
    int[] errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFile(
    @Cast("FILE*") Pointer fp,
    String filename,
    String enc,
    int start,
    String ps1,
    String ps2,
    PyCompilerFlags flags,
    IntPointer errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFile(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    @Cast("const char*") BytePointer enc,
    int start,
    @Cast("const char*") BytePointer ps1,
    @Cast("const char*") BytePointer ps2,
    PyCompilerFlags flags,
    IntBuffer errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFile(
    @Cast("FILE*") Pointer fp,
    String filename,
    String enc,
    int start,
    String ps1,
    String ps2,
    PyCompilerFlags flags,
    int[] errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFileObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    @Cast("const char*") BytePointer enc,
    int start,
    @Cast("const char*") BytePointer ps1,
    @Cast("const char*") BytePointer ps2,
    PyCompilerFlags flags,
    IntPointer errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFileObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    String enc,
    int start,
    String ps1,
    String ps2,
    PyCompilerFlags flags,
    IntBuffer errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFileObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    @Cast("const char*") BytePointer enc,
    int start,
    @Cast("const char*") BytePointer ps1,
    @Cast("const char*") BytePointer ps2,
    PyCompilerFlags flags,
    int[] errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFileObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    String enc,
    int start,
    String ps1,
    String ps2,
    PyCompilerFlags flags,
    IntPointer errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFileObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    @Cast("const char*") BytePointer enc,
    int start,
    @Cast("const char*") BytePointer ps1,
    @Cast("const char*") BytePointer ps2,
    PyCompilerFlags flags,
    IntBuffer errcode,
    PyArena arena);
@NoException public static native _mod PyParser_ASTFromFileObject(
    @Cast("FILE*") Pointer fp,
    PyObject filename,
    String enc,
    int start,
    String ps1,
    String ps2,
    PyCompilerFlags flags,
    int[] errcode,
    PyArena arena);
// #endif

// #ifndef PyParser_SimpleParseString
// #define PyParser_SimpleParseString(S, B)
//     PyParser_SimpleParseStringFlags(S, B, 0)
// #define PyParser_SimpleParseFile(FP, S, B)
//     PyParser_SimpleParseFileFlags(FP, S, B, 0)
// #endif
@NoException public static native @Cast("_node*") node PyParser_SimpleParseStringFlags(@Cast("const char*") BytePointer arg0, int arg1,
                                                           int arg2);
@NoException public static native @Cast("_node*") node PyParser_SimpleParseStringFlags(String arg0, int arg1,
                                                           int arg2);
// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03030000
@NoException public static native @Cast("_node*") node PyParser_SimpleParseStringFlagsFilename(@Cast("const char*") BytePointer arg0,
                                                                   @Cast("const char*") BytePointer arg1,
                                                                   int arg2, int arg3);
@NoException public static native @Cast("_node*") node PyParser_SimpleParseStringFlagsFilename(String arg0,
                                                                   String arg1,
                                                                   int arg2, int arg3);
// #endif
@NoException public static native @Cast("_node*") node PyParser_SimpleParseFileFlags(@Cast("FILE*") Pointer arg0, @Cast("const char*") BytePointer arg1,
                                                         int arg2, int arg3);
@NoException public static native @Cast("_node*") node PyParser_SimpleParseFileFlags(@Cast("FILE*") Pointer arg0, String arg1,
                                                         int arg2, int arg3);

// #ifndef Py_LIMITED_API
@NoException public static native PyObject PyRun_StringFlags(@Cast("const char*") BytePointer arg0, int arg1, PyObject arg2,
                                         PyObject arg3, PyCompilerFlags arg4);
@NoException public static native PyObject PyRun_StringFlags(String arg0, int arg1, PyObject arg2,
                                         PyObject arg3, PyCompilerFlags arg4);

@NoException public static native PyObject PyRun_FileExFlags(
    @Cast("FILE*") Pointer fp,
    @Cast("const char*") BytePointer filename,
    int start,
    PyObject globals,
    PyObject locals,
    int closeit,
    PyCompilerFlags flags);
@NoException public static native PyObject PyRun_FileExFlags(
    @Cast("FILE*") Pointer fp,
    String filename,
    int start,
    PyObject globals,
    PyObject locals,
    int closeit,
    PyCompilerFlags flags);
// #endif

// #ifdef Py_LIMITED_API
@NoException public static native PyObject Py_CompileString(@Cast("const char*") BytePointer arg0, @Cast("const char*") BytePointer arg1, int arg2);
@NoException public static native PyObject Py_CompileString(String arg0, String arg1, int arg2);
// #else
// #define Py_CompileString(str, p, s) Py_CompileStringExFlags(str, p, s, NULL, -1)
// #define Py_CompileStringFlags(str, p, s, f) Py_CompileStringExFlags(str, p, s, f, -1)
@NoException public static native PyObject Py_CompileStringExFlags(
    @Cast("const char*") BytePointer str,
    @Cast("const char*") BytePointer filename,
    int start,
    PyCompilerFlags flags,
    int optimize);
@NoException public static native PyObject Py_CompileStringExFlags(
    String str,
    String filename,
    int start,
    PyCompilerFlags flags,
    int optimize);
@NoException public static native PyObject Py_CompileStringObject(
    @Cast("const char*") BytePointer str,
    PyObject filename, int start,
    PyCompilerFlags flags,
    int optimize);
@NoException public static native PyObject Py_CompileStringObject(
    String str,
    PyObject filename, int start,
    PyCompilerFlags flags,
    int optimize);
// #endif
@NoException public static native symtable Py_SymtableString(
    @Cast("const char*") BytePointer str,
    @Cast("const char*") BytePointer filename,
    int start);
@NoException public static native symtable Py_SymtableString(
    String str,
    String filename,
    int start);
// #ifndef Py_LIMITED_API
@NoException public static native symtable Py_SymtableStringObject(
    @Cast("const char*") BytePointer str,
    PyObject filename,
    int start);
@NoException public static native symtable Py_SymtableStringObject(
    String str,
    PyObject filename,
    int start);
// #endif

@NoException public static native void PyErr_Print();
@NoException public static native void PyErr_PrintEx(int arg0);
@NoException public static native void PyErr_Display(PyObject arg0, PyObject arg1, PyObject arg2);

// #ifndef Py_LIMITED_API
/* Use macros for a bunch of old variants */
// #define PyRun_String(str, s, g, l) PyRun_StringFlags(str, s, g, l, NULL)
// #define PyRun_AnyFile(fp, name) PyRun_AnyFileExFlags(fp, name, 0, NULL)
// #define PyRun_AnyFileEx(fp, name, closeit)
//     PyRun_AnyFileExFlags(fp, name, closeit, NULL)
// #define PyRun_AnyFileFlags(fp, name, flags)
//     PyRun_AnyFileExFlags(fp, name, 0, flags)
// #define PyRun_SimpleString(s) PyRun_SimpleStringFlags(s, NULL)
// #define PyRun_SimpleFile(f, p) PyRun_SimpleFileExFlags(f, p, 0, NULL)
// #define PyRun_SimpleFileEx(f, p, c) PyRun_SimpleFileExFlags(f, p, c, NULL)
// #define PyRun_InteractiveOne(f, p) PyRun_InteractiveOneFlags(f, p, NULL)
// #define PyRun_InteractiveLoop(f, p) PyRun_InteractiveLoopFlags(f, p, NULL)
// #define PyRun_File(fp, p, s, g, l)
//     PyRun_FileExFlags(fp, p, s, g, l, 0, NULL)
// #define PyRun_FileEx(fp, p, s, g, l, c)
//     PyRun_FileExFlags(fp, p, s, g, l, c, NULL)
// #define PyRun_FileFlags(fp, p, s, g, l, flags)
//     PyRun_FileExFlags(fp, p, s, g, l, 0, flags)
// #endif

/* Stuff with no proper home (yet) */
// #ifndef Py_LIMITED_API
@NoException public static native @Cast("char*") BytePointer PyOS_Readline(@Cast("FILE*") Pointer arg0, @Cast("FILE*") Pointer arg1, @Cast("const char*") BytePointer arg2);
@NoException public static native @Cast("char*") ByteBuffer PyOS_Readline(@Cast("FILE*") Pointer arg0, @Cast("FILE*") Pointer arg1, String arg2);
// #endif
public static class Int_PyOS_InputHook extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Int_PyOS_InputHook(Pointer p) { super(p); }
    protected Int_PyOS_InputHook() { allocate(); }
    private native void allocate();
    public native int call();
}
public static native Int_PyOS_InputHook PyOS_InputHook(); public static native void PyOS_InputHook(Int_PyOS_InputHook PyOS_InputHook);
public static class PyOS_ReadlineFunctionPointer_Pointer_Pointer_BytePointer extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    PyOS_ReadlineFunctionPointer_Pointer_Pointer_BytePointer(Pointer p) { super(p); }
    protected PyOS_ReadlineFunctionPointer_Pointer_Pointer_BytePointer() { allocate(); }
    private native void allocate();
    public native @Cast("char*") BytePointer call(@Cast("FILE*") Pointer arg0, @Cast("FILE*") Pointer arg1, @Cast("const char*") BytePointer arg2);
}
public static native PyOS_ReadlineFunctionPointer_Pointer_Pointer_BytePointer PyOS_ReadlineFunctionPointer(); public static native void PyOS_ReadlineFunctionPointer(PyOS_ReadlineFunctionPointer_Pointer_Pointer_BytePointer PyOS_ReadlineFunctionPointer);
// #ifndef Py_LIMITED_API
public static native PyThreadState _PyOS_ReadlineTState(); public static native void _PyOS_ReadlineTState(PyThreadState _PyOS_ReadlineTState);
// #endif

/* Stack size, in "pointers" (so we get extra safety margins
   on 64-bit platforms).  On a 32-bit platform, this translates
   to an 8k margin. */
public static final int PYOS_STACK_MARGIN = 2048;

// #if defined(WIN32) && !defined(MS_WIN64) && defined(_MSC_VER) && _MSC_VER >= 1300
/* Enable stack checking under Microsoft C */
// #define USE_STACKCHECK
// #endif

// #ifdef USE_STACKCHECK
// #endif

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYTHONRUN_H */


// Parsed from pylifecycle.h


/* Interfaces to configure, query, create & destroy the Python runtime */

// #ifndef Py_PYLIFECYCLE_H
// #define Py_PYLIFECYCLE_H
// #ifdef __cplusplus
// #endif

@NoException public static native void Py_SetProgramName(@Cast("wchar_t*") Pointer arg0);
@NoException public static native @Cast("wchar_t*") Pointer Py_GetProgramName();

@NoException public static native void Py_SetPythonHome(@Cast("wchar_t*") Pointer arg0);
@NoException public static native @Cast("wchar_t*") Pointer Py_GetPythonHome();

// #ifndef Py_LIMITED_API
/* Only used by applications that embed the interpreter and need to
 * override the standard encoding determination mechanism
 */
@NoException public static native int Py_SetStandardStreamEncoding(@Cast("const char*") BytePointer encoding,
                                             @Cast("const char*") BytePointer errors);
@NoException public static native int Py_SetStandardStreamEncoding(String encoding,
                                             String errors);
// #endif

@NoException public static native void Py_Initialize();
@NoException public static native void Py_InitializeEx(int arg0);
// #ifndef Py_LIMITED_API
@NoException public static native void _Py_InitializeEx_Private(int arg0, int arg1);
// #endif
@NoException public static native void Py_Finalize();
@NoException public static native int Py_FinalizeEx();
@NoException public static native int Py_IsInitialized();
@NoException public static native PyThreadState Py_NewInterpreter();
@NoException public static native void Py_EndInterpreter(PyThreadState arg0);


/* Py_PyAtExit is for the atexit module, Py_AtExit is for low-level
 * exit functions.
 */
// #ifndef Py_LIMITED_API
public static class Func extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    Func(Pointer p) { super(p); }
    protected Func() { allocate(); }
    private native void allocate();
    public native void call();
}
@NoException public static native void _Py_PyAtExit(Func func);
// #endif
@NoException public static native int Py_AtExit(Func func);

@NoException public static native void Py_Exit(int arg0);

/* Restore signals that the interpreter has called SIG_IGN on to SIG_DFL. */
// #ifndef Py_LIMITED_API
@NoException public static native void _Py_RestoreSignals();

@NoException public static native int Py_FdIsInteractive(@Cast("FILE*") Pointer arg0, @Cast("const char*") BytePointer arg1);
@NoException public static native int Py_FdIsInteractive(@Cast("FILE*") Pointer arg0, String arg1);
// #endif

/* Bootstrap __main__ (defined in Modules/main.c) */
@NoException public static native int Py_Main(int argc, @Cast("wchar_t**") PointerPointer argv);
@NoException public static native int Py_Main(int argc, @Cast("wchar_t**") @ByPtrPtr Pointer argv);

/* In getpath.c */
@NoException public static native @Cast("wchar_t*") Pointer Py_GetProgramFullPath();
@NoException public static native @Cast("wchar_t*") Pointer Py_GetPrefix();
@NoException public static native @Cast("wchar_t*") Pointer Py_GetExecPrefix();
@NoException public static native @Cast("wchar_t*") Pointer Py_GetPath();
@NoException public static native void Py_SetPath(@Cast("const wchar_t*") Pointer arg0);
// #ifdef MS_WINDOWS
// #endif

/* In their own files */
@NoException public static native @Cast("const char*") BytePointer Py_GetVersion();
@NoException public static native @Cast("const char*") BytePointer Py_GetPlatform();
@NoException public static native @Cast("const char*") BytePointer Py_GetCopyright();
@NoException public static native @Cast("const char*") BytePointer Py_GetCompiler();
@NoException public static native @Cast("const char*") BytePointer Py_GetBuildInfo();
// #ifndef Py_LIMITED_API
@NoException public static native @Cast("const char*") BytePointer _Py_gitidentifier();
@NoException public static native @Cast("const char*") BytePointer _Py_gitversion();
// #endif

/* Internal -- various one-time initializations */
// #ifndef Py_LIMITED_API
@NoException public static native PyObject _PyBuiltin_Init();
@NoException public static native PyObject _PySys_Init();
@NoException public static native void _PyImport_Init();
@NoException public static native void _PyExc_Init(PyObject bltinmod);
@NoException public static native void _PyImportHooks_Init();
@NoException public static native int _PyFrame_Init();
@NoException public static native int _PyFloat_Init();
@NoException public static native int PyByteArray_Init();
@NoException public static native void _PyRandom_Init();
// #endif

/* Various internal finalizers */
// #ifndef Py_LIMITED_API
@NoException public static native void _PyExc_Fini();
@NoException public static native void _PyImport_Fini();
@NoException public static native void PyMethod_Fini();
@NoException public static native void PyFrame_Fini();
@NoException public static native void PyCFunction_Fini();
@NoException public static native void PyDict_Fini();
@NoException public static native void PyTuple_Fini();
@NoException public static native void PyList_Fini();
@NoException public static native void PySet_Fini();
@NoException public static native void PyBytes_Fini();
@NoException public static native void PyByteArray_Fini();
@NoException public static native void PyFloat_Fini();
@NoException public static native void PyOS_FiniInterrupts();
@NoException public static native void _PyGC_DumpShutdownStats();
@NoException public static native void _PyGC_Fini();
@NoException public static native void PySlice_Fini();
@NoException public static native void _PyType_Fini();
@NoException public static native void _PyRandom_Fini();
@NoException public static native void PyAsyncGen_Fini();

public static native PyThreadState _Py_Finalizing(); public static native void _Py_Finalizing(PyThreadState _Py_Finalizing);
// #endif

/* Signals */
public static class PyOS_sighandler_t extends FunctionPointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public    PyOS_sighandler_t(Pointer p) { super(p); }
    protected PyOS_sighandler_t() { allocate(); }
    private native void allocate();
    public native void call(int arg0);
}
@NoException public static native PyOS_sighandler_t PyOS_getsig(int arg0);
@NoException public static native PyOS_sighandler_t PyOS_setsig(int arg0, PyOS_sighandler_t arg1);

// #ifndef Py_LIMITED_API
/* Random */
@NoException public static native int _PyOS_URandom(Pointer buffer, @Cast("Py_ssize_t") long size);
@NoException public static native int _PyOS_URandomNonblock(Pointer buffer, @Cast("Py_ssize_t") long size);
// #endif /* !Py_LIMITED_API */

// #ifdef __cplusplus
// #endif
// #endif /* !Py_PYLIFECYCLE_H */


// Parsed from fileutils.h

// #ifndef Py_FILEUTILS_H
// #define Py_FILEUTILS_H

// #ifdef __cplusplus
// #endif

// #if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
@NoException public static native @Cast("wchar_t*") Pointer Py_DecodeLocale(
    @Cast("const char*") BytePointer arg,
    @Cast("size_t*") SizeTPointer size);
@NoException public static native @Cast("wchar_t*") Pointer Py_DecodeLocale(
    String arg,
    @Cast("size_t*") SizeTPointer size);

@NoException public static native @Cast("char*") BytePointer Py_EncodeLocale(
    @Cast("const wchar_t*") Pointer text,
    @Cast("size_t*") SizeTPointer error_pos);
// #endif

// #ifndef Py_LIMITED_API

@NoException public static native @Cast("wchar_t*") Pointer _Py_DecodeLocaleEx(
    @Cast("const char*") BytePointer arg,
    @Cast("size_t*") SizeTPointer size,
    int current_locale);
@NoException public static native @Cast("wchar_t*") Pointer _Py_DecodeLocaleEx(
    String arg,
    @Cast("size_t*") SizeTPointer size,
    int current_locale);

@NoException public static native @Cast("char*") BytePointer _Py_EncodeLocaleEx(
    @Cast("const wchar_t*") Pointer text,
    @Cast("size_t*") SizeTPointer error_pos,
    int current_locale);

@NoException public static native PyObject _Py_device_encoding(int arg0);

// #ifdef MS_WINDOWS
// #else
// #endif

@NoException public static native int _Py_fstat(
    int fd,
    @Cast("struct _Py_stat_struct*") Pointer status);

@NoException public static native int _Py_fstat_noraise(
    int fd,
    @Cast("struct _Py_stat_struct*") Pointer status);

@NoException public static native int _Py_stat(
    PyObject path,
    @Cast("struct stat*") Pointer status);

@NoException public static native int _Py_open(
    @Cast("const char*") BytePointer pathname,
    int flags);
@NoException public static native int _Py_open(
    String pathname,
    int flags);

@NoException public static native int _Py_open_noraise(
    @Cast("const char*") BytePointer pathname,
    int flags);
@NoException public static native int _Py_open_noraise(
    String pathname,
    int flags);

@NoException public static native @Cast("FILE*") Pointer _Py_wfopen(
    @Cast("const wchar_t*") Pointer path,
    @Cast("const wchar_t*") Pointer mode);

@NoException public static native @Cast("FILE*") Pointer _Py_fopen(
    @Cast("const char*") BytePointer pathname,
    @Cast("const char*") BytePointer mode);
@NoException public static native @Cast("FILE*") Pointer _Py_fopen(
    String pathname,
    String mode);

@NoException public static native @Cast("FILE*") Pointer _Py_fopen_obj(
    PyObject path,
    @Cast("const char*") BytePointer mode);
@NoException public static native @Cast("FILE*") Pointer _Py_fopen_obj(
    PyObject path,
    String mode);

@NoException public static native @Cast("Py_ssize_t") long _Py_read(
    int fd,
    Pointer buf,
    @Cast("size_t") long count);

@NoException public static native @Cast("Py_ssize_t") long _Py_write(
    int fd,
    @Const Pointer buf,
    @Cast("size_t") long count);

@NoException public static native @Cast("Py_ssize_t") long _Py_write_noraise(
    int fd,
    @Const Pointer buf,
    @Cast("size_t") long count);

// #ifdef HAVE_READLINK

// #endif

// #ifdef HAVE_REALPATH

// #endif

@NoException public static native @Cast("wchar_t*") Pointer _Py_wgetcwd(
    @Cast("wchar_t*") Pointer buf,
    @Cast("size_t") long size);

@NoException public static native int _Py_get_inheritable(int fd);

@NoException public static native int _Py_set_inheritable(int fd, int inheritable,
                                    IntPointer atomic_flag_works);
@NoException public static native int _Py_set_inheritable(int fd, int inheritable,
                                    IntBuffer atomic_flag_works);
@NoException public static native int _Py_set_inheritable(int fd, int inheritable,
                                    int[] atomic_flag_works);

@NoException public static native int _Py_set_inheritable_async_safe(int fd, int inheritable,
                                               IntPointer atomic_flag_works);
@NoException public static native int _Py_set_inheritable_async_safe(int fd, int inheritable,
                                               IntBuffer atomic_flag_works);
@NoException public static native int _Py_set_inheritable_async_safe(int fd, int inheritable,
                                               int[] atomic_flag_works);

@NoException public static native int _Py_dup(int fd);

// #ifndef MS_WINDOWS



// #endif   /* !MS_WINDOWS */

@NoException public static native int _Py_GetLocaleconvNumeric(
    @Cast("PyObject**") PointerPointer decimal_point,
    @Cast("PyObject**") PointerPointer thousands_sep,
    @Cast("const char**") PointerPointer grouping);
@NoException public static native int _Py_GetLocaleconvNumeric(
    @ByPtrPtr PyObject decimal_point,
    @ByPtrPtr PyObject thousands_sep,
    @Cast("const char**") @ByPtrPtr BytePointer grouping);
@NoException public static native int _Py_GetLocaleconvNumeric(
    @ByPtrPtr PyObject decimal_point,
    @ByPtrPtr PyObject thousands_sep,
    @Cast("const char**") @ByPtrPtr ByteBuffer grouping);
@NoException public static native int _Py_GetLocaleconvNumeric(
    @ByPtrPtr PyObject decimal_point,
    @ByPtrPtr PyObject thousands_sep,
    @Cast("const char**") @ByPtrPtr byte[] grouping);

// #endif   /* Py_LIMITED_API */

// #ifdef __cplusplus
// #endif

// #endif /* !Py_FILEUTILS_H */


}
